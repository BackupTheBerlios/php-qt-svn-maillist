From Katrina.Niolet at mail.berlios.de  Fri Jun  1 01:05:43 2007
From: Katrina.Niolet at mail.berlios.de (Katrina.Niolet at mail.berlios.de)
Date: Fri, 1 Jun 2007 01:05:43 +0200
Subject: [Php-qt-svn] r325 - in trunk: php_qt tests
Message-ID: <200705312305.l4VN5h72004036@sheep.berlios.de>

Author: Katrina Niolet
Date: 2007-06-01 01:05:40 +0200 (Fri, 01 Jun 2007)
New Revision: 325

Modified:
   trunk/php_qt/functions.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/tests/qFunctions.php
Log:
Added support for the following Qt namespace functions
qt_noop,qt_assert,qt_assert_x,Q_ASSERT,Q_ASSERT_X,qt_check_pointer and updated tests/qFunctions.php appropriately

Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-05-31 05:37:32 UTC (rev 324)
+++ trunk/php_qt/functions.cpp	2007-05-31 23:05:40 UTC (rev 325)
@@ -510,15 +510,84 @@
 	if(src_orig_type==IS_STRING || dest_orig_type==IS_STRING)
 		RETURN_TRUE;
 	if(src_orig_type==IS_DOUBLE || dest_orig_type==IS_DOUBLE) {
-		convert_to_double(dest);
 		RETURN_TRUE;
 	}
-	if(src_orig_type==IS_LONG || dest_orig_type==IS_LONG) {
+	if(src_orig_type==IS_LONG && dest_orig_type==IS_LONG) {
 		convert_to_long(dest);
 		RETURN_TRUE;
 	}
 }
 
+PHP_FUNCTION(qt_noop) {}
+
+PHP_FUNCTION(qt_assert) {
+	
+	char* msg;
+	int msglen;
+	char* file;
+	int filelen;
+	int line;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s|sl",&msg,&msglen,&file,&filelen,&line)==FAILURE)
+		return;
+	php_error(E_ERROR,msg);
+}
+
+PHP_FUNCTION(qt_assert_x) {
+	
+	char* msg;
+	int msglen;
+	char* file;
+	int filelen;
+	char* where;
+	int wherelen;
+	char* what;
+	int whatlen;
+	int line;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s|sssl",&msg,&msglen,&where,&wherelen,&what,&whatlen,&file,&filelen,&line)==FAILURE)
+		return;
+	php_error(E_ERROR,msg);
+}
+
+
+PHP_FUNCTION(Q_ASSERT) {
+	
+	bool cond;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"b",&cond)==FAILURE)
+		return;
+	if(!cond)
+		php_error(E_ERROR,"Assertion failed");
+}
+
+PHP_FUNCTION(Q_ASSERT_X) {
+	
+	bool cond;
+	char* where="";
+	int wherelen;
+	char* what="";
+	int whatlen;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"b|ss",&cond,&where,&wherelen,&what,&whatlen)==FAILURE) {
+		return;
+	}
+	if(!cond) {
+		php_error(E_ERROR,"Assertion failed: %s, %s",what,where);
+	}
+}
+
+PHP_FUNCTION(qt_check_pointer) {
+
+	char* file;
+	int line;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"|sl",&file,&line)==FAILURE)
+		return;
+	php_error(E_WARNING,"Out of memory");
+}
+		
+	
 /*!
  *	tr() returns QObject::tr()
  *

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-05-31 05:37:32 UTC (rev 324)
+++ trunk/php_qt/php_qt.cpp	2007-05-31 23:05:40 UTC (rev 325)
@@ -93,6 +93,12 @@
 	PHP_FE(qFree,		NULL)
 	PHP_FE(qRealloc,	NULL)
 	PHP_FE(qMemCopy,	NULL)
+	PHP_FE(qt_noop,		NULL)
+	PHP_FE(qt_assert,	NULL)
+	PHP_FE(qt_assert_x,	NULL)
+	PHP_FE(Q_ASSERT,	NULL)
+	PHP_FE(Q_ASSERT_X,	NULL)
+	PHP_FE(qt_check_pointer,	NULL)
 	PHP_FE(qobject_cast,	phpqt_cast_arginfo)
 	PHP_FE(tr,	NULL)
 	PHP_FE(check_qobject,	NULL)

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-05-31 05:37:32 UTC (rev 324)
+++ trunk/php_qt/php_qt.h	2007-05-31 23:05:40 UTC (rev 325)
@@ -118,6 +118,12 @@
 PHP_FUNCTION(qFree);
 PHP_FUNCTION(qRealloc);
 PHP_FUNCTION(qMemCopy);
+PHP_FUNCTION(qt_noop);
+PHP_FUNCTION(qt_assert);
+PHP_FUNCTION(qt_assert_x);
+PHP_FUNCTION(Q_ASSERT);
+PHP_FUNCTION(Q_ASSERT_X);
+PHP_FUNCTION(qt_check_pointer);
 PHP_FUNCTION(qobject_cast);
 PHP_FUNCTION(tr);
 PHP_FUNCTION(check_qobject);

Modified: trunk/tests/qFunctions.php
===================================================================
--- trunk/tests/qFunctions.php	2007-05-31 05:37:32 UTC (rev 324)
+++ trunk/tests/qFunctions.php	2007-05-31 23:05:40 UTC (rev 325)
@@ -97,8 +97,27 @@
 qMemCopy($b,$a,2);
 echo $b."\n";
 
+echo "\nTesting qt_noop:";
+qt_noop();
+echo "done\n";
 
-/*echo "\nTesting qDebug:\n";
+echo "\nTesting Q_ASSERT:\n";
+echo "Q_ASSERT(5==5): ";
+Q_ASSERT(5==5);
+echo "done\n";
+//echo "Q_ASSERT(6==5): ";
+//Q_ASSERT(6==5);
+//echo "done\n";
+
+echo "\nTesting Q_ASSERT_X:\n";
+echo "Q_ASSERT(5==5,'in our test file', 'oh no! it failed!'): ";
+Q_ASSERT_X(5==5,'in our test file','oh no! it failed!');
+echo "done\n";
+//echo "Q_ASSERT(6==5,'in our test file', 'oh no! it worked!'): ";
+//Q_ASSERT_X(6==5,'in our test file','oh no! it worked!');
+//echo "done\n";
+
+echo "\nTesting qDebug:\n";
 qDebug("This is a debug message");
 
 echo "Testing qWarning:\n";
@@ -106,5 +125,7 @@
 
 echo "Testing qCritical:\n";
 qCritical("This is a fatal error");
- */
+
+echo "We shouldn't see this\n";
+
 ?>



From tm243 at mail.berlios.de  Sat Jun  2 23:22:43 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Sat, 2 Jun 2007 23:22:43 +0200
Subject: [Php-qt-svn] r326 - trunk/php_qt
Message-ID: <200706022122.l52LMhdC004789@sheep.berlios.de>

Author: tm243
Date: 2007-06-02 23:22:42 +0200 (Sat, 02 Jun 2007)
New Revision: 326

Modified:
   trunk/php_qt/handlers.cpp
   trunk/php_qt/marshall.h
   trunk/php_qt/marshall_basetypes.h
   trunk/php_qt/marshall_primitives.h
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/marshall_types.h
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/smokephp.cpp
Log:
* more work on virtual method calls



Modified: trunk/php_qt/handlers.cpp
===================================================================
--- trunk/php_qt/handlers.cpp	2007-05-31 23:05:40 UTC (rev 325)
+++ trunk/php_qt/handlers.cpp	2007-06-02 21:22:42 UTC (rev 326)
@@ -218,7 +218,6 @@
 	if (KCODE == 0) {
 		init_codec();
 	}
-
 	if (qstrcmp(KCODE, "UTF8") == 0)
 		return new QString(QString::fromUtf8(zstring->value.str.val, zstring->value.str.len));
 	else if (qstrcmp(KCODE, "EUC") == 0)

Modified: trunk/php_qt/marshall.h
===================================================================
--- trunk/php_qt/marshall.h	2007-05-31 23:05:40 UTC (rev 325)
+++ trunk/php_qt/marshall.h	2007-06-02 21:22:42 UTC (rev 326)
@@ -43,6 +43,11 @@
 
     virtual ~Marshall() {}
 
+	/** returns a pointer to the return value pointer, we need that for
+	 *	overriding the return value defined by ZEND
+	 */
+	virtual zval** return_value_ptr() = 0;
+
 	const char* identifier;
 
 };

Modified: trunk/php_qt/marshall_basetypes.h
===================================================================
--- trunk/php_qt/marshall_basetypes.h	2007-05-31 23:05:40 UTC (rev 325)
+++ trunk/php_qt/marshall_basetypes.h	2007-06-02 21:22:42 UTC (rev 326)
@@ -119,7 +119,7 @@
 		o->classId,			// from
 		o->smoke->idClass(cl.className)	// to
 		);
-	
+
 	m->item().s_class = ptr;
 
 	return;
@@ -137,13 +137,14 @@
 
 	// return the original
 	if(phpqt_SmokePHPObjectExists(p)) {
-		if(((MethodReturnValue*) m)->retval_ptr()){
+		if(m->return_value_ptr()){
 			// destroys the return_value initialized by ZE, we creare our own:
-			zval_ptr_dtor(((MethodReturnValue*) m)->retval_ptr());
+			zval_ptr_dtor(m->return_value_ptr());
 			// prepare the return value
 			smokephp_object* o = phpqt_createOriginal(m->var(), p);
 			// overwrite the old one:
-			*(((MethodReturnValue*) m)->retval_ptr()) = o->zval_ptr;
+			*(m->return_value_ptr()) = o->zval_ptr;
+			*(m->var()) = *o->zval_ptr;
 		}
 		return;
 

Modified: trunk/php_qt/marshall_primitives.h
===================================================================
--- trunk/php_qt/marshall_primitives.h	2007-05-31 23:05:40 UTC (rev 325)
+++ trunk/php_qt/marshall_primitives.h	2007-06-02 21:22:42 UTC (rev 326)
@@ -7,6 +7,8 @@
  *                                                                         *
  ***************************************************************************/
 
+// TODO catch more types, see php_to_primitive<long>
+
 template <>
 static bool php_to_primitive<bool>(zval* v)
 {

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-05-31 23:05:40 UTC (rev 325)
+++ trunk/php_qt/marshall_types.cpp	2007-06-02 21:22:42 UTC (rev 326)
@@ -200,8 +200,8 @@
  *	MethodReturnValueBase
  */
 
-MethodReturnValueBase::MethodReturnValueBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack) :
-	_smoke(smoke), _method(meth), _stack(stack)
+MethodReturnValueBase::MethodReturnValueBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval** return_value_ptr) :
+	_smoke(smoke), _method(meth), _stack(stack), _return_value_ptr(return_value_ptr)
 {
 	identifier = "MethodReturnValueBase";
 	_st.set(_smoke, method().ret);
@@ -267,12 +267,18 @@
 	return _smoke->className(method().classId); 
 }
 
+zval**
+MethodReturnValueBase::return_value_ptr()
+{
+	return _return_value_ptr;
+}
+
 /**
  *	VirtualMethodReturnValue
  */
 
 VirtualMethodReturnValue::VirtualMethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval retval) :
-	MethodReturnValueBase(smoke,meth,stack), _retval2(retval) 
+	MethodReturnValueBase(smoke,meth,stack,NULL), _retval2(retval) 
 {
 	identifier = "VirtualMethodReturnValue";
 	_retval = &_retval2;
@@ -291,7 +297,7 @@
  */
 
 MethodReturnValue::MethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* retval, zval** return_value_ptr) :
-	MethodReturnValueBase(smoke,meth,stack), _return_value_ptr(return_value_ptr)
+	MethodReturnValueBase(smoke,meth,stack,return_value_ptr)/*, _return_value_ptr(return_value_ptr)*/
 {
 	identifier = "MethodReturnValue";
 	_retval = retval;
@@ -311,20 +317,17 @@
 	return qstrcmp(MethodReturnValueBase::classname(), "QGlobalSpace") == 0 ? "" : MethodReturnValueBase::classname(); 
 }
 
-zval**
-MethodReturnValue::retval_ptr(){ return _return_value_ptr; }
-
 /**
  *	MethodCallBase
  */
 
-MethodCallBase::MethodCallBase(Smoke *smoke, Smoke::Index meth) :
-	_smoke(smoke), _method(meth), _cur(-1), _called(false), _sp(0)  
+MethodCallBase::MethodCallBase(Smoke *smoke, Smoke::Index meth,zval** return_value_ptr) :
+	_smoke(smoke), _method(meth), _cur(-1), _called(false), _sp(0), _return_value_ptr(return_value_ptr)
 {  
 }
 
-MethodCallBase::MethodCallBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack) :
-	_smoke(smoke), _method(meth), _stack(stack), _cur(-1), _called(false), _sp(0) 
+MethodCallBase::MethodCallBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack,zval** return_value_ptr) :
+	_smoke(smoke), _method(meth), _stack(stack), _cur(-1), _called(false), _sp(0), _return_value_ptr(return_value_ptr)
 {  
 }
 
@@ -382,15 +385,21 @@
 	return _smoke->className(method().classId); 
 }
 
+zval**
+MethodCallBase::return_value_ptr()
+{
+	return _return_value_ptr;
+}
+
 /**
  *	VirtualMethodCall
  */
 
-VirtualMethodCall::VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* obj, zval ***sp) :
-	MethodCallBase(smoke,meth,stack), _obj(obj)
+VirtualMethodCall::VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* obj, zval **sp, zval** return_value_ptr) :
+	MethodCallBase( smoke, meth, stack, return_value_ptr), _obj(obj)/*, _sp(sp)*/
 {
+	__sp = sp;
 	identifier = "VirtualMethodCall";
- 	_sp = sp;
   	_args = _smoke->argumentList + method().args;
 }
 
@@ -408,8 +417,9 @@
 zval*
 VirtualMethodCall::var() 
 {
-	*_sp[_cur] = (zval*) emalloc(sizeof(zval));
-    return (zval*) *_sp[_cur];
+// 	*_sp[_cur] = (zval*) emalloc(sizeof(zval));
+	ZVAL_NULL(__sp[_cur]);
+    return __sp[_cur];
 }
 
 int 
@@ -424,7 +434,7 @@
 	if (_called) return;
 	_called = true;
 
-	phpqt_callPHPMethod(_obj, (char*) _smoke->methodNames[method().name], items(), _sp);
+	phpqt_callPHPMethod(_obj, (char*) _smoke->methodNames[method().name], items(), __sp);
 
 	zval _retval;
  	VirtualMethodReturnValue r(_smoke, _method, _stack, _retval);
@@ -441,7 +451,7 @@
  */
 
 MethodCall::MethodCall(Smoke *smoke, Smoke::Index method, zval* target, zval ***sp, int items, zval *retval, zval** return_value_ptr) :
-	MethodCallBase(smoke,method), _target(target), _current_object(0), _sp(sp), _items(items), _retval(retval), _return_value_ptr(return_value_ptr)
+ 	MethodCallBase(smoke,method,return_value_ptr), _target(target), _current_object(0), _sp(sp), _items(items), _retval(retval)
 {
 
 	identifier = "MethodCall";
@@ -460,6 +470,7 @@
 
     _args = _smoke->argumentList + _smoke->methods[_method].args;
     _items = _smoke->methods[_method].numArgs;
+
     _stack = new Smoke::StackItem[items + 1];
 // 	_retval = retval;
 }
@@ -618,6 +629,9 @@
 	~SlotReturnValue() {
 		delete[] _stack;
 	}
+
+	zval** return_value_ptr(){};
+
 };
 
 /**
@@ -668,7 +682,7 @@
 {
 	if (_called) return;
 	_called = true;
-	zval* result = phpqt_callPHPMethod(_obj, (char*) PQ::smoke()->methodNames[PQ::smoke()->methods[_slotname].name], _items - 1, _sp);
+ 	zval* result = phpqt_callPHPMethod(_obj, (char*) PQ::smoke()->methodNames[PQ::smoke()->methods[_slotname].name], _items - 1, *_sp);
 	if (_args[0].argType != xmoc_void) {
 		SlotReturnValue r(_o, result, _args);
 	}

Modified: trunk/php_qt/marshall_types.h
===================================================================
--- trunk/php_qt/marshall_types.h	2007-05-31 23:05:40 UTC (rev 325)
+++ trunk/php_qt/marshall_types.h	2007-06-02 21:22:42 UTC (rev 326)
@@ -41,7 +41,7 @@
 class MethodReturnValueBase : public Marshall 
 {
 public:
-	MethodReturnValueBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack);
+	MethodReturnValueBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval** return_value_ptr);
 	const Smoke::Method &method();
 	Smoke::StackItem &item();
 	Smoke *smoke();
@@ -51,6 +51,7 @@
 	void unsupported();
 	zval* var();
 	void setVar(zval* zobj);
+	zval** return_value_ptr();
 
 protected:
 	Smoke *_smoke;
@@ -58,6 +59,7 @@
 	Smoke::Stack _stack;
 	SmokeType _st;
 	zval* _retval;
+	zval **_return_value_ptr;
 
 	virtual const char *classname();
 };
@@ -83,10 +85,8 @@
 public:
 	MethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval *retval, zval** return_value_ptr);
     Marshall::Action action();
-	zval** retval_ptr();
 
 private:
-	zval **_return_value_ptr;
 	const char *classname();
 };
 
@@ -97,8 +97,8 @@
 class MethodCallBase : public Marshall
 {
 public:
-	MethodCallBase(Smoke *smoke, Smoke::Index meth);
-	MethodCallBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack);
+	MethodCallBase(Smoke *smoke, Smoke::Index meth,zval** return_value_ptr);
+	MethodCallBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval** return_value_ptr);
 	Smoke *smoke();
 	SmokeType type();
 	Smoke::StackItem &item();
@@ -107,6 +107,7 @@
 	virtual void callMethod() = 0;	
 	void next();
 	void unsupported();
+	zval** return_value_ptr();
 
 protected:
 	Smoke *_smoke;
@@ -117,6 +118,8 @@
 	bool _called;
 	zval ***_sp;
 	virtual const char* classname();
+	zval** _return_value_ptr;
+
 };
 
 /**
@@ -125,7 +128,7 @@
 
 class VirtualMethodCall : public MethodCallBase {
 public:
-	VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* obj, zval ***sp);
+	VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* obj, zval **sp, zval** return_value_ptr);
 	~VirtualMethodCall();
 	Marshall::Action action();
 	zval* var();
@@ -135,7 +138,8 @@
  
 private:
 	zval* _obj;
-	zval ***_sp;
+ 	zval **__sp;
+
 };
 
 /**
@@ -169,6 +173,7 @@
 		Smoke::ClassFn fn = _smoke->classes[method().classId].classFn;
 		void *ptr = _smoke->cast(_current_object, _current_object_class, method().classId);
 		_items = -1;
+
 		(*fn)(method().method, ptr, _stack);
 		MethodReturnValue r(_smoke, _method, _stack, _retval, _return_value_ptr);
 	}
@@ -183,7 +188,6 @@
 	zval ***_sp;
 	int _items;
 	zval *_retval;
-	zval **_return_value_ptr;
 
 	const char *classname();
 };
@@ -235,6 +239,8 @@
 	void unsupported();
 	Smoke* smoke();
 	const MocArgument &arg();
+	zval** return_value_ptr(){};
+
  protected:
 	MocArgument *_args;
 	int _cur;

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-05-31 23:05:40 UTC (rev 325)
+++ trunk/php_qt/php_qt.cpp	2007-06-02 21:22:42 UTC (rev 326)
@@ -200,7 +200,7 @@
  *	proxy handler
  */
 
-union _zend_function *proxyHandler(zval **obj_ptr, char* methodName, int methodName_len TSRMLS_DC)
+union _zend_function* proxyHandler(zval **obj_ptr, char* methodName, int methodName_len TSRMLS_DC)
 {
     union _zend_function *fbc;
 
@@ -294,7 +294,7 @@
     zend_class_entry *ce_parent = Z_OBJCE_P(getThis());
 
     while (PQ::smoke()->idClass(ce->name) <= 0) {
-	    ce_parent = ce->parent;
+// 	    ce_parent = ce->parent;
 	    ce = ce->parent; // orig
     }
 
@@ -704,7 +704,7 @@
     cout << "\tcall PHP method " << so->ce_ptr->name << "::" << method_name << endl;
 #endif
 
-        phpqt_callPHPMethod(so->zval_ptr, method_name, j, args);
+         phpqt_callPHPMethod(so->zval_ptr, method_name, j, *args);
 
     // is a signal
     } else {
@@ -744,8 +744,9 @@
 
 }
 
+
 zval* 
-phpqt_callPHPMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args[])
+phpqt_callPHPMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args)
 {
 
 	if(this_ptr == NULL){
@@ -759,7 +760,7 @@
     zval* retval;
     MAKE_STD_ZVAL(retval);
 
-    if(call_user_function(EG(function_table),&this_ptr,function_name,retval,param_count,*args) == FAILURE){
+    if(call_user_function(EG(function_table),&this_ptr,function_name,retval,param_count,args) == FAILURE){
     	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
     	php_error(E_ERROR, "PHP-Qt could not call method %s::%s", o->ce_ptr->name, methodName);
     }
@@ -1000,6 +1001,7 @@
 // 		zval_ptr->is_ref = 1;
 		Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
 		zval_x_smokephp.insert(zval_ptr, o);*/
+	Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
 	zval_ptr = o->zval_ptr;
 	zval_add_ref(&zval_ptr);
 	return o;

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-05-31 23:05:40 UTC (rev 325)
+++ trunk/php_qt/php_qt.h	2007-06-02 21:22:42 UTC (rev 326)
@@ -147,7 +147,7 @@
 static void 			phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc);
 
 // void 				phpqt_register(zval* this_ptr, zend_rsrc_list_entry le);
-zval* 				phpqt_callPHPMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params[]);
+zval* 				phpqt_callPHPMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params);
 bool 				phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname);
 bool 				phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* metachar, QString* meta_stringdata, uint* signature);
 int					phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-05-31 23:05:40 UTC (rev 325)
+++ trunk/php_qt/smokephp.cpp	2007-06-02 21:22:42 UTC (rev 326)
@@ -28,6 +28,8 @@
 #include <QtCore/QCoreApplication>
 #include <QtGui/QApplication>
 
+#define ALLOCA_N(type,n) (type*)alloca(sizeof(type)*(n))
+
 extern void init_qt_Smoke();
 extern zend_class_entry* qstring_ce;
 
@@ -80,13 +82,9 @@
 		}
 
 		if(phpqt_methodExists(o->ce_ptr, (char*) methodName)){
-		    Smoke::Method & meth = smoke->methods[method];
-		    zval*** sp = (zval ***) safe_emalloc((int) meth.numArgs, sizeof(zval), 0);
-
-		    VirtualMethodCall c(smoke, method, args, o->zval_ptr, sp);
+			zval* zmem = ALLOCA_N(zval, smoke->methods[method].numArgs);
+		    VirtualMethodCall c(smoke, method, args, o->zval_ptr, &zmem, &o->zval_ptr);
 		    c.next();
-
-  		    efree(sp);
 		}
 		
 		return false;



From tm243 at mail.berlios.de  Sun Jun  3 12:01:16 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Sun, 3 Jun 2007 12:01:16 +0200
Subject: [Php-qt-svn] r327 - trunk/php_qt
Message-ID: <200706031001.l53A1Gb0015304@sheep.berlios.de>

Author: tm243
Date: 2007-06-03 12:01:16 +0200 (Sun, 03 Jun 2007)
New Revision: 327

Modified:
   trunk/php_qt/marshall_basetypes.h
Log:
* storing value in m->var() commented out temporary



Modified: trunk/php_qt/marshall_basetypes.h
===================================================================
--- trunk/php_qt/marshall_basetypes.h	2007-06-02 21:22:42 UTC (rev 326)
+++ trunk/php_qt/marshall_basetypes.h	2007-06-03 10:01:16 UTC (rev 327)
@@ -144,7 +144,7 @@
 			smokephp_object* o = phpqt_createOriginal(m->var(), p);
 			// overwrite the old one:
 			*(m->return_value_ptr()) = o->zval_ptr;
-			*(m->var()) = *o->zval_ptr;
+// 			*(m->var()) = *o->zval_ptr;
 		}
 		return;
 



From tm243 at mail.berlios.de  Wed Jun  6 15:07:09 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 6 Jun 2007 15:07:09 +0200
Subject: [Php-qt-svn] r328 - in trunk: examples/calculator php_qt smoke tests
Message-ID: <200706061307.l56D79IY009079@sheep.berlios.de>

Author: tm243
Date: 2007-06-06 15:07:07 +0200 (Wed, 06 Jun 2007)
New Revision: 328

Modified:
   trunk/examples/calculator/calculator.php
   trunk/php_qt/marshall_basetypes.h
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/marshall_types.h
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/smokephp.cpp
   trunk/smoke/smoke.h
   trunk/tests/QtBasicTestCase.php
Log:
* added a statixProxyMethod handler, static methods are not picked up anymore in a loop at module init
* made sure that one is allowed to call parent::blablub() within both static and normal methods in a class
* some minor improvements on the marshall system



Modified: trunk/examples/calculator/calculator.php
===================================================================
--- trunk/examples/calculator/calculator.php	2007-06-03 10:01:16 UTC (rev 327)
+++ trunk/examples/calculator/calculator.php	2007-06-06 13:07:07 UTC (rev 328)
@@ -170,7 +170,7 @@
                     return true;
                 }
             }
-            return QDialog::eventFilter($target, $event);
+            return parent::eventFilter($target, $event);
         }
 
         function digitClicked()

Modified: trunk/php_qt/marshall_basetypes.h
===================================================================
--- trunk/php_qt/marshall_basetypes.h	2007-06-03 10:01:16 UTC (rev 327)
+++ trunk/php_qt/marshall_basetypes.h	2007-06-06 13:07:07 UTC (rev 328)
@@ -29,8 +29,8 @@
 template <class T> T php_to_primitive(zval*);
 template <class T> zval* primitive_to_php(T, zval* return_value);
 
-template <class T> 
-static void marshall_from_php(Marshall *m) 
+template <class T>
+static void marshall_from_php(Marshall *m)
 {
 	zval* zobj = m->var();
 	(*smoke_ptr<T>(m)) = php_to_primitive<T>(zobj);
@@ -47,8 +47,8 @@
 
 // Special case marshallers
 
-template <> 
-static void marshall_from_php<char *>(Marshall *m) 
+template <>
+static void marshall_from_php<char *>(Marshall *m)
 {
 	zval* zobj = m->var();
 	m->item().s_voidp = php_to_primitive<char*>(zobj);
@@ -130,7 +130,7 @@
 {
 	if(m->item().s_voidp == 0) {
 		qWarning("Qt Object doesnt exist!");
-		*(m->var()) = *(Qnil);
+		ZVAL_NULL(m->var());
 		return;
 	}
 	void *p = m->item().s_voidp;
@@ -138,7 +138,7 @@
 	// return the original
 	if(phpqt_SmokePHPObjectExists(p)) {
 		if(m->return_value_ptr()){
-			// destroys the return_value initialized by ZE, we creare our own:
+			// destroys the return_value initialized by ZE, we create our own:
 			zval_ptr_dtor(m->return_value_ptr());
 			// prepare the return value
 			smokephp_object* o = phpqt_createOriginal(m->var(), p);
@@ -175,7 +175,7 @@
 		smokephp_object *o = phpqt_createObject(m->var(), __p, _ce, m->type().classId());
 
 //	    if(m->type().isConst() && m->type().isRef()) {
-	    if(m->type().isRef()) 
+	    if(m->type().isRef())
 	    {
 			p = construct_copy( o );
 #ifdef DEBUG

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-06-03 10:01:16 UTC (rev 327)
+++ trunk/php_qt/marshall_types.cpp	2007-06-06 13:07:07 UTC (rev 328)
@@ -208,50 +208,50 @@
 }
 
 const Smoke::Method&
-MethodReturnValueBase::method() 
-{ 
-	return _smoke->methods[_method]; 
+MethodReturnValueBase::method()
+{
+	return _smoke->methods[_method];
 }
 
 Smoke::StackItem&
-MethodReturnValueBase::item() 
+MethodReturnValueBase::item()
 {
 	return _stack[0];
 }
 
 Smoke *
-MethodReturnValueBase::smoke() 
-{ 
-	return _smoke; 
+MethodReturnValueBase::smoke()
+{
+	return _smoke;
 }
 
-SmokeType 
-MethodReturnValueBase::type() 
-{ 
-	return _st; 
+SmokeType
+MethodReturnValueBase::type()
+{
+	return _st;
 }
 
-void 
+void
 MethodReturnValueBase::next() {}
 
-bool 
-MethodReturnValueBase::cleanup() 
-{ 
-	return false; 
+bool
+MethodReturnValueBase::cleanup()
+{
+	return false;
 }
 
-void 
-MethodReturnValueBase::unsupported() 
+void
+MethodReturnValueBase::unsupported()
 {
 	php_error(E_ERROR, "Cannot handle '%s' as return-type of %s::%s",
 	type().name(),
 	classname(),
-	_smoke->methodNames[method().name]);	
+	_smoke->methodNames[method().name]);
 }
 
-zval* 
-MethodReturnValueBase::var() 
-{ 
+zval*
+MethodReturnValueBase::var()
+{
 	return _retval;
 }
 
@@ -262,9 +262,9 @@
 }
 
 const char *
-MethodReturnValueBase::classname() 
-{ 
-	return _smoke->className(method().classId); 
+MethodReturnValueBase::classname()
+{
+	return _smoke->className(method().classId);
 }
 
 zval**
@@ -278,7 +278,7 @@
  */
 
 VirtualMethodReturnValue::VirtualMethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval retval) :
-	MethodReturnValueBase(smoke,meth,stack,NULL), _retval2(retval) 
+	MethodReturnValueBase(smoke,meth,stack,NULL), _retval2(retval)
 {
 	identifier = "VirtualMethodReturnValue";
 	_retval = &_retval2;
@@ -286,10 +286,10 @@
 	(*fn)(this);
 }
 
-Marshall::Action 
-VirtualMethodReturnValue::action() 
-{ 
-	return Marshall::FromZVAL; 
+Marshall::Action
+VirtualMethodReturnValue::action()
+{
+	return Marshall::FromZVAL;
 }
 
 /**
@@ -305,16 +305,16 @@
 	(*fn)(this);
 }
 
-Marshall::Action 
-MethodReturnValue::action() 
-{ 
-	return Marshall::ToZVAL; 
+Marshall::Action
+MethodReturnValue::action()
+{
+	return Marshall::ToZVAL;
 }
 
 const char *
-MethodReturnValue::classname() 
-{ 
-	return qstrcmp(MethodReturnValueBase::classname(), "QGlobalSpace") == 0 ? "" : MethodReturnValueBase::classname(); 
+MethodReturnValue::classname()
+{
+	return qstrcmp(MethodReturnValueBase::classname(), "QGlobalSpace") == 0 ? "" : MethodReturnValueBase::classname();
 }
 
 /**
@@ -323,40 +323,40 @@
 
 MethodCallBase::MethodCallBase(Smoke *smoke, Smoke::Index meth,zval** return_value_ptr) :
 	_smoke(smoke), _method(meth), _cur(-1), _called(false), _sp(0), _return_value_ptr(return_value_ptr)
-{  
+{
 }
 
 MethodCallBase::MethodCallBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack,zval** return_value_ptr) :
 	_smoke(smoke), _method(meth), _stack(stack), _cur(-1), _called(false), _sp(0), _return_value_ptr(return_value_ptr)
-{  
+{
 }
 
 Smoke *
-MethodCallBase::smoke() 
-{ 
-	return _smoke; 
+MethodCallBase::smoke()
+{
+	return _smoke;
 }
 
-SmokeType 
-MethodCallBase::type() 
-{ 
-	return SmokeType(_smoke, _args[_cur]); 
+SmokeType
+MethodCallBase::type()
+{
+	return SmokeType(_smoke, _args[_cur]);
 }
 
 Smoke::StackItem &
-MethodCallBase::item() 
-{ 
-	return _stack[_cur + 1]; 
+MethodCallBase::item()
+{
+	return _stack[_cur + 1];
 }
 
 const Smoke::Method &
-MethodCallBase::method() 
-{ 
-	return _smoke->methods[_method]; 
+MethodCallBase::method()
+{
+	return _smoke->methods[_method];
 }
-	
-void 
-MethodCallBase::next() 
+
+void
+MethodCallBase::next()
 {
 	int oldcur = _cur;
 	_cur++;
@@ -370,8 +370,8 @@
 	_cur = oldcur;
 }
 
-void 
-MethodCallBase::unsupported() 
+void
+MethodCallBase::unsupported()
 {
 	php_error(E_ERROR, "Cannot handle '%s' as argument of %s::%s",
 		type().name(),
@@ -379,10 +379,10 @@
 		_smoke->methodNames[method().name]);
 }
 
-const char* 
-MethodCallBase::classname() 
-{ 
-	return _smoke->className(method().classId); 
+const char*
+MethodCallBase::classname()
+{
+	return _smoke->className(method().classId);
 }
 
 zval**
@@ -403,33 +403,33 @@
   	_args = _smoke->argumentList + method().args;
 }
 
-VirtualMethodCall::~VirtualMethodCall() 
+VirtualMethodCall::~VirtualMethodCall()
 {
     delete[] _stack;
 }
 
-Marshall::Action 
-VirtualMethodCall::action() 
-{ 
-	return Marshall::ToZVAL; 
+Marshall::Action
+VirtualMethodCall::action()
+{
+	return Marshall::ToZVAL;
 }
 
 zval*
-VirtualMethodCall::var() 
+VirtualMethodCall::var()
 {
 // 	*_sp[_cur] = (zval*) emalloc(sizeof(zval));
 	ZVAL_NULL(__sp[_cur]);
     return __sp[_cur];
 }
 
-int 
-VirtualMethodCall::items() 
-{ 
-	return method().numArgs; 
+int
+VirtualMethodCall::items()
+{
+	return method().numArgs;
 }
 
-void 
-VirtualMethodCall::callMethod() 
+void
+VirtualMethodCall::callMethod()
 {
 	if (_called) return;
 	_called = true;
@@ -440,10 +440,10 @@
  	VirtualMethodReturnValue r(_smoke, _method, _stack, _retval);
 }
 
-bool 
-VirtualMethodCall::cleanup() 
-{ 
-	return false; 
+bool
+VirtualMethodCall::cleanup()
+{
+	return false;
 }
 
 /**
@@ -475,40 +475,68 @@
 // 	_retval = retval;
 }
 
-MethodCall::~MethodCall() 
+MethodCall::~MethodCall()
 {
 	delete[] _stack;
 }
 
-Marshall::Action 
-MethodCall::action() 
-{ 
-	return Marshall::FromZVAL; 
+Marshall::Action
+MethodCall::action()
+{
+	return Marshall::FromZVAL;
 }
 
-zval* 
-MethodCall::var() 
+zval*
+MethodCall::var()
 {
 	if (_cur < 0) return _retval;
 	return (zval*) *_sp[_cur];
 }
 
-int 
-MethodCall::items() 
-{ 
-	return _items; 
+void
+MethodCall::callMethod() {
+	if(_called) return;
+	_called = true;
+
+	QString className(_smoke->className(method().classId));
+
+	if (! className.endsWith(_smoke->methodNames[method().name])
+		&& Z_TYPE_P(_target) == IS_NULL
+		&& !(method().flags & Smoke::mf_static) )
+	{
+		php_error(E_ERROR, "Instance is not initialized, cannot call %s",
+					_smoke->methodNames[method().name]);
+	}
+
+	if (Z_TYPE_P(_target) == IS_NULL && !(method().flags & Smoke::mf_static)) {
+		php_error(E_ERROR, "%s is not a class method\n", _smoke->methodNames[method().name]);
+	}
+
+	Smoke::ClassFn fn = _smoke->classes[method().classId].classFn;
+	void *ptr = _smoke->cast(_current_object, _current_object_class, method().classId);
+	_items = -1;
+
+	(*fn)(method().method, ptr, _stack);
+	MethodReturnValue r(_smoke, _method, _stack, _retval, _return_value_ptr);
 }
 
-bool 
-MethodCall::cleanup() 
-{ 
-	return true; 
+
+int
+MethodCall::items()
+{
+	return _items;
 }
 
+bool
+MethodCall::cleanup()
+{
+	return true;
+}
+
 const char *
-MethodCall::classname() 
-{ 
-	return qstrcmp(MethodCallBase::classname(), "QGlobalSpace") == 0 ? "" : MethodCallBase::classname(); 
+MethodCall::classname()
+{
+	return qstrcmp(MethodCallBase::classname(), "QGlobalSpace") == 0 ? "" : MethodCallBase::classname();
 }
 
 /**
@@ -516,54 +544,54 @@
  */
 
 SigSlotBase::SigSlotBase(zval*** sp) : _cur(-1), _called(false), _sp(sp)
-{ 
+{
 	identifier = "SigSlotBase";
 	_stack = new Smoke::StackItem[_items -1];
 }
 
-SigSlotBase::~SigSlotBase() 
-{ 
-	delete[] _stack; 
+SigSlotBase::~SigSlotBase()
+{
+	delete[] _stack;
 }
 
 const MocArgument &
-SigSlotBase::arg() 
-{ 
-	return _args[_cur + 1]; 
+SigSlotBase::arg()
+{
+	return _args[_cur + 1];
 }
 
-SmokeType 
-SigSlotBase::type() 
-{ 
-	return arg().st; 
+SmokeType
+SigSlotBase::type()
+{
+	return arg().st;
 }
 
 Smoke::StackItem &
-SigSlotBase::item() 
-{ 
-	return _stack[_cur]; 
+SigSlotBase::item()
+{
+	return _stack[_cur];
 }
 
-zval* 
-SigSlotBase::var() 
-{ 
-	return (zval*) *_sp[_cur]; 
+zval*
+SigSlotBase::var()
+{
+	return (zval*) *_sp[_cur];
 }
 
 Smoke *
-SigSlotBase::smoke() 
-{ 
-	return type().smoke(); 
+SigSlotBase::smoke()
+{
+	return type().smoke();
 }
 
-void 
-SigSlotBase::unsupported() 
+void
+SigSlotBase::unsupported()
 {
 	php_error(E_ERROR, "Cannot handle '%s' as %s argument\n", type().name(), mytype() );
 }
 
 void
-SigSlotBase::next() 
+SigSlotBase::next()
 {
 	int oldcur = _cur;
 	_cur++;
@@ -580,7 +608,7 @@
 /**
  *	SlotReturnValue
  *
- *	Converts a zval* returned by a slot invocation to a Qt slot 
+ *	Converts a zval* returned by a slot invocation to a Qt slot
  *	reply type
  */
 
@@ -589,14 +617,14 @@
     Smoke::Stack _stack;
 	zval* _result;
 public:
-	SlotReturnValue(void ** o, zval* result, MocArgument * replyType) 
+	SlotReturnValue(void ** o, zval* result, MocArgument * replyType)
 	{
 		_result = result;
 		_replyType = replyType;
 		_stack = new Smoke::StackItem[1];
 		Marshall::HandlerFn fn = getMarshallFn(type());
 		(*fn)(this);
-		// Save any address in zeroth element of the arrary of 'void*'s passed to 
+		// Save any address in zeroth element of the arrary of 'void*'s passed to
 		// qt_metacall()
 		void * ptr = o[0];
 		smokeStackToQtStack(_stack, o, 1, _replyType);
@@ -607,25 +635,25 @@
 		}
     }
 
-    SmokeType type() { 
-		return _replyType[0].st; 
+    SmokeType type() {
+		return _replyType[0].st;
 	}
     Marshall::Action action() { return Marshall::FromZVAL; }
     Smoke::StackItem &item() { return _stack[0]; }
     zval* var() {
     	return _result;
     }
-	
-	void unsupported() 
+
+	void unsupported()
 	{
 		php_error(E_ERROR, "Cannot handle '%s' as slot reply-type", type().name());
     }
 	Smoke *smoke() { return type().smoke(); }
-    
+
 	void next() {}
-    
+
 	bool cleanup() { return false; }
-	
+
 	~SlotReturnValue() {
 		delete[] _stack;
 	}
@@ -648,37 +676,37 @@
 	copyArguments();
 }
 
-InvokeSlot::~InvokeSlot() 
-{ 
-	free(_sp);	
+InvokeSlot::~InvokeSlot()
+{
+	free(_sp);
 }
 
-Marshall::Action 
-InvokeSlot::action() 
-{ 
-	return Marshall::ToZVAL; 
+Marshall::Action
+InvokeSlot::action()
+{
+	return Marshall::ToZVAL;
 }
 
 const char *
-InvokeSlot::mytype() 
-{ 
-	return "slot"; 
+InvokeSlot::mytype()
+{
+	return "slot";
 }
 
-bool 
-InvokeSlot::cleanup() 
-{ 
-	return false; 
+bool
+InvokeSlot::cleanup()
+{
+	return false;
 }
 
-void 
-InvokeSlot::copyArguments() 
+void
+InvokeSlot::copyArguments()
 {
 	smokeStackFromQtStack(_stack, _o + 1, _items - 1, _args + 1);
 }
 
-void 
-InvokeSlot::invokeSlot() 
+void
+InvokeSlot::invokeSlot()
 {
 	if (_called) return;
 	_called = true;
@@ -688,10 +716,10 @@
 	}
 }
 
-void 
-InvokeSlot::mainfunction() 
-{ 
-	invokeSlot(); 
+void
+InvokeSlot::mainfunction()
+{
+	invokeSlot();
 }
 
 /**
@@ -709,26 +737,26 @@
 	_result = result;
 }
 
-Marshall::Action 
-EmitSignal::action() 
-{ 
-	return Marshall::FromZVAL; 
+Marshall::Action
+EmitSignal::action()
+{
+	return Marshall::FromZVAL;
 }
 
 Smoke::StackItem &
-EmitSignal::item() 
+EmitSignal::item()
 {
-	return _stack[_cur]; 
+	return _stack[_cur];
 }
 
 const char *
-EmitSignal::mytype() 
-{ 
-	return "signal"; 
+EmitSignal::mytype()
+{
+	return "signal";
 }
 
-void 
-EmitSignal::emitSignal() 
+void
+EmitSignal::emitSignal()
 {
 
 	if (_called) return;
@@ -745,50 +773,50 @@
 	delete[] o;
 }
 
-void 
-EmitSignal::mainfunction() 
-{ 
-	emitSignal(); 
+void
+EmitSignal::mainfunction()
+{
+	emitSignal();
 }
 
-bool 
-EmitSignal::cleanup() 
-{ 
-	return true; 
+bool
+EmitSignal::cleanup()
+{
+	return true;
 }
 
-SmokeType 
-EmitSignal::type() 
-{ 
-	return arg().st; 
+SmokeType
+EmitSignal::type()
+{
+	return arg().st;
 }
 
-zval* 
-EmitSignal::var() 
-{ 
-	return (zval*) *_sp[_cur]; 
+zval*
+EmitSignal::var()
+{
+	return (zval*) *_sp[_cur];
 }
 
 Smoke *
-EmitSignal::smoke() 
-{ 
-	return type().smoke(); 
+EmitSignal::smoke()
+{
+	return type().smoke();
 }
 
-void 
-EmitSignal::unsupported() 
+void
+EmitSignal::unsupported()
 {
 	php_error(E_ERROR, "Cannot handle '%s' as %s argument\n", type().name(), mytype() );
 }
 
 const MocArgument &
-EmitSignal::arg() 
-{ 
-	return _args[_cur + 1]; 
+EmitSignal::arg()
+{
+	return _args[_cur + 1];
 }
 
 void
-EmitSignal::next() 
+EmitSignal::next()
 {
 	int oldcur = _cur;
 	_cur++;

Modified: trunk/php_qt/marshall_types.h
===================================================================
--- trunk/php_qt/marshall_types.h	2007-06-03 10:01:16 UTC (rev 327)
+++ trunk/php_qt/marshall_types.h	2007-06-06 13:07:07 UTC (rev 328)
@@ -38,7 +38,7 @@
  *	MethodReturnValueBase
  */
 
-class MethodReturnValueBase : public Marshall 
+class MethodReturnValueBase : public Marshall
 {
 public:
 	MethodReturnValueBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval** return_value_ptr);
@@ -104,7 +104,7 @@
 	Smoke::StackItem &item();
 	const Smoke::Method &method();
 	virtual int items() = 0;
-	virtual void callMethod() = 0;	
+	virtual void callMethod() = 0;
 	void next();
 	void unsupported();
 	zval** return_value_ptr();
@@ -135,7 +135,7 @@
 	int items();
 	void callMethod();
 	bool cleanup();
- 
+
 private:
 	zval* _obj;
  	zval **__sp;
@@ -152,32 +152,7 @@
 	~MethodCall();
 	Marshall::Action action();
 	zval* var();
-	inline void callMethod() {
-		if(_called) return;
-		_called = true;
-
-		QString className(_smoke->className(method().classId));
-
-		if (! className.endsWith(_smoke->methodNames[method().name])
-			&& Z_TYPE_P(_target) == IS_NULL
-			&& !(method().flags & Smoke::mf_static) ) 
-		{
-			php_error(E_ERROR, "Instance is not initialized, cannot call %s", 
-						_smoke->methodNames[method().name]);
-		}
-
-		if (Z_TYPE_P(_target) == IS_NULL && !(method().flags & Smoke::mf_static)) {
-			php_error(E_ERROR, "%s is not a class method\n", _smoke->methodNames[method().name]);
-		}
-
-		Smoke::ClassFn fn = _smoke->classes[method().classId].classFn;
-		void *ptr = _smoke->cast(_current_object, _current_object_class, method().classId);
-		_items = -1;
-
-		(*fn)(method().method, ptr, _stack);
-		MethodReturnValue r(_smoke, _method, _stack, _retval, _return_value_ptr);
-	}
-
+	void callMethod();
 	int items();
 	bool cleanup();
 
@@ -208,7 +183,7 @@
 	virtual const char *mytype() = 0;
 	virtual void mainfunction() = 0;
 	void unsupported();
-	void next(); 
+	void next();
 
 protected:
 	MocArgument *_args;
@@ -233,7 +208,7 @@
 	void emitSignal();
 	void mainfunction();
 	bool cleanup();
-	void next(); 
+	void next();
 	SmokeType type();
 	zval* var();
 	void unsupported();
@@ -275,7 +250,7 @@
 	const char *mytype();
     bool cleanup();
 	void copyArguments();
-	void invokeSlot(); 
+	void invokeSlot();
 	void mainfunction();
 };
 
@@ -283,7 +258,7 @@
 /**
  *	SignalReturnValue
  *
- *	Converts a C++ value returned by a signal invocation to a PHP 
+ *	Converts a C++ value returned by a signal invocation to a PHP
  *	reply type
  */
 class SignalReturnValue : public Marshall {
@@ -291,7 +266,7 @@
     Smoke::Stack _stack;
 	zval * _result;
 public:
-	SignalReturnValue(void ** o, zval * result, MocArgument * replyType) 
+	SignalReturnValue(void ** o, zval * result, MocArgument * replyType)
 	{
 		_result = result;
 		_replyType = replyType;
@@ -301,25 +276,25 @@
 		(*fn)(this);
     }
 
-    SmokeType type() { 
-		return _replyType[0].st; 
+    SmokeType type() {
+		return _replyType[0].st;
 	}
     Marshall::Action action() { return Marshall::ToZVAL; }
     Smoke::StackItem &item() { return _stack[0]; }
     zval* var() {
     	return _result;
     }
-	
-	void unsupported() 
+
+	void unsupported()
 	{
 		php_error(E_ERROR, "Cannot handle '%s' as signal reply-type", type().name());
     }
 	Smoke *smoke() { return type().smoke(); }
-    
+
 	void next() {}
-    
+
 	bool cleanup() { return false; }
-	
+
 	~SignalReturnValue() {
 		delete[] _stack;
 	}

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-03 10:01:16 UTC (rev 327)
+++ trunk/php_qt/php_qt.cpp	2007-06-06 13:07:07 UTC (rev 328)
@@ -1,7 +1,7 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2006 
+ * Copyright (C) 2006
  * Thomas Moenicke <thomas.moenicke at kdemail.net>
  * Katrina Niolet <katrina at niolet.name>
  *
@@ -70,7 +70,7 @@
 function_entry php_qt_functions[] = {
 	PHP_FE(confirm_php_qt_compiled,	NULL)		/* For testing, remove later. */
 	PHP_FE(SIGNAL,	NULL)
-	PHP_FE(SLOT,	NULL)	
+	PHP_FE(SLOT,	NULL)
 	PHP_FE(emit,	NULL)
 	PHP_FE(qDebug,	NULL)
 	PHP_FE(qWarning,	NULL)
@@ -132,6 +132,10 @@
 QHash<zend_object_handle, smokephp_object*> obj_x_smokephp;
 QStack<QByteArray*> methodNameStack;
 
+zend_class_entry* activeCe;
+zval* activeScope;
+bool parentCall;
+
 // cached
 Smoke::Index qbool;
 Smoke::Index qstring;
@@ -140,7 +144,70 @@
 extern zend_class_entry* qstring_ce;
 extern void 	_register_QString();
 
-/*
+/*!
+ *	constant method handler
+ *
+ *	here we'll try to find a defined static method in Qt and assign the
+ *  staticProxyMethod handler
+ *  see ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_HANDLER in zend_vm_execute.h
+ */
+#undef EX
+#define EX(element) execute_data->element
+
+static int (*originalConstantMethodHandler)(ZEND_OPCODE_HANDLER_ARGS);
+
+static int constantMethodHandler(ZEND_OPCODE_HANDLER_ARGS)
+{
+	zend_op *opline = EX(opline);
+	zend_class_entry *ce = EX_T(opline->op1.u.var).class_entry;
+	union _zend_function *fbc;
+	zval* function_name;
+	char* function_name_strval;
+	int function_name_strlen;
+
+	function_name = &opline->op2.u.constant;
+	// store the active ce
+	activeCe = EX_T(opline->op1.u.var).class_entry;
+
+	if (Z_TYPE_P(function_name) != IS_STRING) {
+		zend_error_noreturn(E_ERROR, "Function name must be a string");
+	}
+
+	// get method name
+  	function_name_strval = zend_str_tolower_dup(function_name->value.str.val, function_name->value.str.len);
+ 	function_name_strlen = function_name->value.str.len;
+
+	// call proxyMethod if method is not defined in userspace
+	if(zend_hash_find(&ce->function_table, function_name_strval, function_name_strlen+1, (void**) &fbc) == FAILURE)
+	{
+		zend_ptr_stack_3_push(&EG(arg_types_stack), EX(fbc), EX(object), NULL);
+		zend_bool is_const = (IS_CONST == IS_CONST);
+
+		if(zend_hash_find(&ce->function_table, "staticproxymethod", 18, (void**) &fbc) != FAILURE)
+		{
+
+			//! TODO	darn! we have a lowersized string here!
+			const char* methodName = PQ::findRealMethodName( function_name->value.str.val );
+			methodNameStack.push( new QByteArray( methodName ) );
+
+			EX(fbc) = fbc;
+
+			if(!is_const){ efree(function_name_strval); }
+			EX(opline)++;
+			ZEND_VM_CONTINUE();
+
+		}
+
+		if(!is_const){ efree(function_name_strval); }
+
+	}  // end try call proxyMethod
+
+  	return originalConstantMethodHandler(execute_data);
+
+}
+
+
+/*!
  *	constants handler
  */
 
@@ -237,24 +304,16 @@
  *	generic object
  */
 
-ZEND_METHOD(php_qt_generic_class, __construct);
-ZEND_METHOD(php_qt_generic_class, __destruct);
-ZEND_METHOD(php_qt_generic_class, __toString);
-ZEND_METHOD(php_qt_generic_class, emit);
-ZEND_METHOD(php_qt_generic_class, proxyMethod);
-ZEND_METHOD(php_qt_generic_class, staticProxyMethod);
-
 static zend_function_entry php_qt_generic_methods[] = {
     ZEND_ME(php_qt_generic_class,__construct,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(php_qt_generic_class,__destruct,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(php_qt_generic_class,__toString,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(php_qt_generic_class,emit,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(php_qt_generic_class,proxyMethod,NULL,ZEND_ACC_PUBLIC)
+    ZEND_ME(php_qt_generic_class,staticProxyMethod,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
     {NULL,NULL,NULL}
 };
 
-static zend_function_entry*** php_qt_static_methods;
-
 ZEND_METHOD(php_qt_generic_class, emit){
 }
 
@@ -265,7 +324,7 @@
 
 ZEND_METHOD(php_qt_generic_class, __destruct)
 {
-qDebug() << "__destruct" << getThis() << PZVAL_IS_REF(getThis());
+// qDebug() << "__destruct" << getThis() << PZVAL_IS_REF(getThis());
 	if(phpqt_SmokePHPObjectExists(getThis())) {
 
  		smokephp_object *o = phpqt_getSmokePHPObjectFromZval(getThis());
@@ -289,6 +348,8 @@
 
 ZEND_METHOD(php_qt_generic_class, __construct)
 {
+	activeScope = getThis();
+
     // find parents
     zend_class_entry *ce = Z_OBJCE_P(getThis());
     zend_class_entry *ce_parent = Z_OBJCE_P(getThis());
@@ -343,7 +404,7 @@
 		)){
 		  	const char* phpqt_meta_stringdata_ = estrndup(phpqt_meta_stringdata->toAscii(), phpqt_meta_stringdata->size());
   			QMetaObject ob = {
-				{superdata, phpqt_meta_stringdata_, 
+				{superdata, phpqt_meta_stringdata_,
 					phpqt_meta_data, 0}
  			};
  			o->meta = (QMetaObject*) emalloc(sizeof(ob));
@@ -369,14 +430,21 @@
     zend_class_entry *ce;
     // nonstaticphp_qt_generic_class_proxyMethod
     if(getThis()){
-        ce = Z_OBJCE_P(getThis());
+    	activeScope = getThis();
+
+		// if a parent:: call occurs this_ptr has the wrong ce, so we need to
+		// correct it here
+		if(parentCall)
+		{
+			ce = activeCe;
+			parentCall = false;
+        } else {
+        	ce = Z_OBJCE_P(getThis());
+        }
+
     // static
     } else {
-        char* space = "::";
-        char* class_name = get_active_class_name(&space);
-        char* method_name = get_active_function_name();
-        ce = zend_fetch_class(class_name,strlen(class_name), ZEND_FETCH_CLASS_AUTO TSRMLS_DC);
-        methodNameStack.push(new QByteArray(method_name));
+		ce = activeCe;
     }
 
     // find parents
@@ -426,10 +494,10 @@
 		}
 	    }
 
-	    php_error(E_ERROR,"Call to undefined method %s::%s()", ce->name, methodNameStack.top()->constData());
-		
+	    php_error(E_ERROR,"Call to undefined method %s::%s() or wrong arguments", ce->name, methodNameStack.top()->constData());
+
 	}
-	else 
+	else
 	    php_error(E_ERROR,"Call to undefined method!");
     }
 
@@ -443,7 +511,27 @@
     return;
 } // proxyMethod
 
-/*! 
+ZEND_METHOD(php_qt_generic_class, staticProxyMethod)
+{
+	this_ptr = NULL;
+
+	// do we have a parent::blablub() call?
+	if(EG(active_op_array)->scope){
+		if(EG(scope) == EG(active_op_array)->scope->parent)
+		{
+			if(activeScope)
+			{
+				parentCall = true;
+				this_ptr = activeScope;
+			}
+		}
+	}
+
+	// forward to proxyMethod
+	zim_php_qt_generic_class_proxyMethod(ht, return_value, return_value_ptr, this_ptr, return_value_used);
+}
+
+/*!
  *	PHP_MINIT_FUNCTION
  */
 
@@ -463,42 +551,30 @@
 	zend_orig_handler = php_qt_handler;
 	php_qt_handler.get_method = proxyHandler;
 
-	// overwrite :: operator
+	// overwrite :: operator, see zend_vm_execute.h
 	memcpy(phpqt_opcode_handlers, zend_opcode_handlers, sizeof(phpqt_opcode_handlers));
 	phpqt_original_opcode_handlers = zend_opcode_handlers;
 	zend_opcode_handlers = phpqt_opcode_handlers;
+	// ZEND_FETCH_CONSTANT = 99 => 2475
 	phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + 0] = constantHandler;
+	// replace and store ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_HANDLER
+	originalConstantMethodHandler = phpqt_opcode_handlers[2825];
+	phpqt_opcode_handlers[2825] = constantMethodHandler;
+	phpqt_opcode_handlers[2830] = constantMethodHandler;
+	phpqt_opcode_handlers[2835] = constantMethodHandler;
+	phpqt_opcode_handlers[2840] = constantMethodHandler;
+	phpqt_opcode_handlers[2845] = constantMethodHandler;
 
 	smokephp_init();
 
-	Smoke::Index qobject = PQ::smoke()->idClass("QObject");
-
-	php_qt_static_methods = (zend_function_entry***) safe_emalloc((PQ::smoke()->numClasses), sizeof(zend_function_entry **), 0);
-
-	int method_count;
 	// cache class entries
 	Smoke::Index i = 1;
 	QHash<const char*, zend_class_entry*> tmpCeTable;
-	// loop for all classes, register them
+
+	// loop for all classes, register class entries
 	for(i = 1; i <= PQ::smoke()->numClasses; i++){
 
-        // statical methods, there is no method handler which can be overwritten
-        // hope this will be better in future / see zend_std_get_static_method()
-        method_count = 0;
-        for(int j=0;j<PQ::smoke()->numMethods;j++){
-            if(PQ::smoke()->methods[j].classId == i){
-                if(!(PQ::smoke()->methods[j].flags & Smoke::mf_enum)){
-                    if((PQ::smoke()->methods[j].flags & Smoke::mf_static)){
-                        // avoids overloaded methods
-                        if(strcmp(PQ::smoke()->methodNames[PQ::smoke()->methods[j-1].name],PQ::smoke()->methodNames[PQ::smoke()->methods[j].name])){
-                            method_count++;
-                        }
-                    }
-                }
-            }
-        } // for
-
-        zend_function_entry* t = (zend_function_entry*) safe_emalloc((method_count+7), sizeof(zend_function_entry), 0);
+        zend_function_entry* t = (zend_function_entry*) safe_emalloc(7, sizeof(zend_function_entry), 0);
         zend_function_entry* p = t;
 
         PHP_QT_ME(php_qt_generic_class,__construct,phpqt_cast_arginfo,ZEND_ACC_PUBLIC);
@@ -506,57 +582,24 @@
         PHP_QT_ME(php_qt_generic_class,__toString,NULL,ZEND_ACC_PUBLIC);
 		PHP_QT_ME(php_qt_generic_class,emit,NULL,ZEND_ACC_PUBLIC);
         PHP_QT_ME(php_qt_generic_class,proxyMethod,phpqt_cast_arginfo,ZEND_ACC_PUBLIC);
+        PHP_QT_ME(php_qt_generic_class,staticProxyMethod,phpqt_cast_arginfo,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC);
 
-		QHash<const char*, bool> tmpMethodList;	// avoids doubled method names
+		// register zend class
+		zend_class_entry ce;
+		INIT_CLASS_ENTRY(ce, PQ::smoke()->classes[i].className, p);
+		ce.name_length = strlen(PQ::smoke()->classes[i].className);
+		zend_class_entry* ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);
+		tmpCeTable[PQ::smoke()->classes[i].className] = ce_ptr;
+		// cache QObject
+		if(qobject == i){
+			qobject_ce = ce_ptr;
+		}
 
-        for(int j=0;j<PQ::smoke()->numMethods;j++)
-	{
-            if(PQ::smoke()->methods[j].classId == i)
-	    {
-                if(!(PQ::smoke()->methods[j].flags & Smoke::mf_enum))
-		{
-                    if(PQ::smoke()->methods[j].flags & Smoke::mf_static)
-		    {
-                        // avoids overloaded methods, fast
-                        if(strcmp(PQ::smoke()->methodNames[PQ::smoke()->methods[j-1].name],PQ::smoke()->methodNames[PQ::smoke()->methods[j].name]))
-			{
-                        	if(!tmpMethodList.contains(PQ::smoke()->methodNames[PQ::smoke()->methods[j].name])) // method already defined in this class?
-				{ 
-								tmpMethodList[PQ::smoke()->methodNames[PQ::smoke()->methods[j].name]] = true;
-								t->fname = (char*) emalloc(strlen(PQ::smoke()->methodNames[PQ::smoke()->methods[j].name])+1);
-								t->fname = (char*) PQ::smoke()->methodNames[PQ::smoke()->methods[j].name];
-								t->handler = ZEND_MN(php_qt_generic_class_proxyMethod);
-								t->arg_info = phpqt_cast_arginfo;
-								t->flags = ZEND_ACC_PUBLIC|ZEND_ACC_STATIC;
-								t++;
-                        	}
-                        }
-                    }
-                }
-	   }
-        }
+	} // end loop classes
 
-        // stops the zend-loop 'while(ptr->fname) {...}' in zend_register_functions
-        t->fname = NULL;
-        t->handler = NULL;
-        t->arg_info = NULL;
-        t->flags = (zend_uint) NULL;
-        t++;
-
-	// register zend class
-	zend_class_entry ce;
-	INIT_CLASS_ENTRY(ce, PQ::smoke()->classes[i].className, p);
-	ce.name_length = strlen(PQ::smoke()->classes[i].className);
-	zend_class_entry* ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);
-	tmpCeTable[PQ::smoke()->classes[i].className] = ce_ptr;
-	// cache QObject
-	if(qobject == i){
-	    qobject_ce = ce_ptr;
-	}		
-	} // end for
-
+	// cache some stuff
+	Smoke::Index qobject = PQ::smoke()->idClass("QObject");
 	_register_QString();
-	tmpCeTable[PQ::smoke()->classes[i].className] = qstring_ce;
 
 	// do inheritance, all classes must be defined before
 	for(Smoke::Index i = 1; i <= PQ::smoke()->numClasses; i++){
@@ -610,7 +653,7 @@
  *	PHP-Qt internal functions
  */
 
-int	
+int
 phpqt_metacall(smokephp_object* so, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a)
 {
 	QMetaObject* d = so->meta;
@@ -644,11 +687,11 @@
 #endif
 
 			if((int)i[0].s_int < 0)
-				return i[0].s_int;	
+				return i[0].s_int;
 
 		} else {
 			// should never happen
-			php_error(E_ERROR, "Cannot find %s::qt_metacall() method\n", d->className());		
+			php_error(E_ERROR, "Cannot find %s::qt_metacall() method\n", d->className());
 		}
 
 	}
@@ -714,10 +757,10 @@
 
 	efree(method_name);
     return _id;
-	
+
 }
 
-static void 
+static void
 phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc TSRMLS_DC)
 {
 #ifdef DEBUG
@@ -728,7 +771,7 @@
 bool
 phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname)
 {
-	
+
 	if(ce_ptr == NULL){
 	  php_error(E_ERROR,"methodExists fatal error: no class entry");
 	}
@@ -745,7 +788,7 @@
 }
 
 
-zval* 
+zval*
 phpqt_callPHPMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args)
 {
 
@@ -768,7 +811,7 @@
     return retval;
 }
 
-/*! 
+/*!
  *	creates metaObject data
  *  example: "QWidget\0\0value\0test(int)\0"
  *	@param	zval*				this_ptr	pointer of the zval
@@ -777,7 +820,7 @@
  *	@return	QMetaObject*
  */
 
-bool 
+bool
 phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* meta, QString* meta_stringdata, uint* signature){
 
     /// readout the slots table
@@ -818,19 +861,19 @@
 		signature[7] = 0;
 		signature[8] = 0;
 		signature[9] = 0;
-	
+
 		/// write classname
 		meta_stringdata->append(classname);
  		meta_stringdata->append(QChar::Null);
  		meta_stringdata->append(QChar::Null);
- 	
+
 		int i;
 		i = 10;
 
 		zend_hash_internal_pointer_reset(signals_hash);
 
 		while(zend_hash_has_more_elements(signals_hash) == SUCCESS){
-	
+
 			/// read slot from hashtable
 			zend_hash_get_current_key(signals_hash,&assocKey,&numKey,0);
 			zend_hash_get_current_data(signals_hash,(void**)&slotdata);
@@ -840,27 +883,27 @@
 			qr->append(" ");
 			cout << "\t" << signaturecount << "8 8 8 0x05 ::s" << endl;
 #endif
-			
+
 			meta_stringdata->append(Z_STRVAL_PP(slotdata));
 			meta_stringdata->append(QChar::Null);
-	
+
 			zend_hash_move_forward(signals_hash);
-	
+
 			/// write slot signature
 			signature[i++] = signaturecount;
-			signature[i++] = 8;        
 			signature[i++] = 8;
 			signature[i++] = 8;
+			signature[i++] = 8;
 			signature[i++] = 0x05;
-	
+
 			signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
-	
+
 		}
 
     	zend_hash_internal_pointer_reset(slots_hash);
 
 		while(zend_hash_has_more_elements(slots_hash) == SUCCESS){
-	
+
 			/// read slot from hashtable
 			zend_hash_get_current_key(slots_hash,&assocKey,&numKey,0);
 			zend_hash_get_current_data(slots_hash,(void**)&slotdata);
@@ -870,21 +913,21 @@
 			qr->append(" ");
 			cout << "\t" << signaturecount << "8 8 8 0x0a ::s" << endl;
 #endif
-	
+
 			meta_stringdata->append(Z_STRVAL_PP(slotdata));
 			meta_stringdata->append(QChar::Null);
 
 			zend_hash_move_forward(slots_hash);
-	
+
 			/// write slot signature
 			signature[i++] = signaturecount;
 			signature[i++] = 8;
 			signature[i++] = 8;
 			signature[i++] = 8;
 			signature[i++] = 0x0a;
-	
+
 			signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
-	
+
 		}
 #if MOC_DEBUG
 		cout << qr->toAscii().constData() << endl;
@@ -907,7 +950,7 @@
 	return obj_x_smokephp.contains(this_ptr->value.obj.handle);
 }
 
-smokephp_object* 
+smokephp_object*
 phpqt_getSmokePHPObjectFromZval(zval* this_ptr)
 {
 

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-06-03 10:01:16 UTC (rev 327)
+++ trunk/php_qt/php_qt.h	2007-06-06 13:07:07 UTC (rev 328)
@@ -1,7 +1,7 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2006 
+ * Copyright (C) 2006
  * Thomas Moenicke <thomas.moenicke at kdemail.net>
  * Katrina Niolet <katrina at niolet.name>
  *
@@ -167,6 +167,8 @@
 
 const char* 		printType(int type);
 
+union _zend_function* proxyHandler(zval **obj_ptr, char* methodName, int methodName_len TSRMLS_DC);
+
 extern Smoke* qt_Smoke;
 class PQ
 {
@@ -177,6 +179,21 @@
 public:
     ~PQ();
     static inline Smoke* smoke() { return qt_Smoke; }
+
+	typedef short Index;
+
+	static inline const char* findRealMethodName(const char* methodName)
+	{
+
+		if(!methodName) return "";
+		QString _m(methodName);
+		//! TODO its slow but safe, implement a better algorithm
+		for(Index i=0; i < PQ::smoke()->numMethodNames; i++){
+			if(_m.compare(PQ::smoke()->methodNames[i], Qt::CaseInsensitive) == 0){ return PQ::smoke()->methodNames[i]; }
+		}
+ 		qFatal("PQ::findRealMethodName(): could not find %s", methodName);
+	}
+
 };
 
 extern int le_php_qt_hashtype;
@@ -273,4 +290,47 @@
 ZEND_METHOD(QString, toInt);
 ZEND_METHOD(QString, isNull);
 
+ZEND_METHOD(php_qt_generic_class, __construct);
+ZEND_METHOD(php_qt_generic_class, __destruct);
+ZEND_METHOD(php_qt_generic_class, __toString);
+ZEND_METHOD(php_qt_generic_class, emit);
+ZEND_METHOD(php_qt_generic_class, proxyMethod);
+ZEND_METHOD(php_qt_generic_class, staticProxyMethod);
+
+// smoke stuff
+
+
+
+// ZEND stuff
+
+static int zend_check_symbol(zval **pz TSRMLS_DC)
+{
+	if (Z_TYPE_PP(pz) > 9) {
+		fprintf(stderr, "Warning!  %x has invalid type!\n", *pz);
+	} else if (Z_TYPE_PP(pz) == IS_ARRAY) {
+		zend_hash_apply(Z_ARRVAL_PP(pz), (apply_func_t) zend_check_symbol TSRMLS_CC);
+	} else if (Z_TYPE_PP(pz) == IS_OBJECT) {
+
+		/* OBJ-TBI - doesn't support new object model! */
+		zend_hash_apply(Z_OBJPROP_PP(pz), (apply_func_t) zend_check_symbol TSRMLS_CC);
+	}
+
+	return 0;
+}
+
+#define ZEND_VM_CONTINUE() return 0
+
+#define CHECK_SYMBOL_TABLES()														\
+	zend_hash_apply(&EG(symbol_table), (apply_func_t) zend_check_symbol TSRMLS_CC);	\
+	if (&EG(symbol_table)!=EG(active_symbol_table)) {								\
+		zend_hash_apply(EG(active_symbol_table), (apply_func_t) zend_check_symbol TSRMLS_CC);	\
+	}
+
+
+#define ZEND_VM_NEXT_OPCODE() \
+	CHECK_SYMBOL_TABLES() \
+	EX(opline)++; \
+	ZEND_VM_CONTINUE()
+
+
 #endif

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-06-03 10:01:16 UTC (rev 327)
+++ trunk/php_qt/smokephp.cpp	2007-06-06 13:07:07 UTC (rev 328)
@@ -1,7 +1,7 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2006 
+ * Copyright (C) 2006
  * Thomas Moenicke <thomas.moenicke at kdemail.net>
  *
  * This program is free software; you can redistribute it and/or
@@ -86,7 +86,7 @@
 		    VirtualMethodCall c(smoke, method, args, o->zval_ptr, &zmem, &o->zval_ptr);
 		    c.next();
 		}
-		
+
 		return false;
     }
 
@@ -109,7 +109,7 @@
  *	@return	-
  */
 
-void 
+void
 smokephp_init() {
 
     if (qt_Smoke != 0L) {
@@ -127,11 +127,11 @@
 }
 
 /*!
- *  @param  const char*     c   class-name 
+ *  @param  const char*     c   class-name
  *  @param  const char*     m   mangled function-name
  *  @return Smoke::Index        unambiguous method ID
  */
-Smoke::Index 
+Smoke::Index
 smokephp_getMethod(const char* c, const char* m, int argc, zval*** args)
 {
 
@@ -173,7 +173,7 @@
 								right = true;
 							break;
 						case Smoke::t_float:
-						case Smoke::t_double: 
+						case Smoke::t_double:
 							if(type == IS_DOUBLE)
 								right = true;
 							break;
@@ -182,7 +182,7 @@
 							break;
 						case Smoke::t_class:
 							if(type == IS_OBJECT){
-							    QByteArray* name = 
+							    QByteArray* name =
 							    new QByteArray(
 								PQ::smoke()->types[
 								    PQ::smoke()->argumentList[
@@ -204,7 +204,7 @@
 					return PQ::smoke()->ambiguousMethodList[i];
 				}
 			}
-			
+
 			i++;
     	}
     }
@@ -242,7 +242,7 @@
  * #define IS_RESOURCE	7
  * #define IS_CONSTANT	8
  * #define IS_CONSTANT_ARRAY	9
- * 
+ *
  *  @param  zval***                 args
  *	@param	int						argc
  *  @param  Smoke::StackItem*       qargs
@@ -299,13 +299,13 @@
 	if(zend_hash_get_current_data_ex(((zval) *args).value.ht, (void**) &first_elem, 0) == FAILURE){
 		php_error(E_ERROR, "PHP-Qt: could not get first value of hashtable.");
 	}
-	
+
 	uint type = (int) (**first_elem).type;
 	if(type < 0 || type > 9){
 		// should never happen
 		php_error(E_ERROR, "Could not get type of array");
 	}
-	
+
 	void* e_arrayv;
 
 	switch(type){
@@ -358,7 +358,7 @@
         	    methodNameStack.top()->append("#");
         	}
 	    } else {
-	        php_error(E_ERROR,"Unknown argument or unsupported type %d at argument %d, cannot prepare method call\n", type, i);
+	        php_error(E_ERROR,"Unknown argument or unsupported type %d at argument %d, cannot prepare method call %s()\n", type, i, methodNameStack.top()->constData());
 // 	        exit(FAILURE);
 	    }
     }
@@ -412,7 +412,7 @@
 }
 
 
-void 
+void
 smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method){
 
     int j;
@@ -429,11 +429,11 @@
 
 }
 
-bool 
+bool
 smokephp_isQObject(Smoke::Index classId) {
 	if(strcmp(PQ::smoke()->classes[classId].className, "QObject") == 0)
 		return true;
-	
+
 	for(Smoke::Index *p = PQ::smoke()->inheritanceList + PQ::smoke()->classes[classId].parents;	*p;	p++) {
 		if(smokephp_isQObject(*p))
 			return true;

Modified: trunk/smoke/smoke.h
===================================================================
--- trunk/smoke/smoke.h	2007-06-03 10:01:16 UTC (rev 327)
+++ trunk/smoke/smoke.h	2007-06-06 13:07:07 UTC (rev 328)
@@ -320,7 +320,7 @@
 	int icmp = -1;
 	while(imax >= imin) {
 	    icur = (imin + imax) / 2;
-	    icmp = strcmp(methodNames[icur], m);
+ 	    icmp = strcmp(methodNames[icur], m);
 	    if(!icmp) break;
 	    if(icmp > 0)
 		imax = icur - 1;

Modified: trunk/tests/QtBasicTestCase.php
===================================================================
--- trunk/tests/QtBasicTestCase.php	2007-06-03 10:01:16 UTC (rev 327)
+++ trunk/tests/QtBasicTestCase.php	2007-06-06 13:07:07 UTC (rev 328)
@@ -1,5 +1,5 @@
 <?php
-
+// todo: set bool, empty string
     /**
      *	This file contains a couple of basic tests
      *
@@ -21,10 +21,32 @@
 	const a = "a";
 	const b = 24;
 
+	public function __construct($parent)
+	{
+	    parent::__construct($parent);
+	}
+
 	public function testMethod($value = NULL) {
 	    if ($value) echo $value."\n";
 	}
 	
+	public static function staticMethod()
+	{
+	    return "staticMethod";
+	}
+
+//	    parent::tr("");
+
+	public static function staticTrMethod($arg)
+	{
+	    return parent::tr($arg);
+	}
+
+	public function blockSignals($bool)
+	{
+	    return parent::blockSignals($bool);
+	}
+	
     }
 
 
@@ -58,6 +80,38 @@
 	    echo " passed";
 	}
 
+	// try to call a static method
+	function testCallStaticMethod() {
+	    echo "\ntesting foo::staticMethod()";
+	    $this->assertEquals(foo::staticMethod(), "staticMethod", "Could not call a static method!");
+	    echo " passed";
+	}
+
+	// try to call a static Qt method
+	function testCallStaticQtMethod() {
+	    echo "\ntesting foo::tr()";
+	    $this->assertEquals(foo::tr("hello") == "hello", "Could not call a static Qt method!");
+	    echo " passed";
+	}
+
+	// try to call a parent Qt method within a method
+	function testCallParentQtMethod() {
+	    echo "\ntesting parent::blockSignals() within foo::blockSignals()";
+	    $o = new QObject();
+	    $p = new foo($o);
+	    // set blockSignals to true, so we can test it
+	    $p->blockSignals(true); 
+    	    $this->assertTrue($p->blockSignals(true), "Could not call a parent Qt method!");
+	    echo " passed";
+	}
+
+	// try to call a static Qt method within a static PHP method
+	function testCallStaticQtMethodWithinStaticPHPMethod() {
+	    echo "\ntesting foo::staticTrMethod()";
+	    $this->assertEquals(foo::staticTrMethod("hello") == "hello", "Could not call a static Qt method!");
+	    echo " passed";
+	}
+
 	// test the __toString() method
 	function testQString() {
 	    echo "\ntesting QString::__toString()";
@@ -176,7 +230,7 @@
 	}
 
 	function testTr(){
-	    echo "\ntesting tr()";
+	    echo "\ntesting global tr()";
 	    $s = tr("hello world");
 	    $this->assertEquals($s->__toString(), "hello world", "tr() doesnt work!");
 	    echo " passed";



From tm243 at mail.berlios.de  Wed Jun  6 20:43:36 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 6 Jun 2007 20:43:36 +0200
Subject: [Php-qt-svn] r329 - in trunk: . examples/calculator php_qt
Message-ID: <200706061843.l56Ihav8022679@sheep.berlios.de>

Author: tm243
Date: 2007-06-06 20:43:35 +0200 (Wed, 06 Jun 2007)
New Revision: 329

Removed:
   trunk/TODO
   trunk/admin/
   trunk/config.m4
   trunk/kdeize
Modified:
   trunk/examples/calculator/calculator.php
   trunk/php_qt/marshall_basetypes.h
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/marshall_types.h
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/smokephp.cpp
   trunk/svn-commit.tmp
Log:
* major code cleaning



Deleted: trunk/TODO
===================================================================
--- trunk/TODO	2007-06-06 13:07:07 UTC (rev 328)
+++ trunk/TODO	2007-06-06 18:43:35 UTC (rev 329)
@@ -1,9 +0,0 @@
-
-
-- virtual and protected methods (already prepared)
-- storing meta objects in hashtable (already prepared)
-- returning of right php objects if returntype is reference
-- support for pecl operators
-- support for Q_SIGNAL/Q_SLOT macros
-- classes for tutorial 8-14 and QSvgWidget, QSvgRenderer
-

Deleted: trunk/config.m4
===================================================================
--- trunk/config.m4	2007-06-06 13:07:07 UTC (rev 328)
+++ trunk/config.m4	2007-06-06 18:43:35 UTC (rev 329)
@@ -1,150 +0,0 @@
-
-m4_pattern_allow([AM_INIT_AUTOMAKE])dnl
-m4_pattern_allow([AC_PACKAGE_TARNAME])dnl
-m4_pattern_allow([AC_PACKAGE_VERSION])dnl
-AM_INIT_AUTOMAKE([NO-DEFINE])
-
-dnl This is so we can use kde-common
-
-dnl includes kde build environment
-KDE_CREATE_LIBS_ALIASES
-
-AC_ENABLE_SHARED(yes)
-AC_ENABLE_STATIC(no)
-KDE_PROG_LIBTOOL
-
-m4_pattern_allow([AC_PATH_QT])dnl
-AC_PATH_QT()
-AC_SUBST(all_includes)
-AC_SUBST(all_libraries)
-
-dnl =======================================================
-dnl FILE: ./smoke/configure.in.in
-dnl =======================================================
-
-AC_ARG_WITH(
-   smoke,
-   [  --with-smoke@<:@=qt|kde@:>@   Smoke: build Smoke for qt+kde or qt only @<:@default:qt@:>@],
-   [ kde_build_libsmoke="$withval" ],
-   [ kde_build_libsmoke="qt" ]
-)
-AC_SUBST(kde_build_libsmoke)
-
-dnl =======================================================
-dnl FILE: ./smoke/kde/configure.in.in
-dnl =======================================================
-
-
-#AC_HAVE_GL
-#KDE_HAVE_GL=yes;
-#if test "X$GLLIB" = "X"; then
-#    KDE_HAVE_GL=no
-#fi
-#
-#AC_SUBST(KDE_HAVE_GL)   
-#
-#KDE_PREFIX=`$KDECONFIG --prefix --expandvars`
-#AC_SUBST(KDE_PREFIX)
-#
-#if test "X$kde_build_libsmoke" = "Xkde" -o "X$kde_build_libsmoke" = "Xqt kde"; then
-#
-#    AC_CONFIG_FILES([ smoke/kde/qtguess.pl ], [
-#        cd smoke/kde
-#        perl qtguess.pl
-#        cd ../..
-#    ])
-#    AC_CONFIG_FILES([ smoke/kde/generate.pl ], [
-#        cd smoke/kde
-#        perl generate.pl
-#        cd ../..
-#    ])
-#fi
-
-dnl =======================================================
-dnl FILE: ./smoke/qt/configure.in.in
-dnl =======================================================
-
-
-#AC_HAVE_GL
-#KDE_HAVE_GL=yes;
-#if test "X$GLLIB" = "X"; then
-#    KDE_HAVE_GL=no
-#fi
-
-#AC_SUBST(KDE_HAVE_GL)   
-
-AC_ARG_WITH(
-   threshold,
-   [  --with-threshold@<:@=0..15@:>@  Smoke: Qt tests threshold Default:10 Lower=more tests],
-   [ qt_test_threshold="$withval" ],
-   [ qt_test_threshold=10 ]
-)
-AC_SUBST(qt_test_threshold)
-
-if test "X$kde_build_libsmoke" = "Xqt" -o "X$kde_build_libsmoke" = "Xqt kde"; then
-
-    AC_CONFIG_FILES([ smoke/qt/qtguess.pl ], [
-        cd smoke/qt
-        perl qtguess.pl
-        cd ../..
-    ])
-    AC_CONFIG_FILES([ smoke/qt/generate.pl ], [
-        cd smoke/qt
-        perl generate.pl
-        cd ../..
-    ])
-fi
-
-AC_CONFIG_FILES([ smoke/Makefile ])
-AC_CONFIG_FILES([ smoke/qt/Makefile ])
-
-KDE_CREATE_SUBDIRSLIST
-#AM_CONDITIONAL(smoke_SUBDIR_included, test "x$smoke_SUBDIR_included" = xyes)
-
-PHP_ARG_WITH(php_qt, for php_qt,
-[  --enable-php_qt         Enable PHP-Qt support])
-
-if test "$PHP_PHP_QT" != "no"; then
-
-  PHP_QT_DIR="$qt_incdir";
-  smoke_libraries="$LIB_QTCORE \
-		   $LIB_QTGUI \
-		   $LIB_QTNETWORK \
-		   $LIB_QTOPENGL \
-		   $LIB_QTSQL \
-		   $LIB_QTCORE \
-		   $LIB_QTXML \
-		   $GLLIB \
-		   $LIBQSCINTILLA \
-		    -lQtSvg \
-		    -lQtUiTools"
-
-  LDFLAGS="$LDFLAGS $all_libraries $USER_LDFLAGS $LIBQT $smoke_libraries"
-  PHP_REQUIRE_CXX
-
-  PHP_ADD_INCLUDE($PHP_QT_DIR/include)
-  PHP_ADD_INCLUDE($PHP_QT_DIR)
-  PHP_ADD_INCLUDE($PHP_QT_DIR/Qt3Support)
-  PHP_ADD_INCLUDE($PHP_QT_DIR/QtAssistant)
-  PHP_ADD_INCLUDE($PHP_QT_DIR/QtCore)
-  PHP_ADD_INCLUDE($PHP_QT_DIR/QtDesigner)
-  PHP_ADD_INCLUDE($PHP_QT_DIR/QtGui)
-  PHP_ADD_INCLUDE($PHP_QT_DIR/QtNetwork)
-  PHP_ADD_INCLUDE($PHP_QT_DIR/QtOpenGL)
-  PHP_ADD_INCLUDE($PHP_QT_DIR/QtSql)
-  PHP_ADD_INCLUDE($PHP_QT_DIR/QtSvg)
-  PHP_ADD_INCLUDE($PHP_QT_DIR/QtTest)
-  PHP_ADD_INCLUDE($PHP_QT_DIR/QtUiTools)
-  PHP_ADD_INCLUDE($PHP_QT_DIR/QtXml)  
-  PHP_ADD_INCLUDE(smoke/)
-
-  PHP_ADD_SOURCES_X(smoke/qt, \
-    x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
-    x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
-    x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp \
-    smokedata.cpp,,shared_objects_php_qt,yes)
-
-  PHP_NEW_EXTENSION(php_qt, php_qt/smokephp.cpp php_qt/php_qt.cpp php_qt/functions.cpp,$ext_shared,cli)
-  PHP_ADD_BUILD_DIR($ext_builddir/php_qt)
-
-fi

Modified: trunk/examples/calculator/calculator.php
===================================================================
--- trunk/examples/calculator/calculator.php	2007-06-06 13:07:07 UTC (rev 328)
+++ trunk/examples/calculator/calculator.php	2007-06-06 18:43:35 UTC (rev 329)
@@ -169,7 +169,7 @@
                     }
                     return true;
                 }
-            }
+            }//check_qobject($target);
             return parent::eventFilter($target, $event);
         }
 

Deleted: trunk/kdeize
===================================================================
--- trunk/kdeize	2007-06-06 13:07:07 UTC (rev 328)
+++ trunk/kdeize	2007-06-06 18:43:35 UTC (rev 329)
@@ -1,6 +0,0 @@
-#!/bin/bash
-
-mv -f aclocal.m4 admin/phpize.m4.in
-admin/cvs.sh cvs
-
-

Modified: trunk/php_qt/marshall_basetypes.h
===================================================================
--- trunk/php_qt/marshall_basetypes.h	2007-06-06 13:07:07 UTC (rev 328)
+++ trunk/php_qt/marshall_basetypes.h	2007-06-06 18:43:35 UTC (rev 329)
@@ -144,7 +144,11 @@
 			smokephp_object* o = phpqt_createOriginal(m->var(), p);
 			// overwrite the old one:
 			*(m->return_value_ptr()) = o->zval_ptr;
-// 			*(m->var()) = *o->zval_ptr;
+
+			if(!strcmp(m->identifier, "VirtualMethodCall")){
+				// its a copy, not the original but well
+				ZVAL_ZVAL(((VirtualMethodCall*)m)->object(), o->zval_ptr, 0, 1);
+			}
 		}
 		return;
 

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-06-06 13:07:07 UTC (rev 328)
+++ trunk/php_qt/marshall_types.cpp	2007-06-06 18:43:35 UTC (rev 329)
@@ -417,11 +417,18 @@
 zval*
 VirtualMethodCall::var()
 {
-// 	*_sp[_cur] = (zval*) emalloc(sizeof(zval));
 	ZVAL_NULL(__sp[_cur]);
     return __sp[_cur];
 }
 
+zval*
+VirtualMethodCall::object()
+{
+	ZVAL_NULL(__sp[_cur]);
+	__sp[_cur]->type = IS_OBJECT;
+    return __sp[_cur];
+}
+
 int
 VirtualMethodCall::items()
 {

Modified: trunk/php_qt/marshall_types.h
===================================================================
--- trunk/php_qt/marshall_types.h	2007-06-06 13:07:07 UTC (rev 328)
+++ trunk/php_qt/marshall_types.h	2007-06-06 18:43:35 UTC (rev 329)
@@ -132,10 +132,13 @@
 	~VirtualMethodCall();
 	Marshall::Action action();
 	zval* var();
+	zval* object();
 	int items();
 	void callMethod();
 	bool cleanup();
 
+	bool makeObject;
+
 private:
 	zval* _obj;
  	zval **__sp;

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-06 13:07:07 UTC (rev 328)
+++ trunk/php_qt/php_qt.cpp	2007-06-06 18:43:35 UTC (rev 329)
@@ -431,7 +431,6 @@
     // nonstaticphp_qt_generic_class_proxyMethod
     if(getThis()){
     	activeScope = getThis();
-
 		// if a parent:: call occurs this_ptr has the wrong ce, so we need to
 		// correct it here
 		if(parentCall)
@@ -523,6 +522,7 @@
 			{
 				parentCall = true;
 				this_ptr = activeScope;
+//   				this_ptr->type = IS_OBJECT;
 			}
 		}
 	}
@@ -1047,5 +1047,6 @@
 	Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
 	zval_ptr = o->zval_ptr;
 	zval_add_ref(&zval_ptr);
+
 	return o;
 }

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-06-06 13:07:07 UTC (rev 328)
+++ trunk/php_qt/php_qt.h	2007-06-06 18:43:35 UTC (rev 329)
@@ -297,10 +297,6 @@
 ZEND_METHOD(php_qt_generic_class, proxyMethod);
 ZEND_METHOD(php_qt_generic_class, staticProxyMethod);
 
-// smoke stuff
-
-
-
 // ZEND stuff
 
 static int zend_check_symbol(zval **pz TSRMLS_DC)

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-06-06 13:07:07 UTC (rev 328)
+++ trunk/php_qt/smokephp.cpp	2007-06-06 18:43:35 UTC (rev 329)
@@ -82,9 +82,10 @@
 		}
 
 		if(phpqt_methodExists(o->ce_ptr, (char*) methodName)){
-			zval* zmem = ALLOCA_N(zval, smoke->methods[method].numArgs);
+// 			zval* zmem = ALLOCA_N(zval, smoke->methods[method].numArgs);
+			zval* zmem = (zval*) safe_emalloc(sizeof(zval), smoke->methods[method].numArgs,0);
 		    VirtualMethodCall c(smoke, method, args, o->zval_ptr, &zmem, &o->zval_ptr);
-		    c.next();
+			c.next();
 		}
 
 		return false;

Modified: trunk/svn-commit.tmp
===================================================================
--- trunk/svn-commit.tmp	2007-06-06 13:07:07 UTC (rev 328)
+++ trunk/svn-commit.tmp	2007-06-06 18:43:35 UTC (rev 329)
@@ -1,4 +1,15 @@
+* major code cleaning
 
 --This line, and those below, will be ignored--
 
-D    svn+ssh://tm243 at svn.berlios.de/svnroot/repos/php-qt/build
+D    config.m4
+D    admin
+M    php_qt/php_qt.h
+M    php_qt/smokephp.cpp
+M    php_qt/marshall_basetypes.h
+M    php_qt/marshall_types.cpp
+M    php_qt/php_qt.cpp
+M    php_qt/marshall_types.h
+D    TODO
+D    kdeize
+M    examples/calculator/calculator.php



From tm243 at mail.berlios.de  Wed Jun  6 21:59:59 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 6 Jun 2007 21:59:59 +0200
Subject: [Php-qt-svn] r330 - in trunk: . php_qt
Message-ID: <200706061959.l56JxxOw029825@sheep.berlios.de>

Author: tm243
Date: 2007-06-06 21:59:58 +0200 (Wed, 06 Jun 2007)
New Revision: 330

Added:
   trunk/php_qt/zend_handlers.cpp
   trunk/php_qt/zend_handlers.h
Modified:
   trunk/php_qt/CMakeLists.txt
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/svn-commit.tmp
Log:
* moved zend handlers into a seperate file



Modified: trunk/php_qt/CMakeLists.txt
===================================================================
--- trunk/php_qt/CMakeLists.txt	2007-06-06 18:43:35 UTC (rev 329)
+++ trunk/php_qt/CMakeLists.txt	2007-06-06 19:59:58 UTC (rev 330)
@@ -16,6 +16,7 @@
 set(phpqt_LIB_SRCS
     functions.cpp
     php_qt.cpp
+    zend_handlers.cpp
     smokephp.cpp
     qstring.cpp
     marshall_types.cpp

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-06 18:43:35 UTC (rev 329)
+++ trunk/php_qt/php_qt.cpp	2007-06-06 19:59:58 UTC (rev 330)
@@ -1,7 +1,7 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2006
+ * Copyright (C) 2006 - 2007
  * Thomas Moenicke <thomas.moenicke at kdemail.net>
  * Katrina Niolet <katrina at niolet.name>
  *
@@ -21,7 +21,7 @@
  *
  */
 
-#include <zend_interfaces.h>
+
 #include "php_qt.h"
 #include "ext/standard/php_string.h"
 
@@ -29,6 +29,7 @@
 
 #include "marshall.h"
 #include "php_qt.h"
+#include "zend_handlers.h"
 #include "smokephp.h"
 #include "smoke.h"
 #include "marshall_types.h"
@@ -47,20 +48,17 @@
 HashTable php_qt_objptr_hash;
 
 // object handler
-static zend_object_handlers php_qt_handler;
-static zend_object_handlers zend_orig_handler;
+zend_object_handlers php_qt_handler;
+zend_object_handlers zend_orig_handler;
 
 PHP_INI_BEGIN()
     PHP_INI_ENTRY("qt.codec", "UTF8", PHP_INI_ALL, NULL)
 PHP_INI_END()
 
-// opcode handler
-#define PHPQT_OPHANDLER_COUNT				((25 * 151) + 1)
-#define EX__(element) execute_data->element
-#define EX_T(offset) (*(temp_variable *)((char *) EX__(Ts) + offset))
-static opcode_handler_t *phpqt_original_opcode_handlers;
-static opcode_handler_t phpqt_opcode_handlers[PHPQT_OPHANDLER_COUNT];
+int (*originalConstantMethodHandler)(ZEND_OPCODE_HANDLER_ARGS);
 
+opcode_handler_t *phpqt_original_opcode_handlers;
+opcode_handler_t phpqt_opcode_handlers[PHPQT_OPHANDLER_COUNT];
 
 /*! php_qt_functions[]
  *
@@ -144,163 +142,7 @@
 extern zend_class_entry* qstring_ce;
 extern void 	_register_QString();
 
-/*!
- *	constant method handler
- *
- *	here we'll try to find a defined static method in Qt and assign the
- *  staticProxyMethod handler
- *  see ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_HANDLER in zend_vm_execute.h
- */
-#undef EX
-#define EX(element) execute_data->element
-
-static int (*originalConstantMethodHandler)(ZEND_OPCODE_HANDLER_ARGS);
-
-static int constantMethodHandler(ZEND_OPCODE_HANDLER_ARGS)
-{
-	zend_op *opline = EX(opline);
-	zend_class_entry *ce = EX_T(opline->op1.u.var).class_entry;
-	union _zend_function *fbc;
-	zval* function_name;
-	char* function_name_strval;
-	int function_name_strlen;
-
-	function_name = &opline->op2.u.constant;
-	// store the active ce
-	activeCe = EX_T(opline->op1.u.var).class_entry;
-
-	if (Z_TYPE_P(function_name) != IS_STRING) {
-		zend_error_noreturn(E_ERROR, "Function name must be a string");
-	}
-
-	// get method name
-  	function_name_strval = zend_str_tolower_dup(function_name->value.str.val, function_name->value.str.len);
- 	function_name_strlen = function_name->value.str.len;
-
-	// call proxyMethod if method is not defined in userspace
-	if(zend_hash_find(&ce->function_table, function_name_strval, function_name_strlen+1, (void**) &fbc) == FAILURE)
-	{
-		zend_ptr_stack_3_push(&EG(arg_types_stack), EX(fbc), EX(object), NULL);
-		zend_bool is_const = (IS_CONST == IS_CONST);
-
-		if(zend_hash_find(&ce->function_table, "staticproxymethod", 18, (void**) &fbc) != FAILURE)
-		{
-
-			//! TODO	darn! we have a lowersized string here!
-			const char* methodName = PQ::findRealMethodName( function_name->value.str.val );
-			methodNameStack.push( new QByteArray( methodName ) );
-
-			EX(fbc) = fbc;
-
-			if(!is_const){ efree(function_name_strval); }
-			EX(opline)++;
-			ZEND_VM_CONTINUE();
-
-		}
-
-		if(!is_const){ efree(function_name_strval); }
-
-	}  // end try call proxyMethod
-
-  	return originalConstantMethodHandler(execute_data);
-
-}
-
-
-/*!
- *	constants handler
- */
-
-static int constantHandler(ZEND_OPCODE_HANDLER_ARGS) {
-
-	zend_op *opline = EX__(opline);
-	zend_class_entry *ce = NULL;
-	zval **value;
-
-	if (IS_CONST == IS_UNUSED) {
-		if (!zend_get_constant(opline->op2.u.constant.value.str.val, opline->op2.u.constant.value.str.len, &EX_T(opline->result.u.var).tmp_var TSRMLS_CC)) {
-			zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'",
-						opline->op2.u.constant.value.str.val,
-						opline->op2.u.constant.value.str.val);
-			EX_T(opline->result.u.var).tmp_var = opline->op2.u.constant;
-			zval_copy_ctor(&EX_T(opline->result.u.var).tmp_var);
-		}
-		execute_data->opline++;
-	}
-
-	ce = EX_T(opline->op1.u.var).class_entry;
-
-	if (zend_hash_find(&ce->constants_table, opline->op2.u.constant.value.str.val, opline->op2.u.constant.value.str.len+1, (void **) &value) == SUCCESS) {
-		zval_update_constant(value, (void *) 1 TSRMLS_CC);
-		EX_T(opline->result.u.var).tmp_var = **value;
-		zval_copy_ctor(&EX_T(opline->result.u.var).tmp_var);
-	} else {
-		// enums are methods here
-		Smoke::Index method = PQ::smoke()->findMethod(ce->name, opline->op2.u.constant.value.str.val);
-		if(method <= 0) // smoke could not find one
-		    php_error(E_ERROR, "undefined class constant '%s'", opline->op2.u.constant.value.str.val);
-
-		method = PQ::smoke()->methodMaps[method].method;
-
-		// get the Qt value
-		Smoke::Stack args = (Smoke::Stack) safe_emalloc(1, sizeof(Smoke::Stack), 0);
-		void* dummy; // dummy here
-		smokephp_callMethod(dummy, method, args);
-
-		// write the zend return value
-		zval* return_value;
-		MAKE_STD_ZVAL(return_value);
-		ZVAL_LONG(return_value, args[0].s_enum);
-		EX_T(opline->result.u.var).tmp_var = *return_value;
-		zval_copy_ctor(&EX_T(opline->result.u.var).tmp_var);
-
-		efree(args);
-
-	}
-
-	execute_data->opline++;
-	return 0;
-
-}
-
 /**
- *	proxy handler
- */
-
-union _zend_function* proxyHandler(zval **obj_ptr, char* methodName, int methodName_len TSRMLS_DC)
-{
-    union _zend_function *fbc;
-
-    // overwritten protected Qt methods wont work until we cheat here
-    int method_len = strlen(methodName);
-    char* lc_method_name = (char*) do_alloca(method_len+1);
-    zend_str_tolower_copy(lc_method_name, methodName, method_len);
-    // get the zend object and the function pointer
-    zend_object *zobj = zend_objects_get_address(*obj_ptr TSRMLS_CC);
-    if (zend_hash_find(&zobj->ce->function_table, lc_method_name, method_len+1, (void **)&fbc) != FAILURE)
-    {
-		if(fbc->common.fn_flags & ZEND_ACC_PROTECTED)
-		{
-			if(PQ::smoke()->idMethodName(methodName) > 0)
-			{
-				fbc->common.fn_flags = ZEND_ACC_PUBLIC;
-			}
-		}
-    }
-
-    // a try for non-Qt objects
-    fbc = zend_orig_handler.get_method(obj_ptr, methodName, methodName_len);
-    if(!fbc) // maybe a Qt object
-    {
-        methodNameStack.push(new QByteArray(methodName));
-	    // call proxy
-	    fbc = zend_orig_handler.get_method(obj_ptr, "proxyMethod", 11);
-    }
-
-    return fbc;
-}
-
-/**
  *	generic object
  */
 
@@ -324,15 +166,11 @@
 
 ZEND_METHOD(php_qt_generic_class, __destruct)
 {
-// qDebug() << "__destruct" << getThis() << PZVAL_IS_REF(getThis());
 	if(phpqt_SmokePHPObjectExists(getThis())) {
 
  		smokephp_object *o = phpqt_getSmokePHPObjectFromZval(getThis());
 
-// qDebug() << (o->zval_ptr == getThis());
-// qDebug() << "__destruct" << (o->zval_ptr == getThis()) << getThis() << o->zval_ptr;
 		// its not a reference
-// 		if(getThis() == o->zval_ptr)
 		if(!PZVAL_IS_REF(getThis()))
 		{
 			o->allocated = false;
@@ -342,7 +180,6 @@
 			qFatal("try to unmap unregistered zval");
 		}
 
-//check_qobject(getThis());
 	}
 }
 

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-06-06 18:43:35 UTC (rev 329)
+++ trunk/php_qt/php_qt.h	2007-06-06 19:59:58 UTC (rev 330)
@@ -167,8 +167,8 @@
 
 const char* 		printType(int type);
 
-union _zend_function* proxyHandler(zval **obj_ptr, char* methodName, int methodName_len TSRMLS_DC);
 
+
 extern Smoke* qt_Smoke;
 class PQ
 {

Added: trunk/php_qt/zend_handlers.cpp
===================================================================
--- trunk/php_qt/zend_handlers.cpp	2007-06-06 18:43:35 UTC (rev 329)
+++ trunk/php_qt/zend_handlers.cpp	2007-06-06 19:59:58 UTC (rev 330)
@@ -0,0 +1,185 @@
+/*!
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006
+ * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Katrina Niolet <katrina at niolet.name>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+#include "zend_handlers.h"
+#include "php_qt.h"
+#include "ext/standard/php_string.h"
+
+extern zend_object_handlers php_qt_handler;
+extern zend_object_handlers zend_orig_handler;
+extern QStack<QByteArray*> methodNameStack;
+extern opcode_handler_t *phpqt_original_opcode_handlers;
+extern opcode_handler_t phpqt_opcode_handlers[PHPQT_OPHANDLER_COUNT];
+extern zend_class_entry* activeCe;
+extern int (*originalConstantMethodHandler)(ZEND_OPCODE_HANDLER_ARGS);
+
+/**
+ *	proxy handler
+ */
+
+union _zend_function* proxyHandler(zval **obj_ptr, char* methodName, int methodName_len TSRMLS_DC)
+{
+    union _zend_function *fbc;
+
+    // overwritten protected Qt methods wont work until we cheat here
+    int method_len = strlen(methodName);
+    char* lc_method_name = (char*) do_alloca(method_len+1);
+    zend_str_tolower_copy(lc_method_name, methodName, method_len);
+    // get the zend object and the function pointer
+    zend_object *zobj = zend_objects_get_address(*obj_ptr TSRMLS_CC);
+    if (zend_hash_find(&zobj->ce->function_table, lc_method_name, method_len+1, (void **)&fbc) != FAILURE)
+    {
+		if(fbc->common.fn_flags & ZEND_ACC_PROTECTED)
+		{
+			if(PQ::smoke()->idMethodName(methodName) > 0)
+			{
+				fbc->common.fn_flags = ZEND_ACC_PUBLIC;
+			}
+		}
+    }
+
+    // a try for non-Qt objects
+    fbc = zend_orig_handler.get_method(obj_ptr, methodName, methodName_len);
+    if(!fbc) // maybe a Qt object
+    {
+        methodNameStack.push(new QByteArray(methodName));
+	    // call proxy
+	    fbc = zend_orig_handler.get_method(obj_ptr, "proxyMethod", 11);
+    }
+
+    return fbc;
+}
+
+/*!
+ *	constants handler
+ */
+
+int constantHandler(ZEND_OPCODE_HANDLER_ARGS) {
+
+	zend_op *opline = EX__(opline);
+	zend_class_entry *ce = NULL;
+	zval **value;
+
+	if (IS_CONST == IS_UNUSED) {
+		if (!zend_get_constant(opline->op2.u.constant.value.str.val, opline->op2.u.constant.value.str.len, &EX_T(opline->result.u.var).tmp_var TSRMLS_CC)) {
+			zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'",
+						opline->op2.u.constant.value.str.val,
+						opline->op2.u.constant.value.str.val);
+			EX_T(opline->result.u.var).tmp_var = opline->op2.u.constant;
+			zval_copy_ctor(&EX_T(opline->result.u.var).tmp_var);
+		}
+		execute_data->opline++;
+	}
+
+	ce = EX_T(opline->op1.u.var).class_entry;
+
+	if (zend_hash_find(&ce->constants_table, opline->op2.u.constant.value.str.val, opline->op2.u.constant.value.str.len+1, (void **) &value) == SUCCESS) {
+		zval_update_constant(value, (void *) 1 TSRMLS_CC);
+		EX_T(opline->result.u.var).tmp_var = **value;
+		zval_copy_ctor(&EX_T(opline->result.u.var).tmp_var);
+	} else {
+		// enums are methods here
+		Smoke::Index method = PQ::smoke()->findMethod(ce->name, opline->op2.u.constant.value.str.val);
+		if(method <= 0) // smoke could not find one
+		    php_error(E_ERROR, "undefined class constant '%s'", opline->op2.u.constant.value.str.val);
+
+		method = PQ::smoke()->methodMaps[method].method;
+
+		// get the Qt value
+		Smoke::Stack args = (Smoke::Stack) safe_emalloc(1, sizeof(Smoke::Stack), 0);
+		void* dummy; // dummy here
+		smokephp_callMethod(dummy, method, args);
+
+		// write the zend return value
+		zval* return_value;
+		MAKE_STD_ZVAL(return_value);
+		ZVAL_LONG(return_value, args[0].s_enum);
+		EX_T(opline->result.u.var).tmp_var = *return_value;
+		zval_copy_ctor(&EX_T(opline->result.u.var).tmp_var);
+
+		efree(args);
+
+	}
+
+	execute_data->opline++;
+	return 0;
+
+}
+
+/*!
+ *  here we'll try to find a static method defined in Qt and
+ *  to assign the staticProxyMethod handler
+ *  see ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_HANDLER in zend_vm_execute.h
+ */
+
+int constantMethodHandler(ZEND_OPCODE_HANDLER_ARGS)
+{
+	zend_op *opline = EX(opline);
+	zend_class_entry *ce = EX_T(opline->op1.u.var).class_entry;
+	union _zend_function *fbc;
+	zval* function_name;
+	char* function_name_strval;
+	int function_name_strlen;
+
+	function_name = &opline->op2.u.constant;
+	// store the active ce
+	activeCe = EX_T(opline->op1.u.var).class_entry;
+
+	if (Z_TYPE_P(function_name) != IS_STRING) {
+		zend_error_noreturn(E_ERROR, "Function name must be a string");
+	}
+
+	// get method name
+  	function_name_strval = zend_str_tolower_dup(function_name->value.str.val, function_name->value.str.len);
+ 	function_name_strlen = function_name->value.str.len;
+
+	// call proxyMethod if method is not defined in userspace
+	if(zend_hash_find(&ce->function_table, function_name_strval, function_name_strlen+1, (void**) &fbc) == FAILURE)
+	{
+		zend_ptr_stack_3_push(&EG(arg_types_stack), EX(fbc), EX(object), NULL);
+		zend_bool is_const = (IS_CONST == IS_CONST);
+
+		if(zend_hash_find(&ce->function_table, "staticproxymethod", 18, (void**) &fbc) != FAILURE)
+		{
+
+			//! TODO	darn! we have a lowersized string here!
+			const char* methodName = PQ::findRealMethodName( function_name->value.str.val );
+			methodNameStack.push( new QByteArray( methodName ) );
+
+			EX(fbc) = fbc;
+
+			if(!is_const){ efree(function_name_strval); }
+			EX(opline)++;
+			ZEND_VM_CONTINUE();
+
+		}
+
+		if(!is_const){ efree(function_name_strval); }
+
+	}  // end try call proxyMethod
+
+  	return originalConstantMethodHandler(execute_data);
+
+}
+

Added: trunk/php_qt/zend_handlers.h
===================================================================
--- trunk/php_qt/zend_handlers.h	2007-06-06 18:43:35 UTC (rev 329)
+++ trunk/php_qt/zend_handlers.h	2007-06-06 19:59:58 UTC (rev 330)
@@ -0,0 +1,57 @@
+/*!
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006
+ * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Katrina Niolet <katrina at niolet.name>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+
+#ifndef ZEND_HANDLERS_H
+#define ZEND_HANDLERS_H
+
+#include <zend_interfaces.h>
+
+// for opcode handler
+#define PHPQT_OPHANDLER_COUNT				((25 * 151) + 1)
+#define EX__(element) execute_data->element
+#define EX_T(offset) (*(temp_variable *)((char *) EX__(Ts) + offset))
+
+
+/*!
+ *	handler for regular method calls
+ */
+
+union _zend_function* proxyHandler(zval **obj_ptr, char* methodName, int methodName_len TSRMLS_DC);
+
+/*!
+ *	handler for constant method calls
+ *  and for the	parent:: statement too
+ */
+
+#undef EX
+#define EX(element) execute_data->element
+
+int constantMethodHandler(ZEND_OPCODE_HANDLER_ARGS);
+
+/*!
+ *	handler for constants
+ */
+
+int constantHandler(ZEND_OPCODE_HANDLER_ARGS);
+
+#endif

Modified: trunk/svn-commit.tmp
===================================================================
--- trunk/svn-commit.tmp	2007-06-06 18:43:35 UTC (rev 329)
+++ trunk/svn-commit.tmp	2007-06-06 19:59:58 UTC (rev 330)
@@ -1,15 +1,7 @@
-* major code cleaning
+* moved zend handlers into a seperate file
 
 --This line, and those below, will be ignored--
 
-D    config.m4
-D    admin
 M    php_qt/php_qt.h
-M    php_qt/smokephp.cpp
-M    php_qt/marshall_basetypes.h
-M    php_qt/marshall_types.cpp
 M    php_qt/php_qt.cpp
-M    php_qt/marshall_types.h
-D    TODO
-D    kdeize
-M    examples/calculator/calculator.php
+M    php_qt/CMakeLists.txt



From tm243 at mail.berlios.de  Wed Jun  6 22:00:31 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 6 Jun 2007 22:00:31 +0200
Subject: [Php-qt-svn] r331 - trunk
Message-ID: <200706062000.l56K0Vxk029913@sheep.berlios.de>

Author: tm243
Date: 2007-06-06 22:00:31 +0200 (Wed, 06 Jun 2007)
New Revision: 331

Removed:
   trunk/svn-commit.tmp
Log:
* why is a temp. file in svn?



Deleted: trunk/svn-commit.tmp
===================================================================
--- trunk/svn-commit.tmp	2007-06-06 19:59:58 UTC (rev 330)
+++ trunk/svn-commit.tmp	2007-06-06 20:00:31 UTC (rev 331)
@@ -1,7 +0,0 @@
-* moved zend handlers into a seperate file
-
---This line, and those below, will be ignored--
-
-M    php_qt/php_qt.h
-M    php_qt/php_qt.cpp
-M    php_qt/CMakeLists.txt



From tm243 at mail.berlios.de  Wed Jun  6 22:16:13 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 6 Jun 2007 22:16:13 +0200
Subject: [Php-qt-svn] r332 - trunk/php_qt
Message-ID: <200706062016.l56KGDou031329@sheep.berlios.de>

Author: tm243
Date: 2007-06-06 22:16:12 +0200 (Wed, 06 Jun 2007)
New Revision: 332

Modified:
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/zend_handlers.cpp
   trunk/php_qt/zend_handlers.h
Log:
* created an namespace ZendHandlers



Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-06 20:00:31 UTC (rev 331)
+++ trunk/php_qt/php_qt.cpp	2007-06-06 20:16:12 UTC (rev 332)
@@ -383,25 +383,7 @@
 	le_php_qt_hashtype = zend_register_list_destructors_ex(phpqt_destroyHashtable, NULL, "PHP-Qt object list", module_number);
 	zend_hash_init_ex(&php_qt_objptr_hash, PHPQT_CLASS_COUNT, NULL, NULL, 1, 0);
 
-	// overwrite method handler
-	php_qt_handler = *zend_get_std_object_handlers();
-	zend_orig_handler = php_qt_handler;
-	php_qt_handler.get_method = proxyHandler;
-
-	// overwrite :: operator, see zend_vm_execute.h
-	memcpy(phpqt_opcode_handlers, zend_opcode_handlers, sizeof(phpqt_opcode_handlers));
-	phpqt_original_opcode_handlers = zend_opcode_handlers;
-	zend_opcode_handlers = phpqt_opcode_handlers;
-	// ZEND_FETCH_CONSTANT = 99 => 2475
-	phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + 0] = constantHandler;
-	// replace and store ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_HANDLER
-	originalConstantMethodHandler = phpqt_opcode_handlers[2825];
-	phpqt_opcode_handlers[2825] = constantMethodHandler;
-	phpqt_opcode_handlers[2830] = constantMethodHandler;
-	phpqt_opcode_handlers[2835] = constantMethodHandler;
-	phpqt_opcode_handlers[2840] = constantMethodHandler;
-	phpqt_opcode_handlers[2845] = constantMethodHandler;
-
+	ZendHandlers::installZendHandlers();
 	smokephp_init();
 
 	// cache class entries

Modified: trunk/php_qt/zend_handlers.cpp
===================================================================
--- trunk/php_qt/zend_handlers.cpp	2007-06-06 20:00:31 UTC (rev 331)
+++ trunk/php_qt/zend_handlers.cpp	2007-06-06 20:16:12 UTC (rev 332)
@@ -38,7 +38,8 @@
  *	proxy handler
  */
 
-union _zend_function* proxyHandler(zval **obj_ptr, char* methodName, int methodName_len TSRMLS_DC)
+union _zend_function*
+ZendHandlers::proxyHandler(zval **obj_ptr, char* methodName, int methodName_len TSRMLS_DC)
 {
     union _zend_function *fbc;
 
@@ -75,7 +76,8 @@
  *	constants handler
  */
 
-int constantHandler(ZEND_OPCODE_HANDLER_ARGS) {
+int
+ZendHandlers::constantHandler(ZEND_OPCODE_HANDLER_ARGS) {
 
 	zend_op *opline = EX__(opline);
 	zend_class_entry *ce = NULL;
@@ -133,7 +135,8 @@
  *  see ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_HANDLER in zend_vm_execute.h
  */
 
-int constantMethodHandler(ZEND_OPCODE_HANDLER_ARGS)
+int
+ZendHandlers::constantMethodHandler(ZEND_OPCODE_HANDLER_ARGS)
 {
 	zend_op *opline = EX(opline);
 	zend_class_entry *ce = EX_T(opline->op1.u.var).class_entry;
@@ -183,3 +186,27 @@
 
 }
 
+void
+ZendHandlers::installZendHandlers()
+{
+
+	// overwrite method handler
+	php_qt_handler = *zend_get_std_object_handlers();
+	zend_orig_handler = php_qt_handler;
+	php_qt_handler.get_method = proxyHandler;
+
+	// overwrite :: operator, see zend_vm_execute.h
+	memcpy(phpqt_opcode_handlers, zend_opcode_handlers, sizeof(phpqt_opcode_handlers));
+	phpqt_original_opcode_handlers = zend_opcode_handlers;
+	zend_opcode_handlers = phpqt_opcode_handlers;
+	// ZEND_FETCH_CONSTANT = 99 => 2475
+	phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + 0] = constantHandler;
+	// replace and store ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_HANDLER
+	originalConstantMethodHandler = phpqt_opcode_handlers[2825];
+	phpqt_opcode_handlers[2825] = constantMethodHandler;
+	phpqt_opcode_handlers[2830] = constantMethodHandler;
+	phpqt_opcode_handlers[2835] = constantMethodHandler;
+	phpqt_opcode_handlers[2840] = constantMethodHandler;
+	phpqt_opcode_handlers[2845] = constantMethodHandler;
+
+}

Modified: trunk/php_qt/zend_handlers.h
===================================================================
--- trunk/php_qt/zend_handlers.h	2007-06-06 20:00:31 UTC (rev 331)
+++ trunk/php_qt/zend_handlers.h	2007-06-06 20:16:12 UTC (rev 332)
@@ -31,6 +31,7 @@
 #define EX__(element) execute_data->element
 #define EX_T(offset) (*(temp_variable *)((char *) EX__(Ts) + offset))
 
+namespace ZendHandlers {
 
 /*!
  *	handler for regular method calls
@@ -54,4 +55,12 @@
 
 int constantHandler(ZEND_OPCODE_HANDLER_ARGS);
 
+/*!
+ *	install handlers
+ */
+
+void installZendHandlers();
+
+} // namespace ZendHandlers
+
 #endif



From tm243 at mail.berlios.de  Wed Jun  6 22:23:53 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 6 Jun 2007 22:23:53 +0200
Subject: [Php-qt-svn] r333 - trunk/php_qt
Message-ID: <200706062023.l56KNrT8031884@sheep.berlios.de>

Author: tm243
Date: 2007-06-06 22:23:52 +0200 (Wed, 06 Jun 2007)
New Revision: 333

Modified:
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/zend_handlers.cpp
Log:
* linker symbols cleaned up



Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-06 20:16:12 UTC (rev 332)
+++ trunk/php_qt/php_qt.cpp	2007-06-06 20:23:52 UTC (rev 333)
@@ -48,18 +48,12 @@
 HashTable php_qt_objptr_hash;
 
 // object handler
-zend_object_handlers php_qt_handler;
-zend_object_handlers zend_orig_handler;
+extern zend_object_handlers php_qt_handler;
 
 PHP_INI_BEGIN()
     PHP_INI_ENTRY("qt.codec", "UTF8", PHP_INI_ALL, NULL)
 PHP_INI_END()
 
-int (*originalConstantMethodHandler)(ZEND_OPCODE_HANDLER_ARGS);
-
-opcode_handler_t *phpqt_original_opcode_handlers;
-opcode_handler_t phpqt_opcode_handlers[PHPQT_OPHANDLER_COUNT];
-
 /*! php_qt_functions[]
  *
  * Every user visible function must have an entry in php_qt_functions[].

Modified: trunk/php_qt/zend_handlers.cpp
===================================================================
--- trunk/php_qt/zend_handlers.cpp	2007-06-06 20:16:12 UTC (rev 332)
+++ trunk/php_qt/zend_handlers.cpp	2007-06-06 20:23:52 UTC (rev 333)
@@ -26,14 +26,16 @@
 #include "php_qt.h"
 #include "ext/standard/php_string.h"
 
-extern zend_object_handlers php_qt_handler;
-extern zend_object_handlers zend_orig_handler;
 extern QStack<QByteArray*> methodNameStack;
-extern opcode_handler_t *phpqt_original_opcode_handlers;
-extern opcode_handler_t phpqt_opcode_handlers[PHPQT_OPHANDLER_COUNT];
 extern zend_class_entry* activeCe;
-extern int (*originalConstantMethodHandler)(ZEND_OPCODE_HANDLER_ARGS);
 
+zend_object_handlers php_qt_handler;
+zend_object_handlers zend_orig_handler;
+int (*originalConstantMethodHandler)(ZEND_OPCODE_HANDLER_ARGS);
+opcode_handler_t *phpqt_original_opcode_handlers;
+opcode_handler_t phpqt_opcode_handlers[PHPQT_OPHANDLER_COUNT];
+
+
 /**
  *	proxy handler
  */



From Katrina.Niolet at mail.berlios.de  Wed Jun  6 23:09:13 2007
From: Katrina.Niolet at mail.berlios.de (Katrina.Niolet at mail.berlios.de)
Date: Wed, 6 Jun 2007 23:09:13 +0200
Subject: [Php-qt-svn] r334 - trunk/php_qt
Message-ID: <200706062109.l56L9Drk002108@sheep.berlios.de>

Author: Katrina Niolet
Date: 2007-06-06 23:09:12 +0200 (Wed, 06 Jun 2007)
New Revision: 334

Modified:
   trunk/php_qt/zend_handlers.cpp
Log:
modified an error handler to work with PHP 5.2.1

Modified: trunk/php_qt/zend_handlers.cpp
===================================================================
--- trunk/php_qt/zend_handlers.cpp	2007-06-06 20:23:52 UTC (rev 333)
+++ trunk/php_qt/zend_handlers.cpp	2007-06-06 21:09:12 UTC (rev 334)
@@ -152,7 +152,7 @@
 	activeCe = EX_T(opline->op1.u.var).class_entry;
 
 	if (Z_TYPE_P(function_name) != IS_STRING) {
-		zend_error_noreturn(E_ERROR, "Function name must be a string");
+		php_error(E_ERROR, "Function name must be a string");
 	}
 
 	// get method name



From Katrina.Niolet at mail.berlios.de  Wed Jun  6 23:10:10 2007
From: Katrina.Niolet at mail.berlios.de (Katrina.Niolet at mail.berlios.de)
Date: Wed, 6 Jun 2007 23:10:10 +0200
Subject: [Php-qt-svn] r335 - trunk/php_qt
Message-ID: <200706062110.l56LAAsL002237@sheep.berlios.de>

Author: Katrina Niolet
Date: 2007-06-06 23:10:09 +0200 (Wed, 06 Jun 2007)
New Revision: 335

Modified:
   trunk/php_qt/php_qt.h
Log:
added include for zend.h

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-06-06 21:09:12 UTC (rev 334)
+++ trunk/php_qt/php_qt.h	2007-06-06 21:10:09 UTC (rev 335)
@@ -36,6 +36,7 @@
 #include <iostream>
 using namespace std;
 
+#include <zend.h>
 #include <zend_interfaces.h>
 #include "php.h"
 #include "php_ini.h"



From tm243 at mail.berlios.de  Wed Jun  6 23:19:57 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 6 Jun 2007 23:19:57 +0200
Subject: [Php-qt-svn] r336 - trunk/php_qt
Message-ID: <200706062119.l56LJv8U003373@sheep.berlios.de>

Author: tm243
Date: 2007-06-06 23:19:56 +0200 (Wed, 06 Jun 2007)
New Revision: 336

Added:
   trunk/php_qt/phpqt_internals.cpp
   trunk/php_qt/phpqt_internals.h
Modified:
   trunk/php_qt/CMakeLists.txt
   trunk/php_qt/functions.cpp
   trunk/php_qt/handlers.cpp
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/qstring.cpp
   trunk/php_qt/smokephp.cpp
Log:
* moved phpqt_*** functions into a separate file



Modified: trunk/php_qt/CMakeLists.txt
===================================================================
--- trunk/php_qt/CMakeLists.txt	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/CMakeLists.txt	2007-06-06 21:19:56 UTC (rev 336)
@@ -17,6 +17,7 @@
     functions.cpp
     php_qt.cpp
     zend_handlers.cpp
+    phpqt_internals.cpp
     smokephp.cpp
     qstring.cpp
     marshall_types.cpp

Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/functions.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -1,7 +1,7 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2006 
+ * Copyright (C) 2006
  * Thomas Moenicke <thomas.moenicke at kdemail.net>
  * Katrina Niolet <katrina at niolet.name>
  *
@@ -22,6 +22,7 @@
  */
 
 #include "php_qt.h"
+#include "phpqt_internals.h"
 
 extern Smoke *qt_Smoke;
 extern Smoke::Index qstring;
@@ -130,7 +131,7 @@
 
     if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz|", &obj, &cast_type) == FAILURE) {
         php_error(E_WARNING,"error while casting object, wrong parameters");
-        return; 
+        return;
     }
 
 	// just return the first argument
@@ -147,7 +148,7 @@
 PHP_FUNCTION(qDebug) {
 	const char* msg;
 	int msglen;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s",&msg,&msglen)==FAILURE) {
 		php_error(E_PARSE,"wrong parameters for qDebug");
 		return;
@@ -162,7 +163,7 @@
 PHP_FUNCTION(qWarning) {
 	const char* msg;
 	int msglen;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s",&msg,&msglen)==FAILURE) {
 		php_error(E_PARSE,"wrong parameters for qWarning");
 		return;
@@ -177,7 +178,7 @@
 PHP_FUNCTION(qCritical) {
 	const char* msg;
 	int msglen;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s",&msg,&msglen)==FAILURE) {
 		php_error(E_PARSE,"wrong parameters for qCritical");
 		return;
@@ -191,21 +192,21 @@
  */
 PHP_FUNCTION(qAbs) {
 	double x;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"d",&x)==FAILURE) {
 		php_error(E_PARSE,"wrong parameters for qAbs");
 		return;
 	}
 	RETURN_DOUBLE(0.0 >= x ? -x : x);
 }
-	
+
 /**
  * Returns this number rounded to the nearest integer
  * if decimal is greater than .5 it rounds up, otherwise it rounds down
  */
 PHP_FUNCTION(qRound) {
 	double x;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"d",&x)==FAILURE) {
 		php_error(E_PARSE,"wrong parameters for qRound");
 		return;
@@ -219,7 +220,7 @@
  */
 PHP_FUNCTION(qRound64) {
 	double x;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"d",&x)==FAILURE) {
 		php_error(E_PARSE,"wrong parameters for qRound");
 		return;
@@ -234,7 +235,7 @@
 PHP_FUNCTION(qMin) {
 	double x;
 	double y;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"dd",&x,&y)==FAILURE) {
 		php_error(E_PARSE,"wrong paramters for qMin");
 		return;
@@ -251,7 +252,7 @@
 PHP_FUNCTION(qMax) {
 	double x;
 	double y;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"dd",&x,&y)==FAILURE) {
 		php_error(E_PARSE,"wrong parameters for qMax");
 		return;
@@ -269,7 +270,7 @@
 	double min;
 	double val;
 	double max;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"ddd",&min,&val,&max)==FAILURE) {
 		php_error(E_PARSE,"wrong parameters for qBound");
 		return;
@@ -338,7 +339,7 @@
 	double x;
 	double y;
 	double ret;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"dd",&x,&y)==FAILURE) {
 		php_error(E_PARSE,"wrong parameters for qFuzzyCompare");
 		return;
@@ -346,7 +347,7 @@
 	//Just so happens the Qt version does just what we need for this one
 	RETURN_BOOL(qFuzzyCompare(x,y));
 }
-		
+
 /**
  * Returns true if variable is NULL or a numeric 0
  * This varies slightly from the Qt implementation which tests
@@ -354,7 +355,7 @@
  */
 PHP_FUNCTION(qIsNull) {
 	zval *var;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z",&var)==FAILURE) {
 		php_error(E_PARSE,"wrong parameters for qIsNull");
 		return;
@@ -380,7 +381,7 @@
  */
 PHP_FUNCTION(qIntCast) {
 	zval *var;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z",&var)==FAILURE)
 		return;
 	switch(Z_TYPE_P(var)) {
@@ -452,7 +453,7 @@
  */
 PHP_FUNCTION(qFree) {
 	zval* var;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z",&var)==FAILURE)
 		return;
 	convert_to_null(var);
@@ -481,17 +482,17 @@
 PHP_FUNCTION(qMemCopy) {
 	zval* dest;
 	zval* src;
-	
+
 	long size;
 	int src_orig_type;
 	int dest_orig_type;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzl",&dest,&src,&size)==FAILURE)
 		return;
 
 	src_orig_type = Z_TYPE_P(src);
 	dest_orig_type = Z_TYPE_P(dest);
-	
+
 	switch(Z_TYPE_P(src)) {
 		case IS_STRING:
 		case IS_LONG:
@@ -521,20 +522,20 @@
 PHP_FUNCTION(qt_noop) {}
 
 PHP_FUNCTION(qt_assert) {
-	
+
 	char* msg;
 	int msglen;
 	char* file;
 	int filelen;
 	int line;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s|sl",&msg,&msglen,&file,&filelen,&line)==FAILURE)
 		return;
 	php_error(E_ERROR,msg);
 }
 
 PHP_FUNCTION(qt_assert_x) {
-	
+
 	char* msg;
 	int msglen;
 	char* file;
@@ -544,7 +545,7 @@
 	char* what;
 	int whatlen;
 	int line;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s|sssl",&msg,&msglen,&where,&wherelen,&what,&whatlen,&file,&filelen,&line)==FAILURE)
 		return;
 	php_error(E_ERROR,msg);
@@ -552,9 +553,9 @@
 
 
 PHP_FUNCTION(Q_ASSERT) {
-	
+
 	bool cond;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"b",&cond)==FAILURE)
 		return;
 	if(!cond)
@@ -562,13 +563,13 @@
 }
 
 PHP_FUNCTION(Q_ASSERT_X) {
-	
+
 	bool cond;
 	char* where="";
 	int wherelen;
 	char* what="";
 	int whatlen;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"b|ss",&cond,&where,&wherelen,&what,&whatlen)==FAILURE) {
 		return;
 	}
@@ -581,13 +582,13 @@
 
 	char* file;
 	int line;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"|sl",&file,&line)==FAILURE)
 		return;
 	php_error(E_WARNING,"Out of memory");
 }
-		
-	
+
+
 /*!
  *	tr() returns QObject::tr()
  *

Modified: trunk/php_qt/handlers.cpp
===================================================================
--- trunk/php_qt/handlers.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/handlers.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -14,6 +14,7 @@
 #include "marshall.h"
 #include "php_qt.h"
 #include "smokephp.h"
+#include "phpqt_internals.h"
 
 extern zend_class_entry* qstring_ce;
 
@@ -101,11 +102,11 @@
 		case Marshall::FromZVAL:
 			marshall_from_php<T>(m);
 		break;
- 
+
 		case Marshall::ToZVAL:
 			marshall_to_php<T>( m );
 		break;
-				
+
 		default:
 			m->unsupported();
 		break;
@@ -124,15 +125,15 @@
 		case Smoke::t_char:
 			marshall_it<signed char>(m);
 		break;
-		
+
 		case Smoke::t_uchar:
 			marshall_it<unsigned char>(m);
 		break;
- 
+
 		case Smoke::t_short:
 			marshall_it<short>(m);
 		break;
-      
+
 		case Smoke::t_ushort:
 			marshall_it<unsigned short>(m);
 		break;
@@ -140,11 +141,11 @@
 		case Smoke::t_int:
 			marshall_it<int>(m);
 		break;
-		
+
 		case Smoke::t_uint:
 			marshall_it<unsigned int>(m);
 		break;
- 
+
 		case Smoke::t_long:
 			marshall_it<long>(m);
 		break;
@@ -152,7 +153,7 @@
 		case Smoke::t_ulong:
 			marshall_it<unsigned long>(m);
 		break;
- 
+
 		case Smoke::t_float:
 			marshall_it<float>(m);
 		break;
@@ -164,14 +165,14 @@
 		case Smoke::t_enum:
 			marshall_it<SmokeEnumWrapper>(m);
 		break;
-     
+
 		case Smoke::t_class:
 			marshall_it<SmokeClassWrapper>(m);
 		break;
 
 		default:
 			m->unsupported();
-		break;	
+		break;
 	}
 
 }
@@ -197,7 +198,7 @@
 static const char * KCODE = 0;
 static QTextCodec *codec = 0;
 
-void 
+void
 init_codec() {
 
 	KCODE = INI_ORIG_STR("qt.codec");
@@ -213,7 +214,7 @@
 }
 
 
-QString* 
+QString*
 qstringFromZString(zval* zstring) {
 	if (KCODE == 0) {
 		init_codec();
@@ -230,7 +231,7 @@
 	return new QString(QString::fromLocal8Bit(zstring->value.str.val, zstring->value.str.len));
 }
 
-zval* 
+zval*
 zstringFromQString(QString * s) {
 
 	if (KCODE == 0) {
@@ -292,7 +293,7 @@
 			phpqt_createObject(m->var(), (void*) s, qstring_ce, -1);
 		}
 		break;
- 
+
 		default:
 			m->unsupported();
 		break;
@@ -337,7 +338,7 @@
 	if(h == 0 && type.isConst() && strlen(type.name()) > strlen("const ")) {
 			h = type_handlers[type.name() + strlen("const ")];
 	}
-	
+
 	if(h != 0) {
 		return h->fn;
 	}

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/marshall_types.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -17,6 +17,7 @@
  ***************************************************************************/
 
 #include "marshall_types.h"
+#include "phpqt_internals.h"
 
 void
 smokeStackToQtStack(Smoke::Stack stack, void ** o, int items, MocArgument* args)

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/php_qt.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -33,6 +33,7 @@
 #include "smokephp.h"
 #include "smoke.h"
 #include "marshall_types.h"
+#include "phpqt_internals.h"
 
 #define DEBUG 1
 #define MOC_DEBUG 0
@@ -120,8 +121,6 @@
 ZEND_GET_MODULE(php_qt)
 #endif
 
-QHash<void*, smokephp_object*> SmokeQtObjects;
-QHash<zend_object_handle, smokephp_object*> obj_x_smokephp;
 QStack<QByteArray*> methodNameStack;
 
 zend_class_entry* activeCe;
@@ -132,7 +131,7 @@
 Smoke::Index qbool;
 Smoke::Index qstring;
 Smoke::Index qobject;
-zend_class_entry* qobject_ce;
+extern zend_class_entry* qobject_ce;
 extern zend_class_entry* qstring_ce;
 extern void 	_register_QString();
 
@@ -461,405 +460,3 @@
 
 	DISPLAY_INI_ENTRIES();
 }
-
-/*!
- *	PHP-Qt internal functions
- */
-
-int
-phpqt_metacall(smokephp_object* so, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a)
-{
-	QMetaObject* d = so->meta;
-//	int offset = d->methodOffset();
-	int offset = d->methodCount();
-
-#if MOC_DEBUG
-	cout << "qt_metacall " << so->ce_ptr->name << endl;
-#endif
-
-	// call the C++ one
-	if(_id < offset){
-		// find parent
-		Smoke::Index parent = so->smoke->inheritanceList[so->smoke->classes[so->classId].parents];
-
-		// methodId
-		Smoke::Index nameId = so->smoke->idMethodName("qt_metacall$$?");
-		Smoke::Index method = so->smoke->findMethod(so->classId, nameId);
-
-		if(method > 0){
-			Smoke::Method &m = so->smoke->methods[so->smoke->methodMaps[method].method];
-			Smoke::ClassFn fn = so->smoke->classes[m.classId].classFn;
-			Smoke::StackItem i[4];
-			i[1].s_enum = _c;
-			i[2].s_int = _id;
-			i[3].s_voidp = (void*) args[3].s_voidp;
-			(*fn)(m.method, so->ptr, i);
-
-#if MOC_DEBUG
-			cout << "\tcall Qt method " << so->ce_ptr->name << "::" << PQ::smoke()->methodNames[method] << endl;
-#endif
-
-			if((int)i[0].s_int < 0)
-				return i[0].s_int;
-
-		} else {
-			// should never happen
-			php_error(E_ERROR, "Cannot find %s::qt_metacall() method\n", d->className());
-		}
-
-	}
-
-    if (_c != QMetaObject::InvokeMetaMethod) {
-		return _id;
-	}
-
-	// try the PHP one
-	// eg _q_buttonPressed(), breaking at the first bracket
-	char* method_name = estrdup((d->method(_id)).signature());
-
-    for(int i = 0; i < strlen(method_name); i++){
-#define LEFT_PARENTHESIS 40
-        if(method_name[i] == LEFT_PARENTHESIS){
-            method_name[i] = 0;
-            break;
-        }
-    }
-
-    // is a Slot
-    if(d->method(_id).methodType() == QMetaMethod::Slot){
-
-        int j = 0;
-        zval*** args = (zval***) safe_emalloc(2, sizeof(zval*), 0);
-        QList<QByteArray> qargs = d->method(_id).parameterTypes();
-        for(int i = 0; i < qargs.count(); i++){
-            zval *arg;
-            MAKE_STD_ZVAL(arg);
-
-            // invoke to zend types
-            if(!strncmp("int",(const char*) qargs[i],3)){
-
-                ZVAL_LONG(arg, *reinterpret_cast< int*>(_a[i+1]));
-            } else if(!strncmp("char*",(const char*) qargs[i],5)){
-                ZVAL_STRING(arg, *reinterpret_cast< char**>(_a[i+1]), 1);
-            } else if(!strncmp("bool",(const char*) qargs[i],4)){
-                ZVAL_BOOL(arg, *reinterpret_cast< bool*>(_a[i+1]));
-            } else if(!strncmp("double",(const char*) qargs[i],4)){
-                ZVAL_DOUBLE(arg, *reinterpret_cast< double*>(_a[i+1]));
-            } else {
-                    // must be an object
-                    void* ptr = *reinterpret_cast< QObject**>(_a[1]);
-
-                    phpqt_createObject(arg, ptr, qobject_ce);
-            }
-
-            args[j++] = &arg;
-
-        }
-
-#if MOC_DEBUG
-    cout << "\tcall PHP method " << so->ce_ptr->name << "::" << method_name << endl;
-#endif
-
-         phpqt_callPHPMethod(so->zval_ptr, method_name, j, *args);
-
-    // is a signal
-    } else {
-        void *_b[] = { 0, _a[1] };
-        QMetaObject::activate((QObject*) so->ptr, d, 0, _b);
-    }
-
-	efree(method_name);
-    return _id;
-
-}
-
-static void
-phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc TSRMLS_DC)
-{
-#ifdef DEBUG
-	php_error(E_ERROR,"Hashtable destroyed. Shutdown PHP-Qt now.");
-#endif
-}
-
-bool
-phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname)
-{
-
-	if(ce_ptr == NULL){
-	  php_error(E_ERROR,"methodExists fatal error: no class entry");
-	}
-
-	char* lcname = zend_str_tolower_dup(methodname, strlen(methodname));
-
-	if(zend_hash_exists(&ce_ptr->function_table, lcname, strlen(methodname)+1)){
-		return true;
-	}
-
-	efree(lcname);
-	return false;
-
-}
-
-
-zval*
-phpqt_callPHPMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args)
-{
-
-	if(this_ptr == NULL){
-	  php_error(E_ERROR,"callmethod fatal error: object does not exists");
-	}
-
-    zval *function_name;
-    MAKE_STD_ZVAL(function_name);
-    ZVAL_STRING(function_name,methodName,1);
-
-    zval* retval;
-    MAKE_STD_ZVAL(retval);
-
-    if(call_user_function(EG(function_table),&this_ptr,function_name,retval,param_count,args) == FAILURE){
-    	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
-    	php_error(E_ERROR, "PHP-Qt could not call method %s::%s", o->ce_ptr->name, methodName);
-    }
-
-    return retval;
-}
-
-/*!
- *	creates metaObject data
- *  example: "QWidget\0\0value\0test(int)\0"
- *	@param	zval*				this_ptr	pointer of the zval
- *	@param	char*				classname	name of the class
- *	@param	const QMetaObject*	superdata	superdata
- *	@return	QMetaObject*
- */
-
-bool
-phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* meta, QString* meta_stringdata, uint* signature){
-
-    /// readout the slots table
-    zval **slotdata;
-
-    zval *zslot;
-    zslot = zend_read_property(Z_OBJCE_P(this_ptr),this_ptr,"slots",5,0);
-
-    zval *zsignal;
-    zsignal = zend_read_property(Z_OBJCE_P(this_ptr),this_ptr,"signals",7,0);
-
-    if((zslot)->type==IS_ARRAY && (zsignal)->type==IS_ARRAY ) {
-
-
-        HashTable* slots_hash = HASH_OF(zslot);
-        HashTable* signals_hash = HASH_OF(zsignal);
-
-        char* assocKey;
-        ulong numKey;
-
-        int signaturecount;
-        signaturecount = 2 + strlen(classname);
-
-#if MOC_DEBUG
-	QString *qr = new QString();
-	cout << "+== begin metaobject dump ==+\n";
-	cout << "\t" << classname << "\n\t1 0 0 0 " << zend_hash_num_elements(slots_hash)+zend_hash_num_elements(signals_hash) << " 10 0 0 0 0" << endl << endl;
-#endif
-
-		/// write class signature
-		signature[0] = 1;
-		signature[1] = 0;
-		signature[2] = 0;
-		signature[3] = 0;
-		signature[4] = zend_hash_num_elements(slots_hash)+zend_hash_num_elements(signals_hash);
-		signature[5] = 10;
-		signature[6] = 0;
-		signature[7] = 0;
-		signature[8] = 0;
-		signature[9] = 0;
-
-		/// write classname
-		meta_stringdata->append(classname);
- 		meta_stringdata->append(QChar::Null);
- 		meta_stringdata->append(QChar::Null);
-
-		int i;
-		i = 10;
-
-		zend_hash_internal_pointer_reset(signals_hash);
-
-		while(zend_hash_has_more_elements(signals_hash) == SUCCESS){
-
-			/// read slot from hashtable
-			zend_hash_get_current_key(signals_hash,&assocKey,&numKey,0);
-			zend_hash_get_current_data(signals_hash,(void**)&slotdata);
-
-#if MOC_DEBUG
-			qr->append(Z_STRVAL_PP(slotdata));
-			qr->append(" ");
-			cout << "\t" << signaturecount << "8 8 8 0x05 ::s" << endl;
-#endif
-
-			meta_stringdata->append(Z_STRVAL_PP(slotdata));
-			meta_stringdata->append(QChar::Null);
-
-			zend_hash_move_forward(signals_hash);
-
-			/// write slot signature
-			signature[i++] = signaturecount;
-			signature[i++] = 8;
-			signature[i++] = 8;
-			signature[i++] = 8;
-			signature[i++] = 0x05;
-
-			signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
-
-		}
-
-    	zend_hash_internal_pointer_reset(slots_hash);
-
-		while(zend_hash_has_more_elements(slots_hash) == SUCCESS){
-
-			/// read slot from hashtable
-			zend_hash_get_current_key(slots_hash,&assocKey,&numKey,0);
-			zend_hash_get_current_data(slots_hash,(void**)&slotdata);
-
-#if MOC_DEBUG
-			qr->append(Z_STRVAL_PP(slotdata));
-			qr->append(" ");
-			cout << "\t" << signaturecount << "8 8 8 0x0a ::s" << endl;
-#endif
-
-			meta_stringdata->append(Z_STRVAL_PP(slotdata));
-			meta_stringdata->append(QChar::Null);
-
-			zend_hash_move_forward(slots_hash);
-
-			/// write slot signature
-			signature[i++] = signaturecount;
-			signature[i++] = 8;
-			signature[i++] = 8;
-			signature[i++] = 8;
-			signature[i++] = 0x0a;
-
-			signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
-
-		}
-#if MOC_DEBUG
-		cout << qr->toAscii().constData() << endl;
-		cout << "+== end metaobject dump ==+" << endl;
-#endif
-		return true;
-	} else {
-		return false;
-  	}
-}
-
-char*
-phpqt_checkForOperator(const char* fname){
-	return (char*) fname;
-}
-
-bool
-phpqt_SmokePHPObjectExists(zval* this_ptr)
-{
-	return obj_x_smokephp.contains(this_ptr->value.obj.handle);
-}
-
-smokephp_object*
-phpqt_getSmokePHPObjectFromZval(zval* this_ptr)
-{
-
-	if(this_ptr == NULL){
-	  php_error(E_ERROR,"fatal: object does not exists and could not be fetched, %s",Z_OBJCE_P(this_ptr)->name);
-	}
-
-	// value.obj.handle
- 	return (smokephp_object*) obj_x_smokephp.value(this_ptr->value.obj.handle);
-
-}
-
-void*
-phpqt_getQtObjectFromZval(zval* this_ptr){
-	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
-	return o->ptr;
-}
-
-smokephp_object*
-phpqt_getSmokePHPObjectFromQt(void* QtPtr){
-	return (smokephp_object*) SmokeQtObjects.value(QtPtr);
-}
-
-void
-phpqt_setSmokePHPObject(smokephp_object* o){
-	SmokeQtObjects.insert(o->ptr, o);
-}
-
-bool
-phpqt_SmokePHPObjectExists(void* ptr){
-	return (SmokeQtObjects.find(ptr) != SmokeQtObjects.end());
-}
-
-bool
-phpqt_unmapSmokePHPObject(zval* o)
-{
-	return (bool) obj_x_smokephp.remove(o->value.obj.handle);
-}
-
-/**
- *	marshall_basetypes.h marshall_to_php<SmokeClassWrapper>(Marshall *m)
- */
-
-smokephp_object*
-phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce, Smoke::Index classId){
-
-	Q_ASSERT (zval_ptr);
-	Q_ASSERT (ptr);
-
- 	if(!ce) {
- 		qFatal("no class entry!");
- 	}
-
-	if(classId == QSTRING_CLASSID)
-	{
-		ce = qstring_ce;
-	} else if (classId == 0)
-	{
-		qDebug("\nno class id");
-		check_qobject(zval_ptr);
-		qFatal("php object creation failed");
-	}
-
-	Z_TYPE_P(zval_ptr) = IS_OBJECT;
-	object_init_ex(zval_ptr, ce);
-
-	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
-	o->allocated = true;
-	o->ptr = ptr;
-	o->zval_ptr = zval_ptr;
-	o->ce_ptr = ce;
-	o->parent_ce_ptr = ce;
- 	o->classId = classId;
-	o->smoke = PQ::smoke();
-
-	Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
-	phpqt_setSmokePHPObject(o);
-	zval_add_ref(&zval_ptr);
-
-	obj_x_smokephp.insert(zval_ptr->value.obj.handle, o);
-
-	return o;
-
-}
-
-smokephp_object*
-phpqt_createOriginal(zval* zval_ptr, void* ptr)
-{
-	smokephp_object* o = phpqt_getSmokePHPObjectFromQt(ptr);
-/* 		ZVAL_ZVAL(zval_ptr, o->zval_ptr, 1, 0);
-// 		zval_ptr->is_ref = 1;
-		Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
-		zval_x_smokephp.insert(zval_ptr, o);*/
-	Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
-	zval_ptr = o->zval_ptr;
-	zval_add_ref(&zval_ptr);
-
-	return o;
-}

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/php_qt.h	2007-06-06 21:19:56 UTC (rev 336)
@@ -44,7 +44,7 @@
 
 #include "smoke.h"
 #include "smokephp.h"
-#include <QtCore/QMetaMethod>
+
 #include <QtCore/QStack>
 #include <QtCore/QHash>
 #include <QtCore/QTextStream>
@@ -144,28 +144,6 @@
     QMetaObject* meta;
 };
 
-
-static void 			phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc);
-
-// void 				phpqt_register(zval* this_ptr, zend_rsrc_list_entry le);
-zval* 				phpqt_callPHPMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params);
-bool 				phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname);
-bool 				phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* metachar, QString* meta_stringdata, uint* signature);
-int					phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
-char*				phpqt_checkForOperator(const char* fname);
-
-void* 				phpqt_getQtObjectFromZval(zval* this_ptr);
-smokephp_object* 	phpqt_getSmokePHPObjectFromZval(zval* this_ptr);
-smokephp_object*	phpqt_getSmokePHPObjectFromQt(void* QtPtr);
-void				phpqt_setSmokePHPObject(smokephp_object* o);
-bool 				phpqt_SmokePHPObjectExists(zval* this_ptr);
-bool				phpqt_SmokePHPObjectExists(void* ptr);
-
-bool				phpqt_unmapSmokePHPObject(zval* o);
-
-smokephp_object*	phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL, Smoke::Index classId = 0);
-smokephp_object*	phpqt_createOriginal(zval* zval_ptr, void* ptr);
-
 const char* 		printType(int type);
 
 

Added: trunk/php_qt/phpqt_internals.cpp
===================================================================
--- trunk/php_qt/phpqt_internals.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/phpqt_internals.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -0,0 +1,439 @@
+/*!
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006
+ * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+
+#include "phpqt_internals.h"
+
+#include <QtCore/QMetaMethod>
+#include <zend.h>
+#include "smoke.h"
+#include "php_qt.h"
+
+extern zend_object_handlers php_qt_handler;
+extern zend_class_entry* qstring_ce;
+
+zend_class_entry* qobject_ce;
+QHash<void*, smokephp_object*> SmokeQtObjects;
+QHash<zend_object_handle, smokephp_object*> obj_x_smokephp;
+
+
+/*!
+ *	PHP-Qt internal functions
+ */
+
+int
+phpqt_metacall(smokephp_object* so, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a)
+{
+	QMetaObject* d = so->meta;
+//	int offset = d->methodOffset();
+	int offset = d->methodCount();
+
+#if MOC_DEBUG
+	cout << "qt_metacall " << so->ce_ptr->name << endl;
+#endif
+
+	// call the C++ one
+	if(_id < offset){
+		// find parent
+		Smoke::Index parent = so->smoke->inheritanceList[so->smoke->classes[so->classId].parents];
+
+		// methodId
+		Smoke::Index nameId = so->smoke->idMethodName("qt_metacall$$?");
+		Smoke::Index method = so->smoke->findMethod(so->classId, nameId);
+
+		if(method > 0){
+			Smoke::Method &m = so->smoke->methods[so->smoke->methodMaps[method].method];
+			Smoke::ClassFn fn = so->smoke->classes[m.classId].classFn;
+			Smoke::StackItem i[4];
+			i[1].s_enum = _c;
+			i[2].s_int = _id;
+			i[3].s_voidp = (void*) args[3].s_voidp;
+			(*fn)(m.method, so->ptr, i);
+
+#if MOC_DEBUG
+			cout << "\tcall Qt method " << so->ce_ptr->name << "::" << PQ::smoke()->methodNames[method] << endl;
+#endif
+
+			if((int)i[0].s_int < 0)
+				return i[0].s_int;
+
+		} else {
+			// should never happen
+			php_error(E_ERROR, "Cannot find %s::qt_metacall() method\n", d->className());
+		}
+
+	}
+
+    if (_c != QMetaObject::InvokeMetaMethod) {
+		return _id;
+	}
+
+	// try the PHP one
+	// eg _q_buttonPressed(), breaking at the first bracket
+	char* method_name = estrdup((d->method(_id)).signature());
+
+    for(int i = 0; i < strlen(method_name); i++){
+#define LEFT_PARENTHESIS 40
+        if(method_name[i] == LEFT_PARENTHESIS){
+            method_name[i] = 0;
+            break;
+        }
+    }
+
+    // is a Slot
+    if(d->method(_id).methodType() == QMetaMethod::Slot){
+
+        int j = 0;
+        zval*** args = (zval***) safe_emalloc(2, sizeof(zval*), 0);
+        QList<QByteArray> qargs = d->method(_id).parameterTypes();
+        for(int i = 0; i < qargs.count(); i++){
+            zval *arg;
+            MAKE_STD_ZVAL(arg);
+
+            // invoke to zend types
+            if(!strncmp("int",(const char*) qargs[i],3)){
+
+                ZVAL_LONG(arg, *reinterpret_cast< int*>(_a[i+1]));
+            } else if(!strncmp("char*",(const char*) qargs[i],5)){
+                ZVAL_STRING(arg, *reinterpret_cast< char**>(_a[i+1]), 1);
+            } else if(!strncmp("bool",(const char*) qargs[i],4)){
+                ZVAL_BOOL(arg, *reinterpret_cast< bool*>(_a[i+1]));
+            } else if(!strncmp("double",(const char*) qargs[i],4)){
+                ZVAL_DOUBLE(arg, *reinterpret_cast< double*>(_a[i+1]));
+            } else {
+                    // must be an object
+                    void* ptr = *reinterpret_cast< QObject**>(_a[1]);
+
+                    phpqt_createObject(arg, ptr, qobject_ce);
+            }
+
+            args[j++] = &arg;
+
+        }
+
+#if MOC_DEBUG
+    cout << "\tcall PHP method " << so->ce_ptr->name << "::" << method_name << endl;
+#endif
+
+         phpqt_callPHPMethod(so->zval_ptr, method_name, j, *args);
+
+    // is a signal
+    } else {
+        void *_b[] = { 0, _a[1] };
+        QMetaObject::activate((QObject*) so->ptr, d, 0, _b);
+    }
+
+	efree(method_name);
+    return _id;
+
+}
+
+void
+phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc TSRMLS_DC)
+{
+#ifdef DEBUG
+	php_error(E_ERROR,"Hashtable destroyed. Shutdown PHP-Qt now.");
+#endif
+}
+
+bool
+phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname)
+{
+
+	if(ce_ptr == NULL){
+	  php_error(E_ERROR,"methodExists fatal error: no class entry");
+	}
+
+	char* lcname = zend_str_tolower_dup(methodname, strlen(methodname));
+
+	if(zend_hash_exists(&ce_ptr->function_table, lcname, strlen(methodname)+1)){
+		return true;
+	}
+
+	efree(lcname);
+	return false;
+
+}
+
+
+zval*
+phpqt_callPHPMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args)
+{
+
+	if(this_ptr == NULL){
+	  php_error(E_ERROR,"callmethod fatal error: object does not exists");
+	}
+
+    zval *function_name;
+    MAKE_STD_ZVAL(function_name);
+    ZVAL_STRING(function_name,methodName,1);
+
+    zval* retval;
+    MAKE_STD_ZVAL(retval);
+
+    if(call_user_function(EG(function_table),&this_ptr,function_name,retval,param_count,args) == FAILURE){
+    	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
+    	php_error(E_ERROR, "PHP-Qt could not call method %s::%s", o->ce_ptr->name, methodName);
+    }
+
+    return retval;
+}
+
+/*!
+ *	creates metaObject data
+ *  example: "QWidget\0\0value\0test(int)\0"
+ *	@param	zval*				this_ptr	pointer of the zval
+ *	@param	char*				classname	name of the class
+ *	@param	const QMetaObject*	superdata	superdata
+ *	@return	QMetaObject*
+ */
+
+bool
+phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* meta, QString* meta_stringdata, uint* signature){
+
+    /// readout the slots table
+    zval **slotdata;
+
+    zval *zslot;
+    zslot = zend_read_property(Z_OBJCE_P(this_ptr),this_ptr,"slots",5,0);
+
+    zval *zsignal;
+    zsignal = zend_read_property(Z_OBJCE_P(this_ptr),this_ptr,"signals",7,0);
+
+    if((zslot)->type==IS_ARRAY && (zsignal)->type==IS_ARRAY ) {
+
+
+        HashTable* slots_hash = HASH_OF(zslot);
+        HashTable* signals_hash = HASH_OF(zsignal);
+
+        char* assocKey;
+        ulong numKey;
+
+        int signaturecount;
+        signaturecount = 2 + strlen(classname);
+
+#if MOC_DEBUG
+	QString *qr = new QString();
+	cout << "+== begin metaobject dump ==+\n";
+	cout << "\t" << classname << "\n\t1 0 0 0 " << zend_hash_num_elements(slots_hash)+zend_hash_num_elements(signals_hash) << " 10 0 0 0 0" << endl << endl;
+#endif
+
+		/// write class signature
+		signature[0] = 1;
+		signature[1] = 0;
+		signature[2] = 0;
+		signature[3] = 0;
+		signature[4] = zend_hash_num_elements(slots_hash)+zend_hash_num_elements(signals_hash);
+		signature[5] = 10;
+		signature[6] = 0;
+		signature[7] = 0;
+		signature[8] = 0;
+		signature[9] = 0;
+
+		/// write classname
+		meta_stringdata->append(classname);
+ 		meta_stringdata->append(QChar::Null);
+ 		meta_stringdata->append(QChar::Null);
+
+		int i;
+		i = 10;
+
+		zend_hash_internal_pointer_reset(signals_hash);
+
+		while(zend_hash_has_more_elements(signals_hash) == SUCCESS){
+
+			/// read slot from hashtable
+			zend_hash_get_current_key(signals_hash,&assocKey,&numKey,0);
+			zend_hash_get_current_data(signals_hash,(void**)&slotdata);
+
+#if MOC_DEBUG
+			qr->append(Z_STRVAL_PP(slotdata));
+			qr->append(" ");
+			cout << "\t" << signaturecount << "8 8 8 0x05 ::s" << endl;
+#endif
+
+			meta_stringdata->append(Z_STRVAL_PP(slotdata));
+			meta_stringdata->append(QChar::Null);
+
+			zend_hash_move_forward(signals_hash);
+
+			/// write slot signature
+			signature[i++] = signaturecount;
+			signature[i++] = 8;
+			signature[i++] = 8;
+			signature[i++] = 8;
+			signature[i++] = 0x05;
+
+			signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
+
+		}
+
+    	zend_hash_internal_pointer_reset(slots_hash);
+
+		while(zend_hash_has_more_elements(slots_hash) == SUCCESS){
+
+			/// read slot from hashtable
+			zend_hash_get_current_key(slots_hash,&assocKey,&numKey,0);
+			zend_hash_get_current_data(slots_hash,(void**)&slotdata);
+
+#if MOC_DEBUG
+			qr->append(Z_STRVAL_PP(slotdata));
+			qr->append(" ");
+			cout << "\t" << signaturecount << "8 8 8 0x0a ::s" << endl;
+#endif
+
+			meta_stringdata->append(Z_STRVAL_PP(slotdata));
+			meta_stringdata->append(QChar::Null);
+
+			zend_hash_move_forward(slots_hash);
+
+			/// write slot signature
+			signature[i++] = signaturecount;
+			signature[i++] = 8;
+			signature[i++] = 8;
+			signature[i++] = 8;
+			signature[i++] = 0x0a;
+
+			signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
+
+		}
+#if MOC_DEBUG
+		cout << qr->toAscii().constData() << endl;
+		cout << "+== end metaobject dump ==+" << endl;
+#endif
+		return true;
+	} else {
+		return false;
+  	}
+}
+
+char*
+phpqt_checkForOperator(const char* fname){
+	return (char*) fname;
+}
+
+bool
+phpqt_SmokePHPObjectExists(zval* this_ptr)
+{
+	return obj_x_smokephp.contains(this_ptr->value.obj.handle);
+}
+
+smokephp_object*
+phpqt_getSmokePHPObjectFromZval(zval* this_ptr)
+{
+
+	if(this_ptr == NULL){
+	  php_error(E_ERROR,"fatal: object does not exists and could not be fetched, %s",Z_OBJCE_P(this_ptr)->name);
+	}
+
+	// value.obj.handle
+ 	return (smokephp_object*) obj_x_smokephp.value(this_ptr->value.obj.handle);
+
+}
+
+void*
+phpqt_getQtObjectFromZval(zval* this_ptr){
+	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
+	return o->ptr;
+}
+
+smokephp_object*
+phpqt_getSmokePHPObjectFromQt(void* QtPtr){
+	return (smokephp_object*) SmokeQtObjects.value(QtPtr);
+}
+
+void
+phpqt_setSmokePHPObject(smokephp_object* o){
+	SmokeQtObjects.insert(o->ptr, o);
+}
+
+bool
+phpqt_SmokePHPObjectExists(void* ptr){
+	return (SmokeQtObjects.find(ptr) != SmokeQtObjects.end());
+}
+
+bool
+phpqt_unmapSmokePHPObject(zval* o)
+{
+	return (bool) obj_x_smokephp.remove(o->value.obj.handle);
+}
+
+/**
+ *	marshall_basetypes.h marshall_to_php<SmokeClassWrapper>(Marshall *m)
+ */
+
+smokephp_object*
+phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce, Smoke::Index classId){
+
+	Q_ASSERT (zval_ptr);
+	Q_ASSERT (ptr);
+
+ 	if(!ce) {
+ 		qFatal("no class entry!");
+ 	}
+
+	if(classId == QSTRING_CLASSID)
+	{
+		ce = qstring_ce;
+	} else if (classId == 0)
+	{
+		qDebug("\nno class id");
+		check_qobject(zval_ptr);
+		qFatal("php object creation failed");
+	}
+
+	Z_TYPE_P(zval_ptr) = IS_OBJECT;
+	object_init_ex(zval_ptr, ce);
+
+	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
+	o->allocated = true;
+	o->ptr = ptr;
+	o->zval_ptr = zval_ptr;
+	o->ce_ptr = ce;
+	o->parent_ce_ptr = ce;
+ 	o->classId = classId;
+	o->smoke = PQ::smoke();
+
+	Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
+	phpqt_setSmokePHPObject(o);
+	zval_add_ref(&zval_ptr);
+
+	obj_x_smokephp.insert(zval_ptr->value.obj.handle, o);
+
+	return o;
+
+}
+
+smokephp_object*
+phpqt_createOriginal(zval* zval_ptr, void* ptr)
+{
+	smokephp_object* o = phpqt_getSmokePHPObjectFromQt(ptr);
+/* 		ZVAL_ZVAL(zval_ptr, o->zval_ptr, 1, 0);
+// 		zval_ptr->is_ref = 1;
+		Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
+		zval_x_smokephp.insert(zval_ptr, o);*/
+	Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
+	zval_ptr = o->zval_ptr;
+	zval_add_ref(&zval_ptr);
+
+	return o;
+}
+

Added: trunk/php_qt/phpqt_internals.h
===================================================================
--- trunk/php_qt/phpqt_internals.h	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/phpqt_internals.h	2007-06-06 21:19:56 UTC (rev 336)
@@ -0,0 +1,51 @@
+/*!
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006
+ * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+
+#ifndef PHPQT_INTERNALS_H
+#define PHPQT_INTERNALS_H
+
+class QMetaObject;
+class QString;
+
+#include "php_qt.h"
+
+void 				phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc);
+
+zval* 				phpqt_callPHPMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params);
+bool 				phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname);
+bool 				phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* metachar, QString* meta_stringdata, uint* signature);
+int					phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
+char*				phpqt_checkForOperator(const char* fname);
+
+void* 				phpqt_getQtObjectFromZval(zval* this_ptr);
+smokephp_object* 	phpqt_getSmokePHPObjectFromZval(zval* this_ptr);
+smokephp_object*	phpqt_getSmokePHPObjectFromQt(void* QtPtr);
+void				phpqt_setSmokePHPObject(smokephp_object* o);
+bool 				phpqt_SmokePHPObjectExists(zval* this_ptr);
+bool				phpqt_SmokePHPObjectExists(void* ptr);
+
+bool				phpqt_unmapSmokePHPObject(zval* o);
+
+smokephp_object*	phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL, Smoke::Index classId = 0);
+smokephp_object*	phpqt_createOriginal(zval* zval_ptr, void* ptr);
+
+#endif

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/qstring.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -30,7 +30,9 @@
 
 #include <QtCore/QString>
 #include <zend_interfaces.h>
+
 #include "php_qt.h"
+#include "phpqt_internals.h"
 
 zend_class_entry* qstring_ce;
 extern Smoke* qt_Smoke;
@@ -243,7 +245,7 @@
  *    class     QString */
 /*
  *    function  insert
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, insert){
 
@@ -260,7 +262,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->insert((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -295,7 +297,7 @@
  *    class     QString */
 /*
  *    function  clear
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, clear){
 	if (ZEND_NUM_ARGS() == 0){
@@ -310,7 +312,7 @@
  *    class     QString */
 /*
  *    function  setUtf16
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, setUtf16){
 
@@ -324,7 +326,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->setUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -336,7 +338,7 @@
  *    class     QString */
 /*
  *    function  prepend
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, prepend){
 
@@ -355,14 +357,14 @@
 			if(Z_TYPE_P(z_0) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->prepend((char) Z_LVAL_P(z_0));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_STRING){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->prepend( (const char*) Z_STRVAL_P(z_0));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -395,7 +397,7 @@
  *    class     QString */
 /*
  *    function  chop
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, chop){
 
@@ -446,7 +448,7 @@
  *    class     QString */
 /*
  *    function  squeeze
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, squeeze){
 	if (ZEND_NUM_ARGS() == 0){
@@ -579,7 +581,7 @@
  *    class     QString */
 /*
  *    function  QString
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, __construct){
 
@@ -717,7 +719,7 @@
  *    class     QString */
 /*
  *    function  setNum
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, setNum){
 
@@ -731,7 +733,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->setNum((short) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -752,14 +754,14 @@
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->setNum((float) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->setNum((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -798,12 +800,12 @@
  *    function  number
  *    flags:    s
  *
- *	QString number ( long n, int base = 10 ) 
- *	QString number ( ulong n, int base = 10 ) 
- *	QString number ( int n, int base = 10 ) 
- *	QString number ( uint n, int base = 10 ) 
- *	QString number ( qlonglong n, int base = 10 ) 
- *	QString number ( qulonglong n, int base = 10 ) 
+ *	QString number ( long n, int base = 10 )
+ *	QString number ( ulong n, int base = 10 )
+ *	QString number ( int n, int base = 10 )
+ *	QString number ( uint n, int base = 10 )
+ *	QString number ( qlonglong n, int base = 10 )
+ *	QString number ( qulonglong n, int base = 10 )
  *	QString number ( double n, char format = 'g', int precision = 6 )
  */
 ZEND_METHOD(QString, number){
@@ -814,17 +816,17 @@
 			if(Z_TYPE_P(z_0) == IS_LONG){
 				QString obj = (QString) QString::number((ulong) Z_LVAL_P(z_0));
 				QString *s1 = new QString(obj);
-				
+
 				phpqt_createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
 				return;
 			} else if(Z_TYPE_P(z_0) == IS_DOUBLE){
 				QString obj = (QString) QString::number((double) Z_DVAL_P(z_0));
 				QString *s1 = new QString(obj);
-				
+
 				phpqt_createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
 				return;
 			}
-			
+
 		}
 	}
 
@@ -1035,7 +1037,7 @@
  *    class     QString */
 /*
  *    function  truncate
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, truncate){
 
@@ -1112,7 +1114,7 @@
  *    class     QString */
 /*
  *    function  push_front
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, push_front){
 
@@ -1349,7 +1351,7 @@
  *    class     QString */
 /*
  *    function  remove
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, remove){
 
@@ -1387,7 +1389,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->remove((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -1535,7 +1537,7 @@
  *    class     QString */
 /*
  *    function  vsprintf
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, vsprintf){
 
@@ -1597,7 +1599,7 @@
  *    class     QString */
 /*
  *    function  reserve
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, reserve){
 
@@ -1714,7 +1716,7 @@
  *    class     QString */
 /*
  *    function  setUnicode
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, setUnicode){
 
@@ -1764,7 +1766,7 @@
  *    class     QString */
 /*
  *    function  data
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, data){
 	if (ZEND_NUM_ARGS() == 0){
@@ -1792,7 +1794,7 @@
  *    class     QString */
 /*
  *    function  end
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, end){
 	if (ZEND_NUM_ARGS() == 0){
@@ -1855,7 +1857,7 @@
  *    class     QString */
 /*
  *    function  resize
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, resize){
 
@@ -1880,7 +1882,7 @@
  *    class     QString */
 /*
  *    function  replace
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, replace){
 
@@ -1933,7 +1935,7 @@
 			{
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->replace((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(char) Z_LVAL_P(z_2));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -1979,7 +1981,7 @@
   			    if(getThis() == NULL){
 				QString obj = (QString) QString::fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
 				QString *s1 = new QString(obj);
-				
+
 				phpqt_createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
 				return;
 
@@ -2019,7 +2021,7 @@
  *    class     QString */
 /*
  *    function  detach
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, detach){
 	if (ZEND_NUM_ARGS() == 0){
@@ -2033,7 +2035,7 @@
  *    class     QString */
 /*
  *    function  append
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, append){
 
@@ -2045,7 +2047,7 @@
 			{
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->append((char) Z_LVAL_P(z_0));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -2129,7 +2131,7 @@
  *    class     QString */
 /*
  *    function  fill
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, fill){
 
@@ -2144,7 +2146,7 @@
 			{
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->fill((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -2167,7 +2169,7 @@
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) 
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS)
 		{
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG)
 			{
@@ -2294,7 +2296,7 @@
  *    class     QString */
 /*
  *    function  begin
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, begin){
 	if (ZEND_NUM_ARGS() == 0){
@@ -2307,7 +2309,7 @@
  *    class     QString */
 /*
  *    function  push_back
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, push_back){
 

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/smokephp.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -23,6 +23,8 @@
 #include "php_qt.h"
 #include "smoke.h"
 #include "marshall_types.h"
+#include "phpqt_internals.h"
+
 #include <QtCore/QMetaMethod>
 #include <QtCore/QHash>
 #include <QtCore/QCoreApplication>



From tm243 at mail.berlios.de  Wed Jun  6 23:30:22 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 6 Jun 2007 23:30:22 +0200
Subject: [Php-qt-svn] r337 - trunk/php_qt
Message-ID: <200706062130.l56LUMpE004273@sheep.berlios.de>

Author: tm243
Date: 2007-06-06 23:30:22 +0200 (Wed, 06 Jun 2007)
New Revision: 337

Modified:
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/phpqt_internals.cpp
   trunk/php_qt/qstring.cpp
   trunk/php_qt/smokephp.cpp
   trunk/php_qt/zend_handlers.cpp
Log:
* updated copyright notices
* changed order of caching in module startup



Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-06 21:19:56 UTC (rev 336)
+++ trunk/php_qt/php_qt.cpp	2007-06-06 21:30:22 UTC (rev 337)
@@ -409,10 +409,6 @@
 
 	} // end loop classes
 
-	// cache some stuff
-	Smoke::Index qobject = PQ::smoke()->idClass("QObject");
-	_register_QString();
-
 	// do inheritance, all classes must be defined before
 	for(Smoke::Index i = 1; i <= PQ::smoke()->numClasses; i++){
 	    zend_class_entry* ce = tmpCeTable[PQ::smoke()->classes[i].className];
@@ -422,6 +418,10 @@
 	    }
 	}
 
+	// cache some stuff
+	Smoke::Index qobject = PQ::smoke()->idClass("QObject");
+	_register_QString();
+
     return SUCCESS;
 } // PHP_MINIT
 

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-06-06 21:19:56 UTC (rev 336)
+++ trunk/php_qt/php_qt.h	2007-06-06 21:30:22 UTC (rev 337)
@@ -1,7 +1,7 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2006
+ * Copyright (C) 2006 - 2007
  * Thomas Moenicke <thomas.moenicke at kdemail.net>
  * Katrina Niolet <katrina at niolet.name>
  *

Modified: trunk/php_qt/phpqt_internals.cpp
===================================================================
--- trunk/php_qt/phpqt_internals.cpp	2007-06-06 21:19:56 UTC (rev 336)
+++ trunk/php_qt/phpqt_internals.cpp	2007-06-06 21:30:22 UTC (rev 337)
@@ -1,7 +1,7 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2006
+ * Copyright (C) 2006 - 2007
  * Thomas Moenicke <thomas.moenicke at kdemail.net>
  *
  * This program is free software; you can redistribute it and/or

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-06-06 21:19:56 UTC (rev 336)
+++ trunk/php_qt/qstring.cpp	2007-06-06 21:30:22 UTC (rev 337)
@@ -1,7 +1,7 @@
-/*
+/*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2005 - 2007
  * Thomas Moenicke <tm at ippfp.org>,
  * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-06-06 21:19:56 UTC (rev 336)
+++ trunk/php_qt/smokephp.cpp	2007-06-06 21:30:22 UTC (rev 337)
@@ -1,7 +1,7 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2006
+ * Copyright (C) 2006 - 2007
  * Thomas Moenicke <thomas.moenicke at kdemail.net>
  *
  * This program is free software; you can redistribute it and/or

Modified: trunk/php_qt/zend_handlers.cpp
===================================================================
--- trunk/php_qt/zend_handlers.cpp	2007-06-06 21:19:56 UTC (rev 336)
+++ trunk/php_qt/zend_handlers.cpp	2007-06-06 21:30:22 UTC (rev 337)
@@ -1,7 +1,7 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2006
+ * Copyright (C) 2006 - 2007
  * Thomas Moenicke <thomas.moenicke at kdemail.net>
  * Katrina Niolet <katrina at niolet.name>
  *



From tm243 at mail.berlios.de  Wed Jun  6 23:40:46 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 6 Jun 2007 23:40:46 +0200
Subject: [Php-qt-svn] r338 - trunk/php_qt
Message-ID: <200706062140.l56LekvJ005013@sheep.berlios.de>

Author: tm243
Date: 2007-06-06 23:40:45 +0200 (Wed, 06 Jun 2007)
New Revision: 338

Modified:
   trunk/php_qt/functions.cpp
   trunk/php_qt/handlers.cpp
   trunk/php_qt/php_qt.h
Log:
* #include statements cleaned up



Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-06-06 21:30:22 UTC (rev 337)
+++ trunk/php_qt/functions.cpp	2007-06-06 21:40:45 UTC (rev 338)
@@ -24,6 +24,8 @@
 #include "php_qt.h"
 #include "phpqt_internals.h"
 
+#include <QtCore/QObject>
+
 extern Smoke *qt_Smoke;
 extern Smoke::Index qstring;
 extern zend_class_entry* qstring_ce;

Modified: trunk/php_qt/handlers.cpp
===================================================================
--- trunk/php_qt/handlers.cpp	2007-06-06 21:30:22 UTC (rev 337)
+++ trunk/php_qt/handlers.cpp	2007-06-06 21:40:45 UTC (rev 338)
@@ -7,6 +7,7 @@
  *                                                                         *
  ***************************************************************************/
 
+#include <QtGui/QWidget>
 #include <QtCore/qprocess.h>
 #include <QtCore/qtextcodec.h>
 

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-06-06 21:30:22 UTC (rev 337)
+++ trunk/php_qt/php_qt.h	2007-06-06 21:40:45 UTC (rev 338)
@@ -47,16 +47,8 @@
 
 #include <QtCore/QStack>
 #include <QtCore/QHash>
-#include <QtCore/QTextStream>
-#include <QtCore/QVariant>
 #include <QtCore/QString>
-#include <QtCore/QCoreApplication>
-#include <QtGui/QWidget>
-#include <QtGui/QApplication>
-#include <QtGui/QLayout>
-#include <QtGui/QLCDNumber>
-#include <QtGui/QFont>
-#include <QtCore/QDebug>
+#include <QtCore/QMetaObject>
 
 // for older php versions
 #ifndef ZEND_MN



From tm243 at mail.berlios.de  Thu Jun  7 09:57:37 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Thu, 7 Jun 2007 09:57:37 +0200
Subject: [Php-qt-svn] r339 - trunk/php_qt
Message-ID: <200706070757.l577vbFj007432@sheep.berlios.de>

Author: tm243
Date: 2007-06-07 09:57:36 +0200 (Thu, 07 Jun 2007)
New Revision: 339

Modified:
   trunk/php_qt/functions.cpp
   trunk/php_qt/handlers.cpp
   trunk/php_qt/marshall_basetypes.h
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/phpqt_internals.cpp
   trunk/php_qt/phpqt_internals.h
   trunk/php_qt/qstring.cpp
   trunk/php_qt/smokephp.cpp
Log:
* renamed methods and created namespace PHPQt



Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-06-06 21:40:45 UTC (rev 338)
+++ trunk/php_qt/functions.cpp	2007-06-07 07:57:36 UTC (rev 339)
@@ -326,7 +326,7 @@
 			break;
 		case IS_OBJECT:
 			if(strcmp(Z_OBJCE_P(string)->name,"QString")==0) {
-				ptr = (QString*) phpqt_getQtObjectFromZval(string);
+				ptr = (QString*) PHPQt::getQtObjectFromZval(string);
 				RETURN_STRING((char*)ptr->toLocal8Bit().constData(),1);
 			}
 			RETURN_STRING(Z_OBJCE_P(string)->name,1);
@@ -605,7 +605,7 @@
     }
 
 	QString *ptr = new QString(QObject::tr(string));
-	phpqt_createObject(return_value, ptr, qstring_ce, QSTRING_CLASSID);
+	PHPQt::createObject(return_value, ptr, qstring_ce, QSTRING_CLASSID);
 
     return;
 }
@@ -619,7 +619,7 @@
 void check_qobject(zval* zobject)
 {
 
-	if(!phpqt_SmokePHPObjectExists(zobject)) {
+	if(!PHPQt::SmokePHPObjectExists(zobject)) {
 
 		cout << "PHP Object \n(" << endl;
 
@@ -639,7 +639,7 @@
 
 	} else {
 
-		smokephp_object* o = phpqt_getSmokePHPObjectFromZval(zobject);
+		smokephp_object* o = PHPQt::getSmokePHPObjectFromZval(zobject);
 
 		cout << "PHP-Qt object \n(" << endl;
 

Modified: trunk/php_qt/handlers.cpp
===================================================================
--- trunk/php_qt/handlers.cpp	2007-06-06 21:40:45 UTC (rev 338)
+++ trunk/php_qt/handlers.cpp	2007-06-07 07:57:36 UTC (rev 339)
@@ -260,7 +260,7 @@
 		case Marshall::FromZVAL:
 		{
 			if(Z_TYPE_P(m->var()) != IS_STRING){ // is object
-			    m->item().s_voidp = phpqt_getQtObjectFromZval(m->var());
+			    m->item().s_voidp = PHPQt::getQtObjectFromZval(m->var());
 			    m->next();
 			    break;
 			}
@@ -291,7 +291,7 @@
 		{
 			QString* s = static_cast<QString*>(m->item().s_voidp);
 // 			zval* obj = m->var();
-			phpqt_createObject(m->var(), (void*) s, qstring_ce, -1);
+			PHPQt::createObject(m->var(), (void*) s, qstring_ce, -1);
 		}
 		break;
 

Modified: trunk/php_qt/marshall_basetypes.h
===================================================================
--- trunk/php_qt/marshall_basetypes.h	2007-06-06 21:40:45 UTC (rev 338)
+++ trunk/php_qt/marshall_basetypes.h	2007-06-07 07:57:36 UTC (rev 339)
@@ -84,14 +84,14 @@
 		return;
 	}
 
-	if(!/*phpqt_SmokePHPObjectExists*/(v)) {
+	if(!/*SmokePHPObjectExists*/(v)) {
 		check_qobject(v);
 // 		php_error(E_ERROR, "Invalid type, expecting %s, %s given\n", m->type().name(), zend_zval_type_name(v));
 		php_error(E_ERROR, "Invalid type, expecting %s, %s given (probably PHP-Qt lost the Qt object)\n", m->type().name(), Z_OBJCE_P(v)->name);
 		return;
 	}
 
-	smokephp_object *o = phpqt_getSmokePHPObjectFromZval(v);
+	smokephp_object *o = PHPQt::getSmokePHPObjectFromZval(v);
 	if(!o || !o->ptr) {
 		if(m->type().isRef()) {
 			php_error(E_WARNING, "References can't be nil\n");
@@ -136,12 +136,12 @@
 	void *p = m->item().s_voidp;
 
 	// return the original
-	if(phpqt_SmokePHPObjectExists(p)) {
+	if(PHPQt::SmokePHPObjectExists(p)) {
 		if(m->return_value_ptr()){
 			// destroys the return_value initialized by ZE, we create our own:
 			zval_ptr_dtor(m->return_value_ptr());
 			// prepare the return value
-			smokephp_object* o = phpqt_createOriginal(m->var(), p);
+			smokephp_object* o = PHPQt::createOriginal(m->var(), p);
 			// overwrite the old one:
 			*(m->return_value_ptr()) = o->zval_ptr;
 
@@ -176,7 +176,7 @@
 	    }
 
 // #warning parent_ce in createObject
-		smokephp_object *o = phpqt_createObject(m->var(), __p, _ce, m->type().classId());
+		smokephp_object *o = PHPQt::createObject(m->var(), __p, _ce, m->type().classId());
 
 //	    if(m->type().isConst() && m->type().isRef()) {
 	    if(m->type().isRef())

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-06-06 21:40:45 UTC (rev 338)
+++ trunk/php_qt/marshall_types.cpp	2007-06-07 07:57:36 UTC (rev 339)
@@ -442,7 +442,7 @@
 	if (_called) return;
 	_called = true;
 
-	phpqt_callPHPMethod(_obj, (char*) _smoke->methodNames[method().name], items(), __sp);
+	PHPQt::callPHPMethod(_obj, (char*) _smoke->methodNames[method().name], items(), __sp);
 
 	zval _retval;
  	VirtualMethodReturnValue r(_smoke, _method, _stack, _retval);
@@ -465,9 +465,9 @@
 	identifier = "MethodCall";
     if(target != NULL)
     {
-		if (phpqt_SmokePHPObjectExists(_target))
+		if (PHPQt::SmokePHPObjectExists(_target))
 		{
-			smokephp_object *o = phpqt_getSmokePHPObjectFromZval(_target);
+			smokephp_object *o = PHPQt::getSmokePHPObjectFromZval(_target);
 			if (o && o->ptr)
 			{
 				_current_object = o->ptr;
@@ -718,7 +718,7 @@
 {
 	if (_called) return;
 	_called = true;
- 	zval* result = phpqt_callPHPMethod(_obj, (char*) PQ::smoke()->methodNames[PQ::smoke()->methods[_slotname].name], _items - 1, *_sp);
+ 	zval* result = PHPQt::callPHPMethod(_obj, (char*) PQ::smoke()->methodNames[PQ::smoke()->methods[_slotname].name], _items - 1, *_sp);
 	if (_args[0].argType != xmoc_void) {
 		SlotReturnValue r(_o, result, _args);
 	}

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-06 21:40:45 UTC (rev 338)
+++ trunk/php_qt/php_qt.cpp	2007-06-07 07:57:36 UTC (rev 339)
@@ -159,16 +159,16 @@
 
 ZEND_METHOD(php_qt_generic_class, __destruct)
 {
-	if(phpqt_SmokePHPObjectExists(getThis())) {
+	if(PHPQt::SmokePHPObjectExists(getThis())) {
 
- 		smokephp_object *o = phpqt_getSmokePHPObjectFromZval(getThis());
+ 		smokephp_object *o = PHPQt::getSmokePHPObjectFromZval(getThis());
 
 		// its not a reference
 		if(!PZVAL_IS_REF(getThis()))
 		{
 			o->allocated = false;
 		}
-		if(!phpqt_unmapSmokePHPObject(getThis()))
+		if(!PHPQt::unmapSmokePHPObject(getThis()))
 		{
 			qFatal("try to unmap unregistered zval");
 		}
@@ -205,7 +205,7 @@
     c.next();
 
 	// smokephp_object is created above in c.next()
-    smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
+    smokephp_object* o = PHPQt::getSmokePHPObjectFromZval(getThis());
     o->parent_ce_ptr = ce_parent; // = ce if no parent
 
 	// if QObject
@@ -224,7 +224,7 @@
     		uint* phpqt_meta_data = (uint*) emalloc(sizeof(uint)*20*5+10);
 
 		//	create the metaObject
-		if(phpqt_getMocData(
+		if(PHPQt::getMocData(
 				getThis(),
 				o->parent_ce_ptr->name,
 				superdata,
@@ -297,7 +297,7 @@
 
 	    // is it a signal?
 	    if(getThis()){
-		smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
+		smokephp_object* o = PHPQt::getSmokePHPObjectFromZval(getThis());
 		if(o->meta != NULL){
 		    QMetaObject* mo = (QMetaObject*) o->meta;
 		    QByteArray signalname(methodNameStack.top()->constData());
@@ -373,7 +373,7 @@
 	install_handlers(Qt_handlers);
 
 	// object list
-	le_php_qt_hashtype = zend_register_list_destructors_ex(phpqt_destroyHashtable, NULL, "PHP-Qt object list", module_number);
+	le_php_qt_hashtype = zend_register_list_destructors_ex(PHPQt::destroyHashtable, NULL, "PHP-Qt object list", module_number);
 	zend_hash_init_ex(&php_qt_objptr_hash, PHPQT_CLASS_COUNT, NULL, NULL, 1, 0);
 
 	ZendHandlers::installZendHandlers();

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-06-06 21:40:45 UTC (rev 338)
+++ trunk/php_qt/php_qt.h	2007-06-07 07:57:36 UTC (rev 339)
@@ -58,7 +58,7 @@
 #define Qnil (zval *) NULL
 
 #define PHP_QT_FETCH()  \
-	phpqt_getQtObjectFromZval(getThis()) \
+	getQtObjectFromZval(getThis()) \
 
 #define PHP_QT_FENTRY(zend_name, name_, arg_info_, flags_)	\
     t->fname = (char*) emalloc(strlen(#zend_name)+1); \
@@ -138,8 +138,6 @@
 
 const char* 		printType(int type);
 
-
-
 extern Smoke* qt_Smoke;
 class PQ
 {
@@ -167,13 +165,10 @@
 
 };
 
-extern int le_php_qt_hashtype;
-extern HashTable php_qt_objptr_hash;
-
 bool 				smokephp_isQObject(Smoke::Index classId);
 void				smokephp_prepareMethodName(zval*** args, int argc, QStack<QByteArray*> &methodNameStack);
-QByteArray* 			smokephp_getSignature(int argc, zval ***argv, MocArgument* mocStack);
-Smoke::Index			smokephp_getMethod(const char* c, const char* m, int argc, zval*** args);
+QByteArray* 		smokephp_getSignature(int argc, zval ***argv, MocArgument* mocStack);
+Smoke::Index		smokephp_getMethod(const char* c, const char* m, int argc, zval*** args);
 void				smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method);
 void				smokephp_callMethod(void *obj, Smoke::Index method, Smoke::Stack qargs);
 void				smokephp_init();

Modified: trunk/php_qt/phpqt_internals.cpp
===================================================================
--- trunk/php_qt/phpqt_internals.cpp	2007-06-06 21:40:45 UTC (rev 338)
+++ trunk/php_qt/phpqt_internals.cpp	2007-06-07 07:57:36 UTC (rev 339)
@@ -40,7 +40,7 @@
  */
 
 int
-phpqt_metacall(smokephp_object* so, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a)
+PHPQt::metacall(smokephp_object* so, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a)
 {
 	QMetaObject* d = so->meta;
 //	int offset = d->methodOffset();
@@ -122,7 +122,7 @@
                     // must be an object
                     void* ptr = *reinterpret_cast< QObject**>(_a[1]);
 
-                    phpqt_createObject(arg, ptr, qobject_ce);
+                    PHPQt::createObject(arg, ptr, qobject_ce);
             }
 
             args[j++] = &arg;
@@ -133,7 +133,7 @@
     cout << "\tcall PHP method " << so->ce_ptr->name << "::" << method_name << endl;
 #endif
 
-         phpqt_callPHPMethod(so->zval_ptr, method_name, j, *args);
+         PHPQt::callPHPMethod(so->zval_ptr, method_name, j, *args);
 
     // is a signal
     } else {
@@ -147,7 +147,7 @@
 }
 
 void
-phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc TSRMLS_DC)
+PHPQt::destroyHashtable(zend_rsrc_list_entry *rsrc TSRMLS_DC)
 {
 #ifdef DEBUG
 	php_error(E_ERROR,"Hashtable destroyed. Shutdown PHP-Qt now.");
@@ -155,7 +155,7 @@
 }
 
 bool
-phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname)
+PHPQt::methodExists(zend_class_entry* ce_ptr, char* methodname)
 {
 
 	if(ce_ptr == NULL){
@@ -175,7 +175,7 @@
 
 
 zval*
-phpqt_callPHPMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args)
+PHPQt::callPHPMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args)
 {
 
 	if(this_ptr == NULL){
@@ -190,7 +190,7 @@
     MAKE_STD_ZVAL(retval);
 
     if(call_user_function(EG(function_table),&this_ptr,function_name,retval,param_count,args) == FAILURE){
-    	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
+    	smokephp_object* o = PHPQt::getSmokePHPObjectFromZval(this_ptr);
     	php_error(E_ERROR, "PHP-Qt could not call method %s::%s", o->ce_ptr->name, methodName);
     }
 
@@ -207,7 +207,7 @@
  */
 
 bool
-phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* meta, QString* meta_stringdata, uint* signature){
+PHPQt::getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* meta, QString* meta_stringdata, uint* signature){
 
     /// readout the slots table
     zval **slotdata;
@@ -326,18 +326,18 @@
 }
 
 char*
-phpqt_checkForOperator(const char* fname){
+PHPQt::checkForOperator(const char* fname){
 	return (char*) fname;
 }
 
 bool
-phpqt_SmokePHPObjectExists(zval* this_ptr)
+PHPQt::SmokePHPObjectExists(zval* this_ptr)
 {
 	return obj_x_smokephp.contains(this_ptr->value.obj.handle);
 }
 
 smokephp_object*
-phpqt_getSmokePHPObjectFromZval(zval* this_ptr)
+PHPQt::getSmokePHPObjectFromZval(zval* this_ptr)
 {
 
 	if(this_ptr == NULL){
@@ -350,28 +350,28 @@
 }
 
 void*
-phpqt_getQtObjectFromZval(zval* this_ptr){
-	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
+PHPQt::getQtObjectFromZval(zval* this_ptr){
+	smokephp_object* o = getSmokePHPObjectFromZval(this_ptr);
 	return o->ptr;
 }
 
 smokephp_object*
-phpqt_getSmokePHPObjectFromQt(void* QtPtr){
+PHPQt::getSmokePHPObjectFromQt(void* QtPtr){
 	return (smokephp_object*) SmokeQtObjects.value(QtPtr);
 }
 
 void
-phpqt_setSmokePHPObject(smokephp_object* o){
+PHPQt::setSmokePHPObject(smokephp_object* o){
 	SmokeQtObjects.insert(o->ptr, o);
 }
 
 bool
-phpqt_SmokePHPObjectExists(void* ptr){
+PHPQt::SmokePHPObjectExists(void* ptr){
 	return (SmokeQtObjects.find(ptr) != SmokeQtObjects.end());
 }
 
 bool
-phpqt_unmapSmokePHPObject(zval* o)
+PHPQt::unmapSmokePHPObject(zval* o)
 {
 	return (bool) obj_x_smokephp.remove(o->value.obj.handle);
 }
@@ -381,7 +381,7 @@
  */
 
 smokephp_object*
-phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce, Smoke::Index classId){
+PHPQt::createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce, Smoke::Index classId){
 
 	Q_ASSERT (zval_ptr);
 	Q_ASSERT (ptr);
@@ -413,7 +413,7 @@
 	o->smoke = PQ::smoke();
 
 	Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
-	phpqt_setSmokePHPObject(o);
+	setSmokePHPObject(o);
 	zval_add_ref(&zval_ptr);
 
 	obj_x_smokephp.insert(zval_ptr->value.obj.handle, o);
@@ -423,9 +423,9 @@
 }
 
 smokephp_object*
-phpqt_createOriginal(zval* zval_ptr, void* ptr)
+PHPQt::createOriginal(zval* zval_ptr, void* ptr)
 {
-	smokephp_object* o = phpqt_getSmokePHPObjectFromQt(ptr);
+	smokephp_object* o = getSmokePHPObjectFromQt(ptr);
 /* 		ZVAL_ZVAL(zval_ptr, o->zval_ptr, 1, 0);
 // 		zval_ptr->is_ref = 1;
 		Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;

Modified: trunk/php_qt/phpqt_internals.h
===================================================================
--- trunk/php_qt/phpqt_internals.h	2007-06-06 21:40:45 UTC (rev 338)
+++ trunk/php_qt/phpqt_internals.h	2007-06-07 07:57:36 UTC (rev 339)
@@ -28,24 +28,28 @@
 
 #include "php_qt.h"
 
-void 				phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc);
+namespace PHPQt {
 
-zval* 				phpqt_callPHPMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params);
-bool 				phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname);
-bool 				phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* metachar, QString* meta_stringdata, uint* signature);
-int					phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
-char*				phpqt_checkForOperator(const char* fname);
+void 				destroyHashtable(zend_rsrc_list_entry *rsrc);
 
-void* 				phpqt_getQtObjectFromZval(zval* this_ptr);
-smokephp_object* 	phpqt_getSmokePHPObjectFromZval(zval* this_ptr);
-smokephp_object*	phpqt_getSmokePHPObjectFromQt(void* QtPtr);
-void				phpqt_setSmokePHPObject(smokephp_object* o);
-bool 				phpqt_SmokePHPObjectExists(zval* this_ptr);
-bool				phpqt_SmokePHPObjectExists(void* ptr);
+zval* 				callPHPMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params);
+bool 				methodExists(zend_class_entry* ce_ptr, char* methodname);
+bool 				getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* metachar, QString* meta_stringdata, uint* signature);
+int					metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
+char*				checkForOperator(const char* fname);
 
-bool				phpqt_unmapSmokePHPObject(zval* o);
+void* 				getQtObjectFromZval(zval* this_ptr);
+smokephp_object* 	getSmokePHPObjectFromZval(zval* this_ptr);
+smokephp_object*	getSmokePHPObjectFromQt(void* QtPtr);
+void				setSmokePHPObject(smokephp_object* o);
+bool 				SmokePHPObjectExists(zval* this_ptr);
+bool				SmokePHPObjectExists(void* ptr);
 
-smokephp_object*	phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL, Smoke::Index classId = 0);
-smokephp_object*	phpqt_createOriginal(zval* zval_ptr, void* ptr);
+bool				unmapSmokePHPObject(zval* o);
 
+smokephp_object*	createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL, Smoke::Index classId = 0);
+smokephp_object*	createOriginal(zval* zval_ptr, void* ptr);
+
+} // namespace PHPQt
+
 #endif

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-06-06 21:40:45 UTC (rev 338)
+++ trunk/php_qt/qstring.cpp	2007-06-07 07:57:36 UTC (rev 339)
@@ -33,6 +33,7 @@
 
 #include "php_qt.h"
 #include "phpqt_internals.h"
+using namespace PHPQt;
 
 zend_class_entry* qstring_ce;
 extern Smoke* qt_Smoke;
@@ -183,7 +184,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -199,8 +200,8 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) getQtObjectFromZval(z_1);
 
 
 			}
@@ -219,7 +220,7 @@
 			QString *obj = (QString*) PHP_QT_FETCH();
 				const ushort * return_object = (const ushort *) obj->utf16();
 				void* ptr = (void*) &return_object;
-				phpqt_createObject(return_value,(void*) return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 	}
 }
@@ -236,7 +237,7 @@
 				const QChar * return_object = (const QChar *) obj->constData();
 
 
-				phpqt_createObject(return_value,(void*) return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 	}
 }
@@ -263,12 +264,12 @@
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->insert((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
 				return_value = (zval*) emalloc(sizeof(zval));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
+			QObject* obj_z_1 = (QObject*) getQtObjectFromZval(z_1);
 
 
 			}
@@ -285,7 +286,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
+			QObject* obj_z_1 = (QObject*) getQtObjectFromZval(z_1);
 
 
 			}
@@ -327,7 +328,7 @@
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->setUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
 				return_value = (zval*) emalloc(sizeof(zval));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -358,19 +359,19 @@
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->prepend((char) Z_LVAL_P(z_0));
 				return_value = (zval*) emalloc(sizeof(zval));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_STRING){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->prepend( (const char*) Z_STRVAL_P(z_0));
 				return_value = (zval*) emalloc(sizeof(zval));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -388,7 +389,7 @@
 	if (ZEND_NUM_ARGS() == 0){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->trimmed();
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 	}
 }
@@ -437,7 +438,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->leftJustified((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(bool) Z_LVAL_P(z_2));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -478,7 +479,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -497,7 +498,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -529,7 +530,7 @@
 			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->fromAscii( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -572,7 +573,7 @@
 	if (ZEND_NUM_ARGS() == 0){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->toUpper();
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 	}
 }
@@ -587,7 +588,7 @@
 
 	if (ZEND_NUM_ARGS() == 0){
 	    QString *QString_ptr = new QString();
-	    phpqt_createObject(getThis(), (void*) QString_ptr, qstring_ce, QSTRING_CLASSID);
+	    createObject(getThis(), (void*) QString_ptr, qstring_ce, QSTRING_CLASSID);
 	    RETURN_NULL();
 	}
 
@@ -596,20 +597,20 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG){
 				QString *QString_ptr = new QString((char) Z_LVAL_P(z_0));
-				phpqt_createObject(getThis(), (void*) QString_ptr, qstring_ce, QSTRING_CLASSID);
+				createObject(getThis(), (void*) QString_ptr, qstring_ce, QSTRING_CLASSID);
 				RETURN_NULL();
 			}
 			if(Z_TYPE_P(z_0) == IS_STRING){
 				QString *QString_ptr = new QString( (const char*) Z_STRVAL_P(z_0));
-				phpqt_createObject(getThis(), (void*) QString_ptr, qstring_ce, QSTRING_CLASSID);
+				createObject(getThis(), (void*) QString_ptr, qstring_ce, QSTRING_CLASSID);
 				RETURN_NULL();
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
-				smokephp_object *o = phpqt_getSmokePHPObjectFromZval(z_0);
+				smokephp_object *o = getSmokePHPObjectFromZval(z_0);
 				if(o->ce_ptr == qstring_ce){
 				    QString *QString_ptr = new QString(*((QString*) o->ptr));
 				}
-				phpqt_createObject(getThis(), (void*) o->ptr, o->ce_ptr);
+				createObject(getThis(), (void*) o->ptr, o->ce_ptr);
 				RETURN_NULL();
 			}
 		}
@@ -620,14 +621,14 @@
 		zval *z_1; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			    smokephp_object* o = phpqt_getSmokePHPObjectFromZval(z_0);
+			    smokephp_object* o = getSmokePHPObjectFromZval(z_0);
 // TODO type checking
-    			    phpqt_createObject(getThis(), o->ptr, o->ce_ptr);
+    			    createObject(getThis(), o->ptr, o->ce_ptr);
 			    RETURN_NULL();
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			    QString *QString_ptr = new QString((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
-			    phpqt_createObject(getThis(), QString_ptr, qstring_ce, QSTRING_CLASSID);
+			    createObject(getThis(), QString_ptr, qstring_ce, QSTRING_CLASSID);
 			    RETURN_NULL();
 			}
 		}
@@ -654,7 +655,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->normalized((QString::NormalizationForm) Z_LVAL_P(z_0));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -670,7 +671,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->normalized((QString::NormalizationForm) Z_LVAL_P(z_0) ,(QChar::UnicodeVersion) Z_LVAL_P(z_1));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -695,7 +696,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->fromUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -734,7 +735,7 @@
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->setNum((short) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
 				return_value = (zval*) emalloc(sizeof(zval));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -755,14 +756,14 @@
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->setNum((float) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
 				return_value = (zval*) emalloc(sizeof(zval));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->setNum((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
 				return_value = (zval*) emalloc(sizeof(zval));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -786,7 +787,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -817,13 +818,13 @@
 				QString obj = (QString) QString::number((ulong) Z_LVAL_P(z_0));
 				QString *s1 = new QString(obj);
 
-				phpqt_createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
+				createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
 				return;
 			} else if(Z_TYPE_P(z_0) == IS_DOUBLE){
 				QString obj = (QString) QString::number((double) Z_DVAL_P(z_0));
 				QString *s1 = new QString(obj);
 
-				phpqt_createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
+				createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 
@@ -837,13 +838,13 @@
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->number((ulong) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->number((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -857,7 +858,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->number((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -881,7 +882,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -897,8 +898,8 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) getQtObjectFromZval(z_1);
 
 
 			}
@@ -929,12 +930,12 @@
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->section((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(QString::SectionFlags) Z_LVAL_P(z_3));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -978,7 +979,7 @@
 	if (ZEND_NUM_ARGS() == 0){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->simplified();
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 	}
 }
@@ -1103,7 +1104,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->right((int) Z_LVAL_P(z_0));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -1136,7 +1137,7 @@
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -1200,7 +1201,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -1220,7 +1221,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -1251,7 +1252,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -1290,7 +1291,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->left((int) Z_LVAL_P(z_0));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -1315,7 +1316,7 @@
 			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->fromLocal8Bit( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -1339,7 +1340,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -1363,7 +1364,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -1382,7 +1383,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -1390,7 +1391,7 @@
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->remove((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
 				return_value = (zval*) emalloc(sizeof(zval));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -1428,8 +1429,8 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) getQtObjectFromZval(z_1);
 
 
 			}
@@ -1452,22 +1453,22 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
-			QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) getQtObjectFromZval(z_1);
+			QObject* obj_z_2 = (QObject*) getQtObjectFromZval(z_2);
 
 
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
-			QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
+			QObject* obj_z_2 = (QObject*) getQtObjectFromZval(z_2);
 
 
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
+			QObject* obj_z_2 = (QObject*) getQtObjectFromZval(z_2);
 
 
 			}
@@ -1491,22 +1492,22 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_3 = (QObject*) phpqt_getQtObjectFromZval(z_3);
+			QObject* obj_z_3 = (QObject*) getQtObjectFromZval(z_3);
 
 
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_3 = (QObject*) phpqt_getQtObjectFromZval(z_3);
+			QObject* obj_z_3 = (QObject*) getQtObjectFromZval(z_3);
 
 
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
-			QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
-			QObject* obj_z_3 = (QObject*) phpqt_getQtObjectFromZval(z_3);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) getQtObjectFromZval(z_1);
+			QObject* obj_z_2 = (QObject*) getQtObjectFromZval(z_2);
+			QObject* obj_z_3 = (QObject*) getQtObjectFromZval(z_3);
 
 
 			}
@@ -1525,7 +1526,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzz", &z_0, &z_1, &z_2, &z_3, &z_4) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_4 = (QObject*) phpqt_getQtObjectFromZval(z_4);
+			QObject* obj_z_4 = (QObject*) getQtObjectFromZval(z_4);
 
 
 			}
@@ -1550,7 +1551,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
+			QObject* obj_z_1 = (QObject*) getQtObjectFromZval(z_1);
 
 
 			}
@@ -1687,7 +1688,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -1704,7 +1705,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -1729,7 +1730,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -1755,7 +1756,7 @@
 			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->fromLatin1( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -1772,7 +1773,7 @@
 	if (ZEND_NUM_ARGS() == 0){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QChar * return_object = (QChar *) obj->data();
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 	}
 }
@@ -1819,7 +1820,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -1838,7 +1839,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -1895,8 +1896,8 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) getQtObjectFromZval(z_1);
 
 
 			}
@@ -1923,25 +1924,25 @@
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG)
 			{
 				QString *obj = (QString*) PHP_QT_FETCH();
-				QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
-				QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
+				QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
+				QObject* obj_z_1 = (QObject*) getQtObjectFromZval(z_1);
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG)
 			{
 				QString *obj = (QString*) PHP_QT_FETCH();
-				QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
+				QObject* obj_z_1 = (QObject*) getQtObjectFromZval(z_1);
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG)
 			{
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->replace((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(char) Z_LVAL_P(z_2));
 				return_value = (zval*) emalloc(sizeof(zval));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
 				QString *obj = (QString*) PHP_QT_FETCH();
-				QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
+				QObject* obj_z_2 = (QObject*) getQtObjectFromZval(z_2);
 			}
 		}
 	}
@@ -1957,7 +1958,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
+			QObject* obj_z_2 = (QObject*) getQtObjectFromZval(z_2);
 
 
 			}
@@ -1982,7 +1983,7 @@
 				QString obj = (QString) QString::fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
 				QString *s1 = new QString(obj);
 
-				phpqt_createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
+				createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
 				return;
 
 			    }
@@ -2048,7 +2049,7 @@
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->append((char) Z_LVAL_P(z_0));
 				return_value = (zval*) emalloc(sizeof(zval));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			/* QString & append ( const char * str ) */
@@ -2057,7 +2058,7 @@
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString&) obj->append( (const char*) Z_STRVAL_P(z_0) );
 				return_value = (zval*) emalloc(sizeof(zval));
- 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+ 				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 
@@ -2065,10 +2066,10 @@
 			    QString & append ( const QByteArray & ba )
 			    QString & append ( const QString & str ) */
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			    smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
-			    QString* obj_z_0 = (QString*) phpqt_getQtObjectFromZval(z_0);
+			    smokephp_object* o = getSmokePHPObjectFromZval(getThis());
+			    QString* obj_z_0 = (QString*) getQtObjectFromZval(z_0);
 			    QString* s = new QString(((QString*) o->ptr)->append((QString) *obj_z_0));
-			    phpqt_createObject(return_value, s, qstring_ce, QSTRING_CLASSID);
+			    createObject(return_value, s, qstring_ce, QSTRING_CLASSID);
 			    return;
 			}
 		}
@@ -2094,7 +2095,7 @@
 			{
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->mid((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -2147,7 +2148,7 @@
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->fill((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
 				return_value = (zval*) emalloc(sizeof(zval));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -2175,7 +2176,7 @@
 			{
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->rightJustified((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(bool) Z_LVAL_P(z_2));
-				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 		}
@@ -2194,7 +2195,7 @@
 	{
 		QString *obj = (QString*) PHP_QT_FETCH();
 		QString return_object = (QString) obj->toLower();
-		phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+		createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 		return;
 	}
 }
@@ -2216,7 +2217,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -2236,7 +2237,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}
@@ -2262,7 +2263,7 @@
 	{
 		QString *obj = (QString*) PHP_QT_FETCH();
 		const QChar * return_object = (const QChar *) obj->unicode();
-		phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+		createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
 		return;
 	}
 }
@@ -2331,7 +2332,7 @@
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_0 = (QObject*) getQtObjectFromZval(z_0);
 
 
 			}

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-06-06 21:40:45 UTC (rev 338)
+++ trunk/php_qt/smokephp.cpp	2007-06-07 07:57:36 UTC (rev 339)
@@ -50,8 +50,8 @@
 
     virtual void deleted(Smoke::Index classId, void* ptr) {
         qDebug("deleted");
-        if(phpqt_SmokePHPObjectExists(ptr)){
-			smokephp_object *o = (smokephp_object*) phpqt_getSmokePHPObjectFromQt(ptr);
+        if(PHPQt::SmokePHPObjectExists(ptr)){
+			smokephp_object *o = (smokephp_object*) PHPQt::getSmokePHPObjectFromQt(ptr);
 			if(!o->allocated){
 				delete (QObject*) ptr;
 				efree(o);
@@ -63,7 +63,7 @@
     }
     virtual bool callMethod(Smoke::Index method, void* QtPtr, Smoke::Stack args, bool /*isAbstract*/) {
 
-		smokephp_object *o = (smokephp_object*) phpqt_getSmokePHPObjectFromQt(QtPtr);
+		smokephp_object *o = (smokephp_object*) PHPQt::getSmokePHPObjectFromQt(QtPtr);
 
 		if(!o){
 			// no related smokephp_object
@@ -79,11 +79,11 @@
 		}
 
 		if(!strcmp(methodName, "qt_metacall")){
-			phpqt_metacall(o, args, (QMetaObject::Call) args[1].s_enum, args[2].s_int, (void**) args[3].s_voidp);
+			PHPQt::metacall(o, args, (QMetaObject::Call) args[1].s_enum, args[2].s_int, (void**) args[3].s_voidp);
 			return true;
 		}
 
-		if(phpqt_methodExists(o->ce_ptr, (char*) methodName)){
+		if(PHPQt::methodExists(o->ce_ptr, (char*) methodName)){
 // 			zval* zmem = ALLOCA_N(zval, smoke->methods[method].numArgs);
 			zval* zmem = (zval*) safe_emalloc(sizeof(zval), smoke->methods[method].numArgs,0);
 		    VirtualMethodCall c(smoke, method, args, o->zval_ptr, &zmem, &o->zval_ptr);
@@ -260,7 +260,7 @@
 
 	smokephp_object *o;
 	if(type == IS_OBJECT)
-		o = phpqt_getSmokePHPObjectFromZval(((zval*) *val));
+		o = PHPQt::getSmokePHPObjectFromZval(((zval*) *val));
 
 	switch(type){
 		case IS_STRING:
@@ -399,7 +399,7 @@
 		if(Z_OBJCE_P(((zval*) *argv[i])) == qstring_ce)
 		    mocStack[i+1].argType = xmoc_QString;
 		else {
-		    smokephp_object *o = phpqt_getSmokePHPObjectFromZval((zval*) *argv[i]);
+		    smokephp_object *o = PHPQt::getSmokePHPObjectFromZval((zval*) *argv[i]);
 		    mocStack[i+1].st = SmokeType(PQ::smoke(),o->classId);
 		    mocStack[i+1].argType = xmoc_void;
 		}
@@ -424,7 +424,7 @@
  	uint type = ((int) ((zval) **args[j]).type);    // als Macro!
 	if (type == IS_OBJECT) {
 		if(Z_OBJCE_PP(args[j]) == qstring_ce) {
-		QString* o = (QString*) phpqt_getQtObjectFromZval(*args[j]);
+		QString* o = (QString*) PHPQt::getQtObjectFromZval(*args[j]);
 		qargs[j+1].s_voidp = (void*) o->toAscii().constData();
 	    }
 	}



From tm243 at mail.berlios.de  Thu Jun  7 22:21:18 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Thu, 7 Jun 2007 22:21:18 +0200
Subject: [Php-qt-svn] r340 - trunk/php_qt
Message-ID: <200706072021.l57KLI00012277@sheep.berlios.de>

Author: tm243
Date: 2007-06-07 22:21:15 +0200 (Thu, 07 Jun 2007)
New Revision: 340

Added:
   trunk/php_qt/qstring.h
Modified:
   trunk/php_qt/functions.cpp
   trunk/php_qt/handlers.cpp
   trunk/php_qt/marshall_basetypes.h
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/phpqt_internals.cpp
   trunk/php_qt/phpqt_internals.h
   trunk/php_qt/qstring.cpp
   trunk/php_qt/smokephp.cpp
   trunk/php_qt/smokephp.h
   trunk/php_qt/zend_handlers.cpp
   trunk/php_qt/zend_handlers.h
Log:
* more cleanup



Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/functions.cpp	2007-06-07 20:21:15 UTC (rev 340)
@@ -1,8 +1,8 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2006
- * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Copyright (C) 2006 - 2007
+ * Thomas Moenicke <tm at php-qt.org>
  * Katrina Niolet <katrina at niolet.name>
  *
  * This program is free software; you can redistribute it and/or

Modified: trunk/php_qt/handlers.cpp
===================================================================
--- trunk/php_qt/handlers.cpp	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/handlers.cpp	2007-06-07 20:21:15 UTC (rev 340)
@@ -1,11 +1,24 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
+/*!
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006 - 2007
+ * Thomas Moenicke <tm at php-qt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
 
 #include <QtGui/QWidget>
 #include <QtCore/qprocess.h>

Modified: trunk/php_qt/marshall_basetypes.h
===================================================================
--- trunk/php_qt/marshall_basetypes.h	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/marshall_basetypes.h	2007-06-07 20:21:15 UTC (rev 340)
@@ -1,15 +1,27 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
+/*!
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006 - 2007
+ * Thomas Moenicke <tm at php-qt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
 
 #include "marshall_types.h"
 #include <QtCore/QHash>
-// extern QHash<zval*, smokephp_object*> zval_x_smokephp;
 
 template <class T> T* smoke_ptr(Marshall *m) { return (T*) m->item().s_voidp; }
 
@@ -60,7 +72,7 @@
 	zval* v = m->var();
 
 	if (Z_TYPE_P(v) == IS_OBJECT) {
-		// A Qt::Enum is a subclass of Qt::Integer, so 'get_qinteger()' can be called ok
+	// A Qt::Enum is a subclass of Qt::Integer, so 'get_qinteger()' can be called ok
 	} else {
 		m->item().s_enum = (long) Z_LVAL_P(v);
 	}
@@ -86,7 +98,6 @@
 
 	if(!/*SmokePHPObjectExists*/(v)) {
 		check_qobject(v);
-// 		php_error(E_ERROR, "Invalid type, expecting %s, %s given\n", m->type().name(), zend_zval_type_name(v));
 		php_error(E_ERROR, "Invalid type, expecting %s, %s given (probably PHP-Qt lost the Qt object)\n", m->type().name(), Z_OBJCE_P(v)->name);
 		return;
 	}
@@ -175,7 +186,6 @@
 			_ce = zend_fetch_class(__className, __strLenClassName, ZEND_FETCH_CLASS_AUTO TSRMLS_DC);
 	    }
 
-// #warning parent_ce in createObject
 		smokephp_object *o = PHPQt::createObject(m->var(), __p, _ce, m->type().classId());
 
 //	    if(m->type().isConst() && m->type().isRef()) {

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/marshall_types.cpp	2007-06-07 20:21:15 UTC (rev 340)
@@ -1,21 +1,28 @@
-/***************************************************************************
-    marshall_types.cpp - Derived from the QtRuby and PerlQt sources, see AUTHORS
-                         for details
-                             -------------------
-    begin                : March 21 2007
-    copyright            : (C) 2007 by Thomas Moenicke
-    email                : tm at php-qt.org
- ***************************************************************************/
+/*!
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006 - 2007
+ * Thomas Moenicke <tm at php-qt.org>
+ *
+ * marshall_types.cpp - Derived from the QtRuby and PerlQt sources, see AUTHORS
+ *                       for details
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
 
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
 #include "marshall_types.h"
 #include "phpqt_internals.h"
 

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/php_qt.cpp	2007-06-07 20:21:15 UTC (rev 340)
@@ -2,7 +2,7 @@
  * PHP-Qt - The PHP language bindings for Qt
  *
  * Copyright (C) 2006 - 2007
- * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Thomas Moenicke <tm at php-qt.org>
  * Katrina Niolet <katrina at niolet.name>
  *
  * This program is free software; you can redistribute it and/or
@@ -21,16 +21,14 @@
  *
  */
 
+#include <QtCore/qglobal.h>
+#include <QtCore/QHash>
 
 #include "php_qt.h"
+#include "ext/standard/info.h"
 #include "ext/standard/php_string.h"
 
-#include <QtCore/qglobal.h>
-
-#include "marshall.h"
-#include "php_qt.h"
 #include "zend_handlers.h"
-#include "smokephp.h"
 #include "smoke.h"
 #include "marshall_types.h"
 #include "phpqt_internals.h"

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/php_qt.h	2007-06-07 20:21:15 UTC (rev 340)
@@ -2,7 +2,7 @@
  * PHP-Qt - The PHP language bindings for Qt
  *
  * Copyright (C) 2006 - 2007
- * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Thomas Moenicke <tm at php-qt.org>
  * Katrina Niolet <katrina at niolet.name>
  *
  * This program is free software; you can redistribute it and/or
@@ -38,15 +38,11 @@
 
 #include <zend.h>
 #include <zend_interfaces.h>
-#include "php.h"
-#include "php_ini.h"
-#include "ext/standard/info.h"
+#include <php.h>
+#include <php_ini.h>
 
 #include "smoke.h"
-#include "smokephp.h"
 
-#include <QtCore/QStack>
-#include <QtCore/QHash>
 #include <QtCore/QString>
 #include <QtCore/QMetaObject>
 
@@ -165,97 +161,6 @@
 
 };
 
-bool 				smokephp_isQObject(Smoke::Index classId);
-void				smokephp_prepareMethodName(zval*** args, int argc, QStack<QByteArray*> &methodNameStack);
-QByteArray* 		smokephp_getSignature(int argc, zval ***argv, MocArgument* mocStack);
-Smoke::Index		smokephp_getMethod(const char* c, const char* m, int argc, zval*** args);
-void				smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method);
-void				smokephp_callMethod(void *obj, Smoke::Index method, Smoke::Stack qargs);
-void				smokephp_init();
-
-void* 				transformArray(zval* args);
-
-ZEND_METHOD(QString, __toString);
-ZEND_METHOD(QString, compare);
-ZEND_METHOD(QString, utf16);
-ZEND_METHOD(QString, constData);
-ZEND_METHOD(QString, insert);
-ZEND_METHOD(QString, clear);
-ZEND_METHOD(QString, setUtf16);
-ZEND_METHOD(QString, prepend);
-ZEND_METHOD(QString, trimmed);
-ZEND_METHOD(QString, chop);
-ZEND_METHOD(QString, leftJustified);
-ZEND_METHOD(QString, squeeze);
-ZEND_METHOD(QString, count);
-ZEND_METHOD(QString, fromAscii);
-ZEND_METHOD(QString, toLongLong);
-ZEND_METHOD(QString, toUpper);
-ZEND_METHOD(QString, __construct);
-ZEND_METHOD(QString, normalized);
-ZEND_METHOD(QString, fromUtf16);
-ZEND_METHOD(QString, isRightToLeft);
-ZEND_METHOD(QString, setNum);
-ZEND_METHOD(QString, endsWith);
-ZEND_METHOD(QString, number);
-ZEND_METHOD(QString, localeAwareCompare);
-ZEND_METHOD(QString, section);
-ZEND_METHOD(QString, isSimpleText);
-ZEND_METHOD(QString, size);
-ZEND_METHOD(QString, simplified);
-ZEND_METHOD(QString, toUInt);
-ZEND_METHOD(QString, toUShort);
-ZEND_METHOD(QString, truncate);
-ZEND_METHOD(QString, toAscii);
-ZEND_METHOD(QString, length);
-ZEND_METHOD(QString, right);
-ZEND_METHOD(QString, push_front);
-ZEND_METHOD(QString, toUtf8);
-ZEND_METHOD(QString, toULongLong);
-ZEND_METHOD(QString, indexOf);
-ZEND_METHOD(QString, fromRawData);
-ZEND_METHOD(QString, constEnd);
-ZEND_METHOD(QString, left);
-ZEND_METHOD(QString, fromLocal8Bit);
-ZEND_METHOD(QString, startsWith);
-ZEND_METHOD(QString, remove);
-ZEND_METHOD(QString, isEmpty);
-ZEND_METHOD(QString, arg);
-ZEND_METHOD(QString, vsprintf);
-ZEND_METHOD(QString, toFloat);
-ZEND_METHOD(QString, isDetached);
-ZEND_METHOD(QString, reserve);
-ZEND_METHOD(QString, toULong);
-ZEND_METHOD(QString, toShort);
-ZEND_METHOD(QString, split);
-ZEND_METHOD(QString, setUnicode);
-ZEND_METHOD(QString, fromLatin1);
-ZEND_METHOD(QString, data);
-ZEND_METHOD(QString, toLatin1);
-ZEND_METHOD(QString, end);
-ZEND_METHOD(QString, contains);
-ZEND_METHOD(QString, resize);
-ZEND_METHOD(QString, replace);
-ZEND_METHOD(QString, fromUtf8);
-ZEND_METHOD(QString, toLong);
-ZEND_METHOD(QString, detach);
-ZEND_METHOD(QString, append);
-ZEND_METHOD(QString, mid);
-ZEND_METHOD(QString, toDouble);
-ZEND_METHOD(QString, fill);
-ZEND_METHOD(QString, rightJustified);
-ZEND_METHOD(QString, toLower);
-ZEND_METHOD(QString, lastIndexOf);
-ZEND_METHOD(QString, unicode);
-ZEND_METHOD(QString, at);
-ZEND_METHOD(QString, begin);
-ZEND_METHOD(QString, push_back);
-ZEND_METHOD(QString, capacity);
-ZEND_METHOD(QString, constBegin);
-ZEND_METHOD(QString, toLocal8Bit);
-ZEND_METHOD(QString, toInt);
-ZEND_METHOD(QString, isNull);
-
 ZEND_METHOD(php_qt_generic_class, __construct);
 ZEND_METHOD(php_qt_generic_class, __destruct);
 ZEND_METHOD(php_qt_generic_class, __toString);

Modified: trunk/php_qt/phpqt_internals.cpp
===================================================================
--- trunk/php_qt/phpqt_internals.cpp	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/phpqt_internals.cpp	2007-06-07 20:21:15 UTC (rev 340)
@@ -2,7 +2,7 @@
  * PHP-Qt - The PHP language bindings for Qt
  *
  * Copyright (C) 2006 - 2007
- * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Thomas Moenicke <tm at php-qt.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -22,6 +22,7 @@
 
 #include "phpqt_internals.h"
 
+#include <QtCore/QHash>
 #include <QtCore/QMetaMethod>
 #include <zend.h>
 #include "smoke.h"

Modified: trunk/php_qt/phpqt_internals.h
===================================================================
--- trunk/php_qt/phpqt_internals.h	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/phpqt_internals.h	2007-06-07 20:21:15 UTC (rev 340)
@@ -1,8 +1,8 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2006
- * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Copyright (C) 2006 - 2007
+ * Thomas Moenicke <tm at php-qt.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/qstring.cpp	2007-06-07 20:21:15 UTC (rev 340)
@@ -1,23 +1,22 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005 - 2007
- * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
+ * Copyright (C) 2006 - 2007
+ * Thomas Moenicke <tm at php-qt.org>
  *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  *
  * QString.cpp - QString PHP implementation.
  * begin           : Wed Jan 18 23:31:01 2006
@@ -26,14 +25,13 @@
 
 #include <iostream>
 using namespace std;
-#include <QtCore/QDebug>
 
+#include <QtCore/QDebug>
 #include <QtCore/QString>
-#include <zend_interfaces.h>
 
-#include "php_qt.h"
 #include "phpqt_internals.h"
 using namespace PHPQt;
+#include "qstring.h"
 
 zend_class_entry* qstring_ce;
 extern Smoke* qt_Smoke;

Added: trunk/php_qt/qstring.h
===================================================================
--- trunk/php_qt/qstring.h	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/qstring.h	2007-06-07 20:21:15 UTC (rev 340)
@@ -0,0 +1,104 @@
+/*!
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006 - 2007
+ * Thomas Moenicke <tm at php-qt.org>
+ * Katrina Niolet <katrina at niolet.name>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+
+ ZEND_METHOD(QString, __toString);
+ZEND_METHOD(QString, compare);
+ZEND_METHOD(QString, utf16);
+ZEND_METHOD(QString, constData);
+ZEND_METHOD(QString, insert);
+ZEND_METHOD(QString, clear);
+ZEND_METHOD(QString, setUtf16);
+ZEND_METHOD(QString, prepend);
+ZEND_METHOD(QString, trimmed);
+ZEND_METHOD(QString, chop);
+ZEND_METHOD(QString, leftJustified);
+ZEND_METHOD(QString, squeeze);
+ZEND_METHOD(QString, count);
+ZEND_METHOD(QString, fromAscii);
+ZEND_METHOD(QString, toLongLong);
+ZEND_METHOD(QString, toUpper);
+ZEND_METHOD(QString, __construct);
+ZEND_METHOD(QString, normalized);
+ZEND_METHOD(QString, fromUtf16);
+ZEND_METHOD(QString, isRightToLeft);
+ZEND_METHOD(QString, setNum);
+ZEND_METHOD(QString, endsWith);
+ZEND_METHOD(QString, number);
+ZEND_METHOD(QString, localeAwareCompare);
+ZEND_METHOD(QString, section);
+ZEND_METHOD(QString, isSimpleText);
+ZEND_METHOD(QString, size);
+ZEND_METHOD(QString, simplified);
+ZEND_METHOD(QString, toUInt);
+ZEND_METHOD(QString, toUShort);
+ZEND_METHOD(QString, truncate);
+ZEND_METHOD(QString, toAscii);
+ZEND_METHOD(QString, length);
+ZEND_METHOD(QString, right);
+ZEND_METHOD(QString, push_front);
+ZEND_METHOD(QString, toUtf8);
+ZEND_METHOD(QString, toULongLong);
+ZEND_METHOD(QString, indexOf);
+ZEND_METHOD(QString, fromRawData);
+ZEND_METHOD(QString, constEnd);
+ZEND_METHOD(QString, left);
+ZEND_METHOD(QString, fromLocal8Bit);
+ZEND_METHOD(QString, startsWith);
+ZEND_METHOD(QString, remove);
+ZEND_METHOD(QString, isEmpty);
+ZEND_METHOD(QString, arg);
+ZEND_METHOD(QString, vsprintf);
+ZEND_METHOD(QString, toFloat);
+ZEND_METHOD(QString, isDetached);
+ZEND_METHOD(QString, reserve);
+ZEND_METHOD(QString, toULong);
+ZEND_METHOD(QString, toShort);
+ZEND_METHOD(QString, split);
+ZEND_METHOD(QString, setUnicode);
+ZEND_METHOD(QString, fromLatin1);
+ZEND_METHOD(QString, data);
+ZEND_METHOD(QString, toLatin1);
+ZEND_METHOD(QString, end);
+ZEND_METHOD(QString, contains);
+ZEND_METHOD(QString, resize);
+ZEND_METHOD(QString, replace);
+ZEND_METHOD(QString, fromUtf8);
+ZEND_METHOD(QString, toLong);
+ZEND_METHOD(QString, detach);
+ZEND_METHOD(QString, append);
+ZEND_METHOD(QString, mid);
+ZEND_METHOD(QString, toDouble);
+ZEND_METHOD(QString, fill);
+ZEND_METHOD(QString, rightJustified);
+ZEND_METHOD(QString, toLower);
+ZEND_METHOD(QString, lastIndexOf);
+ZEND_METHOD(QString, unicode);
+ZEND_METHOD(QString, at);
+ZEND_METHOD(QString, begin);
+ZEND_METHOD(QString, push_back);
+ZEND_METHOD(QString, capacity);
+ZEND_METHOD(QString, constBegin);
+ZEND_METHOD(QString, toLocal8Bit);
+ZEND_METHOD(QString, toInt);
+ZEND_METHOD(QString, isNull);
+

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/smokephp.cpp	2007-06-07 20:21:15 UTC (rev 340)
@@ -2,7 +2,7 @@
  * PHP-Qt - The PHP language bindings for Qt
  *
  * Copyright (C) 2006 - 2007
- * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Thomas Moenicke <tm at php-qt.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License

Modified: trunk/php_qt/smokephp.h
===================================================================
--- trunk/php_qt/smokephp.h	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/smokephp.h	2007-06-07 20:21:15 UTC (rev 340)
@@ -16,7 +16,8 @@
 #include "php.h"
 #define Qnil (zval *) NULL
 
-#include <QtCore/qbytearray.h>
+#include <QtCore/QStack>
+#include <QtCore/QByteArray>
 
 #include "php_qt.h"
 #include "marshall.h"
@@ -174,7 +175,7 @@
     void setAllocated(bool isAllocated) { _isAllocated = isAllocated; }
 };
 
- 
+
 /**
  * SmokeObject is a thin wrapper around zval* objects. Each SmokeObject instance
  * increments the refcount of its zval* for the duration of its existance.
@@ -189,16 +190,16 @@
 public:
     SmokeObject(zval* obj, Smoke_MAGIC *mag) : rv(obj), m(mag) {
     }
-    
+
     ~SmokeObject() {
     }
-    
+
     SmokeObject(const SmokeObject &other) {
 	rv = other.rv;
 	m = other.m;
 
     }
-    
+
     SmokeObject &operator =(const SmokeObject &other) {
 	rv = other.rv;
 	m = other.m;
@@ -320,4 +321,14 @@
     MocArgumentType argType;
 };
 
+bool 				smokephp_isQObject(Smoke::Index classId);
+void				smokephp_prepareMethodName(zval*** args, int argc, QStack<QByteArray*> &methodNameStack);
+QByteArray* 		smokephp_getSignature(int argc, zval ***argv, MocArgument* mocStack);
+Smoke::Index		smokephp_getMethod(const char* c, const char* m, int argc, zval*** args);
+void				smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method);
+void				smokephp_callMethod(void *obj, Smoke::Index method, Smoke::Stack qargs);
+void				smokephp_init();
+
+void* 				transformArray(zval* args);
+
 #endif // SMOKEPHP_H

Modified: trunk/php_qt/zend_handlers.cpp
===================================================================
--- trunk/php_qt/zend_handlers.cpp	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/zend_handlers.cpp	2007-06-07 20:21:15 UTC (rev 340)
@@ -2,7 +2,7 @@
  * PHP-Qt - The PHP language bindings for Qt
  *
  * Copyright (C) 2006 - 2007
- * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Thomas Moenicke <tm at php-qt.org>
  * Katrina Niolet <katrina at niolet.name>
  *
  * This program is free software; you can redistribute it and/or
@@ -24,6 +24,7 @@
 
 #include "zend_handlers.h"
 #include "php_qt.h"
+#include "smokephp.h"
 #include "ext/standard/php_string.h"
 
 extern QStack<QByteArray*> methodNameStack;

Modified: trunk/php_qt/zend_handlers.h
===================================================================
--- trunk/php_qt/zend_handlers.h	2007-06-07 07:57:36 UTC (rev 339)
+++ trunk/php_qt/zend_handlers.h	2007-06-07 20:21:15 UTC (rev 340)
@@ -2,7 +2,7 @@
  * PHP-Qt - The PHP language bindings for Qt
  *
  * Copyright (C) 2006
- * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Thomas Moenicke <tm at php-qt.org>
  * Katrina Niolet <katrina at niolet.name>
  *
  * This program is free software; you can redistribute it and/or



From tm243 at mail.berlios.de  Thu Jun  7 23:24:14 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Thu, 7 Jun 2007 23:24:14 +0200
Subject: [Php-qt-svn] r341 - trunk/php_qt
Message-ID: <200706072124.l57LOE8E018110@sheep.berlios.de>

Author: tm243
Date: 2007-06-07 23:24:13 +0200 (Thu, 07 Jun 2007)
New Revision: 341

Modified:
   trunk/php_qt/php_qt.cpp
Log:
* installed an underscore as prefix for classes (define CLASS_PREFIX 1)



Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-07 20:21:15 UTC (rev 340)
+++ trunk/php_qt/php_qt.cpp	2007-06-07 21:24:13 UTC (rev 341)
@@ -33,6 +33,7 @@
 #include "marshall_types.h"
 #include "phpqt_internals.h"
 
+// #define CLASS_PREFIX 1 // needed for IQuiP
 #define DEBUG 1
 #define MOC_DEBUG 0
 
@@ -396,8 +397,16 @@
 
 		// register zend class
 		zend_class_entry ce;
-		INIT_CLASS_ENTRY(ce, PQ::smoke()->classes[i].className, p);
-		ce.name_length = strlen(PQ::smoke()->classes[i].className);
+
+#ifdef CLASS_PREFIX
+		QByteArray* _className = new QByteArray("_");
+		_className->append(PQ::smoke()->classes[i].className);
+#else
+		QByteArray* _className = new QByteArray(PQ::smoke()->classes[i].className);
+#endif
+
+		INIT_CLASS_ENTRY(ce, _className->constData(), p);
+		ce.name_length = _className->size();
 		zend_class_entry* ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);
 		tmpCeTable[PQ::smoke()->classes[i].className] = ce_ptr;
 		// cache QObject



From tm243 at mail.berlios.de  Fri Jun  8 00:40:51 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Fri, 8 Jun 2007 00:40:51 +0200
Subject: [Php-qt-svn] r342 - trunk/php_qt
Message-ID: <200706072240.l57MepjM011740@sheep.berlios.de>

Author: tm243
Date: 2007-06-08 00:40:50 +0200 (Fri, 08 Jun 2007)
New Revision: 342

Modified:
   trunk/php_qt/php_qt.cpp
Log:
* repaired a comment 



Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-07 21:24:13 UTC (rev 341)
+++ trunk/php_qt/php_qt.cpp	2007-06-07 22:40:50 UTC (rev 342)
@@ -343,7 +343,7 @@
 {
 	this_ptr = NULL;
 
-	// do we have a parent::blablub() call?
+	// do we have a parent::foo() call?
 	if(EG(active_op_array)->scope){
 		if(EG(scope) == EG(active_op_array)->scope->parent)
 		{



From Katrina.Niolet at mail.berlios.de  Fri Jun  8 01:25:59 2007
From: Katrina.Niolet at mail.berlios.de (Katrina.Niolet at mail.berlios.de)
Date: Fri, 8 Jun 2007 01:25:59 +0200
Subject: [Php-qt-svn] r343 - in trunk/tutorials: t1 t2 t3 t4 t6 t7
Message-ID: <200706072325.l57NPxDL031213@sheep.berlios.de>

Author: Katrina Niolet
Date: 2007-06-08 01:25:58 +0200 (Fri, 08 Jun 2007)
New Revision: 343

Modified:
   trunk/tutorials/t1/main.php
   trunk/tutorials/t2/main.php
   trunk/tutorials/t3/main.php
   trunk/tutorials/t4/main.php
   trunk/tutorials/t6/main.php
   trunk/tutorials/t7/main.php
Log:
Removed call time pass by references from tutorials

Modified: trunk/tutorials/t1/main.php
===================================================================
--- trunk/tutorials/t1/main.php	2007-06-07 22:40:50 UTC (rev 342)
+++ trunk/tutorials/t1/main.php	2007-06-07 23:25:58 UTC (rev 343)
@@ -13,7 +13,7 @@
 		dl('php_qt.' . PHP_SHLIB_SUFFIX);
 	}
 
-	$app = new QApplication(&$argc,$argv);
+	$app = new QApplication($argc,$argv);
 	
 	$hello = new QPushButton("Hello world!");
 	$hello->resize(100, 30);

Modified: trunk/tutorials/t2/main.php
===================================================================
--- trunk/tutorials/t2/main.php	2007-06-07 22:40:50 UTC (rev 342)
+++ trunk/tutorials/t2/main.php	2007-06-07 23:25:58 UTC (rev 343)
@@ -13,7 +13,7 @@
 		dl('php_qt.' . PHP_SHLIB_SUFFIX);
 	}
 
-    $app = new QApplication(&$argc,$argv);
+    $app = new QApplication($argc,$argv);
 
     $quit = new QPushButton("Quit");
     $quit->resize(75,30);

Modified: trunk/tutorials/t3/main.php
===================================================================
--- trunk/tutorials/t3/main.php	2007-06-07 22:40:50 UTC (rev 342)
+++ trunk/tutorials/t3/main.php	2007-06-07 23:25:58 UTC (rev 343)
@@ -13,16 +13,16 @@
 		dl('php_qt.' . PHP_SHLIB_SUFFIX);
 	}
 
-    $app = new QApplication(&$argc,$argv);
+    $app = new QApplication($argc,$argv);
 
     $window = new QWidget();
     $window->resize(200,120);
 
-    $quit = new QPushButton("Quit", &$window);
+    $quit = new QPushButton("Quit", $window);
     $quit->setFont(new QFont("Times", 18, QFont::Bold));
     $quit->setGeometry(10, 40, 180, 40);
 
-    QObject::connect(&$quit,SIGNAL('clicked()'), &$app, SLOT('quit()'));
+    QObject::connect($quit,SIGNAL('clicked()'), $app, SLOT('quit()'));
 
     $window->show();
     $app->exec();

Modified: trunk/tutorials/t4/main.php
===================================================================
--- trunk/tutorials/t4/main.php	2007-06-07 22:40:50 UTC (rev 342)
+++ trunk/tutorials/t4/main.php	2007-06-07 23:25:58 UTC (rev 343)
@@ -34,7 +34,7 @@
 
     }
 
-    $app = new QApplication(&$argc,$argv);
+    $app = new QApplication($argc,$argv);
     $widget = new MyWidget();
     $widget->show();
     $app->exec();

Modified: trunk/tutorials/t6/main.php
===================================================================
--- trunk/tutorials/t6/main.php	2007-06-07 22:40:50 UTC (rev 342)
+++ trunk/tutorials/t6/main.php	2007-06-07 23:25:58 UTC (rev 343)
@@ -67,9 +67,9 @@
         }
     }
 
-    $app = new QApplication(&$argc,$argv);
+    $app = new QApplication($argc,$argv);
     $widget = new MyWidget();
     $widget->show();
     $app->exec();
 
-?>
\ No newline at end of file
+?>

Modified: trunk/tutorials/t7/main.php
===================================================================
--- trunk/tutorials/t7/main.php	2007-06-07 22:40:50 UTC (rev 342)
+++ trunk/tutorials/t7/main.php	2007-06-07 23:25:58 UTC (rev 343)
@@ -86,10 +86,10 @@
         }
     }
 
-    $app = new QApplication(&$argc,$argv);
+    $app = new QApplication($argc,$argv);
 
     $widget = new MyWidget();
     $widget->show();
     $app->exec();
 
-?>
\ No newline at end of file
+?>



From Katrina.Niolet at mail.berlios.de  Fri Jun  8 02:50:31 2007
From: Katrina.Niolet at mail.berlios.de (Katrina.Niolet at mail.berlios.de)
Date: Fri, 8 Jun 2007 02:50:31 +0200
Subject: [Php-qt-svn] r344 - trunk
Message-ID: <200706080050.l580oVPW016722@sheep.berlios.de>

Author: Katrina Niolet
Date: 2007-06-08 02:50:27 +0200 (Fri, 08 Jun 2007)
New Revision: 344

Modified:
   trunk/COPYING
Log:
Made licensing terms more clear, including:
* specified GPL version 2
* added specific language for terms of writing commercial applications

Modified: trunk/COPYING
===================================================================
--- trunk/COPYING	2007-06-07 23:25:58 UTC (rev 343)
+++ trunk/COPYING	2007-06-08 00:50:27 UTC (rev 344)
@@ -1,19 +1,48 @@
+Licensing
+===============
 
+PHP-Qt licensing is dependant upon the license of the dynamically linked Qt library.
+In the case that the linked Qt library is Qt Open Source Edition, PHP-Qt is licensed under the terms of the GNU General Public License version 2.
 
-About licensing
-===============
+You may write commercial, proprietary, or otherwise non-free software only if you have purchased a commercial edition of Qt.
+Purchase of a commercial edition of Qt, however, does not entitle you to support (technical or otherwise) for PHP-Qt of any kind.
+Additionally the following coditions apply to PHP-Qt when linked against Qt Commercial Edition:
 
-PHP-Qt is licensed under the terms of the GNU General Public License.
-Qt is dual licensed software. Please note that PHP-Qt is dynamically linked 
-against the Qt library, Qt header files are neccessary for building PHP-Qt.
+1. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
 
-Qt itself is under the GPL license, people writing closed source commercial software using Qt and php-qt
-bindings need a commercial license if they are not prepared to open source license their own code.
+2. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
 
-More informations can be found here:
-http://www.trolltech.com/download/opensource.html
+3. By linking PHP-Qt against Qt Commercial Edition you indicate your acceptance of
+these conditions.
 
+If you want to develop Free or Open Source software for release under the GPL,
+you can link against the Qt Open Source Edition.
 
+Please note that PHP-Qt is dynamically linked against the Qt library and
+Qt header files are neccessary for building PHP-Qt.
+
+More information can be found here:
+Qt licensing:			http://www.trolltech.com/products/qt/licenses/licensing/
+Qt Open Source Edition:	http://www.trolltech.com/download/opensource.html
+GPL License:			http://www.gnu.org/licenses/gpl.html
+
+
 Trademarks
 ==========
 



From tm243 at mail.berlios.de  Fri Jun  8 15:51:01 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Fri, 8 Jun 2007 15:51:01 +0200
Subject: [Php-qt-svn] r345 - in trunk: examples/calculator kalyptus php_qt
	smoke smoke/web
Message-ID: <200706081351.l58Dp11b008147@sheep.berlios.de>

Author: tm243
Date: 2007-06-08 15:50:59 +0200 (Fri, 08 Jun 2007)
New Revision: 345

Added:
   trunk/kalyptus/kalyptusCxxToWebSmoke.pm
   trunk/smoke/web/
   trunk/smoke/web/CMakeLists.txt
   trunk/smoke/web/Makefile.am
   trunk/smoke/web/Makefile.in
   trunk/smoke/web/configure.in.in
   trunk/smoke/web/generate.pl.cmake
   trunk/smoke/web/generate.pl.in
   trunk/smoke/web/generate_makefile_am.pl
   trunk/smoke/web/header_list
   trunk/smoke/web/hint_header_list.pl
   trunk/smoke/web/qscintilla2_header_list
   trunk/smoke/web/qscintilla_header_list
   trunk/smoke/web/qt_smoke.h
   trunk/smoke/web/qtdbus_header_list
   trunk/smoke/web/qtguess.pl.cmake
   trunk/smoke/web/qtguess.pl.in
   trunk/smoke/web/qwt_header_list
   trunk/smoke/web/smokeqt.pro
Modified:
   trunk/examples/calculator/calculator.php
   trunk/kalyptus/kalyptus
   trunk/php_qt/CMakeLists.txt
   trunk/smoke/CMakeLists.txt
Log:
* websmoke implemented



Modified: trunk/examples/calculator/calculator.php
===================================================================
--- trunk/examples/calculator/calculator.php	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/examples/calculator/calculator.php	2007-06-08 13:50:59 UTC (rev 345)
@@ -149,7 +149,7 @@
 
         }
 
-        function eventFilter($target, $event){
+/*        function eventFilter($target, $event){
             if ($target == $display) {
                 if ($event->type() == QEvent::MouseButtonPress
                     || $event->type() == QEvent::MouseButtonDblClick
@@ -169,9 +169,9 @@
                     }
                     return true;
                 }
-            }//check_qobject($target);
+            }
             return parent::eventFilter($target, $event);
-        }
+        }*/
 
         function digitClicked()
         {

Modified: trunk/kalyptus/kalyptus
===================================================================
--- trunk/kalyptus/kalyptus	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/kalyptus/kalyptus	2007-06-08 13:50:59 UTC (rev 345)
@@ -109,7 +109,7 @@
 # Supported formats
 %formats = ( "java" => "kalyptusCxxToJava", "jni" => "kalyptusCxxToJNI", 
 	"dcopidl" => "kalyptusCxxToDcopIDL",
-	"smoke" => "kalyptusCxxToSmoke", "csharp" => "kalyptusCxxToCSharp", "kimono" => "kalyptusCxxToKimono",
+	"smoke" => "kalyptusCxxToSmoke", "websmoke" => "kalyptusCxxToWebSmoke","csharp" => "kalyptusCxxToCSharp", "kimono" => "kalyptusCxxToKimono",
         "ECMA" => "kalyptusCxxToECMA", "swig" => "kalyptusCxxToSwig",
 		"KDOMECMA" => "kalyptusKDOMEcma");
 

Added: trunk/kalyptus/kalyptusCxxToWebSmoke.pm
===================================================================
--- trunk/kalyptus/kalyptusCxxToWebSmoke.pm	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/kalyptus/kalyptusCxxToWebSmoke.pm	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,2895 @@
+#***************************************************************************
+#            kalyptusCxxToSmoke.pm -  Generates x_*.cpp files for smoke
+#                             -------------------
+#    begin                : Fri Jan 25 12:00:00 2000
+#    copyright            : (C) 2002 Lost Highway Ltd. All Rights Reserved.
+#    email                : david at mandrakesoft.com
+#    author               : David Faure.
+#***************************************************************************/
+
+#/***************************************************************************
+# *                                                                         *
+# *   This program is free software; you can redistribute it and/or modify  *
+# *   it under the terms of the GNU General Public License as published by  *
+# *   the Free Software Foundation; either version 2 of the License, or     *
+# *   (at your option) any later version.                                   *
+# *                                                                         *
+#***************************************************************************/
+
+package kalyptusCxxToWebSmoke;
+
+use File::Path;
+use File::Basename;
+use constant numSourceFiles => 20; # Total number of generated source files.
+                                   # All classes will be distributed across those.
+
+use Carp;
+use Ast;
+use kdocAstUtil;
+use kdocUtil;
+use Iter;
+use kalyptusDataDict;
+
+use strict;
+no strict "subs";
+
+use vars qw/
+	$libname $rootnode $outputdir $opt $debug
+	$methodNumber $headerSubdirectories
+	%builtins %typeunion %allMethods %allTypes %enumValueToType %typedeflist %mungedTypeMap
+	%skippedClasses /;
+
+BEGIN
+{
+
+# Types supported by the StackItem union
+# Key: C++ type  Value: Union field of that type
+%typeunion = (
+    'void*' => 's_voidp',
+    'bool' => 's_bool',
+    'char' => 's_char',
+    'uchar' => 's_uchar',
+    'short' => 's_short',
+    'ushort' => 's_ushort',
+    'int' => 's_int',
+    'uint' => 's_uint',
+    'long' => 's_long',
+    'ulong' => 's_ulong',
+    'float' => 's_float',
+    'double' => 's_double',
+    'enum' => 's_enum',
+    'class' => 's_class'
+);
+
+# Mapping for iterproto, when making up the munged method names
+%mungedTypeMap = (
+     'QString' => '$',
+     'QString*' => '$',
+     'QString&' => '$',
+     'QCString' => '$',
+     'QCString*' => '$',
+     'QCString&' => '$',
+     'char*' => '$',
+     'QCOORD*' => '?',
+     'QRgb*' => '?',
+     'Q_UINT64' => '$',
+     'Q_INT64' => '$',
+     'Q_LLONG' => '$',
+     'quint64' => '$',
+     'qint64' => '$',
+     'long long' => '$',
+     'qlonglong' => '$',
+     'qulonglong' => '$',
+     'WId' => '$',
+     'Q_PID' => '$',
+);
+
+# Yes some of this is in kalyptusDataDict's ctypemap
+# but that one would need to be separated (builtins vs normal classes)
+%typedeflist =
+(
+   'signed char' => 'char',
+   'unsigned char' => 'uchar',
+   'signed short' => 'short',
+   'unsigned short' => 'ushort',
+   'signed' => 'int',
+   'signed int' => 'int',
+   'unsigned' => 'uint',
+   'unsigned int' => 'uint',
+   'signed long' => 'long',
+   'unsigned long' => 'ulong',
+
+# Anything that is not known is mapped to void*, so no need for those here anymore
+#   'QWSEvent*'  =>  'void*',
+#   'QDiskFont*'  =>  'void*',
+#   'XEvent*'  =>  'void*',
+#   'QStyleHintReturn*'  =>  'void*',
+#   'FILE*'  =>  'void*',
+#   'QUnknownInterface*'  =>  'void*',
+#   'GDHandle'  =>  'void*',
+#   '_NPStream*'  =>  'void*',
+#   'QTextFormat*'  =>  'void*',
+#   'QTextDocument*'  =>  'void*',
+#   'QTextCursor*'  =>  'void*',
+#   'QTextParag**'  =>  'void*',
+#   'QTextParag*'  =>  'void*',
+#   'QRemoteInterface*'  =>  'void*',
+#   'QSqlRecordPrivate*'  =>  'void*',
+#   'QTSMFI'  =>  'void*', # QTextStream's QTSManip
+#   'const GUID&'  =>  'void*',
+#   'QWidgetMapper*'  =>  'void*',
+   'MSG*'  =>  'void*',
+#   'const QSqlFieldInfoList&'  =>  'void*', # QSqlRecordInfo - TODO (templates)
+
+   'QPtrCollection::Item'  =>  'void*', # to avoid a warning
+
+   'void(* )()'  =>  'void*',
+   'void (*)(void* )'  =>  'void*',
+   'mode_t'  =>  'long',
+   'QProcess::PID'  =>  'long',
+   'size_type'  =>  'int', # QSqlRecordInfo
+   'Qt::ComparisonFlags'  =>  'uint',
+   'Qt::ToolBarDock'  =>  'int', # compat thing, Qt shouldn't use it
+   'QIODevice::Offset'  =>  'ulong',
+   'WState'  =>  'int',
+   'QRgb'  =>  'uint',
+   'ksocklen_t' => 'uint',
+   'QCOORD'  =>  'int',
+   'QTSMFI'  =>  'int',
+   'Qt::WState'  =>  'int',
+   'Qt::WFlags'  =>  'int',
+   'Qt::HANDLE' => 'uint',
+   'QEventLoop::ProcessEventsFlags' => 'uint',
+   'QStyle::SCFlags' => 'int',
+   'QStyle::SFlags' => 'int',
+   'Q_INT16' => 'short',
+   'qint16' => 'short',
+   'Q_INT32' => 'int',
+   'qint32' => 'int',
+   'qint32&' => 'int&',
+   'Q_INT8' => 'char',
+   'qint8' => 'char',
+   'Q_LONG' => 'long',
+   'Q_UINT16' => 'ushort',
+   'quint16' => 'ushort',
+   'Q_UINT32' => 'uint',
+   'quint32' => 'uint',
+   'Q_UINT8' => 'uchar',
+   'quint8' => 'uchar',
+   'Q_ULONG' => 'long',
+   'qreal' => 'double',
+   'pid_t' => 'int',
+   'size_t' => 'int',
+   'pid_t' => 'int',
+   'time_t' => 'int',
+   'short int' => 'short',
+   'signed long int' => 'long',
+   'unsigned long int' => 'ulong',
+   'unsigned short int' => 'ushort',
+   'Qt::Alignment' => 'int',
+   'Qt::Orientations' => 'int',
+   'Qt::DockWidgetAreas' => 'int',
+   'Qt::DropActions' => 'int',
+   'Qt::ImageConversionFlags' => 'int',
+   'Qt::ItemFlags' => 'int',
+   'Qt::KeyboardModifiers' => 'int',
+   'Qt::MatchFlags' => 'int',
+   'Qt::MouseButtons' => 'int',
+   'Qt::ToolBarAreas' => 'int',
+   'Qt::WindowFlags' => 'int',
+   'Qt::WindowStates' => 'int',
+   'AutoFormatting' => 'int',
+   'DirtyFlags' => 'int',
+   'EditTriggers' => 'int',
+   'FindFlags' => 'int',
+   'Flags' => 'int',
+   'FormattingOptions' => 'int',
+   'GLenum' => 'int',
+   'GLint' => 'int',
+   'GLuint' => 'uint',
+   'LoadOperator' => 'int',
+   'NumberFlags' => 'int',
+   'OpenMode' => 'int',
+   'Options' => 'int',
+   'PaintEngineFeatures' => 'int',
+   'Permissions' => 'int',
+   'PrintDialogOptions' => 'int',
+   'ProcessEventsFlags' => 'int',
+   'QDir::Filters' => 'int',
+   'QDir::SortFlags' => 'int',
+   'QFile::Permissions' => 'int',
+   'QGL::FormatOptions' => 'int',
+   'QIODevice::OpenMode' => 'int',
+   'QImageReader::ImageReaderError' => 'int',
+   'QItemSelectionModel::SelectionFlags' => 'int',
+   'QPaintEngine::DirtyFlags' => 'int',
+   'QPainter::RenderHints' => 'int',
+   'QSql::ParamType' => 'int',
+   'QTextDocument::FindFlags' => 'int',
+   'Qt::DropActions' => 'int',
+   'Qt::ImageConversionFlags' => 'int',
+   'Qt::ItemFlags' => 'int',
+   'Qt::KeyboardModifiers' => 'int',
+   'Qt::MatchFlags' => 'int',
+   'Qt::MouseButtons' => 'int',
+   'Qt::ToolBarAreas' => 'int',
+   'Qt::WindowFlags' => 'int',
+   'Qt::WindowStates' => 'int',
+   'RenderFlags' => 'int',
+   'RenderHints' => 'int',
+   'SortFlags' => 'int',
+   'StepEnabled' => 'int',
+   'Sections' => 'int',
+   'Filters' => 'int',
+   'SortFlags' => 'int',
+   'QDir::Filters' => 'int',
+   'QDir::SortFlags' => 'int',
+   'QStyle::State' => 'int',
+   'QValidator::State' => 'int',
+   'QAbstractSpinBox::StepEnabled' => 'int',
+   'QDockWidget::DockWidgetFeatures' => 'int',
+   'QStyle::SubControls' => 'int',
+   'RegisterOptions' => 'int',
+   'BindMode' => 'int',
+   'ButtonFeatures' => 'int',
+   'CacheMode' => 'int',
+   'CheckType' => 'int',
+   'CornerWidgets' => 'int',
+   'DockWidgetFeatures' => 'int',
+   'FileFlags' => 'int',
+   'FontFilters' => 'int',
+   'FrameFeatures' => 'int',
+   'GraphicsItemFlags' => 'int',
+   'InterfaceFlags' => 'int',
+   'IteratorFlags' => 'int',
+   'MenuItemType' => 'int',
+   'NumberOptions' => 'int',
+   'PageBreakFlags' => 'int',
+   'Qt::TextInteractionFlags' => 'int',
+   'Relation' => 'int',
+   'SectionPosition' => 'int',
+   'SelectedPosition' => 'int',
+   'StandardButtons' => 'int',
+   'State' => 'int',
+   'TabPosition' => 'int',
+   'ToolBarFeatures' => 'int',
+   'ToolBarPosition' => 'int',
+   'ToolButtonFeatures' => 'int',
+   'ViewItemFeatures' => 'int',
+);
+
+$headerSubdirectories = "kio/|phonon/ui/|kmediaplayer/|dnssd/|solid/|solid/ifaces/|phonon/|sonnet/|kdevelop/|kinterfacedesigner/|kontact/|kate/|kparts/|dom/|kabc/|ksettings/|kjs/|ktexteditor/|kdeprint/|kdesu/|knewstuff/|dbus-1.0/dbus/"
+
+}
+
+sub writeDoc
+{
+	( $libname, $rootnode, $outputdir, $opt ) = @_;
+
+	print STDERR "Starting writeDoc for $libname...\n";
+
+	$debug = $main::debuggen;
+
+	mkpath( $outputdir ) unless -f $outputdir;
+
+	# Define QPtrCollection::Item, for resolveType
+	unless ( kdocAstUtil::findRef( $rootnode, "QPtrCollection::Item" ) || $main::qt4 ) {
+		my $cNode = kdocAstUtil::findRef( $rootnode, "QPtrCollection" );
+		warn "QPtrCollection not found" if (!$cNode);
+		my $node = Ast::New( 'Item' );
+		$node->AddProp( "NodeType", "Forward" );
+		$node->AddProp( "Source", $cNode->{Source} ) if ($cNode);
+		kdocAstUtil::attachChild( $cNode, $node ) if ($cNode);
+		$node->AddProp( "Access", "public" );
+	}
+	
+	print STDERR "Preparsing...\n";
+
+	# Preparse everything, to prepare some additional data in the classes and methods
+	Iter::LocalCompounds( $rootnode, sub { preParseClass( shift ); } );
+
+	# Have a look at each class again, to propagate CanBeCopied
+	Iter::LocalCompounds( $rootnode, sub { propagateCanBeCopied( shift ); } );
+
+	print STDERR "Writing smokedata.cpp...\n";
+
+	# Write out smokedata.cpp
+	writeSmokeDataFile($rootnode);
+
+	print STDERR "Writing x_*.cpp...\n";
+
+	# Generate x_*cpp file for each class
+
+        my $numclasses;
+        Iter::LocalCompounds( $rootnode, sub { $numclasses++ } );
+        my $classperfile = int($numclasses/numSourceFiles);
+        print STDERR "Total number of classes: ". $numclasses ."\n" if $debug;
+        my $nodelist = [];
+        my $currentfile = 1;
+        my $currentclass = 1;
+        Iter::LocalCompounds( $rootnode, sub { 
+                   push @$nodelist, shift;
+                   if(@$nodelist == $classperfile and $currentfile != numSourceFiles)
+                   {
+                       print STDERR "Calling writeClassDoc for ". (scalar @$nodelist) . " classes\n" if $debug;
+                       writeClassDoc( $nodelist );
+                       $currentfile++;
+                       $nodelist = []     
+                   }
+                   if(@$nodelist and $currentclass == $numclasses)
+                   {    
+                       print STDERR "Calling writeClassDoc for remaining ". (scalar @$nodelist) . " classes\n" if $debug;
+                       writeClassDoc( $nodelist )
+                   }
+                   $currentclass++
+        });
+
+	print STDERR "Done.\n";
+}
+
+=head2 preParseClass
+	Called for each class
+=cut
+sub preParseClass
+{
+	my( $classNode ) = @_;
+	my $className = join( "::", kdocAstUtil::heritage($classNode) );
+
+	if( $#{$classNode->{Kids}} < 0 ||
+	    $classNode->{Access} eq "private" ||
+	    $classNode->{Access} eq "protected" || # e.g. QPixmap::QPixmapData
+	    exists $classNode->{Tmpl} ||
+	    # Don't generate standard bindings for QString, this class is handled as a native type
+	    $className eq 'QString' ||
+	    $className eq 'QStringData' ||
+	    $className eq 'QLatin1String' ||
+	    $className eq 'QTLWExtra' ||
+	    $className eq 'QWExtra' ||
+	    $className eq 'QBig5Codec' ||
+	    $className eq 'QBig5hkscsCodec' ||
+	    $className eq 'QPtrCollection' ||
+	    $className eq 'QGCache' ||
+	    $className eq 'QConstString' ||
+	    $className eq 'QCString' ||
+	    # Don't map classes which are really arrays
+	    $className eq 'QStringList' ||
+            $className eq 'QCanvasItemList' ||
+            $className eq 'QWidgetList' ||
+            $className eq 'QObjectList' ||
+	    $className eq 'QStrList' ||
+	    $className eq 'KCmdLineOptions' ||
+	    # Those are template related
+            $className eq 'QTSManip' || # cause compiler errors with several gcc versions
+	    $className eq 'QGDict' ||
+	    $className eq 'QGList' ||
+	    $className eq 'QGArray' ||
+	    $className eq 'QGVector' ||
+	    $className eq 'QStrIList' ||
+	    $className eq 'QStrIVec' ||
+	    $className eq 'QBitArray' ||
+	    $className eq 'QMapData' ||
+	    $className eq 'QMetaEnum::Item' ||
+	    $className eq 'QWidgetContainerPlugin' ||
+	    $className eq 'QGArray::array_data' ||
+	    ($className eq 'QMenuItem' and $main::qt_embedded) ||
+	    ($className eq 'QSignal' and $main::qt_embedded) ||
+	    ($className eq 'QWSEvent' and $main::qt_embedded) ||
+	    ($className eq 'QMetaObjectInit' and $main::qt_embedded) ||
+	    ($className eq 'QKoi8Codec' and $main::qt_embedded) ||
+	    $className eq 'KAccelGen' ||
+	    ($className eq 'QAbstractUndoItem' and $main::qt4) ||
+	    ($className eq 'QDebug' and $main::qt4) ||
+	    ($className eq 'QNoDebug' and $main::qt4) ||
+	    ($className eq 'QObjectData' and $main::qt4) ||
+	    ($className eq 'QSysInfo' and $main::qt4) ||
+	    ($className eq 'QPNGImageWriter' and $main::qt4) ||
+	    ($className eq 'QPNGImagePacker' and $main::qt4) ||
+	    ($className eq 'QSqlRelationalDelegate' and $main::qt4) ||
+	    ($className eq 'QTextCodec::ConverterState' and $main::qt4) ||
+	    ($className eq 'QTextLayout::Selection' and $main::qt4) ||
+	    ($className eq 'QTextStreamManipulator' and $main::qt4) ||
+	    $className eq 'DCOPArg' ||
+	    $className eq 'DCOPReply' ||
+	    $className eq 'KBookmarkMenu::DynMenuInfo' ||
+	    $className eq 'KDateTime::Spec' ||
+	    $className eq 'KEncodingFileDialog::Result' ||
+	    $className eq 'KDE' ||
+	    $className eq 'KDEDesktopMimeType::Service' ||
+	    $className eq 'KDialogButtonBox' ||
+	    $className eq 'KEntry' ||
+	    $className eq 'KEntryKey' ||
+	    $className eq 'KGlobalSettings::KMouseSettings' ||
+	    $className eq 'KMimeType::Format' ||
+	    $className eq 'KNotifyClient::Instance' ||
+	    $className eq 'KParts::ComponentFactory' ||
+	    $className eq 'KParts::Plugin::PluginInfo' ||
+	    $className eq 'KParts::MainWindow' ||
+	    $className eq 'KProtocolInfo::ExtraField' ||
+	    $className eq 'KXMLGUIClient::StateChange' ||
+	    $className eq 'KIconTheme' ||
+	    $className eq 'KEditListBox::CustomEditor' ||
+		$className eq 'KIO::KBookmarkMenuNSImporter' ||
+		$className eq 'KIO::NetRC' ||
+	    $className eq 'KExtendedSocket' ||
+	    $className eq 'KSettings::PluginPage' ||
+	    $className eq 'KSocket' ||
+	    $className eq 'KPerDomainSettings' ||
+	    $className eq 'KApplicationPropsPlugin' ||
+	    $className eq 'KOpenWithHandler' ||
+	    $className eq 'KFileOpenWithHandler' ||
+	    $className eq 'KBindingPropsPlugin' ||
+	    $className eq 'KPropsDlgPlugin' ||
+	    $className eq 'KFileSharePropsPlugin' ||
+	    $className eq 'KBookmarkMenuNSImporter' ||
+	    $className eq 'KDevicePropsPlugin' ||
+	    $className eq 'KDEDModule' ||
+	    $className eq 'KFileMetaInfoProvider' ||
+	    $className eq 'KFileMimeTypeInfo' ||
+	    $className eq 'KMimeTypeChooserDialog' ||
+	    $className eq 'KExecPropsPlugin' ||
+	    $className eq 'KFilePermissionsPropsPlugin' ||
+	    $className eq 'KImageFilePreview' ||
+	    $className eq 'KBookmarkManager' ||
+	    $className eq 'KBookmarkNotifier' ||
+	    $className eq 'KOCRDialogFactory' ||
+	    $className eq 'KExtendedBookmarkOwner' ||
+	    $className eq 'KSharedPixmap' ||
+	    $className eq 'KLibrary' ||
+	    $className eq 'KScanDialogFactory' ||
+	    $className eq 'KTimeZone::Transition' ||
+	    $className eq 'KTipDatabase' ||
+	    $className eq 'KBufferedIO' ||
+	    $className eq 'KDictSpellingHighlighter' ||
+		$className eq 'KPropertiesDialog' ||
+	    $className eq 'ProgressItem' ||
+	    $className eq 'KIO::ChmodInfo' ||
+	    $className eq 'KUrl::List' ||
+	    $className eq 'khtml::DrawContentsEvent' || # the khtml:: classes build, but don't link
+	    $className eq 'khtml::MouseDoubleClickEvent' ||
+	    $className eq 'khtml::MouseMoveEvent' ||
+	    $className eq 'khtml::MousePressEvent' ||
+	    $className eq 'khtml::MouseReleaseEvent' ||
+	    $className eq 'khtml::MouseEvent' ||
+	    $className eq 'khtml' ||
+	    $className eq 'KURL::List' ||
+	    $className eq 'KWin::Info' ||
+	    $className eq 'TerminalInterface' ||
+	    $className eq 'QAccessibleBridgePlugin' || # Qt4
+	    $className eq 'QForeachContainerBase' || # Qt4
+	    $className eq 'QInputMethodEvent::Attribute' || # Qt4
+	    $className eq 'QAbstractUndoItem' || # Qt4
+	    $className eq 'QAbstractTextDocumentLayout::PaintContext' || # Qt4
+	    $className eq 'QAbstractTextDocumentLayout::Selection' || # Qt4
+	    $className eq 'QBrushData' || # Qt4
+	    $className eq 'QDBusObjectPath' || # Qt4
+	    $className eq 'QDBusSignature' || # Qt4
+	    $className eq 'QDBusVariant' || # Qt4
+	    $className eq 'QIPv6Address' || # Qt4
+	    $className eq 'QImageTextKeyLang' || # Qt4
+	    $className eq 'QMap' || # Qt4
+	    $className eq 'QMap::const_iterator' || # Qt4
+	    $className eq 'QMap::iterator' || # Qt4
+	    $className eq 'QMapData' || # Qt4
+	    $className eq 'QMapData::Node' || # Qt4
+	    $className eq 'QObjectData' || # Qt4
+	    $className eq 'QProxyModel' || # Obsolete Qt4
+	    $className eq 'QSharedData' || # Qt4
+	    $className eq 'QPainterPath::Element' || # Qt4
+	    $className eq 'QThreadStorageData' || # Qt4
+	    $className eq 'QVFbHeader' || # Qt4
+	    $className eq 'QStyleOptionQ3DockWindow' || # Qt4
+	    $className eq 'QStyleOptionQ3ListView' || # Qt4
+	    $className eq 'QStyleOptionQ3ListViewItem' || # Qt4
+	    $className eq 'QStyleOptionQ3ListView' || # Qt4
+	    $className eq 'QUpdateLaterEvent' || # Qt4
+	    $className eq 'QVFbKeyData' || # Qt4
+	    $className eq 'QVariant::Handler' || # Qt4
+	    $className eq 'QVariant::PrivateShared' || # Qt4
+	    $className eq 'QVectorData' || # Qt4
+	    $className eq 'QWidgetData' || # Qt4
+	    $className eq 'QThread' || # Qt4
+		$className eq 'QThreadStorage' || # Qt4
+		$className eq 'QMutex' || # Qt4
+		$className eq 'QMutexLocker' || # Qt4
+		$className eq 'QSemaphore' || # Qt4
+		$className eq 'QWaitCondition' || # Qt4
+		$className eq 'QReadWriteLock' || # Qt4
+		$className eq 'QReadLocker' || # Qt4
+		$className eq 'QX11Info' || # Qt4
+		$className eq 'QWriteLocker' || 
+	    $className =~ /.*Private$/ || # Ignore any classes which aren't for public consumption
+	    $className =~ /.*Impl$/ ||
+	    $className =~ /.*Internal.*/ ||
+	    $classNode->{Deprecated} ||
+	    $classNode->{NodeType} eq 'union' || # Skip unions for now, e.g. QPDevCmdParam
+	    $className eq 'KImportedBookmarkMenu' || # KDE4
+	    $className eq 'KUndoRedoAction' || # KDE4
+	    $className eq 'KTzfileTimeZoneData' || # KDE4
+	    $className eq 'KUndoRedoAction' # KDE4
+	  ) {
+	    print STDERR "Skipping $className\n" if ($debug);
+	    print STDERR "Skipping union $className\n" if ( $classNode->{NodeType} eq 'union');
+	    $skippedClasses{$className} = 1;
+	    delete $classNode->{Compound}; # Cheat, to get it excluded from Iter::LocalCompounds
+	    return;
+	}
+	
+	my $signalCount = 0;
+	my $eventHandlerCount = 0;
+	my $defaultConstructor = 'none'; #  none, public, protected or private. 'none' will become 'public'.
+	my $constructorCount = 0; # total count of _all_ ctors
+	# If there are ctors, we need at least one public/protected one to instanciate the class
+	my $hasPublicProtectedConstructor = 0;
+	# We need a public dtor to destroy the object --- ### aren't protected dtors ok too ??
+	my $hasPublicDestructor = 1; # by default all classes have a public dtor!
+	#my $hasVirtualDestructor = 0;
+	my $hasDestructor = 0;
+	my $hasPrivatePureVirtual = 0;
+	my $hasCopyConstructor = 0;
+	my $hasPrivateCopyConstructor = 0;
+	# Note: no need for hasPureVirtuals. $classNode{Pure} has that.
+	
+	# Hack to fix up KLed constructors in KDE 3.1
+	my $kledAmbiguousConstructor = undef;
+
+        my $doPrivate = $main::doPrivate;
+	$main::doPrivate = 1;
+	# Look at each class member (looking for methods and enums in particular)
+	Iter::MembersByType ( $classNode, undef,
+		sub {
+
+	my( $classNode, $m ) = @_;
+	my $name = $m->{astNodeName};
+
+	if( $m->{NodeType} eq "method" ) {
+	    if ( $m->{ReturnType} eq 'typedef' # QFile's EncoderFn/DecoderFn callback, very badly parsed
+	       ) {
+		$m->{NodeType} = 'deleted';
+		next;
+	    }
+
+	    print STDERR "preParseClass: looking at $className\::$name  $m->{Params}\n" if ($debug);
+	    
+		if ( $name eq $classNode->{astNodeName} ) {
+		if ( $m->{ReturnType} =~ /~/  ) {
+		    # A destructor
+		    $hasPublicDestructor = 0 if $m->{Access} ne 'public';
+		    #$hasVirtualDestructor = 1 if ( $m->{Flags} =~ "v" && $m->{Access} ne 'private' );
+		    $hasDestructor = 1;
+		} else {
+		    # A constructor
+		    $constructorCount++;
+		    $defaultConstructor = $m->{Access} if ( $m->{Params} eq '' );
+		    $hasPublicProtectedConstructor = 1 if ( $m->{Access} ne 'private' );
+
+		    # Copy constructor?
+		    if ( $#{$m->{ParamList}} == 0 ) {
+			my $theArgType = @{$m->{ParamList}}[0]->{ArgType};
+                        (my $classNameWithoutNS = $className) =~ s/^.*:://;
+			if ($theArgType =~ /$classNameWithoutNS\s*\&/) {
+			    $hasCopyConstructor = 1;
+				$m->{Flags} .= "x";
+			    $hasPrivateCopyConstructor = 1 if ( $m->{Access} eq 'private' );
+			}
+		    }
+		    # Hack the return type for constructors, since constructors return an object pointer
+		    $m->{ReturnType} = $className."*";
+		}
+	    }
+
+	    if ( $name =~ /~$classNode->{astNodeName}/ && $m->{Access} ne "private" ) { # not used
+		$hasPublicDestructor = 0 if $m->{Access} ne 'public';
+		#$hasVirtualDestructor = 1 if ( $m->{Flags} =~ "v" );
+		$hasDestructor = 1;
+	    }
+
+	    if ( $m->{Flags} =~ "p" && $m->{Access} =~ /private/ ) {
+                $hasPrivatePureVirtual = 1; # ouch, can't inherit from that one
+	    }
+
+	    # All we want from private methods is to check for virtuals, nothing else
+	    next if ( $m->{Access} =~ /private/ );
+		# Don't generate code for deprecated methods, 
+		# or where the code won't compile/link for obscure reasons. Or even obvious reasons..
+		if ( ($classNode->{astNodeName} eq 'KCharSelectTable' and $name eq 'paintCell')
+			# KDE4
+			|| ($name eq 'operator<<' and $m->{ParamList}[0]->{ArgType} =~ /QDataStream/ and $m->{ParamList}[1]->{ArgType} =~ /KDateTime::Spec/ )
+			|| ($name eq 'operator>>' and $m->{ParamList}[0]->{ArgType} =~ /QDataStream/ and $m->{ParamList}[1]->{ArgType} =~ /KDateTime::Spec/ )
+                        || ($name eq 'operator<<' and $m->{ParamList}[0]->{ArgType} =~ /QDataStream/ and $m->{ParamList}[1]->{ArgType} =~ /const KDateTime/ )
+                        || ($name eq 'operator>>' and $m->{ParamList}[0]->{ArgType} =~ /QDataStream/ and $m->{ParamList}[1]->{ArgType} =~ /KDateTime/ )
+			|| ($classNode->{astNodeName} eq 'TextEvent' and $name eq 'data')
+			|| ($classNode->{astNodeName} eq 'KApplication' and $name eq 'startKdeinit')
+			|| ($classNode->{astNodeName} eq 'Slave' and $name eq 'Slave')
+			|| ($classNode->{astNodeName} eq 'KIcon' and $name eq 'setOverlays')
+			|| ($classNode->{astNodeName} eq 'KResolver' and $name eq 'setError')
+			|| ($classNode->{astNodeName} eq 'Entry' and $name eq 'setCompatibility')
+			|| ($classNode->{astNodeName} eq 'KTimeZone' and $name eq 'source')
+			|| ($classNode->{astNodeName} eq 'KTzfileTimeZoneSource' and $name eq 'location')
+			|| ($classNode->{astNodeName} eq 'Wallet' and $name eq 'Wallet')
+			# end KDE4
+			|| ($classNode->{astNodeName} eq 'KAnimWidget' and $name eq 'KAnimWidget' and @{$m->{ParamList}} == 2)
+			|| ($classNode->{astNodeName} eq 'KCModuleLoader' and $name eq 'errorModule')
+			|| ($classNode->{astNodeName} eq 'KDCOPActionProxy' and $name eq 'actions')
+			|| ($classNode->{astNodeName} eq 'KEditToolbarWidget' and $name eq 'insertActive')
+			|| ($classNode->{astNodeName} eq 'KEditToolbarWidget' and $name eq 'removeActive')
+			|| ($classNode->{astNodeName} eq 'KEditToolbarWidget' and $name eq 'moveActive')
+			|| ($classNode->{astNodeName} eq 'KFileDialog' and $name eq 'addDirEntry')
+			|| ($classNode->{astNodeName} eq 'KFileDialog' and $name eq 'getDirEntry')
+			|| ($classNode->{astNodeName} eq 'KFileItem' and $name eq 'extraData')
+			|| ($classNode->{astNodeName} eq 'KFileView' and $name eq 'selectionMode')
+			|| ($classNode->{astNodeName} eq 'KFind' and $name eq 'KFind' and @{$m->{ParamList}} == 4)
+			|| ($classNode->{astNodeName} eq 'KGlobalAccel' and $name eq 'setEnabled')
+			|| ($classNode->{astNodeName} eq 'KCharsets' and $name eq 'encodingsForLanguage')
+			|| ($classNode->{astNodeName} eq 'KInputDialog' and $name eq 'getInteger')
+			|| ($classNode->{astNodeName} eq 'SlaveBase' and $name eq 'checkCachedAuthentication')
+			|| ($classNode->{astNodeName} eq 'SlaveBase' and $name eq 'cacheAuthentication')
+			|| ($classNode->{astNodeName} eq 'KInputDialog' and $name eq 'getDouble')
+			|| ($classNode->{astNodeName} eq 'KToolBar' and $name eq 'enable')
+			|| ($classNode->{astNodeName} eq 'KToolBar' and $name eq 'changeEvent')
+			|| ($classNode->{astNodeName} eq 'KAccel' and $name eq 'insert' and @{$m->{ParamList}} == 2)
+			|| ($classNode->{astNodeName} eq 'KAccel' and $name eq 'autoupdate')
+			|| ($classNode->{astNodeName} eq 'KAccel' and $name eq 'getAutoUpdate')
+			|| ($classNode->{astNodeName} eq 'KAction' and $name eq 'activated')
+			|| ($classNode->{astNodeName} eq 'KAction' and $name eq 'actionOfType')
+			|| ($classNode->{astNodeName} eq 'KAction' and $name eq 'actionsOfType')
+			|| ($classNode->{astNodeName} eq 'KActionCollection' and $name eq 'add')
+			|| ($classNode->{astNodeName} eq 'KStdAccel' and $name eq 'insert')
+			|| ($classNode->{astNodeName} eq 'KBookmarkMenu' and $name eq 'invalid')
+			|| ($classNode->{astNodeName} eq 'KCharsets' and $name eq 'languages')
+			|| ($classNode->{astNodeName} eq 'KCombiView' and $name eq 'setDropOptions')
+			|| ($classNode->{astNodeName} eq 'KDialogButtonBox' and $name eq 'using')
+			|| ($classNode->{astNodeName} eq 'KFileMetaInfoItem' and $name eq 'unit')
+			|| ($classNode->{astNodeName} eq 'KInstance' and $name eq 'charsets')
+			|| ($classNode->{astNodeName} eq 'KInstance' and $name eq 'KInstance' and $m->{Access} =~ /protected/)
+			|| ($classNode->{astNodeName} eq 'KKey' and $name eq 'isValidQt')
+			|| ($classNode->{astNodeName} eq 'KKey' and $name eq 'isValidNative')
+			|| ($classNode->{astNodeName} eq 'KKeySequence' and $name eq 'init')
+			|| ($classNode->{astNodeName} eq 'KKeySequence' and $name eq 'setTriggerOnRelease')
+			|| ($classNode->{astNodeName} eq 'KEMailSettings' and $name eq 'getExtendedSetting')
+			|| ($classNode->{astNodeName} eq 'KEMailSettings' and $name eq 'setExtendedSetting')
+			|| ($classNode->{astNodeName} eq 'KProtocolManager' and $name eq 'defaultConnectTimeout')
+			|| ($classNode->{astNodeName} eq 'KMD4' and $name eq 'transform')
+			|| ($classNode->{astNodeName} eq 'KMD5' and $name eq 'transform')
+			|| ($classNode->{astNodeName} eq 'KSSLCertificate' and $name eq 'operator!=')
+			|| ($classNode->{astNodeName} eq 'KSSLPKCS7' and $name eq 'validate')
+			|| ($classNode->{astNodeName} eq 'KSSLPKCS7' and $name eq 'revalidate')
+			|| ($classNode->{astNodeName} eq 'KSSLSession' and $name eq 'KSSLSession' and @{$m->{ParamList}} == 1)
+			|| ($classNode->{astNodeName} eq 'KSimpleFileFilter' and $name eq 'nameFilters')
+			|| ($classNode->{astNodeName} eq 'KTabWidget' and $name eq 'isTabReorderingEnabled')
+			|| ($classNode->{astNodeName} eq 'KTabWidget' and $name eq 'hoverCloseButton')
+			|| ($classNode->{astNodeName} eq 'KTabWidget' and $name eq 'hoverCloseButtonDelayed')
+			|| ($classNode->{astNodeName} eq 'KTar' and $name eq 'writeFile_impl')
+			|| ($classNode->{astNodeName} eq 'KIO' and $name eq 'buildHTMLErrorString')
+			|| ($classNode->{astNodeName} eq 'KIO' and $name eq 'pasteClipboard')
+			|| ($classNode->{astNodeName} eq 'KIO' and $name eq 'pasteData')
+			|| ($classNode->{astNodeName} eq 'KIO' and $name eq 'pasteDataAsync')
+			|| ($classNode->{astNodeName} eq 'KIO' and $name eq 'isClipboardEmpty')
+			|| ($classNode->{astNodeName} eq 'KIO::NetRC' and $name eq 'lookup')
+			|| ($classNode->{astNodeName} eq 'DCOPRef' and $name eq 'callExt')
+			|| ($classNode->{astNodeName} eq 'DCOPRef' and $name eq 'call')
+			|| ($classNode->{astNodeName} eq 'DCOPRef' and $name eq 'send')
+			|| ($classNode->{astNodeName} eq 'DOM' and $name eq 'operator<<') # Avoid kdbgstream debugging method
+			|| ($name eq 'initgroups')
+			|| ($name eq 'qInitJpegIO' and $main::qt4)
+			|| ($name eq 'qInitPngIO' and $main::qt4)
+			|| ($name eq 'qt_metacast' and $main::qt4)
+			|| ($name eq 'virtual_hook')
+			|| ($name eq 'handle')
+			|| ($name eq 'qHash')
+			|| ($classNode->{astNodeName} eq 'QwtThermo' and $name eq 'setFillBrush')
+			|| ($classNode->{astNodeName} eq 'QwtThermo' and $name eq 'fillBrush')
+			|| ($classNode->{astNodeName} eq 'QwtThermo' and $name eq 'setFillColor')
+			|| ($classNode->{astNodeName} eq 'QwtThermo' and $name eq 'fillColor')
+			|| ($classNode->{astNodeName} eq 'QwtThermo' and $name eq 'setAlarmBrush')
+			|| ($classNode->{astNodeName} eq 'QwtThermo' and $name eq 'alarmBrush')
+			|| ($classNode->{astNodeName} eq 'QwtThermo' and $name eq 'setAlarmColor')
+			|| ($classNode->{astNodeName} eq 'QwtThermo' and $name eq 'alarmColor')
+			|| ($classNode->{astNodeName} eq 'QwtWheel' and $name eq 'getScrollMode')
+			|| ($classNode->{astNodeName} eq 'QwtSpline' and $name eq 'points')
+			|| ($classNode->{astNodeName} eq 'QwtPlot' and $name eq 'drawItems')
+			|| ($classNode->{astNodeName} eq 'QwtPlot' and $name eq 'printCanvas')
+			|| ($classNode->{astNodeName} eq 'QwtPlot' and $name eq 'drawItems')
+			|| ($classNode->{astNodeName} eq 'QwtPlot' and $name eq 'setCanvasBackground')
+			|| ($classNode->{astNodeName} eq 'QwtPlot' and $name eq 'canvasBackground')
+			|| ($classNode->{astNodeName} eq 'QwtPlotLayout' and $name eq 'expandLineBreaks')
+			|| ($classNode->{astNodeName} eq 'QwtPlotLayout' and $name eq 'alignScales')
+			|| ($classNode->{astNodeName} eq 'QwtData' and $name eq 'operator=')
+			|| ($classNode->{astNodeName} eq 'QwtScaleTransformation' and $name eq 'double')
+			|| ($classNode->{astNodeName} eq 'QwtScaleDiv' and $name eq 'QwtScaleDiv' and @{$m->{ParamList}} > 0)
+			# Obsolete
+			|| ($classNode->{astNodeName} eq 'QTextStream' and $name eq 'QTextStream'
+					and @{$m->{ParamList}} == 2 and $m->{ParamList}[0]->{ArgType} eq 'QString&')
+			
+			# Various methods to skip in Qt/E (Qt 2.3.x)
+			|| ($main::qt_embedded
+				&& ( ($classNode->{astNodeName} eq 'QUriDrag' and $name =~ /^decode$|decodeLocalFiles|decodeToUnicodeUris/)
+				|| ($classNode->{astNodeName} eq 'QApplication' and $name =~ /^qwsSetCustomColors|^setArgs$|^winMouseButtonUp|^winFocus|^winMouseButtonUP$|^winVersion$/)
+				|| ($classNode->{astNodeName} eq 'QPrinter' and $name =~ /^setIdle$|^setActive$/)
+				|| ($classNode->{astNodeName} eq 'QDragObject' and $name eq 'dragLink')
+				|| ($classNode->{astNodeName} eq 'QFont' and $name eq 'qwsRenderToDisk')
+				|| ($classNode->{astNodeName} eq 'QFontInfo' and $name eq 'font')
+				|| ($classNode->{astNodeName} eq 'QLineEdit' and $name eq 'getSelection')
+				|| ($classNode->{astNodeName} eq 'QMainWindow' and $name eq 'toolBars')
+				|| ($classNode->{astNodeName} eq 'QMovie' and $name eq 'setDisplayWidget')
+				|| ($classNode->{astNodeName} eq 'QMetaObject' and $name =~ /^new_metaenum_item$|^new_metaaccess$/)
+				|| ($classNode->{astNodeName} eq 'QPainter' and $name eq 'pos')
+				|| ($classNode->{astNodeName} eq 'QPixmap' and $name =~ /^allocCell$|^clut$|^freeCell|^hbm|^isMultiCellPixmap|^multiCellPixmap|^multiCellBitmap|^multiCellHandle|^multiCellOffset|^numCols/)
+				|| ($name eq 'handle')
+				|| ($name eq 'resetInputContext')
+				|| ($name eq 'propagateUpdates')
+				|| ($name eq 'bytesPerLine')
+				|| ($name eq 'scanLine')
+				|| ($name eq 'hPal')
+				|| ($name eq 'copyX11Data')
+				|| ($name eq 'getX11Data')
+				|| ($name eq 'setX11Data')
+				|| ($name eq 'realizePal')
+				|| ($name eq 'qwsDisplay')
+				|| ($name eq 'fixport')
+				|| ($name eq 'hack_strrchr')
+				|| ($name eq 'hack_strchr')
+				|| ($name eq 'hack_strstr') ) )
+						
+			# Assume only Qt classes have tr() and trUtf8() in their Q_OBJECT macro
+			|| ($classNode->{astNodeName} !~ /^Q/ and $name eq 'tr')
+			|| ($classNode->{astNodeName} !~ /^Q/ and $name eq 'trUtf8')
+
+			|| ($main::qt4
+				&& ( ($classNode->{astNodeName} eq 'QWidgetListItem' and $name eq 'operator=')
+				|| ($classNode->{astNodeName} eq 'QColormap' and $name eq 'operator=')
+				|| ($classNode->{astNodeName} eq 'QGraphicsLineItem' and $name eq 'QGraphicsLineItem' and $#{$m->{ParamList}} == 5)
+				|| ($classNode->{astNodeName} eq 'QGraphicsEllipseItem' and $name eq 'QGraphicsEllipseItem' and $#{$m->{ParamList}} == 5)
+				|| ($classNode->{astNodeName} eq 'QListWidget' and $name eq 'setItemPosition')
+				|| ($classNode->{astNodeName} eq 'QFontMetricsF' and $name eq 'operator=')
+				|| ($classNode->{astNodeName} eq 'QFontMetricsF' and $name eq 'QFontMetricsF' 
+					and $#{$m->{ParamList}} == 0 && $m->{ParamList}[0]->{ArgType} eq 'const QFontMetrics&')
+				|| ($classNode->{astNodeName} eq 'QAbstractItemDelegate' and $name eq 'QAbstractItemDelegate' 
+					and $#{$m->{ParamList}} == 0 && $m->{ParamList}[0]->{ArgType} eq 'const QAbstractItemDelegate&')
+				|| ($classNode->{astNodeName} eq 'QHttp' and $name eq 'supportedOperations')
+				|| ($classNode->{astNodeName} eq 'QPrinter' and $name eq 'printRange')
+				|| ($classNode->{astNodeName} eq 'QPrinter' and $name eq 'setPrintRange')
+				|| ($classNode->{astNodeName} eq 'QRectF' and $name eq 'setX')
+				|| ($classNode->{astNodeName} eq 'QRectF' and $name eq 'setY')
+				|| ($classNode->{astNodeName} eq 'QTextObject' and $name eq 'formatType')
+				|| ($classNode->{astNodeName} eq 'QUrl' and $name eq 'QUrl'
+					and $#{$m->{ParamList}} == 0 && $m->{ParamList}[0]->{ArgType} eq 'QUrlPrivate&')
+				|| ($classNode->{astNodeName} eq 'QGlobalSpace' and $name eq 'operator<<' and $m->{ParamList}[0]->{ArgType} =~ /QDebug/)
+				|| ($classNode->{astNodeName} eq 'QGlobalSpace' and $name eq 'qDebug')
+				|| ($classNode->{astNodeName} eq 'QGlobalSpace' and $name eq 'qWarning')
+				|| ($classNode->{astNodeName} eq 'QGlobalSpace' and $name eq 'qCritical')
+				|| ($classNode->{astNodeName} eq 'QGlobalSpace' and $#{$m->{ParamList}} > 0 and $name =~ /operator/ and $m->{ParamList}[1]->{ArgType} =~ /QVariant::Type/)
+				|| ($#{$m->{ParamList}} > 0 and $m->{ParamList}[0]->{ArgType} =~ /Private/)
+				|| ($classNode->{astNodeName} eq 'QScrollArea' and $name eq 'alignment')
+				|| ($classNode->{astNodeName} eq 'QScrollArea' and $name eq 'setAlignment')
+				|| ($classNode->{astNodeName} eq 'QDBusConnection' and $name eq 'findInterface' and 
+					$m->{ReturnType} =~ /</ )
+				|| ($classNode->{astNodeName} eq 'QDBusBusService' and $name eq 'RequestName')
+				|| ($classNode->{astNodeName} eq 'QDBusBusService' and $name eq 'requestName')
+				|| ($classNode->{astNodeName} eq 'QGLFormat' and $name eq 'openGLVersionFlags')
+				|| ($classNode->{astNodeName} eq 'QAbstractUndoItem' and $name eq '~QAbstractUndoItem')
+				|| ($classNode->{astNodeName} eq 'QApplication' and $name eq 'setKeypadNavigationEnabled')
+				|| ($classNode->{astNodeName} eq 'QApplication' and $name eq 'keypadNavigationEnabled')
+				|| ($name eq 'qDBusMetaTypeId')
+				|| ($m->{ReturnType} =~ /template/)
+				|| ($m->{ReturnType} =~ /QT3_SUPPORT/) ) )
+
+			|| $m->{Deprecated} ) {
+		    $m->{NodeType} = 'deleted';
+			next;
+		}
+
+		# QLayout::setGeometry() is marked as pure virtual in the header, but actually has
+		# an implementation, so special case it.
+		if ($main::qt4 and $classNode->{astNodeName} eq 'QLayout' and $name eq 'setGeometry') {
+			$m->{Flags} =~ s/p//;
+		}
+
+		# Hack for fixing up KDE 3.1 KLed where the no arg constructor was ambiguous
+		if ($classNode->{astNodeName} eq 'KLed' and $name eq 'KLed' && $#{$m->{ParamList}} > 0) {
+			if ($m->{ParamList}[0]->{ArgType} =~ /QColor/ && defined $m->{ParamList}[0]->{DefaultValue}) {
+				$m->{ParamList}[0]->{DefaultValue} = undef;
+				if (defined $kledAmbiguousConstructor) {
+					$kledAmbiguousConstructor->{ParamList}[0]->{DefaultValue} = undef;
+					$kledAmbiguousConstructor->{FirstDefaultParam} = 1;
+				}
+			} else {
+				$kledAmbiguousConstructor = $m;
+			}
+		}
+
+		# cut the last arguments in size(), boundingRect(), both methods was ambiguous
+		if ($classNode->{astNodeName} eq 'QFontMetrics' and $name eq 'boundingRect' && $#{$m->{ParamList}} == 7) {
+			if ($m->{ParamList}[7]->{ArgType} =~ /int/ && defined $m->{ParamList}[7]->{DefaultValue}) {
+			    pop(@{$m->{ParamList}});
+			    $#{$m->{ParamList}}--;
+			    $m->{Params} =~ s/int \*tabarray\=0//;
+			}
+		}
+
+		if ($classNode->{astNodeName} eq 'QFontMetrics' and $name eq 'size' && $#{$m->{ParamList}} == 3) {
+			if ($m->{ParamList}[3]->{ArgType} =~ /int/ && defined $m->{ParamList}[3]->{DefaultValue}) {
+			    pop(@{$m->{ParamList}});
+			    $#{$m->{ParamList}}--;
+			    $m->{Params} =~ s/int \*tabarray\=0//;
+			}
+		}
+
+		
+	    my $argId = 0;
+	    my $firstDefaultParam;
+	    foreach my $arg ( @{$m->{ParamList}} ) {
+		# Look for first param with a default value
+		if ( defined $arg->{DefaultValue} && !defined $firstDefaultParam ) {
+		    $firstDefaultParam = $argId;
+		}
+
+		if ( $arg->{ArgType} eq '...' # refuse a method with variable arguments
+		     or $arg->{ArgType} eq 'image_io_handler' # QImage's callback
+		     or $arg->{ArgType} eq 'DecoderFn' # QFile's callback
+		     or $arg->{ArgType} eq 'EncoderFn' # QFile's callback
+		     or $arg->{ArgType} =~ /bool \(\*\)\(QObject/ # QMetaObject's ctor
+		     or $arg->{ArgType} eq 'QtStaticMetaObjectFunction' # QMetaObjectCleanUp's ctor with func pointer
+		     or $arg->{ArgType} eq 'const QTextItem&' # ref to a private class in 3.2.0b1
+		     or $arg->{ArgType} eq 'FILE*' # won't be able to handle that I think
+		     or $arg->{ArgType} eq 'const KKeyNative&' #
+		     or $arg->{ArgType} =~ /Node\s*\*/ #
+		) {
+		    $m->{NodeType} = 'deleted';
+		}
+		else
+		{
+		    # Resolve type in full, e.g. for QSessionManager::RestartHint
+		    # (x_QSessionManager doesn't inherit QSessionManager)
+		    $arg->{ArgType} = kalyptusDataDict::resolveType($arg->{ArgType}, $classNode, $rootnode);
+		    registerType( $arg->{ArgType} );
+		    $argId++;
+		}
+	    }
+	    $m->AddProp( "FirstDefaultParam", $firstDefaultParam );
+	    $m->{ReturnType} = kalyptusDataDict::resolveType($m->{ReturnType}, $classNode, $rootnode) if ($m->{ReturnType});
+	    registerType( $m->{ReturnType} );
+	}
+	elsif( $m->{NodeType} eq "enum" ) {
+	    my $fullEnumName = $className."::".$m->{astNodeName};
+		
+		if ( ($fullEnumName eq 'KMimeType::Format' and $name eq 'compression')
+				|| $m->{Deprecated} ) {
+		    $m->{NodeType} = 'deleted';
+			next;
+		}
+	    
+		$classNode->{enumerations}{$m->{astNodeName}} = $fullEnumName
+		if $m->{astNodeName} and $m->{Access} ne 'private';
+
+	    # Define a type for this enum
+	    registerType( $fullEnumName );
+
+	    # Remember that it's an enum
+	    findTypeEntry( $fullEnumName )->{isEnum} = 1;
+
+	    #print STDERR "$fullEnumName is an enum\n";
+ 	}
+	elsif( $m->{NodeType} eq 'var' ) {
+		if (	($classNode->{astNodeName} eq 'QUuid' and $name eq 'data4')
+				|| ($name eq 'd')
+				|| ($classNode->{astNodeName} eq 'QObject' and $name eq 'staticMetaObject')
+				|| ($classNode->{astNodeName} eq 'SlaveBase' and $name eq 'mIncomingMetaData')
+				|| ($classNode->{astNodeName} eq 'SlaveBase' and $name eq 'mOutgoingMetaData') ) 
+		{
+			$m->{NodeType} = 'deleted';
+			next;
+		}
+
+	    my $varType = $m->{Type};
+		$varType =~ s/const\s+(.*)\s*&/$1/;
+		$varType =~ s/^\s*//;
+		$varType =~ s/\s*$//;
+		$varType =~ s/static\s+//;
+
+		if ( $m->{Flags} =~ "s" ) {
+			# We are interested in public static vars, like QColor::blue
+			if ( $m->{Access} ne 'private'
+				&& $className."::".$m->{astNodeName} ne "KSpell::modalListText" )
+			{
+				print STDERR "var: $m->{astNodeName} '$varType'\n" if ($debug);
+
+				# Register the type
+				registerType( $varType );
+			} else {
+				$m->{NodeType} = 'deleted';
+			}
+		} elsif ($m->{Access} eq 'public') {
+			# Add a setter method for a public instance variable
+			my $setMethod = $name;
+			if ($setMethod =~ /^(\w)(.*)/) {
+				my $ch = $1;
+				$ch =~ tr/a-z/A-Z/;
+				$setMethod = "set$ch$2";
+			}
+			my $node = Ast::New( $setMethod );
+			$node->AddProp( "NodeType", "method" );
+			# Flags of "=" for a setter method
+			$node->AddProp( "Flags", "=" );
+			$node->AddProp( "ReturnType", "void" );
+			$node->AddProp( "Params", $varType );
+
+			my $param = Ast::New( 1 );
+			$param->AddProp( "NodeType", "param" );
+			$param->AddProp( "ArgType", $varType );
+			$node->AddPropList( "ParamList", $param );
+
+			kdocAstUtil::attachChild( $classNode, $node );
+
+			# Register the type
+			registerType( $varType );
+		} else {
+			$m->{NodeType} = 'deleted';
+		}
+	}
+		},
+		undef
+	);
+	$main::doPrivate = $doPrivate;
+
+	print STDERR "$className: ctor count: $constructorCount, hasPublicProtectedConstructor: $hasPublicProtectedConstructor, hasCopyConstructor: $hasCopyConstructor:, defaultConstructor: $defaultConstructor, hasPublicDestructor: $hasPublicDestructor, hasPrivatePureVirtual:$hasPrivatePureVirtual\n" if ($debug);
+
+	my $isGlobalSpace = ($className eq $main::globalSpaceClassName);
+
+	# Note that if the class has _no_ constructor, the default ctor applies. Let's even generate it.
+	if ( !$constructorCount && $defaultConstructor eq 'none' 
+		&& !$hasPrivatePureVirtual && !$isGlobalSpace && $classNode->{NodeType} ne 'namespace' ) {
+	    # Create a method node for the constructor
+	    my $methodNode = Ast::New( $classNode->{astNodeName} );
+	    $methodNode->AddProp( "NodeType", "method" );
+	    $methodNode->AddProp( "Flags", "" );
+	    $methodNode->AddProp( "Params", "" );
+            $methodNode->AddProp( "ParamList", [] );
+	    kdocAstUtil::attachChild( $classNode, $methodNode );
+
+	    # Hack the return type for constructors, since constructors return an object pointer
+	    $methodNode->AddProp( "ReturnType", $className."*" );
+	    registerType( $className."*" );
+	    $methodNode->AddProp( "Access", "public" ); # after attachChild
+	    $defaultConstructor = 'public';
+	    $hasPublicProtectedConstructor = 1;
+	}
+
+	# Also, if the class has no explicit destructor, generate a default one.
+	if ( !$hasDestructor && !$hasPrivatePureVirtual && !$isGlobalSpace && $classNode->{NodeType} ne 'namespace' ) {
+	    my $methodNode = Ast::New( "$classNode->{astNodeName}" );
+	    $methodNode->AddProp( "NodeType", "method" );
+	    $methodNode->AddProp( "Flags", "" );
+	    $methodNode->AddProp( "Params", "" );
+	    $methodNode->AddProp( "ParamList", [] );
+	    kdocAstUtil::attachChild( $classNode, $methodNode );
+
+	    $methodNode->AddProp( "ReturnType", "~" );
+	    $methodNode->AddProp( "Access", "public" );
+	}
+
+	# If we have a private pure virtual, then the class can't be instanciated (e.g. QCanvasItem)
+	# Same if the class has only private constructors (e.g. QInputDialog)
+	$classNode->AddProp( "CanBeInstanciated", $hasPublicProtectedConstructor && !$hasPrivatePureVirtual );
+
+	# We will derive from the class only if it has public or protected constructors.
+	# (_Even_ if it has pure virtuals. But in that case the x_ class can't be instantiated either.)
+	$classNode->AddProp( "BindingDerives", $hasPublicProtectedConstructor );
+
+	# We need a public dtor to destroy the object --- ### aren't protected dtors ok too ??
+	$classNode->AddProp( "HasPublicDestructor", $hasPublicDestructor );
+
+	# Hack for QAsyncIO. We don't implement the "if a class has no explicit copy ctor,
+	# then all of its member variables must be copiable, otherwise the class isn't copiable".
+	$hasPrivateCopyConstructor = 1 if ( $className eq 'QAsyncIO' );
+
+	# Remember if this class can't be copied - it means all its descendants can't either
+	$classNode->AddProp( "CanBeCopied", !$hasPrivateCopyConstructor );
+	$classNode->AddProp( "HasCopyConstructor", $hasCopyConstructor );
+}
+
+
+sub propagateCanBeCopied($)
+{
+	my $classNode = shift;
+	my $className = join( "::", kdocAstUtil::heritage($classNode) );
+	my @super = superclass_list($classNode);
+	# A class can only be copied if none of its ancestors have a private copy ctor.
+	for my $s (@super) {
+	    if (!$s->{CanBeCopied}) {
+		$classNode->{CanBeCopied} = 0;
+		print STDERR "$classNode->{astNodeName} cannot be copied\n" if ($debug);
+		last;
+	    }
+	}
+	# If the class has no explicit copy constructor, and it can be copied,
+	# generate the copy constructor.
+	if ( !$classNode->{HasCopyConstructor} && $classNode->{CanBeCopied} && $classNode->{CanBeInstanciated} ) {
+	    my $methodNode = Ast::New( "$classNode->{astNodeName}" );
+	    $methodNode->AddProp( "NodeType", "method" );
+	    $methodNode->AddProp( "Flags", "ix" ); # Only for internal use in marshallers
+	    my $argType = "const ".$className."&";
+	    registerType( $argType );
+	    $methodNode->AddProp( "Params", $argType );
+	    # The param node
+		my $node = Ast::New( 1 ); # let's make the arg index the node "name"
+		$node->AddProp( "NodeType", "param" );
+		$node->AddProp( "ArgType", $argType );
+		$methodNode->AddPropList( "ParamList", $node );
+	    kdocAstUtil::attachChild( $classNode, $methodNode );
+
+	    # Hack the return type for constructors, since constructors return an object pointer
+	    $methodNode->AddProp( "ReturnType", $className."*" );
+	    registerType( $className."*" );
+	    $methodNode->AddProp( "Access", "public" ); # after attachChild
+	}
+
+	# Prepare the {case} dict for the class
+	prepareCaseDict( $classNode );
+}
+
+=head2 writeClassDoc
+
+	Called by writeDoc for each series of classes to be written out
+
+=cut
+
+BEGIN {
+
+my $fhn =1; # static
+
+  sub writeClassDoc
+  {
+	my $nodelist = shift;
+        my $file = "$outputdir/x_${fhn}.cpp";
+        open( my $fh, ">$file" ) || die "Couldn't create $file\n";
+
+	print $fh "//Auto-generated by $0. DO NOT EDIT.\n";
+ 	print $fh "#include <smoke.h>\n";
+ 	print $fh "#include <${libname}_smoke.h>\n";
+	
+        my @code;
+        for my $node ( @$nodelist )
+        {
+            push @code, [generateAllMethods( $node )]
+        }
+        my %includes;
+        map { for my $incl (keys %{$_->[2]}){ $includes{$incl}++ } } @code;
+
+	# Hack - some Qt/KDE headers need other headers included, but omit suitable #includes
+	if (defined $includes{"qregexp.h"} || defined $includes{"qcstring.h"}) {
+	    print $fh "#include <qregexp.h>\n";
+		delete $includes{"qregexp.h"};
+	}
+	if (defined $includes{"qmime.h"} || defined $includes{"qmimedata.h"}) {
+	    print $fh "#include <qurl.h>\n";
+		delete $includes{"qurl.h"};
+	}
+	if (defined $includes{"kshortcut.h"}) {
+	    print $fh "#include <kshortcut.h>\n";
+		delete $includes{"kshortcut.h"};
+	} 
+	if (defined $includes{"kshortcutlist.h"}) {
+	    print $fh "#include <kconfigbase.h>\n";
+	    print $fh "#include <kshortcutlist.h>\n";
+		delete $includes{"kconfigbase.h"};
+		delete $includes{"kshortcutlist.h"};
+	}
+	if (defined $includes{"kaction.h"}) {
+	    print $fh "#include <kaction.h>\n";
+		delete $includes{"kaction.h"};
+	}
+	foreach my $incl (keys %includes) {
+	    die if $incl eq '';
+	    print $fh "#include <$incl>\n";
+	}	
+	print $fh "\n";
+        for my $c( 0..$#code )
+        {
+           my ($methodCode, $switchCode, $incl) = @{ $code[$c] };
+           my $node = $$nodelist[$c];
+           my $className = join( "::", kdocAstUtil::heritage($node) );
+           my $legacyClassName = join( "__", kdocAstUtil::heritage($node) );
+           print $fh "class x_$legacyClassName ";
+           print $fh ": public $className " if $node->{BindingDerives};
+           print $fh "{\n";
+           print $fh $methodCode;
+           print $fh "};\n";
+	   if(keys %{$node->{enumerations}}) {
+	        print $fh "void xenum_${legacyClassName}(Smoke::EnumOperation xop, Smoke::Index xtype, void *&xdata, long &xvalue) {\n";
+	        print $fh "    x_${legacyClassName}\::xenum_operation(xop, xtype, xdata, xvalue);\n";
+	        print $fh "}\n";
+	   }
+	   print $fh "void xcall_${legacyClassName}(Smoke::Index xi, void *obj, Smoke::Stack args) {\n";
+	   print $fh $switchCode;
+	   print $fh "}\n\n";
+        }
+	#if ( $className =~ /^(QBrush|QColor|QCursor|QFont|QImage|QPalette|QPixmap|QPoint|QPointArray|QRect|QRegion|QSize|QWMatrix)$/ ) {
+	#	print XCPPFILE "    const char *{serial} operator << () const : pig_serialize(\$this);\n";
+	#	print XCPPFILE "    void operator >> (const char *{serial}) : pig_deserialize(\$this, \$1);\n";
+	#}
+
+	close $fh;
+        $fhn++
+  }
+
+}
+
+# Generate the prototypes for a method (one per arg with a default value)
+# Helper for makeprotos
+sub iterproto($$$$$) {
+    my $classidx = shift; # to check if a class exists
+    my $method = shift;
+    my $proto = shift;
+    my $idx = shift;
+    my $protolist = shift;
+
+    my $argcnt = scalar @{ $method->{ParamList} } - 1;
+    if($idx > $argcnt) {
+	push @$protolist, $proto;
+	return;
+    }
+    if(defined $method->{FirstDefaultParam} and $method->{FirstDefaultParam} <= $idx) {
+	push @$protolist, $proto;
+    }
+
+    my $arg = $method->{ParamList}[$idx]->{ArgType};
+
+    my $typeEntry = findTypeEntry( $arg );
+    my $realType = $typeEntry->{realType};
+
+    # A scalar ?
+    $arg =~ s/\bconst\b//g;
+    $arg =~ s/\s+//g;
+    if($typeEntry->{isEnum} || $allTypes{$realType}{isEnum} || exists $typeunion{$realType} || exists $mungedTypeMap{$arg})
+    {
+	my $id = '$'; # a 'scalar
+	$id = '?' if $arg =~ /[*&]{2}/;
+	$id = $mungedTypeMap{$arg} if exists $mungedTypeMap{$arg};
+	iterproto($classidx, $method, $proto . $id, $idx + 1, $protolist);
+	return;
+    }
+
+    # A class ?
+    if(exists $classidx->{$realType}) {
+	iterproto($classidx, $method, $proto . '#', $idx + 1, $protolist);
+	return;
+    }
+
+    # A non-scalar (reference to array or hash, undef)
+    iterproto($classidx, $method, $proto . '?', $idx + 1, $protolist);
+    return;
+}
+
+# Generate the prototypes for a method (one per arg with a default value)
+sub makeprotos($$$) {
+    my $classidx = shift;
+    my $method = shift;
+    my $protolist = shift;
+    iterproto($classidx, $method, $method->{astNodeName}, 0, $protolist);
+}
+
+# Return the string containing the signature for this method (without return type).
+# If the 2nd arg is not the size of $m->{ParamList}, this method returns a
+# partial signature (this is used to handle default values).
+sub methodSignature($$) {
+    my $method = shift;
+    my $last = shift;
+    my $sig = $method->{astNodeName};
+    my @argTypeList;
+    my $argId = 0;
+    foreach my $arg ( @{$method->{ParamList}} ) {
+	last if $argId > $last;
+	push @argTypeList, $arg->{ArgType};
+	$argId++;
+    }
+    $sig .= "(". join(", ", at argTypeList) .")";
+    $sig .= " const" if $method->{Flags} =~ "c";
+    return $sig;
+}
+
+sub coerce_type($$$$) {
+    #my $m = shift;
+    my $union = shift;
+    my $var = shift;
+    my $type = shift;
+    my $new = shift; # 1 if this is a return value, 0 for a normal param
+
+    my $typeEntry = findTypeEntry( $type );
+    my $realType = $typeEntry->{realType};
+
+    my $unionfield = $typeEntry->{typeId};
+    die "$type" unless defined( $unionfield );
+    $unionfield =~ s/t_/s_/;
+
+    $type =~ s/\s+const$//; # for 'char* const'
+    $type =~ s/\s+const\s*\*$/\*/; # for 'char* const*'
+
+    my $code = "$union.$unionfield = ";
+    if($type =~ /&$/) {
+	$code .= "(void*)&$var;\n";
+    } elsif($type =~ /\*$/) {
+	$code .= "(void*)$var;\n";
+    } else {
+	if ( $unionfield eq 's_class' 
+		or ( $unionfield eq 's_voidp' and $type ne 'void*' )
+		or $type eq 'QString' ) { # hack
+	    $type =~ s/^const\s+//;
+	    if($new) {
+	        $code .= "(void*)new $type($var);\n";
+	    } else {
+	        $code .= "(void*)&$var;\n";
+	    }
+	} else {
+	    $code .= "$var;\n";
+	}
+    }
+
+    return $code;
+}
+
+# Generate the list of args casted to their real type, e.g.
+# (QObject*)x[1].s_class,(QEvent*)x[2].s_class,x[3].s_int
+sub makeCastedArgList
+{
+    my @castedList;
+    my $i = 1; # The args start at x[1]. x[0] is the return value
+    my $arg;
+    foreach $arg (@_) {
+	my $type = $arg;
+	my $cast;
+
+	my $typeEntry = findTypeEntry( $type );
+	my $unionfield = $typeEntry->{typeId};
+	die "$type" unless defined( $unionfield );
+	$unionfield =~ s/t_/s_/;
+
+	$type =~ s/\s+const$//; # for 'char* const'
+	$type =~ s/\s+const\s*\*$/\*/; # for 'char* const*'
+
+	my $v .= "x[$i].$unionfield";
+	if($type =~ s/&$//) {
+	    $cast = "*($type *)";
+	} elsif($type =~ /\*$/) {
+	    $cast = "($type)";
+        } elsif($type =~ /\(\*\)\s*\(/) { # function pointer ... (*)(...)
+            $cast = "($type)";
+	} else {
+	    if ( $unionfield eq 's_class'
+		or ( $unionfield eq 's_voidp' and $type ne 'void*' )
+		or $type eq 'QString' ) { # hack
+	        $cast = "*($type *)";
+	    } else {
+	        $cast = "($type)";
+	    }
+	}
+	push @castedList, "$cast$v";
+	$i++;
+    }
+    return @castedList;
+}
+
+# Adds the header for node $1 to be included in $2 if not already there
+# Prints out debug stuff if $3
+sub addIncludeForClass($$$)
+{
+    my ( $node, $addInclude, $debugMe ) = @_;
+    my $sourcename = $node->{Source}->{astNodeName};
+    if ( $sourcename !~ s!.*($headerSubdirectories)(.*)!$1$2!m ) {
+    	$sourcename =~ s!.*/(.*)!$1!m;
+	}
+#    die "Empty source name for $node->{astNodeName}" if ( $sourcename eq '' );
+    return if ( $sourcename eq '' );
+    unless ( defined $addInclude->{$sourcename} ) {
+	print "  Including $sourcename\n" if ($debugMe);
+	$addInclude->{$sourcename} = 1;
+    }
+    else { print "  $sourcename already included.\n" if ($debugMe); }
+}
+
+sub checkIncludesForObject($$)
+{
+    my $type = shift;
+    my $addInclude = shift;
+
+    my $debugCI = 0; #$debug
+    #print "checkIncludesForObject $type\n";
+    $type =~ s/const\s+//;
+    my $it = $type;
+    if (!($it and exists $typeunion{$it}) and $type !~ /\*/
+         #and $type !~ /&/  # in fact we also want refs, due to the generated code
+        ) {
+	$type =~ s/&//;
+	print "  Detecting an object by value/ref: $type\n" if ($debugCI);
+	my $node = kdocAstUtil::findRef( $rootnode, $type );
+	if ($node) {
+	    addIncludeForClass( $node, $addInclude, $debugCI );
+	}
+	else { print " No header found for $type\n" if ($debugCI); }
+    }
+}
+
+sub generateVirtualMethod($$$$$)
+{
+    # Generating methods for $class.
+    # $m: method node. $methodClass: the node of the class in which the method is really declared
+    # (can be different from $class when the method comes from a super class)
+    # This is important because of $allMethods, which has no entry for class::method in that case.
+
+    my( $classNode, $signature, $m, $methodClass, $addInclude ) = @_;
+    my $methodCode = '';                    # output
+    my $returnType = $m->{ReturnType};
+    return ('', '') if $returnType eq '~'; # skip destructors
+
+    my $className = $classNode->{astNodeName};
+    my $flags = $m->{Flags};
+    my @argList = @{$m->{ParamList}};
+
+    print "generateVirtualMethod $className: $signature  ($m->{Access})\n" if ($debug);
+
+    # Detect objects returned by value
+    checkIncludesForObject( $returnType, $addInclude ) if ($returnType ne 'void');
+
+    # Generate a matching virtual method in the x_ class
+    $methodCode .= "    virtual $returnType $m->{astNodeName}(";
+    my $i = 0;
+    foreach my $arg ( @argList ) {
+        $methodCode .= ", " if $i++;
+        $methodCode .= $arg->{ArgType};
+        $methodCode .= " x$i";
+
+	# Detect objects passed by value
+	checkIncludesForObject( $arg->{ArgType}, $addInclude );
+    }
+    $methodCode .= ") ";
+    $methodCode .= "const " if ($flags =~ "c");
+    $methodCode .= "\{\n";
+
+    # Now the code of the method
+    my $this = $classNode->{BindingDerives} > 0 ? "this" : "xthis";
+
+    $i++; # Now the number of args
+    $methodCode .= "\tSmoke::StackItem x[$i];\n";
+    $i = 1;
+    for my $arg (@argList) {
+	$methodCode .= "\t";
+	$methodCode .= coerce_type("x[$i]", "x$i", $arg->{ArgType}, 0);
+	$i++;
+    }
+
+    my $sig = $methodClass->{astNodeName} . "::" . $signature;
+    my $idx = $allMethods{$sig};
+    
+	if ( ! defined $idx ) {
+		my $class_name = join( "::", kdocAstUtil::heritage($methodClass) );
+		$sig = $class_name . "::" . $signature;
+		$idx = $allMethods{$sig};
+	}
+#    die "generateVirtualMethod: $className: No method found for $sig\n" if !defined $idx;
+
+if ( !defined $idx ) {
+    print "generateVirtualMethod: $className: No method found for $sig\n";
+    return ('', '');
+}
+
+    if($flags =~ "p") { # pure virtual
+	$methodCode .= "\t${libname}_Smoke->binding->callMethod($idx, (void*)$this, x, true /*pure virtual*/);\n";
+    } else {
+	$methodCode .= "\tif(${libname}_Smoke->binding->callMethod($idx, (void*)$this, x)) ";
+    }
+
+    $returnType = undef if ($returnType eq 'void');
+    if($returnType) {
+	my $arg = $returnType;
+	my $it = applyTypeDef( $arg );
+	my $cast;
+	my $v = "x[0]";
+	my $indent = ($flags =~ "p") ? "\t" : "";
+	if($it and exists $typeunion{$it}) {
+	    $v .= ".$typeunion{$it}";
+	    $cast = "($arg)";
+	    $methodCode .= "${indent}return $cast$v;\n";
+	} else {
+	    $v .= ".s_class";
+	    if($arg =~ s/&//) {
+		$cast = "*($arg *)";
+		$methodCode .= "${indent}return $cast$v;\n";
+	    } elsif($arg !~ /\*$/) {
+		unless($flags =~ "p") {
+		    $indent = "\t    ";
+		    $methodCode .= "{\n";
+		}
+		# we assume it's a new thing, and handle it
+		$methodCode .= "${indent}$arg *xptr = ($arg *)$v;\n";
+		$methodCode .= "${indent}$arg xret(*xptr);\n";
+		$methodCode .= "${indent}delete xptr;\n";
+		$methodCode .= "${indent}return xret;\n";
+		$methodCode .= "\t}\n" unless $flags =~ "p";
+	    } else {
+		$cast = "($arg)";
+		$methodCode .= "${indent}return $cast$v;\n";
+	    }
+	}
+    } else {
+	$methodCode .= "\t" if $flags =~ "p";
+	$methodCode .= "return;\n";
+    }
+    if($flags =~ "p") {
+	$methodCode .= "\t// ABSTRACT\n";
+	$methodCode .= "    }\n";
+	return ( $methodCode );
+    }
+    $methodCode .= "\t";
+    if($returnType) {
+	$methodCode .= "return ";
+    }
+    $methodCode .= "$this\->$methodClass->{astNodeName}\::$m->{astNodeName}(";
+    $i = 0;
+    for my $arg (@argList) {
+	$methodCode .= ", " if $i++;
+	$methodCode .= "x$i";
+    }
+    $methodCode .= ");\n";
+    $methodCode .= "    }\n";
+    return ( $methodCode );
+}
+
+sub generateMethod($$$)
+{
+    my( $classNode, $m, $addInclude ) = @_;	# input
+    my $methodCode = '';	# output
+    my $switchCode = '';	# output
+
+    my $name = $m->{astNodeName}; # method name
+    my @heritage = kdocAstUtil::heritage($classNode);
+    my $className  = join( "::", @heritage );
+    my $xClassName  = "x_" . join( "__", @heritage );
+
+    # Check some method flags: constructor, destructor etc.
+    my $flags = $m->{Flags};
+
+    if ( !defined $flags ) {
+	warn "Method ".$name.  " has no flags\n";
+    }
+
+    my $returnType = $m->{ReturnType};
+
+    $returnType = undef if ($returnType eq 'void');
+
+    # Don't use $className here, it's never the fully qualified (A::B) name for a ctor.
+    my $isConstructor = ($name eq $classNode->{astNodeName} );
+    my $isDestructor = ($returnType eq '~');
+
+    if ($debug) {
+        print STDERR " Method $name";
+	print STDERR ", is DTOR" if $isDestructor;
+	print STDERR ", returns $returnType" if $returnType;
+	#print STDERR " ($m->{Access})";
+	print STDERR "\n";
+    }
+
+    # Don't generate anything for destructors
+    return if $isDestructor;
+
+    return if ( $m->{SkipFromSwitch} ); # pure virtuals, etc.
+
+#    # Skip internal methods, which return unknown types
+#    # Hmm, the C# bindings have a list of those too.
+#    return if ( $returnType =~ m/QGfx\s*\*/ );
+#    return if ( $returnType eq 'CGContextRef' );
+#    return if ( $returnType eq 'QWSDisplay *' );
+#    # This stuff needs callback, or **
+#    return if ( $name eq 'defineIOHandler' or $name eq 'qt_init_internal' );
+#    # Skip casting operators, but not == < etc.
+#    return if ( $name =~ /operator \w+/ );
+#    # QFile's EncoderFn/DecoderFn
+#    return if ( $name =~ /set[ED][ne]codingFunction/ );
+#    # How to implement this? (QXmlDefaultHandler/QXmlEntityResolver::resolveEntity, needs A*&)
+#    return if ( $name eq 'resolveEntity' and $className =~ /^QXml/ );
+#    return if ( $className eq 'QBitArray' && $m->{Access} eq 'protected' );
+
+    #print STDERR "Tests passed, generating.\n";
+
+    # Detect objects returned by value
+    checkIncludesForObject( $returnType, $addInclude ) if ($returnType);
+
+    my $argId = 0;
+
+    my @argTypeList=();
+
+    foreach my $arg ( @{$m->{ParamList}} ) {
+
+	print STDERR "  Param ".$arg->{astNodeName}." type: ".$arg->{ArgType}." name:".$arg->{ArgName}." default: ".$arg->{DefaultValue}."\n" if ($debug);
+
+	my $argType = $arg->{ArgType};
+	push @argTypeList, $argType;
+		
+	# Detect objects passed by value
+	checkIncludesForObject( $argType, $addInclude );
+	}    
+
+    my @castedArgList = makeCastedArgList( @argTypeList );
+
+    my $isStatic = $flags =~ "s";
+
+    my $extra = "";
+    $extra .= "static " if $isStatic || $isConstructor || $classNode->{NodeType} eq 'namespace';
+
+    my $attr = "";
+    $attr .= "const " if $flags =~ "c";
+
+    my $this = $classNode->{BindingDerives} > 0 ? "this" : "xthis";
+
+    # We iterate as many times as we have default params
+    my $firstDefaultParam = $m->{FirstDefaultParam};
+    $firstDefaultParam = scalar(@argTypeList) unless defined $firstDefaultParam;
+    my $iterationCount = scalar(@argTypeList) - $firstDefaultParam;
+
+    my $xretCode = '';
+    if($returnType) {
+	$xretCode .= coerce_type('x[0]', 'xret', $returnType, 1);
+    }
+
+    print STDERR "  ". ($iterationCount+1). " iterations for $name\n" if ($debug);
+
+    while($iterationCount >= 0) {
+
+	local($") = ",";
+	# Handle case of a class with constructors, but with a private pure virtual
+	# so we can't create an instance of it
+	if($isConstructor and !$classNode->{CanBeInstanciated}) {
+
+	    # We still generate "forwarder constructors" for x_className though
+	    $methodCode .= "    $xClassName(";
+	    my $i = 0;
+	    for my $arg (@argTypeList) {
+		$methodCode .= ", " if $i++;
+		$methodCode .= "$arg x$i";
+	    }
+	    $methodCode .= ") : $className(";
+	    $i = 0;
+	    for my $arg (@argTypeList) {
+		$methodCode .= ", " if $i++;
+		$methodCode .= "x$i";
+	    }
+	    $methodCode .= ") {}\n";
+
+	} else {
+
+	    $switchCode .= "\tcase $methodNumber: ";
+	    if ($flags =~ "s" || $isConstructor || $classNode->{NodeType} eq 'namespace') { # static, namespace or constructor
+	        $switchCode .= "$xClassName\::";
+	    } else {
+	        $switchCode .= "xself->"
+	    }
+	    $switchCode .= "x_$methodNumber(args);";
+	    $switchCode .= "\tbreak;\n";
+
+	    $methodCode .= "    ${extra}void x_$methodNumber\(Smoke::Stack x) $attr\{\n";
+	    my $cplusplusparams = join( ", ", @argTypeList );
+	    $methodCode .= "\t// $name($cplusplusparams)\n";
+	    $methodCode .= "\t";
+	
+	    if ($isConstructor) {
+
+	        $methodCode .= "$xClassName* xret = new $xClassName(@castedArgList[0..$#argTypeList]);\n";
+	        #$m->{retnew} = 1;
+	        $methodCode .= "\tx[0].s_class = (void*)xret;\n"; # the return value, containing the new object
+	        $methodCode .= "    }\n";
+
+	        # Now generate the actual constructor for x_className
+	        # (Simply a forwarder to the className constructor with the same args
+			if ( $flags =~ "t" ) {
+	        	$methodCode .= "    explicit $xClassName(";
+			} else {
+	        	$methodCode .= "    $xClassName(";
+			}
+	        my $i = 0;
+	        for my $arg (@argTypeList) {
+		    $methodCode .= ", " if $i++;
+                    if ($arg =~ s/\(\*\)/(* x$i)/) { # function pointer... need to insert argname inside
+                        $methodCode .= $arg;
+                    } else {
+		    $methodCode .= "$arg x$i";
+                    }
+	        }
+	        $methodCode .= ") : $className(";
+	        $i = 0;
+	        for my $arg (@argTypeList) {
+		    $methodCode .= ", " if $i++;
+		    $methodCode .= "x$i";
+	        }
+	        $methodCode .= ") {\n";
+
+	    } else {
+	        $methodCode .= $returnType . " xret = " if $returnType;
+	        $methodCode .= "$this\->" unless $isStatic || $classNode->{NodeType} eq 'namespace';
+		if ($className ne $main::globalSpaceClassName) {
+			if ($flags =~ "=") {
+				# Setter method for a public instance variable
+				my $varName = $name;
+				$varName =~ /^set(\w)(.*)/;
+				my $ch = $1;
+				$ch =~ tr/A-Z/a-z/;
+				$varName = $ch . $2;
+				$methodCode .= "$varName = @castedArgList[0..$#argTypeList];\n";
+			} else {
+		    	$methodCode .= "$className\::$name(@castedArgList[0..$#argTypeList]);\n";
+			}
+		} elsif ($name =~ /^operator\s?\W+/) {
+		    ( my $op = $name ) =~ s/^operator(.*)$/$1/;
+		    if (scalar(@argTypeList) == 2) {
+                        if( $name =~ /^operator(?:\+\+|--)/ ) { # postfix increment/decrement
+                            $methodCode .= "(@castedArgList[0])$op;\n";
+                        } else {
+			    $methodCode .= "(@castedArgList[0] $op @castedArgList[1]);\n"; # a + b
+                        }
+		    } elsif (scalar(@argTypeList) == 1) {
+			$methodCode .= "$op(@castedArgList[0]);\n"; # -a
+		    } else {
+			die "shouldn't reach here!";
+		    }
+		} else {
+		    $methodCode .= "$name(@castedArgList[0..$#argTypeList]);\n";
+		}
+	        $methodCode .= "\t" . $xretCode if $returnType;
+		# To avoid unused parameter warning, add this to void methods:
+		$methodCode .= "\t(void)x; // noop (for compiler warning)\n" unless $returnType;
+	    }
+	    $methodCode .= "    }\n";
+    }
+
+
+	pop @argTypeList;
+	$methodNumber++;
+	$iterationCount--;
+    } # Iteration loop
+
+    return ( $methodCode, $switchCode );
+}
+
+
+sub generateEnum($$$)
+{
+    my( $classNode, $m, $addInclude ) = @_;	# input
+    my $methodCode = '';	# output
+    my $switchCode = '';	# output
+
+    my @heritage = kdocAstUtil::heritage($classNode);
+    my $className  = join( "::", @heritage );
+    my $xClassName  = "x_" . join( "__", @heritage );
+    
+	my $fullEnumType = "$className\::". $m->{astNodeName};
+	checkIncludesForObject( $fullEnumType, $addInclude );
+
+    foreach my $enum ( @{$m->{ParamList}} ) {
+	my $enumName = $enum->{ArgName};
+	my $fullEnumName = "$className\::$enumName";
+        die "Invalid index for $fullEnumName: $classNode->{case}{$fullEnumName} instead of $methodNumber" if $classNode->{case}{$fullEnumName} != $methodNumber;
+	$methodCode .= "    static void x_$methodNumber(Smoke::Stack x) {\n";
+	$methodCode .= "\tx[0].s_enum = (long)$fullEnumName;\n";
+        $methodCode .= "    }\n";
+        $switchCode .= "\tcase $methodNumber: $xClassName\::x_$methodNumber(args);\tbreak;\n";
+        $methodNumber++;
+    }
+
+    return ( $methodCode, $switchCode );
+}
+
+sub generateVar($$$)
+{
+    my( $classNode, $m, $addInclude ) = @_;	# input
+    my $methodCode = '';	# output
+    my $switchCode = '';	# output
+
+    my @heritage = kdocAstUtil::heritage($classNode);
+    my $className  = join( "::", @heritage );
+    my $xClassName  = "x_" . join( "__", @heritage );
+
+    my $name = $m->{astNodeName};
+    my $varType = $m->{Type};
+    $varType =~ s/static\s//;
+    $varType =~ s/const\s+(.*)\s*&/$1/;
+    $varType =~ s/\s*$//;
+    my $fullName = "$className\::$name";
+    my $this = $classNode->{BindingDerives} > 0 ? "this" : "xthis";
+
+    checkIncludesForObject( $varType, $addInclude );
+
+    die "Invalid index for $fullName: $classNode->{case}{$fullName} instead of $methodNumber" if $classNode->{case}{$fullName} != $methodNumber;
+	if ( $m->{Flags} =~ "s" ) {	
+    	$methodCode .= "    static void x_$methodNumber(Smoke::Stack x) {\n        ";
+    	$methodCode .= coerce_type('x[0]', $fullName, $varType, 1);
+    	$methodCode .= "    }\n";
+    	$switchCode .= "\tcase $methodNumber: $xClassName\::x_$methodNumber(args);\tbreak;\n";
+	} else {
+    	$methodCode .= "    void x_$methodNumber(Smoke::Stack x) {\n        ";
+    	$methodCode .= coerce_type('x[0]', "$this->$name", $varType, 1);
+    	$methodCode .= "    }\n";
+    	$switchCode .= "\tcase $methodNumber: xself->x_$methodNumber(args);\tbreak;\n";
+	}
+
+    $methodNumber++;
+
+    return ( $methodCode, $switchCode );
+}
+
+sub generateEnumCast($)
+{
+    my( $classNode ) = @_;
+    my $methodCode = '';
+    return unless keys %{$classNode->{enumerations}};
+    $methodCode .= "    static void xenum_operation(Smoke::EnumOperation xop, Smoke::Index xtype, void *&xdata, long &xvalue) {\n";
+    $methodCode .= "\tswitch(xtype) {\n";
+    for my $enum (values %{$classNode->{enumerations}}) {
+	
+	# Hack - this shouldn't be needed here - deprecated enums
+	next if ($enum eq 'KStatusBar::BarStatus' 
+				or $enum eq 'KMdi::AddWindowFlags' 
+				or $enum eq 'KToolBar::BarStatus' 
+				or $enum eq 'KMimeType::Format:: compression : 4');
+	
+	my $type = findTypeEntry($enum);
+	$methodCode .= "\t  case $type->{index}: //$enum\n";
+	$methodCode .= "\t    switch(xop) {\n";
+	$methodCode .= "\t      case Smoke::EnumNew:\n";
+	$methodCode .= "\t\txdata = (void*)new $enum;\n";
+	$methodCode .= "\t\tbreak;\n";
+	$methodCode .= "\t      case Smoke::EnumDelete:\n";	# unnecessary
+	$methodCode .= "\t\tdelete ($enum*)xdata;\n";
+	$methodCode .= "\t\tbreak;\n";
+	$methodCode .= "\t      case Smoke::EnumFromLong:\n";
+	$methodCode .= "\t\t*($enum*)xdata = ($enum)xvalue;\n";
+	$methodCode .= "\t\tbreak;\n";
+	$methodCode .= "\t      case Smoke::EnumToLong:\n";
+	$methodCode .= "\t\txvalue = (long)*($enum*)xdata;\n";
+	$methodCode .= "\t\tbreak;\n";
+	$methodCode .= "\t    }\n";
+	$methodCode .= "\t    break;\n";
+    }
+    $methodCode .= "\t}\n";
+    $methodCode .= "    }\n";
+
+    return $methodCode;
+} 
+
+## Called by writeClassDoc
+sub generateAllMethods
+{
+    my ($classNode) = @_;
+    my $methodCode = '';
+    my $switchCode = '';
+    $methodNumber = 0;
+
+    #my $className = $classNode->{astNodeName};
+    my $className = join( "::", kdocAstUtil::heritage($classNode) );
+    my $xClassName = "x_" . join( "__", kdocAstUtil::heritage($classNode) );
+    my $isGlobalSpace = ($xClassName eq ("x_".$main::globalSpaceClassName));
+    my $sourcename = $classNode->{Source}->{astNodeName};
+   
+    if ( $sourcename !~ s!.*($headerSubdirectories)(.*)!$1$2!m ) {
+    	$sourcename =~ s!.*/(.*)!$1!m;
+	}
+    die "Empty source name for $classNode->{astNodeName}" if ( $sourcename eq '' );
+
+    my %addInclude = ( $sourcename => 1 );
+
+    if (!$isGlobalSpace) {
+        if($classNode->{NodeType} eq 'namespace') {
+           $switchCode .= "    (void)obj;\n";
+            $methodCode .= "public:\n";
+        	my $s;
+        	for my $sn( @{$classNode->{Sources}} ) {
+    		if ( ($s = $sn->{astNodeName}) !~ s!.*($headerSubdirectories)(.*)!$1$2!m ) {
+    			$s =~ s!.*/(.*)!$1!m;
+			}
+			$addInclude{ $s } = 1;
+        	}
+         } elsif(! $classNode->{BindingDerives}) {
+            $methodCode .= "private:\n";
+            $methodCode .= "    $className *xthis;\n";
+            $methodCode .= "public:\n";
+            $methodCode .= "    $xClassName\(void *x) : xthis(($className*)x) {}\n";
+            $switchCode .= "    $xClassName xtmp(obj), *xself = &xtmp;\n";
+        } else {
+            $switchCode .= "    $xClassName *xself = ($xClassName*)obj;\n";
+            $methodCode .= "public:\n";
+        }
+    } else {
+        my $s;
+        for my $sn( @{$classNode->{Sources}} ) {
+    	if ( ($s = $sn->{astNodeName}) !~ s!.*($headerSubdirectories)(.*)!$1$2!m ) {
+    		$s =~ s!.*/(.*)!$1!m;
+		}
+		$addInclude{ $s } = 1;
+        }
+	$methodCode .= "public:\n";
+	$switchCode .= "    (void) obj;\n";
+    }
+    $switchCode .= "    switch(xi) {\n";
+
+    # Do all enums first
+    Iter::MembersByType ( $classNode, undef,
+			  sub {	my ($classNode, $methodNode ) = @_;
+				
+	if ( $methodNode->{NodeType} eq 'enum' ) {
+	    my ($meth, $swit) = generateEnum( $classNode, $methodNode, \%addInclude );
+	    $methodCode .= $meth;
+	    $switchCode .= $swit;
+	}
+				}, undef );
+
+    # Then all static vars
+    Iter::MembersByType ( $classNode, undef,
+			  sub {	my ($classNode, $methodNode ) = @_;
+				
+	if ( $methodNode->{NodeType} eq 'var' ) {
+	    my ($meth, $swit) = generateVar( $classNode, $methodNode, \%addInclude );
+	    $methodCode .= $meth;
+	    $switchCode .= $swit;
+	}
+				}, undef );
+
+    # Then all methods
+    Iter::MembersByType ( $classNode, undef,
+			  sub {	my ($classNode, $methodNode ) = @_;
+
+        if ( $methodNode->{NodeType} eq 'method' ) {
+	    my ($meth, $swit) = generateMethod( $classNode, $methodNode, \%addInclude );
+	    $methodCode .= $meth;
+	    $switchCode .= $swit;
+	}
+			      }, undef );
+
+    # Virtual methods
+    if ($classNode->{BindingDerives}) {
+	my %virtualMethods;
+	allVirtualMethods( $classNode, \%virtualMethods );
+
+	for my $sig (sort keys %virtualMethods) {
+            my ($meth) = generateVirtualMethod( $classNode, $sig, $virtualMethods{$sig}{method}, $virtualMethods{$sig}{class}, \%addInclude );
+	    $methodCode .= $meth;
+	}
+    }
+
+    $methodCode .= generateEnumCast( $classNode );
+
+    # Destructor
+    # "virtual" is useless, if the base class has a virtual destructor then the x_* class too.
+    #if($classNode->{HasVirtualDestructor} and $classNode->{HasDestructor}) {
+    #	$methodCode .= "    virtual ~$xClassName() {}\n";
+    #}
+    # We generate a dtor though, because we might want to add stuff into it
+    if ( !$isGlobalSpace && $classNode->{NodeType} ne 'namespace' ) {
+        $methodCode .= "    ~$xClassName() { ${libname}_Smoke->binding->deleted($classNode->{ClassIndex}, (void*)this); }\n";
+    }
+
+    if ($classNode->{CanBeInstanciated} and $classNode->{HasPublicDestructor}) {
+	die "$className destructor: methodNumber=$methodNumber != case entry=".$classNode->{case}{"~$className()"}."\n"
+	     if $methodNumber != $classNode->{case}{"~$className()"};
+	$switchCode .= "\tcase $methodNumber: delete ($className*)xself;\tbreak;\n";
+	$methodNumber++;
+    }
+
+    $switchCode .= "    }\n";
+    return ( $methodCode, $switchCode, \%addInclude );
+}
+
+# Return 0 if the class has no virtual dtor, 1 if it has, 2 if it's private
+sub hasVirtualDestructor($)
+{
+    my ( $classNode ) = @_;
+    my $className = join( "::", kdocAstUtil::heritage($classNode) );
+    return if ( $skippedClasses{$className} );
+
+    my $parentHasIt;
+    # Look at ancestors, and (recursively) call hasVirtualDestructor for each
+    # It's enough to have one parent with a prot/public virtual dtor
+    Iter::Ancestors( $classNode, $rootnode, undef, undef, sub {
+                     my $vd = hasVirtualDestructor( $_[0] );
+                     $parentHasIt = $vd unless $parentHasIt > $vd;
+                    } );
+    return $parentHasIt if $parentHasIt; # 1 or 2
+
+    # Now look in $classNode - including private methods
+    my $doPrivate = $main::doPrivate;
+    $main::doPrivate = 1;
+    my $result;
+    Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+			return unless( $m->{NodeType} eq "method" && $m->{ReturnType} eq '~' );
+
+			if ( $m->{Flags} =~ /[vp]/ ) {
+			    if ( $m->{Access} =~ /private/ ) {
+				$result=2; # private virtual
+			    } else {
+				$result=1; # [protected or public] virtual
+			    }
+			}
+		},
+		undef
+	);
+    $main::doPrivate = $doPrivate;
+    $result=0 if (!defined $result);
+    return $result;
+}
+
+=head2 allVirtualMethods
+
+	Parameters: class node, dict
+
+	Adds to the dict, for all method nodes that are virtual, in this class and in parent classes :
+        {method} the method node, {class} the class node (the one where the virtual is implemented)
+
+=cut
+
+sub allVirtualMethods($$)
+{
+    my ( $classNode, $virtualMethods ) = @_;
+    my $className = join( "::", kdocAstUtil::heritage($classNode) );
+    return if ( $skippedClasses{$className} );
+
+    # Look at ancestors, and (recursively) call allVirtualMethods for each
+    # This is done first, so that virtual methods that are reimplemented as 'private'
+    # can be removed from the list afterwards (below)
+    Iter::Ancestors( $classNode, $rootnode, undef, undef, sub {
+			 allVirtualMethods( @_[0], $virtualMethods );
+		     }, undef
+		   );
+
+    # Now look for virtual methods in $classNode - including private ones
+    my $doPrivate = $main::doPrivate;
+    $main::doPrivate = 1;
+    Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+			# Only interested in methods, and skip destructors
+			return unless( $m->{NodeType} eq "method" && $m->{ReturnType} ne '~' );
+
+			my $signature = methodSignature( $m, $#{$m->{ParamList}} );
+			print STDERR $signature . " ($m->{Access})\n" if ($debug);
+
+			# A method is virtual if marked as such (v=virtual p=pure virtual)
+			# or if a parent method with same signature was virtual
+			if ( $m->{Flags} =~ /[vp]/ or defined $virtualMethods->{$signature} ) {
+			    if ( $m->{Access} =~ /private/ ) {
+				if ( defined $virtualMethods->{$signature} ) { # remove previously defined
+				    delete $virtualMethods->{$signature};
+				}
+				# else, nothing, just ignore private virtual method
+			    } else {
+				$virtualMethods->{$signature}{method} = $m;
+				$virtualMethods->{$signature}{class} = $classNode;
+			    }
+			}
+		},
+		undef
+	);
+    $main::doPrivate = $doPrivate;
+}
+
+# Known typedef? If so, apply it.
+sub applyTypeDef($)
+{
+    my $type = shift;
+    # Parse 'const' in front of it, and '*' or '&' after it
+    my $prefix = $type =~ s/^const\s+// ? 'const ' : '';
+    my $suffix = $type =~ s/\s*([\&\*]+)$// ? $1 : '';
+
+    if (exists $typedeflist{$type}) {
+	return $prefix.$typedeflist{$type}.$suffix;
+    }
+    return $prefix.$type.$suffix;
+}
+
+# Register type ($1) into %allTypes if not already there
+sub registerType($$) {
+    my $type = shift;
+    #print "registerType: $type\n" if ($debug);
+
+    $type =~ s/\s+const$//; # for 'char* const'
+    $type =~ s/\s+const\s*\*$/\*/; # for 'char* const*'
+	
+	$type =~ s/(<[^>]*)\s+([^>]*>)/$1$2/; # Remove embedded space from template types, such as
+										  # 'QMap<QCString, DCOPRef>'
+
+    return if ( $type eq 'void' or $type eq '' or $type eq '~' );
+    die if ( $type eq '...' );     # ouch
+
+    # Let's register the real type, not its known equivalent
+    #$type = applyTypeDef($type);
+
+    # Enum _value_ -> get corresponding type
+    if (exists $enumValueToType{$type}) {
+	$type = $enumValueToType{$type};
+    }
+
+    # Already in allTypes
+    if(exists $allTypes{$type}) {
+        return;
+    }
+
+    die if $type eq 'QTextEdit::UndoRedoInfo::Type';
+    die if $type eq '';
+
+    my $realType = $type;
+
+    # Look for references (&) and pointers (* or **)  - this will not handle *& correctly.
+    # We do this parsing here because both the type list and iterproto need it
+    if($realType =~ s/&$//) {
+	$allTypes{$type}{typeFlags} = 'Smoke::tf_ref';
+    }
+    elsif($realType ne 'void*' && $realType =~ s/\*$//) {
+	$allTypes{$type}{typeFlags} = 'Smoke::tf_ptr';
+    }
+    else {
+	$allTypes{$type}{typeFlags} = 'Smoke::tf_stack';
+    }
+
+    if ( $realType =~ s/^const\s+// ) { # Remove 'const'
+	$allTypes{$type}{typeFlags} .= ' | Smoke::tf_const';
+    }
+
+    # Apply typedefs, and store the resulting type.
+    # For instance, if $type was Q_UINT16&, realType will be ushort
+    $allTypes{$type}{realType} = applyTypeDef( $realType );
+
+    # In the first phase we only create entries into allTypes.
+    # The values (indexes) are calculated afterwards, once the list is full.
+    $allTypes{$type}{index} = -1;
+    #print STDERR "Register $type. Realtype: $realType\n" if($debug);
+}
+
+# Get type from %allTypes
+# This returns a hash with {index}, {isEnum}, {typeFlags}, {realType}
+# (and {typeId} after the types array is written by writeSmokeDataFile)
+sub findTypeEntry($) {
+    my $type = shift;
+    my $typeIndex = -1;
+    $type =~ s/\s+const$//; # for 'char* const'
+    $type =~ s/\s+const\s*\*$/\*/; # for 'char* const*'
+
+	$type =~ s/(<[^>]*)\s+([^>]*>)/$1$2/; # Remove embedded space from template types, such as
+										  # 'QMap<QCString, DCOPRef>'
+
+    return undef if ( $type =~ '~' or $type eq 'void' or $type eq '' );
+
+    # Enum _value_ -> get corresponding type
+    if (exists $enumValueToType{$type}) {
+	$type = $enumValueToType{$type};
+    }
+
+    die "type not known: $type" unless defined $allTypes{$type};
+    return $allTypes{ $type };
+}
+
+# List of all super-classes for a given class
+sub superclass_list($)
+{
+    my $classNode = shift;
+    my @super;
+    Iter::Ancestors( $classNode, $rootnode, undef, undef, sub {
+			push @super, @_[0];
+			push @super, superclass_list( @_[0] );
+		     }, undef );
+    return @super;
+}
+
+# Store the {case} dict in the class Node (method signature -> index in the "case" switch)
+# This also determines which methods should NOT be in the switch, and sets {SkipFromSwitch} for them
+sub prepareCaseDict($) {
+
+     my $classNode = shift;
+     my $className = join( "::", kdocAstUtil::heritage($classNode) );
+     $classNode->AddProp("case", {});
+     my $methodNumber = 0;
+
+     # First look at all enums for this class
+     Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	next unless $m->{NodeType} eq 'enum';
+	foreach my $val ( @{$m->{ParamList}} ) {
+	    my $fullEnumName = "$className\::".$val->{ArgName};
+	    print STDERR "Enum: $fullEnumName -> case $methodNumber\n" if ($debug);
+	    $classNode->{case}{$fullEnumName} = $methodNumber;
+	    $enumValueToType{$fullEnumName} = "$className\::$m->{astNodeName}";
+	    $methodNumber++;
+	}
+		      }, undef );
+
+     # Check for vars
+     Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	    next unless $m->{NodeType} eq 'var';
+	    my $name = "$className\::".$m->{astNodeName};			
+	    print STDERR "Var: $name -> case $methodNumber\n" if ($debug);
+	    $classNode->{case}{$name} = $methodNumber;
+	    $methodNumber++;
+
+		      }, undef );
+
+	 my %const_methods = ();
+     # Now look at all const methods for this class, in order to use
+	 # them in preference to any otherwise identical non-const method
+     Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+	
+		next unless $m->{NodeType} eq 'method';
+		my @args = @{ $m->{ParamList} };
+	    my $sig = methodSignature( $m, $#args );
+		if ( $sig =~ /(.*) const$/ ) {
+			$const_methods{$1} = 1;
+		}
+		
+		      }, undef );
+
+     # Now look at all methods for this class
+     Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	next unless $m->{NodeType} eq 'method';
+	my $name = $m->{astNodeName};
+        my $isConstructor = ($name eq $classNode->{astNodeName} );
+	if ($isConstructor and ($m->{ReturnType} eq '~')) # destructor
+	{
+	    # Remember whether we'll generate a switch entry for the destructor
+	    $m->{SkipFromSwitch} = 1 unless ($classNode->{CanBeInstanciated} and $classNode->{HasPublicDestructor});
+	    next;
+	}
+
+        # Don't generate bindings for protected methods (incl. signals) if
+        # we're not deriving from the C++ class. Only take public and public_slots
+        my $ok = ( $classNode->{BindingDerives} or $m->{Access} =~ /public/ ) ? 1 : 0;
+
+        # Don't generate bindings for pure virtuals - we can't call them ;)
+        $ok = 0 if ( $ok && $m->{Flags} =~ "p" );
+
+        # Bugfix for Qt-3.0.4: those methods are NOT implemented (report sent).
+        $ok = 0 if ( $ok && $className eq 'QLineEdit' && ( $name eq 'setPasswordChar' || $name eq 'passwordChar' ) );
+        $ok = 0 if ( $ok && $className eq 'QWidgetItem' && $name eq 'widgetSizeHint' );
+
+        if ( !$ok )
+        {
+	    #print STDERR "Skipping $className\::$name\n" if ($debug);
+	    $m->{SkipFromSwitch} = 1;
+	    next;
+	}
+
+	my @args = @{ $m->{ParamList} };
+	my $sig = methodSignature( $m, $#args );
+	if ( $const_methods{$sig} && $m->{Flags} !~ "v" ) {
+		# If there is a method which just differs from another by 'constness',
+		# then ignore the non-const version
+	    $m->{SkipFromSwitch} = 1;
+	    next;
+	}
+	my $last = $m->{FirstDefaultParam};
+	$last = scalar @args unless defined $last;
+	my $iterationCount = scalar(@args) - $last;
+	while($iterationCount >= 0) {
+	    $sig = methodSignature( $m, $#args );
+	    $classNode->{case}{$sig} = $methodNumber;
+	    #print STDERR "prepareCaseDict: registered case number $methodNumber for $sig in $className()\n" if ($debug);
+	    pop @args;
+	    $iterationCount--;
+	    $methodNumber++;
+	}
+		    }, undef );
+
+    # Add the destructor, at the end
+    if ($classNode->{CanBeInstanciated} and $classNode->{HasPublicDestructor}) {
+        $classNode->{case}{"~$className()"} = $methodNumber;
+	# workaround for ~Sub::Class() being seen as Sub::~Class()
+	$classNode->{case}{"~$classNode->{astNodeName}()"} = $methodNumber;
+	#print STDERR "prepareCaseDict: registered case number $methodNumber for ~$className()\n" if ($debug);
+    }
+}
+
+=head2
+	Write out the smokedata.cpp file containing all the arrays.
+=cut
+
+sub writeSmokeDataFile($) {
+    my $rootnode = shift;
+
+    # Make list of classes
+    my %allIncludes; # list of all header files for all classes
+    my @classlist;
+    push @classlist, ""; # Prepend empty item for "no class"
+    my %enumclasslist;
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = $_[0];
+	my $className = join( "::", kdocAstUtil::heritage($classNode) );
+	
+	push @classlist, $className;
+	$enumclasslist{$className}++ if keys %{$classNode->{enumerations}};
+	$classNode->{ClassIndex} = $#classlist;
+	addIncludeForClass( $classNode, \%allIncludes, undef );
+    } );
+
+    my %classidx = do { my $i = 0; map { $_ => $i++ } @classlist };
+
+    my $file = "$outputdir/smokedata.cpp";
+    open OUT, ">$file" or die "Couldn't create $file\n";
+
+    foreach my $incl (sort{ 
+                           return 1 if $a=~/qmotif/;  # move qmotif* at bottom (they include dirty X11 headers)
+                           return -1 if $b=~/qmotif/;
+			   return -1 if substr($a,0,1) eq 'q' and substr($b,0,1) ne 'q'; # move Qt headers on top
+			   return 1 if substr($a,0,1) ne 'q' and substr($b,0,1) eq 'q';			   
+                           $a cmp $b
+                          } keys %allIncludes) {
+	die if $incl eq '';
+        if( $incl eq "kxmlguifactory.h" ) {
+            print OUT "#include <kxmlguiclient.h>\n";
+        }
+	print OUT "#include <$incl>\n";
+    }	
+
+    print OUT "\n";
+    print OUT "#include <smoke.h>\n\n";
+    print OUT "#include <qt_smoke.h>\n\n";
+
+    # gcc optimizes this method like crazy. switch() is godly
+    print OUT "static void *${libname}_cast(void *xptr, Smoke::Index from, Smoke::Index to) {\n";
+    print OUT "    switch(from) {\n";
+
+    print STDERR "Writing ${libname}_cast function\n" if ($debug);
+
+    # Prepare descendants information for each class
+    my %descendants; # classname -> list of descendant nodes
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	# Get _all_ superclasses (up any number of levels)
+	# and store that $classNode is a descendant of $s
+	my @super = superclass_list($classNode);
+	for my $s (@super) {
+	    my $superClassName = join( "::", kdocAstUtil::heritage($s) );
+	    Ast::AddPropList( \%descendants, $superClassName, $classNode );
+	}
+    } );
+
+    # Iterate over all classes, to write the xtypecast function
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( "::", kdocAstUtil::heritage($classNode) );
+	# @super will contain superclasses, the class itself, and all descendants
+	my @super = superclass_list($classNode);
+	push @super, $classNode;
+        if ( defined $descendants{$className} ) {
+	    push @super, @{$descendants{$className}};
+	}
+	my $cur = $classidx{$className};
+	
+	return if $classNode->{NodeType} eq 'namespace';
+
+	print OUT "      case $cur:\t//$className\n";
+	print OUT "\tswitch(to) {\n";
+	$cur = -1;
+	my %casevalues;
+	for my $s (@super) {
+		my $superClassName = join( "::", kdocAstUtil::heritage($s) );
+		next if !defined $classidx{$superClassName}; # inherits from unknown class, see below
+		next if $classidx{$superClassName} == $cur;    # shouldn't happen in Qt
+		if (!defined $s) {
+			die "problem with $className missing parent"
+		}
+		next if $s->kdocAstUtil::inheritsAsVirtual($classNode); # can't cast from a virtual base class
+		$cur = $classidx{$superClassName}; # KDE has MI with diamond shaped cycles (cf. KXMLGUIClient)
+		next if $casevalues{$cur};         # ..so skip any duplicate parents
+		print OUT "\t  case $cur: return (void*)($superClassName*)($className*)xptr;\n";
+		$casevalues{$cur} = 1;
+	}
+	print OUT "\t  default: return xptr;\n";
+	print OUT "\t}\n";
+    } );
+    print OUT "      default: return xptr;\n";
+    print OUT "    }\n";
+    print OUT "}\n\n";
+
+
+    # Write inheritance array
+    # Imagine you have "Class : public super1, super2"
+    # The inheritlist array will get 3 new items: super1, super2, 0
+    my %inheritfinder;  # key = (super1, super2) -> data = (index in @inheritlist). This one allows reuse.
+    my %classinherit;   # we store that index in %classinherit{className}
+    # We don't actually need to store inheritlist in memory, we write it
+    # directly to the file. We only need to remember its current size.
+    my $inheritlistsize = 1;
+
+    print OUT "// Group of class IDs (0 separated) used as super class lists.\n";
+    print OUT "// Classes with super classes have an index into this array.\n";
+    print OUT "static short ${libname}_inheritanceList[] = {\n";
+    print OUT "\t0,\t// 0: (no super class)\n";
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( "::", kdocAstUtil::heritage($classNode) );
+	
+	print STDERR "inheritanceList: looking at $className\n" if ($debug);
+
+	# Make list of direct ancestors
+	my @super;
+	Iter::Ancestors( $classNode, $rootnode, undef, undef, sub {
+			     my $superClassName = join( "::", kdocAstUtil::heritage($_[0]) );
+			     push @super, $superClassName;
+		    }, undef );
+	# Turn that into a list of class indexes
+	my $key = '';
+	foreach my $superClass( @super ) {
+	    if (defined $classidx{$superClass}) {
+		$key .= ', ' if ( length $key > 0 );
+		$key .= $classidx{$superClass};
+	    }
+	}
+	if ( $key ne '' ) {
+	    if ( !defined $inheritfinder{$key} ) {
+		print OUT "\t";
+		my $index = $inheritlistsize; # Index of first entry (for this group) in inheritlist
+		foreach my $superClass( @super ) {
+		    if (defined $classidx{$superClass}) {
+			print OUT "$classidx{$superClass}, ";
+			$inheritlistsize++;
+		    }
+		}
+		$inheritlistsize++;
+		my $comment = join( ", ", @super );
+		print OUT "0,\t// $index: $comment\n";
+		$inheritfinder{$key} = $index;
+	    }
+	    $classinherit{$className} = $inheritfinder{$key};
+	} else { # No superclass
+	    $classinherit{$className} = 0;
+	}
+    } );
+    print OUT "};\n\n";
+
+
+    print OUT "// These are the xenum functions for manipulating enum pointers\n";
+    for my $className (keys %enumclasslist) {
+	my $c = $className;
+	$c =~ s/::/__/g;
+	print OUT "void xenum_$c\(Smoke::EnumOperation, Smoke::Index, void*&, long&);\n";
+    }
+    print OUT "\n";
+    print OUT "// Those are the xcall functions defined in each x_*.cpp file, for dispatching method calls\n";
+    my $firstClass = 1;
+    for my $className (@classlist) {
+	if ($firstClass) {
+	    $firstClass = 0;
+	    next;
+	}
+	my $c = $className;   # make a copy
+	$c =~ s/::/__/g;
+	print OUT "void xcall_$c\(Smoke::Index, void*, Smoke::Stack);\n";
+    }
+    print OUT "\n";
+
+    # Write class list afterwards because it needs offsets to the inheritance array.
+    print OUT "// List of all classes\n";
+    print OUT "// Name, index into inheritanceList, method dispatcher, enum dispatcher, class flags\n";
+    print OUT "static Smoke::Class ${libname}_classes[] = {\n";
+    my $firstClass = 1;
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( "::", kdocAstUtil::heritage($classNode) );
+
+	if ($firstClass) {
+	    $firstClass = 0;
+	    print OUT "\t{ 0L, 0, 0, 0, 0 }, \t// 0 (no class)\n";
+	}
+	my $c = $className;
+	$c =~ s/::/__/g;
+	my $xcallFunc = "xcall_$c";
+	my $xenumFunc = "0";
+	$xenumFunc = "xenum_$c" if exists $enumclasslist{$className};
+	die "problem with $className" unless defined $classinherit{$className};
+
+	my $xClassFlags = 0;
+	$xClassFlags .= "|Smoke::cf_constructor" if $classNode->{CanBeInstanciated}; # correct?
+	$xClassFlags .= "|Smoke::cf_deepcopy" if $classNode->{CanBeCopied}; # HasCopyConstructor would be wrong (when it's private)
+	$xClassFlags .= "|Smoke::cf_virtual" if hasVirtualDestructor($classNode) == 1;
+	# $xClassFlags .= "|Smoke::cf_undefined" if ...;
+	$xClassFlags =~ s/0\|//; # beautify
+	print OUT "\t{ \"_$className\", $classinherit{$className}, $xcallFunc, $xenumFunc, $xClassFlags }, \t//$classidx{$className}\n";
+    } );
+    print OUT "};\n\n";
+
+
+    print OUT "// List of all types needed by the methods (arguments and return values)\n";
+    print OUT "// Name, class ID if arg is a class, and TypeId\n";
+    print OUT "static Smoke::Type ${libname}_types[] = {\n";
+    my $typeCount = 0;
+    $allTypes{''}{index} = 0; # We need an "item 0"
+    for my $type (sort keys %allTypes) {
+	$allTypes{$type}{index} = $typeCount;      # Register proper index in allTypes
+	if ( $typeCount == 0 ) {
+	    print OUT "\t{ 0, 0, 0 },\t//0 (no type)\n";
+	    $typeCount++;
+	    next;
+	}
+	my $isEnum = $allTypes{$type}{isEnum};
+	my $typeId;
+	my $typeFlags = $allTypes{$type}{typeFlags};
+	my $realType = $allTypes{$type}{realType};
+	die "$type" if !defined $typeFlags;
+#	die "$realType" if $realType =~ /\(/;
+	if ($realType =~ /\(/) {
+		print "FATAL ERROR $type $realType\n";
+	}
+	# First write the name
+	print OUT "\t{ \"$type\", ";
+	# Then write the classId (and find out the typeid at the same time)
+	if(exists $classidx{$realType}) { # this one first, we want t_class for QBlah*
+	    $typeId = 't_class';
+	    print OUT "$classidx{$realType}, ";
+	}
+	elsif($type =~ /&$/ || $type =~ /\*$/) {
+	    $typeId = 't_voidp';
+	    print OUT "0, "; # no classId
+	}
+	elsif($isEnum || $allTypes{$realType}{isEnum}) {
+	    $typeId = 't_enum';
+	    if($realType =~ /(.*)::/) {
+		my $c = $1;
+		if($classidx{$c}) {
+		    print OUT "$classidx{$c}, ";
+		} else {
+		    print OUT "0 /* unknown class $c */, ";
+		}
+	    } else {
+		print OUT "0 /* unknown $realType */, "; # no classId
+	    }
+	}
+	else {
+	    $typeId = $typeunion{$realType};
+	    if (defined $typeId) {
+		$typeId =~ s/s_/t_/; # from s_short to t_short for instance
+	    }
+	    else {
+		# Not a known class - ouch, this happens quite a lot
+		# (private classes, typedefs, template-based types, etc)
+		if ( $skippedClasses{$realType} ) {
+#		    print STDERR "$realType has been skipped, using t_voidp for it\n";
+		} else {
+		    unless( $realType =~ /</ ) { # Don't warn for template stuff...
+			print STDERR "$realType isn't a known type (type=$type)\n";
+		    }
+		}
+		$typeId = 't_voidp'; # Unknown -> map to a void *
+	    }
+	    print OUT "0, "; # no classId
+	}
+	# Then write the flags
+	die "$type" if !defined $typeId;
+	print OUT "Smoke::$typeId | $typeFlags },";
+	print OUT "\t//$typeCount\n";
+	$typeCount++;
+	# Remember it for coerce_type
+	$allTypes{$type}{typeId} = $typeId;
+    }
+    print OUT "};\n\n";
+
+
+    my %arglist; # registers the needs for argumentList (groups of type ids)
+    my %methods;
+    # Look for all methods and all enums, in all classes
+    # And fill in methods and arglist. This loop writes nothing to OUT.
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( "::", kdocAstUtil::heritage($classNode) );
+	print STDERR "writeSmokeDataFile: arglist: looking at $className\n" if ($debug);
+
+	Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	my $methName = $m->{astNodeName};
+	# For destructors, get a proper signature that includes the '~'
+	if ( $m->{ReturnType} eq '~' )
+	{
+	    $methName = '~' . $methName ;
+	    # Let's even store that change, otherwise we have to do it many times
+	    $m->{astNodeName} = $methName;
+	}
+	
+	if( $m->{NodeType} eq "enum" ) {
+
+	    foreach my $enum ( @{$m->{ParamList}} ) {
+		my $enumName = $enum->{ArgName};
+	        $methods{$enumName}++;
+	    }
+
+	} elsif ( $m->{NodeType} eq 'var' ) {
+		$methods{$m->{astNodeName}}++;
+	} elsif( $m->{NodeType} eq "method" ) {
+
+	    $methods{$methName}++;
+	    my @protos;
+	    makeprotos(\%classidx, $m, \@protos);
+
+	    #print "made @protos from $className $methName $m->{Signature})\n" if ($debug);
+	    for my $p (@protos) {
+		$methods{$p}++;
+		my $argcnt = 0;
+		$argcnt = length($1) if $p =~ /([\$\#\?]+)/;
+		my $sig = methodSignature($m, $argcnt-1);
+		# Store in a class hash named "proto", a proto+signature => method association
+		$classNode->{proto}{$p}{$sig} = $m;
+		#$classNode->{signature}{$sig} = $p;
+		# There's probably a way to do this better, but this is the fastest way
+		# to get the old code going: store classname into method
+		$m->{class} = $className;
+	    }
+
+	    my $firstDefaultParam = $m->{FirstDefaultParam};
+	    $firstDefaultParam = scalar(@{ $m->{ParamList} }) unless defined $firstDefaultParam;
+	    my $argNames = '';
+	    my $args = '';
+	    for(my $i = 0; $i < @{ $m->{ParamList} }; $i++) {
+		$args .= ', ' if $i;
+		$argNames .= ', ' if $i;
+		my $argType = $m->{ParamList}[$i]{ArgType};
+		my $typeEntry = findTypeEntry( $argType );
+		$args .= defined $typeEntry ? $typeEntry->{index} : 0;
+		$argNames .= $argType;
+
+		if($i >= ($firstDefaultParam - 1)) {
+		    #print "arglist entry: $args\n";
+		    $arglist{$args} = $argNames;
+		}
+		
+	    }
+	    # create an entry for e.g. "arg0,arg1,arg2" where argN is index in allTypes of type for argN
+	    # The value, $argNames, is temporarily stored, to be written out as comment
+	    # It gets replaced with the index in the next loop.
+	    #print "arglist entry : $args\n";
+	    $arglist{$args} = $argNames;
+	}
+		    }, # end of sub
+	undef
+       );
+    });
+
+
+    $arglist{''} = 0;
+    # Print arguments array
+    print OUT "static Smoke::Index ${libname}_argumentList[] = {\n";
+    my $argListCount = 0;
+    for my $args (sort keys %arglist) {
+	my $numTypes = scalar(split ',', $args);
+	if ($args eq '') {
+	    print OUT "\t0,\t//0  (void)\n";
+	} else {
+	    # This is a nice trick : args can be written in one go ;)
+	    print OUT "\t$args, 0,\t//$argListCount  $arglist{$args}  \n";
+	}
+	$arglist{$args} = $argListCount;      # Register proper index in argList
+	$argListCount += $numTypes + 1;       # Move forward by as much as we wrote out
+    }
+    print OUT "};\n\n";
+
+    $methods{''} = 0;
+    my @methodlist = sort keys %methods;
+    my %methodidx = do { my $i = 0; map { $_ => $i++ } @methodlist };
+
+    print OUT "// Raw list of all methods, using munged names\n";
+    print OUT "static const char *${libname}_methodNames[] = {\n";
+    my $methodNameCount = $#methodlist;
+    for my $m (@methodlist) {
+	print OUT qq(    "$m",\t//$methodidx{$m}\n);
+    }
+    print OUT "};\n\n";
+
+    print OUT "// (classId, name (index in methodNames), argumentList index, number of args, method flags, return type (index in types), xcall() index)\n";
+    print OUT "static Smoke::Method ${libname}_methods[] = {\n";
+    my @methods;
+    %allMethods = ();
+    my $methodCount = 0;
+    # Look at all classes and all enums again
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( "::", kdocAstUtil::heritage($classNode) );
+	
+	my $classIndex = $classidx{$className};
+	print STDERR "writeSmokeDataFile: methods: looking at $className\n" if ($debug);
+
+	Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	if( $m->{NodeType} eq "enum" ) {
+
+	    foreach my $enum ( @{$m->{ParamList}} ) {
+		my $enumName = $enum->{ArgName};
+		my $fullEnumName = "$className\::$enumName";
+		my $sig = "$className\::$enumName\()";
+		my $xmethIndex = $methodidx{$enumName};
+		die "'Method index' for enum $sig not found" unless defined $xmethIndex;
+		my $typeId = findTypeEntry( $fullEnumName )->{index};
+		die "enum has no {case} value in $className: $fullEnumName" unless defined $classNode->{case}{$fullEnumName};
+		print OUT "\t{$classIndex, $xmethIndex, 0, 0, Smoke::mf_static|Smoke::mf_enum, $typeId, $classNode->{case}{$fullEnumName}},\t//$methodCount $fullEnumName (enum)\n";
+		$allMethods{$sig} = $methodCount;
+		print STDERR "Added entry for " . $sig . " into \$allMethods\n" if ($debug);
+		$methods[$methodCount] = {
+				c => $classIndex,
+				methIndex => $xmethIndex,
+				argcnt => '0',
+				args => 0,
+				retTypeIndex => 0,
+				idx => $classNode->{case}{$fullEnumName}
+			       };
+		$methodCount++;
+	    }
+
+	} elsif( $m->{NodeType} eq 'var' ) {
+
+	    my $name = $m->{astNodeName};
+	    my $fullName = "$className\::$name";
+	    my $sig = "$fullName\()";
+	    my $xmethIndex = $methodidx{$name};
+	    die "'Method index' for var $sig not found" unless defined $xmethIndex;
+	    my $varType = $m->{Type};
+	    $varType =~ s/static\s//;
+	    $varType =~ s/const\s+(.*)\s*&/$1/;
+	    $varType =~ s/\s*$//;
+	    my $typeId = findTypeEntry( $varType )->{index};
+	    die "var has no {case} value in $className: $fullName" unless defined $classNode->{case}{$fullName};
+		if ( $m->{Flags} =~ "s" ) {
+	    	print OUT "\t{$classIndex, $xmethIndex, 0, 0, Smoke::mf_static, $typeId, $classNode->{case}{$fullName}},\t//$methodCount $fullName (static var)\n";
+		} else {
+	    	print OUT "\t{$classIndex, $xmethIndex, 0, 0, 0, $typeId, $classNode->{case}{$fullName}},\t//$methodCount $fullName (var)\n";
+		}
+        $allMethods{$sig} = $methodCount;
+	    print STDERR "Added entry for " . $sig . " into \$allMethods\n" if ($debug);
+	    $methods[$methodCount] = {
+				c => $classIndex,
+				methIndex => $xmethIndex,
+				argcnt => '0',
+				args => 0,
+				retTypeIndex => 0,
+				idx => $classNode->{case}{$fullName}
+			       };
+	    $methodCount++;
+
+
+	} elsif( $m->{NodeType} eq "method" ) {
+
+	    # We generate a method entry only if the method is in the switch() code
+	    # BUT: for pure virtuals, they need to have a method entry, even though they
+	    # do NOT have a switch code.
+	    return if ( $m->{SkipFromSwitch} && $m->{Flags} !~ "p" );
+
+	    # No switch code for destructors if we didn't derive from the class (e.g. it has private ctors only)
+    	    return if ( $m->{ReturnType} eq '~' && ! ( $classNode->{BindingDerives} and $classNode->{HasPublicDestructor}) );
+
+            # Is this sorting really important?
+	    #for my $m (sort {$a->{name} cmp $b->{name}} @{ $self->{$c}{method} }) {
+
+	    my $methName = $m->{astNodeName};
+	    my $def = $m->{FirstDefaultParam};
+	    $def = scalar(@{ $m->{ParamList} }) unless defined $def;
+	    my $last = scalar(@{ $m->{ParamList} }) - 1;
+	    #print STDERR "writeSmokeDataFile: methods: generating for method $methName, def=$def last=$last\n" if ($debug);
+
+	    while($last >= ($def-1)) {
+		last if $last < -1;
+		my $args = [ @{ $m->{ParamList} }[0..$last] ];
+		my $sig = methodSignature($m, $last);
+		#my $methodSig = $classNode->{signature}{$sig}; # Munged signature
+		#print STDERR "writeSmokeDataFile: methods: sig=$className\::$sig methodSig=$methodSig\n" if ($debug);
+		#my $methodIndex = $methodidx{$methodSig};
+		#die "$methodSig" if !defined $methodIndex;
+
+		my $methodIndex = $methodidx{$methName};
+		die "$methName" if !defined $methodIndex;
+		my $case = $classNode->{case}{$sig};
+		my $typeEntry = findTypeEntry( $m->{ReturnType} );
+		my $retTypeIndex = defined $typeEntry ? $typeEntry->{index} : 0;
+
+		my $i = 0;
+		my $t = '';
+		for my $arg (@$args) {
+		    $t .= ', ' if $i++;
+		    my $typeEntry = findTypeEntry( $arg->{ArgType} );
+		    $t .= defined $typeEntry ? $typeEntry->{index} : 0;
+		}
+		my $arglist = $t eq '' ? 0 : $arglist{$t};
+		die "arglist for $t not found" unless defined $arglist;
+		if ( $m->{Flags} =~ "p" ) {
+		    # Pure virtuals don't have a {case} number, that's normal
+		    die "pure virtual $className\::$methName has a case number for sig=$sig" if defined $case;
+		    $case = -1; # This remains -1, not 0 !
+		} else {
+		    die "$className\::$methName has no case number for sig=$sig" unless defined $case;
+		}
+		my $argcnt = $last + 1;
+		my $methodFlags = '0';
+		# Make no distinction between a static method in an ordinary class, or a method in a namespace
+		$methodFlags .= "|Smoke::mf_static" if $m->{Flags} =~ "s" or $classNode->{NodeType} eq 'namespace';
+		$methodFlags .= "|Smoke::mf_const" if $m->{Flags} =~ "c"; # useful?? probably not
+		$methodFlags .= "|Smoke::mf_copyctor" if $m->{Flags} =~ "x";
+		$methodFlags .= "|Smoke::mf_internal" if $m->{Flags} =~ "i";
+		$methodFlags .= "|Smoke::mf_ctor" if $methName eq $className;
+		$methodFlags .= "|Smoke::mf_dtor" if $m->{ReturnType} eq '~';
+		$methodFlags .= "|Smoke::mf_protected" if $m->{Access} =~ /protected/;
+		$methodFlags =~ s/0\|//; # beautify
+		
+		print OUT "\t{$classIndex, $methodIndex, $arglist, $argcnt, $methodFlags, $retTypeIndex, $case},\t//$methodCount $className\::$sig";
+		print OUT " [pure virtual]" if ( $m->{Flags} =~ "p" ); # explain why $case = -1 ;)
+		print OUT "\n";
+		
+		$allMethods{$className . "::" . $sig} = $methodCount;
+		$methods[$methodCount] = {
+					  c => $classIndex,
+					  methIndex => $methodIndex,
+					  argcnt => $argcnt,
+					  args => $arglist,
+					  retTypeIndex => $retTypeIndex,
+					  idx => $case
+					 };
+		$methodCount++;
+		$last--;
+	    } # while
+	} # if method
+      } ); # Method Iter
+    } ); # Class Iter
+    print OUT "};\n\n";
+
+    my @protos;
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( "::", kdocAstUtil::heritage($classNode) );
+	
+	my $classIndex = $classidx{$className};
+	print STDERR "writeSmokeDataFile: protos: looking at $className\n" if ($debug);
+
+	Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	if( $m->{NodeType} eq "enum" ) {
+	    foreach my $enum ( @{$m->{ParamList}} ) {
+		my $enumName = $enum->{ArgName};
+		my $sig = "$className\::$enumName\()";
+		my $xmeth = $allMethods{$sig};
+		die "'Method' for enum $sig not found" unless defined $xmeth;
+		my $xmethIndex = $methodidx{$enumName};
+		die "'Method index' for enum $enumName not found" unless defined $xmethIndex;
+		push @protos, {
+			       methIndex => $xmethIndex,
+			       c => $classIndex,
+			       over => {
+					$sig => {
+						 sig => $sig,
+						}
+				       },
+			       meth => $xmeth
+			      };
+	    }
+
+	} elsif( $m->{NodeType} eq 'var' ) {
+
+	    my $name = $m->{astNodeName};
+	    my $fullName = "$className\::$name";
+	    my $sig = "$fullName\()";
+	    my $xmeth = $allMethods{$sig};
+	    die "'Method' for var $sig not found" unless defined $xmeth;
+	    my $xmethIndex = $methodidx{$name};
+	    die "'Method index' for var $name not found" unless defined $xmethIndex;
+	    push @protos, {
+			       methIndex => $xmethIndex,
+			       c => $classIndex,
+			       over => {
+					$sig => {
+						 sig => $sig,
+						}
+				       },
+			       meth => $xmeth
+			  };
+
+	}
+		    });
+
+	for my $p (keys %{ $classNode->{proto} }) {
+	    # For each prototype
+	    my $scratch = { %{ $classNode->{proto}{$p} } }; # sig->method association
+	    # first, grab all the superclass voodoo
+	    for my $supNode (superclass_list($classNode)) {
+		my $i = $supNode->{proto}{$p};
+		next unless $i;
+		for my $k (keys %$i) {
+		    $scratch->{$k} = $i->{$k} unless exists $scratch->{$k};
+		}
+	    }
+
+	    # Ok, now we have a full list
+	    #if(scalar keys %$scratch > 1) {
+		#print STDERR "Overload: $p (@{[keys %$scratch]})\n" if ($debug);
+	    #}
+	    my $xmethIndex = $methodidx{$p};
+	    my $classIndex = $classidx{$className};
+	    for my $sig (keys %$scratch) {
+		#my $xsig = $scratch->{$sig}{class} . "::" . $sig;
+		my $xsig = $className . "::" . $sig;
+		$scratch->{$sig}{sig} = $xsig;
+		delete $scratch->{$sig}
+		    if $scratch->{$sig}{Flags} =~ "p" # pure virtual
+			or not exists $allMethods{$xsig};
+	    }
+	    push @protos, {
+		methIndex => $xmethIndex,
+		c => $classIndex,
+		over => $scratch
+	    } if scalar keys %$scratch;
+	}
+    });
+
+    my @protolist = sort { $a->{c} <=> $b->{c} || $a->{methIndex} <=> $b->{methIndex} } @protos;
+#for my $abc (@protos) {
+#print "$abc->{methIndex}.$abc->{c}\n";
+#}
+
+    print STDERR "Writing methodmap table\n" if ($debug);
+    my @resolve = ();
+    print OUT "// Class ID, munged name ID (index into methodNames), method def (see methods) if >0 or number of overloads if <0\n";
+    my $methodMapCount = 1;
+    print OUT "static Smoke::MethodMap ${libname}_methodMaps[] = {\n";
+    print OUT "\t{ 0, 0, 0 },\t//0 (no method)\n";
+    for my $cur (@protolist) {
+	if(scalar keys %{ $cur->{over} } > 1) {
+	    print OUT "\t{$cur->{c}, $cur->{methIndex}, -@{[1+scalar @resolve]}},\t//$methodMapCount $classlist[$cur->{c}]\::$methodlist[$cur->{methIndex}]\n";
+	    $methodMapCount++;
+	    for my $k (keys %{ $cur->{over} }) {
+	        my $p = $cur->{over}{$k};
+	        my $xsig = $p->{class} ? "$p->{class}\::$k" : $p->{sig};
+	        push @resolve, { k => $k, p => $p, cur => $cur, id => $allMethods{$xsig} };
+	    }
+	    push @resolve, 0;
+	} else {
+	    for my $k (keys %{ $cur->{over} }) {
+	        my $p = $cur->{over}{$k};
+	        my $xsig = $p->{class} ? "$p->{class}\::$k" : $p->{sig};
+	        print OUT "\t{$cur->{c}, $cur->{methIndex}, $allMethods{$xsig}},\t//$methodMapCount $classlist[$cur->{c}]\::$methodlist[$cur->{methIndex}]\n";
+	        $methodMapCount++;
+	    }
+	}
+    }
+    print OUT "};\n\n";
+
+
+    print STDERR "Writing ambiguousMethodList\n" if ($debug);
+    print OUT "static Smoke::Index ${libname}_ambiguousMethodList[] = {\n";
+    print OUT "    0,\n";
+    for my $r (@resolve) {
+	unless($r) {
+	    print OUT "    0,\n";
+	    next;
+	}
+	my $xsig = $r->{p}{class} ? "$r->{p}{class}\::$r->{k}" : $r->{p}{sig};
+	die "ambiguousMethodList: no method found for $xsig\n" if !defined $allMethods{$xsig};
+	print OUT "    $allMethods{$xsig},  // $xsig\n";
+    }
+    print OUT "};\n\n";
+
+#    print OUT "extern \"C\" { // needed?\n";
+#    print OUT "    void init_${libname}_Smoke();\n";
+#    print OUT "}\n";
+    print OUT "\n";
+    print OUT "Smoke* qt_Smoke = 0L;\n";
+    print OUT "\n";
+    print OUT "// Create the Smoke instance encapsulating all the above.\n";
+    print OUT "void init_${libname}_Smoke() {\n";
+    print OUT "    qt_Smoke = new Smoke(\n";
+    print OUT "        ${libname}_classes, ".$#classlist.",\n";
+    print OUT "        ${libname}_methods, $methodCount,\n";
+    print OUT "        ${libname}_methodMaps, $methodMapCount,\n";
+    print OUT "        ${libname}_methodNames, $methodNameCount,\n";
+    print OUT "        ${libname}_types, $typeCount,\n";
+    print OUT "        ${libname}_inheritanceList,\n";
+    print OUT "        ${libname}_argumentList,\n";
+    print OUT "        ${libname}_ambiguousMethodList,\n";
+    print OUT "        ${libname}_cast );\n";
+    print OUT "}\n";
+    close OUT;
+
+#print "@{[keys %allMethods ]}\n";
+}
+
+1;

Modified: trunk/php_qt/CMakeLists.txt
===================================================================
--- trunk/php_qt/CMakeLists.txt	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/php_qt/CMakeLists.txt	2007-06-08 13:50:59 UTC (rev 345)
@@ -25,8 +25,12 @@
     )
 
 add_library(php_qt SHARED ${phpqt_LIB_SRCS})
-
 target_link_libraries(php_qt ${QT_QTCORE_LIBRARY} QtSvg QtGui QtNetwork QtSql QtOpenGL QtXml QtUiTools ${QTDBUS_LIBRARY} ${QSCINTILLA_LIBRARIES} ${QWT_LIBRARIES} smokeqt)
 set_target_properties(php_qt PROPERTIES PREFIX "")
+install(TARGETS php_qt DESTINATION ${PHP5_EXTENSION_DIR}/ )
 
-install(TARGETS php_qt DESTINATION ${PHP5_EXTENSION_DIR}/ )
+add_library(iquip SHARED ${phpqt_LIB_SRCS})
+target_link_libraries(iquip ${QT_QTCORE_LIBRARY} QtSvg QtGui QtNetwork QtSql QtOpenGL QtXml QtUiTools ${QTDBUS_LIBRARY} ${QSCINTILLA_LIBRARIES} ${QWT_LIBRARIES} smokewebqt)
+set_target_properties(iquip PROPERTIES PREFIX "")
+install(TARGETS iquip DESTINATION ${PHP5_EXTENSION_DIR}/ )
+

Modified: trunk/smoke/CMakeLists.txt
===================================================================
--- trunk/smoke/CMakeLists.txt	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/CMakeLists.txt	2007-06-08 13:50:59 UTC (rev 345)
@@ -3,8 +3,10 @@
 #message(STATUS "${CMAKE_CURRENT_SOURCE_DIR}: skipped subdir $(kde_build_libsmoke)")
 
 add_subdirectory(qt)
+add_subdirectory(web)
 #add_subdirectory(kde)
 
+
 ########### install files ###############
 
 #install( FILES  smoke.h DESTINATION ${INCLUDE_INSTALL_DIR} )

Added: trunk/smoke/web/CMakeLists.txt
===================================================================
--- trunk/smoke/web/CMakeLists.txt	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/CMakeLists.txt	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,132 @@
+
+include(FindQScintilla)
+include(FindQwt)
+
+include_directories( ${QT_INCLUDES}  ${CMAKE_CURRENT_SOURCE_DIR}/../ ${CMAKE_CURRENT_SOURCE_DIR} )
+
+if(QSCINTILLA_FOUND)
+    include_directories( ${QSCINTILLA_INCLUDE_DIR} )
+endif(QSCINTILLA_FOUND)
+
+if(QWT_FOUND)
+    include_directories( ${QWT_INCLUDE_DIR} )
+endif(QWT_FOUND)
+
+IF(QT_QTDBUS_FOUND)
+    SET(QTDBUS_LIBRARY QtDBus)
+ENDIF(QT_QTDBUS_FOUND)
+
+# for qtguess.pl
+set(qt_test_threshold 10)
+set(qtflags "-lQtCore -lQtGui")
+FOREACH(filename ${QT_INCLUDES})
+    set(all_includes "-I${filename} ${all_includes}")
+ENDFOREACH(filename)
+
+configure_file(qtguess.pl.cmake ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl @ONLY)
+configure_file(generate.pl.cmake ${CMAKE_CURRENT_BINARY_DIR}/generate.pl @ONLY )
+
+# macro is defined in qt-copy/src/qbase.pri but couldn't be found by qtguess, so I append it manually
+file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/qtdefines "QT_NO_CAST_TO_ASCII\n")
+
+########### next target ###############
+
+add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_2.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_3.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_4.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_5.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_6.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_7.cpp 
+                ${CMAKE_CURRENT_BINARY_DIR}/x_8.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_9.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_10.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_11.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_12.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_13.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_14.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_15.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_16.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_17.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_18.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_19.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_20.cpp
+
+                  COMMAND ${PERL_EXECUTABLE} ARGS ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl
+                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl
+
+                  COMMAND ${PERL_EXECUTABLE} ARGS ${CMAKE_CURRENT_BINARY_DIR}/generate.pl
+                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/generate.pl
+
+                  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
+
+macro_add_file_dependencies( ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp ${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp )
+
+set(smokewebqt_LIB_SRCS ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp  
+		${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_2.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_3.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_4.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_5.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_6.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_7.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_8.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_9.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_10.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_11.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_12.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_13.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_14.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_15.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_16.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_17.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_18.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_19.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_20.cpp
+)
+
+# kde4_add_library(smokewebqt SHARED ${smokewebqt_LIB_SRCS})
+add_library(smokewebqt SHARED ${smokewebqt_LIB_SRCS})
+
+target_link_libraries(smokewebqt ${QT_QTCORE_LIBRARY} QtSvg QtGui QtNetwork QtSql QtOpenGL QtXml QtUiTools ${QTDBUS_LIBRARY} ${QSCINTILLA_LIBRARIES} ${QWT_LIBRARIES} )
+
+set_target_properties(smokewebqt PROPERTIES VERSION 2.0.0 SOVERSION 2 )
+install(TARGETS smokewebqt DESTINATION lib )
+
+
+########### install files ###############
+
+
+
+
+#original Makefile.am contents follow:
+
+#lib_LTLIBRARIES = libsmokeqt.la
+#
+## set the include path for X, qt and KDE
+#INCLUDES         = -I$(srcdir)/.. $(all_includes) -I$(qt_includes)/QtUiTools \
+#                   -I$(qt_includes)/QtDBus
+#
+#EXTRA_DIST=generate.pl.in qtguess.pl.in qt_smoke.h Makefile.am
+#
+## the library search path. 
+#libsmokeqt_la_LDFLAGS = -version-info 2:0:0 -no-undefined $(all_libraries) $(GLINC)
+#
+## the libraries to link against.
+#libsmokeqt_la_LIBADD   = $(LIB_QTCORE) $(LIB_QTGUI) $(LIB_QTNETWORK) \
+#						$(LIB_QTOPENGL) $(LIB_QTSQL) $(LIB_QTCORE) $(LIB_QTXML) $(LIB_QTSVG) \
+#						$(GLLIB) $(LIBQSCINTILLA) \
+#						-lQtSvg -lQtUiTools $(LIBQTDBUS) $(LIBQWT)
+#
+#x_sources = x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+#   x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+#   x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp
+#
+## which sources should be compiled for perlqtkde
+#libsmokeqt_la_SOURCES = smokedata.cpp $(x_sources)
+#
+#$(x_sources) smokedata.cpp:
+#	perl generate.pl
+#
+#CLEANFILES = $(libsmokeqt_la_SOURCES)

Added: trunk/smoke/web/Makefile.am
===================================================================
--- trunk/smoke/web/Makefile.am	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/Makefile.am	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,28 @@
+lib_LTLIBRARIES = libsmokeqt.la
+
+# set the include path for X, qt and KDE
+INCLUDES         = -I$(srcdir)/.. $(all_includes) -I$(qt_includes)/QtUiTools \
+                   -I$(qt_includes)/QtDBus
+
+EXTRA_DIST=generate.pl.in qtguess.pl.in qt_smoke.h Makefile.am
+
+# the library search path. 
+libsmokeqt_la_LDFLAGS = -version-info 3:3:2 -no-undefined $(all_libraries) $(GLINC)
+
+# the libraries to link against.
+libsmokeqt_la_LIBADD   = $(LIB_QTCORE) $(LIB_QTGUI) $(LIB_QTNETWORK) \
+						$(LIB_QTOPENGL) $(LIB_QTSQL) $(LIB_QTCORE) $(LIB_QTXML) $(LIB_QTSVG) \
+						$(GLLIB) $(LIBQSCINTILLA) \
+						-lQtSvg -lQtUiTools $(LIBQTDBUS) $(LIBQWT)
+
+x_sources = x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+   x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+   x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp
+
+# which sources should be compiled for perlqtkde
+libsmokeqt_la_SOURCES = smokedata.cpp $(x_sources)
+
+$(x_sources) smokedata.cpp:
+	perl generate.pl
+
+CLEANFILES = $(libsmokeqt_la_SOURCES)

Added: trunk/smoke/web/Makefile.in
===================================================================
--- trunk/smoke/web/Makefile.in	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/Makefile.in	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,621 @@
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+ENABLE_PERMISSIVE_FLAG = @ENABLE_PERMISSIVE_FLAG@
+EXEEXT = @EXEEXT@
+FRAMEWORK_COREAUDIO = @FRAMEWORK_COREAUDIO@
+GLINC = @GLINC@
+GLLIB = @GLLIB@
+HAVE_GCC_VISIBILITY = @HAVE_GCC_VISIBILITY@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+KDE_HAVE_GL = @KDE_HAVE_GL@
+KDE_MT_LDFLAGS = @KDE_MT_LDFLAGS@
+KDE_MT_LIBS = @KDE_MT_LIBS@
+KDE_NO_UNDEFINED = @KDE_NO_UNDEFINED@
+KDE_PLUGIN = @KDE_PLUGIN@
+KDE_USE_CLOSURE_FALSE = @KDE_USE_CLOSURE_FALSE@
+KDE_USE_CLOSURE_TRUE = @KDE_USE_CLOSURE_TRUE@
+KDE_USE_FINAL_FALSE = @KDE_USE_FINAL_FALSE@
+KDE_USE_FINAL_TRUE = @KDE_USE_FINAL_TRUE@
+KDE_USE_FPIE = @KDE_USE_FPIE@
+KDE_USE_NMCHECK_FALSE = @KDE_USE_NMCHECK_FALSE@
+KDE_USE_NMCHECK_TRUE = @KDE_USE_NMCHECK_TRUE@
+KDE_USE_PIE = @KDE_USE_PIE@
+LDFLAGS = @LDFLAGS@
+LDFLAGS_AS_NEEDED = @LDFLAGS_AS_NEEDED@
+LDFLAGS_NEW_DTAGS = @LDFLAGS_NEW_DTAGS@
+LIBCOMPAT = @LIBCOMPAT@
+LIBCRYPT = @LIBCRYPT@
+LIBDL = @LIBDL@
+LIBJPEG = @LIBJPEG@
+LIBOBJS = @LIBOBJS@
+LIBPNG = @LIBPNG@
+LIBPTHREAD = @LIBPTHREAD@
+LIBQSCINTILLA = @LIBQSCINTILLA@
+LIBQTDBUS = @LIBQTDBUS@
+LIBQWT = @LIBQWT@
+LIBRESOLV = @LIBRESOLV@
+LIBS = @LIBS@
+LIBSM = @LIBSM@
+LIBSOCKET = @LIBSOCKET@
+LIBTOOL = @LIBTOOL@
+LIBUCB = @LIBUCB@
+LIBUTIL = @LIBUTIL@
+LIBZ = @LIBZ@
+LIB_KAB = @LIB_KAB@
+LIB_KABC = @LIB_KABC@
+LIB_KDE3SUPPORT = @LIB_KDE3SUPPORT@
+LIB_KDECORE = @LIB_KDECORE@
+LIB_KDED = @LIB_KDED@
+LIB_KDEPIM = @LIB_KDEPIM@
+LIB_KDEPRINT = @LIB_KDEPRINT@
+LIB_KDEUI = @LIB_KDEUI@
+LIB_KDNSSD = @LIB_KDNSSD@
+LIB_KFILE = @LIB_KFILE@
+LIB_KHTML = @LIB_KHTML@
+LIB_KIMPROXY = @LIB_KIMPROXY@
+LIB_KIO = @LIB_KIO@
+LIB_KJS = @LIB_KJS@
+LIB_KNEWSTUFF = @LIB_KNEWSTUFF@
+LIB_KPARTS = @LIB_KPARTS@
+LIB_KSPELL = @LIB_KSPELL@
+LIB_KSPELL2 = @LIB_KSPELL2@
+LIB_KSYCOCA = @LIB_KSYCOCA@
+LIB_KUTILS = @LIB_KUTILS@
+LIB_POLL = @LIB_POLL@
+LIB_QPE = @LIB_QPE@
+LIB_QT = @LIB_QT@
+LIB_QT3SUPPORT = @LIB_QT3SUPPORT@
+LIB_QTCORE = @LIB_QTCORE@
+LIB_QTDESIGNER = @LIB_QTDESIGNER@
+LIB_QTGUI = @LIB_QTGUI@
+LIB_QTNETWORK = @LIB_QTNETWORK@
+LIB_QTOPENGL = @LIB_QTOPENGL@
+LIB_QTSQL = @LIB_QTSQL@
+LIB_QTTESTLIB = @LIB_QTTESTLIB@
+LIB_QTXML = @LIB_QTXML@
+LIB_SMB = @LIB_SMB@
+LIB_X11 = @LIB_X11@
+LIB_XEXT = @LIB_XEXT@
+LIB_XRENDER = @LIB_XRENDER@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MOC = @MOC@
+NOOPT_CFLAGS = @NOOPT_CFLAGS@
+NOOPT_CXXFLAGS = @NOOPT_CXXFLAGS@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PERL = @PERL@
+QTE_NORTTI = @QTE_NORTTI@
+QT_INCLUDES = @QT_INCLUDES@
+QT_LDFLAGS = @QT_LDFLAGS@
+RANLIB = @RANLIB@
+RCC = @RCC@
+RUBY = @RUBY@
+RUBY_ARCHDIR = @RUBY_ARCHDIR@
+RUBY_LIBDIR = @RUBY_LIBDIR@
+RUBY_LIBRUBYARG = @RUBY_LIBRUBYARG@
+RUBY_SITEARCHDIR = @RUBY_SITEARCHDIR@
+RUBY_SITEDIR = @RUBY_SITEDIR@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+TOPSUBDIRS = @TOPSUBDIRS@
+UIC = @UIC@
+UIC3_PATH = @UIC3_PATH@
+UIC_TR = @UIC_TR@
+USER_INCLUDES = @USER_INCLUDES@
+USER_LDFLAGS = @USER_LDFLAGS@
+USE_EXCEPTIONS = @USE_EXCEPTIONS@
+USE_RTTI = @USE_RTTI@
+USE_THREADS = @USE_THREADS@
+VERSION = @VERSION@
+WOVERLOADED_VIRTUAL = @WOVERLOADED_VIRTUAL@
+X_EXTRA_LIBS = @X_EXTRA_LIBS@
+X_INCLUDES = @X_INCLUDES@
+X_LDFLAGS = @X_LDFLAGS@
+X_PRE_LIBS = @X_PRE_LIBS@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+all_includes = @all_includes@
+all_libraries = @all_libraries@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+include_x11_FALSE = @include_x11_FALSE@
+include_x11_TRUE = @include_x11_TRUE@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+kde_build_libsmoke = @kde_build_libsmoke@
+kde_qtver = @kde_qtver@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+qt_includes = @qt_includes@
+qt_libraries = @qt_libraries@
+qt_test_threshold = @qt_test_threshold@
+qtdbus = @qtdbus@
+qtextscintilla = @qtextscintilla@
+qtruby_SUBDIR_included_FALSE = @qtruby_SUBDIR_included_FALSE@
+qtruby_SUBDIR_included_TRUE = @qtruby_SUBDIR_included_TRUE@
+qwt = @qwt@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+smoke_SUBDIR_included_FALSE = @smoke_SUBDIR_included_FALSE@
+smoke_SUBDIR_included_TRUE = @smoke_SUBDIR_included_TRUE@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+unsermake_enable_pch_FALSE = @unsermake_enable_pch_FALSE@
+unsermake_enable_pch_TRUE = @unsermake_enable_pch_TRUE@
+x_includes = @x_includes@
+x_libraries = @x_libraries@
+lib_LTLIBRARIES = libsmokeqt.la
+
+# set the include path for X, qt and KDE
+INCLUDES = -I$(srcdir)/.. $(all_includes) -I$(qt_includes)/QtUiTools \
+                   -I$(qt_includes)/QtDBus
+
+
+EXTRA_DIST = generate.pl.in qtguess.pl.in qt_smoke.h Makefile.am
+
+# the library search path. 
+libsmokeqt_la_LDFLAGS = -version-info 3:3:2 -no-undefined $(all_libraries) $(GLINC)
+
+# the libraries to link against.
+libsmokeqt_la_LIBADD = $(LIB_QTCORE) $(LIB_QTGUI) $(LIB_QTNETWORK) \
+						$(LIB_QTOPENGL) $(LIB_QTSQL) $(LIB_QTCORE) $(LIB_QTXML) $(LIB_QTSVG) \
+						$(GLLIB) $(LIBQSCINTILLA) \
+						-lQtSvg -lQtUiTools $(LIBQTDBUS) $(LIBQWT)
+
+
+x_sources = x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+   x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+   x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp
+
+
+# which sources should be compiled for perlqtkde
+libsmokeqt_la_SOURCES = smokedata.cpp $(x_sources)
+
+CLEANFILES = $(libsmokeqt_la_SOURCES)
+subdir = smoke/qt
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/admin/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES = qtguess.pl generate.pl
+LTLIBRARIES = $(lib_LTLIBRARIES)
+
+libsmokeqt_la_DEPENDENCIES =
+am__objects_1 = x_1.lo x_2.lo x_3.lo x_4.lo x_5.lo x_6.lo x_7.lo x_8.lo \
+	x_9.lo x_10.lo x_11.lo x_12.lo x_13.lo x_14.lo x_15.lo x_16.lo \
+	x_17.lo x_18.lo x_19.lo x_20.lo
+am_libsmokeqt_la_OBJECTS = smokedata.lo $(am__objects_1)
+libsmokeqt_la_OBJECTS = $(am_libsmokeqt_la_OBJECTS)
+
+DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/admin/depcomp
+am__depfiles_maybe = depfiles
+ at AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/smokedata.Plo ./$(DEPDIR)/x_1.Plo \
+ at AMDEP_TRUE@	./$(DEPDIR)/x_10.Plo ./$(DEPDIR)/x_11.Plo \
+ at AMDEP_TRUE@	./$(DEPDIR)/x_12.Plo ./$(DEPDIR)/x_13.Plo \
+ at AMDEP_TRUE@	./$(DEPDIR)/x_14.Plo ./$(DEPDIR)/x_15.Plo \
+ at AMDEP_TRUE@	./$(DEPDIR)/x_16.Plo ./$(DEPDIR)/x_17.Plo \
+ at AMDEP_TRUE@	./$(DEPDIR)/x_18.Plo ./$(DEPDIR)/x_19.Plo \
+ at AMDEP_TRUE@	./$(DEPDIR)/x_2.Plo ./$(DEPDIR)/x_20.Plo \
+ at AMDEP_TRUE@	./$(DEPDIR)/x_3.Plo ./$(DEPDIR)/x_4.Plo \
+ at AMDEP_TRUE@	./$(DEPDIR)/x_5.Plo ./$(DEPDIR)/x_6.Plo \
+ at AMDEP_TRUE@	./$(DEPDIR)/x_7.Plo ./$(DEPDIR)/x_8.Plo \
+ at AMDEP_TRUE@	./$(DEPDIR)/x_9.Plo
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+LTCXXCOMPILE = $(LIBTOOL) --mode=compile $(CXX) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CXXFLAGS) $(CXXFLAGS)
+CXXLD = $(CXX)
+CXXLINK = $(LIBTOOL) --mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+DIST_SOURCES = $(libsmokeqt_la_SOURCES)
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am generate.pl.in \
+	qtguess.pl.in
+SOURCES = $(libsmokeqt_la_SOURCES)
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cpp .lo .o .obj
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  smoke/qt/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+qtguess.pl: $(top_builddir)/config.status qtguess.pl.in
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@
+generate.pl: $(top_builddir)/config.status generate.pl.in
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@
+libLTLIBRARIES_INSTALL = $(INSTALL)
+install-libLTLIBRARIES: $(lib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libdir)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    f="`echo $$p | sed -e 's|^.*/||'`"; \
+	    echo " $(LIBTOOL) --mode=install $(libLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) $$p $(DESTDIR)$(libdir)/$$f"; \
+	    $(LIBTOOL) --mode=install $(libLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) $$p $(DESTDIR)$(libdir)/$$f; \
+	  else :; fi; \
+	done
+
+uninstall-libLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	    p="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(LIBTOOL) --mode=uninstall rm -f $(DESTDIR)$(libdir)/$$p"; \
+	  $(LIBTOOL) --mode=uninstall rm -f $(DESTDIR)$(libdir)/$$p; \
+	done
+
+clean-libLTLIBRARIES:
+	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" = "$$p" && dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsmokeqt.la: $(libsmokeqt_la_OBJECTS) $(libsmokeqt_la_DEPENDENCIES) 
+	$(CXXLINK) -rpath $(libdir) $(libsmokeqt_la_LDFLAGS) $(libsmokeqt_la_OBJECTS) $(libsmokeqt_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT) core *.core
+
+distclean-compile:
+	-rm -f *.tab.c
+
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/smokedata.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_1.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_10.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_11.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_12.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_13.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_14.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_15.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_16.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_17.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_18.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_19.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_2.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_20.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_3.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_4.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_5.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_6.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_7.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_8.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/x_9.Plo at am__quote@
+
+.cpp.o:
+ at am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
+ at am__fastdepCXX_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
+ at am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+ at am__fastdepCXX_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
+ at am__fastdepCXX_TRUE@	fi
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<
+
+.cpp.obj:
+ at am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
+ at am__fastdepCXX_TRUE@	  -c -o $@ `if test -f '$<'; then $(CYGPATH_W) '$<'; else $(CYGPATH_W) '$(srcdir)/$<'; fi`; \
+ at am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+ at am__fastdepCXX_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
+ at am__fastdepCXX_TRUE@	fi
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `if test -f '$<'; then $(CYGPATH_W) '$<'; else $(CYGPATH_W) '$(srcdir)/$<'; fi`
+
+.cpp.lo:
+ at am__fastdepCXX_TRUE@	if $(LTCXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
+ at am__fastdepCXX_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
+ at am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; \
+ at am__fastdepCXX_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
+ at am__fastdepCXX_TRUE@	fi
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	depfile='$(DEPDIR)/$*.Plo' tmpdepfile='$(DEPDIR)/$*.TPlo' @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCXX_FALSE@	$(LTCXXCOMPILE) -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libdir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am: install-libLTLIBRARIES
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libLTLIBRARIES
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libLTLIBRARIES clean-libtool ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am info info-am install \
+	install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am \
+	install-libLTLIBRARIES install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-info-am \
+	uninstall-libLTLIBRARIES
+
+
+$(x_sources) smokedata.cpp:
+	perl generate.pl
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/smoke/web/configure.in.in
===================================================================
--- trunk/smoke/web/configure.in.in	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/configure.in.in	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,200 @@
+
+AC_HAVE_GL
+KDE_HAVE_GL=yes;
+if test "X$GLLIB" = "X"; then
+    KDE_HAVE_GL=no
+fi
+
+AC_SUBST(KDE_HAVE_GL)   
+
+AC_ARG_WITH(
+   threshold,
+   [  --with-threshold@<:@=0..15@:>@  Smoke: Qt tests threshold Default:10 Lower=more tests],
+   [ qt_test_threshold="$withval" ],
+   [ qt_test_threshold=10 ]
+)
+AC_SUBST(qt_test_threshold)
+
+if test "X$kde_build_libsmoke" = "Xqt" -o "X$kde_build_libsmoke" = "Xqt kde"; then
+
+    AC_CONFIG_FILES([ smoke/qt/qtguess.pl ], [
+        cd smoke/qt
+        perl qtguess.pl
+        cd ../..
+    ])
+    AC_CONFIG_FILES([ smoke/qt/generate.pl ], [
+    ])
+fi
+
+dnl -------
+dnl Test for libqscintilla (QScintilla support)
+dnl -------
+
+AC_ARG_ENABLE(
+   qscintilla,
+   [  --enable-qscintilla@<:@=yes|no@:>@   Smoke: build Smoke with QScintilla extention for qt @<:@default:no@:>@],
+   [ qtextscintilla="$enableval" ],
+   [ qtextscintilla="no" ]
+)
+AC_SUBST(qtextscintilla)
+
+AC_DEFUN([AC_FIND_QSCINTILLA],
+[
+AC_MSG_CHECKING([for libqscintilla])
+AC_CACHE_VAL(ac_cv_lib_qscintilla,
+[
+ kde_ldflags_save="$LDFLAGS"
+ kde_libs_save="$LIBS"
+ kde_cxxflags_save="$CXXFLAGS"
+
+ LIBS="-lqscintilla $LIBQT $LIBS"
+ CXXFLAGS="$CXXFLAGS $all_includes"
+ LDFLAGS="$LDFLAGS $all_libraries $USER_LDFLAGS"
+
+AC_TRY_LINK([
+   #include <qextscintillabase.h>
+],
+[
+            QextScintillaBase s;
+],
+            eval "ac_cv_lib_qscintilla='-lqscintilla'",
+            eval "ac_cv_lib_qscintilla=no")
+
+ LDFLAGS=$kde_ldflags_save
+ LIBS=$kde_libs_save
+ CXXFLAGS=$kde_cxxflags_save
+])
+
+if test ! "$ac_cv_lib_qscintilla" = no; then
+  AC_DEFINE_UNQUOTED(HAVE_LIBQSCINTILLA, 1, [Define if you have libqscintilla])
+  LIBQSCINTILLA="$ac_cv_lib_qscintilla"
+  AC_MSG_RESULT($ac_cv_lib_qscintilla)
+else
+  AC_MSG_ERROR(not found. 
+          Check your installation and look into config.log)
+  LIBQSCINTILLA=""
+fi
+AC_SUBST(LIBQSCINTILLA)
+])
+
+if test "X$qtextscintilla" = "Xyes" ; then
+  AC_FIND_QSCINTILLA
+fi
+
+dnl -------
+dnl Test for libQtDBus (D-Bus support)
+dnl -------
+
+AC_ARG_ENABLE(
+   qtdbus,
+   [  --enable-qtdbus@<:@=yes|no@:>@   Smoke: build Smoke with QtDbus extention for qt @<:@default:no@:>@],
+   [ qtdbus="$enableval" ],
+   [ qtdbus="no" ]
+)
+AC_SUBST(qtdbus)
+
+AC_DEFUN([AC_FIND_QTDBUS],
+[
+AC_MSG_CHECKING([for libQtDBus])
+AC_CACHE_VAL(ac_cv_lib_qtdbus,
+[
+AC_LANG_SAVE
+AC_LANG_CPLUSPLUS
+
+ kde_ldflags_save="$LDFLAGS"
+ kde_libs_save="$LIBS"
+ kde_cxxflags_save="$CXXFLAGS"
+
+ LIBS="-ldbus-1 -lQtDBus -ldbus-glib-1 $LIB_QTCORE $LIB_QTXML $LIBS"
+ CXXFLAGS="$CXXFLAGS $all_includes -DDBUS_COMPILATION"
+ LDFLAGS="$LDFLAGS $all_libraries $USER_LDFLAGS"
+
+AC_TRY_LINK([
+   #include <QtDBus/qdbusconnection.h>
+],
+[
+            QDBusConnection b = QDBus::sessionBus();
+],
+            eval "ac_cv_lib_qtdbus='-ldbus-1 -lQtDBus -ldbus-glib-1'",
+            eval "ac_cv_lib_qtdbus=no")
+
+ LDFLAGS=$kde_ldflags_save
+ LIBS=$kde_libs_save
+ CXXFLAGS=$kde_cxxflags_save
+AC_LANG_RESTORE
+])
+
+if test ! "$ac_cv_lib_qtdbus" = no; then
+  AC_DEFINE_UNQUOTED(HAVE_LIBQTDBUS, 1, [Define if you have libdbus-qt4-1])
+  LIBQTDBUS="$ac_cv_lib_qtdbus"
+  AC_MSG_RESULT($ac_cv_lib_qtdbus)
+else
+  AC_MSG_ERROR(not found. 
+          Check your installation and look into config.log)
+  LIBQTDBUS=""
+fi
+AC_SUBST(LIBQTDBUS)
+])
+
+if test "X$qtdbus" = "Xyes" ; then
+  AC_FIND_QTDBUS
+fi
+
+dnl -------
+dnl Test for libqwt (Scientific Plotting library)
+dnl -------
+
+AC_ARG_ENABLE(
+   qwt,
+   [  --enable-qwt@<:@=yes|no@:>@   Smoke: build Smoke with Qwt extention for qt @<:@default:no@:>@],
+   [ qwt="$enableval" ],
+   [ qwt="no" ]
+)
+AC_SUBST(qwt)
+
+AC_DEFUN([AC_FIND_QWT],
+[
+AC_MSG_CHECKING([for libqwt])
+AC_CACHE_VAL(ac_cv_lib_qwt,
+[
+AC_LANG_SAVE
+AC_LANG_CPLUSPLUS
+
+ kde_ldflags_save="$LDFLAGS"
+ kde_libs_save="$LIBS"
+ kde_cxxflags_save="$CXXFLAGS"
+
+ LIBS="-lqwt $LIB_QTCORE $LIB_QTXML $LIBS"
+ CXXFLAGS="$CXXFLAGS $all_includes"
+ LDFLAGS="$LDFLAGS $all_libraries $USER_LDFLAGS"
+
+AC_TRY_LINK([
+   #include <qwt_plot.h>
+],
+[
+            QwtPlot p;
+],
+            eval "ac_cv_lib_qwt='-lqwt'",
+            eval "ac_cv_lib_qwt=no")
+
+ LDFLAGS=$kde_ldflags_save
+ LIBS=$kde_libs_save
+ CXXFLAGS=$kde_cxxflags_save
+AC_LANG_RESTORE
+])
+
+if test ! "$ac_cv_lib_qwt" = no; then
+  AC_DEFINE_UNQUOTED(HAVE_LIBQWT, 1, [Define if you have libqwt])
+  LIBQWT="$ac_cv_lib_qwt"
+  AC_MSG_RESULT($ac_cv_lib_qwt)
+else
+  AC_MSG_ERROR(not found. 
+          Check your installation and look into config.log)
+  LIBQWT=""
+fi
+AC_SUBST(LIBQWT)
+])
+
+if test "X$qwt" = "Xyes" ; then
+  AC_FIND_QWT
+fi

Added: trunk/smoke/web/generate.pl.cmake
===================================================================
--- trunk/smoke/web/generate.pl.cmake	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/generate.pl.cmake	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,254 @@
+#!/usr/bin/perl -w
+
+## Run this first, to generate the x_*.cpp files from the Qt headers
+## using kalyptus
+
+my $kalyptusdir = "@CMAKE_CURRENT_SOURCE_DIR@/../../kalyptus";
+
+use File::Basename;
+use File::Copy qw|cp|;
+use File::Compare;
+use File::Find;
+use Cwd;
+
+my $here = getcwd;
+my $outdir = $here . "/generate.pl.tmpdir";
+my $finaloutdir = $here;
+my $defines = "qtdefines";
+my $headerlist = "@CMAKE_CURRENT_SOURCE_DIR@/header_list";
+my $definespath = "$here/$defines";
+my $headerlistpath = "$headerlist";
+my $qscintilla_headerlist = "";
+my $qscintilla_headerlistpath = "";
+my $qtdbus_headerlist = "";
+my $qtdbus_headerlistpath = "";
+
+if("@QSCINTILLA_FOUND@" eq "YES")
+{
+ $qscintilla_headerlist = "@CMAKE_CURRENT_SOURCE_DIR@/qscintilla2_header_list";
+ $qscintilla_headerlistpath = "$here/$qscintilla_headerlist";
+}
+
+if("@QT_QTDBUS_FOUND@" eq "1")
+{
+ $qtdbus_headerlist = "@CMAKE_CURRENT_SOURCE_DIR@/qtdbus_header_list";
+ $qtdbus_headerlistpath = "$here/$qtdbus_headerlist";
+}
+
+if("@QWT_FOUND@" eq "YES")
+{
+ $qwt_headerlist = "@CMAKE_CURRENT_SOURCE_DIR@/qwt_header_list";
+ $qwt_headerlistpath = "$here/$qwt_headerlist";
+}
+
+## If srcdir != builddir, use headerlist from src
+$headerlistpath = $headerlist if ($headerlist =~ /^\//);
+if("@QSCINTILLA_FOUND@" eq "YES")
+{
+ $qscintilla_headerlistpath = $qscintilla_headerlist if ($qscintilla_headerlist =~ /^\//);
+}
+
+if("@QT_QTDBUS_FOUND@" eq "1")
+{
+ $qtdbus_headerlistpath = $qtdbus_headerlist if ($qtdbus_headerlist =~ /^\//);
+}
+
+if("@QWT_FOUND@" eq "YES")
+{
+ $qwt_headerlistpath = $qwt_headerlist if ($qwt_headerlist =~ /^\//);
+}
+## Note: outdir and finaloutdir should NOT be the same dir!
+
+# Delete all x_*.cpp files under outdir (or create outdir if nonexistent)
+if (-d $outdir) { system "rm -f $outdir/x_*.cpp"; } else { mkdir $outdir; }
+
+mkdir $finaloutdir unless (-d $finaloutdir);
+
+#  Load the QT_NO_* macros found in "qtdefines". They'll be passed to kalyptus
+my $macros="";
+if ( -e $definespath ){
+    print "Found '$defines'. Reading preprocessor symbols from there...\n";
+    $macros = " --defines=$definespath ";
+}
+
+mkdir $kalyptusdir, 0777;
+# Need to cd to kalyptus's directory so that perl finds Ast.pm etc.
+chdir "$kalyptusdir" or die "Couldn't go to $kalyptusdir (edit script to change dir)\n";
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %excludes = (
+    'qaccessible.h' => 1,  # Accessibility support is not compiled by defaut
+    'qassistantclient.h' => 1, # Not part of Qt (introduced in Qt-3.1)
+    'qmotif.h' => 1,       # 
+    'qmotifwidget.h' => 1, # Motif extension (introduced in Qt-3.1)
+    'qmotifdialog.h' => 1, #
+    'qxt.h' => 1, # Xt
+    'qxtwidget.h' => 1, # Xt
+    'qdns.h' => 1, # internal
+    'qgl.h' => 1, # OpenGL
+    'qglcolormap.h' => 1, # OpenGL
+    'qnp.h' => 1, # NSPlugin
+    'qttableview.h' => 1,  # Not in Qt anymore...
+    'qtmultilineedit.h' => 1,  # Not in Qt anymore...
+    'qwidgetfactory.h' => 1,  # Just an interface
+    'qsharedmemory.h' => 1, # "not part of the Qt API" they say
+    'qwindowsstyle.h' => 1, # Qt windowsstyle, plugin
+    'qmotifstyle.h' => 1,
+    'qcompactstyle.h' => 1,
+    'qinterlacestyle.h' => 1,
+    'qmotifplusstyle.h' => 1,
+    'qsgistyle.h' => 1,
+    'qplatinumstyle.h' => 1,
+    'qcdestyle.h' => 1,
+	 'qworkspace.h' => 1,
+    'qwindowsxpstyle.h' => 1 # play on the safe side 
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %includes;
+open(HEADERS, $headerlistpath) or die "Couldn't open $headerlistpath: $!\n";
+map { chomp ; $includes{$_} = 1 } <HEADERS>;
+close HEADERS;
+
+if("@QSCINTILLA_FOUND@" eq "YES")
+{
+ open(HEADERS, $qscintilla_headerlistpath) or die "Couldn't open $qscintilla_headerlistpath: $!\n";
+ map { chomp ; $includes{$_} = 1 } <HEADERS>;
+ close HEADERS;
+}
+
+if("@QT_QTDBUS_FOUND@" eq "1")
+{
+ open(HEADERS, $qtdbus_headerlistpath) or die "Couldn't open $qtdbus_headerlistpath: $!\n";
+ map { chomp ; $includes{$_} = 1 } <HEADERS>;
+ close HEADERS;
+}
+
+my %qwt_includes;
+if("@QWT_FOUND@" eq "YES")
+{
+ open(HEADERS, $qwt_headerlistpath) or die "Couldn't open $qwt_headerlistpath: $!\n";
+ map { chomp ; $qwt_includes{$_} = 1 } <HEADERS>;
+ close HEADERS;
+}
+ 
+# Can we compile the OpenGl module ?
+if("@QT_OPENGL_FOUND@" eq "YES")
+{
+    open(DEFS, $definespath);
+    my @defs = <DEFS>;
+    close DEFS;
+    if(!grep(/QT_NO_OPENGL/, @defs))
+    {
+      $excludes{'qgl.h'} = undef;
+      $excludes{'qglcolormap.h'} = undef;
+    }
+    else
+    {
+      print STDERR "Qt was not compiled with OpenGL support...\n Skipping QGL Classes.\n";
+    }
+}
+
+# List Qt headers, and exclude the ones listed above
+my @headers = ();
+
+$qtinc= '@QT_INCLUDE_DIR@';
+
+find(
+    {   wanted => sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qtinc);
+                if( !defined $excludes{$f} # Not excluded
+                     && $includes{$f}        # Known header
+                     && /\.h$/)     # Not a backup file etc. Only headers.
+                {
+                    my $header = $_;
+                    open(FILE, $_);
+                    my @header_lines = <FILE>;
+                    if (@header_lines == 1) {
+                        $line = $header_lines[0];
+                        if ($line =~ /^#include "(.*)"/) {
+                            push ( @headers, $qtinc . substr($1, 2) );
+                        } else {
+                            push ( @headers, $header );
+                        }
+                    } else {
+                        push ( @headers, $header );
+                    }
+                }
+	    	undef $includes{$f}   
+	     };
+	},
+	follow_fast => 1,
+	follow_skip => 2,
+	no_chdir => 1
+    }, $qtinc
+ );
+
+$qwtinc = '@QWT_INCLUDE_DIR@';
+
+find(
+    {   wanted => sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qwtinc);
+		push ( @headers, $_ )
+                if( !defined $excludes{$f} # Not excluded
+                     && $qwt_includes{$f}        # Known header
+                     && /\.h$/);     # Not a backup file etc. Only headers.
+	    	undef $qwt_includes{$f}   
+	     };
+	},
+	follow_fast => 1,
+	follow_skip => 2,
+	no_chdir => 1
+    }, $qwtinc
+ );
+ 
+# Launch kalyptus
+chdir "../smoke/web";
+system "perl -I at kdebindings_SOURCE_DIR@/kalyptus @kdebindings_SOURCE_DIR@/kalyptus/kalyptus @ARGV --qt4 --globspace -fwebsmoke --name=qt $macros --no-cache --outputdir=$outdir @headers";
+my $exit = $? >> 8;
+exit $exit if ($exit);
+chdir "$kalyptusdir";
+
+# Generate diff for smokedata.cpp
+unless ( -e "$finaloutdir/smokedata.cpp" ) {
+    open( TOUCH, ">$finaloutdir/smokedata.cpp");
+    close TOUCH;
+}
+system "diff -u $finaloutdir/smokedata.cpp $outdir/smokedata.cpp > $outdir/smokedata.cpp.diff";
+
+# Copy changed or new files to finaloutdir
+opendir (OUT, $outdir) or die "Couldn't opendir $outdir";
+foreach $filename (readdir(OUT)) {
+    next if ( -d "$outdir/$filename" ); # only files, not dirs
+    my $docopy = 1;
+    if ( -f "$finaloutdir/$filename" ) {
+        $docopy = compare("$outdir/$filename", "$finaloutdir/$filename"); # 1 if files are differents
+    }
+    if ($docopy) {
+	#print STDERR "Updating $filename...\n";
+	cp("$outdir/$filename", "$finaloutdir/$filename");
+    }
+}
+closedir OUT;
+
+# Check for deleted files and warn
+my $deleted = 0;
+opendir(FINALOUT, $finaloutdir) or die "Couldn't opendir $finaloutdir";
+foreach $filename (readdir(FINALOUT)) {
+    next if ( -d "$finaloutdir/$filename" ); # only files, not dirs
+    if ( $filename =~ /.cpp$/ && ! ($filename =~ /_la_closure.cpp/) && ! -f "$outdir/$filename" ) {
+      print STDERR "Removing obsolete file $filename\n";
+      unlink "$finaloutdir/$filename";
+      $deleted = 1;
+    }
+}
+closedir FINALOUT;
+
+# Delete outdir
+system "rm -rf $outdir";
+

Added: trunk/smoke/web/generate.pl.in
===================================================================
--- trunk/smoke/web/generate.pl.in	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/generate.pl.in	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,220 @@
+#!/usr/bin/perl -w
+
+## Run this first, to generate the x_*.cpp files from the Qt headers
+## using kalyptus
+
+my $kalyptusdir = "../../kalyptus";
+
+use File::Basename;
+use File::Copy qw|cp|;
+use File::Compare;
+use File::Find;
+use Cwd;
+
+my $here = getcwd;
+my $outdir = $here . "/generate.pl.tmpdir";
+my $finaloutdir = $here;
+my $defines = "qtdefines";
+my $headerlist = "@srcdir@/header_list";
+my $definespath = "$here/$defines";
+my $headerlistpath = "$here/$headerlist";
+my $qscintilla_headerlist = "";
+my $qscintilla_headerlistpath = "";
+my $qtdbus_headerlist = "";
+my $qtdbus_headerlistpath = "";
+
+if("@qtextscintilla@" eq "yes")
+{
+ $qscintilla_headerlist = "./qscintilla_header_list";
+ $qscintilla_headerlistpath = "$here/$qscintilla_headerlist";
+}
+
+if("@qtdbus@" eq "yes")
+{
+ $qtdbus_headerlist = "./qtdbus_header_list";
+ $qtdbus_headerlistpath = "$here/$qtdbus_headerlist";
+}
+
+if("@qwt@" eq "yes")
+{
+ $qwt_headerlist = "./qwt_header_list";
+ $qwt_headerlistpath = "$here/$qwt_headerlist";
+}
+
+## If srcdir != builddir, use headerlist from src
+$headerlistpath = $headerlist if ($headerlist =~ /^\//);
+if("@qtextscintilla@" eq "yes")
+{
+ $qscintilla_headerlistpath = $qscintilla_headerlist if ($qscintilla_headerlist =~ /^\//);
+}
+
+if("@qtdbus@" eq "yes")
+{
+ $qtdbus_headerlistpath = $qtdbus_headerlist if ($qtdbus_headerlist =~ /^\//);
+}
+
+if("@qwt@" eq "yes")
+{
+ $qwt_headerlistpath = $qwt_headerlist if ($qwt_headerlist =~ /^\//);
+}
+## Note: outdir and finaloutdir should NOT be the same dir!
+
+# Delete all x_*.cpp files under outdir (or create outdir if nonexistent)
+if (-d $outdir) { system "rm -f $outdir/x_*.cpp"; } else { mkdir $outdir; }
+
+mkdir $finaloutdir unless (-d $finaloutdir);
+
+#  Load the QT_NO_* macros found in "qtdefines". They'll be passed to kalyptus
+my $macros="";
+if ( -e $definespath ){
+    print "Found '$defines'. Reading preprocessor symbols from there...\n";
+    $macros = " --defines=$definespath ";
+}
+
+mkdir $kalyptusdir, 0777;
+# Need to cd to kalyptus's directory so that perl finds Ast.pm etc.
+chdir "$kalyptusdir" or die "Couldn't go to $kalyptusdir (edit script to change dir)\n";
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %excludes = (
+    'qaccessible.h' => 1,  # Accessibility support is not compiled by defaut
+    'qassistantclient.h' => 1, # Not part of Qt (introduced in Qt-3.1)
+    'qmotif.h' => 1,       # 
+    'qmotifwidget.h' => 1, # Motif extension (introduced in Qt-3.1)
+    'qmotifdialog.h' => 1, #
+    'qxt.h' => 1, # Xt
+    'qxtwidget.h' => 1, # Xt
+    'qdns.h' => 1, # internal
+    'qgl.h' => 1, # OpenGL
+    'qglcolormap.h' => 1, # OpenGL
+    'qnp.h' => 1, # NSPlugin
+    'qttableview.h' => 1,  # Not in Qt anymore...
+    'qtmultilineedit.h' => 1,  # Not in Qt anymore...
+    'qwidgetfactory.h' => 1,  # Just an interface
+    'qsharedmemory.h' => 1, # "not part of the Qt API" they say
+    'qwindowsstyle.h' => 1, # Qt windowsstyle, plugin
+    'qmotifstyle.h' => 1,
+    'qcompactstyle.h' => 1,
+    'qinterlacestyle.h' => 1,
+    'qmotifplusstyle.h' => 1,
+    'qsgistyle.h' => 1,
+    'qplatinumstyle.h' => 1,
+    'qcdestyle.h' => 1,
+	 'qworkspace.h' => 1,
+    'qwindowsxpstyle.h' => 1 # play on the safe side 
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %includes;
+open(HEADERS, $headerlistpath) or die "Couldn't open $headerlistpath: $!\n";
+map { chomp ; $includes{$_} = 1 } <HEADERS>;
+close HEADERS;
+
+if("@qtextscintilla@" eq "yes")
+{
+ open(HEADERS, $qscintilla_headerlistpath) or die "Couldn't open $qscintilla_headerlistpath: $!\n";
+ map { chomp ; $includes{$_} = 1 } <HEADERS>;
+ close HEADERS;
+}
+
+if("@qtdbus@" eq "yes")
+{
+ open(HEADERS, $qtdbus_headerlistpath) or die "Couldn't open $qtdbus_headerlistpath: $!\n";
+ map { chomp ; $includes{$_} = 1 } <HEADERS>;
+ close HEADERS;
+}
+
+if("@qwt@" eq "yes")
+{
+ open(HEADERS, $qwt_headerlistpath) or die "Couldn't open $qwt_headerlistpath: $!\n";
+ map { chomp ; $includes{$_} = 1 } <HEADERS>;
+ close HEADERS;
+}
+ 
+# Can we compile the OpenGl module ?
+if("@KDE_HAVE_GL@" eq "yes")
+{
+    open(DEFS, $definespath);
+    my @defs = <DEFS>;
+    close DEFS;
+    if(!grep(/QT_NO_OPENGL/, @defs))
+    {
+      $excludes{'qgl.h'} = undef;
+      $excludes{'qglcolormap.h'} = undef;
+    }
+    else
+    {
+      print STDERR "Qt was not compiled with OpenGL support...\n Skipping QGL Classes.\n";
+    }
+}
+
+# List Qt headers, and exclude the ones listed above
+my @headers = ();
+
+$qtinc= '@qt_includes@';
+
+find(
+    {   wanted => sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qtinc);
+                push ( @headers, $_ )
+	    	  if( !defined $excludes{$f} # Not excluded
+	    	     && $includes{$f}        # Known header
+	    	     && /\.h$/);     # Not a backup file etc. Only headers.
+	    	undef $includes{$f}   
+	     };
+	},
+	follow_fast => 1,
+	follow_skip => 2,
+	no_chdir => 1
+    }, $qtinc
+ );
+
+# Launch kalyptus
+chdir "../smoke/qt";
+system "perl -I at top_srcdir@/kalyptus @top_srcdir@/kalyptus/kalyptus @ARGV --qt4 --globspace -fsmoke --name=qt $macros --no-cache --outputdir=$outdir @headers";
+my $exit = $? >> 8;
+exit $exit if ($exit);
+chdir "$kalyptusdir";
+
+# Generate diff for smokedata.cpp
+unless ( -e "$finaloutdir/smokedata.cpp" ) {
+    open( TOUCH, ">$finaloutdir/smokedata.cpp");
+    close TOUCH;
+}
+system "diff -u $finaloutdir/smokedata.cpp $outdir/smokedata.cpp > $outdir/smokedata.cpp.diff";
+
+# Copy changed or new files to finaloutdir
+opendir (OUT, $outdir) or die "Couldn't opendir $outdir";
+foreach $filename (readdir(OUT)) {
+    next if ( -d "$outdir/$filename" ); # only files, not dirs
+    my $docopy = 1;
+    if ( -f "$finaloutdir/$filename" ) {
+        $docopy = compare("$outdir/$filename", "$finaloutdir/$filename"); # 1 if files are differents
+    }
+    if ($docopy) {
+	#print STDERR "Updating $filename...\n";
+	cp("$outdir/$filename", "$finaloutdir/$filename");
+    }
+}
+closedir OUT;
+
+# Check for deleted files and warn
+my $deleted = 0;
+opendir(FINALOUT, $finaloutdir) or die "Couldn't opendir $finaloutdir";
+foreach $filename (readdir(FINALOUT)) {
+    next if ( -d "$finaloutdir/$filename" ); # only files, not dirs
+    if ( $filename =~ /.cpp$/ && ! ($filename =~ /_la_closure.cpp/) && ! -f "$outdir/$filename" ) {
+      print STDERR "Removing obsolete file $filename\n";
+      unlink "$finaloutdir/$filename";
+      $deleted = 1;
+    }
+}
+closedir FINALOUT;
+
+# Delete outdir
+system "rm -rf $outdir";
+

Added: trunk/smoke/web/generate_makefile_am.pl
===================================================================
--- trunk/smoke/web/generate_makefile_am.pl	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/generate_makefile_am.pl	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,55 @@
+#!/usr/bin/perl -w
+
+use File::Basename;
+
+my $here = `pwd`;
+chomp $here;
+my $outdir = $here;
+my $tempfile = "$outdir/.Makefile.am.tmpfile";
+
+# Update list of source files in $outdir/Makefile.am
+open( MAKEFILE, "<$outdir/Makefile.am" ) or die;
+my $makeFileData = '';
+my $found = 0;
+while (<MAKEFILE>) {
+	if (/^libsmokeqt_la_SOURCES/)
+	{
+		$found = 1;
+		$makeFileData .= "libsmokeqt_la_SOURCES = smokedata.cpp";
+	}
+	$makeFileData .= $_ if (!$found);
+}
+close MAKEFILE;
+
+die "libsmokeqt_la_SOURCES not found" if (!$found);
+
+open( MAKEFILE, ">$tempfile" ) or die;
+print MAKEFILE $makeFileData;
+
+my $count = 0;
+opendir (FILES, $outdir) or die;
+foreach $filename (readdir(FILES)) {
+	if ( $filename =~ /^x_.*\.cpp$/ ) {
+		if ( $count++ == 7 ) {
+			$count = 0;
+			print MAKEFILE " \\\n";
+		}
+		print MAKEFILE " $filename";
+	}
+}
+
+print MAKEFILE "\n";
+close MAKEFILE;
+closedir FILES;
+
+system "cmp -s $tempfile $outdir/Makefile.am";
+if ($? >> 8) {
+    system "cp -f $tempfile $outdir/Makefile.am";
+    print STDERR "Makefile.am updated.\n";
+}
+else {
+    print STDERR "Makefile.am unchanged.\n";
+}
+system "rm -f $tempfile";
+
+exit 0;


Property changes on: trunk/smoke/web/generate_makefile_am.pl
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/smoke/web/header_list
===================================================================
--- trunk/smoke/web/header_list	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/header_list	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,299 @@
+QtCore/qabstracteventdispatcher.h
+QtCore/qabstractfileengine.h
+QtCore/qabstractitemmodel.h
+QtCore/qalgorithms.h
+QtCore/qbasictimer.h
+QtCore/qbitarray.h
+QtCore/qbuffer.h
+QtCore/qbytearray.h
+QtCore/qbytearraymatcher.h
+QtCore/qcache.h
+QtCore/qchar.h
+QtCore/qconfig-dist.h
+QtCore/qconfig.h
+QtCore/qconfig-large.h
+QtCore/qconfig-medium.h
+QtCore/qconfig-minimal.h
+QtCore/qconfig-small.h
+QtCore/qcoreapplication.h
+QtCore/qcoreevent.h
+QtCore/qdatastream.h
+QtCore/qdatetime.h
+QtCore/qdebug.h
+QtCore/qdir.h
+QtCore/qeventloop.h
+QtCore/qfactoryinterface.h
+QtCore/qfeatures.h
+QtCore/qfile.h
+QtCore/qfileinfo.h
+QtCore/qfilesystemwatcher.h
+QtCore/qfsfileengine.h
+QtCore/qglobal.h
+QtCore/qiodevice.h
+QtCore/qiterator.h
+QtCore/qlibrary.h
+QtCore/qlibraryinfo.h
+QtCore/qline.h
+QtCore/qlocale.h
+QtCore/qmap.h
+QtCore/qmetaobject.h
+QtCore/qmetatype.h
+QtCore/qmimedata.h
+QtCore/qmutex.h
+QtCore/qnamespace.h
+QtCore/qobjectcleanuphandler.h
+QtCore/qobjectdefs.h
+QtCore/qobject.h
+QtCore/qpair.h
+QtCore/qplugin.h
+QtCore/qpluginloader.h
+QtCore/qpointer.h
+QtCore/qpoint.h
+QtCore/qprocess.h
+QtCore/qqueue.h
+QtCore/qreadwritelock.h
+QtCore/qrect.h
+QtCore/qregexp.h
+QtCore/qsemaphore.h
+QtCore/qsettings.h
+QtCore/qshareddata.h
+QtCore/qsignalmapper.h
+QtCore/qsize.h
+QtCore/qsocketnotifier.h
+QtCore/qstack.h
+QtCore/qstring.h
+QtCore/qstringlist.h
+QtCore/qstringmatcher.h
+QtCore/qtemporaryfile.h
+QtCore/qtextcodec.h
+QtCore/qtextcodecplugin.h
+QtCore/qtextstream.h
+QtCore/qthread.h
+QtCore/qthreadstorage.h
+QtCore/qtimeline.h
+QtCore/qtimer.h
+QtCore/qtranslator.h
+QtCore/qurl.h
+QtCore/quuid.h
+QtCore/qvariant.h
+QtCore/qvarlengtharray.h
+QtCore/qvector.h
+QtCore/qwaitcondition.h
+QtGui/qabstractbutton.h
+QtGui/qabstractitemdelegate.h
+QtGui/qabstractitemview.h
+QtGui/qabstractpagesetupdialog.h
+QtGui/qabstractprintdialog.h
+QtGui/qabstractproxymodel.h
+QtGui/qabstractscrollarea.h
+QtGui/qabstractslider.h
+QtGui/qabstractspinbox.h
+QtGui/qabstracttextdocumentlayout.h
+QtGui/qaccessiblebridge.h
+QtGui/qaccessible.h
+QtGui/qaccessibleobject.h
+QtGui/qaccessibleplugin.h
+QtGui/qaccessiblewidget.h
+QtGui/qactiongroup.h
+QtGui/qaction.h
+QtGui/qapplication.h
+QtGui/qbitmap.h
+QtGui/qboxlayout.h
+QtGui/qbrush.h
+QtGui/qbuttongroup.h
+QtGui/qcalendarwidget.h
+QtGui/qcheckbox.h
+QtGui/qcleanlooksstyle.h
+QtGui/qclipboard.h
+QtGui/qcolordialog.h
+QtGui/qcolor.h
+QtGui/qcolormap.h
+QtGui/qcombobox.h
+QtGui/qcommonstyle.h
+QtGui/qcompleter.h
+QtGui/qcursor.h
+QtGui/qdatawidgetmapper.h
+QtGui/qdatetimeedit.h
+QtGui/qdesktopservices.h
+QtGui/qdesktopwidget.h
+QtGui/qdial.h
+QtGui/qdialogbuttonbox.h
+QtGui/qdialog.h
+QtGui/qdirmodel.h
+QtGui/qdockwidget.h
+QtGui/qdrag.h
+QtGui/qdrawutil.h
+QtGui/qerrormessage.h
+QtGui/qevent.h
+QtGui/qfiledialog.h
+QtGui/qfocusframe.h
+QtGui/qfontcombobox.h
+QtGui/qfontdatabase.h
+QtGui/qfontdialog.h
+QtGui/qfont.h
+QtGui/qfontinfo.h
+QtGui/qfontmetrics.h
+QtGui/qframe.h
+QtGui/qgraphicsitemanimation.h
+QtGui/qgraphicsitem.h
+QtGui/qgraphicssceneevent.h
+QtGui/qgraphicsscene.h
+QtGui/qgraphicsview.h
+QtGui/qgridlayout.h
+QtGui/qgroupbox.h
+QtGui/qhboxlayout.h
+QtGui/qheaderview.h
+QtGui/qiconengine.h
+QtGui/qiconengineplugin.h
+QtGui/qicon.h
+QtGui/qimage.h
+QtGui/qimageiohandler.h
+QtGui/qimagereader.h
+QtGui/qimagewriter.h
+QtGui/qinputcontextfactory.h
+QtGui/qinputcontext.h
+QtGui/qinputcontextplugin.h
+QtGui/qinputdialog.h
+QtGui/qitemdelegate.h
+QtGui/qitemeditorfactory.h
+QtGui/qitemselectionmodel.h
+QtGui/qkeysequence.h
+QtGui/qlabel.h
+QtGui/qlayout.h
+QtGui/qlayoutitem.h
+QtGui/qlcdnumber.h
+QtGui/qlineedit.h
+QtGui/qlistview.h
+QtGui/qlistwidget.h
+QtGui/qmacstyle.h
+QtGui/qmainwindow.h
+QtGui/qmatrix.h
+QtGui/qmenubar.h
+QtGui/qmenudata.h
+QtGui/qmenu.h
+QtGui/qmessageboxex.h
+QtGui/qmessagebox.h
+QtGui/qmime.h
+QtGui/qmovie.h
+QtGui/qpagesetupdialog.h
+QtGui/qpaintdevice.h
+QtGui/qpaintengine.h
+QtGui/qpainter.h
+QtGui/qpainterpath.h
+QtGui/qpalette.h
+QtGui/qpen.h
+QtGui/qpictureformatplugin.h
+QtGui/qpicture.h
+QtGui/qpixmapcache.h
+QtGui/qpixmap.h
+QtGui/qplastiquestyle.h
+QtGui/qpolygon.h
+QtGui/qprintdialog.h
+QtGui/qprintengine.h
+QtGui/qprinter.h
+QtGui/qprogressbar.h
+QtGui/qprogressdialog.h
+QtGui/qproxymodel.h
+QtGui/qpushbutton.h
+QtGui/qradiobutton.h
+QtGui/qregion.h
+QtGui/qrgb.h
+QtGui/qrubberband.h
+QtGui/qscrollarea.h
+QtGui/qscrollbar.h
+QtGui/qsessionmanager.h
+QtGui/qshortcut.h
+QtGui/qsizegrip.h
+QtGui/qsizepolicy.h
+QtGui/qslider.h
+QtGui/qsortfilterproxymodel.h
+QtGui/qsound.h
+QtGui/qspinbox.h
+QtGui/qsplashscreen.h
+QtGui/qsplitter.h
+QtGui/qstackedlayout.h
+QtGui/qstackedwidget.h
+QtGui/qstandarditemmodel.h
+QtGui/qstatusbar.h
+QtGui/qstringlistmodel.h
+QtGui/qstylefactory.h
+QtGui/qstyle.h
+QtGui/qstyleoption.h
+QtGui/qstylepainter.h
+QtGui/qstyleplugin.h
+QtGui/qsyntaxhighlighter.h
+QtGui/qsystemtrayicon.h
+QtGui/qtabbar.h
+QtGui/qtableview.h
+QtGui/qtablewidget.h
+QtGui/qtabwidget.h
+QtGui/qtextbrowser.h
+QtGui/qtextcursor.h
+QtGui/qtextdocumentfragment.h
+QtGui/qtextdocument.h
+QtGui/qtextedit.h
+QtGui/qtextformat.h
+QtGui/qtextlayout.h
+QtGui/qtextlist.h
+QtGui/qtextobject.h
+QtGui/qtextoption.h
+QtGui/qtexttable.h
+QtGui/qtoolbar.h
+QtGui/qtoolbox.h
+QtGui/qtoolbutton.h
+QtGui/qtooltip.h
+QtGui/qtreeview.h
+QtGui/qtreewidget.h
+QtGui/qtreewidgetitemiterator.h
+QtGui/qundogroup.h
+QtGui/qundostack.h
+QtGui/qundoview.h
+QtGui/qvalidator.h
+QtGui/qvboxlayout.h
+QtGui/qvfbhdr.h
+QtGui/qwhatsthis.h
+QtGui/qwidgetaction.h
+QtGui/qwidget.h
+QtGui/qwindowdefs.h
+QtGui/qwindowsstyle.h
+QtGui/qwindowsxpstyle.h
+QtGui/qwmatrix.h
+QtGui/qworkspace.h
+QtGui/qx11embed_x11.h
+QtGui/qx11info_x11.h
+QtNetwork/qabstractsocket.h
+QtNetwork/qftp.h
+QtNetwork/qhostaddress.h
+QtNetwork/qhostinfo.h
+QtNetwork/qhttp.h
+QtNetwork/qnetworkinterface.h
+QtNetwork/qnetworkproxy.h
+QtNetwork/qtcpserver.h
+QtNetwork/qtcpsocket.h
+QtNetwork/qudpsocket.h
+QtNetwork/qurlinfo.h
+QtOpenGL/qglcolormap.h
+QtOpenGL/qglframebufferobject.h
+QtOpenGL/qgl.h
+QtOpenGL/qglpixelbuffer.h
+Qt/qiconset.h
+QtSql/qsqldatabase.h
+QtSql/qsqldriver.h
+QtSql/qsqldriverplugin.h
+QtSql/qsqlerror.h
+QtSql/qsqlfield.h
+QtSql/qsql.h
+QtSql/qsqlindex.h
+QtSql/qsqlquery.h
+QtSql/qsqlquerymodel.h
+QtSql/qsqlrecord.h
+QtSql/qsqlrelationaldelegate.h
+QtSql/qsqlrelationaltablemodel.h
+QtSql/qsqlrelation.h
+QtSql/qsqlresult.h
+QtSql/qsqltablemodel.h
+QtSvg/qsvgrenderer.h
+QtSvg/qsvgwidget.h
+QtUiTools/quiloader.h
+QtXml/qdom.h
+QtXml/qxml.h

Added: trunk/smoke/web/hint_header_list.pl
===================================================================
--- trunk/smoke/web/hint_header_list.pl	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/hint_header_list.pl	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,23 @@
+
+# CVS admin : run this script to compare the set of Qt headers to
+#             the actual content of header_list
+
+$l = "header_list";
+$q = $ENV{'QTDIR'} || die "QTDIR not set\n";
+ at h = <$q/include/*.h>;
+grep s|.*/(.*\.h)|$1|, @h;
+open(IN, $l) or die "$!: $l\n";
+ at old = <IN>;
+chomp @old;
+map{ $h{$_}++ } @h;
+map{ $old{$_}++ } @old;
+map{ $diff{$_}++ unless $old{$_} } keys %h; 
+map{ delete $diff{$_} if /^qconfig.*/ or !/^q/ } keys %diff;
+print "Check if any of the following headers should be added to $l:\n\n";
+print join "\n", keys %diff,  "\n"
+
+
+
+
+
+

Added: trunk/smoke/web/qscintilla2_header_list
===================================================================
--- trunk/smoke/web/qscintilla2_header_list	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qscintilla2_header_list	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,30 @@
+Qsci/qsciapis.h
+Qsci/qscicommand.h
+Qsci/qscicommandset.h
+Qsci/qscidocument.h
+Qsci/qsciglobal.h
+Qsci/qscilexerbash.h
+Qsci/qscilexerbatch.h
+Qsci/qscilexercpp.h
+Qsci/qscilexercsharp.h
+Qsci/qscilexercss.h
+Qsci/qscilexerdiff.h
+Qsci/qscilexer.h
+Qsci/qscilexerhtml.h
+Qsci/qscilexeridl.h
+Qsci/qscilexerjava.h
+Qsci/qscilexerjavascript.h
+Qsci/qscilexerlua.h
+Qsci/qscilexermakefile.h
+Qsci/qscilexerperl.h
+Qsci/qscilexerpov.h
+Qsci/qscilexerproperties.h
+Qsci/qscilexerpython.h
+Qsci/qscilexerruby.h
+Qsci/qscilexersql.h
+Qsci/qscilexertex.h
+Qsci/qscimacro.h
+Qsci/qscintilla2_header_list
+Qsci/qsciprinter.h
+Qsci/qsciscintillabase.h
+Qsci/qsciscintilla.h

Added: trunk/smoke/web/qscintilla_header_list
===================================================================
--- trunk/smoke/web/qscintilla_header_list	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qscintilla_header_list	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,22 @@
+qextscintilla.h
+qextscintillaapis.h
+qextscintillabase.h
+qextscintillacommand.h
+qextscintillacommandset.h
+qextscintilladocument.h
+qextscintillaglobal.h
+qextscintillalexer.h
+qextscintillalexerbash.h
+qextscintillalexercpp.h
+qextscintillalexercsharp.h
+qextscintillalexerhtml.h
+qextscintillalexeridl.h
+qextscintillalexerjava.h
+qextscintillalexerjavascript.h
+qextscintillalexerlua.h
+qextscintillalexerperl.h
+qextscintillalexerpython.h
+qextscintillalexerruby.h
+qextscintillalexersql.h
+qextscintillamacro.h
+qextscintillaprinter.h

Added: trunk/smoke/web/qt_smoke.h
===================================================================
--- trunk/smoke/web/qt_smoke.h	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qt_smoke.h	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,12 @@
+#ifndef QT_SMOKE_H
+#define QT_SMOKE_H
+
+// Don't use kdemacros.h/KDE_EXPORT here as it needs to be free of KDE dependencies
+#include <QtCore/qglobal.h>
+// Defined in smokedata.cpp, initialized by init_qt_Smoke(), used by all .cpp files
+extern Q_DECL_EXPORT Smoke* qt_Smoke;
+extern Q_DECL_EXPORT void init_qt_Smoke();
+
+class QGlobalSpace { };
+
+#endif

Added: trunk/smoke/web/qtdbus_header_list
===================================================================
--- trunk/smoke/web/qtdbus_header_list	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qtdbus_header_list	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,13 @@
+QtDBus/qdbusabstractadaptor.h
+QtDBus/qdbusabstractinterface.h
+QtDBus/qdbusargument.h
+QtDBus/qdbusconnection.h
+QtDBus/qdbusconnectioninterface.h
+QtDBus/qdbuserror.h
+QtDBus/qdbusextratypes.h
+QtDBus/qdbusinterface.h
+QtDBus/qdbusmacros.h
+QtDBus/qdbusmessage.h
+QtDBus/qdbusmetatype.h
+QtDBus/qdbusreply.h
+QtDBus/qdbusserver.h

Added: trunk/smoke/web/qtguess.pl.cmake
===================================================================
--- trunk/smoke/web/qtguess.pl.cmake	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qtguess.pl.cmake	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,423 @@
+#!/usr/bin/perl
+
+# qtguess.pl : check how Qt was compiled. Issue a list of all defined QT_NO_* macros, one per line.
+#
+# author:  germain Garand <germain at ebooksfrance.com>
+# licence: GPL v.2
+
+# options: -q: be quieter
+#	   -o file: redirect output to "file". (default: ./qtdefines)
+#	   -t [0..15]: set the testing threshold (see below)
+#	   -f "flags": additional compiler flags/parameters
+
+use Getopt::Std;
+
+use vars qw/$opt_f $opt_o $opt_p/;
+
+getopts('qo:f:t:');
+
+# Threshold :
+#	 0 - test basic Qt types/classes
+#	 5 - test higher level, non-gui classes
+#	 8 - test options of the above (ex: QT_NO_IMAGE_SMOOTHSCALE)
+#	10 - test basic widgets
+#	12 - test composite widgets
+#	13 - test widgets inheriting composite widgets
+#	15 - test goodies (default)
+
+my $default_threshold = @qt_test_threshold@;
+my $cc = "@CMAKE_CXX_COMPILER@";
+my $ccflags = $opt_f || "@CMAKE_CXX_FLAGS@";
+
+my $nspaces = 50;
+
+my %qtdefs=();
+my %qtundefs=();
+
+my $tmp = gettmpfile();
+my $qtinc = '@QT_INCLUDE_DIR@';
+my $allinc = '@all_includes@';
+my $alllib = '-L at QT_LIBRARY_DIR@';
+my $qtflags = '@qtflags@';
+# my %x;
+# $x{'LIBPNG'}  =   '@LIBPNG@';
+# $x{'LIBJPEG'} =   '@LIBJPEG@';
+# $x{'LIBSM'}   =   '@LIBSM@';
+# $x{'LIBSOCKET'} = '@LIBSOCKET@';
+# $x{'LIBDL'}      = '@LIBDL@';
+# $x{'LIBRESOLV'}  = '@LIBRESOLV@';
+# $x{'LIB_X11'} =   '@LIB_X11@';
+# $x{'X_PRE_LIBS'} = '@X_PRE_LIBS@';
+# $x{'LIB_X11'} =~ s/\$\((.*?)\)/$x{$1}/g;
+# 
+# $qtflags =~ s/\$\((.*?)\)/$x{$1}/g;
+
+ -e "$qtinc/QtCore/qglobal.h" or die "Invalid Qt include directory.\n";
+
+my $ccmd = "$cc $ccflags $allinc $alllib -o $tmp $tmp.cpp $qtflags";
+
+my $threshold = defined($opt_t)?$opt_t : $default_threshold;
+$threshold >= 0 or die "invalid testing threshold: $threshold\n";
+
+print "Checking how Qt was built... \n";
+print "Threshold is set to $threshold\n" unless $opt_q;
+
+my($count, $used, $total);
+map{ $tests{$_}->[2]>=$threshold ? ($used++, $total++):$total++ } keys %tests;
+
+print "Number of defines to be tested : $used/$total\n\n" unless $opt_q;
+open( QTDEFS, ">>".($opt_o || "qtdefines") ) or die "Can't open output file: $!\n";
+
+grab_qglobal_symbols();
+preliminary_test();
+perform_all_tests();
+
+print +scalar(keys %qtdefs) . " defines found.\n";
+
+print QTDEFS join("\n", keys %qtdefs), "\n";
+close;
+
+#--------------------------------------------------------------#
+
+sub gettmpfile
+{
+	my $tmpdir = $ENV{'TMP'} || ".";
+	my $tmpname = $$."-qtguess";
+	while( -e "$tmpdir/$tmpname" || -e "$tmpdir/${tmpname}.cpp" )
+	{
+		$tmpname .= int (rand * 9);
+	}
+	return "$tmpdir/$tmpname";
+}
+
+#--------------------------------------------------------------#
+
+sub grab_qglobal_symbols
+{
+	my $cmd = "$cc -E -D__cplusplus -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2>/dev/null";
+	my $symbols = `$cmd`;
+        for(0..1)
+        {
+	    if( check_exit_status($?) )
+	    {
+		while( $symbols =~/^#\s*define\s*(QT_\S+)/gm )
+		{
+			$qtdefs{$1} = 1;
+		}
+		print "Found ". scalar( keys %qtdefs )." predefined symbol".((scalar( keys %qtdefs ) -1)?"s":"")." in qglobal.h\n" unless ($opt_q or !(keys %qtdefs));
+		while( $symbols =~/^#\s*define\s*QT_MODULE_(\S+)/gm )
+		{
+			$qtundefs{"QT_NO_$1"} = 1;
+		}
+		print "Found ". scalar( keys %qtundefs )." undefined symbol".((scalar( keys %qtundefs ) -1)?"s":"")." in qglobal.h\n" unless ($opt_q or !(keys %qtundefs));
+                last;
+	    }
+	    elsif(! $_) # first try
+	    {
+		print  "Failed to run $cmd.\nTrying without __cplusplus (might be already defined)\n";
+                $cmd = "$cc -E -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2>/dev/null";
+                $symbols = `$cmd`;
+                next;
+	    }
+        }
+}
+
+#--------------------------------------------------------------#
+
+sub preliminary_test
+{
+	my $msg = "Trying to compile and link a small program...";
+	print $msg, " " x ($nspaces - length($msg) + 8);
+	open( OUT, ">${tmp}.cpp" ) or die "Failed to open temp file ${tmp}.cpp: $!\n";
+	my $simple=q"
+		#include <QtGui/qapplication.h>
+		int main( int argc, char **argv )
+		{
+			QApplication foo( argc, argv );
+			return 0;
+		}
+	";
+	print OUT $simple;
+	close OUT;
+        my $out = `$ccmd 2>&1`;
+	if( !check_exit_status($?) )
+	{
+		die <<"EOF";
+
+FAILED : check your configuration.
+Failed program was:
+$simple
+Compiled with:
+$ccmd
+Compiler output:
+$out
+EOF
+	}
+	else
+	{
+		print "OK\n";
+	}
+}
+
+#--------------------------------------------------------------#
+
+sub perform_all_tests
+{
+	foreach ( sort { $tests{$a}->[2] <=> $tests{$b}->[2]} keys %tests)
+	{
+		$tests{$_}->[2] < $threshold and next;
+		($qtdefs{$_} || $qtundefs{$_}) and do
+		{
+			print "\rSkipping $_ (in qglobal.h)".( " " x (($nspaces-16) - length($_)) ).($qtundefs{$_}?"*Undefined*":" [Defined]").($opt_q?"":"\n");
+			next
+		};
+		print "\rTesting $_".( " " x ($nspaces - length($_)) );
+		open( OUT, ">${tmp}.cpp" ) or die "Failed to open temp file ${tmp}.cpp: $!\n";
+		foreach $def(keys %qtdefs)
+		{
+			print OUT "#define $def\n";
+		}
+		foreach $inc(split /,\s*/, $tests{$_}->[0])
+		{
+			print OUT "#include <$inc>\n";
+		}
+		print OUT "#include <QtCore/qfeatures.h>\n";
+		print OUT $tests{$_}->[3] if $tests{$_}->[3]; # need to define some classes ?
+		print OUT qq"
+
+		int main( int argc, char ** argv)
+		{
+		$tests{$_}->[1]
+		return 0;
+		}
+
+		";
+		close OUT;
+
+                my $out = `$ccmd 2>&1`;
+		my $ok = check_exit_status($?);
+		if( !$ok )
+		{
+			$qtdefs{$_} = 1;
+		}
+		print +$opt_q ? ++$count."/$used" : ( $ok ? "*Undefined*\n" : " [Defined]\n" );
+	}
+	$opt_q && print "\n";
+}
+
+#--------------------------------------------------------------#
+
+sub check_exit_status
+{
+	my $a = 0xFFFF & shift;
+	if( !$a )
+	{
+		return 1;
+	}
+	elsif( $a == 0xFF00 )
+	{
+		die "\nSystem call failed: $!\n";
+	}
+	elsif( $a > 0x80 )
+	{
+		# non-zero status.
+	}
+	else
+	{
+		if( $a & 0x80 )
+		{
+			die "\n$cc coredumped with signal ". ($a & ~0x80);
+		}
+		die "\n$cc interrupted by signal $a\n";
+	}
+	return 0;
+}
+
+#--------------------------------------------------------------#
+
+END
+{
+	unlink $tmp if -e $tmp;
+	unlink "${tmp}.cpp" if -e "${tmp}.cpp";
+}
+
+#--------------------------------------------------------------#
+
+BEGIN {
+
+# "DEFINE" => ["header-1.h,... header-n.h", "main() code", priority, "Definitions (if needed)"]
+
+our %tests = (
+	"QT_NO_ACCESSIBILITY" =>        ["QtGui/qaccessible.h", "QAccessibleEvent event(QEvent::AccessibilityHelp, 0);", 15],
+	"QT_NO_ACTION" =>		["QtGui/qaction.h", "QAction foo( (QObject*)NULL );", 5],
+	#QT_NO_BIG_CODECS
+ 	"QT_NO_BUTTONGROUP" =>		["QtGui/qbuttongroup.h", "QButtonGroup foo( (QObject*)NULL );", 12],
+ 	"QT_NO_CHECKBOX" =>		["QtGui/qcheckbox.h", "QCheckBox foo( (QWidget*)NULL );", 10],
+	"QT_NO_CLIPBOARD" => 		["QtGui/qapplication.h, QtGui/qclipboard.h", q"
+						QApplication foo( argc, argv );
+						QClipboard *baz= foo.clipboard();
+					", 5],
+ 	"QT_NO_COLORDIALOG" =>		["QtGui/qcolordialog.h", "QColorDialog::customCount();", 12],
+	#QT_NO_COLORNAMES
+ 	"QT_NO_COMBOBOX" =>		["QtGui/qcombobox.h", "QComboBox foo( (QWidget*)NULL );", 10],
+	"QT_NO_COMPAT" =>		["QtGui/qfontmetrics.h", q"
+						QFontMetrics *foo= new QFontMetrics( QFont() );
+						int bar = foo->width( 'c' );
+					", 0],
+	"QT_NO_COMPONENT" =>		["QtGui/qapplication.h", q"
+ 						QApplication foo( argc, argv );
+ 						foo.addLibraryPath( QString::null );
+					", 5],
+	#QT_NO_COP
+ 	"QT_NO_CURSOR" =>		["QtGui/qcursor.h", "QCursor foo;", 5],
+ 	"QT_NO_DATASTREAM" =>		["QtCore/qdatastream.h", "QDataStream foo;", 5],
+ 	"QT_NO_DATETIMEEDIT" =>		["QtGui/qdatetimeedit.h", "QTimeEdit foo;", 12],
+	"QT_NO_DIAL" =>			["QtGui/qdial.h", "QDial foo;", 10],
+	"QT_NO_DIALOG" =>		["QtGui/qdialog.h", "QDialog foo;", 12],
+	"QT_NO_DIR" =>			["QtCore/qdir.h", "QDir foo;", 5],
+	#QT_NO_DIRECTPAINTER
+	"QT_NO_DOM" =>			["QtXml/qdom.h", "QDomDocumentType foo;", 5],
+	"QT_NO_DRAGANDDROP" =>		["QtGui/qevent.h", "QDropEvent foo( QDropEvent() );", 5],
+	"QT_NO_DRAWUTIL" =>		["QtGui/qdrawutil.h, QtGui/qcolor.h", "qDrawPlainRect( (QPainter *) NULL, 0, 0, 0, 0, QColor() );", 10],
+	#QT_NO_EFFECTS
+	"QT_NO_ERRORMESSAGE" => 	["QtGui/qerrormessage.h", "QErrorMessage foo( (QWidget*) NULL );", 13],
+	"QT_NO_FILEDIALOG" =>		["QtGui/qfiledialog.h", "QFileDialog foo();", 13],
+
+	"QT_NO_FONTDATABASE" =>		["QtGui/qfontdatabase.h", "QFontDatabase foo;", 5],
+	"QT_NO_FONTDIALOG" => 		["QtGui/qfontdialog.h",   "QFontDialog::getFont( (bool *)NULL );", 12],
+	"QT_NO_FRAME" => 		["QtGui/qframe.h", "QFrame foo;", 10],
+	#QT_NO_FREETYPE
+ 	"QT_NO_FTP" =>	["QtNetwork/qftp.h", "QFtp foo;", 9],
+	"QT_NO_GROUPBOX" =>		["QtGui/qgroupbox.h", "QGroupBox foo;", 12],
+	#QT_NO_IMAGEFORMAT_BMP
+	#QT_NO_IMAGEFORMAT_JPEG
+	#QT_NO_IMAGEFORMATPLUGIN
+	#QT_NO_IMAGEFORMAT_PNG
+	#QT_NO_IMAGEFORMAT_PPM
+	#QT_NO_IMAGEFORMAT_XBM
+ 	"QT_NO_IMAGE_HEURISTIC_MASK" =>	["QtGui/qimage.h", q"
+						QImage *foo = new QImage;
+						foo->createHeuristicMask();
+					", 8],
+	#QT_NO_IMAGE_TEXT
+	"QT_NO_IMAGEIO" => 		["QtGui/qbitmap.h, QtCore/qstring.h", q"
+						QBitmap foo( QString::fromLatin1('foobar') );
+					", 5],
+	"QT_NO_LABEL" =>		["QtGui/qlabel.h", "QLabel foo( (QWidget*) NULL );", 10],
+	"QT_NO_LAYOUT" =>		["QtGui/qlayout.h", "QFoo foo;", 10, q"
+ 						class QFoo: public QLayout
+ 						{
+ 						public:
+ 						    QFoo() {};
+ 						    ~QFoo() {};
+ 						    void addItem( QLayoutItem * ) { };
+						    QSize sizeHint() const { return QSize(); }
+						    void setGeometry( const QRect & ) { };
+                            QLayoutItem* itemAt(int) const {return (QLayoutItem*) NULL;}
+                            QLayoutItem* takeAt(int) {return (QLayoutItem*) NULL;}
+                            int QFoo::count() const {return 0;}
+
+ 						};
+ 					"],
+	"QT_NO_LCDNUMBER" =>		["QtGui/qlcdnumber.h", "QLCDNumber foo;", 12],
+	"QT_NO_LINEEDIT" =>		["QtGui/qlineedit.h", "QLineEdit foo( (QWidget *) NULL );", 12],
+	"QT_NO_LISTVIEW" =>		["QtGui/qlistview.h", "QListView foo;", 13],
+	"QT_NO_MAINWINDOW" =>		["QtGui/qmainwindow.h", "QMainWindow foo;", 13],
+	"QT_NO_MATRIX" =>		["QtGui/qmatrix.h", "QMatrix foo;", 0],
+	"QT_NO_MENUBAR" =>		["QtGui/qmenubar.h", "QMenuBar foo;", 13],
+	"QT_NO_MESSAGEBOX" =>		["QtGui/qmessagebox.h", "QMessageBox foo;", 13],
+	"QT_NO_MOVIE" =>		["QtGui/qmovie.h", "QMovie foo;", 5],
+	"QT_NO_NETWORK" =>		["QtNetwork/qnetworkproxy.h", "QNetworkProxy foo;", 5],
+	#QT_NO_NETWORKPROXY
+	"QT_NO_PALETTE" =>		["QtGui/qpalette.h", "QPalette foo;", 5],
+	"QT_NO_PICTURE" =>		["QtGui/qpicture.h", "QPicture foo;", 5],
+	"QT_NO_PRINTER" =>		["QtGui/qprinter.h", "QPrinter foo();", 5],
+	"QT_NO_PRINTDIALOG" =>		["QtGui/qprintdialog.h", "QPrintDialog foo( (QPrinter*) NULL );", 13],
+	"QT_NO_PROCESS" =>		["QtCore/qprocess.h", "QProcess foo;", 5],
+	"QT_NO_PROGRESSBAR" =>		["QtGui/qprogressbar.h", "QProgressBar foo;", 12],
+	"QT_NO_PROGRESSDIALOG" =>	["QtGui/qprogressdialog.h", "QProgressDialog foo;", 13],
+	"QT_NO_PROPERTIES" =>		["QtCore/qmetaobject.h", "QMetaProperty foo;", 0],
+	"QT_NO_PUSHBUTTON" =>		["QtGui/qpushbutton.h", "QPushButton foo( (QWidget *) NULL );", 12],
+	"QT_NO_QUUID_STRING" =>		["QtCore/quuid.h", "QUuid foo( QString() );", 8],
+	"QT_NO_RADIOBUTTON" =>		["QtGui/qradiobutton.h", "QRadioButton foo( (QWidget *) NULL );", 12],
+	#QT_NO_QWS_ALPHA_CURSOR
+	#QT_NO_QWS_DECORATION_DEFAULT
+	#QT_NO_QWS_INPUTMETHODS
+	#QT_NO_QWS_KEYBOARD
+	#QT_NO_QWS_MOUSE
+	#QT_NO_QWS_MOUSE_AUTO
+	#QT_NO_QWS_MOUSE_MANUAL
+	#QT_NO_QWS_MULTIPROCESS
+	#QT_NO_QWS_PROPERTIES
+	#QT_NO_QWS_QPF
+	#QT_NO_RESIZEHANDLER
+	#QT_NO_RUBBERBAND
+	"QT_NO_SCROLLBAR" =>		["QtGui/qscrollbar.h", "QScrollBar foo( (QWidget *) NULL );", 12],
+	"QT_NO_SESSIONMANAGER" =>	["QtGui/qapplication.h", q"
+  						QApplication foo( argc, argv );
+  						foo.sessionId();
+					", 15],
+	"QT_NO_SETTINGS" =>		["QtCore/qsettings.h", "QSettings foo;", 5],
+	#QT_NO_SHORTCUT
+	"QT_NO_SIGNALMAPPER" =>		["QtCore/qsignalmapper.h", "QSignalMapper foo( (QObject *) NULL );", 0],
+	"QT_NO_SIZEGRIP" =>		["QtGui/qsizegrip.h", "QSizeGrip foo( (QWidget *) NULL );", 10],
+	"QT_NO_SLIDER" =>		["QtGui/qslider.h", "QSlider foo( (QWidget *) NULL );", 12],
+	"QT_NO_SOUND" =>		["QtGui/qsound.h", "QSound foo( QString::null );", 5],
+	#QT_NO_SPINWIDGET
+	#QT_NO_SPLASHSCREEN
+	#QT_NO_STACKEDWIDGET
+	#QT_NO_STATUSBAR
+	#QT_NO_STATUSTIP
+	#QT_NO_STL
+	"QT_NO_STRINGLIST" =>		["qstringlist.h", "QStringList foo;", 0],
+	"QT_NO_STYLE_PLASTIQUE" =>		["QtGui/qplastiquestyle.h", "QPlastiqueStyle foo;", 16],
+ 	"QT_NO_STYLE_WINDOWSXP" =>	["QtGui/qwindowsxpstyle.h", "QWindowsXPStyle foo;", 16],
+ 	"QT_NO_STYLE_WINDOWS" =>	["QtGui/qwindowsstyle.h", "QWindowsStyle foo;", 16],
+	"QT_NO_STYLE_MAC" =>	["QtGui/macstyle.h", "QMacStyle foo;", 16],
+	"QT_NO_STYLE_CLEANLOOKS" =>	["QtGui/qcleanlooksstyle.h", "QCleanlooksStyle foo;", 16],
+    "QT_NO_TABBAR" =>               ["QtGui/qtabbar.h", "QTabBar foo;", 10],
+	"QT_NO_TABLEVIEW" =>		["QtGui/qtableview.h", "QTableView foo;", 16],
+    "QT_NO_TABWIDGET" =>            ["QtGui/qtabwidget.h", "QTabWidget foo;", 10],
+    "QT_NO_TEXTBROWSER" =>          ["QtGui/qtextbrowser.h", "QTextBrowser foo;", 14],
+    "QT_NO_TEXTCODEC" =>            ["QtCore/qtextcodec.h", "QTextCodec::codecForMib(1);", 5],
+    "QT_NO_TEXTCODECPLUGIN" =>      ["QtCore/qtextcodecplugin.h, QtCore/qstringlist.h, QtCore/qlist.h, QtCore/qtextcodec.h", "QFoo foo;", 6, q"
+						class QFoo: public QTextCodecPlugin
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            QList<QByteArray> names() const {return QList<QByteArray>();}
+                            QList<int>mibEnums() const {return QList<int>();}
+                            QTextCodec *createForName( const QByteArray & name ) {return (QTextCodec *)NULL;}
+                            QTextCodec *createForMib( int mib ) {return (QTextCodec *)NULL;}
+                            QList<QByteArray> aliases() const {return QList<QByteArray>();}
+						};
+						Q_EXPORT_PLUGIN2( 'Foo', QFoo )
+					"],
+	#QT_NO_TEXTDATE
+ 	"QT_NO_TEXTEDIT" =>		["QtGui/qtextedit.h", "QTextEdit foo;", 13], 
+    "QT_NO_TEXTSTREAM" =>           ["qtextstream.h", "QTextStream foo;", 5],
+    "QT_NO_THREAD" =>           ["QtCore/qthread.h", "QFoo foo;", 5, q"
+						class QFoo: public QThread
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            void run() {}
+						};
+					"],
+    "QT_NO_TOOLBAR" =>              ["QtGui/qtoolbar.h", "QToolBar foo;", 10],
+    "QT_NO_TOOLBUTTON" =>           ["QtGui/qtoolbutton.h", "QToolButton foo((QWidget *) NULL );", 12],
+    "QT_NO_TOOLTIP" =>              ["QtGui/qtooltip.h", "QToolTip::palette();", 10],
+	#QT_NO_TRANSLATION
+	#QT_NO_UDPSOCKET
+	#QT_NO_URLINFO
+	#QT_NO_VALIDATOR
+    "QT_NO_VARIANT" =>              ["QtCore/qvariant.h", "QVariant foo;", 0],
+    "QT_NO_WHATSTHIS" =>            ["QtGui/qwhatsthis.h", "QWhatsThis::inWhatsThisMode();", 10],
+	"QT_NO_WHEELEVENT" =>		["QtGui/qevent.h", "QWheelEvent foo( QPoint(1,1), 1, (Qt::MouseButtons)1, 0 );", 5],
+	"QT_NO_XML" =>			["QtXml/qxml.h", "QXmlNamespaceSupport foo;", 5],
+
+	);
+
+}

Added: trunk/smoke/web/qtguess.pl.in
===================================================================
--- trunk/smoke/web/qtguess.pl.in	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qtguess.pl.in	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,422 @@
+#!/usr/bin/perl
+
+# qtguess.pl : check how Qt was compiled. Issue a list of all defined QT_NO_* macros, one per line.
+#
+# author:  germain Garand <germain at ebooksfrance.com>
+# licence: GPL v.2
+
+# options: -q: be quieter
+#	   -o file: redirect output to "file". (default: ./qtdefines)
+#	   -t [0..15]: set the testing threshold (see below)
+#	   -f "flags": additional compiler flags/parameters
+
+use Getopt::Std;
+
+use vars qw/$opt_f $opt_o $opt_p/;
+
+getopts('qo:f:t:');
+
+# Threshold :
+#	 0 - test basic Qt types/classes
+#	 5 - test higher level, non-gui classes
+#	 8 - test options of the above (ex: QT_NO_IMAGE_SMOOTHSCALE)
+#	10 - test basic widgets
+#	12 - test composite widgets
+#	13 - test widgets inheriting composite widgets
+#	15 - test goodies (default)
+
+my $default_threshold = @qt_test_threshold@;
+my $cc = "@CXX@";
+my $ccflags = $opt_f || "@CXXFLAGS@";
+
+my $nspaces = 50;
+
+my %qtdefs=();
+my %qtundefs=();
+
+my $tmp = gettmpfile();
+my $qtinc = '@qt_includes@';
+my $allinc = '@all_includes@';
+my $alllib = '@all_libraries@';
+my $qtflags ='@LIB_QTCORE@ @LIB_QTGUI@ @LIB_QTNETWORK@ @LIB_QTXML@ @LIB_QTSQL@ @LIB_QTOPENGL@';
+my %x;
+$x{'LIBPNG'}  =   '@LIBPNG@';
+$x{'LIBJPEG'} =   '@LIBJPEG@';
+$x{'LIBSM'}   =   '@LIBSM@';
+$x{'LIBSOCKET'} = '@LIBSOCKET@';
+$x{'LIBDL'}      = '@LIBDL@';
+$x{'LIBRESOLV'}  = '@LIBRESOLV@';
+$x{'LIB_X11'} =   '@LIB_X11@';
+$x{'X_PRE_LIBS'} = '@X_PRE_LIBS@';
+$x{'LIB_X11'} =~ s/\$\((.*?)\)/$x{$1}/g;
+
+$qtflags =~ s/\$\((.*?)\)/$x{$1}/g;
+
+ -e "$qtinc/QtCore/qglobal.h" or die "Invalid Qt include directory.\n";
+
+my $ccmd = "$cc $ccflags $allinc $alllib -o $tmp $tmp.cpp $qtflags";
+
+my $threshold = defined($opt_t)?$opt_t : $default_threshold;
+$threshold >= 0 or die "invalid testing threshold: $threshold\n";
+
+print "Checking how Qt was built... \n";
+print "Threshold is set to $threshold\n" unless $opt_q;
+
+my($count, $used, $total);
+map{ $tests{$_}->[2]>=$threshold ? ($used++, $total++):$total++ } keys %tests;
+
+print "Number of defines to be tested : $used/$total\n\n" unless $opt_q;
+open( QTDEFS, ">".($opt_o || "qtdefines") ) or die "Can't open output file: $!\n";
+
+grab_qglobal_symbols();
+preliminary_test();
+perform_all_tests();
+
+print +scalar(keys %qtdefs) . " defines found.\n";
+
+print QTDEFS join("\n", keys %qtdefs), "\n";
+close;
+
+#--------------------------------------------------------------#
+
+sub gettmpfile
+{
+	my $tmpdir = $ENV{'TMP'} || ".";
+	my $tmpname = $$."-qtguess";
+	while( -e "$tmpdir/$tmpname" || -e "$tmpdir/${tmpname}.cpp" )
+	{
+		$tmpname .= int (rand * 9);
+	}
+	return "$tmpdir/$tmpname";
+}
+
+#--------------------------------------------------------------#
+
+sub grab_qglobal_symbols
+{
+	my $cmd = "$cc -E -D__cplusplus -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2>/dev/null";
+	my $symbols = `$cmd`;
+        for(0..1)
+        {
+	    if( check_exit_status($?) )
+	    {
+		while( $symbols =~/^#\s*define\s*(QT_\S+)/gm )
+		{
+			$qtdefs{$1} = 1;
+		}
+		print "Found ". scalar( keys %qtdefs )." predefined symbol".((scalar( keys %qtdefs ) -1)?"s":"")." in qglobal.h\n" unless ($opt_q or !(keys %qtdefs));
+		while( $symbols =~/^#\s*define\s*QT_MODULE_(\S+)/gm )
+		{
+			$qtundefs{"QT_NO_$1"} = 1;
+		}
+		print "Found ". scalar( keys %qtundefs )." undefined symbol".((scalar( keys %qtundefs ) -1)?"s":"")." in qglobal.h\n" unless ($opt_q or !(keys %qtundefs));
+                last;
+	    }
+	    elsif(! $_) # first try
+	    {
+		print  "Failed to run $cmd.\nTrying without __cplusplus (might be already defined)\n";
+                $cmd = "$cc -E -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2>/dev/null";
+                $symbols = `$cmd`;
+                next;
+	    }
+        }
+}
+
+#--------------------------------------------------------------#
+
+sub preliminary_test
+{
+	my $msg = "Trying to compile and link a small program...";
+	print $msg, " " x ($nspaces - length($msg) + 8);
+	open( OUT, ">${tmp}.cpp" ) or die "Failed to open temp file ${tmp}.cpp: $!\n";
+	my $simple=q?
+		#include <QtGui/qapplication.h>
+		int main( int argc, char **argv )
+		{
+			QApplication foo( argc, argv );
+			return 0;
+		}
+	?;
+	print OUT $simple;
+	close OUT;
+        my $out = `$ccmd 2>&1`;
+	if( !check_exit_status($?) )
+	{
+		die <<"EOF";
+
+FAILED : check your configuration.
+Failed program was:
+$simple
+Compiled with:
+$ccmd
+Compiler output:
+$out
+EOF
+	}
+	else
+	{
+		print "OK\n";
+	}
+}
+
+#--------------------------------------------------------------#
+
+sub perform_all_tests
+{
+	foreach ( sort { $tests{$a}->[2] <=> $tests{$b}->[2]} keys %tests)
+	{
+		$tests{$_}->[2] < $threshold and next;
+		($qtdefs{$_} || $qtundefs{$_}) and do
+		{
+			print "\rSkipping $_ (in qglobal.h)".( " " x (($nspaces-16) - length($_)) ).($qtundefs{$_}?"*Undefined*":" [Defined]").($opt_q?"":"\n");
+			next
+		};
+		print "\rTesting $_".( " " x ($nspaces - length($_)) );
+		open( OUT, ">${tmp}.cpp" ) or die "Failed to open temp file ${tmp}.cpp: $!\n";
+		foreach $def(keys %qtdefs)
+		{
+			print OUT "#define $def\n";
+		}
+		foreach $inc(split /,\s*/, $tests{$_}->[0])
+		{
+			print OUT "#include <$inc>\n";
+		}
+		print OUT "#include <QtCore/qfeatures.h>\n";
+		print OUT $tests{$_}->[3] if $tests{$_}->[3]; # need to define some classes ?
+		print OUT qq?
+
+		int main( int argc, char ** argv)
+		{
+		$tests{$_}->[1]
+		return 0;
+		}
+
+		?;
+		close OUT;
+
+                my $out = `$ccmd 2>&1`;
+		my $ok = check_exit_status($?);
+		if( !$ok )
+		{
+			$qtdefs{$_} = 1;
+		}
+		print +$opt_q ? ++$count."/$used" : ( $ok ? "*Undefined*\n" : " [Defined]\n" );
+	}
+	$opt_q && print "\n";
+}
+
+#--------------------------------------------------------------#
+
+sub check_exit_status
+{
+	my $a = 0xFFFF & shift;
+	if( !$a )
+	{
+		return 1;
+	}
+	elsif( $a == 0xFF00 )
+	{
+		die "\nSystem call failed: $!\n";
+	}
+	elsif( $a > 0x80 )
+	{
+		# non-zero status.
+	}
+	else
+	{
+		if( $a & 0x80 )
+		{
+			die "\n$cc coredumped with signal ". ($a & ~0x80);
+		}
+		die "\n$cc interrupted by signal $a\n";
+	}
+	return 0;
+}
+
+#--------------------------------------------------------------#
+
+END
+{
+	unlink $tmp if -e $tmp;
+	unlink "${tmp}.cpp" if -e "${tmp}.cpp";
+}
+
+#--------------------------------------------------------------#
+
+BEGIN {
+
+# "DEFINE" => ["header-1.h,... header-n.h", "main() code", priority, "Definitions (if needed)"]
+
+our %tests = (
+	"QT_NO_ACCESSIBILITY" =>        ["QtGui/qaccessible.h", "QAccessibleEvent event(QEvent::AccessibilityHelp, 0);", 15],
+	"QT_NO_ACTION" =>		["QtGui/qaction.h", "QAction foo( (QObject*)NULL );", 5],
+	#QT_NO_BIG_CODECS
+ 	"QT_NO_BUTTONGROUP" =>		["QtGui/qbuttongroup.h", "QButtonGroup foo( (QObject*)NULL );", 12],
+ 	"QT_NO_CHECKBOX" =>		["QtGui/qcheckbox.h", "QCheckBox foo( (QWidget*)NULL );", 10],
+	"QT_NO_CLIPBOARD" => 		["QtGui/qapplication.h, QtGui/qclipboard.h", q?
+						QApplication foo( argc, argv );
+						QClipboard *baz= foo.clipboard();
+					?, 5],
+ 	"QT_NO_COLORDIALOG" =>		["QtGui/qcolordialog.h", "QColorDialog::customCount();", 12],
+	#QT_NO_COLORNAMES
+ 	"QT_NO_COMBOBOX" =>		["QtGui/qcombobox.h", "QComboBox foo( (QWidget*)NULL );", 10],
+	"QT_NO_COMPAT" =>		["QtGui/qfontmetrics.h", q?
+						QFontMetrics *foo= new QFontMetrics( QFont() );
+						int bar = foo->width( 'c' );
+					?, 0],
+	"QT_NO_COMPONENT" =>		["QtGui/qapplication.h", q?
+ 						QApplication foo( argc, argv );
+ 						foo.addLibraryPath( QString::null );
+					?, 5],
+	#QT_NO_COP
+ 	"QT_NO_CURSOR" =>		["QtGui/qcursor.h", "QCursor foo;", 5],
+ 	"QT_NO_DATASTREAM" =>		["QtCore/qdatastream.h", "QDataStream foo;", 5],
+ 	"QT_NO_DATETIMEEDIT" =>		["QtGui/qdatetimeedit.h", "QTimeEdit foo;", 12],
+	"QT_NO_DIAL" =>			["QtGui/qdial.h", "QDial foo;", 10],
+	"QT_NO_DIALOG" =>		["QtGui/qdialog.h", "QDialog foo;", 12],
+	"QT_NO_DIR" =>			["QtCore/qdir.h", "QDir foo;", 5],
+	#QT_NO_DIRECTPAINTER
+	"QT_NO_DOM" =>			["QtXml/qdom.h", "QDomDocumentType foo;", 5],
+	"QT_NO_DRAGANDDROP" =>		["QtGui/qevent.h", "QDropEvent foo( QDropEvent() );", 5],
+	"QT_NO_DRAWUTIL" =>		["QtGui/qdrawutil.h, QtGui/qcolor.h", "qDrawPlainRect( (QPainter *) NULL, 0, 0, 0, 0, QColor() );", 10],
+	#QT_NO_EFFECTS
+	"QT_NO_ERRORMESSAGE" => 	["QtGui/qerrormessage.h", "QErrorMessage foo( (QWidget*) NULL );", 13],
+	"QT_NO_FILEDIALOG" =>		["QtGui/qfiledialog.h", "QFileDialog foo();", 13],
+
+	"QT_NO_FONTDATABASE" =>		["QtGui/qfontdatabase.h", "QFontDatabase foo;", 5],
+	"QT_NO_FONTDIALOG" => 		["QtGui/qfontdialog.h",   "QFontDialog::getFont( (bool *)NULL );", 12],
+	"QT_NO_FRAME" => 		["QtGui/qframe.h", "QFrame foo;", 10],
+	#QT_NO_FREETYPE
+ 	"QT_NO_FTP" =>	["QtNetwork/qftp.h", "QFtp foo;", 9],
+	"QT_NO_GROUPBOX" =>		["QtGui/qgroupbox.h", "QGroupBox foo;", 12],
+	#QT_NO_IMAGEFORMAT_BMP
+	#QT_NO_IMAGEFORMAT_JPEG
+	#QT_NO_IMAGEFORMATPLUGIN
+	#QT_NO_IMAGEFORMAT_PNG
+	#QT_NO_IMAGEFORMAT_PPM
+	#QT_NO_IMAGEFORMAT_XBM
+ 	"QT_NO_IMAGE_HEURISTIC_MASK" =>	["QtGui/qimage.h", q?
+						QImage *foo = new QImage;
+						foo->createHeuristicMask();
+					?, 8],
+	#QT_NO_IMAGE_TEXT
+	"QT_NO_IMAGEIO" => 		["QtGui/qbitmap.h, QtCore/qstring.h", q?
+						QBitmap foo( QString::fromLatin1("foobar") );
+					?, 5],
+	"QT_NO_LABEL" =>		["QtGui/qlabel.h", "QLabel foo( (QWidget*) NULL );", 10],
+	"QT_NO_LAYOUT" =>		["QtGui/qlayout.h", "QFoo foo;", 10, q?
+ 						class QFoo: public QLayout
+ 						{
+ 						public:
+ 						    QFoo() {};
+ 						    ~QFoo() {};
+ 						    void addItem( QLayoutItem * ) { };
+						    QSize sizeHint() const { return QSize(); }
+						    void setGeometry( const QRect & ) { };
+                            QLayoutItem* itemAt(int) const {return (QLayoutItem*) NULL;}
+                            QLayoutItem* takeAt(int) {return (QLayoutItem*) NULL;}
+                            int QFoo::count() const {return 0;}
+
+ 						};
+ 					?],
+	"QT_NO_LCDNUMBER" =>		["QtGui/qlcdnumber.h", "QLCDNumber foo;", 12],
+	"QT_NO_LINEEDIT" =>		["QtGui/qlineedit.h", "QLineEdit foo( (QWidget *) NULL );", 12],
+	"QT_NO_LISTVIEW" =>		["QtGui/qlistview.h", "QListView foo;", 13],
+	"QT_NO_MAINWINDOW" =>		["QtGui/qmainwindow.h", "QMainWindow foo;", 13],
+	"QT_NO_MATRIX" =>		["QtGui/qmatrix.h", "QMatrix foo;", 0],
+	"QT_NO_MENUBAR" =>		["QtGui/qmenubar.h", "QMenuBar foo;", 13],
+	"QT_NO_MESSAGEBOX" =>		["QtGui/qmessagebox.h", "QMessageBox foo;", 13],
+	"QT_NO_MOVIE" =>		["QtGui/qmovie.h", "QMovie foo;", 5],
+	"QT_NO_NETWORK" =>		["QtNetwork/qnetworkproxy.h", "QNetworkProxy foo;", 5],
+	#QT_NO_NETWORKPROXY
+	"QT_NO_PALETTE" =>		["QtGui/qpalette.h", "QPalette foo;", 5],
+	"QT_NO_PICTURE" =>		["QtGui/qpicture.h", "QPicture foo;", 5],
+	"QT_NO_PRINTER" =>		["QtGui/qprinter.h", "QPrinter foo();", 5],
+	"QT_NO_PRINTDIALOG" =>		["QtGui/qprintdialog.h", "QPrintDialog foo( (QPrinter*) NULL );", 13],
+	"QT_NO_PROCESS" =>		["QtCore/qprocess.h", "QProcess foo;", 5],
+	"QT_NO_PROGRESSBAR" =>		["QtGui/qprogressbar.h", "QProgressBar foo;", 12],
+	"QT_NO_PROGRESSDIALOG" =>	["QtGui/qprogressdialog.h", "QProgressDialog foo;", 13],
+	"QT_NO_PROPERTIES" =>		["QtCore/qmetaobject.h", "QMetaProperty foo;", 0],
+	"QT_NO_PUSHBUTTON" =>		["QtGui/qpushbutton.h", "QPushButton foo( (QWidget *) NULL );", 12],
+	"QT_NO_QUUID_STRING" =>		["QtCore/quuid.h", "QUuid foo( QString() );", 8],
+	"QT_NO_RADIOBUTTON" =>		["QtGui/qradiobutton.h", "QRadioButton foo( (QWidget *) NULL );", 12],
+	#QT_NO_QWS_ALPHA_CURSOR
+	#QT_NO_QWS_DECORATION_DEFAULT
+	#QT_NO_QWS_INPUTMETHODS
+	#QT_NO_QWS_KEYBOARD
+	#QT_NO_QWS_MOUSE
+	#QT_NO_QWS_MOUSE_AUTO
+	#QT_NO_QWS_MOUSE_MANUAL
+	#QT_NO_QWS_MULTIPROCESS
+	#QT_NO_QWS_PROPERTIES
+	#QT_NO_QWS_QPF
+	#QT_NO_RESIZEHANDLER
+	#QT_NO_RUBBERBAND
+	"QT_NO_SCROLLBAR" =>		["QtGui/qscrollbar.h", "QScrollBar foo( (QWidget *) NULL );", 12],
+	"QT_NO_SESSIONMANAGER" =>	["QtGui/qapplication.h", q?
+  						QApplication foo( argc, argv );
+  						foo.sessionId();
+					?, 15],
+	"QT_NO_SETTINGS" =>		["QtCore/qsettings.h", "QSettings foo;", 5],
+	#QT_NO_SHORTCUT
+	"QT_NO_SIGNALMAPPER" =>		["QtCore/qsignalmapper.h", "QSignalMapper foo( (QObject *) NULL );", 0],
+	"QT_NO_SIZEGRIP" =>		["QtGui/qsizegrip.h", "QSizeGrip foo( (QWidget *) NULL );", 10],
+	"QT_NO_SLIDER" =>		["QtGui/qslider.h", "QSlider foo( (QWidget *) NULL );", 12],
+	"QT_NO_SOUND" =>		["QtGui/qsound.h", "QSound foo( QString::null );", 5],
+	#QT_NO_SPINWIDGET
+	#QT_NO_SPLASHSCREEN
+	#QT_NO_STACKEDWIDGET
+	#QT_NO_STATUSBAR
+	#QT_NO_STATUSTIP
+	#QT_NO_STL
+	"QT_NO_STRINGLIST" =>		["qstringlist.h", "QStringList foo;", 0],
+	"QT_NO_STYLE_PLASTIQUE" =>		["QtGui/qplastiquestyle.h", "QPlastiqueStyle foo;", 16],
+ 	"QT_NO_STYLE_WINDOWSXP" =>	["QtGui/qwindowsxpstyle.h", "QWindowsXPStyle foo;", 16],
+ 	"QT_NO_STYLE_WINDOWS" =>	["QtGui/qwindowsstyle.h", "QWindowsStyle foo;", 16],
+	"QT_NO_STYLE_MAC" =>	["QtGui/macstyle.h", "QMacStyle foo;", 16],
+	"QT_NO_STYLE_CLEANLOOKS" =>	["QtGui/qcleanlooksstyle.h", "QCleanlooksStyle foo;", 16],
+    "QT_NO_TABBAR" =>               ["QtGui/qtabbar.h", "QTabBar foo;", 10],
+	"QT_NO_TABLEVIEW" =>		["QtGui/qtableview.h", "QTableView foo;", 16],
+    "QT_NO_TABWIDGET" =>            ["QtGui/qtabwidget.h", "QTabWidget foo;", 10],
+    "QT_NO_TEXTBROWSER" =>          ["QtGui/qtextbrowser.h", "QTextBrowser foo;", 14],
+    "QT_NO_TEXTCODEC" =>            ["QtCore/qtextcodec.h", "QTextCodec::codecForMib(1);", 5],
+    "QT_NO_TEXTCODECPLUGIN" =>      ["QtCore/qtextcodecplugin.h, QtCore/qstringlist.h, QtCore/qlist.h, QtCore/qtextcodec.h", "QFoo foo;", 6, q? 
+						class QFoo: public QTextCodecPlugin
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            QList<QByteArray> names() const {return QList<QByteArray>();}
+                            QList<int>mibEnums() const {return QList<int>();}
+                            QTextCodec *createForName( const QByteArray & name ) {return (QTextCodec *)NULL;}
+                            QTextCodec *createForMib( int mib ) {return (QTextCodec *)NULL;}
+                            QList<QByteArray> aliases() const {return QList<QByteArray>();}
+						};
+						Q_EXPORT_PLUGIN2( "Foo", QFoo )
+					?],
+	#QT_NO_TEXTDATE
+ 	"QT_NO_TEXTEDIT" =>		["QtGui/qtextedit.h", "QTextEdit foo;", 13], 
+    "QT_NO_TEXTSTREAM" =>           ["qtextstream.h", "QTextStream foo;", 5],
+    "QT_NO_THREAD" =>           ["QtCore/qthread.h", "QFoo foo;", 5, q?
+						class QFoo: public QThread
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            void run() {}
+						};
+					?],
+    "QT_NO_TOOLBAR" =>              ["QtGui/qtoolbar.h", "QToolBar foo;", 10],
+    "QT_NO_TOOLBUTTON" =>           ["QtGui/qtoolbutton.h", "QToolButton foo((QWidget *) NULL );", 12],
+    "QT_NO_TOOLTIP" =>              ["QtGui/qtooltip.h", "QToolTip::palette();", 10],
+	#QT_NO_TRANSLATION
+	#QT_NO_UDPSOCKET
+	#QT_NO_URLINFO
+	#QT_NO_VALIDATOR
+    "QT_NO_VARIANT" =>              ["QtCore/qvariant.h", "QVariant foo;", 0],
+    "QT_NO_WHATSTHIS" =>            ["QtGui/qwhatsthis.h", "QWhatsThis::inWhatsThisMode();", 10],
+	"QT_NO_WHEELEVENT" =>		["QtGui/qevent.h", "QWheelEvent foo( QPoint(1,1), 1, (Qt::MouseButtons)1, 0 );", 5],
+	"QT_NO_XML" =>			["QtXml/qxml.h", "QXmlNamespaceSupport foo;", 5],
+	);
+
+}

Added: trunk/smoke/web/qwt_header_list
===================================================================
--- trunk/smoke/web/qwt_header_list	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qwt_header_list	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,66 @@
+qwt_abstract_scale_draw.h
+qwt_abstract_scale.h
+qwt_abstract_slider.h
+qwt_analog_clock.h
+qwt_array.h
+qwt_arrow_button.h
+qwt_color_map.h
+qwt_compass.h
+qwt_compass_rose.h
+qwt_counter.h
+qwt_curve_fitter.h
+qwt_data.h
+qwt_dial.h
+qwt_dial_needle.h
+qwt_double_interval.h
+qwt_double_range.h
+qwt_double_rect.h
+qwt_dyngrid_layout.h
+qwt_event_pattern.h
+qwt_global.h
+qwt.h
+qwt_interval_data.h
+qwt_knob.h
+qwt_layout_metrics.h
+qwt_legend.h
+qwt_legend_item.h
+qwt_math.h
+qwt_paint_buffer.h
+qwt_painter.h
+qwt_panner.h
+qwt_picker.h
+qwt_picker_machine.h
+qwt_plot_canvas.h
+qwt_plot_curve.h
+qwt_plot_dict.h
+qwt_plot_grid.h
+qwt_plot.h
+qwt_plot_item.h
+qwt_plot_layout.h
+qwt_plot_magnifier.h
+qwt_plot_marker.h
+qwt_plot_panner.h
+qwt_plot_picker.h
+qwt_plot_printfilter.h
+qwt_plot_rasteritem.h
+qwt_plot_spectrogram.h
+qwt_plot_zoomer.h
+qwt_polygon.h
+qwt_raster_data.h
+qwt_rect.h
+qwt_round_scale_draw.h
+qwt_scale_div.h
+qwt_scale_draw.h
+qwt_scale_engine.h
+qwt_scale_map.h
+qwt_scale_widget.h
+qwt_slider.h
+qwt_spline.h
+qwt_symbol.h
+qwt_text_engine.h
+qwt_text.h
+qwt_text_label.h
+qwt_text_plugin.h
+qwt_thermo.h
+qwt_valuelist.h
+qwt_wheel.h

Added: trunk/smoke/web/smokeqt.pro
===================================================================
--- trunk/smoke/web/smokeqt.pro	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/smokeqt.pro	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,39 @@
+######################################################################
+# Automatically generated by qmake (2.00a) lun 17. abr 22:10:08 2006
+######################################################################
+
+QT += network xml sql opengl svg uitools
+TEMPLATE = lib
+TARGET += 
+DEPENDPATH += .
+INCLUDEPATH += .
+INCLUDEPATH += ..
+
+# Add a 'qdbus' option if building with QtDBus:
+CONFIG += uitools
+
+DEFINES += QT_NO_DEBUG_STREAM
+
+# Input
+HEADERS += qt_smoke.h
+SOURCES += smokedata.cpp \
+           x_1.cpp \
+           x_10.cpp \
+           x_11.cpp \
+           x_12.cpp \
+           x_13.cpp \
+           x_14.cpp \
+           x_15.cpp \
+           x_16.cpp \
+           x_17.cpp \
+           x_18.cpp \
+           x_19.cpp \
+           x_2.cpp \
+           x_20.cpp \
+           x_3.cpp \
+           x_4.cpp \
+           x_5.cpp \
+           x_6.cpp \
+           x_7.cpp \
+           x_8.cpp \
+           x_9.cpp



From tm243 at mail.berlios.de  Sat Jun  9 13:40:06 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Sat, 9 Jun 2007 13:40:06 +0200
Subject: [Php-qt-svn] r346 - trunk/php_qt
Message-ID: <200706091140.l59Be6wS026318@sheep.berlios.de>

Author: tm243
Date: 2007-06-09 13:40:05 +0200 (Sat, 09 Jun 2007)
New Revision: 346

Modified:
   trunk/php_qt/php_qt.cpp
Log:
* fixed constructor fore prefixed classes



Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-08 13:50:59 UTC (rev 345)
+++ trunk/php_qt/php_qt.cpp	2007-06-09 11:40:05 UTC (rev 346)
@@ -33,7 +33,8 @@
 #include "marshall_types.h"
 #include "phpqt_internals.h"
 
-// #define CLASS_PREFIX 1 // needed for IQuiP
+#define IQUIP
+
 #define DEBUG 1
 #define MOC_DEBUG 0
 
@@ -197,10 +198,16 @@
     }
 
     methodNameStack.push(new QByteArray(ce->name));
+
+#ifdef IQUIP
+	// remove the leading '_'
+	methodNameStack.top()->remove(0,1);
+#endif
+
     smokephp_prepareMethodName(args, argc, methodNameStack);	// #, $, ?
     Smoke::Index method = smokephp_getMethod(ce->name, methodNameStack.top()->constData(), ZEND_NUM_ARGS(), args);
 
- 	MethodCall c(PQ::smoke(), method, getThis(), args, argc-1, getThis(), return_value_ptr);
+    MethodCall c(PQ::smoke(), method, getThis(), args, argc-1, getThis(), return_value_ptr);
     c.next();
 
 	// smokephp_object is created above in c.next()
@@ -398,15 +405,8 @@
 		// register zend class
 		zend_class_entry ce;
 
-#ifdef CLASS_PREFIX
-		QByteArray* _className = new QByteArray("_");
-		_className->append(PQ::smoke()->classes[i].className);
-#else
-		QByteArray* _className = new QByteArray(PQ::smoke()->classes[i].className);
-#endif
-
-		INIT_CLASS_ENTRY(ce, _className->constData(), p);
-		ce.name_length = _className->size();
+		INIT_CLASS_ENTRY(ce, PQ::smoke()->classes[i].className, p);
+		ce.name_length = strlen(PQ::smoke()->classes[i].className);
 		zend_class_entry* ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);
 		tmpCeTable[PQ::smoke()->classes[i].className] = ce_ptr;
 		// cache QObject



From tm243 at mail.berlios.de  Sat Jun  9 13:52:05 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Sat, 9 Jun 2007 13:52:05 +0200
Subject: [Php-qt-svn] r347 - trunk/tests
Message-ID: <200706091152.l59Bq5UU026838@sheep.berlios.de>

Author: tm243
Date: 2007-06-09 13:52:04 +0200 (Sat, 09 Jun 2007)
New Revision: 347

Added:
   trunk/tests/iquip.php
Log:
* added a test for iquip



Added: trunk/tests/iquip.php
===================================================================
--- trunk/tests/iquip.php	2007-06-09 11:40:05 UTC (rev 346)
+++ trunk/tests/iquip.php	2007-06-09 11:52:04 UTC (rev 347)
@@ -0,0 +1,16 @@
+<?php
+
+
+    class QApplication extends _QApplication
+    {
+    
+	public function __construct($argc, $argv){
+	    parent::__construct($argc, $argv);
+	}
+    
+    }
+
+    $app = new QApplication($argc, $argv);
+    $app->exec();
+
+?>
\ No newline at end of file



From tm243 at mail.berlios.de  Wed Jun 20 10:26:44 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 20 Jun 2007 10:26:44 +0200
Subject: [Php-qt-svn] r348 - in trunk: cmake/modules examples/calculator
	php_qt
Message-ID: <200706200826.l5K8QiBn018231@sheep.berlios.de>

Author: tm243
Date: 2007-06-20 10:26:43 +0200 (Wed, 20 Jun 2007)
New Revision: 348

Modified:
   trunk/cmake/modules/FindQwt.cmake
   trunk/examples/calculator/calculator.php
   trunk/examples/calculator/main.php
   trunk/php_qt/functions.cpp
   trunk/php_qt/handlers.cpp
   trunk/php_qt/marshall_basetypes.h
   trunk/php_qt/marshall_primitives.h
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/marshall_types.h
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/phpqt_internals.cpp
   trunk/php_qt/phpqt_internals.h
   trunk/php_qt/qstring.cpp
   trunk/php_qt/smokephp.cpp
Log:
* converted smokephp_object into a class
* added 'const' at some places
* solved a memory problem in virtual method calls



Modified: trunk/cmake/modules/FindQwt.cmake
===================================================================
--- trunk/cmake/modules/FindQwt.cmake	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/cmake/modules/FindQwt.cmake	2007-06-20 08:26:43 UTC (rev 348)
@@ -30,7 +30,7 @@
         PATHS /usr/local/qwt/lib /usr/local/lib /usr/lib
     )
 
-    IF (QWT_LIBRARY)
+    IF (QWT_LIBRARY AND QWT_INCLUDE_DIR)
 
         SET(QWT_LIBRARIES ${QWT_LIBRARY})
         SET(QWT_FOUND "YES")
@@ -43,17 +43,17 @@
             ENDIF(BUILD_SHARED_LIBS)
         ENDIF (CYGWIN)
 
-    ENDIF (QWT_LIBRARY)
+    ENDIF (QWT_LIBRARY AND QWT_INCLUDE_DIR)
 ENDIF(QT4_FOUND)
 
 IF (QWT_FOUND)
-  IF (NOT QWT_FIND_QUIETLY)
+  IF (NOT Qwt_FIND_QUIETLY)
     MESSAGE(STATUS "Found Qwt: ${QWT_LIBRARY}")
-  ENDIF (NOT QWT_FIND_QUIETLY)
+  ENDIF (NOT Qwt_FIND_QUIETLY)
 ELSE (QWT_FOUND)
-  IF (QWT_FIND_REQUIRED)
+  IF (Qwt_FIND_REQUIRED)
     MESSAGE(FATAL_ERROR "Could not find Qwt library")
-  ENDIF (QWT_FIND_REQUIRED)
+  ENDIF (Qwt_FIND_REQUIRED)
 ENDIF (QWT_FOUND)
 
 MARK_AS_ADVANCED(QWT_INCLUDE_DIR QWT_LIBRARY)

Modified: trunk/examples/calculator/calculator.php
===================================================================
--- trunk/examples/calculator/calculator.php	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/examples/calculator/calculator.php	2007-06-20 08:26:43 UTC (rev 348)
@@ -65,7 +65,7 @@
         function __construct()
         {
             parent::__construct();
-
+check_qobject($this);
             $this->pendingAdditiveOperator = new QString();
             $this->pendingMultiplicativeOperator = new QString();
 
@@ -149,7 +149,7 @@
 
         }
 
-/*        function eventFilter($target, $event){
+        function eventFilter($target, $event){
             if ($target == $display) {
                 if ($event->type() == QEvent::MouseButtonPress
                     || $event->type() == QEvent::MouseButtonDblClick
@@ -170,8 +170,8 @@
                     return true;
                 }
             }
-            return parent::eventFilter($target, $event);
-        }*/
+	    return parent::eventFilter($target, $event);
+        }
 
         function digitClicked()
         {

Modified: trunk/examples/calculator/main.php
===================================================================
--- trunk/examples/calculator/main.php	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/examples/calculator/main.php	2007-06-20 08:26:43 UTC (rev 348)
@@ -19,6 +19,7 @@
 
     $calc = new Calculator();
     $calc->show();
+
     $app->exec();
 
 ?>
\ No newline at end of file

Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/php_qt/functions.cpp	2007-06-20 08:26:43 UTC (rev 348)
@@ -645,7 +645,7 @@
 
 		cout << "\t       zval => " << zobject << endl;
 // 		cout << "\tclass entry => " << Z_OBJCE_P(zobject)->name << endl;
-		cout << "\tclass entry => " << o->ce_ptr->name << endl;
+		cout << "\tclass entry => " << o->ce_ptr()->name << endl;
 		cout << "\t  ref count => " << zobject->refcount << endl;
 		cout << "\t     is_ref => " << (int) zobject->is_ref << endl;
 		cout << "\t       type => " << printType(Z_TYPE_P(zobject)) << endl;
@@ -658,12 +658,12 @@
 		cout << endl;
 
 		cout << "\t      smokeobj => " << o << endl;
-		cout << "\t         Smoke => " << o->smoke << endl;
-		cout << "\t       classId => " << o->classId << endl;
-		cout << "\t        Qt ptr => " << o->ptr << endl;
-		cout << "\t        ce_ptr => " << o->ce_ptr << endl;
-		cout << "\t      zval_ptr => " << o->zval_ptr << endl;
-		cout << "\t  QMetaObject* => " << o->meta << endl;
+		cout << "\t         Smoke => " << o->smoke() << endl;
+		cout << "\t       classId => " << o->classId() << endl;
+		cout << "\t        Qt ptr => " << o->ptr() << endl;
+		cout << "\t        ce_ptr => " << o->ce_ptr() << endl;
+		cout << "\t      zval_ptr => " << o->zval_ptr() << endl;
+		cout << "\t  QMetaObject* => " << o->meta() << endl;
 
 		cout << ")" << endl;
 	}

Modified: trunk/php_qt/handlers.cpp
===================================================================
--- trunk/php_qt/handlers.cpp	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/php_qt/handlers.cpp	2007-06-20 08:26:43 UTC (rev 348)
@@ -47,12 +47,12 @@
 construct_copy(smokephp_object *o)
 {
 	const char *className;
-	if(o->classId > 0)
+	if(o->classId() > 0)
 	{
-		className = o->smoke->className(o->classId);
+		className = o->smoke()->className(o->classId());
 	} else {
 		// must be a qstring
-		return o->ptr;
+		return o->mPtr();
 	}
 
     int classNameLen = strlen(className);
@@ -60,23 +60,23 @@
     char *ccSig = new char[classNameLen + 2];       // copy constructor signature
     strcpy(ccSig, className);
     strcat(ccSig, "#");
-    Smoke::Index ccId = o->smoke->idMethodName(ccSig);
+    Smoke::Index ccId = o->smoke()->idMethodName(ccSig);
     delete[] ccSig;
     char *ccArg = new char[classNameLen + 8];
     sprintf(ccArg, "const %s&", className);
 
-    Smoke::Index ccMeth = o->smoke->findMethod(o->classId, ccId);
+    Smoke::Index ccMeth = o->smoke()->findMethod(o->classId(), ccId);
 
     if(!ccMeth) {
 		delete[] ccArg;
 		return 0;
     }
 
-    Smoke::Index method = o->smoke->methodMaps[ccMeth].method;
+    Smoke::Index method = o->smoke()->methodMaps[ccMeth].method;
     if(method > 0)
     {
 		// Make sure it's a copy constructor
-		if(!matches_arg(o->smoke, method, 0, ccArg)) {
+		if(!matches_arg(o->smoke(), method, 0, ccArg)) {
 				delete[] ccArg;
 			return 0;
 		}
@@ -85,13 +85,13 @@
     } else {
         // ambiguous method, pick the copy constructor
 		Smoke::Index i = -method;
-		while(o->smoke->ambiguousMethodList[i]) {
-			if(matches_arg(o->smoke, o->smoke->ambiguousMethodList[i], 0, ccArg))
+		while(o->smoke()->ambiguousMethodList[i]) {
+			if(matches_arg(o->smoke(), o->smoke()->ambiguousMethodList[i], 0, ccArg))
 			break;
 				i++;
 		}
         delete[] ccArg;
-		ccMeth = o->smoke->ambiguousMethodList[i];
+		ccMeth = o->smoke()->ambiguousMethodList[i];
 		if(!ccMeth)
 		{
 			return 0;
@@ -101,9 +101,9 @@
     // Okay, ccMeth is the copy constructor. Time to call it.
     Smoke::StackItem args[2];
     args[0].s_voidp = 0;
-    args[1].s_voidp = o->ptr;
-    Smoke::ClassFn fn = o->smoke->classes[o->classId].classFn;
-    (*fn)(o->smoke->methods[ccMeth].method, 0, args);
+    args[1].s_voidp = o->mPtr();
+    Smoke::ClassFn fn = o->smoke()->classes[o->classId()].classFn;
+    (*fn)(o->smoke()->methods[ccMeth].method, 0, args);
     return args[0].s_voidp;
 }
 

Modified: trunk/php_qt/marshall_basetypes.h
===================================================================
--- trunk/php_qt/marshall_basetypes.h	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/php_qt/marshall_basetypes.h	2007-06-20 08:26:43 UTC (rev 348)
@@ -89,21 +89,23 @@
 template <>
 static void marshall_from_php<SmokeClassWrapper>(Marshall *m)
 {
-	zval* v = m->var();
+	zval* zval_ptr = m->var();
 
-	if(v == NULL) {
+	if(zval_ptr == NULL) {
 		m->item().s_class = 0;
 		return;
 	}
 
-	if(!/*SmokePHPObjectExists*/(v)) {
-		check_qobject(v);
-		php_error(E_ERROR, "Invalid type, expecting %s, %s given (probably PHP-Qt lost the Qt object)\n", m->type().name(), Z_OBJCE_P(v)->name);
+	if(!PHPQt::SmokePHPObjectExists(zval_ptr)) {
+		check_qobject(zval_ptr);
+// 		php_error(E_ERROR, "Invalid type, expecting %s, %s given (probably PHP-Qt lost the Qt object)\n", m->type().name(), Z_OBJCE_P(zval_ptr)->name);
+		php_error(E_ERROR, "Invalid type, expecting %s (probably PHP-Qt lost the Qt object)\n", m->type().name());
 		return;
 	}
 
-	smokephp_object *o = PHPQt::getSmokePHPObjectFromZval(v);
-	if(!o || !o->ptr) {
+	smokephp_object *o = PHPQt::getSmokePHPObjectFromZval(zval_ptr);
+
+	if(!o || !o->ptr()) {
 		if(m->type().isRef()) {
 			php_error(E_WARNING, "References can't be nil\n");
 			m->unsupported();
@@ -113,22 +115,22 @@
 		return;
 	}
 
-	void *ptr = o->ptr;
+	void *ptr = o->mPtr();
 
 //	if((!m->cleanup() && m->type().isStack())) {
 	if(m->type().isRef()){
 		ptr = construct_copy(o);
 #ifdef DEBUG
-			php_error(E_WARNING, "copying %s %p to %p\n", resolve_classname(o->smoke, o->classId, o->ptr), o->ptr, ptr);
+			php_error(E_WARNING, "copying %s %p to %p\n", resolve_classname(o->smoke(), o->classId(), o->ptr(), o->ptr(), ptr);
 #endif
 	}
 
 	const Smoke::Class &cl = m->smoke()->classes[m->type().classId()];
 
-	ptr = o->smoke->cast(
+	ptr = o->smoke()->cast(
 		ptr,				// pointer
-		o->classId,			// from
-		o->smoke->idClass(cl.className)	// to
+		o->classId(),			// from
+		o->smoke()->idClass(cl.className)	// to
 		);
 
 	m->item().s_class = ptr;
@@ -154,11 +156,10 @@
 			// prepare the return value
 			smokephp_object* o = PHPQt::createOriginal(m->var(), p);
 			// overwrite the old one:
-			*(m->return_value_ptr()) = o->zval_ptr;
+			*(m->return_value_ptr()) = const_cast<zval*>(o->zval_ptr());
 
 			if(!strcmp(m->identifier, "VirtualMethodCall")){
-				// its a copy, not the original but well
-				ZVAL_ZVAL(((VirtualMethodCall*)m)->object(), o->zval_ptr, 0, 1);
+				((VirtualMethodCall*)m)->var(*m->return_value_ptr());
 			}
 		}
 		return;
@@ -185,29 +186,36 @@
 	    } else {
 			_ce = zend_fetch_class(__className, __strLenClassName, ZEND_FETCH_CLASS_AUTO TSRMLS_DC);
 	    }
+		smokephp_object *o;
+		if(!strcmp(m->identifier, "VirtualMethodCall")){
+			zval* z = (zval*) emalloc(sizeof(zval));
+// 			zval* z = (zval*) alloca(sizeof(zval));
+			((VirtualMethodCall*) m)->var(z);
+			o = PHPQt::createObject(m->var(), __p, _ce, m->type().classId());
+			m->var()->refcount--;
+		} else
+		/*smokephp_object **/o = PHPQt::createObject(m->var(), __p, _ce, m->type().classId());
 
-		smokephp_object *o = PHPQt::createObject(m->var(), __p, _ce, m->type().classId());
-
 //	    if(m->type().isConst() && m->type().isRef()) {
 	    if(m->type().isRef())
 	    {
 			p = construct_copy( o );
 #ifdef DEBUG
-			const char * classname = o->ce_ptr->name;
-			php_error(E_WARNING, "copying %s %p to %p\n", classname, o->ptr, p);
+			const char * classname = o->ce_ptr()->name;
+			php_error(E_WARNING, "copying %s %p to %p\n", classname, o->ptr(), p);
 #endif
 			if(p) {
-				o->ptr = p;
-				o->allocated = true;
+				o->setPtr(p);
+				o->setAllocated(true);
 			}
 		}
 
 #ifdef DEBUG
-		php_error(E_WARNING, "allocating %s %p -> %p\n", __className, o->ptr, (void*)m->var());
+		php_error(E_WARNING, "allocating %s %p -> %p\n", __className, o->ptr(), (void*)m->var());
 #endif
 
 		if(m->type().isStack()) {
-			o->allocated = true;
+			o->setAllocated(true);
 		}
 
 	} // smokephp_object p doesn't exist

Modified: trunk/php_qt/marshall_primitives.h
===================================================================
--- trunk/php_qt/marshall_primitives.h	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/php_qt/marshall_primitives.h	2007-06-20 08:26:43 UTC (rev 348)
@@ -209,7 +209,7 @@
 {
 	if(rv == Qnil)
 		return 0;
-	
+
 	int len = rv->value.str.len;
 	char* mem = (char*) malloc(len+1);
 	memcpy(mem, rv->value.str.val, len);
@@ -246,7 +246,7 @@
 {
 	if(v == Qnil)
 		return 0;
-	
+
 	return (WId) Z_LVAL_P(v);
 }
 
@@ -262,7 +262,7 @@
 {
 	if(v == Qnil)
 		return 0;
-	
+
 	return (Q_PID) Z_LVAL_P(v);
 }
 

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/php_qt/marshall_types.cpp	2007-06-20 08:26:43 UTC (rev 348)
@@ -263,12 +263,6 @@
 	return _retval;
 }
 
-void
-MethodReturnValueBase::setVar(zval* zobj)
-{
-	_retval = zobj;
-}
-
 const char *
 MethodReturnValueBase::classname()
 {
@@ -285,11 +279,12 @@
  *	VirtualMethodReturnValue
  */
 
-VirtualMethodReturnValue::VirtualMethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval retval) :
-	MethodReturnValueBase(smoke,meth,stack,NULL), _retval2(retval)
+VirtualMethodReturnValue::VirtualMethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* retval) :
+	MethodReturnValueBase(smoke,meth,stack,NULL)//, _retval(retval)
 {
 	identifier = "VirtualMethodReturnValue";
-	_retval = &_retval2;
+// 	_retval = &_retval2;
+	_retval = retval;
 	Marshall::HandlerFn fn = getMarshallFn(type());
 	(*fn)(this);
 }
@@ -373,7 +368,6 @@
 		(*fn)(this);
 		_cur++;
 	}
-
 	callMethod();
 	_cur = oldcur;
 }
@@ -404,16 +398,16 @@
  */
 
 VirtualMethodCall::VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* obj, zval **sp, zval** return_value_ptr) :
-	MethodCallBase( smoke, meth, stack, return_value_ptr), _obj(obj)/*, _sp(sp)*/
+ 	MethodCallBase( smoke, meth, stack, return_value_ptr), _obj(obj)/*, _sp(sp)*/
 {
 	__sp = sp;
-	identifier = "VirtualMethodCall";
   	_args = _smoke->argumentList + method().args;
+  	 identifier = "VirtualMethodCall";
 }
 
 VirtualMethodCall::~VirtualMethodCall()
 {
-    delete[] _stack;
+//      delete[] _stack;
 }
 
 Marshall::Action
@@ -425,15 +419,13 @@
 zval*
 VirtualMethodCall::var()
 {
-	ZVAL_NULL(__sp[_cur]);
     return __sp[_cur];
 }
 
 zval*
-VirtualMethodCall::object()
+VirtualMethodCall::var(zval* zval_ptr)
 {
-	ZVAL_NULL(__sp[_cur]);
-	__sp[_cur]->type = IS_OBJECT;
+	__sp[_cur] = zval_ptr;
     return __sp[_cur];
 }
 
@@ -449,10 +441,8 @@
 	if (_called) return;
 	_called = true;
 
-	PHPQt::callPHPMethod(_obj, (char*) _smoke->methodNames[method().name], items(), __sp);
-
-	zval _retval;
- 	VirtualMethodReturnValue r(_smoke, _method, _stack, _retval);
+	zval* retval = PHPQt::callPHPMethod(_obj, (char*) _smoke->methodNames[method().name], items(), __sp);
+	VirtualMethodReturnValue r(_smoke, _method, _stack, retval);
 }
 
 bool
@@ -475,10 +465,10 @@
 		if (PHPQt::SmokePHPObjectExists(_target))
 		{
 			smokephp_object *o = PHPQt::getSmokePHPObjectFromZval(_target);
-			if (o && o->ptr)
+			if (o && o->ptr())
 			{
-				_current_object = o->ptr;
-				_current_object_class = o->classId;
+				_current_object = o->mPtr();
+				_current_object_class = o->classId();
 			}
 		}
 	} else {_target = (zval*) emalloc(sizeof(zval));}

Modified: trunk/php_qt/marshall_types.h
===================================================================
--- trunk/php_qt/marshall_types.h	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/php_qt/marshall_types.h	2007-06-20 08:26:43 UTC (rev 348)
@@ -50,7 +50,6 @@
 	bool cleanup();
 	void unsupported();
 	zval* var();
-	void setVar(zval* zobj);
 	zval** return_value_ptr();
 
 protected:
@@ -70,11 +69,11 @@
 
 class VirtualMethodReturnValue : public MethodReturnValueBase {
 public:
-	VirtualMethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval retval);
+	VirtualMethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* retval);
 	Marshall::Action action();
 
 private:
-	zval _retval2;
+// 	zval _retval2;
 };
 
 /**
@@ -132,7 +131,7 @@
 	~VirtualMethodCall();
 	Marshall::Action action();
 	zval* var();
-	zval* object();
+	zval* var(zval* zval_ptr);
 	int items();
 	void callMethod();
 	bool cleanup();

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/php_qt/php_qt.cpp	2007-06-20 08:26:43 UTC (rev 348)
@@ -33,7 +33,7 @@
 #include "marshall_types.h"
 #include "phpqt_internals.h"
 
-#define IQUIP
+// #define IQUIP
 
 #define DEBUG 1
 #define MOC_DEBUG 0
@@ -160,19 +160,19 @@
 ZEND_METHOD(php_qt_generic_class, __destruct)
 {
 	if(PHPQt::SmokePHPObjectExists(getThis())) {
+qDebug() << "destruct" << getThis();
 
  		smokephp_object *o = PHPQt::getSmokePHPObjectFromZval(getThis());
 
-		// its not a reference
+//		its not a reference
 		if(!PZVAL_IS_REF(getThis()))
 		{
-			o->allocated = false;
+			o->setAllocated(false);
 		}
 		if(!PHPQt::unmapSmokePHPObject(getThis()))
 		{
 			qFatal("try to unmap unregistered zval");
 		}
-
 	}
 }
 
@@ -188,6 +188,7 @@
 // 	    ce_parent = ce->parent;
 	    ce = ce->parent; // orig
     }
+    activeCe = ce;
 
     // get arguments
     int i, argc = ZEND_NUM_ARGS();
@@ -212,18 +213,18 @@
 
 	// smokephp_object is created above in c.next()
     smokephp_object* o = PHPQt::getSmokePHPObjectFromZval(getThis());
-    o->parent_ce_ptr = ce_parent; // = ce if no parent
+    o->setParentCePtr(ce_parent); // = ce if no parent
 
 	// if QObject
 	if(smokephp_isQObject(PQ::smoke()->idClass(ce->name))){
 
 		// fetch superdata
-		Smoke::Index nameId = o->smoke->idMethodName("metaObject");
-		Smoke::Index meth = o->smoke->findMethod(o->classId, nameId);
-		Smoke::Method &methodId = o->smoke->methods[o->smoke->methodMaps[meth].method];
-		Smoke::ClassFn fn = o->smoke->classes[methodId.classId].classFn;
+		Smoke::Index nameId = o->smoke()->idMethodName("metaObject");
+		Smoke::Index meth = o->smoke()->findMethod(o->classId(), nameId);
+		Smoke::Method &methodId = o->smoke()->methods[o->smoke()->methodMaps[meth].method];
+		Smoke::ClassFn fn = o->smoke()->classes[methodId.classId].classFn;
 		Smoke::StackItem i[1];
-		(*fn)(methodId.method, o->ptr, i);
+		(*fn)(methodId.method, const_cast<void*>(o->ptr()), i);
 		QMetaObject *superdata = (QMetaObject *) i[0].s_voidp;
 
  		QString* phpqt_meta_stringdata = new QString("");
@@ -232,9 +233,9 @@
 		//	create the metaObject
 		if(PHPQt::getMocData(
 				getThis(),
-				o->parent_ce_ptr->name,
+				o->parent_ce_ptr()->name,
 				superdata,
-				o->meta,
+				o->meta(),
 				phpqt_meta_stringdata,
 				phpqt_meta_data
 		)){
@@ -243,11 +244,11 @@
 				{superdata, phpqt_meta_stringdata_,
 					phpqt_meta_data, 0}
  			};
- 			o->meta = (QMetaObject*) emalloc(sizeof(ob));
- 			memcpy(o->meta, &ob, sizeof(ob));
-
+ 			QMetaObject* m = (QMetaObject*) emalloc(sizeof(ob));
+ 			memcpy(m, &ob, sizeof(ob));
+			o->setMetaObject(m);
 		} else {
-			o->meta = superdata;
+			o->setMetaObject(superdata);
 		}
 
 	}
@@ -266,7 +267,6 @@
     zend_class_entry *ce;
     // nonstaticphp_qt_generic_class_proxyMethod
     if(getThis()){
-    	activeScope = getThis();
 		// if a parent:: call occurs this_ptr has the wrong ce, so we need to
 		// correct it here
 		if(parentCall)
@@ -274,9 +274,9 @@
 			ce = activeCe;
 			parentCall = false;
         } else {
+        	activeScope = getThis();
         	ce = Z_OBJCE_P(getThis());
         }
-
     // static
     } else {
 		ce = activeCe;
@@ -304,8 +304,8 @@
 	    // is it a signal?
 	    if(getThis()){
 		smokephp_object* o = PHPQt::getSmokePHPObjectFromZval(getThis());
-		if(o->meta != NULL){
-		    QMetaObject* mo = (QMetaObject*) o->meta;
+		if(o->meta() != NULL){
+		    QMetaObject* mo = (QMetaObject*) o->meta();
 		    QByteArray signalname(methodNameStack.top()->constData());
 		    signalname.replace("$","");
 		    signalname.replace("#","");
@@ -315,10 +315,10 @@
 		    // seems to be a signal
 		    int index = mo->indexOfSignal(signalname);
 		    if(index >= 0) {
-			QObject *qobj = (QObject*)o->smoke->cast(
-			    o->ptr,
-			    o->classId,
-			    o->smoke->idClass("QObject")
+			QObject *qobj = (QObject*)o->smoke()->cast(
+			    const_cast<void*>(o->ptr()),
+			    o->classId(),
+			    o->smoke()->idClass("QObject")
 			);
 			zval* result;
 			EmitSignal signal(qobj, index, argc, mocStack, args, result);
@@ -358,7 +358,6 @@
 			{
 				parentCall = true;
 				this_ptr = activeScope;
-//   				this_ptr->type = IS_OBJECT;
 			}
 		}
 	}

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/php_qt/php_qt.h	2007-06-20 08:26:43 UTC (rev 348)
@@ -45,6 +45,7 @@
 
 #include <QtCore/QString>
 #include <QtCore/QMetaObject>
+#include <QtCore/QDebug>
 
 // for older php versions
 #ifndef ZEND_MN
@@ -121,15 +122,43 @@
 void init_codec();
 zval* zstringFromQString(QString * s);
 
-struct smokephp_object {
-    bool allocated;
-    Smoke *smoke;
-    int classId;
-    void *ptr;
-    zend_class_entry *ce_ptr;
-    zend_class_entry *parent_ce_ptr;
-    zval *zval_ptr;
-    QMetaObject* meta;
+class smokephp_object {
+public:
+	inline explicit smokephp_object(Smoke* smoke, int classId, const void* ptr, const zend_class_entry* ce, zval* zval_ptr)
+		: 	m_smoke(smoke),
+			m_classId(classId),
+			m_ptr(ptr),
+			m_ce_ptr(ce),
+			m_parent_ce_ptr(ce),
+			m_zval_ptr(zval_ptr),
+			m_allocated(true)
+	{
+	}
+
+	inline const bool allocated() { return m_allocated; }
+	inline Smoke* smoke() { return m_smoke; }
+	inline const int classId() { return m_classId; }
+	inline const void* ptr() { return m_ptr; }
+	inline void* mPtr() { return const_cast<void*>(m_ptr); } // can be modified
+	inline const zend_class_entry* ce_ptr() { return m_ce_ptr; }
+	inline const zend_class_entry* parent_ce_ptr() { return m_parent_ce_ptr; }
+	inline const zval* zval_ptr() { return m_zval_ptr; }
+	inline QMetaObject* meta() { return m_meta; }
+
+	inline void setAllocated( bool allocated ) { m_allocated = allocated; }
+	inline void setParentCePtr(zend_class_entry* parent_ce_ptr) { m_parent_ce_ptr = parent_ce_ptr; }
+	inline void setMetaObject(QMetaObject* meta) { m_meta = meta; }
+	inline void setPtr(void* ptr) { m_ptr = ptr; }
+
+private:
+    bool m_allocated;
+    Smoke *m_smoke;
+    int m_classId;
+    const void *m_ptr;
+    const zend_class_entry *m_ce_ptr;
+    const zend_class_entry *m_parent_ce_ptr;
+    zval *m_zval_ptr;
+    QMetaObject* m_meta;
 };
 
 const char* 		printType(int type);

Modified: trunk/php_qt/phpqt_internals.cpp
===================================================================
--- trunk/php_qt/phpqt_internals.cpp	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/php_qt/phpqt_internals.cpp	2007-06-20 08:26:43 UTC (rev 348)
@@ -32,7 +32,7 @@
 extern zend_class_entry* qstring_ce;
 
 zend_class_entry* qobject_ce;
-QHash<void*, smokephp_object*> SmokeQtObjects;
+QHash<const void*, smokephp_object*> SmokeQtObjects;
 QHash<zend_object_handle, smokephp_object*> obj_x_smokephp;
 
 
@@ -43,7 +43,7 @@
 int
 PHPQt::metacall(smokephp_object* so, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a)
 {
-	QMetaObject* d = so->meta;
+	QMetaObject* d = so->meta();
 //	int offset = d->methodOffset();
 	int offset = d->methodCount();
 
@@ -54,23 +54,23 @@
 	// call the C++ one
 	if(_id < offset){
 		// find parent
-		Smoke::Index parent = so->smoke->inheritanceList[so->smoke->classes[so->classId].parents];
+		Smoke::Index parent = so->smoke()->inheritanceList[so->smoke()->classes[so->classId()].parents];
 
 		// methodId
-		Smoke::Index nameId = so->smoke->idMethodName("qt_metacall$$?");
-		Smoke::Index method = so->smoke->findMethod(so->classId, nameId);
+		Smoke::Index nameId = so->smoke()->idMethodName("qt_metacall$$?");
+		Smoke::Index method = so->smoke()->findMethod(so->classId(), nameId);
 
 		if(method > 0){
-			Smoke::Method &m = so->smoke->methods[so->smoke->methodMaps[method].method];
-			Smoke::ClassFn fn = so->smoke->classes[m.classId].classFn;
+			Smoke::Method &m = so->smoke()->methods[so->smoke()->methodMaps[method].method];
+			Smoke::ClassFn fn = so->smoke()->classes[m.classId].classFn;
 			Smoke::StackItem i[4];
 			i[1].s_enum = _c;
 			i[2].s_int = _id;
 			i[3].s_voidp = (void*) args[3].s_voidp;
-			(*fn)(m.method, so->ptr, i);
+			(*fn)(m.method, so->mPtr(), i);
 
 #if MOC_DEBUG
-			cout << "\tcall Qt method " << so->ce_ptr->name << "::" << PQ::smoke()->methodNames[method] << endl;
+			cout << "\tcall Qt method " << so->ce_ptr()->name << "::" << PQ::smoke()->methodNames[method] << endl;
 #endif
 
 			if((int)i[0].s_int < 0)
@@ -131,15 +131,15 @@
         }
 
 #if MOC_DEBUG
-    cout << "\tcall PHP method " << so->ce_ptr->name << "::" << method_name << endl;
+    cout << "\tcall PHP method " << so->ce_ptr()->name << "::" << method_name << endl;
 #endif
 
-         PHPQt::callPHPMethod(so->zval_ptr, method_name, j, *args);
+         PHPQt::callPHPMethod(so->zval_ptr(), method_name, j, *args);
 
     // is a signal
     } else {
         void *_b[] = { 0, _a[1] };
-        QMetaObject::activate((QObject*) so->ptr, d, 0, _b);
+        QMetaObject::activate((QObject*) so->ptr(), d, 0, _b);
     }
 
 	efree(method_name);
@@ -156,7 +156,7 @@
 }
 
 bool
-PHPQt::methodExists(zend_class_entry* ce_ptr, char* methodname)
+PHPQt::methodExists(const zend_class_entry* ce_ptr, const char* methodname)
 {
 
 	if(ce_ptr == NULL){
@@ -165,7 +165,7 @@
 
 	char* lcname = zend_str_tolower_dup(methodname, strlen(methodname));
 
-	if(zend_hash_exists(&ce_ptr->function_table, lcname, strlen(methodname)+1)){
+	if(zend_hash_exists(const_cast<HashTable*>(&ce_ptr->function_table), lcname, strlen(methodname)+1)){
 		return true;
 	}
 
@@ -176,7 +176,7 @@
 
 
 zval*
-PHPQt::callPHPMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args)
+PHPQt::callPHPMethod(const zval* this_ptr, char* methodName, zend_uint param_count, zval** args)
 {
 
 	if(this_ptr == NULL){
@@ -190,11 +190,17 @@
     zval* retval;
     MAKE_STD_ZVAL(retval);
 
-    if(call_user_function(EG(function_table),&this_ptr,function_name,retval,param_count,args) == FAILURE){
+    if(call_user_function(EG(function_table),(zval**) &this_ptr,function_name,retval,param_count,args) == FAILURE){
     	smokephp_object* o = PHPQt::getSmokePHPObjectFromZval(this_ptr);
-    	php_error(E_ERROR, "PHP-Qt could not call method %s::%s", o->ce_ptr->name, methodName);
+    	php_error(E_ERROR, "PHP-Qt could not call method %s::%s", o->ce_ptr()->name, methodName);
     }
 
+	// make sure we return the right object
+	if(PHPQt::SmokePHPObjectExists(retval)){
+		smokephp_object* o = PHPQt::getSmokePHPObjectFromZval(retval);
+		retval = const_cast<zval*>(o->zval_ptr());
+	}
+
     return retval;
 }
 
@@ -338,22 +344,22 @@
 }
 
 smokephp_object*
-PHPQt::getSmokePHPObjectFromZval(zval* this_ptr)
+PHPQt::getSmokePHPObjectFromZval(const zval* this_ptr)
 {
 
 	if(this_ptr == NULL){
-	  php_error(E_ERROR,"fatal: object does not exists and could not be fetched, %s",Z_OBJCE_P(this_ptr)->name);
+	  php_error(E_ERROR,"fatal: object does not exists and could not be fetched, %s",Z_OBJCE_P(const_cast<zval*>(this_ptr))->name);
 	}
 
 	// value.obj.handle
- 	return (smokephp_object*) obj_x_smokephp.value(this_ptr->value.obj.handle);
+ 	return obj_x_smokephp.value(this_ptr->value.obj.handle);
 
 }
 
 void*
-PHPQt::getQtObjectFromZval(zval* this_ptr){
+PHPQt::getQtObjectFromZval(const zval* this_ptr){
 	smokephp_object* o = getSmokePHPObjectFromZval(this_ptr);
-	return o->ptr;
+	return o->mPtr();
 }
 
 smokephp_object*
@@ -363,7 +369,7 @@
 
 void
 PHPQt::setSmokePHPObject(smokephp_object* o){
-	SmokeQtObjects.insert(o->ptr, o);
+	SmokeQtObjects.insert(o->ptr(), o);
 }
 
 bool
@@ -372,9 +378,9 @@
 }
 
 bool
-PHPQt::unmapSmokePHPObject(zval* o)
+PHPQt::unmapSmokePHPObject(zval* zvalue)
 {
-	return (bool) obj_x_smokephp.remove(o->value.obj.handle);
+	return (bool) obj_x_smokephp.remove(zvalue->value.obj.handle);
 }
 
 /**
@@ -382,7 +388,7 @@
  */
 
 smokephp_object*
-PHPQt::createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce, Smoke::Index classId){
+PHPQt::createObject(zval* zval_ptr, const void* ptr, const zend_class_entry* ce, const Smoke::Index classId){
 
 	Q_ASSERT (zval_ptr);
 	Q_ASSERT (ptr);
@@ -402,17 +408,9 @@
 	}
 
 	Z_TYPE_P(zval_ptr) = IS_OBJECT;
-	object_init_ex(zval_ptr, ce);
+	object_init_ex(zval_ptr, const_cast<zend_class_entry*>(ce));
+	smokephp_object* o = new smokephp_object(PQ::smoke(), classId, ptr, ce, zval_ptr);
 
-	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
-	o->allocated = true;
-	o->ptr = ptr;
-	o->zval_ptr = zval_ptr;
-	o->ce_ptr = ce;
-	o->parent_ce_ptr = ce;
- 	o->classId = classId;
-	o->smoke = PQ::smoke();
-
 	Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
 	setSmokePHPObject(o);
 	zval_add_ref(&zval_ptr);
@@ -432,7 +430,8 @@
 		Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
 		zval_x_smokephp.insert(zval_ptr, o);*/
 	Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
-	zval_ptr = o->zval_ptr;
+ 	zval_ptr = const_cast<zval*>(o->zval_ptr());
+
 	zval_add_ref(&zval_ptr);
 
 	return o;

Modified: trunk/php_qt/phpqt_internals.h
===================================================================
--- trunk/php_qt/phpqt_internals.h	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/php_qt/phpqt_internals.h	2007-06-20 08:26:43 UTC (rev 348)
@@ -32,14 +32,14 @@
 
 void 				destroyHashtable(zend_rsrc_list_entry *rsrc);
 
-zval* 				callPHPMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params);
-bool 				methodExists(zend_class_entry* ce_ptr, char* methodname);
+zval* 				callPHPMethod(const zval* zend_ptr, char* methodname, zend_uint param_count, zval** params);
+bool 				methodExists(const zend_class_entry* ce_ptr, const char* methodname);
 bool 				getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* metachar, QString* meta_stringdata, uint* signature);
 int					metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
 char*				checkForOperator(const char* fname);
 
-void* 				getQtObjectFromZval(zval* this_ptr);
-smokephp_object* 	getSmokePHPObjectFromZval(zval* this_ptr);
+void* 				getQtObjectFromZval(const zval* this_ptr);
+smokephp_object* 	getSmokePHPObjectFromZval(const zval* this_ptr);
 smokephp_object*	getSmokePHPObjectFromQt(void* QtPtr);
 void				setSmokePHPObject(smokephp_object* o);
 bool 				SmokePHPObjectExists(zval* this_ptr);
@@ -47,7 +47,7 @@
 
 bool				unmapSmokePHPObject(zval* o);
 
-smokephp_object*	createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL, Smoke::Index classId = 0);
+smokephp_object*	createObject(zval* zval_ptr, const void* ptr, const zend_class_entry* ce = NULL, const Smoke::Index classId = 0);
 smokephp_object*	createOriginal(zval* zval_ptr, void* ptr);
 
 } // namespace PHPQt

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/php_qt/qstring.cpp	2007-06-20 08:26:43 UTC (rev 348)
@@ -605,10 +605,10 @@
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 				smokephp_object *o = getSmokePHPObjectFromZval(z_0);
-				if(o->ce_ptr == qstring_ce){
-				    QString *QString_ptr = new QString(*((QString*) o->ptr));
+				if(o->ce_ptr() == qstring_ce){
+				    QString *QString_ptr = new QString(*((QString*) o->ptr()));
 				}
-				createObject(getThis(), (void*) o->ptr, o->ce_ptr);
+				createObject(getThis(), o->ptr(), o->ce_ptr());
 				RETURN_NULL();
 			}
 		}
@@ -621,7 +621,7 @@
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			    smokephp_object* o = getSmokePHPObjectFromZval(z_0);
 // TODO type checking
-    			    createObject(getThis(), o->ptr, o->ce_ptr);
+    			    createObject(getThis(), o->ptr(), o->ce_ptr());
 			    RETURN_NULL();
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
@@ -1067,7 +1067,7 @@
 	if (ZEND_NUM_ARGS() == 0){
 			QString *obj = (QString*) PHP_QT_FETCH();
 //			smokephp_object* o = PHP_QT_FETCH();
-//			QString *obj = (QString*) o->ptr;
+//			QString *obj = (QString*) o->ptr();
 			RETURN_STRING((char*) obj->toAscii().constData(), 1);
 	}
 }
@@ -2066,7 +2066,7 @@
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			    smokephp_object* o = getSmokePHPObjectFromZval(getThis());
 			    QString* obj_z_0 = (QString*) getQtObjectFromZval(z_0);
-			    QString* s = new QString(((QString*) o->ptr)->append((QString) *obj_z_0));
+			    QString* s = new QString(((QString*) o->ptr())->append((QString) *obj_z_0));
 			    createObject(return_value, s, qstring_ce, QSTRING_CLASSID);
 			    return;
 			}

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-06-09 11:52:04 UTC (rev 347)
+++ trunk/php_qt/smokephp.cpp	2007-06-20 08:26:43 UTC (rev 348)
@@ -41,7 +41,9 @@
 Smoke::Index connect4;
 Smoke::Index connect5;
 
-extern QHash<void*, smokephp_object*> SmokeQtObjects;
+extern QHash<const void*, smokephp_object*> SmokeQtObjects;
+extern zval* activeScope;
+extern zend_class_entry* activeCe;
 
 class PHPQtSmokeBinding : public SmokeBinding {
 
@@ -49,16 +51,16 @@
     PHPQtSmokeBinding(Smoke *s) : SmokeBinding(s) {}
 
     virtual void deleted(Smoke::Index classId, void* ptr) {
-        qDebug("deleted");
+qDebug("deleted");
         if(PHPQt::SmokePHPObjectExists(ptr)){
 			smokephp_object *o = (smokephp_object*) PHPQt::getSmokePHPObjectFromQt(ptr);
-			if(!o->allocated){
+			if(!o->allocated()){
 				delete (QObject*) ptr;
 				efree(o);
 			} else {
-				o->ptr = 0;
+				o->setPtr(0);
 			}
-			SmokeQtObjects.remove(o->ptr);
+			SmokeQtObjects.remove(o->ptr());
 		}
     }
     virtual bool callMethod(Smoke::Index method, void* QtPtr, Smoke::Stack args, bool /*isAbstract*/) {
@@ -74,7 +76,7 @@
 
 		// metaobjects
 		if(!strcmp(methodName, "metaObject")){
-			args[0].s_class = o->meta;
+			args[0].s_class = o->meta();
 			return true;
 		}
 
@@ -83,11 +85,15 @@
 			return true;
 		}
 
-		if(PHPQt::methodExists(o->ce_ptr, (char*) methodName)){
-// 			zval* zmem = ALLOCA_N(zval, smoke->methods[method].numArgs);
-			zval* zmem = (zval*) safe_emalloc(sizeof(zval), smoke->methods[method].numArgs,0);
-		    VirtualMethodCall c(smoke, method, args, o->zval_ptr, &zmem, &o->zval_ptr);
+		if(PHPQt::methodExists(o->ce_ptr(), (char*) methodName)){
+			activeScope = const_cast<zval*>(o->zval_ptr());
+			activeCe = Z_OBJCE_P(activeScope);
+
+			zval* zmem = ALLOCA_N(zval, smoke->methods[method].numArgs);
+// 			zval* zmem = (zval*) safe_emalloc(sizeof(zval), smoke->methods[method].numArgs,0);
+		    VirtualMethodCall c(smoke, method, args, activeScope, &zmem, &activeScope);
 			c.next();
+ 			return true;
 		}
 
 		return false;
@@ -280,8 +286,8 @@
  			e_arrayv[e_arrayc++] = (void*) Z_BVAL_PP(val);
  			break;
  		case IS_OBJECT:
- 			e_arrayv[e_arrayc] = emalloc(sizeof(o->ptr));
- 			e_arrayv[e_arrayc++] = o->ptr;
+ 			e_arrayv[e_arrayc] = emalloc(sizeof(o->ptr()));
+ 			e_arrayv[e_arrayc++] = const_cast<void*>(o->ptr());
  			break;
 		default:
 			php_error(E_ERROR, "PHP-Qt: unsupported array type %d", type);
@@ -400,7 +406,7 @@
 		    mocStack[i+1].argType = xmoc_QString;
 		else {
 		    smokephp_object *o = PHPQt::getSmokePHPObjectFromZval((zval*) *argv[i]);
-		    mocStack[i+1].st = SmokeType(PQ::smoke(),o->classId);
+		    mocStack[i+1].st = SmokeType(PQ::smoke(),o->classId());
 		    mocStack[i+1].argType = xmoc_void;
 		}
 		signature->append("object");



From tm243 at mail.berlios.de  Wed Jun 20 10:40:44 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 20 Jun 2007 10:40:44 +0200
Subject: [Php-qt-svn] r349 - trunk/php_qt
Message-ID: <200706200840.l5K8eiif019711@sheep.berlios.de>

Author: tm243
Date: 2007-06-20 10:40:43 +0200 (Wed, 20 Jun 2007)
New Revision: 349

Modified:
   trunk/php_qt/handlers.cpp
   trunk/php_qt/marshall_types.cpp
Log:
* cleaning up



Modified: trunk/php_qt/handlers.cpp
===================================================================
--- trunk/php_qt/handlers.cpp	2007-06-20 08:26:43 UTC (rev 348)
+++ trunk/php_qt/handlers.cpp	2007-06-20 08:40:43 UTC (rev 349)
@@ -303,7 +303,6 @@
 		case Marshall::ToZVAL:
 		{
 			QString* s = static_cast<QString*>(m->item().s_voidp);
-// 			zval* obj = m->var();
 			PHPQt::createObject(m->var(), (void*) s, qstring_ce, -1);
 		}
 		break;

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-06-20 08:26:43 UTC (rev 348)
+++ trunk/php_qt/marshall_types.cpp	2007-06-20 08:40:43 UTC (rev 349)
@@ -280,10 +280,10 @@
  */
 
 VirtualMethodReturnValue::VirtualMethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* retval) :
-	MethodReturnValueBase(smoke,meth,stack,NULL)//, _retval(retval)
+	MethodReturnValueBase(smoke,meth,stack,NULL)
 {
 	identifier = "VirtualMethodReturnValue";
-// 	_retval = &_retval2;
+
 	_retval = retval;
 	Marshall::HandlerFn fn = getMarshallFn(type());
 	(*fn)(this);
@@ -407,7 +407,6 @@
 
 VirtualMethodCall::~VirtualMethodCall()
 {
-//      delete[] _stack;
 }
 
 Marshall::Action
@@ -477,7 +476,7 @@
     _items = _smoke->methods[_method].numArgs;
 
     _stack = new Smoke::StackItem[items + 1];
-// 	_retval = retval;
+
 }
 
 MethodCall::~MethodCall()



From tm243 at mail.berlios.de  Wed Jun 20 10:44:54 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 20 Jun 2007 10:44:54 +0200
Subject: [Php-qt-svn] r350 - trunk/tests
Message-ID: <200706200844.l5K8isYV019958@sheep.berlios.de>

Author: tm243
Date: 2007-06-20 10:44:54 +0200 (Wed, 20 Jun 2007)
New Revision: 350

Added:
   trunk/tests/testVirtual.php
Log:
* added test for virtual method calls



Added: trunk/tests/testVirtual.php
===================================================================
--- trunk/tests/testVirtual.php	2007-06-20 08:40:43 UTC (rev 349)
+++ trunk/tests/testVirtual.php	2007-06-20 08:44:54 UTC (rev 350)
@@ -0,0 +1,31 @@
+<?php
+
+
+    class myWidget extends QWidget
+    {
+	public function __construct()
+	{
+	    parent::__construct();
+	}
+	
+	public function sizeHint()
+	{
+	    echo "my own sizeHint\n";
+	    return parent::sizeHint();
+	}
+	
+    }
+
+    $app = new QApplication($argc, $argv);
+    
+    $m = new myWidget();
+    
+    for( $i = 0; $i < 10; $i++ )
+    {
+      $m->show();
+      $m->hide();
+    }
+    
+    $app->exec();
+
+?>
\ No newline at end of file



From tm243 at mail.berlios.de  Wed Jun 20 11:32:30 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 20 Jun 2007 11:32:30 +0200
Subject: [Php-qt-svn] r351 - trunk/tests
Message-ID: <200706200932.l5K9WUBU023088@sheep.berlios.de>

Author: tm243
Date: 2007-06-20 11:32:29 +0200 (Wed, 20 Jun 2007)
New Revision: 351

Modified:
   trunk/tests/QtBasicTestCase.php
Log:
* added unittest for virtual method calls



Modified: trunk/tests/QtBasicTestCase.php
===================================================================
--- trunk/tests/QtBasicTestCase.php	2007-06-20 08:44:54 UTC (rev 350)
+++ trunk/tests/QtBasicTestCase.php	2007-06-20 09:32:29 UTC (rev 351)
@@ -49,6 +49,20 @@
 	
     }
 
+    class myWidget extends QWidget
+    {
+	public function __construct()
+	{
+	    parent::__construct();
+	}
+	
+	public function sizeHint()
+	{
+	  echo ".";
+	    return parent::sizeHint();
+	}
+	
+    }
 
 
     class QtBasicTestCase extends PHPUnit_Framework_TestCase {
@@ -236,6 +250,23 @@
 	    echo " passed";
 	}
 
+      function testVirtualMethodCall()
+      {
+	echo "\ntesting virtual method call 'sizeHint()' in a loop: ";
+	$argc=1;
+	$argv=array("argv");
+	$app = new QApplication($argc, $argv);
+    
+	$m = new myWidget();
+    
+	for( $i = 0; $i < 10; $i++ )
+	  {
+	    $m->show();
+	    $m->hide();
+	  }
+	echo " passed";
+      }
+
     }    
     
 ?>
\ No newline at end of file



