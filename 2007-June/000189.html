<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Php-qt-svn] r345 - in trunk: examples/calculator kalyptus php_qt	smoke smoke/web
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/php-qt-svn/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r345%20-%20in%20trunk%3A%20examples/calculator%20kalyptus%20php_qt%0A%09smoke%20smoke/web&In-Reply-To=%3C200706081351.l58Dp11b008147%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000188.html">
   <LINK REL="Next"  HREF="000190.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Php-qt-svn] r345 - in trunk: examples/calculator kalyptus php_qt	smoke smoke/web</H1>
    <B>tm243 at BerliOS</B> 
    <A HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r345%20-%20in%20trunk%3A%20examples/calculator%20kalyptus%20php_qt%0A%09smoke%20smoke/web&In-Reply-To=%3C200706081351.l58Dp11b008147%40sheep.berlios.de%3E"
       TITLE="[Php-qt-svn] r345 - in trunk: examples/calculator kalyptus php_qt	smoke smoke/web">tm243 at mail.berlios.de
       </A><BR>
    <I>Fri Jun  8 15:51:01 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000188.html">[Php-qt-svn] r344 - trunk
</A></li>
        <LI>Next message: <A HREF="000190.html">[Php-qt-svn] r346 - trunk/php_qt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#189">[ date ]</a>
              <a href="thread.html#189">[ thread ]</a>
              <a href="subject.html#189">[ subject ]</a>
              <a href="author.html#189">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tm243
Date: 2007-06-08 15:50:59 +0200 (Fri, 08 Jun 2007)
New Revision: 345

Added:
   trunk/kalyptus/kalyptusCxxToWebSmoke.pm
   trunk/smoke/web/
   trunk/smoke/web/CMakeLists.txt
   trunk/smoke/web/Makefile.am
   trunk/smoke/web/Makefile.in
   trunk/smoke/web/configure.in.in
   trunk/smoke/web/generate.pl.cmake
   trunk/smoke/web/generate.pl.in
   trunk/smoke/web/generate_makefile_am.pl
   trunk/smoke/web/header_list
   trunk/smoke/web/hint_header_list.pl
   trunk/smoke/web/qscintilla2_header_list
   trunk/smoke/web/qscintilla_header_list
   trunk/smoke/web/qt_smoke.h
   trunk/smoke/web/qtdbus_header_list
   trunk/smoke/web/qtguess.pl.cmake
   trunk/smoke/web/qtguess.pl.in
   trunk/smoke/web/qwt_header_list
   trunk/smoke/web/smokeqt.pro
Modified:
   trunk/examples/calculator/calculator.php
   trunk/kalyptus/kalyptus
   trunk/php_qt/CMakeLists.txt
   trunk/smoke/CMakeLists.txt
Log:
* websmoke implemented



Modified: trunk/examples/calculator/calculator.php
===================================================================
--- trunk/examples/calculator/calculator.php	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/examples/calculator/calculator.php	2007-06-08 13:50:59 UTC (rev 345)
@@ -149,7 +149,7 @@
 
         }
 
-        function eventFilter($target, $event){
+/*        function eventFilter($target, $event){
             if ($target == $display) {
                 if ($event-&gt;type() == QEvent::MouseButtonPress
                     || $event-&gt;type() == QEvent::MouseButtonDblClick
@@ -169,9 +169,9 @@
                     }
                     return true;
                 }
-            }//check_qobject($target);
+            }
             return parent::eventFilter($target, $event);
-        }
+        }*/
 
         function digitClicked()
         {

Modified: trunk/kalyptus/kalyptus
===================================================================
--- trunk/kalyptus/kalyptus	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/kalyptus/kalyptus	2007-06-08 13:50:59 UTC (rev 345)
@@ -109,7 +109,7 @@
 # Supported formats
 %formats = ( &quot;java&quot; =&gt; &quot;kalyptusCxxToJava&quot;, &quot;jni&quot; =&gt; &quot;kalyptusCxxToJNI&quot;, 
 	&quot;dcopidl&quot; =&gt; &quot;kalyptusCxxToDcopIDL&quot;,
-	&quot;smoke&quot; =&gt; &quot;kalyptusCxxToSmoke&quot;, &quot;csharp&quot; =&gt; &quot;kalyptusCxxToCSharp&quot;, &quot;kimono&quot; =&gt; &quot;kalyptusCxxToKimono&quot;,
+	&quot;smoke&quot; =&gt; &quot;kalyptusCxxToSmoke&quot;, &quot;websmoke&quot; =&gt; &quot;kalyptusCxxToWebSmoke&quot;,&quot;csharp&quot; =&gt; &quot;kalyptusCxxToCSharp&quot;, &quot;kimono&quot; =&gt; &quot;kalyptusCxxToKimono&quot;,
         &quot;ECMA&quot; =&gt; &quot;kalyptusCxxToECMA&quot;, &quot;swig&quot; =&gt; &quot;kalyptusCxxToSwig&quot;,
 		&quot;KDOMECMA&quot; =&gt; &quot;kalyptusKDOMEcma&quot;);
 

Added: trunk/kalyptus/kalyptusCxxToWebSmoke.pm
===================================================================
--- trunk/kalyptus/kalyptusCxxToWebSmoke.pm	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/kalyptus/kalyptusCxxToWebSmoke.pm	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,2895 @@
+#***************************************************************************
+#            kalyptusCxxToSmoke.pm -  Generates x_*.cpp files for smoke
+#                             -------------------
+#    begin                : Fri Jan 25 12:00:00 2000
+#    copyright            : (C) 2002 Lost Highway Ltd. All Rights Reserved.
+#    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">david at mandrakesoft.com</A>
+#    author               : David Faure.
+#***************************************************************************/
+
+#/***************************************************************************
+# *                                                                         *
+# *   This program is free software; you can redistribute it and/or modify  *
+# *   it under the terms of the GNU General Public License as published by  *
+# *   the Free Software Foundation; either version 2 of the License, or     *
+# *   (at your option) any later version.                                   *
+# *                                                                         *
+#***************************************************************************/
+
+package kalyptusCxxToWebSmoke;
+
+use File::Path;
+use File::Basename;
+use constant numSourceFiles =&gt; 20; # Total number of generated source files.
+                                   # All classes will be distributed across those.
+
+use Carp;
+use Ast;
+use kdocAstUtil;
+use kdocUtil;
+use Iter;
+use kalyptusDataDict;
+
+use strict;
+no strict &quot;subs&quot;;
+
+use vars qw/
+	$libname $rootnode $outputdir $opt $debug
+	$methodNumber $headerSubdirectories
+	%builtins %typeunion %allMethods %allTypes %enumValueToType %typedeflist %mungedTypeMap
+	%skippedClasses /;
+
+BEGIN
+{
+
+# Types supported by the StackItem union
+# Key: C++ type  Value: Union field of that type
+%typeunion = (
+    'void*' =&gt; 's_voidp',
+    'bool' =&gt; 's_bool',
+    'char' =&gt; 's_char',
+    'uchar' =&gt; 's_uchar',
+    'short' =&gt; 's_short',
+    'ushort' =&gt; 's_ushort',
+    'int' =&gt; 's_int',
+    'uint' =&gt; 's_uint',
+    'long' =&gt; 's_long',
+    'ulong' =&gt; 's_ulong',
+    'float' =&gt; 's_float',
+    'double' =&gt; 's_double',
+    'enum' =&gt; 's_enum',
+    'class' =&gt; 's_class'
+);
+
+# Mapping for iterproto, when making up the munged method names
+%mungedTypeMap = (
+     'QString' =&gt; '$',
+     'QString*' =&gt; '$',
+     'QString&amp;' =&gt; '$',
+     'QCString' =&gt; '$',
+     'QCString*' =&gt; '$',
+     'QCString&amp;' =&gt; '$',
+     'char*' =&gt; '$',
+     'QCOORD*' =&gt; '?',
+     'QRgb*' =&gt; '?',
+     'Q_UINT64' =&gt; '$',
+     'Q_INT64' =&gt; '$',
+     'Q_LLONG' =&gt; '$',
+     'quint64' =&gt; '$',
+     'qint64' =&gt; '$',
+     'long long' =&gt; '$',
+     'qlonglong' =&gt; '$',
+     'qulonglong' =&gt; '$',
+     'WId' =&gt; '$',
+     'Q_PID' =&gt; '$',
+);
+
+# Yes some of this is in kalyptusDataDict's ctypemap
+# but that one would need to be separated (builtins vs normal classes)
+%typedeflist =
+(
+   'signed char' =&gt; 'char',
+   'unsigned char' =&gt; 'uchar',
+   'signed short' =&gt; 'short',
+   'unsigned short' =&gt; 'ushort',
+   'signed' =&gt; 'int',
+   'signed int' =&gt; 'int',
+   'unsigned' =&gt; 'uint',
+   'unsigned int' =&gt; 'uint',
+   'signed long' =&gt; 'long',
+   'unsigned long' =&gt; 'ulong',
+
+# Anything that is not known is mapped to void*, so no need for those here anymore
+#   'QWSEvent*'  =&gt;  'void*',
+#   'QDiskFont*'  =&gt;  'void*',
+#   'XEvent*'  =&gt;  'void*',
+#   'QStyleHintReturn*'  =&gt;  'void*',
+#   'FILE*'  =&gt;  'void*',
+#   'QUnknownInterface*'  =&gt;  'void*',
+#   'GDHandle'  =&gt;  'void*',
+#   '_NPStream*'  =&gt;  'void*',
+#   'QTextFormat*'  =&gt;  'void*',
+#   'QTextDocument*'  =&gt;  'void*',
+#   'QTextCursor*'  =&gt;  'void*',
+#   'QTextParag**'  =&gt;  'void*',
+#   'QTextParag*'  =&gt;  'void*',
+#   'QRemoteInterface*'  =&gt;  'void*',
+#   'QSqlRecordPrivate*'  =&gt;  'void*',
+#   'QTSMFI'  =&gt;  'void*', # QTextStream's QTSManip
+#   'const GUID&amp;'  =&gt;  'void*',
+#   'QWidgetMapper*'  =&gt;  'void*',
+   'MSG*'  =&gt;  'void*',
+#   'const QSqlFieldInfoList&amp;'  =&gt;  'void*', # QSqlRecordInfo - TODO (templates)
+
+   'QPtrCollection::Item'  =&gt;  'void*', # to avoid a warning
+
+   'void(* )()'  =&gt;  'void*',
+   'void (*)(void* )'  =&gt;  'void*',
+   'mode_t'  =&gt;  'long',
+   'QProcess::PID'  =&gt;  'long',
+   'size_type'  =&gt;  'int', # QSqlRecordInfo
+   'Qt::ComparisonFlags'  =&gt;  'uint',
+   'Qt::ToolBarDock'  =&gt;  'int', # compat thing, Qt shouldn't use it
+   'QIODevice::Offset'  =&gt;  'ulong',
+   'WState'  =&gt;  'int',
+   'QRgb'  =&gt;  'uint',
+   'ksocklen_t' =&gt; 'uint',
+   'QCOORD'  =&gt;  'int',
+   'QTSMFI'  =&gt;  'int',
+   'Qt::WState'  =&gt;  'int',
+   'Qt::WFlags'  =&gt;  'int',
+   'Qt::HANDLE' =&gt; 'uint',
+   'QEventLoop::ProcessEventsFlags' =&gt; 'uint',
+   'QStyle::SCFlags' =&gt; 'int',
+   'QStyle::SFlags' =&gt; 'int',
+   'Q_INT16' =&gt; 'short',
+   'qint16' =&gt; 'short',
+   'Q_INT32' =&gt; 'int',
+   'qint32' =&gt; 'int',
+   'qint32&amp;' =&gt; 'int&amp;',
+   'Q_INT8' =&gt; 'char',
+   'qint8' =&gt; 'char',
+   'Q_LONG' =&gt; 'long',
+   'Q_UINT16' =&gt; 'ushort',
+   'quint16' =&gt; 'ushort',
+   'Q_UINT32' =&gt; 'uint',
+   'quint32' =&gt; 'uint',
+   'Q_UINT8' =&gt; 'uchar',
+   'quint8' =&gt; 'uchar',
+   'Q_ULONG' =&gt; 'long',
+   'qreal' =&gt; 'double',
+   'pid_t' =&gt; 'int',
+   'size_t' =&gt; 'int',
+   'pid_t' =&gt; 'int',
+   'time_t' =&gt; 'int',
+   'short int' =&gt; 'short',
+   'signed long int' =&gt; 'long',
+   'unsigned long int' =&gt; 'ulong',
+   'unsigned short int' =&gt; 'ushort',
+   'Qt::Alignment' =&gt; 'int',
+   'Qt::Orientations' =&gt; 'int',
+   'Qt::DockWidgetAreas' =&gt; 'int',
+   'Qt::DropActions' =&gt; 'int',
+   'Qt::ImageConversionFlags' =&gt; 'int',
+   'Qt::ItemFlags' =&gt; 'int',
+   'Qt::KeyboardModifiers' =&gt; 'int',
+   'Qt::MatchFlags' =&gt; 'int',
+   'Qt::MouseButtons' =&gt; 'int',
+   'Qt::ToolBarAreas' =&gt; 'int',
+   'Qt::WindowFlags' =&gt; 'int',
+   'Qt::WindowStates' =&gt; 'int',
+   'AutoFormatting' =&gt; 'int',
+   'DirtyFlags' =&gt; 'int',
+   'EditTriggers' =&gt; 'int',
+   'FindFlags' =&gt; 'int',
+   'Flags' =&gt; 'int',
+   'FormattingOptions' =&gt; 'int',
+   'GLenum' =&gt; 'int',
+   'GLint' =&gt; 'int',
+   'GLuint' =&gt; 'uint',
+   'LoadOperator' =&gt; 'int',
+   'NumberFlags' =&gt; 'int',
+   'OpenMode' =&gt; 'int',
+   'Options' =&gt; 'int',
+   'PaintEngineFeatures' =&gt; 'int',
+   'Permissions' =&gt; 'int',
+   'PrintDialogOptions' =&gt; 'int',
+   'ProcessEventsFlags' =&gt; 'int',
+   'QDir::Filters' =&gt; 'int',
+   'QDir::SortFlags' =&gt; 'int',
+   'QFile::Permissions' =&gt; 'int',
+   'QGL::FormatOptions' =&gt; 'int',
+   'QIODevice::OpenMode' =&gt; 'int',
+   'QImageReader::ImageReaderError' =&gt; 'int',
+   'QItemSelectionModel::SelectionFlags' =&gt; 'int',
+   'QPaintEngine::DirtyFlags' =&gt; 'int',
+   'QPainter::RenderHints' =&gt; 'int',
+   'QSql::ParamType' =&gt; 'int',
+   'QTextDocument::FindFlags' =&gt; 'int',
+   'Qt::DropActions' =&gt; 'int',
+   'Qt::ImageConversionFlags' =&gt; 'int',
+   'Qt::ItemFlags' =&gt; 'int',
+   'Qt::KeyboardModifiers' =&gt; 'int',
+   'Qt::MatchFlags' =&gt; 'int',
+   'Qt::MouseButtons' =&gt; 'int',
+   'Qt::ToolBarAreas' =&gt; 'int',
+   'Qt::WindowFlags' =&gt; 'int',
+   'Qt::WindowStates' =&gt; 'int',
+   'RenderFlags' =&gt; 'int',
+   'RenderHints' =&gt; 'int',
+   'SortFlags' =&gt; 'int',
+   'StepEnabled' =&gt; 'int',
+   'Sections' =&gt; 'int',
+   'Filters' =&gt; 'int',
+   'SortFlags' =&gt; 'int',
+   'QDir::Filters' =&gt; 'int',
+   'QDir::SortFlags' =&gt; 'int',
+   'QStyle::State' =&gt; 'int',
+   'QValidator::State' =&gt; 'int',
+   'QAbstractSpinBox::StepEnabled' =&gt; 'int',
+   'QDockWidget::DockWidgetFeatures' =&gt; 'int',
+   'QStyle::SubControls' =&gt; 'int',
+   'RegisterOptions' =&gt; 'int',
+   'BindMode' =&gt; 'int',
+   'ButtonFeatures' =&gt; 'int',
+   'CacheMode' =&gt; 'int',
+   'CheckType' =&gt; 'int',
+   'CornerWidgets' =&gt; 'int',
+   'DockWidgetFeatures' =&gt; 'int',
+   'FileFlags' =&gt; 'int',
+   'FontFilters' =&gt; 'int',
+   'FrameFeatures' =&gt; 'int',
+   'GraphicsItemFlags' =&gt; 'int',
+   'InterfaceFlags' =&gt; 'int',
+   'IteratorFlags' =&gt; 'int',
+   'MenuItemType' =&gt; 'int',
+   'NumberOptions' =&gt; 'int',
+   'PageBreakFlags' =&gt; 'int',
+   'Qt::TextInteractionFlags' =&gt; 'int',
+   'Relation' =&gt; 'int',
+   'SectionPosition' =&gt; 'int',
+   'SelectedPosition' =&gt; 'int',
+   'StandardButtons' =&gt; 'int',
+   'State' =&gt; 'int',
+   'TabPosition' =&gt; 'int',
+   'ToolBarFeatures' =&gt; 'int',
+   'ToolBarPosition' =&gt; 'int',
+   'ToolButtonFeatures' =&gt; 'int',
+   'ViewItemFeatures' =&gt; 'int',
+);
+
+$headerSubdirectories = &quot;kio/|phonon/ui/|kmediaplayer/|dnssd/|solid/|solid/ifaces/|phonon/|sonnet/|kdevelop/|kinterfacedesigner/|kontact/|kate/|kparts/|dom/|kabc/|ksettings/|kjs/|ktexteditor/|kdeprint/|kdesu/|knewstuff/|dbus-1.0/dbus/&quot;
+
+}
+
+sub writeDoc
+{
+	( $libname, $rootnode, $outputdir, $opt ) = @_;
+
+	print STDERR &quot;Starting writeDoc for $libname...\n&quot;;
+
+	$debug = $main::debuggen;
+
+	mkpath( $outputdir ) unless -f $outputdir;
+
+	# Define QPtrCollection::Item, for resolveType
+	unless ( kdocAstUtil::findRef( $rootnode, &quot;QPtrCollection::Item&quot; ) || $main::qt4 ) {
+		my $cNode = kdocAstUtil::findRef( $rootnode, &quot;QPtrCollection&quot; );
+		warn &quot;QPtrCollection not found&quot; if (!$cNode);
+		my $node = Ast::New( 'Item' );
+		$node-&gt;AddProp( &quot;NodeType&quot;, &quot;Forward&quot; );
+		$node-&gt;AddProp( &quot;Source&quot;, $cNode-&gt;{Source} ) if ($cNode);
+		kdocAstUtil::attachChild( $cNode, $node ) if ($cNode);
+		$node-&gt;AddProp( &quot;Access&quot;, &quot;public&quot; );
+	}
+	
+	print STDERR &quot;Preparsing...\n&quot;;
+
+	# Preparse everything, to prepare some additional data in the classes and methods
+	Iter::LocalCompounds( $rootnode, sub { preParseClass( shift ); } );
+
+	# Have a look at each class again, to propagate CanBeCopied
+	Iter::LocalCompounds( $rootnode, sub { propagateCanBeCopied( shift ); } );
+
+	print STDERR &quot;Writing smokedata.cpp...\n&quot;;
+
+	# Write out smokedata.cpp
+	writeSmokeDataFile($rootnode);
+
+	print STDERR &quot;Writing x_*.cpp...\n&quot;;
+
+	# Generate x_*cpp file for each class
+
+        my $numclasses;
+        Iter::LocalCompounds( $rootnode, sub { $numclasses++ } );
+        my $classperfile = int($numclasses/numSourceFiles);
+        print STDERR &quot;Total number of classes: &quot;. $numclasses .&quot;\n&quot; if $debug;
+        my $nodelist = [];
+        my $currentfile = 1;
+        my $currentclass = 1;
+        Iter::LocalCompounds( $rootnode, sub { 
+                   push @$nodelist, shift;
+                   if(@$nodelist == $classperfile and $currentfile != numSourceFiles)
+                   {
+                       print STDERR &quot;Calling writeClassDoc for &quot;. (scalar @$nodelist) . &quot; classes\n&quot; if $debug;
+                       writeClassDoc( $nodelist );
+                       $currentfile++;
+                       $nodelist = []     
+                   }
+                   if(@$nodelist and $currentclass == $numclasses)
+                   {    
+                       print STDERR &quot;Calling writeClassDoc for remaining &quot;. (scalar @$nodelist) . &quot; classes\n&quot; if $debug;
+                       writeClassDoc( $nodelist )
+                   }
+                   $currentclass++
+        });
+
+	print STDERR &quot;Done.\n&quot;;
+}
+
+=head2 preParseClass
+	Called for each class
+=cut
+sub preParseClass
+{
+	my( $classNode ) = @_;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+
+	if( $#{$classNode-&gt;{Kids}} &lt; 0 ||
+	    $classNode-&gt;{Access} eq &quot;private&quot; ||
+	    $classNode-&gt;{Access} eq &quot;protected&quot; || # e.g. QPixmap::QPixmapData
+	    exists $classNode-&gt;{Tmpl} ||
+	    # Don't generate standard bindings for QString, this class is handled as a native type
+	    $className eq 'QString' ||
+	    $className eq 'QStringData' ||
+	    $className eq 'QLatin1String' ||
+	    $className eq 'QTLWExtra' ||
+	    $className eq 'QWExtra' ||
+	    $className eq 'QBig5Codec' ||
+	    $className eq 'QBig5hkscsCodec' ||
+	    $className eq 'QPtrCollection' ||
+	    $className eq 'QGCache' ||
+	    $className eq 'QConstString' ||
+	    $className eq 'QCString' ||
+	    # Don't map classes which are really arrays
+	    $className eq 'QStringList' ||
+            $className eq 'QCanvasItemList' ||
+            $className eq 'QWidgetList' ||
+            $className eq 'QObjectList' ||
+	    $className eq 'QStrList' ||
+	    $className eq 'KCmdLineOptions' ||
+	    # Those are template related
+            $className eq 'QTSManip' || # cause compiler errors with several gcc versions
+	    $className eq 'QGDict' ||
+	    $className eq 'QGList' ||
+	    $className eq 'QGArray' ||
+	    $className eq 'QGVector' ||
+	    $className eq 'QStrIList' ||
+	    $className eq 'QStrIVec' ||
+	    $className eq 'QBitArray' ||
+	    $className eq 'QMapData' ||
+	    $className eq 'QMetaEnum::Item' ||
+	    $className eq 'QWidgetContainerPlugin' ||
+	    $className eq 'QGArray::array_data' ||
+	    ($className eq 'QMenuItem' and $main::qt_embedded) ||
+	    ($className eq 'QSignal' and $main::qt_embedded) ||
+	    ($className eq 'QWSEvent' and $main::qt_embedded) ||
+	    ($className eq 'QMetaObjectInit' and $main::qt_embedded) ||
+	    ($className eq 'QKoi8Codec' and $main::qt_embedded) ||
+	    $className eq 'KAccelGen' ||
+	    ($className eq 'QAbstractUndoItem' and $main::qt4) ||
+	    ($className eq 'QDebug' and $main::qt4) ||
+	    ($className eq 'QNoDebug' and $main::qt4) ||
+	    ($className eq 'QObjectData' and $main::qt4) ||
+	    ($className eq 'QSysInfo' and $main::qt4) ||
+	    ($className eq 'QPNGImageWriter' and $main::qt4) ||
+	    ($className eq 'QPNGImagePacker' and $main::qt4) ||
+	    ($className eq 'QSqlRelationalDelegate' and $main::qt4) ||
+	    ($className eq 'QTextCodec::ConverterState' and $main::qt4) ||
+	    ($className eq 'QTextLayout::Selection' and $main::qt4) ||
+	    ($className eq 'QTextStreamManipulator' and $main::qt4) ||
+	    $className eq 'DCOPArg' ||
+	    $className eq 'DCOPReply' ||
+	    $className eq 'KBookmarkMenu::DynMenuInfo' ||
+	    $className eq 'KDateTime::Spec' ||
+	    $className eq 'KEncodingFileDialog::Result' ||
+	    $className eq 'KDE' ||
+	    $className eq 'KDEDesktopMimeType::Service' ||
+	    $className eq 'KDialogButtonBox' ||
+	    $className eq 'KEntry' ||
+	    $className eq 'KEntryKey' ||
+	    $className eq 'KGlobalSettings::KMouseSettings' ||
+	    $className eq 'KMimeType::Format' ||
+	    $className eq 'KNotifyClient::Instance' ||
+	    $className eq 'KParts::ComponentFactory' ||
+	    $className eq 'KParts::Plugin::PluginInfo' ||
+	    $className eq 'KParts::MainWindow' ||
+	    $className eq 'KProtocolInfo::ExtraField' ||
+	    $className eq 'KXMLGUIClient::StateChange' ||
+	    $className eq 'KIconTheme' ||
+	    $className eq 'KEditListBox::CustomEditor' ||
+		$className eq 'KIO::KBookmarkMenuNSImporter' ||
+		$className eq 'KIO::NetRC' ||
+	    $className eq 'KExtendedSocket' ||
+	    $className eq 'KSettings::PluginPage' ||
+	    $className eq 'KSocket' ||
+	    $className eq 'KPerDomainSettings' ||
+	    $className eq 'KApplicationPropsPlugin' ||
+	    $className eq 'KOpenWithHandler' ||
+	    $className eq 'KFileOpenWithHandler' ||
+	    $className eq 'KBindingPropsPlugin' ||
+	    $className eq 'KPropsDlgPlugin' ||
+	    $className eq 'KFileSharePropsPlugin' ||
+	    $className eq 'KBookmarkMenuNSImporter' ||
+	    $className eq 'KDevicePropsPlugin' ||
+	    $className eq 'KDEDModule' ||
+	    $className eq 'KFileMetaInfoProvider' ||
+	    $className eq 'KFileMimeTypeInfo' ||
+	    $className eq 'KMimeTypeChooserDialog' ||
+	    $className eq 'KExecPropsPlugin' ||
+	    $className eq 'KFilePermissionsPropsPlugin' ||
+	    $className eq 'KImageFilePreview' ||
+	    $className eq 'KBookmarkManager' ||
+	    $className eq 'KBookmarkNotifier' ||
+	    $className eq 'KOCRDialogFactory' ||
+	    $className eq 'KExtendedBookmarkOwner' ||
+	    $className eq 'KSharedPixmap' ||
+	    $className eq 'KLibrary' ||
+	    $className eq 'KScanDialogFactory' ||
+	    $className eq 'KTimeZone::Transition' ||
+	    $className eq 'KTipDatabase' ||
+	    $className eq 'KBufferedIO' ||
+	    $className eq 'KDictSpellingHighlighter' ||
+		$className eq 'KPropertiesDialog' ||
+	    $className eq 'ProgressItem' ||
+	    $className eq 'KIO::ChmodInfo' ||
+	    $className eq 'KUrl::List' ||
+	    $className eq 'khtml::DrawContentsEvent' || # the khtml:: classes build, but don't link
+	    $className eq 'khtml::MouseDoubleClickEvent' ||
+	    $className eq 'khtml::MouseMoveEvent' ||
+	    $className eq 'khtml::MousePressEvent' ||
+	    $className eq 'khtml::MouseReleaseEvent' ||
+	    $className eq 'khtml::MouseEvent' ||
+	    $className eq 'khtml' ||
+	    $className eq 'KURL::List' ||
+	    $className eq 'KWin::Info' ||
+	    $className eq 'TerminalInterface' ||
+	    $className eq 'QAccessibleBridgePlugin' || # Qt4
+	    $className eq 'QForeachContainerBase' || # Qt4
+	    $className eq 'QInputMethodEvent::Attribute' || # Qt4
+	    $className eq 'QAbstractUndoItem' || # Qt4
+	    $className eq 'QAbstractTextDocumentLayout::PaintContext' || # Qt4
+	    $className eq 'QAbstractTextDocumentLayout::Selection' || # Qt4
+	    $className eq 'QBrushData' || # Qt4
+	    $className eq 'QDBusObjectPath' || # Qt4
+	    $className eq 'QDBusSignature' || # Qt4
+	    $className eq 'QDBusVariant' || # Qt4
+	    $className eq 'QIPv6Address' || # Qt4
+	    $className eq 'QImageTextKeyLang' || # Qt4
+	    $className eq 'QMap' || # Qt4
+	    $className eq 'QMap::const_iterator' || # Qt4
+	    $className eq 'QMap::iterator' || # Qt4
+	    $className eq 'QMapData' || # Qt4
+	    $className eq 'QMapData::Node' || # Qt4
+	    $className eq 'QObjectData' || # Qt4
+	    $className eq 'QProxyModel' || # Obsolete Qt4
+	    $className eq 'QSharedData' || # Qt4
+	    $className eq 'QPainterPath::Element' || # Qt4
+	    $className eq 'QThreadStorageData' || # Qt4
+	    $className eq 'QVFbHeader' || # Qt4
+	    $className eq 'QStyleOptionQ3DockWindow' || # Qt4
+	    $className eq 'QStyleOptionQ3ListView' || # Qt4
+	    $className eq 'QStyleOptionQ3ListViewItem' || # Qt4
+	    $className eq 'QStyleOptionQ3ListView' || # Qt4
+	    $className eq 'QUpdateLaterEvent' || # Qt4
+	    $className eq 'QVFbKeyData' || # Qt4
+	    $className eq 'QVariant::Handler' || # Qt4
+	    $className eq 'QVariant::PrivateShared' || # Qt4
+	    $className eq 'QVectorData' || # Qt4
+	    $className eq 'QWidgetData' || # Qt4
+	    $className eq 'QThread' || # Qt4
+		$className eq 'QThreadStorage' || # Qt4
+		$className eq 'QMutex' || # Qt4
+		$className eq 'QMutexLocker' || # Qt4
+		$className eq 'QSemaphore' || # Qt4
+		$className eq 'QWaitCondition' || # Qt4
+		$className eq 'QReadWriteLock' || # Qt4
+		$className eq 'QReadLocker' || # Qt4
+		$className eq 'QX11Info' || # Qt4
+		$className eq 'QWriteLocker' || 
+	    $className =~ /.*Private$/ || # Ignore any classes which aren't for public consumption
+	    $className =~ /.*Impl$/ ||
+	    $className =~ /.*Internal.*/ ||
+	    $classNode-&gt;{Deprecated} ||
+	    $classNode-&gt;{NodeType} eq 'union' || # Skip unions for now, e.g. QPDevCmdParam
+	    $className eq 'KImportedBookmarkMenu' || # KDE4
+	    $className eq 'KUndoRedoAction' || # KDE4
+	    $className eq 'KTzfileTimeZoneData' || # KDE4
+	    $className eq 'KUndoRedoAction' # KDE4
+	  ) {
+	    print STDERR &quot;Skipping $className\n&quot; if ($debug);
+	    print STDERR &quot;Skipping union $className\n&quot; if ( $classNode-&gt;{NodeType} eq 'union');
+	    $skippedClasses{$className} = 1;
+	    delete $classNode-&gt;{Compound}; # Cheat, to get it excluded from Iter::LocalCompounds
+	    return;
+	}
+	
+	my $signalCount = 0;
+	my $eventHandlerCount = 0;
+	my $defaultConstructor = 'none'; #  none, public, protected or private. 'none' will become 'public'.
+	my $constructorCount = 0; # total count of _all_ ctors
+	# If there are ctors, we need at least one public/protected one to instanciate the class
+	my $hasPublicProtectedConstructor = 0;
+	# We need a public dtor to destroy the object --- ### aren't protected dtors ok too ??
+	my $hasPublicDestructor = 1; # by default all classes have a public dtor!
+	#my $hasVirtualDestructor = 0;
+	my $hasDestructor = 0;
+	my $hasPrivatePureVirtual = 0;
+	my $hasCopyConstructor = 0;
+	my $hasPrivateCopyConstructor = 0;
+	# Note: no need for hasPureVirtuals. $classNode{Pure} has that.
+	
+	# Hack to fix up KLed constructors in KDE 3.1
+	my $kledAmbiguousConstructor = undef;
+
+        my $doPrivate = $main::doPrivate;
+	$main::doPrivate = 1;
+	# Look at each class member (looking for methods and enums in particular)
+	Iter::MembersByType ( $classNode, undef,
+		sub {
+
+	my( $classNode, $m ) = @_;
+	my $name = $m-&gt;{astNodeName};
+
+	if( $m-&gt;{NodeType} eq &quot;method&quot; ) {
+	    if ( $m-&gt;{ReturnType} eq 'typedef' # QFile's EncoderFn/DecoderFn callback, very badly parsed
+	       ) {
+		$m-&gt;{NodeType} = 'deleted';
+		next;
+	    }
+
+	    print STDERR &quot;preParseClass: looking at $className\::$name  $m-&gt;{Params}\n&quot; if ($debug);
+	    
+		if ( $name eq $classNode-&gt;{astNodeName} ) {
+		if ( $m-&gt;{ReturnType} =~ /~/  ) {
+		    # A destructor
+		    $hasPublicDestructor = 0 if $m-&gt;{Access} ne 'public';
+		    #$hasVirtualDestructor = 1 if ( $m-&gt;{Flags} =~ &quot;v&quot; &amp;&amp; $m-&gt;{Access} ne 'private' );
+		    $hasDestructor = 1;
+		} else {
+		    # A constructor
+		    $constructorCount++;
+		    $defaultConstructor = $m-&gt;{Access} if ( $m-&gt;{Params} eq '' );
+		    $hasPublicProtectedConstructor = 1 if ( $m-&gt;{Access} ne 'private' );
+
+		    # Copy constructor?
+		    if ( $#{$m-&gt;{ParamList}} == 0 ) {
+			my $theArgType = @{$m-&gt;{ParamList}}[0]-&gt;{ArgType};
+                        (my $classNameWithoutNS = $className) =~ s/^.*:://;
+			if ($theArgType =~ /$classNameWithoutNS\s*\&amp;/) {
+			    $hasCopyConstructor = 1;
+				$m-&gt;{Flags} .= &quot;x&quot;;
+			    $hasPrivateCopyConstructor = 1 if ( $m-&gt;{Access} eq 'private' );
+			}
+		    }
+		    # Hack the return type for constructors, since constructors return an object pointer
+		    $m-&gt;{ReturnType} = $className.&quot;*&quot;;
+		}
+	    }
+
+	    if ( $name =~ /~$classNode-&gt;{astNodeName}/ &amp;&amp; $m-&gt;{Access} ne &quot;private&quot; ) { # not used
+		$hasPublicDestructor = 0 if $m-&gt;{Access} ne 'public';
+		#$hasVirtualDestructor = 1 if ( $m-&gt;{Flags} =~ &quot;v&quot; );
+		$hasDestructor = 1;
+	    }
+
+	    if ( $m-&gt;{Flags} =~ &quot;p&quot; &amp;&amp; $m-&gt;{Access} =~ /private/ ) {
+                $hasPrivatePureVirtual = 1; # ouch, can't inherit from that one
+	    }
+
+	    # All we want from private methods is to check for virtuals, nothing else
+	    next if ( $m-&gt;{Access} =~ /private/ );
+		# Don't generate code for deprecated methods, 
+		# or where the code won't compile/link for obscure reasons. Or even obvious reasons..
+		if ( ($classNode-&gt;{astNodeName} eq 'KCharSelectTable' and $name eq 'paintCell')
+			# KDE4
+			|| ($name eq 'operator&lt;&lt;' and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QDataStream/ and $m-&gt;{ParamList}[1]-&gt;{ArgType} =~ /KDateTime::Spec/ )
+			|| ($name eq 'operator&gt;&gt;' and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QDataStream/ and $m-&gt;{ParamList}[1]-&gt;{ArgType} =~ /KDateTime::Spec/ )
+                        || ($name eq 'operator&lt;&lt;' and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QDataStream/ and $m-&gt;{ParamList}[1]-&gt;{ArgType} =~ /const KDateTime/ )
+                        || ($name eq 'operator&gt;&gt;' and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QDataStream/ and $m-&gt;{ParamList}[1]-&gt;{ArgType} =~ /KDateTime/ )
+			|| ($classNode-&gt;{astNodeName} eq 'TextEvent' and $name eq 'data')
+			|| ($classNode-&gt;{astNodeName} eq 'KApplication' and $name eq 'startKdeinit')
+			|| ($classNode-&gt;{astNodeName} eq 'Slave' and $name eq 'Slave')
+			|| ($classNode-&gt;{astNodeName} eq 'KIcon' and $name eq 'setOverlays')
+			|| ($classNode-&gt;{astNodeName} eq 'KResolver' and $name eq 'setError')
+			|| ($classNode-&gt;{astNodeName} eq 'Entry' and $name eq 'setCompatibility')
+			|| ($classNode-&gt;{astNodeName} eq 'KTimeZone' and $name eq 'source')
+			|| ($classNode-&gt;{astNodeName} eq 'KTzfileTimeZoneSource' and $name eq 'location')
+			|| ($classNode-&gt;{astNodeName} eq 'Wallet' and $name eq 'Wallet')
+			# end KDE4
+			|| ($classNode-&gt;{astNodeName} eq 'KAnimWidget' and $name eq 'KAnimWidget' and @{$m-&gt;{ParamList}} == 2)
+			|| ($classNode-&gt;{astNodeName} eq 'KCModuleLoader' and $name eq 'errorModule')
+			|| ($classNode-&gt;{astNodeName} eq 'KDCOPActionProxy' and $name eq 'actions')
+			|| ($classNode-&gt;{astNodeName} eq 'KEditToolbarWidget' and $name eq 'insertActive')
+			|| ($classNode-&gt;{astNodeName} eq 'KEditToolbarWidget' and $name eq 'removeActive')
+			|| ($classNode-&gt;{astNodeName} eq 'KEditToolbarWidget' and $name eq 'moveActive')
+			|| ($classNode-&gt;{astNodeName} eq 'KFileDialog' and $name eq 'addDirEntry')
+			|| ($classNode-&gt;{astNodeName} eq 'KFileDialog' and $name eq 'getDirEntry')
+			|| ($classNode-&gt;{astNodeName} eq 'KFileItem' and $name eq 'extraData')
+			|| ($classNode-&gt;{astNodeName} eq 'KFileView' and $name eq 'selectionMode')
+			|| ($classNode-&gt;{astNodeName} eq 'KFind' and $name eq 'KFind' and @{$m-&gt;{ParamList}} == 4)
+			|| ($classNode-&gt;{astNodeName} eq 'KGlobalAccel' and $name eq 'setEnabled')
+			|| ($classNode-&gt;{astNodeName} eq 'KCharsets' and $name eq 'encodingsForLanguage')
+			|| ($classNode-&gt;{astNodeName} eq 'KInputDialog' and $name eq 'getInteger')
+			|| ($classNode-&gt;{astNodeName} eq 'SlaveBase' and $name eq 'checkCachedAuthentication')
+			|| ($classNode-&gt;{astNodeName} eq 'SlaveBase' and $name eq 'cacheAuthentication')
+			|| ($classNode-&gt;{astNodeName} eq 'KInputDialog' and $name eq 'getDouble')
+			|| ($classNode-&gt;{astNodeName} eq 'KToolBar' and $name eq 'enable')
+			|| ($classNode-&gt;{astNodeName} eq 'KToolBar' and $name eq 'changeEvent')
+			|| ($classNode-&gt;{astNodeName} eq 'KAccel' and $name eq 'insert' and @{$m-&gt;{ParamList}} == 2)
+			|| ($classNode-&gt;{astNodeName} eq 'KAccel' and $name eq 'autoupdate')
+			|| ($classNode-&gt;{astNodeName} eq 'KAccel' and $name eq 'getAutoUpdate')
+			|| ($classNode-&gt;{astNodeName} eq 'KAction' and $name eq 'activated')
+			|| ($classNode-&gt;{astNodeName} eq 'KAction' and $name eq 'actionOfType')
+			|| ($classNode-&gt;{astNodeName} eq 'KAction' and $name eq 'actionsOfType')
+			|| ($classNode-&gt;{astNodeName} eq 'KActionCollection' and $name eq 'add')
+			|| ($classNode-&gt;{astNodeName} eq 'KStdAccel' and $name eq 'insert')
+			|| ($classNode-&gt;{astNodeName} eq 'KBookmarkMenu' and $name eq 'invalid')
+			|| ($classNode-&gt;{astNodeName} eq 'KCharsets' and $name eq 'languages')
+			|| ($classNode-&gt;{astNodeName} eq 'KCombiView' and $name eq 'setDropOptions')
+			|| ($classNode-&gt;{astNodeName} eq 'KDialogButtonBox' and $name eq 'using')
+			|| ($classNode-&gt;{astNodeName} eq 'KFileMetaInfoItem' and $name eq 'unit')
+			|| ($classNode-&gt;{astNodeName} eq 'KInstance' and $name eq 'charsets')
+			|| ($classNode-&gt;{astNodeName} eq 'KInstance' and $name eq 'KInstance' and $m-&gt;{Access} =~ /protected/)
+			|| ($classNode-&gt;{astNodeName} eq 'KKey' and $name eq 'isValidQt')
+			|| ($classNode-&gt;{astNodeName} eq 'KKey' and $name eq 'isValidNative')
+			|| ($classNode-&gt;{astNodeName} eq 'KKeySequence' and $name eq 'init')
+			|| ($classNode-&gt;{astNodeName} eq 'KKeySequence' and $name eq 'setTriggerOnRelease')
+			|| ($classNode-&gt;{astNodeName} eq 'KEMailSettings' and $name eq 'getExtendedSetting')
+			|| ($classNode-&gt;{astNodeName} eq 'KEMailSettings' and $name eq 'setExtendedSetting')
+			|| ($classNode-&gt;{astNodeName} eq 'KProtocolManager' and $name eq 'defaultConnectTimeout')
+			|| ($classNode-&gt;{astNodeName} eq 'KMD4' and $name eq 'transform')
+			|| ($classNode-&gt;{astNodeName} eq 'KMD5' and $name eq 'transform')
+			|| ($classNode-&gt;{astNodeName} eq 'KSSLCertificate' and $name eq 'operator!=')
+			|| ($classNode-&gt;{astNodeName} eq 'KSSLPKCS7' and $name eq 'validate')
+			|| ($classNode-&gt;{astNodeName} eq 'KSSLPKCS7' and $name eq 'revalidate')
+			|| ($classNode-&gt;{astNodeName} eq 'KSSLSession' and $name eq 'KSSLSession' and @{$m-&gt;{ParamList}} == 1)
+			|| ($classNode-&gt;{astNodeName} eq 'KSimpleFileFilter' and $name eq 'nameFilters')
+			|| ($classNode-&gt;{astNodeName} eq 'KTabWidget' and $name eq 'isTabReorderingEnabled')
+			|| ($classNode-&gt;{astNodeName} eq 'KTabWidget' and $name eq 'hoverCloseButton')
+			|| ($classNode-&gt;{astNodeName} eq 'KTabWidget' and $name eq 'hoverCloseButtonDelayed')
+			|| ($classNode-&gt;{astNodeName} eq 'KTar' and $name eq 'writeFile_impl')
+			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'buildHTMLErrorString')
+			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'pasteClipboard')
+			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'pasteData')
+			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'pasteDataAsync')
+			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'isClipboardEmpty')
+			|| ($classNode-&gt;{astNodeName} eq 'KIO::NetRC' and $name eq 'lookup')
+			|| ($classNode-&gt;{astNodeName} eq 'DCOPRef' and $name eq 'callExt')
+			|| ($classNode-&gt;{astNodeName} eq 'DCOPRef' and $name eq 'call')
+			|| ($classNode-&gt;{astNodeName} eq 'DCOPRef' and $name eq 'send')
+			|| ($classNode-&gt;{astNodeName} eq 'DOM' and $name eq 'operator&lt;&lt;') # Avoid kdbgstream debugging method
+			|| ($name eq 'initgroups')
+			|| ($name eq 'qInitJpegIO' and $main::qt4)
+			|| ($name eq 'qInitPngIO' and $main::qt4)
+			|| ($name eq 'qt_metacast' and $main::qt4)
+			|| ($name eq 'virtual_hook')
+			|| ($name eq 'handle')
+			|| ($name eq 'qHash')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'setFillBrush')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'fillBrush')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'setFillColor')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'fillColor')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'setAlarmBrush')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'alarmBrush')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'setAlarmColor')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'alarmColor')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtWheel' and $name eq 'getScrollMode')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtSpline' and $name eq 'points')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtPlot' and $name eq 'drawItems')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtPlot' and $name eq 'printCanvas')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtPlot' and $name eq 'drawItems')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtPlot' and $name eq 'setCanvasBackground')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtPlot' and $name eq 'canvasBackground')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtPlotLayout' and $name eq 'expandLineBreaks')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtPlotLayout' and $name eq 'alignScales')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtData' and $name eq 'operator=')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtScaleTransformation' and $name eq 'double')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtScaleDiv' and $name eq 'QwtScaleDiv' and @{$m-&gt;{ParamList}} &gt; 0)
+			# Obsolete
+			|| ($classNode-&gt;{astNodeName} eq 'QTextStream' and $name eq 'QTextStream'
+					and @{$m-&gt;{ParamList}} == 2 and $m-&gt;{ParamList}[0]-&gt;{ArgType} eq 'QString&amp;')
+			
+			# Various methods to skip in Qt/E (Qt 2.3.x)
+			|| ($main::qt_embedded
+				&amp;&amp; ( ($classNode-&gt;{astNodeName} eq 'QUriDrag' and $name =~ /^decode$|decodeLocalFiles|decodeToUnicodeUris/)
+				|| ($classNode-&gt;{astNodeName} eq 'QApplication' and $name =~ /^qwsSetCustomColors|^setArgs$|^winMouseButtonUp|^winFocus|^winMouseButtonUP$|^winVersion$/)
+				|| ($classNode-&gt;{astNodeName} eq 'QPrinter' and $name =~ /^setIdle$|^setActive$/)
+				|| ($classNode-&gt;{astNodeName} eq 'QDragObject' and $name eq 'dragLink')
+				|| ($classNode-&gt;{astNodeName} eq 'QFont' and $name eq 'qwsRenderToDisk')
+				|| ($classNode-&gt;{astNodeName} eq 'QFontInfo' and $name eq 'font')
+				|| ($classNode-&gt;{astNodeName} eq 'QLineEdit' and $name eq 'getSelection')
+				|| ($classNode-&gt;{astNodeName} eq 'QMainWindow' and $name eq 'toolBars')
+				|| ($classNode-&gt;{astNodeName} eq 'QMovie' and $name eq 'setDisplayWidget')
+				|| ($classNode-&gt;{astNodeName} eq 'QMetaObject' and $name =~ /^new_metaenum_item$|^new_metaaccess$/)
+				|| ($classNode-&gt;{astNodeName} eq 'QPainter' and $name eq 'pos')
+				|| ($classNode-&gt;{astNodeName} eq 'QPixmap' and $name =~ /^allocCell$|^clut$|^freeCell|^hbm|^isMultiCellPixmap|^multiCellPixmap|^multiCellBitmap|^multiCellHandle|^multiCellOffset|^numCols/)
+				|| ($name eq 'handle')
+				|| ($name eq 'resetInputContext')
+				|| ($name eq 'propagateUpdates')
+				|| ($name eq 'bytesPerLine')
+				|| ($name eq 'scanLine')
+				|| ($name eq 'hPal')
+				|| ($name eq 'copyX11Data')
+				|| ($name eq 'getX11Data')
+				|| ($name eq 'setX11Data')
+				|| ($name eq 'realizePal')
+				|| ($name eq 'qwsDisplay')
+				|| ($name eq 'fixport')
+				|| ($name eq 'hack_strrchr')
+				|| ($name eq 'hack_strchr')
+				|| ($name eq 'hack_strstr') ) )
+						
+			# Assume only Qt classes have tr() and trUtf8() in their Q_OBJECT macro
+			|| ($classNode-&gt;{astNodeName} !~ /^Q/ and $name eq 'tr')
+			|| ($classNode-&gt;{astNodeName} !~ /^Q/ and $name eq 'trUtf8')
+
+			|| ($main::qt4
+				&amp;&amp; ( ($classNode-&gt;{astNodeName} eq 'QWidgetListItem' and $name eq 'operator=')
+				|| ($classNode-&gt;{astNodeName} eq 'QColormap' and $name eq 'operator=')
+				|| ($classNode-&gt;{astNodeName} eq 'QGraphicsLineItem' and $name eq 'QGraphicsLineItem' and $#{$m-&gt;{ParamList}} == 5)
+				|| ($classNode-&gt;{astNodeName} eq 'QGraphicsEllipseItem' and $name eq 'QGraphicsEllipseItem' and $#{$m-&gt;{ParamList}} == 5)
+				|| ($classNode-&gt;{astNodeName} eq 'QListWidget' and $name eq 'setItemPosition')
+				|| ($classNode-&gt;{astNodeName} eq 'QFontMetricsF' and $name eq 'operator=')
+				|| ($classNode-&gt;{astNodeName} eq 'QFontMetricsF' and $name eq 'QFontMetricsF' 
+					and $#{$m-&gt;{ParamList}} == 0 &amp;&amp; $m-&gt;{ParamList}[0]-&gt;{ArgType} eq 'const QFontMetrics&amp;')
+				|| ($classNode-&gt;{astNodeName} eq 'QAbstractItemDelegate' and $name eq 'QAbstractItemDelegate' 
+					and $#{$m-&gt;{ParamList}} == 0 &amp;&amp; $m-&gt;{ParamList}[0]-&gt;{ArgType} eq 'const QAbstractItemDelegate&amp;')
+				|| ($classNode-&gt;{astNodeName} eq 'QHttp' and $name eq 'supportedOperations')
+				|| ($classNode-&gt;{astNodeName} eq 'QPrinter' and $name eq 'printRange')
+				|| ($classNode-&gt;{astNodeName} eq 'QPrinter' and $name eq 'setPrintRange')
+				|| ($classNode-&gt;{astNodeName} eq 'QRectF' and $name eq 'setX')
+				|| ($classNode-&gt;{astNodeName} eq 'QRectF' and $name eq 'setY')
+				|| ($classNode-&gt;{astNodeName} eq 'QTextObject' and $name eq 'formatType')
+				|| ($classNode-&gt;{astNodeName} eq 'QUrl' and $name eq 'QUrl'
+					and $#{$m-&gt;{ParamList}} == 0 &amp;&amp; $m-&gt;{ParamList}[0]-&gt;{ArgType} eq 'QUrlPrivate&amp;')
+				|| ($classNode-&gt;{astNodeName} eq 'QGlobalSpace' and $name eq 'operator&lt;&lt;' and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QDebug/)
+				|| ($classNode-&gt;{astNodeName} eq 'QGlobalSpace' and $name eq 'qDebug')
+				|| ($classNode-&gt;{astNodeName} eq 'QGlobalSpace' and $name eq 'qWarning')
+				|| ($classNode-&gt;{astNodeName} eq 'QGlobalSpace' and $name eq 'qCritical')
+				|| ($classNode-&gt;{astNodeName} eq 'QGlobalSpace' and $#{$m-&gt;{ParamList}} &gt; 0 and $name =~ /operator/ and $m-&gt;{ParamList}[1]-&gt;{ArgType} =~ /QVariant::Type/)
+				|| ($#{$m-&gt;{ParamList}} &gt; 0 and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /Private/)
+				|| ($classNode-&gt;{astNodeName} eq 'QScrollArea' and $name eq 'alignment')
+				|| ($classNode-&gt;{astNodeName} eq 'QScrollArea' and $name eq 'setAlignment')
+				|| ($classNode-&gt;{astNodeName} eq 'QDBusConnection' and $name eq 'findInterface' and 
+					$m-&gt;{ReturnType} =~ /&lt;/ )
+				|| ($classNode-&gt;{astNodeName} eq 'QDBusBusService' and $name eq 'RequestName')
+				|| ($classNode-&gt;{astNodeName} eq 'QDBusBusService' and $name eq 'requestName')
+				|| ($classNode-&gt;{astNodeName} eq 'QGLFormat' and $name eq 'openGLVersionFlags')
+				|| ($classNode-&gt;{astNodeName} eq 'QAbstractUndoItem' and $name eq '~QAbstractUndoItem')
+				|| ($classNode-&gt;{astNodeName} eq 'QApplication' and $name eq 'setKeypadNavigationEnabled')
+				|| ($classNode-&gt;{astNodeName} eq 'QApplication' and $name eq 'keypadNavigationEnabled')
+				|| ($name eq 'qDBusMetaTypeId')
+				|| ($m-&gt;{ReturnType} =~ /template/)
+				|| ($m-&gt;{ReturnType} =~ /QT3_SUPPORT/) ) )
+
+			|| $m-&gt;{Deprecated} ) {
+		    $m-&gt;{NodeType} = 'deleted';
+			next;
+		}
+
+		# QLayout::setGeometry() is marked as pure virtual in the header, but actually has
+		# an implementation, so special case it.
+		if ($main::qt4 and $classNode-&gt;{astNodeName} eq 'QLayout' and $name eq 'setGeometry') {
+			$m-&gt;{Flags} =~ s/p//;
+		}
+
+		# Hack for fixing up KDE 3.1 KLed where the no arg constructor was ambiguous
+		if ($classNode-&gt;{astNodeName} eq 'KLed' and $name eq 'KLed' &amp;&amp; $#{$m-&gt;{ParamList}} &gt; 0) {
+			if ($m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QColor/ &amp;&amp; defined $m-&gt;{ParamList}[0]-&gt;{DefaultValue}) {
+				$m-&gt;{ParamList}[0]-&gt;{DefaultValue} = undef;
+				if (defined $kledAmbiguousConstructor) {
+					$kledAmbiguousConstructor-&gt;{ParamList}[0]-&gt;{DefaultValue} = undef;
+					$kledAmbiguousConstructor-&gt;{FirstDefaultParam} = 1;
+				}
+			} else {
+				$kledAmbiguousConstructor = $m;
+			}
+		}
+
+		# cut the last arguments in size(), boundingRect(), both methods was ambiguous
+		if ($classNode-&gt;{astNodeName} eq 'QFontMetrics' and $name eq 'boundingRect' &amp;&amp; $#{$m-&gt;{ParamList}} == 7) {
+			if ($m-&gt;{ParamList}[7]-&gt;{ArgType} =~ /int/ &amp;&amp; defined $m-&gt;{ParamList}[7]-&gt;{DefaultValue}) {
+			    pop(@{$m-&gt;{ParamList}});
+			    $#{$m-&gt;{ParamList}}--;
+			    $m-&gt;{Params} =~ s/int \*tabarray\=0//;
+			}
+		}
+
+		if ($classNode-&gt;{astNodeName} eq 'QFontMetrics' and $name eq 'size' &amp;&amp; $#{$m-&gt;{ParamList}} == 3) {
+			if ($m-&gt;{ParamList}[3]-&gt;{ArgType} =~ /int/ &amp;&amp; defined $m-&gt;{ParamList}[3]-&gt;{DefaultValue}) {
+			    pop(@{$m-&gt;{ParamList}});
+			    $#{$m-&gt;{ParamList}}--;
+			    $m-&gt;{Params} =~ s/int \*tabarray\=0//;
+			}
+		}
+
+		
+	    my $argId = 0;
+	    my $firstDefaultParam;
+	    foreach my $arg ( @{$m-&gt;{ParamList}} ) {
+		# Look for first param with a default value
+		if ( defined $arg-&gt;{DefaultValue} &amp;&amp; !defined $firstDefaultParam ) {
+		    $firstDefaultParam = $argId;
+		}
+
+		if ( $arg-&gt;{ArgType} eq '...' # refuse a method with variable arguments
+		     or $arg-&gt;{ArgType} eq 'image_io_handler' # QImage's callback
+		     or $arg-&gt;{ArgType} eq 'DecoderFn' # QFile's callback
+		     or $arg-&gt;{ArgType} eq 'EncoderFn' # QFile's callback
+		     or $arg-&gt;{ArgType} =~ /bool \(\*\)\(QObject/ # QMetaObject's ctor
+		     or $arg-&gt;{ArgType} eq 'QtStaticMetaObjectFunction' # QMetaObjectCleanUp's ctor with func pointer
+		     or $arg-&gt;{ArgType} eq 'const QTextItem&amp;' # ref to a private class in 3.2.0b1
+		     or $arg-&gt;{ArgType} eq 'FILE*' # won't be able to handle that I think
+		     or $arg-&gt;{ArgType} eq 'const KKeyNative&amp;' #
+		     or $arg-&gt;{ArgType} =~ /Node\s*\*/ #
+		) {
+		    $m-&gt;{NodeType} = 'deleted';
+		}
+		else
+		{
+		    # Resolve type in full, e.g. for QSessionManager::RestartHint
+		    # (x_QSessionManager doesn't inherit QSessionManager)
+		    $arg-&gt;{ArgType} = kalyptusDataDict::resolveType($arg-&gt;{ArgType}, $classNode, $rootnode);
+		    registerType( $arg-&gt;{ArgType} );
+		    $argId++;
+		}
+	    }
+	    $m-&gt;AddProp( &quot;FirstDefaultParam&quot;, $firstDefaultParam );
+	    $m-&gt;{ReturnType} = kalyptusDataDict::resolveType($m-&gt;{ReturnType}, $classNode, $rootnode) if ($m-&gt;{ReturnType});
+	    registerType( $m-&gt;{ReturnType} );
+	}
+	elsif( $m-&gt;{NodeType} eq &quot;enum&quot; ) {
+	    my $fullEnumName = $className.&quot;::&quot;.$m-&gt;{astNodeName};
+		
+		if ( ($fullEnumName eq 'KMimeType::Format' and $name eq 'compression')
+				|| $m-&gt;{Deprecated} ) {
+		    $m-&gt;{NodeType} = 'deleted';
+			next;
+		}
+	    
+		$classNode-&gt;{enumerations}{$m-&gt;{astNodeName}} = $fullEnumName
+		if $m-&gt;{astNodeName} and $m-&gt;{Access} ne 'private';
+
+	    # Define a type for this enum
+	    registerType( $fullEnumName );
+
+	    # Remember that it's an enum
+	    findTypeEntry( $fullEnumName )-&gt;{isEnum} = 1;
+
+	    #print STDERR &quot;$fullEnumName is an enum\n&quot;;
+ 	}
+	elsif( $m-&gt;{NodeType} eq 'var' ) {
+		if (	($classNode-&gt;{astNodeName} eq 'QUuid' and $name eq 'data4')
+				|| ($name eq 'd')
+				|| ($classNode-&gt;{astNodeName} eq 'QObject' and $name eq 'staticMetaObject')
+				|| ($classNode-&gt;{astNodeName} eq 'SlaveBase' and $name eq 'mIncomingMetaData')
+				|| ($classNode-&gt;{astNodeName} eq 'SlaveBase' and $name eq 'mOutgoingMetaData') ) 
+		{
+			$m-&gt;{NodeType} = 'deleted';
+			next;
+		}
+
+	    my $varType = $m-&gt;{Type};
+		$varType =~ s/const\s+(.*)\s*&amp;/$1/;
+		$varType =~ s/^\s*//;
+		$varType =~ s/\s*$//;
+		$varType =~ s/static\s+//;
+
+		if ( $m-&gt;{Flags} =~ &quot;s&quot; ) {
+			# We are interested in public static vars, like QColor::blue
+			if ( $m-&gt;{Access} ne 'private'
+				&amp;&amp; $className.&quot;::&quot;.$m-&gt;{astNodeName} ne &quot;KSpell::modalListText&quot; )
+			{
+				print STDERR &quot;var: $m-&gt;{astNodeName} '$varType'\n&quot; if ($debug);
+
+				# Register the type
+				registerType( $varType );
+			} else {
+				$m-&gt;{NodeType} = 'deleted';
+			}
+		} elsif ($m-&gt;{Access} eq 'public') {
+			# Add a setter method for a public instance variable
+			my $setMethod = $name;
+			if ($setMethod =~ /^(\w)(.*)/) {
+				my $ch = $1;
+				$ch =~ tr/a-z/A-Z/;
+				$setMethod = &quot;set$ch$2&quot;;
+			}
+			my $node = Ast::New( $setMethod );
+			$node-&gt;AddProp( &quot;NodeType&quot;, &quot;method&quot; );
+			# Flags of &quot;=&quot; for a setter method
+			$node-&gt;AddProp( &quot;Flags&quot;, &quot;=&quot; );
+			$node-&gt;AddProp( &quot;ReturnType&quot;, &quot;void&quot; );
+			$node-&gt;AddProp( &quot;Params&quot;, $varType );
+
+			my $param = Ast::New( 1 );
+			$param-&gt;AddProp( &quot;NodeType&quot;, &quot;param&quot; );
+			$param-&gt;AddProp( &quot;ArgType&quot;, $varType );
+			$node-&gt;AddPropList( &quot;ParamList&quot;, $param );
+
+			kdocAstUtil::attachChild( $classNode, $node );
+
+			# Register the type
+			registerType( $varType );
+		} else {
+			$m-&gt;{NodeType} = 'deleted';
+		}
+	}
+		},
+		undef
+	);
+	$main::doPrivate = $doPrivate;
+
+	print STDERR &quot;$className: ctor count: $constructorCount, hasPublicProtectedConstructor: $hasPublicProtectedConstructor, hasCopyConstructor: $hasCopyConstructor:, defaultConstructor: $defaultConstructor, hasPublicDestructor: $hasPublicDestructor, hasPrivatePureVirtual:$hasPrivatePureVirtual\n&quot; if ($debug);
+
+	my $isGlobalSpace = ($className eq $main::globalSpaceClassName);
+
+	# Note that if the class has _no_ constructor, the default ctor applies. Let's even generate it.
+	if ( !$constructorCount &amp;&amp; $defaultConstructor eq 'none' 
+		&amp;&amp; !$hasPrivatePureVirtual &amp;&amp; !$isGlobalSpace &amp;&amp; $classNode-&gt;{NodeType} ne 'namespace' ) {
+	    # Create a method node for the constructor
+	    my $methodNode = Ast::New( $classNode-&gt;{astNodeName} );
+	    $methodNode-&gt;AddProp( &quot;NodeType&quot;, &quot;method&quot; );
+	    $methodNode-&gt;AddProp( &quot;Flags&quot;, &quot;&quot; );
+	    $methodNode-&gt;AddProp( &quot;Params&quot;, &quot;&quot; );
+            $methodNode-&gt;AddProp( &quot;ParamList&quot;, [] );
+	    kdocAstUtil::attachChild( $classNode, $methodNode );
+
+	    # Hack the return type for constructors, since constructors return an object pointer
+	    $methodNode-&gt;AddProp( &quot;ReturnType&quot;, $className.&quot;*&quot; );
+	    registerType( $className.&quot;*&quot; );
+	    $methodNode-&gt;AddProp( &quot;Access&quot;, &quot;public&quot; ); # after attachChild
+	    $defaultConstructor = 'public';
+	    $hasPublicProtectedConstructor = 1;
+	}
+
+	# Also, if the class has no explicit destructor, generate a default one.
+	if ( !$hasDestructor &amp;&amp; !$hasPrivatePureVirtual &amp;&amp; !$isGlobalSpace &amp;&amp; $classNode-&gt;{NodeType} ne 'namespace' ) {
+	    my $methodNode = Ast::New( &quot;$classNode-&gt;{astNodeName}&quot; );
+	    $methodNode-&gt;AddProp( &quot;NodeType&quot;, &quot;method&quot; );
+	    $methodNode-&gt;AddProp( &quot;Flags&quot;, &quot;&quot; );
+	    $methodNode-&gt;AddProp( &quot;Params&quot;, &quot;&quot; );
+	    $methodNode-&gt;AddProp( &quot;ParamList&quot;, [] );
+	    kdocAstUtil::attachChild( $classNode, $methodNode );
+
+	    $methodNode-&gt;AddProp( &quot;ReturnType&quot;, &quot;~&quot; );
+	    $methodNode-&gt;AddProp( &quot;Access&quot;, &quot;public&quot; );
+	}
+
+	# If we have a private pure virtual, then the class can't be instanciated (e.g. QCanvasItem)
+	# Same if the class has only private constructors (e.g. QInputDialog)
+	$classNode-&gt;AddProp( &quot;CanBeInstanciated&quot;, $hasPublicProtectedConstructor &amp;&amp; !$hasPrivatePureVirtual );
+
+	# We will derive from the class only if it has public or protected constructors.
+	# (_Even_ if it has pure virtuals. But in that case the x_ class can't be instantiated either.)
+	$classNode-&gt;AddProp( &quot;BindingDerives&quot;, $hasPublicProtectedConstructor );
+
+	# We need a public dtor to destroy the object --- ### aren't protected dtors ok too ??
+	$classNode-&gt;AddProp( &quot;HasPublicDestructor&quot;, $hasPublicDestructor );
+
+	# Hack for QAsyncIO. We don't implement the &quot;if a class has no explicit copy ctor,
+	# then all of its member variables must be copiable, otherwise the class isn't copiable&quot;.
+	$hasPrivateCopyConstructor = 1 if ( $className eq 'QAsyncIO' );
+
+	# Remember if this class can't be copied - it means all its descendants can't either
+	$classNode-&gt;AddProp( &quot;CanBeCopied&quot;, !$hasPrivateCopyConstructor );
+	$classNode-&gt;AddProp( &quot;HasCopyConstructor&quot;, $hasCopyConstructor );
+}
+
+
+sub propagateCanBeCopied($)
+{
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	my @super = superclass_list($classNode);
+	# A class can only be copied if none of its ancestors have a private copy ctor.
+	for my $s (@super) {
+	    if (!$s-&gt;{CanBeCopied}) {
+		$classNode-&gt;{CanBeCopied} = 0;
+		print STDERR &quot;$classNode-&gt;{astNodeName} cannot be copied\n&quot; if ($debug);
+		last;
+	    }
+	}
+	# If the class has no explicit copy constructor, and it can be copied,
+	# generate the copy constructor.
+	if ( !$classNode-&gt;{HasCopyConstructor} &amp;&amp; $classNode-&gt;{CanBeCopied} &amp;&amp; $classNode-&gt;{CanBeInstanciated} ) {
+	    my $methodNode = Ast::New( &quot;$classNode-&gt;{astNodeName}&quot; );
+	    $methodNode-&gt;AddProp( &quot;NodeType&quot;, &quot;method&quot; );
+	    $methodNode-&gt;AddProp( &quot;Flags&quot;, &quot;ix&quot; ); # Only for internal use in marshallers
+	    my $argType = &quot;const &quot;.$className.&quot;&amp;&quot;;
+	    registerType( $argType );
+	    $methodNode-&gt;AddProp( &quot;Params&quot;, $argType );
+	    # The param node
+		my $node = Ast::New( 1 ); # let's make the arg index the node &quot;name&quot;
+		$node-&gt;AddProp( &quot;NodeType&quot;, &quot;param&quot; );
+		$node-&gt;AddProp( &quot;ArgType&quot;, $argType );
+		$methodNode-&gt;AddPropList( &quot;ParamList&quot;, $node );
+	    kdocAstUtil::attachChild( $classNode, $methodNode );
+
+	    # Hack the return type for constructors, since constructors return an object pointer
+	    $methodNode-&gt;AddProp( &quot;ReturnType&quot;, $className.&quot;*&quot; );
+	    registerType( $className.&quot;*&quot; );
+	    $methodNode-&gt;AddProp( &quot;Access&quot;, &quot;public&quot; ); # after attachChild
+	}
+
+	# Prepare the {case} dict for the class
+	prepareCaseDict( $classNode );
+}
+
+=head2 writeClassDoc
+
+	Called by writeDoc for each series of classes to be written out
+
+=cut
+
+BEGIN {
+
+my $fhn =1; # static
+
+  sub writeClassDoc
+  {
+	my $nodelist = shift;
+        my $file = &quot;$outputdir/x_${fhn}.cpp&quot;;
+        open( my $fh, &quot;&gt;$file&quot; ) || die &quot;Couldn't create $file\n&quot;;
+
+	print $fh &quot;//Auto-generated by $0. DO NOT EDIT.\n&quot;;
+ 	print $fh &quot;#include &lt;smoke.h&gt;\n&quot;;
+ 	print $fh &quot;#include &lt;${libname}_smoke.h&gt;\n&quot;;
+	
+        my @code;
+        for my $node ( @$nodelist )
+        {
+            push @code, [generateAllMethods( $node )]
+        }
+        my %includes;
+        map { for my $incl (keys %{$_-&gt;[2]}){ $includes{$incl}++ } } @code;
+
+	# Hack - some Qt/KDE headers need other headers included, but omit suitable #includes
+	if (defined $includes{&quot;qregexp.h&quot;} || defined $includes{&quot;qcstring.h&quot;}) {
+	    print $fh &quot;#include &lt;qregexp.h&gt;\n&quot;;
+		delete $includes{&quot;qregexp.h&quot;};
+	}
+	if (defined $includes{&quot;qmime.h&quot;} || defined $includes{&quot;qmimedata.h&quot;}) {
+	    print $fh &quot;#include &lt;qurl.h&gt;\n&quot;;
+		delete $includes{&quot;qurl.h&quot;};
+	}
+	if (defined $includes{&quot;kshortcut.h&quot;}) {
+	    print $fh &quot;#include &lt;kshortcut.h&gt;\n&quot;;
+		delete $includes{&quot;kshortcut.h&quot;};
+	} 
+	if (defined $includes{&quot;kshortcutlist.h&quot;}) {
+	    print $fh &quot;#include &lt;kconfigbase.h&gt;\n&quot;;
+	    print $fh &quot;#include &lt;kshortcutlist.h&gt;\n&quot;;
+		delete $includes{&quot;kconfigbase.h&quot;};
+		delete $includes{&quot;kshortcutlist.h&quot;};
+	}
+	if (defined $includes{&quot;kaction.h&quot;}) {
+	    print $fh &quot;#include &lt;kaction.h&gt;\n&quot;;
+		delete $includes{&quot;kaction.h&quot;};
+	}
+	foreach my $incl (keys %includes) {
+	    die if $incl eq '';
+	    print $fh &quot;#include &lt;$incl&gt;\n&quot;;
+	}	
+	print $fh &quot;\n&quot;;
+        for my $c( 0..$#code )
+        {
+           my ($methodCode, $switchCode, $incl) = @{ $code[$c] };
+           my $node = $$nodelist[$c];
+           my $className = join( &quot;::&quot;, kdocAstUtil::heritage($node) );
+           my $legacyClassName = join( &quot;__&quot;, kdocAstUtil::heritage($node) );
+           print $fh &quot;class x_$legacyClassName &quot;;
+           print $fh &quot;: public $className &quot; if $node-&gt;{BindingDerives};
+           print $fh &quot;{\n&quot;;
+           print $fh $methodCode;
+           print $fh &quot;};\n&quot;;
+	   if(keys %{$node-&gt;{enumerations}}) {
+	        print $fh &quot;void xenum_${legacyClassName}(Smoke::EnumOperation xop, Smoke::Index xtype, void *&amp;xdata, long &amp;xvalue) {\n&quot;;
+	        print $fh &quot;    x_${legacyClassName}\::xenum_operation(xop, xtype, xdata, xvalue);\n&quot;;
+	        print $fh &quot;}\n&quot;;
+	   }
+	   print $fh &quot;void xcall_${legacyClassName}(Smoke::Index xi, void *obj, Smoke::Stack args) {\n&quot;;
+	   print $fh $switchCode;
+	   print $fh &quot;}\n\n&quot;;
+        }
+	#if ( $className =~ /^(QBrush|QColor|QCursor|QFont|QImage|QPalette|QPixmap|QPoint|QPointArray|QRect|QRegion|QSize|QWMatrix)$/ ) {
+	#	print XCPPFILE &quot;    const char *{serial} operator &lt;&lt; () const : pig_serialize(\$this);\n&quot;;
+	#	print XCPPFILE &quot;    void operator &gt;&gt; (const char *{serial}) : pig_deserialize(\$this, \$1);\n&quot;;
+	#}
+
+	close $fh;
+        $fhn++
+  }
+
+}
+
+# Generate the prototypes for a method (one per arg with a default value)
+# Helper for makeprotos
+sub iterproto($$$$$) {
+    my $classidx = shift; # to check if a class exists
+    my $method = shift;
+    my $proto = shift;
+    my $idx = shift;
+    my $protolist = shift;
+
+    my $argcnt = scalar @{ $method-&gt;{ParamList} } - 1;
+    if($idx &gt; $argcnt) {
+	push @$protolist, $proto;
+	return;
+    }
+    if(defined $method-&gt;{FirstDefaultParam} and $method-&gt;{FirstDefaultParam} &lt;= $idx) {
+	push @$protolist, $proto;
+    }
+
+    my $arg = $method-&gt;{ParamList}[$idx]-&gt;{ArgType};
+
+    my $typeEntry = findTypeEntry( $arg );
+    my $realType = $typeEntry-&gt;{realType};
+
+    # A scalar ?
+    $arg =~ s/\bconst\b//g;
+    $arg =~ s/\s+//g;
+    if($typeEntry-&gt;{isEnum} || $allTypes{$realType}{isEnum} || exists $typeunion{$realType} || exists $mungedTypeMap{$arg})
+    {
+	my $id = '$'; # a 'scalar
+	$id = '?' if $arg =~ /[*&amp;]{2}/;
+	$id = $mungedTypeMap{$arg} if exists $mungedTypeMap{$arg};
+	iterproto($classidx, $method, $proto . $id, $idx + 1, $protolist);
+	return;
+    }
+
+    # A class ?
+    if(exists $classidx-&gt;{$realType}) {
+	iterproto($classidx, $method, $proto . '#', $idx + 1, $protolist);
+	return;
+    }
+
+    # A non-scalar (reference to array or hash, undef)
+    iterproto($classidx, $method, $proto . '?', $idx + 1, $protolist);
+    return;
+}
+
+# Generate the prototypes for a method (one per arg with a default value)
+sub makeprotos($$$) {
+    my $classidx = shift;
+    my $method = shift;
+    my $protolist = shift;
+    iterproto($classidx, $method, $method-&gt;{astNodeName}, 0, $protolist);
+}
+
+# Return the string containing the signature for this method (without return type).
+# If the 2nd arg is not the size of $m-&gt;{ParamList}, this method returns a
+# partial signature (this is used to handle default values).
+sub methodSignature($$) {
+    my $method = shift;
+    my $last = shift;
+    my $sig = $method-&gt;{astNodeName};
+    my @argTypeList;
+    my $argId = 0;
+    foreach my $arg ( @{$method-&gt;{ParamList}} ) {
+	last if $argId &gt; $last;
+	push @argTypeList, $arg-&gt;{ArgType};
+	$argId++;
+    }
+    $sig .= &quot;(&quot;. join(&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">, at argTypeList</A>) .&quot;)&quot;;
+    $sig .= &quot; const&quot; if $method-&gt;{Flags} =~ &quot;c&quot;;
+    return $sig;
+}
+
+sub coerce_type($$$$) {
+    #my $m = shift;
+    my $union = shift;
+    my $var = shift;
+    my $type = shift;
+    my $new = shift; # 1 if this is a return value, 0 for a normal param
+
+    my $typeEntry = findTypeEntry( $type );
+    my $realType = $typeEntry-&gt;{realType};
+
+    my $unionfield = $typeEntry-&gt;{typeId};
+    die &quot;$type&quot; unless defined( $unionfield );
+    $unionfield =~ s/t_/s_/;
+
+    $type =~ s/\s+const$//; # for 'char* const'
+    $type =~ s/\s+const\s*\*$/\*/; # for 'char* const*'
+
+    my $code = &quot;$union.$unionfield = &quot;;
+    if($type =~ /&amp;$/) {
+	$code .= &quot;(void*)&amp;$var;\n&quot;;
+    } elsif($type =~ /\*$/) {
+	$code .= &quot;(void*)$var;\n&quot;;
+    } else {
+	if ( $unionfield eq 's_class' 
+		or ( $unionfield eq 's_voidp' and $type ne 'void*' )
+		or $type eq 'QString' ) { # hack
+	    $type =~ s/^const\s+//;
+	    if($new) {
+	        $code .= &quot;(void*)new $type($var);\n&quot;;
+	    } else {
+	        $code .= &quot;(void*)&amp;$var;\n&quot;;
+	    }
+	} else {
+	    $code .= &quot;$var;\n&quot;;
+	}
+    }
+
+    return $code;
+}
+
+# Generate the list of args casted to their real type, e.g.
+# (QObject*)x[1].s_class,(QEvent*)x[2].s_class,x[3].s_int
+sub makeCastedArgList
+{
+    my @castedList;
+    my $i = 1; # The args start at x[1]. x[0] is the return value
+    my $arg;
+    foreach $arg (@_) {
+	my $type = $arg;
+	my $cast;
+
+	my $typeEntry = findTypeEntry( $type );
+	my $unionfield = $typeEntry-&gt;{typeId};
+	die &quot;$type&quot; unless defined( $unionfield );
+	$unionfield =~ s/t_/s_/;
+
+	$type =~ s/\s+const$//; # for 'char* const'
+	$type =~ s/\s+const\s*\*$/\*/; # for 'char* const*'
+
+	my $v .= &quot;x[$i].$unionfield&quot;;
+	if($type =~ s/&amp;$//) {
+	    $cast = &quot;*($type *)&quot;;
+	} elsif($type =~ /\*$/) {
+	    $cast = &quot;($type)&quot;;
+        } elsif($type =~ /\(\*\)\s*\(/) { # function pointer ... (*)(...)
+            $cast = &quot;($type)&quot;;
+	} else {
+	    if ( $unionfield eq 's_class'
+		or ( $unionfield eq 's_voidp' and $type ne 'void*' )
+		or $type eq 'QString' ) { # hack
+	        $cast = &quot;*($type *)&quot;;
+	    } else {
+	        $cast = &quot;($type)&quot;;
+	    }
+	}
+	push @castedList, &quot;$cast$v&quot;;
+	$i++;
+    }
+    return @castedList;
+}
+
+# Adds the header for node $1 to be included in $2 if not already there
+# Prints out debug stuff if $3
+sub addIncludeForClass($$$)
+{
+    my ( $node, $addInclude, $debugMe ) = @_;
+    my $sourcename = $node-&gt;{Source}-&gt;{astNodeName};
+    if ( $sourcename !~ s!.*($headerSubdirectories)(.*)!$1$2!m ) {
+    	$sourcename =~ s!.*/(.*)!$1!m;
+	}
+#    die &quot;Empty source name for $node-&gt;{astNodeName}&quot; if ( $sourcename eq '' );
+    return if ( $sourcename eq '' );
+    unless ( defined $addInclude-&gt;{$sourcename} ) {
+	print &quot;  Including $sourcename\n&quot; if ($debugMe);
+	$addInclude-&gt;{$sourcename} = 1;
+    }
+    else { print &quot;  $sourcename already included.\n&quot; if ($debugMe); }
+}
+
+sub checkIncludesForObject($$)
+{
+    my $type = shift;
+    my $addInclude = shift;
+
+    my $debugCI = 0; #$debug
+    #print &quot;checkIncludesForObject $type\n&quot;;
+    $type =~ s/const\s+//;
+    my $it = $type;
+    if (!($it and exists $typeunion{$it}) and $type !~ /\*/
+         #and $type !~ /&amp;/  # in fact we also want refs, due to the generated code
+        ) {
+	$type =~ s/&amp;//;
+	print &quot;  Detecting an object by value/ref: $type\n&quot; if ($debugCI);
+	my $node = kdocAstUtil::findRef( $rootnode, $type );
+	if ($node) {
+	    addIncludeForClass( $node, $addInclude, $debugCI );
+	}
+	else { print &quot; No header found for $type\n&quot; if ($debugCI); }
+    }
+}
+
+sub generateVirtualMethod($$$$$)
+{
+    # Generating methods for $class.
+    # $m: method node. $methodClass: the node of the class in which the method is really declared
+    # (can be different from $class when the method comes from a super class)
+    # This is important because of $allMethods, which has no entry for class::method in that case.
+
+    my( $classNode, $signature, $m, $methodClass, $addInclude ) = @_;
+    my $methodCode = '';                    # output
+    my $returnType = $m-&gt;{ReturnType};
+    return ('', '') if $returnType eq '~'; # skip destructors
+
+    my $className = $classNode-&gt;{astNodeName};
+    my $flags = $m-&gt;{Flags};
+    my @argList = @{$m-&gt;{ParamList}};
+
+    print &quot;generateVirtualMethod $className: $signature  ($m-&gt;{Access})\n&quot; if ($debug);
+
+    # Detect objects returned by value
+    checkIncludesForObject( $returnType, $addInclude ) if ($returnType ne 'void');
+
+    # Generate a matching virtual method in the x_ class
+    $methodCode .= &quot;    virtual $returnType $m-&gt;{astNodeName}(&quot;;
+    my $i = 0;
+    foreach my $arg ( @argList ) {
+        $methodCode .= &quot;, &quot; if $i++;
+        $methodCode .= $arg-&gt;{ArgType};
+        $methodCode .= &quot; x$i&quot;;
+
+	# Detect objects passed by value
+	checkIncludesForObject( $arg-&gt;{ArgType}, $addInclude );
+    }
+    $methodCode .= &quot;) &quot;;
+    $methodCode .= &quot;const &quot; if ($flags =~ &quot;c&quot;);
+    $methodCode .= &quot;\{\n&quot;;
+
+    # Now the code of the method
+    my $this = $classNode-&gt;{BindingDerives} &gt; 0 ? &quot;this&quot; : &quot;xthis&quot;;
+
+    $i++; # Now the number of args
+    $methodCode .= &quot;\tSmoke::StackItem x[$i];\n&quot;;
+    $i = 1;
+    for my $arg (@argList) {
+	$methodCode .= &quot;\t&quot;;
+	$methodCode .= coerce_type(&quot;x[$i]&quot;, &quot;x$i&quot;, $arg-&gt;{ArgType}, 0);
+	$i++;
+    }
+
+    my $sig = $methodClass-&gt;{astNodeName} . &quot;::&quot; . $signature;
+    my $idx = $allMethods{$sig};
+    
+	if ( ! defined $idx ) {
+		my $class_name = join( &quot;::&quot;, kdocAstUtil::heritage($methodClass) );
+		$sig = $class_name . &quot;::&quot; . $signature;
+		$idx = $allMethods{$sig};
+	}
+#    die &quot;generateVirtualMethod: $className: No method found for $sig\n&quot; if !defined $idx;
+
+if ( !defined $idx ) {
+    print &quot;generateVirtualMethod: $className: No method found for $sig\n&quot;;
+    return ('', '');
+}
+
+    if($flags =~ &quot;p&quot;) { # pure virtual
+	$methodCode .= &quot;\t${libname}_Smoke-&gt;binding-&gt;callMethod($idx, (void*)$this, x, true /*pure virtual*/);\n&quot;;
+    } else {
+	$methodCode .= &quot;\tif(${libname}_Smoke-&gt;binding-&gt;callMethod($idx, (void*)$this, x)) &quot;;
+    }
+
+    $returnType = undef if ($returnType eq 'void');
+    if($returnType) {
+	my $arg = $returnType;
+	my $it = applyTypeDef( $arg );
+	my $cast;
+	my $v = &quot;x[0]&quot;;
+	my $indent = ($flags =~ &quot;p&quot;) ? &quot;\t&quot; : &quot;&quot;;
+	if($it and exists $typeunion{$it}) {
+	    $v .= &quot;.$typeunion{$it}&quot;;
+	    $cast = &quot;($arg)&quot;;
+	    $methodCode .= &quot;${indent}return $cast$v;\n&quot;;
+	} else {
+	    $v .= &quot;.s_class&quot;;
+	    if($arg =~ s/&amp;//) {
+		$cast = &quot;*($arg *)&quot;;
+		$methodCode .= &quot;${indent}return $cast$v;\n&quot;;
+	    } elsif($arg !~ /\*$/) {
+		unless($flags =~ &quot;p&quot;) {
+		    $indent = &quot;\t    &quot;;
+		    $methodCode .= &quot;{\n&quot;;
+		}
+		# we assume it's a new thing, and handle it
+		$methodCode .= &quot;${indent}$arg *xptr = ($arg *)$v;\n&quot;;
+		$methodCode .= &quot;${indent}$arg xret(*xptr);\n&quot;;
+		$methodCode .= &quot;${indent}delete xptr;\n&quot;;
+		$methodCode .= &quot;${indent}return xret;\n&quot;;
+		$methodCode .= &quot;\t}\n&quot; unless $flags =~ &quot;p&quot;;
+	    } else {
+		$cast = &quot;($arg)&quot;;
+		$methodCode .= &quot;${indent}return $cast$v;\n&quot;;
+	    }
+	}
+    } else {
+	$methodCode .= &quot;\t&quot; if $flags =~ &quot;p&quot;;
+	$methodCode .= &quot;return;\n&quot;;
+    }
+    if($flags =~ &quot;p&quot;) {
+	$methodCode .= &quot;\t// ABSTRACT\n&quot;;
+	$methodCode .= &quot;    }\n&quot;;
+	return ( $methodCode );
+    }
+    $methodCode .= &quot;\t&quot;;
+    if($returnType) {
+	$methodCode .= &quot;return &quot;;
+    }
+    $methodCode .= &quot;$this\-&gt;$methodClass-&gt;{astNodeName}\::$m-&gt;{astNodeName}(&quot;;
+    $i = 0;
+    for my $arg (@argList) {
+	$methodCode .= &quot;, &quot; if $i++;
+	$methodCode .= &quot;x$i&quot;;
+    }
+    $methodCode .= &quot;);\n&quot;;
+    $methodCode .= &quot;    }\n&quot;;
+    return ( $methodCode );
+}
+
+sub generateMethod($$$)
+{
+    my( $classNode, $m, $addInclude ) = @_;	# input
+    my $methodCode = '';	# output
+    my $switchCode = '';	# output
+
+    my $name = $m-&gt;{astNodeName}; # method name
+    my @heritage = kdocAstUtil::heritage($classNode);
+    my $className  = join( &quot;::&quot;, @heritage );
+    my $xClassName  = &quot;x_&quot; . join( &quot;__&quot;, @heritage );
+
+    # Check some method flags: constructor, destructor etc.
+    my $flags = $m-&gt;{Flags};
+
+    if ( !defined $flags ) {
+	warn &quot;Method &quot;.$name.  &quot; has no flags\n&quot;;
+    }
+
+    my $returnType = $m-&gt;{ReturnType};
+
+    $returnType = undef if ($returnType eq 'void');
+
+    # Don't use $className here, it's never the fully qualified (A::B) name for a ctor.
+    my $isConstructor = ($name eq $classNode-&gt;{astNodeName} );
+    my $isDestructor = ($returnType eq '~');
+
+    if ($debug) {
+        print STDERR &quot; Method $name&quot;;
+	print STDERR &quot;, is DTOR&quot; if $isDestructor;
+	print STDERR &quot;, returns $returnType&quot; if $returnType;
+	#print STDERR &quot; ($m-&gt;{Access})&quot;;
+	print STDERR &quot;\n&quot;;
+    }
+
+    # Don't generate anything for destructors
+    return if $isDestructor;
+
+    return if ( $m-&gt;{SkipFromSwitch} ); # pure virtuals, etc.
+
+#    # Skip internal methods, which return unknown types
+#    # Hmm, the C# bindings have a list of those too.
+#    return if ( $returnType =~ m/QGfx\s*\*/ );
+#    return if ( $returnType eq 'CGContextRef' );
+#    return if ( $returnType eq 'QWSDisplay *' );
+#    # This stuff needs callback, or **
+#    return if ( $name eq 'defineIOHandler' or $name eq 'qt_init_internal' );
+#    # Skip casting operators, but not == &lt; etc.
+#    return if ( $name =~ /operator \w+/ );
+#    # QFile's EncoderFn/DecoderFn
+#    return if ( $name =~ /set[ED][ne]codingFunction/ );
+#    # How to implement this? (QXmlDefaultHandler/QXmlEntityResolver::resolveEntity, needs A*&amp;)
+#    return if ( $name eq 'resolveEntity' and $className =~ /^QXml/ );
+#    return if ( $className eq 'QBitArray' &amp;&amp; $m-&gt;{Access} eq 'protected' );
+
+    #print STDERR &quot;Tests passed, generating.\n&quot;;
+
+    # Detect objects returned by value
+    checkIncludesForObject( $returnType, $addInclude ) if ($returnType);
+
+    my $argId = 0;
+
+    my @argTypeList=();
+
+    foreach my $arg ( @{$m-&gt;{ParamList}} ) {
+
+	print STDERR &quot;  Param &quot;.$arg-&gt;{astNodeName}.&quot; type: &quot;.$arg-&gt;{ArgType}.&quot; name:&quot;.$arg-&gt;{ArgName}.&quot; default: &quot;.$arg-&gt;{DefaultValue}.&quot;\n&quot; if ($debug);
+
+	my $argType = $arg-&gt;{ArgType};
+	push @argTypeList, $argType;
+		
+	# Detect objects passed by value
+	checkIncludesForObject( $argType, $addInclude );
+	}    
+
+    my @castedArgList = makeCastedArgList( @argTypeList );
+
+    my $isStatic = $flags =~ &quot;s&quot;;
+
+    my $extra = &quot;&quot;;
+    $extra .= &quot;static &quot; if $isStatic || $isConstructor || $classNode-&gt;{NodeType} eq 'namespace';
+
+    my $attr = &quot;&quot;;
+    $attr .= &quot;const &quot; if $flags =~ &quot;c&quot;;
+
+    my $this = $classNode-&gt;{BindingDerives} &gt; 0 ? &quot;this&quot; : &quot;xthis&quot;;
+
+    # We iterate as many times as we have default params
+    my $firstDefaultParam = $m-&gt;{FirstDefaultParam};
+    $firstDefaultParam = scalar(@argTypeList) unless defined $firstDefaultParam;
+    my $iterationCount = scalar(@argTypeList) - $firstDefaultParam;
+
+    my $xretCode = '';
+    if($returnType) {
+	$xretCode .= coerce_type('x[0]', 'xret', $returnType, 1);
+    }
+
+    print STDERR &quot;  &quot;. ($iterationCount+1). &quot; iterations for $name\n&quot; if ($debug);
+
+    while($iterationCount &gt;= 0) {
+
+	local($&quot;) = &quot;,&quot;;
+	# Handle case of a class with constructors, but with a private pure virtual
+	# so we can't create an instance of it
+	if($isConstructor and !$classNode-&gt;{CanBeInstanciated}) {
+
+	    # We still generate &quot;forwarder constructors&quot; for x_className though
+	    $methodCode .= &quot;    $xClassName(&quot;;
+	    my $i = 0;
+	    for my $arg (@argTypeList) {
+		$methodCode .= &quot;, &quot; if $i++;
+		$methodCode .= &quot;$arg x$i&quot;;
+	    }
+	    $methodCode .= &quot;) : $className(&quot;;
+	    $i = 0;
+	    for my $arg (@argTypeList) {
+		$methodCode .= &quot;, &quot; if $i++;
+		$methodCode .= &quot;x$i&quot;;
+	    }
+	    $methodCode .= &quot;) {}\n&quot;;
+
+	} else {
+
+	    $switchCode .= &quot;\tcase $methodNumber: &quot;;
+	    if ($flags =~ &quot;s&quot; || $isConstructor || $classNode-&gt;{NodeType} eq 'namespace') { # static, namespace or constructor
+	        $switchCode .= &quot;$xClassName\::&quot;;
+	    } else {
+	        $switchCode .= &quot;xself-&gt;&quot;
+	    }
+	    $switchCode .= &quot;x_$methodNumber(args);&quot;;
+	    $switchCode .= &quot;\tbreak;\n&quot;;
+
+	    $methodCode .= &quot;    ${extra}void x_$methodNumber\(Smoke::Stack x) $attr\{\n&quot;;
+	    my $cplusplusparams = join( &quot;, &quot;, @argTypeList );
+	    $methodCode .= &quot;\t// $name($cplusplusparams)\n&quot;;
+	    $methodCode .= &quot;\t&quot;;
+	
+	    if ($isConstructor) {
+
+	        $methodCode .= &quot;$xClassName* xret = new $xClassName(@castedArgList[0..$#argTypeList]);\n&quot;;
+	        #$m-&gt;{retnew} = 1;
+	        $methodCode .= &quot;\tx[0].s_class = (void*)xret;\n&quot;; # the return value, containing the new object
+	        $methodCode .= &quot;    }\n&quot;;
+
+	        # Now generate the actual constructor for x_className
+	        # (Simply a forwarder to the className constructor with the same args
+			if ( $flags =~ &quot;t&quot; ) {
+	        	$methodCode .= &quot;    explicit $xClassName(&quot;;
+			} else {
+	        	$methodCode .= &quot;    $xClassName(&quot;;
+			}
+	        my $i = 0;
+	        for my $arg (@argTypeList) {
+		    $methodCode .= &quot;, &quot; if $i++;
+                    if ($arg =~ s/\(\*\)/(* x$i)/) { # function pointer... need to insert argname inside
+                        $methodCode .= $arg;
+                    } else {
+		    $methodCode .= &quot;$arg x$i&quot;;
+                    }
+	        }
+	        $methodCode .= &quot;) : $className(&quot;;
+	        $i = 0;
+	        for my $arg (@argTypeList) {
+		    $methodCode .= &quot;, &quot; if $i++;
+		    $methodCode .= &quot;x$i&quot;;
+	        }
+	        $methodCode .= &quot;) {\n&quot;;
+
+	    } else {
+	        $methodCode .= $returnType . &quot; xret = &quot; if $returnType;
+	        $methodCode .= &quot;$this\-&gt;&quot; unless $isStatic || $classNode-&gt;{NodeType} eq 'namespace';
+		if ($className ne $main::globalSpaceClassName) {
+			if ($flags =~ &quot;=&quot;) {
+				# Setter method for a public instance variable
+				my $varName = $name;
+				$varName =~ /^set(\w)(.*)/;
+				my $ch = $1;
+				$ch =~ tr/A-Z/a-z/;
+				$varName = $ch . $2;
+				$methodCode .= &quot;$varName = @castedArgList[0..$#argTypeList];\n&quot;;
+			} else {
+		    	$methodCode .= &quot;$className\::$name(@castedArgList[0..$#argTypeList]);\n&quot;;
+			}
+		} elsif ($name =~ /^operator\s?\W+/) {
+		    ( my $op = $name ) =~ s/^operator(.*)$/$1/;
+		    if (scalar(@argTypeList) == 2) {
+                        if( $name =~ /^operator(?:\+\+|--)/ ) { # postfix increment/decrement
+                            $methodCode .= &quot;(@castedArgList[0])$op;\n&quot;;
+                        } else {
+			    $methodCode .= &quot;(@castedArgList[0] $op @castedArgList[1]);\n&quot;; # a + b
+                        }
+		    } elsif (scalar(@argTypeList) == 1) {
+			$methodCode .= &quot;$op(@castedArgList[0]);\n&quot;; # -a
+		    } else {
+			die &quot;shouldn't reach here!&quot;;
+		    }
+		} else {
+		    $methodCode .= &quot;$name(@castedArgList[0..$#argTypeList]);\n&quot;;
+		}
+	        $methodCode .= &quot;\t&quot; . $xretCode if $returnType;
+		# To avoid unused parameter warning, add this to void methods:
+		$methodCode .= &quot;\t(void)x; // noop (for compiler warning)\n&quot; unless $returnType;
+	    }
+	    $methodCode .= &quot;    }\n&quot;;
+    }
+
+
+	pop @argTypeList;
+	$methodNumber++;
+	$iterationCount--;
+    } # Iteration loop
+
+    return ( $methodCode, $switchCode );
+}
+
+
+sub generateEnum($$$)
+{
+    my( $classNode, $m, $addInclude ) = @_;	# input
+    my $methodCode = '';	# output
+    my $switchCode = '';	# output
+
+    my @heritage = kdocAstUtil::heritage($classNode);
+    my $className  = join( &quot;::&quot;, @heritage );
+    my $xClassName  = &quot;x_&quot; . join( &quot;__&quot;, @heritage );
+    
+	my $fullEnumType = &quot;$className\::&quot;. $m-&gt;{astNodeName};
+	checkIncludesForObject( $fullEnumType, $addInclude );
+
+    foreach my $enum ( @{$m-&gt;{ParamList}} ) {
+	my $enumName = $enum-&gt;{ArgName};
+	my $fullEnumName = &quot;$className\::$enumName&quot;;
+        die &quot;Invalid index for $fullEnumName: $classNode-&gt;{case}{$fullEnumName} instead of $methodNumber&quot; if $classNode-&gt;{case}{$fullEnumName} != $methodNumber;
+	$methodCode .= &quot;    static void x_$methodNumber(Smoke::Stack x) {\n&quot;;
+	$methodCode .= &quot;\tx[0].s_enum = (long)$fullEnumName;\n&quot;;
+        $methodCode .= &quot;    }\n&quot;;
+        $switchCode .= &quot;\tcase $methodNumber: $xClassName\::x_$methodNumber(args);\tbreak;\n&quot;;
+        $methodNumber++;
+    }
+
+    return ( $methodCode, $switchCode );
+}
+
+sub generateVar($$$)
+{
+    my( $classNode, $m, $addInclude ) = @_;	# input
+    my $methodCode = '';	# output
+    my $switchCode = '';	# output
+
+    my @heritage = kdocAstUtil::heritage($classNode);
+    my $className  = join( &quot;::&quot;, @heritage );
+    my $xClassName  = &quot;x_&quot; . join( &quot;__&quot;, @heritage );
+
+    my $name = $m-&gt;{astNodeName};
+    my $varType = $m-&gt;{Type};
+    $varType =~ s/static\s//;
+    $varType =~ s/const\s+(.*)\s*&amp;/$1/;
+    $varType =~ s/\s*$//;
+    my $fullName = &quot;$className\::$name&quot;;
+    my $this = $classNode-&gt;{BindingDerives} &gt; 0 ? &quot;this&quot; : &quot;xthis&quot;;
+
+    checkIncludesForObject( $varType, $addInclude );
+
+    die &quot;Invalid index for $fullName: $classNode-&gt;{case}{$fullName} instead of $methodNumber&quot; if $classNode-&gt;{case}{$fullName} != $methodNumber;
+	if ( $m-&gt;{Flags} =~ &quot;s&quot; ) {	
+    	$methodCode .= &quot;    static void x_$methodNumber(Smoke::Stack x) {\n        &quot;;
+    	$methodCode .= coerce_type('x[0]', $fullName, $varType, 1);
+    	$methodCode .= &quot;    }\n&quot;;
+    	$switchCode .= &quot;\tcase $methodNumber: $xClassName\::x_$methodNumber(args);\tbreak;\n&quot;;
+	} else {
+    	$methodCode .= &quot;    void x_$methodNumber(Smoke::Stack x) {\n        &quot;;
+    	$methodCode .= coerce_type('x[0]', &quot;$this-&gt;$name&quot;, $varType, 1);
+    	$methodCode .= &quot;    }\n&quot;;
+    	$switchCode .= &quot;\tcase $methodNumber: xself-&gt;x_$methodNumber(args);\tbreak;\n&quot;;
+	}
+
+    $methodNumber++;
+
+    return ( $methodCode, $switchCode );
+}
+
+sub generateEnumCast($)
+{
+    my( $classNode ) = @_;
+    my $methodCode = '';
+    return unless keys %{$classNode-&gt;{enumerations}};
+    $methodCode .= &quot;    static void xenum_operation(Smoke::EnumOperation xop, Smoke::Index xtype, void *&amp;xdata, long &amp;xvalue) {\n&quot;;
+    $methodCode .= &quot;\tswitch(xtype) {\n&quot;;
+    for my $enum (values %{$classNode-&gt;{enumerations}}) {
+	
+	# Hack - this shouldn't be needed here - deprecated enums
+	next if ($enum eq 'KStatusBar::BarStatus' 
+				or $enum eq 'KMdi::AddWindowFlags' 
+				or $enum eq 'KToolBar::BarStatus' 
+				or $enum eq 'KMimeType::Format:: compression : 4');
+	
+	my $type = findTypeEntry($enum);
+	$methodCode .= &quot;\t  case $type-&gt;{index}: //$enum\n&quot;;
+	$methodCode .= &quot;\t    switch(xop) {\n&quot;;
+	$methodCode .= &quot;\t      case Smoke::EnumNew:\n&quot;;
+	$methodCode .= &quot;\t\txdata = (void*)new $enum;\n&quot;;
+	$methodCode .= &quot;\t\tbreak;\n&quot;;
+	$methodCode .= &quot;\t      case Smoke::EnumDelete:\n&quot;;	# unnecessary
+	$methodCode .= &quot;\t\tdelete ($enum*)xdata;\n&quot;;
+	$methodCode .= &quot;\t\tbreak;\n&quot;;
+	$methodCode .= &quot;\t      case Smoke::EnumFromLong:\n&quot;;
+	$methodCode .= &quot;\t\t*($enum*)xdata = ($enum)xvalue;\n&quot;;
+	$methodCode .= &quot;\t\tbreak;\n&quot;;
+	$methodCode .= &quot;\t      case Smoke::EnumToLong:\n&quot;;
+	$methodCode .= &quot;\t\txvalue = (long)*($enum*)xdata;\n&quot;;
+	$methodCode .= &quot;\t\tbreak;\n&quot;;
+	$methodCode .= &quot;\t    }\n&quot;;
+	$methodCode .= &quot;\t    break;\n&quot;;
+    }
+    $methodCode .= &quot;\t}\n&quot;;
+    $methodCode .= &quot;    }\n&quot;;
+
+    return $methodCode;
+} 
+
+## Called by writeClassDoc
+sub generateAllMethods
+{
+    my ($classNode) = @_;
+    my $methodCode = '';
+    my $switchCode = '';
+    $methodNumber = 0;
+
+    #my $className = $classNode-&gt;{astNodeName};
+    my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+    my $xClassName = &quot;x_&quot; . join( &quot;__&quot;, kdocAstUtil::heritage($classNode) );
+    my $isGlobalSpace = ($xClassName eq (&quot;x_&quot;.$main::globalSpaceClassName));
+    my $sourcename = $classNode-&gt;{Source}-&gt;{astNodeName};
+   
+    if ( $sourcename !~ s!.*($headerSubdirectories)(.*)!$1$2!m ) {
+    	$sourcename =~ s!.*/(.*)!$1!m;
+	}
+    die &quot;Empty source name for $classNode-&gt;{astNodeName}&quot; if ( $sourcename eq '' );
+
+    my %addInclude = ( $sourcename =&gt; 1 );
+
+    if (!$isGlobalSpace) {
+        if($classNode-&gt;{NodeType} eq 'namespace') {
+           $switchCode .= &quot;    (void)obj;\n&quot;;
+            $methodCode .= &quot;public:\n&quot;;
+        	my $s;
+        	for my $sn( @{$classNode-&gt;{Sources}} ) {
+    		if ( ($s = $sn-&gt;{astNodeName}) !~ s!.*($headerSubdirectories)(.*)!$1$2!m ) {
+    			$s =~ s!.*/(.*)!$1!m;
+			}
+			$addInclude{ $s } = 1;
+        	}
+         } elsif(! $classNode-&gt;{BindingDerives}) {
+            $methodCode .= &quot;private:\n&quot;;
+            $methodCode .= &quot;    $className *xthis;\n&quot;;
+            $methodCode .= &quot;public:\n&quot;;
+            $methodCode .= &quot;    $xClassName\(void *x) : xthis(($className*)x) {}\n&quot;;
+            $switchCode .= &quot;    $xClassName xtmp(obj), *xself = &xtmp;\n&quot;;
+        } else {
+            $switchCode .= &quot;    $xClassName *xself = ($xClassName*)obj;\n&quot;;
+            $methodCode .= &quot;public:\n&quot;;
+        }
+    } else {
+        my $s;
+        for my $sn( @{$classNode-&gt;{Sources}} ) {
+    	if ( ($s = $sn-&gt;{astNodeName}) !~ s!.*($headerSubdirectories)(.*)!$1$2!m ) {
+    		$s =~ s!.*/(.*)!$1!m;
+		}
+		$addInclude{ $s } = 1;
+        }
+	$methodCode .= &quot;public:\n&quot;;
+	$switchCode .= &quot;    (void) obj;\n&quot;;
+    }
+    $switchCode .= &quot;    switch(xi) {\n&quot;;
+
+    # Do all enums first
+    Iter::MembersByType ( $classNode, undef,
+			  sub {	my ($classNode, $methodNode ) = @_;
+				
+	if ( $methodNode-&gt;{NodeType} eq 'enum' ) {
+	    my ($meth, $swit) = generateEnum( $classNode, $methodNode, \%addInclude );
+	    $methodCode .= $meth;
+	    $switchCode .= $swit;
+	}
+				}, undef );
+
+    # Then all static vars
+    Iter::MembersByType ( $classNode, undef,
+			  sub {	my ($classNode, $methodNode ) = @_;
+				
+	if ( $methodNode-&gt;{NodeType} eq 'var' ) {
+	    my ($meth, $swit) = generateVar( $classNode, $methodNode, \%addInclude );
+	    $methodCode .= $meth;
+	    $switchCode .= $swit;
+	}
+				}, undef );
+
+    # Then all methods
+    Iter::MembersByType ( $classNode, undef,
+			  sub {	my ($classNode, $methodNode ) = @_;
+
+        if ( $methodNode-&gt;{NodeType} eq 'method' ) {
+	    my ($meth, $swit) = generateMethod( $classNode, $methodNode, \%addInclude );
+	    $methodCode .= $meth;
+	    $switchCode .= $swit;
+	}
+			      }, undef );
+
+    # Virtual methods
+    if ($classNode-&gt;{BindingDerives}) {
+	my %virtualMethods;
+	allVirtualMethods( $classNode, \%virtualMethods );
+
+	for my $sig (sort keys %virtualMethods) {
+            my ($meth) = generateVirtualMethod( $classNode, $sig, $virtualMethods{$sig}{method}, $virtualMethods{$sig}{class}, \%addInclude );
+	    $methodCode .= $meth;
+	}
+    }
+
+    $methodCode .= generateEnumCast( $classNode );
+
+    # Destructor
+    # &quot;virtual&quot; is useless, if the base class has a virtual destructor then the x_* class too.
+    #if($classNode-&gt;{HasVirtualDestructor} and $classNode-&gt;{HasDestructor}) {
+    #	$methodCode .= &quot;    virtual ~$xClassName() {}\n&quot;;
+    #}
+    # We generate a dtor though, because we might want to add stuff into it
+    if ( !$isGlobalSpace &amp;&amp; $classNode-&gt;{NodeType} ne 'namespace' ) {
+        $methodCode .= &quot;    ~$xClassName() { ${libname}_Smoke-&gt;binding-&gt;deleted($classNode-&gt;{ClassIndex}, (void*)this); }\n&quot;;
+    }
+
+    if ($classNode-&gt;{CanBeInstanciated} and $classNode-&gt;{HasPublicDestructor}) {
+	die &quot;$className destructor: methodNumber=$methodNumber != case entry=&quot;.$classNode-&gt;{case}{&quot;~$className()&quot;}.&quot;\n&quot;
+	     if $methodNumber != $classNode-&gt;{case}{&quot;~$className()&quot;};
+	$switchCode .= &quot;\tcase $methodNumber: delete ($className*)xself;\tbreak;\n&quot;;
+	$methodNumber++;
+    }
+
+    $switchCode .= &quot;    }\n&quot;;
+    return ( $methodCode, $switchCode, \%addInclude );
+}
+
+# Return 0 if the class has no virtual dtor, 1 if it has, 2 if it's private
+sub hasVirtualDestructor($)
+{
+    my ( $classNode ) = @_;
+    my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+    return if ( $skippedClasses{$className} );
+
+    my $parentHasIt;
+    # Look at ancestors, and (recursively) call hasVirtualDestructor for each
+    # It's enough to have one parent with a prot/public virtual dtor
+    Iter::Ancestors( $classNode, $rootnode, undef, undef, sub {
+                     my $vd = hasVirtualDestructor( $_[0] );
+                     $parentHasIt = $vd unless $parentHasIt &gt; $vd;
+                    } );
+    return $parentHasIt if $parentHasIt; # 1 or 2
+
+    # Now look in $classNode - including private methods
+    my $doPrivate = $main::doPrivate;
+    $main::doPrivate = 1;
+    my $result;
+    Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+			return unless( $m-&gt;{NodeType} eq &quot;method&quot; &amp;&amp; $m-&gt;{ReturnType} eq '~' );
+
+			if ( $m-&gt;{Flags} =~ /[vp]/ ) {
+			    if ( $m-&gt;{Access} =~ /private/ ) {
+				$result=2; # private virtual
+			    } else {
+				$result=1; # [protected or public] virtual
+			    }
+			}
+		},
+		undef
+	);
+    $main::doPrivate = $doPrivate;
+    $result=0 if (!defined $result);
+    return $result;
+}
+
+=head2 allVirtualMethods
+
+	Parameters: class node, dict
+
+	Adds to the dict, for all method nodes that are virtual, in this class and in parent classes :
+        {method} the method node, {class} the class node (the one where the virtual is implemented)
+
+=cut
+
+sub allVirtualMethods($$)
+{
+    my ( $classNode, $virtualMethods ) = @_;
+    my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+    return if ( $skippedClasses{$className} );
+
+    # Look at ancestors, and (recursively) call allVirtualMethods for each
+    # This is done first, so that virtual methods that are reimplemented as 'private'
+    # can be removed from the list afterwards (below)
+    Iter::Ancestors( $classNode, $rootnode, undef, undef, sub {
+			 allVirtualMethods( @_[0], $virtualMethods );
+		     }, undef
+		   );
+
+    # Now look for virtual methods in $classNode - including private ones
+    my $doPrivate = $main::doPrivate;
+    $main::doPrivate = 1;
+    Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+			# Only interested in methods, and skip destructors
+			return unless( $m-&gt;{NodeType} eq &quot;method&quot; &amp;&amp; $m-&gt;{ReturnType} ne '~' );
+
+			my $signature = methodSignature( $m, $#{$m-&gt;{ParamList}} );
+			print STDERR $signature . &quot; ($m-&gt;{Access})\n&quot; if ($debug);
+
+			# A method is virtual if marked as such (v=virtual p=pure virtual)
+			# or if a parent method with same signature was virtual
+			if ( $m-&gt;{Flags} =~ /[vp]/ or defined $virtualMethods-&gt;{$signature} ) {
+			    if ( $m-&gt;{Access} =~ /private/ ) {
+				if ( defined $virtualMethods-&gt;{$signature} ) { # remove previously defined
+				    delete $virtualMethods-&gt;{$signature};
+				}
+				# else, nothing, just ignore private virtual method
+			    } else {
+				$virtualMethods-&gt;{$signature}{method} = $m;
+				$virtualMethods-&gt;{$signature}{class} = $classNode;
+			    }
+			}
+		},
+		undef
+	);
+    $main::doPrivate = $doPrivate;
+}
+
+# Known typedef? If so, apply it.
+sub applyTypeDef($)
+{
+    my $type = shift;
+    # Parse 'const' in front of it, and '*' or '&amp;' after it
+    my $prefix = $type =~ s/^const\s+// ? 'const ' : '';
+    my $suffix = $type =~ s/\s*([\&amp;\*]+)$// ? $1 : '';
+
+    if (exists $typedeflist{$type}) {
+	return $prefix.$typedeflist{$type}.$suffix;
+    }
+    return $prefix.$type.$suffix;
+}
+
+# Register type ($1) into %allTypes if not already there
+sub registerType($$) {
+    my $type = shift;
+    #print &quot;registerType: $type\n&quot; if ($debug);
+
+    $type =~ s/\s+const$//; # for 'char* const'
+    $type =~ s/\s+const\s*\*$/\*/; # for 'char* const*'
+	
+	$type =~ s/(&lt;[^&gt;]*)\s+([^&gt;]*&gt;)/$1$2/; # Remove embedded space from template types, such as
+										  # 'QMap&lt;QCString, DCOPRef&gt;'
+
+    return if ( $type eq 'void' or $type eq '' or $type eq '~' );
+    die if ( $type eq '...' );     # ouch
+
+    # Let's register the real type, not its known equivalent
+    #$type = applyTypeDef($type);
+
+    # Enum _value_ -&gt; get corresponding type
+    if (exists $enumValueToType{$type}) {
+	$type = $enumValueToType{$type};
+    }
+
+    # Already in allTypes
+    if(exists $allTypes{$type}) {
+        return;
+    }
+
+    die if $type eq 'QTextEdit::UndoRedoInfo::Type';
+    die if $type eq '';
+
+    my $realType = $type;
+
+    # Look for references (&amp;) and pointers (* or **)  - this will not handle *&amp; correctly.
+    # We do this parsing here because both the type list and iterproto need it
+    if($realType =~ s/&amp;$//) {
+	$allTypes{$type}{typeFlags} = 'Smoke::tf_ref';
+    }
+    elsif($realType ne 'void*' &amp;&amp; $realType =~ s/\*$//) {
+	$allTypes{$type}{typeFlags} = 'Smoke::tf_ptr';
+    }
+    else {
+	$allTypes{$type}{typeFlags} = 'Smoke::tf_stack';
+    }
+
+    if ( $realType =~ s/^const\s+// ) { # Remove 'const'
+	$allTypes{$type}{typeFlags} .= ' | Smoke::tf_const';
+    }
+
+    # Apply typedefs, and store the resulting type.
+    # For instance, if $type was Q_UINT16&amp;, realType will be ushort
+    $allTypes{$type}{realType} = applyTypeDef( $realType );
+
+    # In the first phase we only create entries into allTypes.
+    # The values (indexes) are calculated afterwards, once the list is full.
+    $allTypes{$type}{index} = -1;
+    #print STDERR &quot;Register $type. Realtype: $realType\n&quot; if($debug);
+}
+
+# Get type from %allTypes
+# This returns a hash with {index}, {isEnum}, {typeFlags}, {realType}
+# (and {typeId} after the types array is written by writeSmokeDataFile)
+sub findTypeEntry($) {
+    my $type = shift;
+    my $typeIndex = -1;
+    $type =~ s/\s+const$//; # for 'char* const'
+    $type =~ s/\s+const\s*\*$/\*/; # for 'char* const*'
+
+	$type =~ s/(&lt;[^&gt;]*)\s+([^&gt;]*&gt;)/$1$2/; # Remove embedded space from template types, such as
+										  # 'QMap&lt;QCString, DCOPRef&gt;'
+
+    return undef if ( $type =~ '~' or $type eq 'void' or $type eq '' );
+
+    # Enum _value_ -&gt; get corresponding type
+    if (exists $enumValueToType{$type}) {
+	$type = $enumValueToType{$type};
+    }
+
+    die &quot;type not known: $type&quot; unless defined $allTypes{$type};
+    return $allTypes{ $type };
+}
+
+# List of all super-classes for a given class
+sub superclass_list($)
+{
+    my $classNode = shift;
+    my @super;
+    Iter::Ancestors( $classNode, $rootnode, undef, undef, sub {
+			push @super, @_[0];
+			push @super, superclass_list( @_[0] );
+		     }, undef );
+    return @super;
+}
+
+# Store the {case} dict in the class Node (method signature -&gt; index in the &quot;case&quot; switch)
+# This also determines which methods should NOT be in the switch, and sets {SkipFromSwitch} for them
+sub prepareCaseDict($) {
+
+     my $classNode = shift;
+     my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+     $classNode-&gt;AddProp(&quot;case&quot;, {});
+     my $methodNumber = 0;
+
+     # First look at all enums for this class
+     Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	next unless $m-&gt;{NodeType} eq 'enum';
+	foreach my $val ( @{$m-&gt;{ParamList}} ) {
+	    my $fullEnumName = &quot;$className\::&quot;.$val-&gt;{ArgName};
+	    print STDERR &quot;Enum: $fullEnumName -&gt; case $methodNumber\n&quot; if ($debug);
+	    $classNode-&gt;{case}{$fullEnumName} = $methodNumber;
+	    $enumValueToType{$fullEnumName} = &quot;$className\::$m-&gt;{astNodeName}&quot;;
+	    $methodNumber++;
+	}
+		      }, undef );
+
+     # Check for vars
+     Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	    next unless $m-&gt;{NodeType} eq 'var';
+	    my $name = &quot;$className\::&quot;.$m-&gt;{astNodeName};			
+	    print STDERR &quot;Var: $name -&gt; case $methodNumber\n&quot; if ($debug);
+	    $classNode-&gt;{case}{$name} = $methodNumber;
+	    $methodNumber++;
+
+		      }, undef );
+
+	 my %const_methods = ();
+     # Now look at all const methods for this class, in order to use
+	 # them in preference to any otherwise identical non-const method
+     Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+	
+		next unless $m-&gt;{NodeType} eq 'method';
+		my @args = @{ $m-&gt;{ParamList} };
+	    my $sig = methodSignature( $m, $#args );
+		if ( $sig =~ /(.*) const$/ ) {
+			$const_methods{$1} = 1;
+		}
+		
+		      }, undef );
+
+     # Now look at all methods for this class
+     Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	next unless $m-&gt;{NodeType} eq 'method';
+	my $name = $m-&gt;{astNodeName};
+        my $isConstructor = ($name eq $classNode-&gt;{astNodeName} );
+	if ($isConstructor and ($m-&gt;{ReturnType} eq '~')) # destructor
+	{
+	    # Remember whether we'll generate a switch entry for the destructor
+	    $m-&gt;{SkipFromSwitch} = 1 unless ($classNode-&gt;{CanBeInstanciated} and $classNode-&gt;{HasPublicDestructor});
+	    next;
+	}
+
+        # Don't generate bindings for protected methods (incl. signals) if
+        # we're not deriving from the C++ class. Only take public and public_slots
+        my $ok = ( $classNode-&gt;{BindingDerives} or $m-&gt;{Access} =~ /public/ ) ? 1 : 0;
+
+        # Don't generate bindings for pure virtuals - we can't call them ;)
+        $ok = 0 if ( $ok &amp;&amp; $m-&gt;{Flags} =~ &quot;p&quot; );
+
+        # Bugfix for Qt-3.0.4: those methods are NOT implemented (report sent).
+        $ok = 0 if ( $ok &amp;&amp; $className eq 'QLineEdit' &amp;&amp; ( $name eq 'setPasswordChar' || $name eq 'passwordChar' ) );
+        $ok = 0 if ( $ok &amp;&amp; $className eq 'QWidgetItem' &amp;&amp; $name eq 'widgetSizeHint' );
+
+        if ( !$ok )
+        {
+	    #print STDERR &quot;Skipping $className\::$name\n&quot; if ($debug);
+	    $m-&gt;{SkipFromSwitch} = 1;
+	    next;
+	}
+
+	my @args = @{ $m-&gt;{ParamList} };
+	my $sig = methodSignature( $m, $#args );
+	if ( $const_methods{$sig} &amp;&amp; $m-&gt;{Flags} !~ &quot;v&quot; ) {
+		# If there is a method which just differs from another by 'constness',
+		# then ignore the non-const version
+	    $m-&gt;{SkipFromSwitch} = 1;
+	    next;
+	}
+	my $last = $m-&gt;{FirstDefaultParam};
+	$last = scalar @args unless defined $last;
+	my $iterationCount = scalar(@args) - $last;
+	while($iterationCount &gt;= 0) {
+	    $sig = methodSignature( $m, $#args );
+	    $classNode-&gt;{case}{$sig} = $methodNumber;
+	    #print STDERR &quot;prepareCaseDict: registered case number $methodNumber for $sig in $className()\n&quot; if ($debug);
+	    pop @args;
+	    $iterationCount--;
+	    $methodNumber++;
+	}
+		    }, undef );
+
+    # Add the destructor, at the end
+    if ($classNode-&gt;{CanBeInstanciated} and $classNode-&gt;{HasPublicDestructor}) {
+        $classNode-&gt;{case}{&quot;~$className()&quot;} = $methodNumber;
+	# workaround for ~Sub::Class() being seen as Sub::~Class()
+	$classNode-&gt;{case}{&quot;~$classNode-&gt;{astNodeName}()&quot;} = $methodNumber;
+	#print STDERR &quot;prepareCaseDict: registered case number $methodNumber for ~$className()\n&quot; if ($debug);
+    }
+}
+
+=head2
+	Write out the smokedata.cpp file containing all the arrays.
+=cut
+
+sub writeSmokeDataFile($) {
+    my $rootnode = shift;
+
+    # Make list of classes
+    my %allIncludes; # list of all header files for all classes
+    my @classlist;
+    push @classlist, &quot;&quot;; # Prepend empty item for &quot;no class&quot;
+    my %enumclasslist;
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = $_[0];
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	
+	push @classlist, $className;
+	$enumclasslist{$className}++ if keys %{$classNode-&gt;{enumerations}};
+	$classNode-&gt;{ClassIndex} = $#classlist;
+	addIncludeForClass( $classNode, \%allIncludes, undef );
+    } );
+
+    my %classidx = do { my $i = 0; map { $_ =&gt; $i++ } @classlist };
+
+    my $file = &quot;$outputdir/smokedata.cpp&quot;;
+    open OUT, &quot;&gt;$file&quot; or die &quot;Couldn't create $file\n&quot;;
+
+    foreach my $incl (sort{ 
+                           return 1 if $a=~/qmotif/;  # move qmotif* at bottom (they include dirty X11 headers)
+                           return -1 if $b=~/qmotif/;
+			   return -1 if substr($a,0,1) eq 'q' and substr($b,0,1) ne 'q'; # move Qt headers on top
+			   return 1 if substr($a,0,1) ne 'q' and substr($b,0,1) eq 'q';			   
+                           $a cmp $b
+                          } keys %allIncludes) {
+	die if $incl eq '';
+        if( $incl eq &quot;kxmlguifactory.h&quot; ) {
+            print OUT &quot;#include &lt;kxmlguiclient.h&gt;\n&quot;;
+        }
+	print OUT &quot;#include &lt;$incl&gt;\n&quot;;
+    }	
+
+    print OUT &quot;\n&quot;;
+    print OUT &quot;#include &lt;smoke.h&gt;\n\n&quot;;
+    print OUT &quot;#include &lt;qt_smoke.h&gt;\n\n&quot;;
+
+    # gcc optimizes this method like crazy. switch() is godly
+    print OUT &quot;static void *${libname}_cast(void *xptr, Smoke::Index from, Smoke::Index to) {\n&quot;;
+    print OUT &quot;    switch(from) {\n&quot;;
+
+    print STDERR &quot;Writing ${libname}_cast function\n&quot; if ($debug);
+
+    # Prepare descendants information for each class
+    my %descendants; # classname -&gt; list of descendant nodes
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	# Get _all_ superclasses (up any number of levels)
+	# and store that $classNode is a descendant of $s
+	my @super = superclass_list($classNode);
+	for my $s (@super) {
+	    my $superClassName = join( &quot;::&quot;, kdocAstUtil::heritage($s) );
+	    Ast::AddPropList( \%descendants, $superClassName, $classNode );
+	}
+    } );
+
+    # Iterate over all classes, to write the xtypecast function
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	# @super will contain superclasses, the class itself, and all descendants
+	my @super = superclass_list($classNode);
+	push @super, $classNode;
+        if ( defined $descendants{$className} ) {
+	    push @super, @{$descendants{$className}};
+	}
+	my $cur = $classidx{$className};
+	
+	return if $classNode-&gt;{NodeType} eq 'namespace';
+
+	print OUT &quot;      case $cur:\t//$className\n&quot;;
+	print OUT &quot;\tswitch(to) {\n&quot;;
+	$cur = -1;
+	my %casevalues;
+	for my $s (@super) {
+		my $superClassName = join( &quot;::&quot;, kdocAstUtil::heritage($s) );
+		next if !defined $classidx{$superClassName}; # inherits from unknown class, see below
+		next if $classidx{$superClassName} == $cur;    # shouldn't happen in Qt
+		if (!defined $s) {
+			die &quot;problem with $className missing parent&quot;
+		}
+		next if $s-&gt;kdocAstUtil::inheritsAsVirtual($classNode); # can't cast from a virtual base class
+		$cur = $classidx{$superClassName}; # KDE has MI with diamond shaped cycles (cf. KXMLGUIClient)
+		next if $casevalues{$cur};         # ..so skip any duplicate parents
+		print OUT &quot;\t  case $cur: return (void*)($superClassName*)($className*)xptr;\n&quot;;
+		$casevalues{$cur} = 1;
+	}
+	print OUT &quot;\t  default: return xptr;\n&quot;;
+	print OUT &quot;\t}\n&quot;;
+    } );
+    print OUT &quot;      default: return xptr;\n&quot;;
+    print OUT &quot;    }\n&quot;;
+    print OUT &quot;}\n\n&quot;;
+
+
+    # Write inheritance array
+    # Imagine you have &quot;Class : public super1, super2&quot;
+    # The inheritlist array will get 3 new items: super1, super2, 0
+    my %inheritfinder;  # key = (super1, super2) -&gt; data = (index in @inheritlist). This one allows reuse.
+    my %classinherit;   # we store that index in %classinherit{className}
+    # We don't actually need to store inheritlist in memory, we write it
+    # directly to the file. We only need to remember its current size.
+    my $inheritlistsize = 1;
+
+    print OUT &quot;// Group of class IDs (0 separated) used as super class lists.\n&quot;;
+    print OUT &quot;// Classes with super classes have an index into this array.\n&quot;;
+    print OUT &quot;static short ${libname}_inheritanceList[] = {\n&quot;;
+    print OUT &quot;\t0,\t// 0: (no super class)\n&quot;;
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	
+	print STDERR &quot;inheritanceList: looking at $className\n&quot; if ($debug);
+
+	# Make list of direct ancestors
+	my @super;
+	Iter::Ancestors( $classNode, $rootnode, undef, undef, sub {
+			     my $superClassName = join( &quot;::&quot;, kdocAstUtil::heritage($_[0]) );
+			     push @super, $superClassName;
+		    }, undef );
+	# Turn that into a list of class indexes
+	my $key = '';
+	foreach my $superClass( @super ) {
+	    if (defined $classidx{$superClass}) {
+		$key .= ', ' if ( length $key &gt; 0 );
+		$key .= $classidx{$superClass};
+	    }
+	}
+	if ( $key ne '' ) {
+	    if ( !defined $inheritfinder{$key} ) {
+		print OUT &quot;\t&quot;;
+		my $index = $inheritlistsize; # Index of first entry (for this group) in inheritlist
+		foreach my $superClass( @super ) {
+		    if (defined $classidx{$superClass}) {
+			print OUT &quot;$classidx{$superClass}, &quot;;
+			$inheritlistsize++;
+		    }
+		}
+		$inheritlistsize++;
+		my $comment = join( &quot;, &quot;, @super );
+		print OUT &quot;0,\t// $index: $comment\n&quot;;
+		$inheritfinder{$key} = $index;
+	    }
+	    $classinherit{$className} = $inheritfinder{$key};
+	} else { # No superclass
+	    $classinherit{$className} = 0;
+	}
+    } );
+    print OUT &quot;};\n\n&quot;;
+
+
+    print OUT &quot;// These are the xenum functions for manipulating enum pointers\n&quot;;
+    for my $className (keys %enumclasslist) {
+	my $c = $className;
+	$c =~ s/::/__/g;
+	print OUT &quot;void xenum_$c\(Smoke::EnumOperation, Smoke::Index, void*&amp;, long&amp;);\n&quot;;
+    }
+    print OUT &quot;\n&quot;;
+    print OUT &quot;// Those are the xcall functions defined in each x_*.cpp file, for dispatching method calls\n&quot;;
+    my $firstClass = 1;
+    for my $className (@classlist) {
+	if ($firstClass) {
+	    $firstClass = 0;
+	    next;
+	}
+	my $c = $className;   # make a copy
+	$c =~ s/::/__/g;
+	print OUT &quot;void xcall_$c\(Smoke::Index, void*, Smoke::Stack);\n&quot;;
+    }
+    print OUT &quot;\n&quot;;
+
+    # Write class list afterwards because it needs offsets to the inheritance array.
+    print OUT &quot;// List of all classes\n&quot;;
+    print OUT &quot;// Name, index into inheritanceList, method dispatcher, enum dispatcher, class flags\n&quot;;
+    print OUT &quot;static Smoke::Class ${libname}_classes[] = {\n&quot;;
+    my $firstClass = 1;
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+
+	if ($firstClass) {
+	    $firstClass = 0;
+	    print OUT &quot;\t{ 0L, 0, 0, 0, 0 }, \t// 0 (no class)\n&quot;;
+	}
+	my $c = $className;
+	$c =~ s/::/__/g;
+	my $xcallFunc = &quot;xcall_$c&quot;;
+	my $xenumFunc = &quot;0&quot;;
+	$xenumFunc = &quot;xenum_$c&quot; if exists $enumclasslist{$className};
+	die &quot;problem with $className&quot; unless defined $classinherit{$className};
+
+	my $xClassFlags = 0;
+	$xClassFlags .= &quot;|Smoke::cf_constructor&quot; if $classNode-&gt;{CanBeInstanciated}; # correct?
+	$xClassFlags .= &quot;|Smoke::cf_deepcopy&quot; if $classNode-&gt;{CanBeCopied}; # HasCopyConstructor would be wrong (when it's private)
+	$xClassFlags .= &quot;|Smoke::cf_virtual&quot; if hasVirtualDestructor($classNode) == 1;
+	# $xClassFlags .= &quot;|Smoke::cf_undefined&quot; if ...;
+	$xClassFlags =~ s/0\|//; # beautify
+	print OUT &quot;\t{ \&quot;_$className\&quot;, $classinherit{$className}, $xcallFunc, $xenumFunc, $xClassFlags }, \t//$classidx{$className}\n&quot;;
+    } );
+    print OUT &quot;};\n\n&quot;;
+
+
+    print OUT &quot;// List of all types needed by the methods (arguments and return values)\n&quot;;
+    print OUT &quot;// Name, class ID if arg is a class, and TypeId\n&quot;;
+    print OUT &quot;static Smoke::Type ${libname}_types[] = {\n&quot;;
+    my $typeCount = 0;
+    $allTypes{''}{index} = 0; # We need an &quot;item 0&quot;
+    for my $type (sort keys %allTypes) {
+	$allTypes{$type}{index} = $typeCount;      # Register proper index in allTypes
+	if ( $typeCount == 0 ) {
+	    print OUT &quot;\t{ 0, 0, 0 },\t//0 (no type)\n&quot;;
+	    $typeCount++;
+	    next;
+	}
+	my $isEnum = $allTypes{$type}{isEnum};
+	my $typeId;
+	my $typeFlags = $allTypes{$type}{typeFlags};
+	my $realType = $allTypes{$type}{realType};
+	die &quot;$type&quot; if !defined $typeFlags;
+#	die &quot;$realType&quot; if $realType =~ /\(/;
+	if ($realType =~ /\(/) {
+		print &quot;FATAL ERROR $type $realType\n&quot;;
+	}
+	# First write the name
+	print OUT &quot;\t{ \&quot;$type\&quot;, &quot;;
+	# Then write the classId (and find out the typeid at the same time)
+	if(exists $classidx{$realType}) { # this one first, we want t_class for QBlah*
+	    $typeId = 't_class';
+	    print OUT &quot;$classidx{$realType}, &quot;;
+	}
+	elsif($type =~ /&amp;$/ || $type =~ /\*$/) {
+	    $typeId = 't_voidp';
+	    print OUT &quot;0, &quot;; # no classId
+	}
+	elsif($isEnum || $allTypes{$realType}{isEnum}) {
+	    $typeId = 't_enum';
+	    if($realType =~ /(.*)::/) {
+		my $c = $1;
+		if($classidx{$c}) {
+		    print OUT &quot;$classidx{$c}, &quot;;
+		} else {
+		    print OUT &quot;0 /* unknown class $c */, &quot;;
+		}
+	    } else {
+		print OUT &quot;0 /* unknown $realType */, &quot;; # no classId
+	    }
+	}
+	else {
+	    $typeId = $typeunion{$realType};
+	    if (defined $typeId) {
+		$typeId =~ s/s_/t_/; # from s_short to t_short for instance
+	    }
+	    else {
+		# Not a known class - ouch, this happens quite a lot
+		# (private classes, typedefs, template-based types, etc)
+		if ( $skippedClasses{$realType} ) {
+#		    print STDERR &quot;$realType has been skipped, using t_voidp for it\n&quot;;
+		} else {
+		    unless( $realType =~ /&lt;/ ) { # Don't warn for template stuff...
+			print STDERR &quot;$realType isn't a known type (type=$type)\n&quot;;
+		    }
+		}
+		$typeId = 't_voidp'; # Unknown -&gt; map to a void *
+	    }
+	    print OUT &quot;0, &quot;; # no classId
+	}
+	# Then write the flags
+	die &quot;$type&quot; if !defined $typeId;
+	print OUT &quot;Smoke::$typeId | $typeFlags },&quot;;
+	print OUT &quot;\t//$typeCount\n&quot;;
+	$typeCount++;
+	# Remember it for coerce_type
+	$allTypes{$type}{typeId} = $typeId;
+    }
+    print OUT &quot;};\n\n&quot;;
+
+
+    my %arglist; # registers the needs for argumentList (groups of type ids)
+    my %methods;
+    # Look for all methods and all enums, in all classes
+    # And fill in methods and arglist. This loop writes nothing to OUT.
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	print STDERR &quot;writeSmokeDataFile: arglist: looking at $className\n&quot; if ($debug);
+
+	Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	my $methName = $m-&gt;{astNodeName};
+	# For destructors, get a proper signature that includes the '~'
+	if ( $m-&gt;{ReturnType} eq '~' )
+	{
+	    $methName = '~' . $methName ;
+	    # Let's even store that change, otherwise we have to do it many times
+	    $m-&gt;{astNodeName} = $methName;
+	}
+	
+	if( $m-&gt;{NodeType} eq &quot;enum&quot; ) {
+
+	    foreach my $enum ( @{$m-&gt;{ParamList}} ) {
+		my $enumName = $enum-&gt;{ArgName};
+	        $methods{$enumName}++;
+	    }
+
+	} elsif ( $m-&gt;{NodeType} eq 'var' ) {
+		$methods{$m-&gt;{astNodeName}}++;
+	} elsif( $m-&gt;{NodeType} eq &quot;method&quot; ) {
+
+	    $methods{$methName}++;
+	    my @protos;
+	    makeprotos(\%classidx, $m, \@protos);
+
+	    #print &quot;made @protos from $className $methName $m-&gt;{Signature})\n&quot; if ($debug);
+	    for my $p (@protos) {
+		$methods{$p}++;
+		my $argcnt = 0;
+		$argcnt = length($1) if $p =~ /([\$\#\?]+)/;
+		my $sig = methodSignature($m, $argcnt-1);
+		# Store in a class hash named &quot;proto&quot;, a proto+signature =&gt; method association
+		$classNode-&gt;{proto}{$p}{$sig} = $m;
+		#$classNode-&gt;{signature}{$sig} = $p;
+		# There's probably a way to do this better, but this is the fastest way
+		# to get the old code going: store classname into method
+		$m-&gt;{class} = $className;
+	    }
+
+	    my $firstDefaultParam = $m-&gt;{FirstDefaultParam};
+	    $firstDefaultParam = scalar(@{ $m-&gt;{ParamList} }) unless defined $firstDefaultParam;
+	    my $argNames = '';
+	    my $args = '';
+	    for(my $i = 0; $i &lt; @{ $m-&gt;{ParamList} }; $i++) {
+		$args .= ', ' if $i;
+		$argNames .= ', ' if $i;
+		my $argType = $m-&gt;{ParamList}[$i]{ArgType};
+		my $typeEntry = findTypeEntry( $argType );
+		$args .= defined $typeEntry ? $typeEntry-&gt;{index} : 0;
+		$argNames .= $argType;
+
+		if($i &gt;= ($firstDefaultParam - 1)) {
+		    #print &quot;arglist entry: $args\n&quot;;
+		    $arglist{$args} = $argNames;
+		}
+		
+	    }
+	    # create an entry for e.g. &quot;arg0,arg1,arg2&quot; where argN is index in allTypes of type for argN
+	    # The value, $argNames, is temporarily stored, to be written out as comment
+	    # It gets replaced with the index in the next loop.
+	    #print &quot;arglist entry : $args\n&quot;;
+	    $arglist{$args} = $argNames;
+	}
+		    }, # end of sub
+	undef
+       );
+    });
+
+
+    $arglist{''} = 0;
+    # Print arguments array
+    print OUT &quot;static Smoke::Index ${libname}_argumentList[] = {\n&quot;;
+    my $argListCount = 0;
+    for my $args (sort keys %arglist) {
+	my $numTypes = scalar(split ',', $args);
+	if ($args eq '') {
+	    print OUT &quot;\t0,\t//0  (void)\n&quot;;
+	} else {
+	    # This is a nice trick : args can be written in one go ;)
+	    print OUT &quot;\t$args, 0,\t//$argListCount  $arglist{$args}  \n&quot;;
+	}
+	$arglist{$args} = $argListCount;      # Register proper index in argList
+	$argListCount += $numTypes + 1;       # Move forward by as much as we wrote out
+    }
+    print OUT &quot;};\n\n&quot;;
+
+    $methods{''} = 0;
+    my @methodlist = sort keys %methods;
+    my %methodidx = do { my $i = 0; map { $_ =&gt; $i++ } @methodlist };
+
+    print OUT &quot;// Raw list of all methods, using munged names\n&quot;;
+    print OUT &quot;static const char *${libname}_methodNames[] = {\n&quot;;
+    my $methodNameCount = $#methodlist;
+    for my $m (@methodlist) {
+	print OUT qq(    &quot;$m&quot;,\t//$methodidx{$m}\n);
+    }
+    print OUT &quot;};\n\n&quot;;
+
+    print OUT &quot;// (classId, name (index in methodNames), argumentList index, number of args, method flags, return type (index in types), xcall() index)\n&quot;;
+    print OUT &quot;static Smoke::Method ${libname}_methods[] = {\n&quot;;
+    my @methods;
+    %allMethods = ();
+    my $methodCount = 0;
+    # Look at all classes and all enums again
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	
+	my $classIndex = $classidx{$className};
+	print STDERR &quot;writeSmokeDataFile: methods: looking at $className\n&quot; if ($debug);
+
+	Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	if( $m-&gt;{NodeType} eq &quot;enum&quot; ) {
+
+	    foreach my $enum ( @{$m-&gt;{ParamList}} ) {
+		my $enumName = $enum-&gt;{ArgName};
+		my $fullEnumName = &quot;$className\::$enumName&quot;;
+		my $sig = &quot;$className\::$enumName\()&quot;;
+		my $xmethIndex = $methodidx{$enumName};
+		die &quot;'Method index' for enum $sig not found&quot; unless defined $xmethIndex;
+		my $typeId = findTypeEntry( $fullEnumName )-&gt;{index};
+		die &quot;enum has no {case} value in $className: $fullEnumName&quot; unless defined $classNode-&gt;{case}{$fullEnumName};
+		print OUT &quot;\t{$classIndex, $xmethIndex, 0, 0, Smoke::mf_static|Smoke::mf_enum, $typeId, $classNode-&gt;{case}{$fullEnumName}},\t//$methodCount $fullEnumName (enum)\n&quot;;
+		$allMethods{$sig} = $methodCount;
+		print STDERR &quot;Added entry for &quot; . $sig . &quot; into \$allMethods\n&quot; if ($debug);
+		$methods[$methodCount] = {
+				c =&gt; $classIndex,
+				methIndex =&gt; $xmethIndex,
+				argcnt =&gt; '0',
+				args =&gt; 0,
+				retTypeIndex =&gt; 0,
+				idx =&gt; $classNode-&gt;{case}{$fullEnumName}
+			       };
+		$methodCount++;
+	    }
+
+	} elsif( $m-&gt;{NodeType} eq 'var' ) {
+
+	    my $name = $m-&gt;{astNodeName};
+	    my $fullName = &quot;$className\::$name&quot;;
+	    my $sig = &quot;$fullName\()&quot;;
+	    my $xmethIndex = $methodidx{$name};
+	    die &quot;'Method index' for var $sig not found&quot; unless defined $xmethIndex;
+	    my $varType = $m-&gt;{Type};
+	    $varType =~ s/static\s//;
+	    $varType =~ s/const\s+(.*)\s*&amp;/$1/;
+	    $varType =~ s/\s*$//;
+	    my $typeId = findTypeEntry( $varType )-&gt;{index};
+	    die &quot;var has no {case} value in $className: $fullName&quot; unless defined $classNode-&gt;{case}{$fullName};
+		if ( $m-&gt;{Flags} =~ &quot;s&quot; ) {
+	    	print OUT &quot;\t{$classIndex, $xmethIndex, 0, 0, Smoke::mf_static, $typeId, $classNode-&gt;{case}{$fullName}},\t//$methodCount $fullName (static var)\n&quot;;
+		} else {
+	    	print OUT &quot;\t{$classIndex, $xmethIndex, 0, 0, 0, $typeId, $classNode-&gt;{case}{$fullName}},\t//$methodCount $fullName (var)\n&quot;;
+		}
+        $allMethods{$sig} = $methodCount;
+	    print STDERR &quot;Added entry for &quot; . $sig . &quot; into \$allMethods\n&quot; if ($debug);
+	    $methods[$methodCount] = {
+				c =&gt; $classIndex,
+				methIndex =&gt; $xmethIndex,
+				argcnt =&gt; '0',
+				args =&gt; 0,
+				retTypeIndex =&gt; 0,
+				idx =&gt; $classNode-&gt;{case}{$fullName}
+			       };
+	    $methodCount++;
+
+
+	} elsif( $m-&gt;{NodeType} eq &quot;method&quot; ) {
+
+	    # We generate a method entry only if the method is in the switch() code
+	    # BUT: for pure virtuals, they need to have a method entry, even though they
+	    # do NOT have a switch code.
+	    return if ( $m-&gt;{SkipFromSwitch} &amp;&amp; $m-&gt;{Flags} !~ &quot;p&quot; );
+
+	    # No switch code for destructors if we didn't derive from the class (e.g. it has private ctors only)
+    	    return if ( $m-&gt;{ReturnType} eq '~' &amp;&amp; ! ( $classNode-&gt;{BindingDerives} and $classNode-&gt;{HasPublicDestructor}) );
+
+            # Is this sorting really important?
+	    #for my $m (sort {$a-&gt;{name} cmp $b-&gt;{name}} @{ $self-&gt;{$c}{method} }) {
+
+	    my $methName = $m-&gt;{astNodeName};
+	    my $def = $m-&gt;{FirstDefaultParam};
+	    $def = scalar(@{ $m-&gt;{ParamList} }) unless defined $def;
+	    my $last = scalar(@{ $m-&gt;{ParamList} }) - 1;
+	    #print STDERR &quot;writeSmokeDataFile: methods: generating for method $methName, def=$def last=$last\n&quot; if ($debug);
+
+	    while($last &gt;= ($def-1)) {
+		last if $last &lt; -1;
+		my $args = [ @{ $m-&gt;{ParamList} }[0..$last] ];
+		my $sig = methodSignature($m, $last);
+		#my $methodSig = $classNode-&gt;{signature}{$sig}; # Munged signature
+		#print STDERR &quot;writeSmokeDataFile: methods: sig=$className\::$sig methodSig=$methodSig\n&quot; if ($debug);
+		#my $methodIndex = $methodidx{$methodSig};
+		#die &quot;$methodSig&quot; if !defined $methodIndex;
+
+		my $methodIndex = $methodidx{$methName};
+		die &quot;$methName&quot; if !defined $methodIndex;
+		my $case = $classNode-&gt;{case}{$sig};
+		my $typeEntry = findTypeEntry( $m-&gt;{ReturnType} );
+		my $retTypeIndex = defined $typeEntry ? $typeEntry-&gt;{index} : 0;
+
+		my $i = 0;
+		my $t = '';
+		for my $arg (@$args) {
+		    $t .= ', ' if $i++;
+		    my $typeEntry = findTypeEntry( $arg-&gt;{ArgType} );
+		    $t .= defined $typeEntry ? $typeEntry-&gt;{index} : 0;
+		}
+		my $arglist = $t eq '' ? 0 : $arglist{$t};
+		die &quot;arglist for $t not found&quot; unless defined $arglist;
+		if ( $m-&gt;{Flags} =~ &quot;p&quot; ) {
+		    # Pure virtuals don't have a {case} number, that's normal
+		    die &quot;pure virtual $className\::$methName has a case number for sig=$sig&quot; if defined $case;
+		    $case = -1; # This remains -1, not 0 !
+		} else {
+		    die &quot;$className\::$methName has no case number for sig=$sig&quot; unless defined $case;
+		}
+		my $argcnt = $last + 1;
+		my $methodFlags = '0';
+		# Make no distinction between a static method in an ordinary class, or a method in a namespace
+		$methodFlags .= &quot;|Smoke::mf_static&quot; if $m-&gt;{Flags} =~ &quot;s&quot; or $classNode-&gt;{NodeType} eq 'namespace';
+		$methodFlags .= &quot;|Smoke::mf_const&quot; if $m-&gt;{Flags} =~ &quot;c&quot;; # useful?? probably not
+		$methodFlags .= &quot;|Smoke::mf_copyctor&quot; if $m-&gt;{Flags} =~ &quot;x&quot;;
+		$methodFlags .= &quot;|Smoke::mf_internal&quot; if $m-&gt;{Flags} =~ &quot;i&quot;;
+		$methodFlags .= &quot;|Smoke::mf_ctor&quot; if $methName eq $className;
+		$methodFlags .= &quot;|Smoke::mf_dtor&quot; if $m-&gt;{ReturnType} eq '~';
+		$methodFlags .= &quot;|Smoke::mf_protected&quot; if $m-&gt;{Access} =~ /protected/;
+		$methodFlags =~ s/0\|//; # beautify
+		
+		print OUT &quot;\t{$classIndex, $methodIndex, $arglist, $argcnt, $methodFlags, $retTypeIndex, $case},\t//$methodCount $className\::$sig&quot;;
+		print OUT &quot; [pure virtual]&quot; if ( $m-&gt;{Flags} =~ &quot;p&quot; ); # explain why $case = -1 ;)
+		print OUT &quot;\n&quot;;
+		
+		$allMethods{$className . &quot;::&quot; . $sig} = $methodCount;
+		$methods[$methodCount] = {
+					  c =&gt; $classIndex,
+					  methIndex =&gt; $methodIndex,
+					  argcnt =&gt; $argcnt,
+					  args =&gt; $arglist,
+					  retTypeIndex =&gt; $retTypeIndex,
+					  idx =&gt; $case
+					 };
+		$methodCount++;
+		$last--;
+	    } # while
+	} # if method
+      } ); # Method Iter
+    } ); # Class Iter
+    print OUT &quot;};\n\n&quot;;
+
+    my @protos;
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	
+	my $classIndex = $classidx{$className};
+	print STDERR &quot;writeSmokeDataFile: protos: looking at $className\n&quot; if ($debug);
+
+	Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	if( $m-&gt;{NodeType} eq &quot;enum&quot; ) {
+	    foreach my $enum ( @{$m-&gt;{ParamList}} ) {
+		my $enumName = $enum-&gt;{ArgName};
+		my $sig = &quot;$className\::$enumName\()&quot;;
+		my $xmeth = $allMethods{$sig};
+		die &quot;'Method' for enum $sig not found&quot; unless defined $xmeth;
+		my $xmethIndex = $methodidx{$enumName};
+		die &quot;'Method index' for enum $enumName not found&quot; unless defined $xmethIndex;
+		push @protos, {
+			       methIndex =&gt; $xmethIndex,
+			       c =&gt; $classIndex,
+			       over =&gt; {
+					$sig =&gt; {
+						 sig =&gt; $sig,
+						}
+				       },
+			       meth =&gt; $xmeth
+			      };
+	    }
+
+	} elsif( $m-&gt;{NodeType} eq 'var' ) {
+
+	    my $name = $m-&gt;{astNodeName};
+	    my $fullName = &quot;$className\::$name&quot;;
+	    my $sig = &quot;$fullName\()&quot;;
+	    my $xmeth = $allMethods{$sig};
+	    die &quot;'Method' for var $sig not found&quot; unless defined $xmeth;
+	    my $xmethIndex = $methodidx{$name};
+	    die &quot;'Method index' for var $name not found&quot; unless defined $xmethIndex;
+	    push @protos, {
+			       methIndex =&gt; $xmethIndex,
+			       c =&gt; $classIndex,
+			       over =&gt; {
+					$sig =&gt; {
+						 sig =&gt; $sig,
+						}
+				       },
+			       meth =&gt; $xmeth
+			  };
+
+	}
+		    });
+
+	for my $p (keys %{ $classNode-&gt;{proto} }) {
+	    # For each prototype
+	    my $scratch = { %{ $classNode-&gt;{proto}{$p} } }; # sig-&gt;method association
+	    # first, grab all the superclass voodoo
+	    for my $supNode (superclass_list($classNode)) {
+		my $i = $supNode-&gt;{proto}{$p};
+		next unless $i;
+		for my $k (keys %$i) {
+		    $scratch-&gt;{$k} = $i-&gt;{$k} unless exists $scratch-&gt;{$k};
+		}
+	    }
+
+	    # Ok, now we have a full list
+	    #if(scalar keys %$scratch &gt; 1) {
+		#print STDERR &quot;Overload: $p (@{[keys %$scratch]})\n&quot; if ($debug);
+	    #}
+	    my $xmethIndex = $methodidx{$p};
+	    my $classIndex = $classidx{$className};
+	    for my $sig (keys %$scratch) {
+		#my $xsig = $scratch-&gt;{$sig}{class} . &quot;::&quot; . $sig;
+		my $xsig = $className . &quot;::&quot; . $sig;
+		$scratch-&gt;{$sig}{sig} = $xsig;
+		delete $scratch-&gt;{$sig}
+		    if $scratch-&gt;{$sig}{Flags} =~ &quot;p&quot; # pure virtual
+			or not exists $allMethods{$xsig};
+	    }
+	    push @protos, {
+		methIndex =&gt; $xmethIndex,
+		c =&gt; $classIndex,
+		over =&gt; $scratch
+	    } if scalar keys %$scratch;
+	}
+    });
+
+    my @protolist = sort { $a-&gt;{c} &lt;=&gt; $b-&gt;{c} || $a-&gt;{methIndex} &lt;=&gt; $b-&gt;{methIndex} } @protos;
+#for my $abc (@protos) {
+#print &quot;$abc-&gt;{methIndex}.$abc-&gt;{c}\n&quot;;
+#}
+
+    print STDERR &quot;Writing methodmap table\n&quot; if ($debug);
+    my @resolve = ();
+    print OUT &quot;// Class ID, munged name ID (index into methodNames), method def (see methods) if &gt;0 or number of overloads if &lt;0\n&quot;;
+    my $methodMapCount = 1;
+    print OUT &quot;static Smoke::MethodMap ${libname}_methodMaps[] = {\n&quot;;
+    print OUT &quot;\t{ 0, 0, 0 },\t//0 (no method)\n&quot;;
+    for my $cur (@protolist) {
+	if(scalar keys %{ $cur-&gt;{over} } &gt; 1) {
+	    print OUT &quot;\t{$cur-&gt;{c}, $cur-&gt;{methIndex}, -@{[1+scalar @resolve]}},\t//$methodMapCount $classlist[$cur-&gt;{c}]\::$methodlist[$cur-&gt;{methIndex}]\n&quot;;
+	    $methodMapCount++;
+	    for my $k (keys %{ $cur-&gt;{over} }) {
+	        my $p = $cur-&gt;{over}{$k};
+	        my $xsig = $p-&gt;{class} ? &quot;$p-&gt;{class}\::$k&quot; : $p-&gt;{sig};
+	        push @resolve, { k =&gt; $k, p =&gt; $p, cur =&gt; $cur, id =&gt; $allMethods{$xsig} };
+	    }
+	    push @resolve, 0;
+	} else {
+	    for my $k (keys %{ $cur-&gt;{over} }) {
+	        my $p = $cur-&gt;{over}{$k};
+	        my $xsig = $p-&gt;{class} ? &quot;$p-&gt;{class}\::$k&quot; : $p-&gt;{sig};
+	        print OUT &quot;\t{$cur-&gt;{c}, $cur-&gt;{methIndex}, $allMethods{$xsig}},\t//$methodMapCount $classlist[$cur-&gt;{c}]\::$methodlist[$cur-&gt;{methIndex}]\n&quot;;
+	        $methodMapCount++;
+	    }
+	}
+    }
+    print OUT &quot;};\n\n&quot;;
+
+
+    print STDERR &quot;Writing ambiguousMethodList\n&quot; if ($debug);
+    print OUT &quot;static Smoke::Index ${libname}_ambiguousMethodList[] = {\n&quot;;
+    print OUT &quot;    0,\n&quot;;
+    for my $r (@resolve) {
+	unless($r) {
+	    print OUT &quot;    0,\n&quot;;
+	    next;
+	}
+	my $xsig = $r-&gt;{p}{class} ? &quot;$r-&gt;{p}{class}\::$r-&gt;{k}&quot; : $r-&gt;{p}{sig};
+	die &quot;ambiguousMethodList: no method found for $xsig\n&quot; if !defined $allMethods{$xsig};
+	print OUT &quot;    $allMethods{$xsig},  // $xsig\n&quot;;
+    }
+    print OUT &quot;};\n\n&quot;;
+
+#    print OUT &quot;extern \&quot;C\&quot; { // needed?\n&quot;;
+#    print OUT &quot;    void init_${libname}_Smoke();\n&quot;;
+#    print OUT &quot;}\n&quot;;
+    print OUT &quot;\n&quot;;
+    print OUT &quot;Smoke* qt_Smoke = 0L;\n&quot;;
+    print OUT &quot;\n&quot;;
+    print OUT &quot;// Create the Smoke instance encapsulating all the above.\n&quot;;
+    print OUT &quot;void init_${libname}_Smoke() {\n&quot;;
+    print OUT &quot;    qt_Smoke = new Smoke(\n&quot;;
+    print OUT &quot;        ${libname}_classes, &quot;.$#classlist.&quot;,\n&quot;;
+    print OUT &quot;        ${libname}_methods, $methodCount,\n&quot;;
+    print OUT &quot;        ${libname}_methodMaps, $methodMapCount,\n&quot;;
+    print OUT &quot;        ${libname}_methodNames, $methodNameCount,\n&quot;;
+    print OUT &quot;        ${libname}_types, $typeCount,\n&quot;;
+    print OUT &quot;        ${libname}_inheritanceList,\n&quot;;
+    print OUT &quot;        ${libname}_argumentList,\n&quot;;
+    print OUT &quot;        ${libname}_ambiguousMethodList,\n&quot;;
+    print OUT &quot;        ${libname}_cast );\n&quot;;
+    print OUT &quot;}\n&quot;;
+    close OUT;
+
+#print &quot;@{[keys %allMethods ]}\n&quot;;
+}
+
+1;

Modified: trunk/php_qt/CMakeLists.txt
===================================================================
--- trunk/php_qt/CMakeLists.txt	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/php_qt/CMakeLists.txt	2007-06-08 13:50:59 UTC (rev 345)
@@ -25,8 +25,12 @@
     )
 
 add_library(php_qt SHARED ${phpqt_LIB_SRCS})
-
 target_link_libraries(php_qt ${QT_QTCORE_LIBRARY} QtSvg QtGui QtNetwork QtSql QtOpenGL QtXml QtUiTools ${QTDBUS_LIBRARY} ${QSCINTILLA_LIBRARIES} ${QWT_LIBRARIES} smokeqt)
 set_target_properties(php_qt PROPERTIES PREFIX &quot;&quot;)
+install(TARGETS php_qt DESTINATION ${PHP5_EXTENSION_DIR}/ )
 
-install(TARGETS php_qt DESTINATION ${PHP5_EXTENSION_DIR}/ )
+add_library(iquip SHARED ${phpqt_LIB_SRCS})
+target_link_libraries(iquip ${QT_QTCORE_LIBRARY} QtSvg QtGui QtNetwork QtSql QtOpenGL QtXml QtUiTools ${QTDBUS_LIBRARY} ${QSCINTILLA_LIBRARIES} ${QWT_LIBRARIES} smokewebqt)
+set_target_properties(iquip PROPERTIES PREFIX &quot;&quot;)
+install(TARGETS iquip DESTINATION ${PHP5_EXTENSION_DIR}/ )
+

Modified: trunk/smoke/CMakeLists.txt
===================================================================
--- trunk/smoke/CMakeLists.txt	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/CMakeLists.txt	2007-06-08 13:50:59 UTC (rev 345)
@@ -3,8 +3,10 @@
 #message(STATUS &quot;${CMAKE_CURRENT_SOURCE_DIR}: skipped subdir $(kde_build_libsmoke)&quot;)
 
 add_subdirectory(qt)
+add_subdirectory(web)
 #add_subdirectory(kde)
 
+
 ########### install files ###############
 
 #install( FILES  smoke.h DESTINATION ${INCLUDE_INSTALL_DIR} )

Added: trunk/smoke/web/CMakeLists.txt
===================================================================
--- trunk/smoke/web/CMakeLists.txt	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/CMakeLists.txt	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,132 @@
+
+include(FindQScintilla)
+include(FindQwt)
+
+include_directories( ${QT_INCLUDES}  ${CMAKE_CURRENT_SOURCE_DIR}/../ ${CMAKE_CURRENT_SOURCE_DIR} )
+
+if(QSCINTILLA_FOUND)
+    include_directories( ${QSCINTILLA_INCLUDE_DIR} )
+endif(QSCINTILLA_FOUND)
+
+if(QWT_FOUND)
+    include_directories( ${QWT_INCLUDE_DIR} )
+endif(QWT_FOUND)
+
+IF(QT_QTDBUS_FOUND)
+    SET(QTDBUS_LIBRARY QtDBus)
+ENDIF(QT_QTDBUS_FOUND)
+
+# for qtguess.pl
+set(qt_test_threshold 10)
+set(qtflags &quot;-lQtCore -lQtGui&quot;)
+FOREACH(filename ${QT_INCLUDES})
+    set(all_includes &quot;-I${filename} ${all_includes}&quot;)
+ENDFOREACH(filename)
+
+configure_file(qtguess.pl.cmake ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl @ONLY)
+configure_file(generate.pl.cmake ${CMAKE_CURRENT_BINARY_DIR}/generate.pl @ONLY )
+
+# macro is defined in qt-copy/src/qbase.pri but couldn't be found by qtguess, so I append it manually
+file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/qtdefines &quot;QT_NO_CAST_TO_ASCII\n&quot;)
+
+########### next target ###############
+
+add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_2.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_3.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_4.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_5.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_6.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_7.cpp 
+                ${CMAKE_CURRENT_BINARY_DIR}/x_8.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_9.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_10.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_11.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_12.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_13.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_14.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_15.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_16.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_17.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_18.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_19.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_20.cpp
+
+                  COMMAND ${PERL_EXECUTABLE} ARGS ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl
+                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl
+
+                  COMMAND ${PERL_EXECUTABLE} ARGS ${CMAKE_CURRENT_BINARY_DIR}/generate.pl
+                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/generate.pl
+
+                  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
+
+macro_add_file_dependencies( ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp ${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp )
+
+set(smokewebqt_LIB_SRCS ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp  
+		${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_2.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_3.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_4.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_5.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_6.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_7.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_8.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_9.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_10.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_11.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_12.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_13.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_14.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_15.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_16.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_17.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_18.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_19.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_20.cpp
+)
+
+# kde4_add_library(smokewebqt SHARED ${smokewebqt_LIB_SRCS})
+add_library(smokewebqt SHARED ${smokewebqt_LIB_SRCS})
+
+target_link_libraries(smokewebqt ${QT_QTCORE_LIBRARY} QtSvg QtGui QtNetwork QtSql QtOpenGL QtXml QtUiTools ${QTDBUS_LIBRARY} ${QSCINTILLA_LIBRARIES} ${QWT_LIBRARIES} )
+
+set_target_properties(smokewebqt PROPERTIES VERSION 2.0.0 SOVERSION 2 )
+install(TARGETS smokewebqt DESTINATION lib )
+
+
+########### install files ###############
+
+
+
+
+#original Makefile.am contents follow:
+
+#lib_LTLIBRARIES = libsmokeqt.la
+#
+## set the include path for X, qt and KDE
+#INCLUDES         = -I$(srcdir)/.. $(all_includes) -I$(qt_includes)/QtUiTools \
+#                   -I$(qt_includes)/QtDBus
+#
+#EXTRA_DIST=generate.pl.in qtguess.pl.in qt_smoke.h Makefile.am
+#
+## the library search path. 
+#libsmokeqt_la_LDFLAGS = -version-info 2:0:0 -no-undefined $(all_libraries) $(GLINC)
+#
+## the libraries to link against.
+#libsmokeqt_la_LIBADD   = $(LIB_QTCORE) $(LIB_QTGUI) $(LIB_QTNETWORK) \
+#						$(LIB_QTOPENGL) $(LIB_QTSQL) $(LIB_QTCORE) $(LIB_QTXML) $(LIB_QTSVG) \
+#						$(GLLIB) $(LIBQSCINTILLA) \
+#						-lQtSvg -lQtUiTools $(LIBQTDBUS) $(LIBQWT)
+#
+#x_sources = x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+#   x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+#   x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp
+#
+## which sources should be compiled for perlqtkde
+#libsmokeqt_la_SOURCES = smokedata.cpp $(x_sources)
+#
+#$(x_sources) smokedata.cpp:
+#	perl generate.pl
+#
+#CLEANFILES = $(libsmokeqt_la_SOURCES)

Added: trunk/smoke/web/Makefile.am
===================================================================
--- trunk/smoke/web/Makefile.am	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/Makefile.am	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,28 @@
+lib_LTLIBRARIES = libsmokeqt.la
+
+# set the include path for X, qt and KDE
+INCLUDES         = -I$(srcdir)/.. $(all_includes) -I$(qt_includes)/QtUiTools \
+                   -I$(qt_includes)/QtDBus
+
+EXTRA_DIST=generate.pl.in qtguess.pl.in qt_smoke.h Makefile.am
+
+# the library search path. 
+libsmokeqt_la_LDFLAGS = -version-info 3:3:2 -no-undefined $(all_libraries) $(GLINC)
+
+# the libraries to link against.
+libsmokeqt_la_LIBADD   = $(LIB_QTCORE) $(LIB_QTGUI) $(LIB_QTNETWORK) \
+						$(LIB_QTOPENGL) $(LIB_QTSQL) $(LIB_QTCORE) $(LIB_QTXML) $(LIB_QTSVG) \
+						$(GLLIB) $(LIBQSCINTILLA) \
+						-lQtSvg -lQtUiTools $(LIBQTDBUS) $(LIBQWT)
+
+x_sources = x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+   x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+   x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp
+
+# which sources should be compiled for perlqtkde
+libsmokeqt_la_SOURCES = smokedata.cpp $(x_sources)
+
+$(x_sources) smokedata.cpp:
+	perl generate.pl
+
+CLEANFILES = $(libsmokeqt_la_SOURCES)

Added: trunk/smoke/web/Makefile.in
===================================================================
--- trunk/smoke/web/Makefile.in	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/Makefile.in	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,621 @@
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at SET_MAKE</A>@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+
+am__cd = CDPATH=&quot;$${ZSH_VERSION+.}$(PATH_SEPARATOR)&quot; &amp;&amp; cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+ENABLE_PERMISSIVE_FLAG = @ENABLE_PERMISSIVE_FLAG@
+EXEEXT = @EXEEXT@
+FRAMEWORK_COREAUDIO = @FRAMEWORK_COREAUDIO@
+GLINC = @GLINC@
+GLLIB = @GLLIB@
+HAVE_GCC_VISIBILITY = @HAVE_GCC_VISIBILITY@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+KDE_HAVE_GL = @KDE_HAVE_GL@
+KDE_MT_LDFLAGS = @KDE_MT_LDFLAGS@
+KDE_MT_LIBS = @KDE_MT_LIBS@
+KDE_NO_UNDEFINED = @KDE_NO_UNDEFINED@
+KDE_PLUGIN = @KDE_PLUGIN@
+KDE_USE_CLOSURE_FALSE = @KDE_USE_CLOSURE_FALSE@
+KDE_USE_CLOSURE_TRUE = @KDE_USE_CLOSURE_TRUE@
+KDE_USE_FINAL_FALSE = @KDE_USE_FINAL_FALSE@
+KDE_USE_FINAL_TRUE = @KDE_USE_FINAL_TRUE@
+KDE_USE_FPIE = @KDE_USE_FPIE@
+KDE_USE_NMCHECK_FALSE = @KDE_USE_NMCHECK_FALSE@
+KDE_USE_NMCHECK_TRUE = @KDE_USE_NMCHECK_TRUE@
+KDE_USE_PIE = @KDE_USE_PIE@
+LDFLAGS = @LDFLAGS@
+LDFLAGS_AS_NEEDED = @LDFLAGS_AS_NEEDED@
+LDFLAGS_NEW_DTAGS = @LDFLAGS_NEW_DTAGS@
+LIBCOMPAT = @LIBCOMPAT@
+LIBCRYPT = @LIBCRYPT@
+LIBDL = @LIBDL@
+LIBJPEG = @LIBJPEG@
+LIBOBJS = @LIBOBJS@
+LIBPNG = @LIBPNG@
+LIBPTHREAD = @LIBPTHREAD@
+LIBQSCINTILLA = @LIBQSCINTILLA@
+LIBQTDBUS = @LIBQTDBUS@
+LIBQWT = @LIBQWT@
+LIBRESOLV = @LIBRESOLV@
+LIBS = @LIBS@
+LIBSM = @LIBSM@
+LIBSOCKET = @LIBSOCKET@
+LIBTOOL = @LIBTOOL@
+LIBUCB = @LIBUCB@
+LIBUTIL = @LIBUTIL@
+LIBZ = @LIBZ@
+LIB_KAB = @LIB_KAB@
+LIB_KABC = @LIB_KABC@
+LIB_KDE3SUPPORT = @LIB_KDE3SUPPORT@
+LIB_KDECORE = @LIB_KDECORE@
+LIB_KDED = @LIB_KDED@
+LIB_KDEPIM = @LIB_KDEPIM@
+LIB_KDEPRINT = @LIB_KDEPRINT@
+LIB_KDEUI = @LIB_KDEUI@
+LIB_KDNSSD = @LIB_KDNSSD@
+LIB_KFILE = @LIB_KFILE@
+LIB_KHTML = @LIB_KHTML@
+LIB_KIMPROXY = @LIB_KIMPROXY@
+LIB_KIO = @LIB_KIO@
+LIB_KJS = @LIB_KJS@
+LIB_KNEWSTUFF = @LIB_KNEWSTUFF@
+LIB_KPARTS = @LIB_KPARTS@
+LIB_KSPELL = @LIB_KSPELL@
+LIB_KSPELL2 = @LIB_KSPELL2@
+LIB_KSYCOCA = @LIB_KSYCOCA@
+LIB_KUTILS = @LIB_KUTILS@
+LIB_POLL = @LIB_POLL@
+LIB_QPE = @LIB_QPE@
+LIB_QT = @LIB_QT@
+LIB_QT3SUPPORT = @LIB_QT3SUPPORT@
+LIB_QTCORE = @LIB_QTCORE@
+LIB_QTDESIGNER = @LIB_QTDESIGNER@
+LIB_QTGUI = @LIB_QTGUI@
+LIB_QTNETWORK = @LIB_QTNETWORK@
+LIB_QTOPENGL = @LIB_QTOPENGL@
+LIB_QTSQL = @LIB_QTSQL@
+LIB_QTTESTLIB = @LIB_QTTESTLIB@
+LIB_QTXML = @LIB_QTXML@
+LIB_SMB = @LIB_SMB@
+LIB_X11 = @LIB_X11@
+LIB_XEXT = @LIB_XEXT@
+LIB_XRENDER = @LIB_XRENDER@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MOC = @MOC@
+NOOPT_CFLAGS = @NOOPT_CFLAGS@
+NOOPT_CXXFLAGS = @NOOPT_CXXFLAGS@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PERL = @PERL@
+QTE_NORTTI = @QTE_NORTTI@
+QT_INCLUDES = @QT_INCLUDES@
+QT_LDFLAGS = @QT_LDFLAGS@
+RANLIB = @RANLIB@
+RCC = @RCC@
+RUBY = @RUBY@
+RUBY_ARCHDIR = @RUBY_ARCHDIR@
+RUBY_LIBDIR = @RUBY_LIBDIR@
+RUBY_LIBRUBYARG = @RUBY_LIBRUBYARG@
+RUBY_SITEARCHDIR = @RUBY_SITEARCHDIR@
+RUBY_SITEDIR = @RUBY_SITEDIR@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+TOPSUBDIRS = @TOPSUBDIRS@
+UIC = @UIC@
+UIC3_PATH = @UIC3_PATH@
+UIC_TR = @UIC_TR@
+USER_INCLUDES = @USER_INCLUDES@
+USER_LDFLAGS = @USER_LDFLAGS@
+USE_EXCEPTIONS = @USE_EXCEPTIONS@
+USE_RTTI = @USE_RTTI@
+USE_THREADS = @USE_THREADS@
+VERSION = @VERSION@
+WOVERLOADED_VIRTUAL = @WOVERLOADED_VIRTUAL@
+X_EXTRA_LIBS = @X_EXTRA_LIBS@
+X_INCLUDES = @X_INCLUDES@
+X_LDFLAGS = @X_LDFLAGS@
+X_PRE_LIBS = @X_PRE_LIBS@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+all_includes = @all_includes@
+all_libraries = @all_libraries@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+include_x11_FALSE = @include_x11_FALSE@
+include_x11_TRUE = @include_x11_TRUE@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+kde_build_libsmoke = @kde_build_libsmoke@
+kde_qtver = @kde_qtver@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+qt_includes = @qt_includes@
+qt_libraries = @qt_libraries@
+qt_test_threshold = @qt_test_threshold@
+qtdbus = @qtdbus@
+qtextscintilla = @qtextscintilla@
+qtruby_SUBDIR_included_FALSE = @qtruby_SUBDIR_included_FALSE@
+qtruby_SUBDIR_included_TRUE = @qtruby_SUBDIR_included_TRUE@
+qwt = @qwt@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+smoke_SUBDIR_included_FALSE = @smoke_SUBDIR_included_FALSE@
+smoke_SUBDIR_included_TRUE = @smoke_SUBDIR_included_TRUE@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+unsermake_enable_pch_FALSE = @unsermake_enable_pch_FALSE@
+unsermake_enable_pch_TRUE = @unsermake_enable_pch_TRUE@
+x_includes = @x_includes@
+x_libraries = @x_libraries@
+lib_LTLIBRARIES = libsmokeqt.la
+
+# set the include path for X, qt and KDE
+INCLUDES = -I$(srcdir)/.. $(all_includes) -I$(qt_includes)/QtUiTools \
+                   -I$(qt_includes)/QtDBus
+
+
+EXTRA_DIST = generate.pl.in qtguess.pl.in qt_smoke.h Makefile.am
+
+# the library search path. 
+libsmokeqt_la_LDFLAGS = -version-info 3:3:2 -no-undefined $(all_libraries) $(GLINC)
+
+# the libraries to link against.
+libsmokeqt_la_LIBADD = $(LIB_QTCORE) $(LIB_QTGUI) $(LIB_QTNETWORK) \
+						$(LIB_QTOPENGL) $(LIB_QTSQL) $(LIB_QTCORE) $(LIB_QTXML) $(LIB_QTSVG) \
+						$(GLLIB) $(LIBQSCINTILLA) \
+						-lQtSvg -lQtUiTools $(LIBQTDBUS) $(LIBQWT)
+
+
+x_sources = x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+   x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+   x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp
+
+
+# which sources should be compiled for perlqtkde
+libsmokeqt_la_SOURCES = smokedata.cpp $(x_sources)
+
+CLEANFILES = $(libsmokeqt_la_SOURCES)
+subdir = smoke/qt
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/admin/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES = qtguess.pl generate.pl
+LTLIBRARIES = $(lib_LTLIBRARIES)
+
+libsmokeqt_la_DEPENDENCIES =
+am__objects_1 = x_1.lo x_2.lo x_3.lo x_4.lo x_5.lo x_6.lo x_7.lo x_8.lo \
+	x_9.lo x_10.lo x_11.lo x_12.lo x_13.lo x_14.lo x_15.lo x_16.lo \
+	x_17.lo x_18.lo x_19.lo x_20.lo
+am_libsmokeqt_la_OBJECTS = smokedata.lo $(am__objects_1)
+libsmokeqt_la_OBJECTS = $(am_libsmokeqt_la_OBJECTS)
+
+DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/admin/depcomp
+am__depfiles_maybe = depfiles
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@DEP_FILES = ./$(DEPDIR)/smokedata.Plo ./$(DEPDIR)/x_1.Plo \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@	./$(DEPDIR)/x_10.Plo ./$(DEPDIR)/x_11.Plo \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@	./$(DEPDIR)/x_12.Plo ./$(DEPDIR)/x_13.Plo \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@	./$(DEPDIR)/x_14.Plo ./$(DEPDIR)/x_15.Plo \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@	./$(DEPDIR)/x_16.Plo ./$(DEPDIR)/x_17.Plo \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@	./$(DEPDIR)/x_18.Plo ./$(DEPDIR)/x_19.Plo \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@	./$(DEPDIR)/x_2.Plo ./$(DEPDIR)/x_20.Plo \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@	./$(DEPDIR)/x_3.Plo ./$(DEPDIR)/x_4.Plo \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@	./$(DEPDIR)/x_5.Plo ./$(DEPDIR)/x_6.Plo \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@	./$(DEPDIR)/x_7.Plo ./$(DEPDIR)/x_8.Plo \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@	./$(DEPDIR)/x_9.Plo
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+LTCXXCOMPILE = $(LIBTOOL) --mode=compile $(CXX) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CXXFLAGS) $(CXXFLAGS)
+CXXLD = $(CXX)
+CXXLINK = $(LIBTOOL) --mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+DIST_SOURCES = $(libsmokeqt_la_SOURCES)
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am generate.pl.in \
+	qtguess.pl.in
+SOURCES = $(libsmokeqt_la_SOURCES)
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cpp .lo .o .obj
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) &amp;&amp; \
+	  $(AUTOMAKE) --gnu  smoke/qt/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+qtguess.pl: $(top_builddir)/config.status qtguess.pl.in
+	cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status $(subdir)/$@
+generate.pl: $(top_builddir)/config.status generate.pl.in
+	cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status $(subdir)/$@
+libLTLIBRARIES_INSTALL = $(INSTALL)
+install-libLTLIBRARIES: $(lib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libdir)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    f=&quot;`echo $$p | sed -e 's|^.*/||'`&quot;; \
+	    echo &quot; $(LIBTOOL) --mode=install $(libLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) $$p $(DESTDIR)$(libdir)/$$f&quot;; \
+	    $(LIBTOOL) --mode=install $(libLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) $$p $(DESTDIR)$(libdir)/$$f; \
+	  else :; fi; \
+	done
+
+uninstall-libLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	    p=&quot;`echo $$p | sed -e 's|^.*/||'`&quot;; \
+	  echo &quot; $(LIBTOOL) --mode=uninstall rm -f $(DESTDIR)$(libdir)/$$p&quot;; \
+	  $(LIBTOOL) --mode=uninstall rm -f $(DESTDIR)$(libdir)/$$p; \
+	done
+
+clean-libLTLIBRARIES:
+	-test -z &quot;$(lib_LTLIBRARIES)&quot; || rm -f $(lib_LTLIBRARIES)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  dir=&quot;`echo $$p | sed -e 's|/[^/]*$$||'`&quot;; \
+	  test &quot;$$dir&quot; = &quot;$$p&quot; &amp;&amp; dir=.; \
+	  echo &quot;rm -f \&quot;$${dir}/so_locations\&quot;&quot;; \
+	  rm -f &quot;$${dir}/so_locations&quot;; \
+	done
+libsmokeqt.la: $(libsmokeqt_la_OBJECTS) $(libsmokeqt_la_DEPENDENCIES) 
+	$(CXXLINK) -rpath $(libdir) $(libsmokeqt_la_LDFLAGS) $(libsmokeqt_la_OBJECTS) $(libsmokeqt_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT) core *.core
+
+distclean-compile:
+	-rm -f *.tab.c
+
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">smokedata.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_1.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_10.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_11.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_12.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_13.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_14.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_15.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_16.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_17.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_18.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_19.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_2.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_20.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_3.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_4.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_5.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_6.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_7.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_8.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">x_9.Plo at am__quote</A>@
+
+.cpp.o:
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF &quot;$(DEPDIR)/$*.Tpo&quot; \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	  -c -o $@ `test -f '$&lt;' || echo '$(srcdir)/'`$&lt;; \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	then mv -f &quot;$(DEPDIR)/$*.Tpo&quot; &quot;$(DEPDIR)/$*.Po&quot;; \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	else rm -f &quot;$(DEPDIR)/$*.Tpo&quot;; exit 1; \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	fi
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__fastdepCXX_FALSE@	source='$&lt;' object='$@' libtool=no @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__fastdepCXX_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__fastdepCXX_FALSE@	$(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_FALSE</A>@	$(CXXCOMPILE) -c -o $@ `test -f '$&lt;' || echo '$(srcdir)/'`$&lt;
+
+.cpp.obj:
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF &quot;$(DEPDIR)/$*.Tpo&quot; \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	  -c -o $@ `if test -f '$&lt;'; then $(CYGPATH_W) '$&lt;'; else $(CYGPATH_W) '$(srcdir)/$&lt;'; fi`; \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	then mv -f &quot;$(DEPDIR)/$*.Tpo&quot; &quot;$(DEPDIR)/$*.Po&quot;; \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	else rm -f &quot;$(DEPDIR)/$*.Tpo&quot;; exit 1; \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	fi
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__fastdepCXX_FALSE@	source='$&lt;' object='$@' libtool=no @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__fastdepCXX_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__fastdepCXX_FALSE@	$(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_FALSE</A>@	$(CXXCOMPILE) -c -o $@ `if test -f '$&lt;'; then $(CYGPATH_W) '$&lt;'; else $(CYGPATH_W) '$(srcdir)/$&lt;'; fi`
+
+.cpp.lo:
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	if $(LTCXXCOMPILE) -MT $@ -MD -MP -MF &quot;$(DEPDIR)/$*.Tpo&quot; \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	  -c -o $@ `test -f '$&lt;' || echo '$(srcdir)/'`$&lt;; \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	then mv -f &quot;$(DEPDIR)/$*.Tpo&quot; &quot;$(DEPDIR)/$*.Plo&quot;; \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	else rm -f &quot;$(DEPDIR)/$*.Tpo&quot;; exit 1; \
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_TRUE</A>@	fi
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__fastdepCXX_FALSE@	source='$&lt;' object='$@' libtool=yes @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__fastdepCXX_FALSE@	depfile='$(DEPDIR)/$*.Plo' tmpdepfile='$(DEPDIR)/$*.TPlo' @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at AMDEP_TRUE</A>@@am__fastdepCXX_FALSE@	$(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at am__fastdepCXX_FALSE</A>@	$(LTCXXCOMPILE) -c -o $@ `test -f '$&lt;' || echo '$(srcdir)/'`$&lt;
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z &quot;$(ETAGS_ARGS)$$tags$$unique&quot; \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z &quot;$(CTAGS_ARGS)$$tags$$unique&quot; \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) &amp;&amp; pwd` \
+	  &amp;&amp; cd $(top_srcdir) \
+	  &amp;&amp; gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo &quot;$(srcdir)&quot; | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo &quot;$(top_srcdir)&quot; | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo &quot;$$file&quot; | sed &quot;s|^$$srcdirstrip/||&quot;`;; \
+	    $(top_srcdir)/*) file=`echo &quot;$$file&quot; | sed &quot;s|^$$topsrcdirstrip/|$(top_builddir)/|&quot;`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo &quot;$$file&quot; | sed -e 's,/[^/]*$$,,'`; \
+	  if test &quot;$$dir&quot; != &quot;$$file&quot; &amp;&amp; test &quot;$$dir&quot; != &quot;.&quot;; then \
+	    dir=&quot;/$$dir&quot;; \
+	    $(mkinstalldirs) &quot;$(distdir)$$dir&quot;; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file &amp;&amp; test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libdir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=&quot;$(INSTALL_STRIP_PROGRAM)&quot; \
+	  install_sh_PROGRAM=&quot;$(INSTALL_STRIP_PROGRAM)&quot; INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo &quot;INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'&quot;` install
+mostlyclean-generic:
+
+clean-generic:
+	-test -z &quot;$(CLEANFILES)&quot; || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo &quot;This command is intended for maintainers to use&quot;
+	@echo &quot;it deletes files that may require special tools to rebuild.&quot;
+clean: clean-am
+
+clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am: install-libLTLIBRARIES
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libLTLIBRARIES
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libLTLIBRARIES clean-libtool ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am info info-am install \
+	install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am \
+	install-libLTLIBRARIES install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-info-am \
+	uninstall-libLTLIBRARIES
+
+
+$(x_sources) smokedata.cpp:
+	perl generate.pl
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/smoke/web/configure.in.in
===================================================================
--- trunk/smoke/web/configure.in.in	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/configure.in.in	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,200 @@
+
+AC_HAVE_GL
+KDE_HAVE_GL=yes;
+if test &quot;X$GLLIB&quot; = &quot;X&quot;; then
+    KDE_HAVE_GL=no
+fi
+
+AC_SUBST(KDE_HAVE_GL)   
+
+AC_ARG_WITH(
+   threshold,
+   [  --with-threshold@&lt;:@=0..15@:&gt;@  Smoke: Qt tests threshold Default:10 Lower=more tests],
+   [ qt_test_threshold=&quot;$withval&quot; ],
+   [ qt_test_threshold=10 ]
+)
+AC_SUBST(qt_test_threshold)
+
+if test &quot;X$kde_build_libsmoke&quot; = &quot;Xqt&quot; -o &quot;X$kde_build_libsmoke&quot; = &quot;Xqt kde&quot;; then
+
+    AC_CONFIG_FILES([ smoke/qt/qtguess.pl ], [
+        cd smoke/qt
+        perl qtguess.pl
+        cd ../..
+    ])
+    AC_CONFIG_FILES([ smoke/qt/generate.pl ], [
+    ])
+fi
+
+dnl -------
+dnl Test for libqscintilla (QScintilla support)
+dnl -------
+
+AC_ARG_ENABLE(
+   qscintilla,
+   [  --enable-qscintilla@&lt;:@=yes|no@:&gt;@   Smoke: build Smoke with QScintilla extention for qt @&lt;:@default:no@:&gt;@],
+   [ qtextscintilla=&quot;$enableval&quot; ],
+   [ qtextscintilla=&quot;no&quot; ]
+)
+AC_SUBST(qtextscintilla)
+
+AC_DEFUN([AC_FIND_QSCINTILLA],
+[
+AC_MSG_CHECKING([for libqscintilla])
+AC_CACHE_VAL(ac_cv_lib_qscintilla,
+[
+ kde_ldflags_save=&quot;$LDFLAGS&quot;
+ kde_libs_save=&quot;$LIBS&quot;
+ kde_cxxflags_save=&quot;$CXXFLAGS&quot;
+
+ LIBS=&quot;-lqscintilla $LIBQT $LIBS&quot;
+ CXXFLAGS=&quot;$CXXFLAGS $all_includes&quot;
+ LDFLAGS=&quot;$LDFLAGS $all_libraries $USER_LDFLAGS&quot;
+
+AC_TRY_LINK([
+   #include &lt;qextscintillabase.h&gt;
+],
+[
+            QextScintillaBase s;
+],
+            eval &quot;ac_cv_lib_qscintilla='-lqscintilla'&quot;,
+            eval &quot;ac_cv_lib_qscintilla=no&quot;)
+
+ LDFLAGS=$kde_ldflags_save
+ LIBS=$kde_libs_save
+ CXXFLAGS=$kde_cxxflags_save
+])
+
+if test ! &quot;$ac_cv_lib_qscintilla&quot; = no; then
+  AC_DEFINE_UNQUOTED(HAVE_LIBQSCINTILLA, 1, [Define if you have libqscintilla])
+  LIBQSCINTILLA=&quot;$ac_cv_lib_qscintilla&quot;
+  AC_MSG_RESULT($ac_cv_lib_qscintilla)
+else
+  AC_MSG_ERROR(not found. 
+          Check your installation and look into config.log)
+  LIBQSCINTILLA=&quot;&quot;
+fi
+AC_SUBST(LIBQSCINTILLA)
+])
+
+if test &quot;X$qtextscintilla&quot; = &quot;Xyes&quot; ; then
+  AC_FIND_QSCINTILLA
+fi
+
+dnl -------
+dnl Test for libQtDBus (D-Bus support)
+dnl -------
+
+AC_ARG_ENABLE(
+   qtdbus,
+   [  --enable-qtdbus@&lt;:@=yes|no@:&gt;@   Smoke: build Smoke with QtDbus extention for qt @&lt;:@default:no@:&gt;@],
+   [ qtdbus=&quot;$enableval&quot; ],
+   [ qtdbus=&quot;no&quot; ]
+)
+AC_SUBST(qtdbus)
+
+AC_DEFUN([AC_FIND_QTDBUS],
+[
+AC_MSG_CHECKING([for libQtDBus])
+AC_CACHE_VAL(ac_cv_lib_qtdbus,
+[
+AC_LANG_SAVE
+AC_LANG_CPLUSPLUS
+
+ kde_ldflags_save=&quot;$LDFLAGS&quot;
+ kde_libs_save=&quot;$LIBS&quot;
+ kde_cxxflags_save=&quot;$CXXFLAGS&quot;
+
+ LIBS=&quot;-ldbus-1 -lQtDBus -ldbus-glib-1 $LIB_QTCORE $LIB_QTXML $LIBS&quot;
+ CXXFLAGS=&quot;$CXXFLAGS $all_includes -DDBUS_COMPILATION&quot;
+ LDFLAGS=&quot;$LDFLAGS $all_libraries $USER_LDFLAGS&quot;
+
+AC_TRY_LINK([
+   #include &lt;QtDBus/qdbusconnection.h&gt;
+],
+[
+            QDBusConnection b = QDBus::sessionBus();
+],
+            eval &quot;ac_cv_lib_qtdbus='-ldbus-1 -lQtDBus -ldbus-glib-1'&quot;,
+            eval &quot;ac_cv_lib_qtdbus=no&quot;)
+
+ LDFLAGS=$kde_ldflags_save
+ LIBS=$kde_libs_save
+ CXXFLAGS=$kde_cxxflags_save
+AC_LANG_RESTORE
+])
+
+if test ! &quot;$ac_cv_lib_qtdbus&quot; = no; then
+  AC_DEFINE_UNQUOTED(HAVE_LIBQTDBUS, 1, [Define if you have libdbus-qt4-1])
+  LIBQTDBUS=&quot;$ac_cv_lib_qtdbus&quot;
+  AC_MSG_RESULT($ac_cv_lib_qtdbus)
+else
+  AC_MSG_ERROR(not found. 
+          Check your installation and look into config.log)
+  LIBQTDBUS=&quot;&quot;
+fi
+AC_SUBST(LIBQTDBUS)
+])
+
+if test &quot;X$qtdbus&quot; = &quot;Xyes&quot; ; then
+  AC_FIND_QTDBUS
+fi
+
+dnl -------
+dnl Test for libqwt (Scientific Plotting library)
+dnl -------
+
+AC_ARG_ENABLE(
+   qwt,
+   [  --enable-qwt@&lt;:@=yes|no@:&gt;@   Smoke: build Smoke with Qwt extention for qt @&lt;:@default:no@:&gt;@],
+   [ qwt=&quot;$enableval&quot; ],
+   [ qwt=&quot;no&quot; ]
+)
+AC_SUBST(qwt)
+
+AC_DEFUN([AC_FIND_QWT],
+[
+AC_MSG_CHECKING([for libqwt])
+AC_CACHE_VAL(ac_cv_lib_qwt,
+[
+AC_LANG_SAVE
+AC_LANG_CPLUSPLUS
+
+ kde_ldflags_save=&quot;$LDFLAGS&quot;
+ kde_libs_save=&quot;$LIBS&quot;
+ kde_cxxflags_save=&quot;$CXXFLAGS&quot;
+
+ LIBS=&quot;-lqwt $LIB_QTCORE $LIB_QTXML $LIBS&quot;
+ CXXFLAGS=&quot;$CXXFLAGS $all_includes&quot;
+ LDFLAGS=&quot;$LDFLAGS $all_libraries $USER_LDFLAGS&quot;
+
+AC_TRY_LINK([
+   #include &lt;qwt_plot.h&gt;
+],
+[
+            QwtPlot p;
+],
+            eval &quot;ac_cv_lib_qwt='-lqwt'&quot;,
+            eval &quot;ac_cv_lib_qwt=no&quot;)
+
+ LDFLAGS=$kde_ldflags_save
+ LIBS=$kde_libs_save
+ CXXFLAGS=$kde_cxxflags_save
+AC_LANG_RESTORE
+])
+
+if test ! &quot;$ac_cv_lib_qwt&quot; = no; then
+  AC_DEFINE_UNQUOTED(HAVE_LIBQWT, 1, [Define if you have libqwt])
+  LIBQWT=&quot;$ac_cv_lib_qwt&quot;
+  AC_MSG_RESULT($ac_cv_lib_qwt)
+else
+  AC_MSG_ERROR(not found. 
+          Check your installation and look into config.log)
+  LIBQWT=&quot;&quot;
+fi
+AC_SUBST(LIBQWT)
+])
+
+if test &quot;X$qwt&quot; = &quot;Xyes&quot; ; then
+  AC_FIND_QWT
+fi

Added: trunk/smoke/web/generate.pl.cmake
===================================================================
--- trunk/smoke/web/generate.pl.cmake	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/generate.pl.cmake	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,254 @@
+#!/usr/bin/perl -w
+
+## Run this first, to generate the x_*.cpp files from the Qt headers
+## using kalyptus
+
+my $kalyptusdir = &quot;@CMAKE_CURRENT_SOURCE_DIR@/../../kalyptus&quot;;
+
+use File::Basename;
+use File::Copy qw|cp|;
+use File::Compare;
+use File::Find;
+use Cwd;
+
+my $here = getcwd;
+my $outdir = $here . &quot;/generate.pl.tmpdir&quot;;
+my $finaloutdir = $here;
+my $defines = &quot;qtdefines&quot;;
+my $headerlist = &quot;@CMAKE_CURRENT_SOURCE_DIR@/header_list&quot;;
+my $definespath = &quot;$here/$defines&quot;;
+my $headerlistpath = &quot;$headerlist&quot;;
+my $qscintilla_headerlist = &quot;&quot;;
+my $qscintilla_headerlistpath = &quot;&quot;;
+my $qtdbus_headerlist = &quot;&quot;;
+my $qtdbus_headerlistpath = &quot;&quot;;
+
+if(&quot;@QSCINTILLA_FOUND@&quot; eq &quot;YES&quot;)
+{
+ $qscintilla_headerlist = &quot;@CMAKE_CURRENT_SOURCE_DIR@/qscintilla2_header_list&quot;;
+ $qscintilla_headerlistpath = &quot;$here/$qscintilla_headerlist&quot;;
+}
+
+if(&quot;@QT_QTDBUS_FOUND@&quot; eq &quot;1&quot;)
+{
+ $qtdbus_headerlist = &quot;@CMAKE_CURRENT_SOURCE_DIR@/qtdbus_header_list&quot;;
+ $qtdbus_headerlistpath = &quot;$here/$qtdbus_headerlist&quot;;
+}
+
+if(&quot;@QWT_FOUND@&quot; eq &quot;YES&quot;)
+{
+ $qwt_headerlist = &quot;@CMAKE_CURRENT_SOURCE_DIR@/qwt_header_list&quot;;
+ $qwt_headerlistpath = &quot;$here/$qwt_headerlist&quot;;
+}
+
+## If srcdir != builddir, use headerlist from src
+$headerlistpath = $headerlist if ($headerlist =~ /^\//);
+if(&quot;@QSCINTILLA_FOUND@&quot; eq &quot;YES&quot;)
+{
+ $qscintilla_headerlistpath = $qscintilla_headerlist if ($qscintilla_headerlist =~ /^\//);
+}
+
+if(&quot;@QT_QTDBUS_FOUND@&quot; eq &quot;1&quot;)
+{
+ $qtdbus_headerlistpath = $qtdbus_headerlist if ($qtdbus_headerlist =~ /^\//);
+}
+
+if(&quot;@QWT_FOUND@&quot; eq &quot;YES&quot;)
+{
+ $qwt_headerlistpath = $qwt_headerlist if ($qwt_headerlist =~ /^\//);
+}
+## Note: outdir and finaloutdir should NOT be the same dir!
+
+# Delete all x_*.cpp files under outdir (or create outdir if nonexistent)
+if (-d $outdir) { system &quot;rm -f $outdir/x_*.cpp&quot;; } else { mkdir $outdir; }
+
+mkdir $finaloutdir unless (-d $finaloutdir);
+
+#  Load the QT_NO_* macros found in &quot;qtdefines&quot;. They'll be passed to kalyptus
+my $macros=&quot;&quot;;
+if ( -e $definespath ){
+    print &quot;Found '$defines'. Reading preprocessor symbols from there...\n&quot;;
+    $macros = &quot; --defines=$definespath &quot;;
+}
+
+mkdir $kalyptusdir, 0777;
+# Need to cd to kalyptus's directory so that perl finds Ast.pm etc.
+chdir &quot;$kalyptusdir&quot; or die &quot;Couldn't go to $kalyptusdir (edit script to change dir)\n&quot;;
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %excludes = (
+    'qaccessible.h' =&gt; 1,  # Accessibility support is not compiled by defaut
+    'qassistantclient.h' =&gt; 1, # Not part of Qt (introduced in Qt-3.1)
+    'qmotif.h' =&gt; 1,       # 
+    'qmotifwidget.h' =&gt; 1, # Motif extension (introduced in Qt-3.1)
+    'qmotifdialog.h' =&gt; 1, #
+    'qxt.h' =&gt; 1, # Xt
+    'qxtwidget.h' =&gt; 1, # Xt
+    'qdns.h' =&gt; 1, # internal
+    'qgl.h' =&gt; 1, # OpenGL
+    'qglcolormap.h' =&gt; 1, # OpenGL
+    'qnp.h' =&gt; 1, # NSPlugin
+    'qttableview.h' =&gt; 1,  # Not in Qt anymore...
+    'qtmultilineedit.h' =&gt; 1,  # Not in Qt anymore...
+    'qwidgetfactory.h' =&gt; 1,  # Just an interface
+    'qsharedmemory.h' =&gt; 1, # &quot;not part of the Qt API&quot; they say
+    'qwindowsstyle.h' =&gt; 1, # Qt windowsstyle, plugin
+    'qmotifstyle.h' =&gt; 1,
+    'qcompactstyle.h' =&gt; 1,
+    'qinterlacestyle.h' =&gt; 1,
+    'qmotifplusstyle.h' =&gt; 1,
+    'qsgistyle.h' =&gt; 1,
+    'qplatinumstyle.h' =&gt; 1,
+    'qcdestyle.h' =&gt; 1,
+	 'qworkspace.h' =&gt; 1,
+    'qwindowsxpstyle.h' =&gt; 1 # play on the safe side 
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %includes;
+open(HEADERS, $headerlistpath) or die &quot;Couldn't open $headerlistpath: $!\n&quot;;
+map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+close HEADERS;
+
+if(&quot;@QSCINTILLA_FOUND@&quot; eq &quot;YES&quot;)
+{
+ open(HEADERS, $qscintilla_headerlistpath) or die &quot;Couldn't open $qscintilla_headerlistpath: $!\n&quot;;
+ map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+ close HEADERS;
+}
+
+if(&quot;@QT_QTDBUS_FOUND@&quot; eq &quot;1&quot;)
+{
+ open(HEADERS, $qtdbus_headerlistpath) or die &quot;Couldn't open $qtdbus_headerlistpath: $!\n&quot;;
+ map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+ close HEADERS;
+}
+
+my %qwt_includes;
+if(&quot;@QWT_FOUND@&quot; eq &quot;YES&quot;)
+{
+ open(HEADERS, $qwt_headerlistpath) or die &quot;Couldn't open $qwt_headerlistpath: $!\n&quot;;
+ map { chomp ; $qwt_includes{$_} = 1 } &lt;HEADERS&gt;;
+ close HEADERS;
+}
+ 
+# Can we compile the OpenGl module ?
+if(&quot;@QT_OPENGL_FOUND@&quot; eq &quot;YES&quot;)
+{
+    open(DEFS, $definespath);
+    my @defs = &lt;DEFS&gt;;
+    close DEFS;
+    if(!grep(/QT_NO_OPENGL/, @defs))
+    {
+      $excludes{'qgl.h'} = undef;
+      $excludes{'qglcolormap.h'} = undef;
+    }
+    else
+    {
+      print STDERR &quot;Qt was not compiled with OpenGL support...\n Skipping QGL Classes.\n&quot;;
+    }
+}
+
+# List Qt headers, and exclude the ones listed above
+my @headers = ();
+
+$qtinc= '@QT_INCLUDE_DIR@';
+
+find(
+    {   wanted =&gt; sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qtinc);
+                if( !defined $excludes{$f} # Not excluded
+                     &amp;&amp; $includes{$f}        # Known header
+                     &amp;&amp; /\.h$/)     # Not a backup file etc. Only headers.
+                {
+                    my $header = $_;
+                    open(FILE, $_);
+                    my @header_lines = &lt;FILE&gt;;
+                    if (@header_lines == 1) {
+                        $line = $header_lines[0];
+                        if ($line =~ /^#include &quot;(.*)&quot;/) {
+                            push ( @headers, $qtinc . substr($1, 2) );
+                        } else {
+                            push ( @headers, $header );
+                        }
+                    } else {
+                        push ( @headers, $header );
+                    }
+                }
+	    	undef $includes{$f}   
+	     };
+	},
+	follow_fast =&gt; 1,
+	follow_skip =&gt; 2,
+	no_chdir =&gt; 1
+    }, $qtinc
+ );
+
+$qwtinc = '@QWT_INCLUDE_DIR@';
+
+find(
+    {   wanted =&gt; sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qwtinc);
+		push ( @headers, $_ )
+                if( !defined $excludes{$f} # Not excluded
+                     &amp;&amp; $qwt_includes{$f}        # Known header
+                     &amp;&amp; /\.h$/);     # Not a backup file etc. Only headers.
+	    	undef $qwt_includes{$f}   
+	     };
+	},
+	follow_fast =&gt; 1,
+	follow_skip =&gt; 2,
+	no_chdir =&gt; 1
+    }, $qwtinc
+ );
+ 
+# Launch kalyptus
+chdir &quot;../smoke/web&quot;;
+system &quot;perl <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">-I at kdebindings_SOURCE_DIR</A>@/kalyptus @kdebindings_SOURCE_DIR@/kalyptus/kalyptus @ARGV --qt4 --globspace -fwebsmoke --name=qt $macros --no-cache --outputdir=$outdir @headers&quot;;
+my $exit = $? &gt;&gt; 8;
+exit $exit if ($exit);
+chdir &quot;$kalyptusdir&quot;;
+
+# Generate diff for smokedata.cpp
+unless ( -e &quot;$finaloutdir/smokedata.cpp&quot; ) {
+    open( TOUCH, &quot;&gt;$finaloutdir/smokedata.cpp&quot;);
+    close TOUCH;
+}
+system &quot;diff -u $finaloutdir/smokedata.cpp $outdir/smokedata.cpp &gt; $outdir/smokedata.cpp.diff&quot;;
+
+# Copy changed or new files to finaloutdir
+opendir (OUT, $outdir) or die &quot;Couldn't opendir $outdir&quot;;
+foreach $filename (readdir(OUT)) {
+    next if ( -d &quot;$outdir/$filename&quot; ); # only files, not dirs
+    my $docopy = 1;
+    if ( -f &quot;$finaloutdir/$filename&quot; ) {
+        $docopy = compare(&quot;$outdir/$filename&quot;, &quot;$finaloutdir/$filename&quot;); # 1 if files are differents
+    }
+    if ($docopy) {
+	#print STDERR &quot;Updating $filename...\n&quot;;
+	cp(&quot;$outdir/$filename&quot;, &quot;$finaloutdir/$filename&quot;);
+    }
+}
+closedir OUT;
+
+# Check for deleted files and warn
+my $deleted = 0;
+opendir(FINALOUT, $finaloutdir) or die &quot;Couldn't opendir $finaloutdir&quot;;
+foreach $filename (readdir(FINALOUT)) {
+    next if ( -d &quot;$finaloutdir/$filename&quot; ); # only files, not dirs
+    if ( $filename =~ /.cpp$/ &amp;&amp; ! ($filename =~ /_la_closure.cpp/) &amp;&amp; ! -f &quot;$outdir/$filename&quot; ) {
+      print STDERR &quot;Removing obsolete file $filename\n&quot;;
+      unlink &quot;$finaloutdir/$filename&quot;;
+      $deleted = 1;
+    }
+}
+closedir FINALOUT;
+
+# Delete outdir
+system &quot;rm -rf $outdir&quot;;
+

Added: trunk/smoke/web/generate.pl.in
===================================================================
--- trunk/smoke/web/generate.pl.in	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/generate.pl.in	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,220 @@
+#!/usr/bin/perl -w
+
+## Run this first, to generate the x_*.cpp files from the Qt headers
+## using kalyptus
+
+my $kalyptusdir = &quot;../../kalyptus&quot;;
+
+use File::Basename;
+use File::Copy qw|cp|;
+use File::Compare;
+use File::Find;
+use Cwd;
+
+my $here = getcwd;
+my $outdir = $here . &quot;/generate.pl.tmpdir&quot;;
+my $finaloutdir = $here;
+my $defines = &quot;qtdefines&quot;;
+my $headerlist = &quot;@srcdir@/header_list&quot;;
+my $definespath = &quot;$here/$defines&quot;;
+my $headerlistpath = &quot;$here/$headerlist&quot;;
+my $qscintilla_headerlist = &quot;&quot;;
+my $qscintilla_headerlistpath = &quot;&quot;;
+my $qtdbus_headerlist = &quot;&quot;;
+my $qtdbus_headerlistpath = &quot;&quot;;
+
+if(&quot;@qtextscintilla@&quot; eq &quot;yes&quot;)
+{
+ $qscintilla_headerlist = &quot;./qscintilla_header_list&quot;;
+ $qscintilla_headerlistpath = &quot;$here/$qscintilla_headerlist&quot;;
+}
+
+if(&quot;@qtdbus@&quot; eq &quot;yes&quot;)
+{
+ $qtdbus_headerlist = &quot;./qtdbus_header_list&quot;;
+ $qtdbus_headerlistpath = &quot;$here/$qtdbus_headerlist&quot;;
+}
+
+if(&quot;@qwt@&quot; eq &quot;yes&quot;)
+{
+ $qwt_headerlist = &quot;./qwt_header_list&quot;;
+ $qwt_headerlistpath = &quot;$here/$qwt_headerlist&quot;;
+}
+
+## If srcdir != builddir, use headerlist from src
+$headerlistpath = $headerlist if ($headerlist =~ /^\//);
+if(&quot;@qtextscintilla@&quot; eq &quot;yes&quot;)
+{
+ $qscintilla_headerlistpath = $qscintilla_headerlist if ($qscintilla_headerlist =~ /^\//);
+}
+
+if(&quot;@qtdbus@&quot; eq &quot;yes&quot;)
+{
+ $qtdbus_headerlistpath = $qtdbus_headerlist if ($qtdbus_headerlist =~ /^\//);
+}
+
+if(&quot;@qwt@&quot; eq &quot;yes&quot;)
+{
+ $qwt_headerlistpath = $qwt_headerlist if ($qwt_headerlist =~ /^\//);
+}
+## Note: outdir and finaloutdir should NOT be the same dir!
+
+# Delete all x_*.cpp files under outdir (or create outdir if nonexistent)
+if (-d $outdir) { system &quot;rm -f $outdir/x_*.cpp&quot;; } else { mkdir $outdir; }
+
+mkdir $finaloutdir unless (-d $finaloutdir);
+
+#  Load the QT_NO_* macros found in &quot;qtdefines&quot;. They'll be passed to kalyptus
+my $macros=&quot;&quot;;
+if ( -e $definespath ){
+    print &quot;Found '$defines'. Reading preprocessor symbols from there...\n&quot;;
+    $macros = &quot; --defines=$definespath &quot;;
+}
+
+mkdir $kalyptusdir, 0777;
+# Need to cd to kalyptus's directory so that perl finds Ast.pm etc.
+chdir &quot;$kalyptusdir&quot; or die &quot;Couldn't go to $kalyptusdir (edit script to change dir)\n&quot;;
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %excludes = (
+    'qaccessible.h' =&gt; 1,  # Accessibility support is not compiled by defaut
+    'qassistantclient.h' =&gt; 1, # Not part of Qt (introduced in Qt-3.1)
+    'qmotif.h' =&gt; 1,       # 
+    'qmotifwidget.h' =&gt; 1, # Motif extension (introduced in Qt-3.1)
+    'qmotifdialog.h' =&gt; 1, #
+    'qxt.h' =&gt; 1, # Xt
+    'qxtwidget.h' =&gt; 1, # Xt
+    'qdns.h' =&gt; 1, # internal
+    'qgl.h' =&gt; 1, # OpenGL
+    'qglcolormap.h' =&gt; 1, # OpenGL
+    'qnp.h' =&gt; 1, # NSPlugin
+    'qttableview.h' =&gt; 1,  # Not in Qt anymore...
+    'qtmultilineedit.h' =&gt; 1,  # Not in Qt anymore...
+    'qwidgetfactory.h' =&gt; 1,  # Just an interface
+    'qsharedmemory.h' =&gt; 1, # &quot;not part of the Qt API&quot; they say
+    'qwindowsstyle.h' =&gt; 1, # Qt windowsstyle, plugin
+    'qmotifstyle.h' =&gt; 1,
+    'qcompactstyle.h' =&gt; 1,
+    'qinterlacestyle.h' =&gt; 1,
+    'qmotifplusstyle.h' =&gt; 1,
+    'qsgistyle.h' =&gt; 1,
+    'qplatinumstyle.h' =&gt; 1,
+    'qcdestyle.h' =&gt; 1,
+	 'qworkspace.h' =&gt; 1,
+    'qwindowsxpstyle.h' =&gt; 1 # play on the safe side 
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %includes;
+open(HEADERS, $headerlistpath) or die &quot;Couldn't open $headerlistpath: $!\n&quot;;
+map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+close HEADERS;
+
+if(&quot;@qtextscintilla@&quot; eq &quot;yes&quot;)
+{
+ open(HEADERS, $qscintilla_headerlistpath) or die &quot;Couldn't open $qscintilla_headerlistpath: $!\n&quot;;
+ map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+ close HEADERS;
+}
+
+if(&quot;@qtdbus@&quot; eq &quot;yes&quot;)
+{
+ open(HEADERS, $qtdbus_headerlistpath) or die &quot;Couldn't open $qtdbus_headerlistpath: $!\n&quot;;
+ map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+ close HEADERS;
+}
+
+if(&quot;@qwt@&quot; eq &quot;yes&quot;)
+{
+ open(HEADERS, $qwt_headerlistpath) or die &quot;Couldn't open $qwt_headerlistpath: $!\n&quot;;
+ map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+ close HEADERS;
+}
+ 
+# Can we compile the OpenGl module ?
+if(&quot;@KDE_HAVE_GL@&quot; eq &quot;yes&quot;)
+{
+    open(DEFS, $definespath);
+    my @defs = &lt;DEFS&gt;;
+    close DEFS;
+    if(!grep(/QT_NO_OPENGL/, @defs))
+    {
+      $excludes{'qgl.h'} = undef;
+      $excludes{'qglcolormap.h'} = undef;
+    }
+    else
+    {
+      print STDERR &quot;Qt was not compiled with OpenGL support...\n Skipping QGL Classes.\n&quot;;
+    }
+}
+
+# List Qt headers, and exclude the ones listed above
+my @headers = ();
+
+$qtinc= '@qt_includes@';
+
+find(
+    {   wanted =&gt; sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qtinc);
+                push ( @headers, $_ )
+	    	  if( !defined $excludes{$f} # Not excluded
+	    	     &amp;&amp; $includes{$f}        # Known header
+	    	     &amp;&amp; /\.h$/);     # Not a backup file etc. Only headers.
+	    	undef $includes{$f}   
+	     };
+	},
+	follow_fast =&gt; 1,
+	follow_skip =&gt; 2,
+	no_chdir =&gt; 1
+    }, $qtinc
+ );
+
+# Launch kalyptus
+chdir &quot;../smoke/qt&quot;;
+system &quot;perl <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">-I at top_srcdir</A>@/kalyptus @top_srcdir@/kalyptus/kalyptus @ARGV --qt4 --globspace -fsmoke --name=qt $macros --no-cache --outputdir=$outdir @headers&quot;;
+my $exit = $? &gt;&gt; 8;
+exit $exit if ($exit);
+chdir &quot;$kalyptusdir&quot;;
+
+# Generate diff for smokedata.cpp
+unless ( -e &quot;$finaloutdir/smokedata.cpp&quot; ) {
+    open( TOUCH, &quot;&gt;$finaloutdir/smokedata.cpp&quot;);
+    close TOUCH;
+}
+system &quot;diff -u $finaloutdir/smokedata.cpp $outdir/smokedata.cpp &gt; $outdir/smokedata.cpp.diff&quot;;
+
+# Copy changed or new files to finaloutdir
+opendir (OUT, $outdir) or die &quot;Couldn't opendir $outdir&quot;;
+foreach $filename (readdir(OUT)) {
+    next if ( -d &quot;$outdir/$filename&quot; ); # only files, not dirs
+    my $docopy = 1;
+    if ( -f &quot;$finaloutdir/$filename&quot; ) {
+        $docopy = compare(&quot;$outdir/$filename&quot;, &quot;$finaloutdir/$filename&quot;); # 1 if files are differents
+    }
+    if ($docopy) {
+	#print STDERR &quot;Updating $filename...\n&quot;;
+	cp(&quot;$outdir/$filename&quot;, &quot;$finaloutdir/$filename&quot;);
+    }
+}
+closedir OUT;
+
+# Check for deleted files and warn
+my $deleted = 0;
+opendir(FINALOUT, $finaloutdir) or die &quot;Couldn't opendir $finaloutdir&quot;;
+foreach $filename (readdir(FINALOUT)) {
+    next if ( -d &quot;$finaloutdir/$filename&quot; ); # only files, not dirs
+    if ( $filename =~ /.cpp$/ &amp;&amp; ! ($filename =~ /_la_closure.cpp/) &amp;&amp; ! -f &quot;$outdir/$filename&quot; ) {
+      print STDERR &quot;Removing obsolete file $filename\n&quot;;
+      unlink &quot;$finaloutdir/$filename&quot;;
+      $deleted = 1;
+    }
+}
+closedir FINALOUT;
+
+# Delete outdir
+system &quot;rm -rf $outdir&quot;;
+

Added: trunk/smoke/web/generate_makefile_am.pl
===================================================================
--- trunk/smoke/web/generate_makefile_am.pl	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/generate_makefile_am.pl	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,55 @@
+#!/usr/bin/perl -w
+
+use File::Basename;
+
+my $here = `pwd`;
+chomp $here;
+my $outdir = $here;
+my $tempfile = &quot;$outdir/.Makefile.am.tmpfile&quot;;
+
+# Update list of source files in $outdir/Makefile.am
+open( MAKEFILE, &quot;&lt;$outdir/Makefile.am&quot; ) or die;
+my $makeFileData = '';
+my $found = 0;
+while (&lt;MAKEFILE&gt;) {
+	if (/^libsmokeqt_la_SOURCES/)
+	{
+		$found = 1;
+		$makeFileData .= &quot;libsmokeqt_la_SOURCES = smokedata.cpp&quot;;
+	}
+	$makeFileData .= $_ if (!$found);
+}
+close MAKEFILE;
+
+die &quot;libsmokeqt_la_SOURCES not found&quot; if (!$found);
+
+open( MAKEFILE, &quot;&gt;$tempfile&quot; ) or die;
+print MAKEFILE $makeFileData;
+
+my $count = 0;
+opendir (FILES, $outdir) or die;
+foreach $filename (readdir(FILES)) {
+	if ( $filename =~ /^x_.*\.cpp$/ ) {
+		if ( $count++ == 7 ) {
+			$count = 0;
+			print MAKEFILE &quot; \\\n&quot;;
+		}
+		print MAKEFILE &quot; $filename&quot;;
+	}
+}
+
+print MAKEFILE &quot;\n&quot;;
+close MAKEFILE;
+closedir FILES;
+
+system &quot;cmp -s $tempfile $outdir/Makefile.am&quot;;
+if ($? &gt;&gt; 8) {
+    system &quot;cp -f $tempfile $outdir/Makefile.am&quot;;
+    print STDERR &quot;Makefile.am updated.\n&quot;;
+}
+else {
+    print STDERR &quot;Makefile.am unchanged.\n&quot;;
+}
+system &quot;rm -f $tempfile&quot;;
+
+exit 0;


Property changes on: trunk/smoke/web/generate_makefile_am.pl
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/smoke/web/header_list
===================================================================
--- trunk/smoke/web/header_list	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/header_list	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,299 @@
+QtCore/qabstracteventdispatcher.h
+QtCore/qabstractfileengine.h
+QtCore/qabstractitemmodel.h
+QtCore/qalgorithms.h
+QtCore/qbasictimer.h
+QtCore/qbitarray.h
+QtCore/qbuffer.h
+QtCore/qbytearray.h
+QtCore/qbytearraymatcher.h
+QtCore/qcache.h
+QtCore/qchar.h
+QtCore/qconfig-dist.h
+QtCore/qconfig.h
+QtCore/qconfig-large.h
+QtCore/qconfig-medium.h
+QtCore/qconfig-minimal.h
+QtCore/qconfig-small.h
+QtCore/qcoreapplication.h
+QtCore/qcoreevent.h
+QtCore/qdatastream.h
+QtCore/qdatetime.h
+QtCore/qdebug.h
+QtCore/qdir.h
+QtCore/qeventloop.h
+QtCore/qfactoryinterface.h
+QtCore/qfeatures.h
+QtCore/qfile.h
+QtCore/qfileinfo.h
+QtCore/qfilesystemwatcher.h
+QtCore/qfsfileengine.h
+QtCore/qglobal.h
+QtCore/qiodevice.h
+QtCore/qiterator.h
+QtCore/qlibrary.h
+QtCore/qlibraryinfo.h
+QtCore/qline.h
+QtCore/qlocale.h
+QtCore/qmap.h
+QtCore/qmetaobject.h
+QtCore/qmetatype.h
+QtCore/qmimedata.h
+QtCore/qmutex.h
+QtCore/qnamespace.h
+QtCore/qobjectcleanuphandler.h
+QtCore/qobjectdefs.h
+QtCore/qobject.h
+QtCore/qpair.h
+QtCore/qplugin.h
+QtCore/qpluginloader.h
+QtCore/qpointer.h
+QtCore/qpoint.h
+QtCore/qprocess.h
+QtCore/qqueue.h
+QtCore/qreadwritelock.h
+QtCore/qrect.h
+QtCore/qregexp.h
+QtCore/qsemaphore.h
+QtCore/qsettings.h
+QtCore/qshareddata.h
+QtCore/qsignalmapper.h
+QtCore/qsize.h
+QtCore/qsocketnotifier.h
+QtCore/qstack.h
+QtCore/qstring.h
+QtCore/qstringlist.h
+QtCore/qstringmatcher.h
+QtCore/qtemporaryfile.h
+QtCore/qtextcodec.h
+QtCore/qtextcodecplugin.h
+QtCore/qtextstream.h
+QtCore/qthread.h
+QtCore/qthreadstorage.h
+QtCore/qtimeline.h
+QtCore/qtimer.h
+QtCore/qtranslator.h
+QtCore/qurl.h
+QtCore/quuid.h
+QtCore/qvariant.h
+QtCore/qvarlengtharray.h
+QtCore/qvector.h
+QtCore/qwaitcondition.h
+QtGui/qabstractbutton.h
+QtGui/qabstractitemdelegate.h
+QtGui/qabstractitemview.h
+QtGui/qabstractpagesetupdialog.h
+QtGui/qabstractprintdialog.h
+QtGui/qabstractproxymodel.h
+QtGui/qabstractscrollarea.h
+QtGui/qabstractslider.h
+QtGui/qabstractspinbox.h
+QtGui/qabstracttextdocumentlayout.h
+QtGui/qaccessiblebridge.h
+QtGui/qaccessible.h
+QtGui/qaccessibleobject.h
+QtGui/qaccessibleplugin.h
+QtGui/qaccessiblewidget.h
+QtGui/qactiongroup.h
+QtGui/qaction.h
+QtGui/qapplication.h
+QtGui/qbitmap.h
+QtGui/qboxlayout.h
+QtGui/qbrush.h
+QtGui/qbuttongroup.h
+QtGui/qcalendarwidget.h
+QtGui/qcheckbox.h
+QtGui/qcleanlooksstyle.h
+QtGui/qclipboard.h
+QtGui/qcolordialog.h
+QtGui/qcolor.h
+QtGui/qcolormap.h
+QtGui/qcombobox.h
+QtGui/qcommonstyle.h
+QtGui/qcompleter.h
+QtGui/qcursor.h
+QtGui/qdatawidgetmapper.h
+QtGui/qdatetimeedit.h
+QtGui/qdesktopservices.h
+QtGui/qdesktopwidget.h
+QtGui/qdial.h
+QtGui/qdialogbuttonbox.h
+QtGui/qdialog.h
+QtGui/qdirmodel.h
+QtGui/qdockwidget.h
+QtGui/qdrag.h
+QtGui/qdrawutil.h
+QtGui/qerrormessage.h
+QtGui/qevent.h
+QtGui/qfiledialog.h
+QtGui/qfocusframe.h
+QtGui/qfontcombobox.h
+QtGui/qfontdatabase.h
+QtGui/qfontdialog.h
+QtGui/qfont.h
+QtGui/qfontinfo.h
+QtGui/qfontmetrics.h
+QtGui/qframe.h
+QtGui/qgraphicsitemanimation.h
+QtGui/qgraphicsitem.h
+QtGui/qgraphicssceneevent.h
+QtGui/qgraphicsscene.h
+QtGui/qgraphicsview.h
+QtGui/qgridlayout.h
+QtGui/qgroupbox.h
+QtGui/qhboxlayout.h
+QtGui/qheaderview.h
+QtGui/qiconengine.h
+QtGui/qiconengineplugin.h
+QtGui/qicon.h
+QtGui/qimage.h
+QtGui/qimageiohandler.h
+QtGui/qimagereader.h
+QtGui/qimagewriter.h
+QtGui/qinputcontextfactory.h
+QtGui/qinputcontext.h
+QtGui/qinputcontextplugin.h
+QtGui/qinputdialog.h
+QtGui/qitemdelegate.h
+QtGui/qitemeditorfactory.h
+QtGui/qitemselectionmodel.h
+QtGui/qkeysequence.h
+QtGui/qlabel.h
+QtGui/qlayout.h
+QtGui/qlayoutitem.h
+QtGui/qlcdnumber.h
+QtGui/qlineedit.h
+QtGui/qlistview.h
+QtGui/qlistwidget.h
+QtGui/qmacstyle.h
+QtGui/qmainwindow.h
+QtGui/qmatrix.h
+QtGui/qmenubar.h
+QtGui/qmenudata.h
+QtGui/qmenu.h
+QtGui/qmessageboxex.h
+QtGui/qmessagebox.h
+QtGui/qmime.h
+QtGui/qmovie.h
+QtGui/qpagesetupdialog.h
+QtGui/qpaintdevice.h
+QtGui/qpaintengine.h
+QtGui/qpainter.h
+QtGui/qpainterpath.h
+QtGui/qpalette.h
+QtGui/qpen.h
+QtGui/qpictureformatplugin.h
+QtGui/qpicture.h
+QtGui/qpixmapcache.h
+QtGui/qpixmap.h
+QtGui/qplastiquestyle.h
+QtGui/qpolygon.h
+QtGui/qprintdialog.h
+QtGui/qprintengine.h
+QtGui/qprinter.h
+QtGui/qprogressbar.h
+QtGui/qprogressdialog.h
+QtGui/qproxymodel.h
+QtGui/qpushbutton.h
+QtGui/qradiobutton.h
+QtGui/qregion.h
+QtGui/qrgb.h
+QtGui/qrubberband.h
+QtGui/qscrollarea.h
+QtGui/qscrollbar.h
+QtGui/qsessionmanager.h
+QtGui/qshortcut.h
+QtGui/qsizegrip.h
+QtGui/qsizepolicy.h
+QtGui/qslider.h
+QtGui/qsortfilterproxymodel.h
+QtGui/qsound.h
+QtGui/qspinbox.h
+QtGui/qsplashscreen.h
+QtGui/qsplitter.h
+QtGui/qstackedlayout.h
+QtGui/qstackedwidget.h
+QtGui/qstandarditemmodel.h
+QtGui/qstatusbar.h
+QtGui/qstringlistmodel.h
+QtGui/qstylefactory.h
+QtGui/qstyle.h
+QtGui/qstyleoption.h
+QtGui/qstylepainter.h
+QtGui/qstyleplugin.h
+QtGui/qsyntaxhighlighter.h
+QtGui/qsystemtrayicon.h
+QtGui/qtabbar.h
+QtGui/qtableview.h
+QtGui/qtablewidget.h
+QtGui/qtabwidget.h
+QtGui/qtextbrowser.h
+QtGui/qtextcursor.h
+QtGui/qtextdocumentfragment.h
+QtGui/qtextdocument.h
+QtGui/qtextedit.h
+QtGui/qtextformat.h
+QtGui/qtextlayout.h
+QtGui/qtextlist.h
+QtGui/qtextobject.h
+QtGui/qtextoption.h
+QtGui/qtexttable.h
+QtGui/qtoolbar.h
+QtGui/qtoolbox.h
+QtGui/qtoolbutton.h
+QtGui/qtooltip.h
+QtGui/qtreeview.h
+QtGui/qtreewidget.h
+QtGui/qtreewidgetitemiterator.h
+QtGui/qundogroup.h
+QtGui/qundostack.h
+QtGui/qundoview.h
+QtGui/qvalidator.h
+QtGui/qvboxlayout.h
+QtGui/qvfbhdr.h
+QtGui/qwhatsthis.h
+QtGui/qwidgetaction.h
+QtGui/qwidget.h
+QtGui/qwindowdefs.h
+QtGui/qwindowsstyle.h
+QtGui/qwindowsxpstyle.h
+QtGui/qwmatrix.h
+QtGui/qworkspace.h
+QtGui/qx11embed_x11.h
+QtGui/qx11info_x11.h
+QtNetwork/qabstractsocket.h
+QtNetwork/qftp.h
+QtNetwork/qhostaddress.h
+QtNetwork/qhostinfo.h
+QtNetwork/qhttp.h
+QtNetwork/qnetworkinterface.h
+QtNetwork/qnetworkproxy.h
+QtNetwork/qtcpserver.h
+QtNetwork/qtcpsocket.h
+QtNetwork/qudpsocket.h
+QtNetwork/qurlinfo.h
+QtOpenGL/qglcolormap.h
+QtOpenGL/qglframebufferobject.h
+QtOpenGL/qgl.h
+QtOpenGL/qglpixelbuffer.h
+Qt/qiconset.h
+QtSql/qsqldatabase.h
+QtSql/qsqldriver.h
+QtSql/qsqldriverplugin.h
+QtSql/qsqlerror.h
+QtSql/qsqlfield.h
+QtSql/qsql.h
+QtSql/qsqlindex.h
+QtSql/qsqlquery.h
+QtSql/qsqlquerymodel.h
+QtSql/qsqlrecord.h
+QtSql/qsqlrelationaldelegate.h
+QtSql/qsqlrelationaltablemodel.h
+QtSql/qsqlrelation.h
+QtSql/qsqlresult.h
+QtSql/qsqltablemodel.h
+QtSvg/qsvgrenderer.h
+QtSvg/qsvgwidget.h
+QtUiTools/quiloader.h
+QtXml/qdom.h
+QtXml/qxml.h

Added: trunk/smoke/web/hint_header_list.pl
===================================================================
--- trunk/smoke/web/hint_header_list.pl	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/hint_header_list.pl	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,23 @@
+
+# CVS admin : run this script to compare the set of Qt headers to
+#             the actual content of header_list
+
+$l = &quot;header_list&quot;;
+$q = $ENV{'QTDIR'} || die &quot;QTDIR not set\n&quot;;
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at h</A> = &lt;$q/include/*.h&gt;;
+grep s|.*/(.*\.h)|$1|, @h;
+open(IN, $l) or die &quot;$!: $l\n&quot;;
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at old</A> = &lt;IN&gt;;
+chomp @old;
+map{ $h{$_}++ } @h;
+map{ $old{$_}++ } @old;
+map{ $diff{$_}++ unless $old{$_} } keys %h; 
+map{ delete $diff{$_} if /^qconfig.*/ or !/^q/ } keys %diff;
+print &quot;Check if any of the following headers should be added to $l:\n\n&quot;;
+print join &quot;\n&quot;, keys %diff,  &quot;\n&quot;
+
+
+
+
+
+

Added: trunk/smoke/web/qscintilla2_header_list
===================================================================
--- trunk/smoke/web/qscintilla2_header_list	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qscintilla2_header_list	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,30 @@
+Qsci/qsciapis.h
+Qsci/qscicommand.h
+Qsci/qscicommandset.h
+Qsci/qscidocument.h
+Qsci/qsciglobal.h
+Qsci/qscilexerbash.h
+Qsci/qscilexerbatch.h
+Qsci/qscilexercpp.h
+Qsci/qscilexercsharp.h
+Qsci/qscilexercss.h
+Qsci/qscilexerdiff.h
+Qsci/qscilexer.h
+Qsci/qscilexerhtml.h
+Qsci/qscilexeridl.h
+Qsci/qscilexerjava.h
+Qsci/qscilexerjavascript.h
+Qsci/qscilexerlua.h
+Qsci/qscilexermakefile.h
+Qsci/qscilexerperl.h
+Qsci/qscilexerpov.h
+Qsci/qscilexerproperties.h
+Qsci/qscilexerpython.h
+Qsci/qscilexerruby.h
+Qsci/qscilexersql.h
+Qsci/qscilexertex.h
+Qsci/qscimacro.h
+Qsci/qscintilla2_header_list
+Qsci/qsciprinter.h
+Qsci/qsciscintillabase.h
+Qsci/qsciscintilla.h

Added: trunk/smoke/web/qscintilla_header_list
===================================================================
--- trunk/smoke/web/qscintilla_header_list	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qscintilla_header_list	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,22 @@
+qextscintilla.h
+qextscintillaapis.h
+qextscintillabase.h
+qextscintillacommand.h
+qextscintillacommandset.h
+qextscintilladocument.h
+qextscintillaglobal.h
+qextscintillalexer.h
+qextscintillalexerbash.h
+qextscintillalexercpp.h
+qextscintillalexercsharp.h
+qextscintillalexerhtml.h
+qextscintillalexeridl.h
+qextscintillalexerjava.h
+qextscintillalexerjavascript.h
+qextscintillalexerlua.h
+qextscintillalexerperl.h
+qextscintillalexerpython.h
+qextscintillalexerruby.h
+qextscintillalexersql.h
+qextscintillamacro.h
+qextscintillaprinter.h

Added: trunk/smoke/web/qt_smoke.h
===================================================================
--- trunk/smoke/web/qt_smoke.h	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qt_smoke.h	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,12 @@
+#ifndef QT_SMOKE_H
+#define QT_SMOKE_H
+
+// Don't use kdemacros.h/KDE_EXPORT here as it needs to be free of KDE dependencies
+#include &lt;QtCore/qglobal.h&gt;
+// Defined in smokedata.cpp, initialized by init_qt_Smoke(), used by all .cpp files
+extern Q_DECL_EXPORT Smoke* qt_Smoke;
+extern Q_DECL_EXPORT void init_qt_Smoke();
+
+class QGlobalSpace { };
+
+#endif

Added: trunk/smoke/web/qtdbus_header_list
===================================================================
--- trunk/smoke/web/qtdbus_header_list	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qtdbus_header_list	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,13 @@
+QtDBus/qdbusabstractadaptor.h
+QtDBus/qdbusabstractinterface.h
+QtDBus/qdbusargument.h
+QtDBus/qdbusconnection.h
+QtDBus/qdbusconnectioninterface.h
+QtDBus/qdbuserror.h
+QtDBus/qdbusextratypes.h
+QtDBus/qdbusinterface.h
+QtDBus/qdbusmacros.h
+QtDBus/qdbusmessage.h
+QtDBus/qdbusmetatype.h
+QtDBus/qdbusreply.h
+QtDBus/qdbusserver.h

Added: trunk/smoke/web/qtguess.pl.cmake
===================================================================
--- trunk/smoke/web/qtguess.pl.cmake	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qtguess.pl.cmake	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,423 @@
+#!/usr/bin/perl
+
+# qtguess.pl : check how Qt was compiled. Issue a list of all defined QT_NO_* macros, one per line.
+#
+# author:  germain Garand &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">germain at ebooksfrance.com</A>&gt;
+# licence: GPL v.2
+
+# options: -q: be quieter
+#	   -o file: redirect output to &quot;file&quot;. (default: ./qtdefines)
+#	   -t [0..15]: set the testing threshold (see below)
+#	   -f &quot;flags&quot;: additional compiler flags/parameters
+
+use Getopt::Std;
+
+use vars qw/$opt_f $opt_o $opt_p/;
+
+getopts('qo:f:t:');
+
+# Threshold :
+#	 0 - test basic Qt types/classes
+#	 5 - test higher level, non-gui classes
+#	 8 - test options of the above (ex: QT_NO_IMAGE_SMOOTHSCALE)
+#	10 - test basic widgets
+#	12 - test composite widgets
+#	13 - test widgets inheriting composite widgets
+#	15 - test goodies (default)
+
+my $default_threshold = @qt_test_threshold@;
+my $cc = &quot;@CMAKE_CXX_COMPILER@&quot;;
+my $ccflags = $opt_f || &quot;@CMAKE_CXX_FLAGS@&quot;;
+
+my $nspaces = 50;
+
+my %qtdefs=();
+my %qtundefs=();
+
+my $tmp = gettmpfile();
+my $qtinc = '@QT_INCLUDE_DIR@';
+my $allinc = '@all_includes@';
+my $alllib = '<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">-L at QT_LIBRARY_DIR</A>@';
+my $qtflags = '@qtflags@';
+# my %x;
+# $x{'LIBPNG'}  =   '@LIBPNG@';
+# $x{'LIBJPEG'} =   '@LIBJPEG@';
+# $x{'LIBSM'}   =   '@LIBSM@';
+# $x{'LIBSOCKET'} = '@LIBSOCKET@';
+# $x{'LIBDL'}      = '@LIBDL@';
+# $x{'LIBRESOLV'}  = '@LIBRESOLV@';
+# $x{'LIB_X11'} =   '@LIB_X11@';
+# $x{'X_PRE_LIBS'} = '@X_PRE_LIBS@';
+# $x{'LIB_X11'} =~ s/\$\((.*?)\)/$x{$1}/g;
+# 
+# $qtflags =~ s/\$\((.*?)\)/$x{$1}/g;
+
+ -e &quot;$qtinc/QtCore/qglobal.h&quot; or die &quot;Invalid Qt include directory.\n&quot;;
+
+my $ccmd = &quot;$cc $ccflags $allinc $alllib -o $tmp $tmp.cpp $qtflags&quot;;
+
+my $threshold = defined($opt_t)?$opt_t : $default_threshold;
+$threshold &gt;= 0 or die &quot;invalid testing threshold: $threshold\n&quot;;
+
+print &quot;Checking how Qt was built... \n&quot;;
+print &quot;Threshold is set to $threshold\n&quot; unless $opt_q;
+
+my($count, $used, $total);
+map{ $tests{$_}-&gt;[2]&gt;=$threshold ? ($used++, $total++):$total++ } keys %tests;
+
+print &quot;Number of defines to be tested : $used/$total\n\n&quot; unless $opt_q;
+open( QTDEFS, &quot;&gt;&gt;&quot;.($opt_o || &quot;qtdefines&quot;) ) or die &quot;Can't open output file: $!\n&quot;;
+
+grab_qglobal_symbols();
+preliminary_test();
+perform_all_tests();
+
+print +scalar(keys %qtdefs) . &quot; defines found.\n&quot;;
+
+print QTDEFS join(&quot;\n&quot;, keys %qtdefs), &quot;\n&quot;;
+close;
+
+#--------------------------------------------------------------#
+
+sub gettmpfile
+{
+	my $tmpdir = $ENV{'TMP'} || &quot;.&quot;;
+	my $tmpname = $$.&quot;-qtguess&quot;;
+	while( -e &quot;$tmpdir/$tmpname&quot; || -e &quot;$tmpdir/${tmpname}.cpp&quot; )
+	{
+		$tmpname .= int (rand * 9);
+	}
+	return &quot;$tmpdir/$tmpname&quot;;
+}
+
+#--------------------------------------------------------------#
+
+sub grab_qglobal_symbols
+{
+	my $cmd = &quot;$cc -E -D__cplusplus -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2&gt;/dev/null&quot;;
+	my $symbols = `$cmd`;
+        for(0..1)
+        {
+	    if( check_exit_status($?) )
+	    {
+		while( $symbols =~/^#\s*define\s*(QT_\S+)/gm )
+		{
+			$qtdefs{$1} = 1;
+		}
+		print &quot;Found &quot;. scalar( keys %qtdefs ).&quot; predefined symbol&quot;.((scalar( keys %qtdefs ) -1)?&quot;s&quot;:&quot;&quot;).&quot; in qglobal.h\n&quot; unless ($opt_q or !(keys %qtdefs));
+		while( $symbols =~/^#\s*define\s*QT_MODULE_(\S+)/gm )
+		{
+			$qtundefs{&quot;QT_NO_$1&quot;} = 1;
+		}
+		print &quot;Found &quot;. scalar( keys %qtundefs ).&quot; undefined symbol&quot;.((scalar( keys %qtundefs ) -1)?&quot;s&quot;:&quot;&quot;).&quot; in qglobal.h\n&quot; unless ($opt_q or !(keys %qtundefs));
+                last;
+	    }
+	    elsif(! $_) # first try
+	    {
+		print  &quot;Failed to run $cmd.\nTrying without __cplusplus (might be already defined)\n&quot;;
+                $cmd = &quot;$cc -E -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2&gt;/dev/null&quot;;
+                $symbols = `$cmd`;
+                next;
+	    }
+        }
+}
+
+#--------------------------------------------------------------#
+
+sub preliminary_test
+{
+	my $msg = &quot;Trying to compile and link a small program...&quot;;
+	print $msg, &quot; &quot; x ($nspaces - length($msg) + 8);
+	open( OUT, &quot;&gt;${tmp}.cpp&quot; ) or die &quot;Failed to open temp file ${tmp}.cpp: $!\n&quot;;
+	my $simple=q&quot;
+		#include &lt;QtGui/qapplication.h&gt;
+		int main( int argc, char **argv )
+		{
+			QApplication foo( argc, argv );
+			return 0;
+		}
+	&quot;;
+	print OUT $simple;
+	close OUT;
+        my $out = `$ccmd 2&gt;&amp;1`;
+	if( !check_exit_status($?) )
+	{
+		die &lt;&lt;&quot;EOF&quot;;
+
+FAILED : check your configuration.
+Failed program was:
+$simple
+Compiled with:
+$ccmd
+Compiler output:
+$out
+EOF
+	}
+	else
+	{
+		print &quot;OK\n&quot;;
+	}
+}
+
+#--------------------------------------------------------------#
+
+sub perform_all_tests
+{
+	foreach ( sort { $tests{$a}-&gt;[2] &lt;=&gt; $tests{$b}-&gt;[2]} keys %tests)
+	{
+		$tests{$_}-&gt;[2] &lt; $threshold and next;
+		($qtdefs{$_} || $qtundefs{$_}) and do
+		{
+			print &quot;\rSkipping $_ (in qglobal.h)&quot;.( &quot; &quot; x (($nspaces-16) - length($_)) ).($qtundefs{$_}?&quot;*Undefined*&quot;:&quot; [Defined]&quot;).($opt_q?&quot;&quot;:&quot;\n&quot;);
+			next
+		};
+		print &quot;\rTesting $_&quot;.( &quot; &quot; x ($nspaces - length($_)) );
+		open( OUT, &quot;&gt;${tmp}.cpp&quot; ) or die &quot;Failed to open temp file ${tmp}.cpp: $!\n&quot;;
+		foreach $def(keys %qtdefs)
+		{
+			print OUT &quot;#define $def\n&quot;;
+		}
+		foreach $inc(split /,\s*/, $tests{$_}-&gt;[0])
+		{
+			print OUT &quot;#include &lt;$inc&gt;\n&quot;;
+		}
+		print OUT &quot;#include &lt;QtCore/qfeatures.h&gt;\n&quot;;
+		print OUT $tests{$_}-&gt;[3] if $tests{$_}-&gt;[3]; # need to define some classes ?
+		print OUT qq&quot;
+
+		int main( int argc, char ** argv)
+		{
+		$tests{$_}-&gt;[1]
+		return 0;
+		}
+
+		&quot;;
+		close OUT;
+
+                my $out = `$ccmd 2&gt;&amp;1`;
+		my $ok = check_exit_status($?);
+		if( !$ok )
+		{
+			$qtdefs{$_} = 1;
+		}
+		print +$opt_q ? ++$count.&quot;/$used&quot; : ( $ok ? &quot;*Undefined*\n&quot; : &quot; [Defined]\n&quot; );
+	}
+	$opt_q &amp;&amp; print &quot;\n&quot;;
+}
+
+#--------------------------------------------------------------#
+
+sub check_exit_status
+{
+	my $a = 0xFFFF &amp; shift;
+	if( !$a )
+	{
+		return 1;
+	}
+	elsif( $a == 0xFF00 )
+	{
+		die &quot;\nSystem call failed: $!\n&quot;;
+	}
+	elsif( $a &gt; 0x80 )
+	{
+		# non-zero status.
+	}
+	else
+	{
+		if( $a &amp; 0x80 )
+		{
+			die &quot;\n$cc coredumped with signal &quot;. ($a &amp; ~0x80);
+		}
+		die &quot;\n$cc interrupted by signal $a\n&quot;;
+	}
+	return 0;
+}
+
+#--------------------------------------------------------------#
+
+END
+{
+	unlink $tmp if -e $tmp;
+	unlink &quot;${tmp}.cpp&quot; if -e &quot;${tmp}.cpp&quot;;
+}
+
+#--------------------------------------------------------------#
+
+BEGIN {
+
+# &quot;DEFINE&quot; =&gt; [&quot;header-1.h,... header-n.h&quot;, &quot;main() code&quot;, priority, &quot;Definitions (if needed)&quot;]
+
+our %tests = (
+	&quot;QT_NO_ACCESSIBILITY&quot; =&gt;        [&quot;QtGui/qaccessible.h&quot;, &quot;QAccessibleEvent event(QEvent::AccessibilityHelp, 0);&quot;, 15],
+	&quot;QT_NO_ACTION&quot; =&gt;		[&quot;QtGui/qaction.h&quot;, &quot;QAction foo( (QObject*)NULL );&quot;, 5],
+	#QT_NO_BIG_CODECS
+ 	&quot;QT_NO_BUTTONGROUP&quot; =&gt;		[&quot;QtGui/qbuttongroup.h&quot;, &quot;QButtonGroup foo( (QObject*)NULL );&quot;, 12],
+ 	&quot;QT_NO_CHECKBOX&quot; =&gt;		[&quot;QtGui/qcheckbox.h&quot;, &quot;QCheckBox foo( (QWidget*)NULL );&quot;, 10],
+	&quot;QT_NO_CLIPBOARD&quot; =&gt; 		[&quot;QtGui/qapplication.h, QtGui/qclipboard.h&quot;, q&quot;
+						QApplication foo( argc, argv );
+						QClipboard *baz= foo.clipboard();
+					&quot;, 5],
+ 	&quot;QT_NO_COLORDIALOG&quot; =&gt;		[&quot;QtGui/qcolordialog.h&quot;, &quot;QColorDialog::customCount();&quot;, 12],
+	#QT_NO_COLORNAMES
+ 	&quot;QT_NO_COMBOBOX&quot; =&gt;		[&quot;QtGui/qcombobox.h&quot;, &quot;QComboBox foo( (QWidget*)NULL );&quot;, 10],
+	&quot;QT_NO_COMPAT&quot; =&gt;		[&quot;QtGui/qfontmetrics.h&quot;, q&quot;
+						QFontMetrics *foo= new QFontMetrics( QFont() );
+						int bar = foo-&gt;width( 'c' );
+					&quot;, 0],
+	&quot;QT_NO_COMPONENT&quot; =&gt;		[&quot;QtGui/qapplication.h&quot;, q&quot;
+ 						QApplication foo( argc, argv );
+ 						foo.addLibraryPath( QString::null );
+					&quot;, 5],
+	#QT_NO_COP
+ 	&quot;QT_NO_CURSOR&quot; =&gt;		[&quot;QtGui/qcursor.h&quot;, &quot;QCursor foo;&quot;, 5],
+ 	&quot;QT_NO_DATASTREAM&quot; =&gt;		[&quot;QtCore/qdatastream.h&quot;, &quot;QDataStream foo;&quot;, 5],
+ 	&quot;QT_NO_DATETIMEEDIT&quot; =&gt;		[&quot;QtGui/qdatetimeedit.h&quot;, &quot;QTimeEdit foo;&quot;, 12],
+	&quot;QT_NO_DIAL&quot; =&gt;			[&quot;QtGui/qdial.h&quot;, &quot;QDial foo;&quot;, 10],
+	&quot;QT_NO_DIALOG&quot; =&gt;		[&quot;QtGui/qdialog.h&quot;, &quot;QDialog foo;&quot;, 12],
+	&quot;QT_NO_DIR&quot; =&gt;			[&quot;QtCore/qdir.h&quot;, &quot;QDir foo;&quot;, 5],
+	#QT_NO_DIRECTPAINTER
+	&quot;QT_NO_DOM&quot; =&gt;			[&quot;QtXml/qdom.h&quot;, &quot;QDomDocumentType foo;&quot;, 5],
+	&quot;QT_NO_DRAGANDDROP&quot; =&gt;		[&quot;QtGui/qevent.h&quot;, &quot;QDropEvent foo( QDropEvent() );&quot;, 5],
+	&quot;QT_NO_DRAWUTIL&quot; =&gt;		[&quot;QtGui/qdrawutil.h, QtGui/qcolor.h&quot;, &quot;qDrawPlainRect( (QPainter *) NULL, 0, 0, 0, 0, QColor() );&quot;, 10],
+	#QT_NO_EFFECTS
+	&quot;QT_NO_ERRORMESSAGE&quot; =&gt; 	[&quot;QtGui/qerrormessage.h&quot;, &quot;QErrorMessage foo( (QWidget*) NULL );&quot;, 13],
+	&quot;QT_NO_FILEDIALOG&quot; =&gt;		[&quot;QtGui/qfiledialog.h&quot;, &quot;QFileDialog foo();&quot;, 13],
+
+	&quot;QT_NO_FONTDATABASE&quot; =&gt;		[&quot;QtGui/qfontdatabase.h&quot;, &quot;QFontDatabase foo;&quot;, 5],
+	&quot;QT_NO_FONTDIALOG&quot; =&gt; 		[&quot;QtGui/qfontdialog.h&quot;,   &quot;QFontDialog::getFont( (bool *)NULL );&quot;, 12],
+	&quot;QT_NO_FRAME&quot; =&gt; 		[&quot;QtGui/qframe.h&quot;, &quot;QFrame foo;&quot;, 10],
+	#QT_NO_FREETYPE
+ 	&quot;QT_NO_FTP&quot; =&gt;	[&quot;QtNetwork/qftp.h&quot;, &quot;QFtp foo;&quot;, 9],
+	&quot;QT_NO_GROUPBOX&quot; =&gt;		[&quot;QtGui/qgroupbox.h&quot;, &quot;QGroupBox foo;&quot;, 12],
+	#QT_NO_IMAGEFORMAT_BMP
+	#QT_NO_IMAGEFORMAT_JPEG
+	#QT_NO_IMAGEFORMATPLUGIN
+	#QT_NO_IMAGEFORMAT_PNG
+	#QT_NO_IMAGEFORMAT_PPM
+	#QT_NO_IMAGEFORMAT_XBM
+ 	&quot;QT_NO_IMAGE_HEURISTIC_MASK&quot; =&gt;	[&quot;QtGui/qimage.h&quot;, q&quot;
+						QImage *foo = new QImage;
+						foo-&gt;createHeuristicMask();
+					&quot;, 8],
+	#QT_NO_IMAGE_TEXT
+	&quot;QT_NO_IMAGEIO&quot; =&gt; 		[&quot;QtGui/qbitmap.h, QtCore/qstring.h&quot;, q&quot;
+						QBitmap foo( QString::fromLatin1('foobar') );
+					&quot;, 5],
+	&quot;QT_NO_LABEL&quot; =&gt;		[&quot;QtGui/qlabel.h&quot;, &quot;QLabel foo( (QWidget*) NULL );&quot;, 10],
+	&quot;QT_NO_LAYOUT&quot; =&gt;		[&quot;QtGui/qlayout.h&quot;, &quot;QFoo foo;&quot;, 10, q&quot;
+ 						class QFoo: public QLayout
+ 						{
+ 						public:
+ 						    QFoo() {};
+ 						    ~QFoo() {};
+ 						    void addItem( QLayoutItem * ) { };
+						    QSize sizeHint() const { return QSize(); }
+						    void setGeometry( const QRect &amp; ) { };
+                            QLayoutItem* itemAt(int) const {return (QLayoutItem*) NULL;}
+                            QLayoutItem* takeAt(int) {return (QLayoutItem*) NULL;}
+                            int QFoo::count() const {return 0;}
+
+ 						};
+ 					&quot;],
+	&quot;QT_NO_LCDNUMBER&quot; =&gt;		[&quot;QtGui/qlcdnumber.h&quot;, &quot;QLCDNumber foo;&quot;, 12],
+	&quot;QT_NO_LINEEDIT&quot; =&gt;		[&quot;QtGui/qlineedit.h&quot;, &quot;QLineEdit foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_LISTVIEW&quot; =&gt;		[&quot;QtGui/qlistview.h&quot;, &quot;QListView foo;&quot;, 13],
+	&quot;QT_NO_MAINWINDOW&quot; =&gt;		[&quot;QtGui/qmainwindow.h&quot;, &quot;QMainWindow foo;&quot;, 13],
+	&quot;QT_NO_MATRIX&quot; =&gt;		[&quot;QtGui/qmatrix.h&quot;, &quot;QMatrix foo;&quot;, 0],
+	&quot;QT_NO_MENUBAR&quot; =&gt;		[&quot;QtGui/qmenubar.h&quot;, &quot;QMenuBar foo;&quot;, 13],
+	&quot;QT_NO_MESSAGEBOX&quot; =&gt;		[&quot;QtGui/qmessagebox.h&quot;, &quot;QMessageBox foo;&quot;, 13],
+	&quot;QT_NO_MOVIE&quot; =&gt;		[&quot;QtGui/qmovie.h&quot;, &quot;QMovie foo;&quot;, 5],
+	&quot;QT_NO_NETWORK&quot; =&gt;		[&quot;QtNetwork/qnetworkproxy.h&quot;, &quot;QNetworkProxy foo;&quot;, 5],
+	#QT_NO_NETWORKPROXY
+	&quot;QT_NO_PALETTE&quot; =&gt;		[&quot;QtGui/qpalette.h&quot;, &quot;QPalette foo;&quot;, 5],
+	&quot;QT_NO_PICTURE&quot; =&gt;		[&quot;QtGui/qpicture.h&quot;, &quot;QPicture foo;&quot;, 5],
+	&quot;QT_NO_PRINTER&quot; =&gt;		[&quot;QtGui/qprinter.h&quot;, &quot;QPrinter foo();&quot;, 5],
+	&quot;QT_NO_PRINTDIALOG&quot; =&gt;		[&quot;QtGui/qprintdialog.h&quot;, &quot;QPrintDialog foo( (QPrinter*) NULL );&quot;, 13],
+	&quot;QT_NO_PROCESS&quot; =&gt;		[&quot;QtCore/qprocess.h&quot;, &quot;QProcess foo;&quot;, 5],
+	&quot;QT_NO_PROGRESSBAR&quot; =&gt;		[&quot;QtGui/qprogressbar.h&quot;, &quot;QProgressBar foo;&quot;, 12],
+	&quot;QT_NO_PROGRESSDIALOG&quot; =&gt;	[&quot;QtGui/qprogressdialog.h&quot;, &quot;QProgressDialog foo;&quot;, 13],
+	&quot;QT_NO_PROPERTIES&quot; =&gt;		[&quot;QtCore/qmetaobject.h&quot;, &quot;QMetaProperty foo;&quot;, 0],
+	&quot;QT_NO_PUSHBUTTON&quot; =&gt;		[&quot;QtGui/qpushbutton.h&quot;, &quot;QPushButton foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_QUUID_STRING&quot; =&gt;		[&quot;QtCore/quuid.h&quot;, &quot;QUuid foo( QString() );&quot;, 8],
+	&quot;QT_NO_RADIOBUTTON&quot; =&gt;		[&quot;QtGui/qradiobutton.h&quot;, &quot;QRadioButton foo( (QWidget *) NULL );&quot;, 12],
+	#QT_NO_QWS_ALPHA_CURSOR
+	#QT_NO_QWS_DECORATION_DEFAULT
+	#QT_NO_QWS_INPUTMETHODS
+	#QT_NO_QWS_KEYBOARD
+	#QT_NO_QWS_MOUSE
+	#QT_NO_QWS_MOUSE_AUTO
+	#QT_NO_QWS_MOUSE_MANUAL
+	#QT_NO_QWS_MULTIPROCESS
+	#QT_NO_QWS_PROPERTIES
+	#QT_NO_QWS_QPF
+	#QT_NO_RESIZEHANDLER
+	#QT_NO_RUBBERBAND
+	&quot;QT_NO_SCROLLBAR&quot; =&gt;		[&quot;QtGui/qscrollbar.h&quot;, &quot;QScrollBar foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_SESSIONMANAGER&quot; =&gt;	[&quot;QtGui/qapplication.h&quot;, q&quot;
+  						QApplication foo( argc, argv );
+  						foo.sessionId();
+					&quot;, 15],
+	&quot;QT_NO_SETTINGS&quot; =&gt;		[&quot;QtCore/qsettings.h&quot;, &quot;QSettings foo;&quot;, 5],
+	#QT_NO_SHORTCUT
+	&quot;QT_NO_SIGNALMAPPER&quot; =&gt;		[&quot;QtCore/qsignalmapper.h&quot;, &quot;QSignalMapper foo( (QObject *) NULL );&quot;, 0],
+	&quot;QT_NO_SIZEGRIP&quot; =&gt;		[&quot;QtGui/qsizegrip.h&quot;, &quot;QSizeGrip foo( (QWidget *) NULL );&quot;, 10],
+	&quot;QT_NO_SLIDER&quot; =&gt;		[&quot;QtGui/qslider.h&quot;, &quot;QSlider foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_SOUND&quot; =&gt;		[&quot;QtGui/qsound.h&quot;, &quot;QSound foo( QString::null );&quot;, 5],
+	#QT_NO_SPINWIDGET
+	#QT_NO_SPLASHSCREEN
+	#QT_NO_STACKEDWIDGET
+	#QT_NO_STATUSBAR
+	#QT_NO_STATUSTIP
+	#QT_NO_STL
+	&quot;QT_NO_STRINGLIST&quot; =&gt;		[&quot;qstringlist.h&quot;, &quot;QStringList foo;&quot;, 0],
+	&quot;QT_NO_STYLE_PLASTIQUE&quot; =&gt;		[&quot;QtGui/qplastiquestyle.h&quot;, &quot;QPlastiqueStyle foo;&quot;, 16],
+ 	&quot;QT_NO_STYLE_WINDOWSXP&quot; =&gt;	[&quot;QtGui/qwindowsxpstyle.h&quot;, &quot;QWindowsXPStyle foo;&quot;, 16],
+ 	&quot;QT_NO_STYLE_WINDOWS&quot; =&gt;	[&quot;QtGui/qwindowsstyle.h&quot;, &quot;QWindowsStyle foo;&quot;, 16],
+	&quot;QT_NO_STYLE_MAC&quot; =&gt;	[&quot;QtGui/macstyle.h&quot;, &quot;QMacStyle foo;&quot;, 16],
+	&quot;QT_NO_STYLE_CLEANLOOKS&quot; =&gt;	[&quot;QtGui/qcleanlooksstyle.h&quot;, &quot;QCleanlooksStyle foo;&quot;, 16],
+    &quot;QT_NO_TABBAR&quot; =&gt;               [&quot;QtGui/qtabbar.h&quot;, &quot;QTabBar foo;&quot;, 10],
+	&quot;QT_NO_TABLEVIEW&quot; =&gt;		[&quot;QtGui/qtableview.h&quot;, &quot;QTableView foo;&quot;, 16],
+    &quot;QT_NO_TABWIDGET&quot; =&gt;            [&quot;QtGui/qtabwidget.h&quot;, &quot;QTabWidget foo;&quot;, 10],
+    &quot;QT_NO_TEXTBROWSER&quot; =&gt;          [&quot;QtGui/qtextbrowser.h&quot;, &quot;QTextBrowser foo;&quot;, 14],
+    &quot;QT_NO_TEXTCODEC&quot; =&gt;            [&quot;QtCore/qtextcodec.h&quot;, &quot;QTextCodec::codecForMib(1);&quot;, 5],
+    &quot;QT_NO_TEXTCODECPLUGIN&quot; =&gt;      [&quot;QtCore/qtextcodecplugin.h, QtCore/qstringlist.h, QtCore/qlist.h, QtCore/qtextcodec.h&quot;, &quot;QFoo foo;&quot;, 6, q&quot;
+						class QFoo: public QTextCodecPlugin
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            QList&lt;QByteArray&gt; names() const {return QList&lt;QByteArray&gt;();}
+                            QList&lt;int&gt;mibEnums() const {return QList&lt;int&gt;();}
+                            QTextCodec *createForName( const QByteArray &amp; name ) {return (QTextCodec *)NULL;}
+                            QTextCodec *createForMib( int mib ) {return (QTextCodec *)NULL;}
+                            QList&lt;QByteArray&gt; aliases() const {return QList&lt;QByteArray&gt;();}
+						};
+						Q_EXPORT_PLUGIN2( 'Foo', QFoo )
+					&quot;],
+	#QT_NO_TEXTDATE
+ 	&quot;QT_NO_TEXTEDIT&quot; =&gt;		[&quot;QtGui/qtextedit.h&quot;, &quot;QTextEdit foo;&quot;, 13], 
+    &quot;QT_NO_TEXTSTREAM&quot; =&gt;           [&quot;qtextstream.h&quot;, &quot;QTextStream foo;&quot;, 5],
+    &quot;QT_NO_THREAD&quot; =&gt;           [&quot;QtCore/qthread.h&quot;, &quot;QFoo foo;&quot;, 5, q&quot;
+						class QFoo: public QThread
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            void run() {}
+						};
+					&quot;],
+    &quot;QT_NO_TOOLBAR&quot; =&gt;              [&quot;QtGui/qtoolbar.h&quot;, &quot;QToolBar foo;&quot;, 10],
+    &quot;QT_NO_TOOLBUTTON&quot; =&gt;           [&quot;QtGui/qtoolbutton.h&quot;, &quot;QToolButton foo((QWidget *) NULL );&quot;, 12],
+    &quot;QT_NO_TOOLTIP&quot; =&gt;              [&quot;QtGui/qtooltip.h&quot;, &quot;QToolTip::palette();&quot;, 10],
+	#QT_NO_TRANSLATION
+	#QT_NO_UDPSOCKET
+	#QT_NO_URLINFO
+	#QT_NO_VALIDATOR
+    &quot;QT_NO_VARIANT&quot; =&gt;              [&quot;QtCore/qvariant.h&quot;, &quot;QVariant foo;&quot;, 0],
+    &quot;QT_NO_WHATSTHIS&quot; =&gt;            [&quot;QtGui/qwhatsthis.h&quot;, &quot;QWhatsThis::inWhatsThisMode();&quot;, 10],
+	&quot;QT_NO_WHEELEVENT&quot; =&gt;		[&quot;QtGui/qevent.h&quot;, &quot;QWheelEvent foo( QPoint(1,1), 1, (Qt::MouseButtons)1, 0 );&quot;, 5],
+	&quot;QT_NO_XML&quot; =&gt;			[&quot;QtXml/qxml.h&quot;, &quot;QXmlNamespaceSupport foo;&quot;, 5],
+
+	);
+
+}

Added: trunk/smoke/web/qtguess.pl.in
===================================================================
--- trunk/smoke/web/qtguess.pl.in	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qtguess.pl.in	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,422 @@
+#!/usr/bin/perl
+
+# qtguess.pl : check how Qt was compiled. Issue a list of all defined QT_NO_* macros, one per line.
+#
+# author:  germain Garand &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">germain at ebooksfrance.com</A>&gt;
+# licence: GPL v.2
+
+# options: -q: be quieter
+#	   -o file: redirect output to &quot;file&quot;. (default: ./qtdefines)
+#	   -t [0..15]: set the testing threshold (see below)
+#	   -f &quot;flags&quot;: additional compiler flags/parameters
+
+use Getopt::Std;
+
+use vars qw/$opt_f $opt_o $opt_p/;
+
+getopts('qo:f:t:');
+
+# Threshold :
+#	 0 - test basic Qt types/classes
+#	 5 - test higher level, non-gui classes
+#	 8 - test options of the above (ex: QT_NO_IMAGE_SMOOTHSCALE)
+#	10 - test basic widgets
+#	12 - test composite widgets
+#	13 - test widgets inheriting composite widgets
+#	15 - test goodies (default)
+
+my $default_threshold = @qt_test_threshold@;
+my $cc = &quot;@CXX@&quot;;
+my $ccflags = $opt_f || &quot;@CXXFLAGS@&quot;;
+
+my $nspaces = 50;
+
+my %qtdefs=();
+my %qtundefs=();
+
+my $tmp = gettmpfile();
+my $qtinc = '@qt_includes@';
+my $allinc = '@all_includes@';
+my $alllib = '@all_libraries@';
+my $qtflags ='@LIB_QTCORE@ @LIB_QTGUI@ @LIB_QTNETWORK@ @LIB_QTXML@ @LIB_QTSQL@ @LIB_QTOPENGL@';
+my %x;
+$x{'LIBPNG'}  =   '@LIBPNG@';
+$x{'LIBJPEG'} =   '@LIBJPEG@';
+$x{'LIBSM'}   =   '@LIBSM@';
+$x{'LIBSOCKET'} = '@LIBSOCKET@';
+$x{'LIBDL'}      = '@LIBDL@';
+$x{'LIBRESOLV'}  = '@LIBRESOLV@';
+$x{'LIB_X11'} =   '@LIB_X11@';
+$x{'X_PRE_LIBS'} = '@X_PRE_LIBS@';
+$x{'LIB_X11'} =~ s/\$\((.*?)\)/$x{$1}/g;
+
+$qtflags =~ s/\$\((.*?)\)/$x{$1}/g;
+
+ -e &quot;$qtinc/QtCore/qglobal.h&quot; or die &quot;Invalid Qt include directory.\n&quot;;
+
+my $ccmd = &quot;$cc $ccflags $allinc $alllib -o $tmp $tmp.cpp $qtflags&quot;;
+
+my $threshold = defined($opt_t)?$opt_t : $default_threshold;
+$threshold &gt;= 0 or die &quot;invalid testing threshold: $threshold\n&quot;;
+
+print &quot;Checking how Qt was built... \n&quot;;
+print &quot;Threshold is set to $threshold\n&quot; unless $opt_q;
+
+my($count, $used, $total);
+map{ $tests{$_}-&gt;[2]&gt;=$threshold ? ($used++, $total++):$total++ } keys %tests;
+
+print &quot;Number of defines to be tested : $used/$total\n\n&quot; unless $opt_q;
+open( QTDEFS, &quot;&gt;&quot;.($opt_o || &quot;qtdefines&quot;) ) or die &quot;Can't open output file: $!\n&quot;;
+
+grab_qglobal_symbols();
+preliminary_test();
+perform_all_tests();
+
+print +scalar(keys %qtdefs) . &quot; defines found.\n&quot;;
+
+print QTDEFS join(&quot;\n&quot;, keys %qtdefs), &quot;\n&quot;;
+close;
+
+#--------------------------------------------------------------#
+
+sub gettmpfile
+{
+	my $tmpdir = $ENV{'TMP'} || &quot;.&quot;;
+	my $tmpname = $$.&quot;-qtguess&quot;;
+	while( -e &quot;$tmpdir/$tmpname&quot; || -e &quot;$tmpdir/${tmpname}.cpp&quot; )
+	{
+		$tmpname .= int (rand * 9);
+	}
+	return &quot;$tmpdir/$tmpname&quot;;
+}
+
+#--------------------------------------------------------------#
+
+sub grab_qglobal_symbols
+{
+	my $cmd = &quot;$cc -E -D__cplusplus -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2&gt;/dev/null&quot;;
+	my $symbols = `$cmd`;
+        for(0..1)
+        {
+	    if( check_exit_status($?) )
+	    {
+		while( $symbols =~/^#\s*define\s*(QT_\S+)/gm )
+		{
+			$qtdefs{$1} = 1;
+		}
+		print &quot;Found &quot;. scalar( keys %qtdefs ).&quot; predefined symbol&quot;.((scalar( keys %qtdefs ) -1)?&quot;s&quot;:&quot;&quot;).&quot; in qglobal.h\n&quot; unless ($opt_q or !(keys %qtdefs));
+		while( $symbols =~/^#\s*define\s*QT_MODULE_(\S+)/gm )
+		{
+			$qtundefs{&quot;QT_NO_$1&quot;} = 1;
+		}
+		print &quot;Found &quot;. scalar( keys %qtundefs ).&quot; undefined symbol&quot;.((scalar( keys %qtundefs ) -1)?&quot;s&quot;:&quot;&quot;).&quot; in qglobal.h\n&quot; unless ($opt_q or !(keys %qtundefs));
+                last;
+	    }
+	    elsif(! $_) # first try
+	    {
+		print  &quot;Failed to run $cmd.\nTrying without __cplusplus (might be already defined)\n&quot;;
+                $cmd = &quot;$cc -E -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2&gt;/dev/null&quot;;
+                $symbols = `$cmd`;
+                next;
+	    }
+        }
+}
+
+#--------------------------------------------------------------#
+
+sub preliminary_test
+{
+	my $msg = &quot;Trying to compile and link a small program...&quot;;
+	print $msg, &quot; &quot; x ($nspaces - length($msg) + 8);
+	open( OUT, &quot;&gt;${tmp}.cpp&quot; ) or die &quot;Failed to open temp file ${tmp}.cpp: $!\n&quot;;
+	my $simple=q&#163;
+		#include &lt;QtGui/qapplication.h&gt;
+		int main( int argc, char **argv )
+		{
+			QApplication foo( argc, argv );
+			return 0;
+		}
+	&#163;;
+	print OUT $simple;
+	close OUT;
+        my $out = `$ccmd 2&gt;&amp;1`;
+	if( !check_exit_status($?) )
+	{
+		die &lt;&lt;&quot;EOF&quot;;
+
+FAILED : check your configuration.
+Failed program was:
+$simple
+Compiled with:
+$ccmd
+Compiler output:
+$out
+EOF
+	}
+	else
+	{
+		print &quot;OK\n&quot;;
+	}
+}
+
+#--------------------------------------------------------------#
+
+sub perform_all_tests
+{
+	foreach ( sort { $tests{$a}-&gt;[2] &lt;=&gt; $tests{$b}-&gt;[2]} keys %tests)
+	{
+		$tests{$_}-&gt;[2] &lt; $threshold and next;
+		($qtdefs{$_} || $qtundefs{$_}) and do
+		{
+			print &quot;\rSkipping $_ (in qglobal.h)&quot;.( &quot; &quot; x (($nspaces-16) - length($_)) ).($qtundefs{$_}?&quot;*Undefined*&quot;:&quot; [Defined]&quot;).($opt_q?&quot;&quot;:&quot;\n&quot;);
+			next
+		};
+		print &quot;\rTesting $_&quot;.( &quot; &quot; x ($nspaces - length($_)) );
+		open( OUT, &quot;&gt;${tmp}.cpp&quot; ) or die &quot;Failed to open temp file ${tmp}.cpp: $!\n&quot;;
+		foreach $def(keys %qtdefs)
+		{
+			print OUT &quot;#define $def\n&quot;;
+		}
+		foreach $inc(split /,\s*/, $tests{$_}-&gt;[0])
+		{
+			print OUT &quot;#include &lt;$inc&gt;\n&quot;;
+		}
+		print OUT &quot;#include &lt;QtCore/qfeatures.h&gt;\n&quot;;
+		print OUT $tests{$_}-&gt;[3] if $tests{$_}-&gt;[3]; # need to define some classes ?
+		print OUT qq&#163;
+
+		int main( int argc, char ** argv)
+		{
+		$tests{$_}-&gt;[1]
+		return 0;
+		}
+
+		&#163;;
+		close OUT;
+
+                my $out = `$ccmd 2&gt;&amp;1`;
+		my $ok = check_exit_status($?);
+		if( !$ok )
+		{
+			$qtdefs{$_} = 1;
+		}
+		print +$opt_q ? ++$count.&quot;/$used&quot; : ( $ok ? &quot;*Undefined*\n&quot; : &quot; [Defined]\n&quot; );
+	}
+	$opt_q &amp;&amp; print &quot;\n&quot;;
+}
+
+#--------------------------------------------------------------#
+
+sub check_exit_status
+{
+	my $a = 0xFFFF &amp; shift;
+	if( !$a )
+	{
+		return 1;
+	}
+	elsif( $a == 0xFF00 )
+	{
+		die &quot;\nSystem call failed: $!\n&quot;;
+	}
+	elsif( $a &gt; 0x80 )
+	{
+		# non-zero status.
+	}
+	else
+	{
+		if( $a &amp; 0x80 )
+		{
+			die &quot;\n$cc coredumped with signal &quot;. ($a &amp; ~0x80);
+		}
+		die &quot;\n$cc interrupted by signal $a\n&quot;;
+	}
+	return 0;
+}
+
+#--------------------------------------------------------------#
+
+END
+{
+	unlink $tmp if -e $tmp;
+	unlink &quot;${tmp}.cpp&quot; if -e &quot;${tmp}.cpp&quot;;
+}
+
+#--------------------------------------------------------------#
+
+BEGIN {
+
+# &quot;DEFINE&quot; =&gt; [&quot;header-1.h,... header-n.h&quot;, &quot;main() code&quot;, priority, &quot;Definitions (if needed)&quot;]
+
+our %tests = (
+	&quot;QT_NO_ACCESSIBILITY&quot; =&gt;        [&quot;QtGui/qaccessible.h&quot;, &quot;QAccessibleEvent event(QEvent::AccessibilityHelp, 0);&quot;, 15],
+	&quot;QT_NO_ACTION&quot; =&gt;		[&quot;QtGui/qaction.h&quot;, &quot;QAction foo( (QObject*)NULL );&quot;, 5],
+	#QT_NO_BIG_CODECS
+ 	&quot;QT_NO_BUTTONGROUP&quot; =&gt;		[&quot;QtGui/qbuttongroup.h&quot;, &quot;QButtonGroup foo( (QObject*)NULL );&quot;, 12],
+ 	&quot;QT_NO_CHECKBOX&quot; =&gt;		[&quot;QtGui/qcheckbox.h&quot;, &quot;QCheckBox foo( (QWidget*)NULL );&quot;, 10],
+	&quot;QT_NO_CLIPBOARD&quot; =&gt; 		[&quot;QtGui/qapplication.h, QtGui/qclipboard.h&quot;, q&#163;
+						QApplication foo( argc, argv );
+						QClipboard *baz= foo.clipboard();
+					&#163;, 5],
+ 	&quot;QT_NO_COLORDIALOG&quot; =&gt;		[&quot;QtGui/qcolordialog.h&quot;, &quot;QColorDialog::customCount();&quot;, 12],
+	#QT_NO_COLORNAMES
+ 	&quot;QT_NO_COMBOBOX&quot; =&gt;		[&quot;QtGui/qcombobox.h&quot;, &quot;QComboBox foo( (QWidget*)NULL );&quot;, 10],
+	&quot;QT_NO_COMPAT&quot; =&gt;		[&quot;QtGui/qfontmetrics.h&quot;, q&#163;
+						QFontMetrics *foo= new QFontMetrics( QFont() );
+						int bar = foo-&gt;width( 'c' );
+					&#163;, 0],
+	&quot;QT_NO_COMPONENT&quot; =&gt;		[&quot;QtGui/qapplication.h&quot;, q&#163;
+ 						QApplication foo( argc, argv );
+ 						foo.addLibraryPath( QString::null );
+					&#163;, 5],
+	#QT_NO_COP
+ 	&quot;QT_NO_CURSOR&quot; =&gt;		[&quot;QtGui/qcursor.h&quot;, &quot;QCursor foo;&quot;, 5],
+ 	&quot;QT_NO_DATASTREAM&quot; =&gt;		[&quot;QtCore/qdatastream.h&quot;, &quot;QDataStream foo;&quot;, 5],
+ 	&quot;QT_NO_DATETIMEEDIT&quot; =&gt;		[&quot;QtGui/qdatetimeedit.h&quot;, &quot;QTimeEdit foo;&quot;, 12],
+	&quot;QT_NO_DIAL&quot; =&gt;			[&quot;QtGui/qdial.h&quot;, &quot;QDial foo;&quot;, 10],
+	&quot;QT_NO_DIALOG&quot; =&gt;		[&quot;QtGui/qdialog.h&quot;, &quot;QDialog foo;&quot;, 12],
+	&quot;QT_NO_DIR&quot; =&gt;			[&quot;QtCore/qdir.h&quot;, &quot;QDir foo;&quot;, 5],
+	#QT_NO_DIRECTPAINTER
+	&quot;QT_NO_DOM&quot; =&gt;			[&quot;QtXml/qdom.h&quot;, &quot;QDomDocumentType foo;&quot;, 5],
+	&quot;QT_NO_DRAGANDDROP&quot; =&gt;		[&quot;QtGui/qevent.h&quot;, &quot;QDropEvent foo( QDropEvent() );&quot;, 5],
+	&quot;QT_NO_DRAWUTIL&quot; =&gt;		[&quot;QtGui/qdrawutil.h, QtGui/qcolor.h&quot;, &quot;qDrawPlainRect( (QPainter *) NULL, 0, 0, 0, 0, QColor() );&quot;, 10],
+	#QT_NO_EFFECTS
+	&quot;QT_NO_ERRORMESSAGE&quot; =&gt; 	[&quot;QtGui/qerrormessage.h&quot;, &quot;QErrorMessage foo( (QWidget*) NULL );&quot;, 13],
+	&quot;QT_NO_FILEDIALOG&quot; =&gt;		[&quot;QtGui/qfiledialog.h&quot;, &quot;QFileDialog foo();&quot;, 13],
+
+	&quot;QT_NO_FONTDATABASE&quot; =&gt;		[&quot;QtGui/qfontdatabase.h&quot;, &quot;QFontDatabase foo;&quot;, 5],
+	&quot;QT_NO_FONTDIALOG&quot; =&gt; 		[&quot;QtGui/qfontdialog.h&quot;,   &quot;QFontDialog::getFont( (bool *)NULL );&quot;, 12],
+	&quot;QT_NO_FRAME&quot; =&gt; 		[&quot;QtGui/qframe.h&quot;, &quot;QFrame foo;&quot;, 10],
+	#QT_NO_FREETYPE
+ 	&quot;QT_NO_FTP&quot; =&gt;	[&quot;QtNetwork/qftp.h&quot;, &quot;QFtp foo;&quot;, 9],
+	&quot;QT_NO_GROUPBOX&quot; =&gt;		[&quot;QtGui/qgroupbox.h&quot;, &quot;QGroupBox foo;&quot;, 12],
+	#QT_NO_IMAGEFORMAT_BMP
+	#QT_NO_IMAGEFORMAT_JPEG
+	#QT_NO_IMAGEFORMATPLUGIN
+	#QT_NO_IMAGEFORMAT_PNG
+	#QT_NO_IMAGEFORMAT_PPM
+	#QT_NO_IMAGEFORMAT_XBM
+ 	&quot;QT_NO_IMAGE_HEURISTIC_MASK&quot; =&gt;	[&quot;QtGui/qimage.h&quot;, q&#163;
+						QImage *foo = new QImage;
+						foo-&gt;createHeuristicMask();
+					&#163;, 8],
+	#QT_NO_IMAGE_TEXT
+	&quot;QT_NO_IMAGEIO&quot; =&gt; 		[&quot;QtGui/qbitmap.h, QtCore/qstring.h&quot;, q&#163;
+						QBitmap foo( QString::fromLatin1(&quot;foobar&quot;) );
+					&#163;, 5],
+	&quot;QT_NO_LABEL&quot; =&gt;		[&quot;QtGui/qlabel.h&quot;, &quot;QLabel foo( (QWidget*) NULL );&quot;, 10],
+	&quot;QT_NO_LAYOUT&quot; =&gt;		[&quot;QtGui/qlayout.h&quot;, &quot;QFoo foo;&quot;, 10, q&#163;
+ 						class QFoo: public QLayout
+ 						{
+ 						public:
+ 						    QFoo() {};
+ 						    ~QFoo() {};
+ 						    void addItem( QLayoutItem * ) { };
+						    QSize sizeHint() const { return QSize(); }
+						    void setGeometry( const QRect &amp; ) { };
+                            QLayoutItem* itemAt(int) const {return (QLayoutItem*) NULL;}
+                            QLayoutItem* takeAt(int) {return (QLayoutItem*) NULL;}
+                            int QFoo::count() const {return 0;}
+
+ 						};
+ 					&#163;],
+	&quot;QT_NO_LCDNUMBER&quot; =&gt;		[&quot;QtGui/qlcdnumber.h&quot;, &quot;QLCDNumber foo;&quot;, 12],
+	&quot;QT_NO_LINEEDIT&quot; =&gt;		[&quot;QtGui/qlineedit.h&quot;, &quot;QLineEdit foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_LISTVIEW&quot; =&gt;		[&quot;QtGui/qlistview.h&quot;, &quot;QListView foo;&quot;, 13],
+	&quot;QT_NO_MAINWINDOW&quot; =&gt;		[&quot;QtGui/qmainwindow.h&quot;, &quot;QMainWindow foo;&quot;, 13],
+	&quot;QT_NO_MATRIX&quot; =&gt;		[&quot;QtGui/qmatrix.h&quot;, &quot;QMatrix foo;&quot;, 0],
+	&quot;QT_NO_MENUBAR&quot; =&gt;		[&quot;QtGui/qmenubar.h&quot;, &quot;QMenuBar foo;&quot;, 13],
+	&quot;QT_NO_MESSAGEBOX&quot; =&gt;		[&quot;QtGui/qmessagebox.h&quot;, &quot;QMessageBox foo;&quot;, 13],
+	&quot;QT_NO_MOVIE&quot; =&gt;		[&quot;QtGui/qmovie.h&quot;, &quot;QMovie foo;&quot;, 5],
+	&quot;QT_NO_NETWORK&quot; =&gt;		[&quot;QtNetwork/qnetworkproxy.h&quot;, &quot;QNetworkProxy foo;&quot;, 5],
+	#QT_NO_NETWORKPROXY
+	&quot;QT_NO_PALETTE&quot; =&gt;		[&quot;QtGui/qpalette.h&quot;, &quot;QPalette foo;&quot;, 5],
+	&quot;QT_NO_PICTURE&quot; =&gt;		[&quot;QtGui/qpicture.h&quot;, &quot;QPicture foo;&quot;, 5],
+	&quot;QT_NO_PRINTER&quot; =&gt;		[&quot;QtGui/qprinter.h&quot;, &quot;QPrinter foo();&quot;, 5],
+	&quot;QT_NO_PRINTDIALOG&quot; =&gt;		[&quot;QtGui/qprintdialog.h&quot;, &quot;QPrintDialog foo( (QPrinter*) NULL );&quot;, 13],
+	&quot;QT_NO_PROCESS&quot; =&gt;		[&quot;QtCore/qprocess.h&quot;, &quot;QProcess foo;&quot;, 5],
+	&quot;QT_NO_PROGRESSBAR&quot; =&gt;		[&quot;QtGui/qprogressbar.h&quot;, &quot;QProgressBar foo;&quot;, 12],
+	&quot;QT_NO_PROGRESSDIALOG&quot; =&gt;	[&quot;QtGui/qprogressdialog.h&quot;, &quot;QProgressDialog foo;&quot;, 13],
+	&quot;QT_NO_PROPERTIES&quot; =&gt;		[&quot;QtCore/qmetaobject.h&quot;, &quot;QMetaProperty foo;&quot;, 0],
+	&quot;QT_NO_PUSHBUTTON&quot; =&gt;		[&quot;QtGui/qpushbutton.h&quot;, &quot;QPushButton foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_QUUID_STRING&quot; =&gt;		[&quot;QtCore/quuid.h&quot;, &quot;QUuid foo( QString() );&quot;, 8],
+	&quot;QT_NO_RADIOBUTTON&quot; =&gt;		[&quot;QtGui/qradiobutton.h&quot;, &quot;QRadioButton foo( (QWidget *) NULL );&quot;, 12],
+	#QT_NO_QWS_ALPHA_CURSOR
+	#QT_NO_QWS_DECORATION_DEFAULT
+	#QT_NO_QWS_INPUTMETHODS
+	#QT_NO_QWS_KEYBOARD
+	#QT_NO_QWS_MOUSE
+	#QT_NO_QWS_MOUSE_AUTO
+	#QT_NO_QWS_MOUSE_MANUAL
+	#QT_NO_QWS_MULTIPROCESS
+	#QT_NO_QWS_PROPERTIES
+	#QT_NO_QWS_QPF
+	#QT_NO_RESIZEHANDLER
+	#QT_NO_RUBBERBAND
+	&quot;QT_NO_SCROLLBAR&quot; =&gt;		[&quot;QtGui/qscrollbar.h&quot;, &quot;QScrollBar foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_SESSIONMANAGER&quot; =&gt;	[&quot;QtGui/qapplication.h&quot;, q&#163;
+  						QApplication foo( argc, argv );
+  						foo.sessionId();
+					&#163;, 15],
+	&quot;QT_NO_SETTINGS&quot; =&gt;		[&quot;QtCore/qsettings.h&quot;, &quot;QSettings foo;&quot;, 5],
+	#QT_NO_SHORTCUT
+	&quot;QT_NO_SIGNALMAPPER&quot; =&gt;		[&quot;QtCore/qsignalmapper.h&quot;, &quot;QSignalMapper foo( (QObject *) NULL );&quot;, 0],
+	&quot;QT_NO_SIZEGRIP&quot; =&gt;		[&quot;QtGui/qsizegrip.h&quot;, &quot;QSizeGrip foo( (QWidget *) NULL );&quot;, 10],
+	&quot;QT_NO_SLIDER&quot; =&gt;		[&quot;QtGui/qslider.h&quot;, &quot;QSlider foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_SOUND&quot; =&gt;		[&quot;QtGui/qsound.h&quot;, &quot;QSound foo( QString::null );&quot;, 5],
+	#QT_NO_SPINWIDGET
+	#QT_NO_SPLASHSCREEN
+	#QT_NO_STACKEDWIDGET
+	#QT_NO_STATUSBAR
+	#QT_NO_STATUSTIP
+	#QT_NO_STL
+	&quot;QT_NO_STRINGLIST&quot; =&gt;		[&quot;qstringlist.h&quot;, &quot;QStringList foo;&quot;, 0],
+	&quot;QT_NO_STYLE_PLASTIQUE&quot; =&gt;		[&quot;QtGui/qplastiquestyle.h&quot;, &quot;QPlastiqueStyle foo;&quot;, 16],
+ 	&quot;QT_NO_STYLE_WINDOWSXP&quot; =&gt;	[&quot;QtGui/qwindowsxpstyle.h&quot;, &quot;QWindowsXPStyle foo;&quot;, 16],
+ 	&quot;QT_NO_STYLE_WINDOWS&quot; =&gt;	[&quot;QtGui/qwindowsstyle.h&quot;, &quot;QWindowsStyle foo;&quot;, 16],
+	&quot;QT_NO_STYLE_MAC&quot; =&gt;	[&quot;QtGui/macstyle.h&quot;, &quot;QMacStyle foo;&quot;, 16],
+	&quot;QT_NO_STYLE_CLEANLOOKS&quot; =&gt;	[&quot;QtGui/qcleanlooksstyle.h&quot;, &quot;QCleanlooksStyle foo;&quot;, 16],
+    &quot;QT_NO_TABBAR&quot; =&gt;               [&quot;QtGui/qtabbar.h&quot;, &quot;QTabBar foo;&quot;, 10],
+	&quot;QT_NO_TABLEVIEW&quot; =&gt;		[&quot;QtGui/qtableview.h&quot;, &quot;QTableView foo;&quot;, 16],
+    &quot;QT_NO_TABWIDGET&quot; =&gt;            [&quot;QtGui/qtabwidget.h&quot;, &quot;QTabWidget foo;&quot;, 10],
+    &quot;QT_NO_TEXTBROWSER&quot; =&gt;          [&quot;QtGui/qtextbrowser.h&quot;, &quot;QTextBrowser foo;&quot;, 14],
+    &quot;QT_NO_TEXTCODEC&quot; =&gt;            [&quot;QtCore/qtextcodec.h&quot;, &quot;QTextCodec::codecForMib(1);&quot;, 5],
+    &quot;QT_NO_TEXTCODECPLUGIN&quot; =&gt;      [&quot;QtCore/qtextcodecplugin.h, QtCore/qstringlist.h, QtCore/qlist.h, QtCore/qtextcodec.h&quot;, &quot;QFoo foo;&quot;, 6, q&#163; 
+						class QFoo: public QTextCodecPlugin
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            QList&lt;QByteArray&gt; names() const {return QList&lt;QByteArray&gt;();}
+                            QList&lt;int&gt;mibEnums() const {return QList&lt;int&gt;();}
+                            QTextCodec *createForName( const QByteArray &amp; name ) {return (QTextCodec *)NULL;}
+                            QTextCodec *createForMib( int mib ) {return (QTextCodec *)NULL;}
+                            QList&lt;QByteArray&gt; aliases() const {return QList&lt;QByteArray&gt;();}
+						};
+						Q_EXPORT_PLUGIN2( &quot;Foo&quot;, QFoo )
+					&#163;],
+	#QT_NO_TEXTDATE
+ 	&quot;QT_NO_TEXTEDIT&quot; =&gt;		[&quot;QtGui/qtextedit.h&quot;, &quot;QTextEdit foo;&quot;, 13], 
+    &quot;QT_NO_TEXTSTREAM&quot; =&gt;           [&quot;qtextstream.h&quot;, &quot;QTextStream foo;&quot;, 5],
+    &quot;QT_NO_THREAD&quot; =&gt;           [&quot;QtCore/qthread.h&quot;, &quot;QFoo foo;&quot;, 5, q&#163;
+						class QFoo: public QThread
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            void run() {}
+						};
+					&#163;],
+    &quot;QT_NO_TOOLBAR&quot; =&gt;              [&quot;QtGui/qtoolbar.h&quot;, &quot;QToolBar foo;&quot;, 10],
+    &quot;QT_NO_TOOLBUTTON&quot; =&gt;           [&quot;QtGui/qtoolbutton.h&quot;, &quot;QToolButton foo((QWidget *) NULL );&quot;, 12],
+    &quot;QT_NO_TOOLTIP&quot; =&gt;              [&quot;QtGui/qtooltip.h&quot;, &quot;QToolTip::palette();&quot;, 10],
+	#QT_NO_TRANSLATION
+	#QT_NO_UDPSOCKET
+	#QT_NO_URLINFO
+	#QT_NO_VALIDATOR
+    &quot;QT_NO_VARIANT&quot; =&gt;              [&quot;QtCore/qvariant.h&quot;, &quot;QVariant foo;&quot;, 0],
+    &quot;QT_NO_WHATSTHIS&quot; =&gt;            [&quot;QtGui/qwhatsthis.h&quot;, &quot;QWhatsThis::inWhatsThisMode();&quot;, 10],
+	&quot;QT_NO_WHEELEVENT&quot; =&gt;		[&quot;QtGui/qevent.h&quot;, &quot;QWheelEvent foo( QPoint(1,1), 1, (Qt::MouseButtons)1, 0 );&quot;, 5],
+	&quot;QT_NO_XML&quot; =&gt;			[&quot;QtXml/qxml.h&quot;, &quot;QXmlNamespaceSupport foo;&quot;, 5],
+	);
+
+}

Added: trunk/smoke/web/qwt_header_list
===================================================================
--- trunk/smoke/web/qwt_header_list	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/qwt_header_list	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,66 @@
+qwt_abstract_scale_draw.h
+qwt_abstract_scale.h
+qwt_abstract_slider.h
+qwt_analog_clock.h
+qwt_array.h
+qwt_arrow_button.h
+qwt_color_map.h
+qwt_compass.h
+qwt_compass_rose.h
+qwt_counter.h
+qwt_curve_fitter.h
+qwt_data.h
+qwt_dial.h
+qwt_dial_needle.h
+qwt_double_interval.h
+qwt_double_range.h
+qwt_double_rect.h
+qwt_dyngrid_layout.h
+qwt_event_pattern.h
+qwt_global.h
+qwt.h
+qwt_interval_data.h
+qwt_knob.h
+qwt_layout_metrics.h
+qwt_legend.h
+qwt_legend_item.h
+qwt_math.h
+qwt_paint_buffer.h
+qwt_painter.h
+qwt_panner.h
+qwt_picker.h
+qwt_picker_machine.h
+qwt_plot_canvas.h
+qwt_plot_curve.h
+qwt_plot_dict.h
+qwt_plot_grid.h
+qwt_plot.h
+qwt_plot_item.h
+qwt_plot_layout.h
+qwt_plot_magnifier.h
+qwt_plot_marker.h
+qwt_plot_panner.h
+qwt_plot_picker.h
+qwt_plot_printfilter.h
+qwt_plot_rasteritem.h
+qwt_plot_spectrogram.h
+qwt_plot_zoomer.h
+qwt_polygon.h
+qwt_raster_data.h
+qwt_rect.h
+qwt_round_scale_draw.h
+qwt_scale_div.h
+qwt_scale_draw.h
+qwt_scale_engine.h
+qwt_scale_map.h
+qwt_scale_widget.h
+qwt_slider.h
+qwt_spline.h
+qwt_symbol.h
+qwt_text_engine.h
+qwt_text.h
+qwt_text_label.h
+qwt_text_plugin.h
+qwt_thermo.h
+qwt_valuelist.h
+qwt_wheel.h

Added: trunk/smoke/web/smokeqt.pro
===================================================================
--- trunk/smoke/web/smokeqt.pro	2007-06-08 00:50:27 UTC (rev 344)
+++ trunk/smoke/web/smokeqt.pro	2007-06-08 13:50:59 UTC (rev 345)
@@ -0,0 +1,39 @@
+######################################################################
+# Automatically generated by qmake (2.00a) lun 17. abr 22:10:08 2006
+######################################################################
+
+QT += network xml sql opengl svg uitools
+TEMPLATE = lib
+TARGET += 
+DEPENDPATH += .
+INCLUDEPATH += .
+INCLUDEPATH += ..
+
+# Add a 'qdbus' option if building with QtDBus:
+CONFIG += uitools
+
+DEFINES += QT_NO_DEBUG_STREAM
+
+# Input
+HEADERS += qt_smoke.h
+SOURCES += smokedata.cpp \
+           x_1.cpp \
+           x_10.cpp \
+           x_11.cpp \
+           x_12.cpp \
+           x_13.cpp \
+           x_14.cpp \
+           x_15.cpp \
+           x_16.cpp \
+           x_17.cpp \
+           x_18.cpp \
+           x_19.cpp \
+           x_2.cpp \
+           x_20.cpp \
+           x_3.cpp \
+           x_4.cpp \
+           x_5.cpp \
+           x_6.cpp \
+           x_7.cpp \
+           x_8.cpp \
+           x_9.cpp


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000188.html">[Php-qt-svn] r344 - trunk
</A></li>
	<LI>Next message: <A HREF="000190.html">[Php-qt-svn] r346 - trunk/php_qt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#189">[ date ]</a>
              <a href="thread.html#189">[ thread ]</a>
              <a href="subject.html#189">[ subject ]</a>
              <a href="author.html#189">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/php-qt-svn">More information about the Php-qt-svn
mailing list</a><br>
</body></html>
