<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Php-qt-svn] r336 - trunk/php_qt
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/php-qt-svn/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r336%20-%20trunk/php_qt&In-Reply-To=%3C200706062119.l56LJv8U003373%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000179.html">
   <LINK REL="Next"  HREF="000181.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Php-qt-svn] r336 - trunk/php_qt</H1>
    <B>tm243 at BerliOS</B> 
    <A HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r336%20-%20trunk/php_qt&In-Reply-To=%3C200706062119.l56LJv8U003373%40sheep.berlios.de%3E"
       TITLE="[Php-qt-svn] r336 - trunk/php_qt">tm243 at mail.berlios.de
       </A><BR>
    <I>Wed Jun  6 23:19:57 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000179.html">[Php-qt-svn] r335 - trunk/php_qt
</A></li>
        <LI>Next message: <A HREF="000181.html">[Php-qt-svn] r337 - trunk/php_qt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#180">[ date ]</a>
              <a href="thread.html#180">[ thread ]</a>
              <a href="subject.html#180">[ subject ]</a>
              <a href="author.html#180">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tm243
Date: 2007-06-06 23:19:56 +0200 (Wed, 06 Jun 2007)
New Revision: 336

Added:
   trunk/php_qt/phpqt_internals.cpp
   trunk/php_qt/phpqt_internals.h
Modified:
   trunk/php_qt/CMakeLists.txt
   trunk/php_qt/functions.cpp
   trunk/php_qt/handlers.cpp
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/qstring.cpp
   trunk/php_qt/smokephp.cpp
Log:
* moved phpqt_*** functions into a separate file



Modified: trunk/php_qt/CMakeLists.txt
===================================================================
--- trunk/php_qt/CMakeLists.txt	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/CMakeLists.txt	2007-06-06 21:19:56 UTC (rev 336)
@@ -17,6 +17,7 @@
     functions.cpp
     php_qt.cpp
     zend_handlers.cpp
+    phpqt_internals.cpp
     smokephp.cpp
     qstring.cpp
     marshall_types.cpp

Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/functions.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -1,7 +1,7 @@
 /*!
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2006 
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;thomas.moenicke at kdemail.net&gt;
  * Katrina Niolet &lt;katrina at niolet.name&gt;
  *
@@ -22,6 +22,7 @@
  */
 
 #include &quot;php_qt.h&quot;
+#include &quot;phpqt_internals.h&quot;
 
 extern Smoke *qt_Smoke;
 extern Smoke::Index qstring;
@@ -130,7 +131,7 @@
 
     if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz|&quot;, &amp;obj, &amp;cast_type) == FAILURE) {
         php_error(E_WARNING,&quot;error while casting object, wrong parameters&quot;);
-        return; 
+        return;
     }
 
 	// just return the first argument
@@ -147,7 +148,7 @@
 PHP_FUNCTION(qDebug) {
 	const char* msg;
 	int msglen;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s&quot;,&amp;msg,&amp;msglen)==FAILURE) {
 		php_error(E_PARSE,&quot;wrong parameters for qDebug&quot;);
 		return;
@@ -162,7 +163,7 @@
 PHP_FUNCTION(qWarning) {
 	const char* msg;
 	int msglen;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s&quot;,&amp;msg,&amp;msglen)==FAILURE) {
 		php_error(E_PARSE,&quot;wrong parameters for qWarning&quot;);
 		return;
@@ -177,7 +178,7 @@
 PHP_FUNCTION(qCritical) {
 	const char* msg;
 	int msglen;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s&quot;,&amp;msg,&amp;msglen)==FAILURE) {
 		php_error(E_PARSE,&quot;wrong parameters for qCritical&quot;);
 		return;
@@ -191,21 +192,21 @@
  */
 PHP_FUNCTION(qAbs) {
 	double x;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;d&quot;,&amp;x)==FAILURE) {
 		php_error(E_PARSE,&quot;wrong parameters for qAbs&quot;);
 		return;
 	}
 	RETURN_DOUBLE(0.0 &gt;= x ? -x : x);
 }
-	
+
 /**
  * Returns this number rounded to the nearest integer
  * if decimal is greater than .5 it rounds up, otherwise it rounds down
  */
 PHP_FUNCTION(qRound) {
 	double x;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;d&quot;,&amp;x)==FAILURE) {
 		php_error(E_PARSE,&quot;wrong parameters for qRound&quot;);
 		return;
@@ -219,7 +220,7 @@
  */
 PHP_FUNCTION(qRound64) {
 	double x;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;d&quot;,&amp;x)==FAILURE) {
 		php_error(E_PARSE,&quot;wrong parameters for qRound&quot;);
 		return;
@@ -234,7 +235,7 @@
 PHP_FUNCTION(qMin) {
 	double x;
 	double y;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;dd&quot;,&amp;x,&amp;y)==FAILURE) {
 		php_error(E_PARSE,&quot;wrong paramters for qMin&quot;);
 		return;
@@ -251,7 +252,7 @@
 PHP_FUNCTION(qMax) {
 	double x;
 	double y;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;dd&quot;,&amp;x,&amp;y)==FAILURE) {
 		php_error(E_PARSE,&quot;wrong parameters for qMax&quot;);
 		return;
@@ -269,7 +270,7 @@
 	double min;
 	double val;
 	double max;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;ddd&quot;,&amp;min,&amp;val,&amp;max)==FAILURE) {
 		php_error(E_PARSE,&quot;wrong parameters for qBound&quot;);
 		return;
@@ -338,7 +339,7 @@
 	double x;
 	double y;
 	double ret;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;dd&quot;,&amp;x,&amp;y)==FAILURE) {
 		php_error(E_PARSE,&quot;wrong parameters for qFuzzyCompare&quot;);
 		return;
@@ -346,7 +347,7 @@
 	//Just so happens the Qt version does just what we need for this one
 	RETURN_BOOL(qFuzzyCompare(x,y));
 }
-		
+
 /**
  * Returns true if variable is NULL or a numeric 0
  * This varies slightly from the Qt implementation which tests
@@ -354,7 +355,7 @@
  */
 PHP_FUNCTION(qIsNull) {
 	zval *var;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;,&amp;var)==FAILURE) {
 		php_error(E_PARSE,&quot;wrong parameters for qIsNull&quot;);
 		return;
@@ -380,7 +381,7 @@
  */
 PHP_FUNCTION(qIntCast) {
 	zval *var;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;,&amp;var)==FAILURE)
 		return;
 	switch(Z_TYPE_P(var)) {
@@ -452,7 +453,7 @@
  */
 PHP_FUNCTION(qFree) {
 	zval* var;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;,&amp;var)==FAILURE)
 		return;
 	convert_to_null(var);
@@ -481,17 +482,17 @@
 PHP_FUNCTION(qMemCopy) {
 	zval* dest;
 	zval* src;
-	
+
 	long size;
 	int src_orig_type;
 	int dest_orig_type;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzl&quot;,&amp;dest,&amp;src,&amp;size)==FAILURE)
 		return;
 
 	src_orig_type = Z_TYPE_P(src);
 	dest_orig_type = Z_TYPE_P(dest);
-	
+
 	switch(Z_TYPE_P(src)) {
 		case IS_STRING:
 		case IS_LONG:
@@ -521,20 +522,20 @@
 PHP_FUNCTION(qt_noop) {}
 
 PHP_FUNCTION(qt_assert) {
-	
+
 	char* msg;
 	int msglen;
 	char* file;
 	int filelen;
 	int line;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s|sl&quot;,&amp;msg,&amp;msglen,&amp;file,&amp;filelen,&amp;line)==FAILURE)
 		return;
 	php_error(E_ERROR,msg);
 }
 
 PHP_FUNCTION(qt_assert_x) {
-	
+
 	char* msg;
 	int msglen;
 	char* file;
@@ -544,7 +545,7 @@
 	char* what;
 	int whatlen;
 	int line;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s|sssl&quot;,&amp;msg,&amp;msglen,&amp;where,&amp;wherelen,&amp;what,&amp;whatlen,&amp;file,&amp;filelen,&amp;line)==FAILURE)
 		return;
 	php_error(E_ERROR,msg);
@@ -552,9 +553,9 @@
 
 
 PHP_FUNCTION(Q_ASSERT) {
-	
+
 	bool cond;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;b&quot;,&amp;cond)==FAILURE)
 		return;
 	if(!cond)
@@ -562,13 +563,13 @@
 }
 
 PHP_FUNCTION(Q_ASSERT_X) {
-	
+
 	bool cond;
 	char* where=&quot;&quot;;
 	int wherelen;
 	char* what=&quot;&quot;;
 	int whatlen;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;b|ss&quot;,&amp;cond,&amp;where,&amp;wherelen,&amp;what,&amp;whatlen)==FAILURE) {
 		return;
 	}
@@ -581,13 +582,13 @@
 
 	char* file;
 	int line;
-	
+
 	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;|sl&quot;,&amp;file,&amp;line)==FAILURE)
 		return;
 	php_error(E_WARNING,&quot;Out of memory&quot;);
 }
-		
-	
+
+
 /*!
  *	tr() returns QObject::tr()
  *

Modified: trunk/php_qt/handlers.cpp
===================================================================
--- trunk/php_qt/handlers.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/handlers.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -14,6 +14,7 @@
 #include &quot;marshall.h&quot;
 #include &quot;php_qt.h&quot;
 #include &quot;smokephp.h&quot;
+#include &quot;phpqt_internals.h&quot;
 
 extern zend_class_entry* qstring_ce;
 
@@ -101,11 +102,11 @@
 		case Marshall::FromZVAL:
 			marshall_from_php&lt;T&gt;(m);
 		break;
- 
+
 		case Marshall::ToZVAL:
 			marshall_to_php&lt;T&gt;( m );
 		break;
-				
+
 		default:
 			m-&gt;unsupported();
 		break;
@@ -124,15 +125,15 @@
 		case Smoke::t_char:
 			marshall_it&lt;signed char&gt;(m);
 		break;
-		
+
 		case Smoke::t_uchar:
 			marshall_it&lt;unsigned char&gt;(m);
 		break;
- 
+
 		case Smoke::t_short:
 			marshall_it&lt;short&gt;(m);
 		break;
-      
+
 		case Smoke::t_ushort:
 			marshall_it&lt;unsigned short&gt;(m);
 		break;
@@ -140,11 +141,11 @@
 		case Smoke::t_int:
 			marshall_it&lt;int&gt;(m);
 		break;
-		
+
 		case Smoke::t_uint:
 			marshall_it&lt;unsigned int&gt;(m);
 		break;
- 
+
 		case Smoke::t_long:
 			marshall_it&lt;long&gt;(m);
 		break;
@@ -152,7 +153,7 @@
 		case Smoke::t_ulong:
 			marshall_it&lt;unsigned long&gt;(m);
 		break;
- 
+
 		case Smoke::t_float:
 			marshall_it&lt;float&gt;(m);
 		break;
@@ -164,14 +165,14 @@
 		case Smoke::t_enum:
 			marshall_it&lt;SmokeEnumWrapper&gt;(m);
 		break;
-     
+
 		case Smoke::t_class:
 			marshall_it&lt;SmokeClassWrapper&gt;(m);
 		break;
 
 		default:
 			m-&gt;unsupported();
-		break;	
+		break;
 	}
 
 }
@@ -197,7 +198,7 @@
 static const char * KCODE = 0;
 static QTextCodec *codec = 0;
 
-void 
+void
 init_codec() {
 
 	KCODE = INI_ORIG_STR(&quot;qt.codec&quot;);
@@ -213,7 +214,7 @@
 }
 
 
-QString* 
+QString*
 qstringFromZString(zval* zstring) {
 	if (KCODE == 0) {
 		init_codec();
@@ -230,7 +231,7 @@
 	return new QString(QString::fromLocal8Bit(zstring-&gt;value.str.val, zstring-&gt;value.str.len));
 }
 
-zval* 
+zval*
 zstringFromQString(QString * s) {
 
 	if (KCODE == 0) {
@@ -292,7 +293,7 @@
 			phpqt_createObject(m-&gt;var(), (void*) s, qstring_ce, -1);
 		}
 		break;
- 
+
 		default:
 			m-&gt;unsupported();
 		break;
@@ -337,7 +338,7 @@
 	if(h == 0 &amp;&amp; type.isConst() &amp;&amp; strlen(type.name()) &gt; strlen(&quot;const &quot;)) {
 			h = type_handlers[type.name() + strlen(&quot;const &quot;)];
 	}
-	
+
 	if(h != 0) {
 		return h-&gt;fn;
 	}

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/marshall_types.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -17,6 +17,7 @@
  ***************************************************************************/
 
 #include &quot;marshall_types.h&quot;
+#include &quot;phpqt_internals.h&quot;
 
 void
 smokeStackToQtStack(Smoke::Stack stack, void ** o, int items, MocArgument* args)

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/php_qt.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -33,6 +33,7 @@
 #include &quot;smokephp.h&quot;
 #include &quot;smoke.h&quot;
 #include &quot;marshall_types.h&quot;
+#include &quot;phpqt_internals.h&quot;
 
 #define DEBUG 1
 #define MOC_DEBUG 0
@@ -120,8 +121,6 @@
 ZEND_GET_MODULE(php_qt)
 #endif
 
-QHash&lt;void*, smokephp_object*&gt; SmokeQtObjects;
-QHash&lt;zend_object_handle, smokephp_object*&gt; obj_x_smokephp;
 QStack&lt;QByteArray*&gt; methodNameStack;
 
 zend_class_entry* activeCe;
@@ -132,7 +131,7 @@
 Smoke::Index qbool;
 Smoke::Index qstring;
 Smoke::Index qobject;
-zend_class_entry* qobject_ce;
+extern zend_class_entry* qobject_ce;
 extern zend_class_entry* qstring_ce;
 extern void 	_register_QString();
 
@@ -461,405 +460,3 @@
 
 	DISPLAY_INI_ENTRIES();
 }
-
-/*!
- *	PHP-Qt internal functions
- */
-
-int
-phpqt_metacall(smokephp_object* so, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a)
-{
-	QMetaObject* d = so-&gt;meta;
-//	int offset = d-&gt;methodOffset();
-	int offset = d-&gt;methodCount();
-
-#if MOC_DEBUG
-	cout &lt;&lt; &quot;qt_metacall &quot; &lt;&lt; so-&gt;ce_ptr-&gt;name &lt;&lt; endl;
-#endif
-
-	// call the C++ one
-	if(_id &lt; offset){
-		// find parent
-		Smoke::Index parent = so-&gt;smoke-&gt;inheritanceList[so-&gt;smoke-&gt;classes[so-&gt;classId].parents];
-
-		// methodId
-		Smoke::Index nameId = so-&gt;smoke-&gt;idMethodName(&quot;qt_metacall$$?&quot;);
-		Smoke::Index method = so-&gt;smoke-&gt;findMethod(so-&gt;classId, nameId);
-
-		if(method &gt; 0){
-			Smoke::Method &amp;m = so-&gt;smoke-&gt;methods[so-&gt;smoke-&gt;methodMaps[method].method];
-			Smoke::ClassFn fn = so-&gt;smoke-&gt;classes[m.classId].classFn;
-			Smoke::StackItem i[4];
-			i[1].s_enum = _c;
-			i[2].s_int = _id;
-			i[3].s_voidp = (void*) args[3].s_voidp;
-			(*fn)(m.method, so-&gt;ptr, i);
-
-#if MOC_DEBUG
-			cout &lt;&lt; &quot;\tcall Qt method &quot; &lt;&lt; so-&gt;ce_ptr-&gt;name &lt;&lt; &quot;::&quot; &lt;&lt; PQ::smoke()-&gt;methodNames[method] &lt;&lt; endl;
-#endif
-
-			if((int)i[0].s_int &lt; 0)
-				return i[0].s_int;
-
-		} else {
-			// should never happen
-			php_error(E_ERROR, &quot;Cannot find %s::qt_metacall() method\n&quot;, d-&gt;className());
-		}
-
-	}
-
-    if (_c != QMetaObject::InvokeMetaMethod) {
-		return _id;
-	}
-
-	// try the PHP one
-	// eg _q_buttonPressed(), breaking at the first bracket
-	char* method_name = estrdup((d-&gt;method(_id)).signature());
-
-    for(int i = 0; i &lt; strlen(method_name); i++){
-#define LEFT_PARENTHESIS 40
-        if(method_name[i] == LEFT_PARENTHESIS){
-            method_name[i] = 0;
-            break;
-        }
-    }
-
-    // is a Slot
-    if(d-&gt;method(_id).methodType() == QMetaMethod::Slot){
-
-        int j = 0;
-        zval*** args = (zval***) safe_emalloc(2, sizeof(zval*), 0);
-        QList&lt;QByteArray&gt; qargs = d-&gt;method(_id).parameterTypes();
-        for(int i = 0; i &lt; qargs.count(); i++){
-            zval *arg;
-            MAKE_STD_ZVAL(arg);
-
-            // invoke to zend types
-            if(!strncmp(&quot;int&quot;,(const char*) qargs[i],3)){
-
-                ZVAL_LONG(arg, *reinterpret_cast&lt; int*&gt;(_a[i+1]));
-            } else if(!strncmp(&quot;char*&quot;,(const char*) qargs[i],5)){
-                ZVAL_STRING(arg, *reinterpret_cast&lt; char**&gt;(_a[i+1]), 1);
-            } else if(!strncmp(&quot;bool&quot;,(const char*) qargs[i],4)){
-                ZVAL_BOOL(arg, *reinterpret_cast&lt; bool*&gt;(_a[i+1]));
-            } else if(!strncmp(&quot;double&quot;,(const char*) qargs[i],4)){
-                ZVAL_DOUBLE(arg, *reinterpret_cast&lt; double*&gt;(_a[i+1]));
-            } else {
-                    // must be an object
-                    void* ptr = *reinterpret_cast&lt; QObject**&gt;(_a[1]);
-
-                    phpqt_createObject(arg, ptr, qobject_ce);
-            }
-
-            args[j++] = &arg;
-
-        }
-
-#if MOC_DEBUG
-    cout &lt;&lt; &quot;\tcall PHP method &quot; &lt;&lt; so-&gt;ce_ptr-&gt;name &lt;&lt; &quot;::&quot; &lt;&lt; method_name &lt;&lt; endl;
-#endif
-
-         phpqt_callPHPMethod(so-&gt;zval_ptr, method_name, j, *args);
-
-    // is a signal
-    } else {
-        void *_b[] = { 0, _a[1] };
-        QMetaObject::activate((QObject*) so-&gt;ptr, d, 0, _b);
-    }
-
-	efree(method_name);
-    return _id;
-
-}
-
-static void
-phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc TSRMLS_DC)
-{
-#ifdef DEBUG
-	php_error(E_ERROR,&quot;Hashtable destroyed. Shutdown PHP-Qt now.&quot;);
-#endif
-}
-
-bool
-phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname)
-{
-
-	if(ce_ptr == NULL){
-	  php_error(E_ERROR,&quot;methodExists fatal error: no class entry&quot;);
-	}
-
-	char* lcname = zend_str_tolower_dup(methodname, strlen(methodname));
-
-	if(zend_hash_exists(&amp;ce_ptr-&gt;function_table, lcname, strlen(methodname)+1)){
-		return true;
-	}
-
-	efree(lcname);
-	return false;
-
-}
-
-
-zval*
-phpqt_callPHPMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args)
-{
-
-	if(this_ptr == NULL){
-	  php_error(E_ERROR,&quot;callmethod fatal error: object does not exists&quot;);
-	}
-
-    zval *function_name;
-    MAKE_STD_ZVAL(function_name);
-    ZVAL_STRING(function_name,methodName,1);
-
-    zval* retval;
-    MAKE_STD_ZVAL(retval);
-
-    if(call_user_function(EG(function_table),&amp;this_ptr,function_name,retval,param_count,args) == FAILURE){
-    	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
-    	php_error(E_ERROR, &quot;PHP-Qt could not call method %s::%s&quot;, o-&gt;ce_ptr-&gt;name, methodName);
-    }
-
-    return retval;
-}
-
-/*!
- *	creates metaObject data
- *  example: &quot;QWidget\0\0value\0test(int)\0&quot;
- *	@param	zval*				this_ptr	pointer of the zval
- *	@param	char*				classname	name of the class
- *	@param	const QMetaObject*	superdata	superdata
- *	@return	QMetaObject*
- */
-
-bool
-phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* meta, QString* meta_stringdata, uint* signature){
-
-    /// readout the slots table
-    zval **slotdata;
-
-    zval *zslot;
-    zslot = zend_read_property(Z_OBJCE_P(this_ptr),this_ptr,&quot;slots&quot;,5,0);
-
-    zval *zsignal;
-    zsignal = zend_read_property(Z_OBJCE_P(this_ptr),this_ptr,&quot;signals&quot;,7,0);
-
-    if((zslot)-&gt;type==IS_ARRAY &amp;&amp; (zsignal)-&gt;type==IS_ARRAY ) {
-
-
-        HashTable* slots_hash = HASH_OF(zslot);
-        HashTable* signals_hash = HASH_OF(zsignal);
-
-        char* assocKey;
-        ulong numKey;
-
-        int signaturecount;
-        signaturecount = 2 + strlen(classname);
-
-#if MOC_DEBUG
-	QString *qr = new QString();
-	cout &lt;&lt; &quot;+== begin metaobject dump ==+\n&quot;;
-	cout &lt;&lt; &quot;\t&quot; &lt;&lt; classname &lt;&lt; &quot;\n\t1 0 0 0 &quot; &lt;&lt; zend_hash_num_elements(slots_hash)+zend_hash_num_elements(signals_hash) &lt;&lt; &quot; 10 0 0 0 0&quot; &lt;&lt; endl &lt;&lt; endl;
-#endif
-
-		/// write class signature
-		signature[0] = 1;
-		signature[1] = 0;
-		signature[2] = 0;
-		signature[3] = 0;
-		signature[4] = zend_hash_num_elements(slots_hash)+zend_hash_num_elements(signals_hash);
-		signature[5] = 10;
-		signature[6] = 0;
-		signature[7] = 0;
-		signature[8] = 0;
-		signature[9] = 0;
-
-		/// write classname
-		meta_stringdata-&gt;append(classname);
- 		meta_stringdata-&gt;append(QChar::Null);
- 		meta_stringdata-&gt;append(QChar::Null);
-
-		int i;
-		i = 10;
-
-		zend_hash_internal_pointer_reset(signals_hash);
-
-		while(zend_hash_has_more_elements(signals_hash) == SUCCESS){
-
-			/// read slot from hashtable
-			zend_hash_get_current_key(signals_hash,&amp;assocKey,&amp;numKey,0);
-			zend_hash_get_current_data(signals_hash,(void**)&amp;slotdata);
-
-#if MOC_DEBUG
-			qr-&gt;append(Z_STRVAL_PP(slotdata));
-			qr-&gt;append(&quot; &quot;);
-			cout &lt;&lt; &quot;\t&quot; &lt;&lt; signaturecount &lt;&lt; &quot;8 8 8 0x05 ::s&quot; &lt;&lt; endl;
-#endif
-
-			meta_stringdata-&gt;append(Z_STRVAL_PP(slotdata));
-			meta_stringdata-&gt;append(QChar::Null);
-
-			zend_hash_move_forward(signals_hash);
-
-			/// write slot signature
-			signature[i++] = signaturecount;
-			signature[i++] = 8;
-			signature[i++] = 8;
-			signature[i++] = 8;
-			signature[i++] = 0x05;
-
-			signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
-
-		}
-
-    	zend_hash_internal_pointer_reset(slots_hash);
-
-		while(zend_hash_has_more_elements(slots_hash) == SUCCESS){
-
-			/// read slot from hashtable
-			zend_hash_get_current_key(slots_hash,&amp;assocKey,&amp;numKey,0);
-			zend_hash_get_current_data(slots_hash,(void**)&amp;slotdata);
-
-#if MOC_DEBUG
-			qr-&gt;append(Z_STRVAL_PP(slotdata));
-			qr-&gt;append(&quot; &quot;);
-			cout &lt;&lt; &quot;\t&quot; &lt;&lt; signaturecount &lt;&lt; &quot;8 8 8 0x0a ::s&quot; &lt;&lt; endl;
-#endif
-
-			meta_stringdata-&gt;append(Z_STRVAL_PP(slotdata));
-			meta_stringdata-&gt;append(QChar::Null);
-
-			zend_hash_move_forward(slots_hash);
-
-			/// write slot signature
-			signature[i++] = signaturecount;
-			signature[i++] = 8;
-			signature[i++] = 8;
-			signature[i++] = 8;
-			signature[i++] = 0x0a;
-
-			signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
-
-		}
-#if MOC_DEBUG
-		cout &lt;&lt; qr-&gt;toAscii().constData() &lt;&lt; endl;
-		cout &lt;&lt; &quot;+== end metaobject dump ==+&quot; &lt;&lt; endl;
-#endif
-		return true;
-	} else {
-		return false;
-  	}
-}
-
-char*
-phpqt_checkForOperator(const char* fname){
-	return (char*) fname;
-}
-
-bool
-phpqt_SmokePHPObjectExists(zval* this_ptr)
-{
-	return obj_x_smokephp.contains(this_ptr-&gt;value.obj.handle);
-}
-
-smokephp_object*
-phpqt_getSmokePHPObjectFromZval(zval* this_ptr)
-{
-
-	if(this_ptr == NULL){
-	  php_error(E_ERROR,&quot;fatal: object does not exists and could not be fetched, %s&quot;,Z_OBJCE_P(this_ptr)-&gt;name);
-	}
-
-	// value.obj.handle
- 	return (smokephp_object*) obj_x_smokephp.value(this_ptr-&gt;value.obj.handle);
-
-}
-
-void*
-phpqt_getQtObjectFromZval(zval* this_ptr){
-	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
-	return o-&gt;ptr;
-}
-
-smokephp_object*
-phpqt_getSmokePHPObjectFromQt(void* QtPtr){
-	return (smokephp_object*) SmokeQtObjects.value(QtPtr);
-}
-
-void
-phpqt_setSmokePHPObject(smokephp_object* o){
-	SmokeQtObjects.insert(o-&gt;ptr, o);
-}
-
-bool
-phpqt_SmokePHPObjectExists(void* ptr){
-	return (SmokeQtObjects.find(ptr) != SmokeQtObjects.end());
-}
-
-bool
-phpqt_unmapSmokePHPObject(zval* o)
-{
-	return (bool) obj_x_smokephp.remove(o-&gt;value.obj.handle);
-}
-
-/**
- *	marshall_basetypes.h marshall_to_php&lt;SmokeClassWrapper&gt;(Marshall *m)
- */
-
-smokephp_object*
-phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce, Smoke::Index classId){
-
-	Q_ASSERT (zval_ptr);
-	Q_ASSERT (ptr);
-
- 	if(!ce) {
- 		qFatal(&quot;no class entry!&quot;);
- 	}
-
-	if(classId == QSTRING_CLASSID)
-	{
-		ce = qstring_ce;
-	} else if (classId == 0)
-	{
-		qDebug(&quot;\nno class id&quot;);
-		check_qobject(zval_ptr);
-		qFatal(&quot;php object creation failed&quot;);
-	}
-
-	Z_TYPE_P(zval_ptr) = IS_OBJECT;
-	object_init_ex(zval_ptr, ce);
-
-	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
-	o-&gt;allocated = true;
-	o-&gt;ptr = ptr;
-	o-&gt;zval_ptr = zval_ptr;
-	o-&gt;ce_ptr = ce;
-	o-&gt;parent_ce_ptr = ce;
- 	o-&gt;classId = classId;
-	o-&gt;smoke = PQ::smoke();
-
-	Z_OBJ_HT_P(zval_ptr) = &amp;php_qt_handler;
-	phpqt_setSmokePHPObject(o);
-	zval_add_ref(&amp;zval_ptr);
-
-	obj_x_smokephp.insert(zval_ptr-&gt;value.obj.handle, o);
-
-	return o;
-
-}
-
-smokephp_object*
-phpqt_createOriginal(zval* zval_ptr, void* ptr)
-{
-	smokephp_object* o = phpqt_getSmokePHPObjectFromQt(ptr);
-/* 		ZVAL_ZVAL(zval_ptr, o-&gt;zval_ptr, 1, 0);
-// 		zval_ptr-&gt;is_ref = 1;
-		Z_OBJ_HT_P(zval_ptr) = &amp;php_qt_handler;
-		zval_x_smokephp.insert(zval_ptr, o);*/
-	Z_OBJ_HT_P(zval_ptr) = &amp;php_qt_handler;
-	zval_ptr = o-&gt;zval_ptr;
-	zval_add_ref(&amp;zval_ptr);
-
-	return o;
-}

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/php_qt.h	2007-06-06 21:19:56 UTC (rev 336)
@@ -44,7 +44,7 @@
 
 #include &quot;smoke.h&quot;
 #include &quot;smokephp.h&quot;
-#include &lt;QtCore/QMetaMethod&gt;
+
 #include &lt;QtCore/QStack&gt;
 #include &lt;QtCore/QHash&gt;
 #include &lt;QtCore/QTextStream&gt;
@@ -144,28 +144,6 @@
     QMetaObject* meta;
 };
 
-
-static void 			phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc);
-
-// void 				phpqt_register(zval* this_ptr, zend_rsrc_list_entry le);
-zval* 				phpqt_callPHPMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params);
-bool 				phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname);
-bool 				phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* metachar, QString* meta_stringdata, uint* signature);
-int					phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
-char*				phpqt_checkForOperator(const char* fname);
-
-void* 				phpqt_getQtObjectFromZval(zval* this_ptr);
-smokephp_object* 	phpqt_getSmokePHPObjectFromZval(zval* this_ptr);
-smokephp_object*	phpqt_getSmokePHPObjectFromQt(void* QtPtr);
-void				phpqt_setSmokePHPObject(smokephp_object* o);
-bool 				phpqt_SmokePHPObjectExists(zval* this_ptr);
-bool				phpqt_SmokePHPObjectExists(void* ptr);
-
-bool				phpqt_unmapSmokePHPObject(zval* o);
-
-smokephp_object*	phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL, Smoke::Index classId = 0);
-smokephp_object*	phpqt_createOriginal(zval* zval_ptr, void* ptr);
-
 const char* 		printType(int type);
 
 

Added: trunk/php_qt/phpqt_internals.cpp
===================================================================
--- trunk/php_qt/phpqt_internals.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/phpqt_internals.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -0,0 +1,439 @@
+/*!
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006
+ * Thomas Moenicke &lt;thomas.moenicke at kdemail.net&gt;
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+
+#include &quot;phpqt_internals.h&quot;
+
+#include &lt;QtCore/QMetaMethod&gt;
+#include &lt;zend.h&gt;
+#include &quot;smoke.h&quot;
+#include &quot;php_qt.h&quot;
+
+extern zend_object_handlers php_qt_handler;
+extern zend_class_entry* qstring_ce;
+
+zend_class_entry* qobject_ce;
+QHash&lt;void*, smokephp_object*&gt; SmokeQtObjects;
+QHash&lt;zend_object_handle, smokephp_object*&gt; obj_x_smokephp;
+
+
+/*!
+ *	PHP-Qt internal functions
+ */
+
+int
+phpqt_metacall(smokephp_object* so, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a)
+{
+	QMetaObject* d = so-&gt;meta;
+//	int offset = d-&gt;methodOffset();
+	int offset = d-&gt;methodCount();
+
+#if MOC_DEBUG
+	cout &lt;&lt; &quot;qt_metacall &quot; &lt;&lt; so-&gt;ce_ptr-&gt;name &lt;&lt; endl;
+#endif
+
+	// call the C++ one
+	if(_id &lt; offset){
+		// find parent
+		Smoke::Index parent = so-&gt;smoke-&gt;inheritanceList[so-&gt;smoke-&gt;classes[so-&gt;classId].parents];
+
+		// methodId
+		Smoke::Index nameId = so-&gt;smoke-&gt;idMethodName(&quot;qt_metacall$$?&quot;);
+		Smoke::Index method = so-&gt;smoke-&gt;findMethod(so-&gt;classId, nameId);
+
+		if(method &gt; 0){
+			Smoke::Method &amp;m = so-&gt;smoke-&gt;methods[so-&gt;smoke-&gt;methodMaps[method].method];
+			Smoke::ClassFn fn = so-&gt;smoke-&gt;classes[m.classId].classFn;
+			Smoke::StackItem i[4];
+			i[1].s_enum = _c;
+			i[2].s_int = _id;
+			i[3].s_voidp = (void*) args[3].s_voidp;
+			(*fn)(m.method, so-&gt;ptr, i);
+
+#if MOC_DEBUG
+			cout &lt;&lt; &quot;\tcall Qt method &quot; &lt;&lt; so-&gt;ce_ptr-&gt;name &lt;&lt; &quot;::&quot; &lt;&lt; PQ::smoke()-&gt;methodNames[method] &lt;&lt; endl;
+#endif
+
+			if((int)i[0].s_int &lt; 0)
+				return i[0].s_int;
+
+		} else {
+			// should never happen
+			php_error(E_ERROR, &quot;Cannot find %s::qt_metacall() method\n&quot;, d-&gt;className());
+		}
+
+	}
+
+    if (_c != QMetaObject::InvokeMetaMethod) {
+		return _id;
+	}
+
+	// try the PHP one
+	// eg _q_buttonPressed(), breaking at the first bracket
+	char* method_name = estrdup((d-&gt;method(_id)).signature());
+
+    for(int i = 0; i &lt; strlen(method_name); i++){
+#define LEFT_PARENTHESIS 40
+        if(method_name[i] == LEFT_PARENTHESIS){
+            method_name[i] = 0;
+            break;
+        }
+    }
+
+    // is a Slot
+    if(d-&gt;method(_id).methodType() == QMetaMethod::Slot){
+
+        int j = 0;
+        zval*** args = (zval***) safe_emalloc(2, sizeof(zval*), 0);
+        QList&lt;QByteArray&gt; qargs = d-&gt;method(_id).parameterTypes();
+        for(int i = 0; i &lt; qargs.count(); i++){
+            zval *arg;
+            MAKE_STD_ZVAL(arg);
+
+            // invoke to zend types
+            if(!strncmp(&quot;int&quot;,(const char*) qargs[i],3)){
+
+                ZVAL_LONG(arg, *reinterpret_cast&lt; int*&gt;(_a[i+1]));
+            } else if(!strncmp(&quot;char*&quot;,(const char*) qargs[i],5)){
+                ZVAL_STRING(arg, *reinterpret_cast&lt; char**&gt;(_a[i+1]), 1);
+            } else if(!strncmp(&quot;bool&quot;,(const char*) qargs[i],4)){
+                ZVAL_BOOL(arg, *reinterpret_cast&lt; bool*&gt;(_a[i+1]));
+            } else if(!strncmp(&quot;double&quot;,(const char*) qargs[i],4)){
+                ZVAL_DOUBLE(arg, *reinterpret_cast&lt; double*&gt;(_a[i+1]));
+            } else {
+                    // must be an object
+                    void* ptr = *reinterpret_cast&lt; QObject**&gt;(_a[1]);
+
+                    phpqt_createObject(arg, ptr, qobject_ce);
+            }
+
+            args[j++] = &arg;
+
+        }
+
+#if MOC_DEBUG
+    cout &lt;&lt; &quot;\tcall PHP method &quot; &lt;&lt; so-&gt;ce_ptr-&gt;name &lt;&lt; &quot;::&quot; &lt;&lt; method_name &lt;&lt; endl;
+#endif
+
+         phpqt_callPHPMethod(so-&gt;zval_ptr, method_name, j, *args);
+
+    // is a signal
+    } else {
+        void *_b[] = { 0, _a[1] };
+        QMetaObject::activate((QObject*) so-&gt;ptr, d, 0, _b);
+    }
+
+	efree(method_name);
+    return _id;
+
+}
+
+void
+phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc TSRMLS_DC)
+{
+#ifdef DEBUG
+	php_error(E_ERROR,&quot;Hashtable destroyed. Shutdown PHP-Qt now.&quot;);
+#endif
+}
+
+bool
+phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname)
+{
+
+	if(ce_ptr == NULL){
+	  php_error(E_ERROR,&quot;methodExists fatal error: no class entry&quot;);
+	}
+
+	char* lcname = zend_str_tolower_dup(methodname, strlen(methodname));
+
+	if(zend_hash_exists(&amp;ce_ptr-&gt;function_table, lcname, strlen(methodname)+1)){
+		return true;
+	}
+
+	efree(lcname);
+	return false;
+
+}
+
+
+zval*
+phpqt_callPHPMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args)
+{
+
+	if(this_ptr == NULL){
+	  php_error(E_ERROR,&quot;callmethod fatal error: object does not exists&quot;);
+	}
+
+    zval *function_name;
+    MAKE_STD_ZVAL(function_name);
+    ZVAL_STRING(function_name,methodName,1);
+
+    zval* retval;
+    MAKE_STD_ZVAL(retval);
+
+    if(call_user_function(EG(function_table),&amp;this_ptr,function_name,retval,param_count,args) == FAILURE){
+    	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
+    	php_error(E_ERROR, &quot;PHP-Qt could not call method %s::%s&quot;, o-&gt;ce_ptr-&gt;name, methodName);
+    }
+
+    return retval;
+}
+
+/*!
+ *	creates metaObject data
+ *  example: &quot;QWidget\0\0value\0test(int)\0&quot;
+ *	@param	zval*				this_ptr	pointer of the zval
+ *	@param	char*				classname	name of the class
+ *	@param	const QMetaObject*	superdata	superdata
+ *	@return	QMetaObject*
+ */
+
+bool
+phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* meta, QString* meta_stringdata, uint* signature){
+
+    /// readout the slots table
+    zval **slotdata;
+
+    zval *zslot;
+    zslot = zend_read_property(Z_OBJCE_P(this_ptr),this_ptr,&quot;slots&quot;,5,0);
+
+    zval *zsignal;
+    zsignal = zend_read_property(Z_OBJCE_P(this_ptr),this_ptr,&quot;signals&quot;,7,0);
+
+    if((zslot)-&gt;type==IS_ARRAY &amp;&amp; (zsignal)-&gt;type==IS_ARRAY ) {
+
+
+        HashTable* slots_hash = HASH_OF(zslot);
+        HashTable* signals_hash = HASH_OF(zsignal);
+
+        char* assocKey;
+        ulong numKey;
+
+        int signaturecount;
+        signaturecount = 2 + strlen(classname);
+
+#if MOC_DEBUG
+	QString *qr = new QString();
+	cout &lt;&lt; &quot;+== begin metaobject dump ==+\n&quot;;
+	cout &lt;&lt; &quot;\t&quot; &lt;&lt; classname &lt;&lt; &quot;\n\t1 0 0 0 &quot; &lt;&lt; zend_hash_num_elements(slots_hash)+zend_hash_num_elements(signals_hash) &lt;&lt; &quot; 10 0 0 0 0&quot; &lt;&lt; endl &lt;&lt; endl;
+#endif
+
+		/// write class signature
+		signature[0] = 1;
+		signature[1] = 0;
+		signature[2] = 0;
+		signature[3] = 0;
+		signature[4] = zend_hash_num_elements(slots_hash)+zend_hash_num_elements(signals_hash);
+		signature[5] = 10;
+		signature[6] = 0;
+		signature[7] = 0;
+		signature[8] = 0;
+		signature[9] = 0;
+
+		/// write classname
+		meta_stringdata-&gt;append(classname);
+ 		meta_stringdata-&gt;append(QChar::Null);
+ 		meta_stringdata-&gt;append(QChar::Null);
+
+		int i;
+		i = 10;
+
+		zend_hash_internal_pointer_reset(signals_hash);
+
+		while(zend_hash_has_more_elements(signals_hash) == SUCCESS){
+
+			/// read slot from hashtable
+			zend_hash_get_current_key(signals_hash,&amp;assocKey,&amp;numKey,0);
+			zend_hash_get_current_data(signals_hash,(void**)&amp;slotdata);
+
+#if MOC_DEBUG
+			qr-&gt;append(Z_STRVAL_PP(slotdata));
+			qr-&gt;append(&quot; &quot;);
+			cout &lt;&lt; &quot;\t&quot; &lt;&lt; signaturecount &lt;&lt; &quot;8 8 8 0x05 ::s&quot; &lt;&lt; endl;
+#endif
+
+			meta_stringdata-&gt;append(Z_STRVAL_PP(slotdata));
+			meta_stringdata-&gt;append(QChar::Null);
+
+			zend_hash_move_forward(signals_hash);
+
+			/// write slot signature
+			signature[i++] = signaturecount;
+			signature[i++] = 8;
+			signature[i++] = 8;
+			signature[i++] = 8;
+			signature[i++] = 0x05;
+
+			signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
+
+		}
+
+    	zend_hash_internal_pointer_reset(slots_hash);
+
+		while(zend_hash_has_more_elements(slots_hash) == SUCCESS){
+
+			/// read slot from hashtable
+			zend_hash_get_current_key(slots_hash,&amp;assocKey,&amp;numKey,0);
+			zend_hash_get_current_data(slots_hash,(void**)&amp;slotdata);
+
+#if MOC_DEBUG
+			qr-&gt;append(Z_STRVAL_PP(slotdata));
+			qr-&gt;append(&quot; &quot;);
+			cout &lt;&lt; &quot;\t&quot; &lt;&lt; signaturecount &lt;&lt; &quot;8 8 8 0x0a ::s&quot; &lt;&lt; endl;
+#endif
+
+			meta_stringdata-&gt;append(Z_STRVAL_PP(slotdata));
+			meta_stringdata-&gt;append(QChar::Null);
+
+			zend_hash_move_forward(slots_hash);
+
+			/// write slot signature
+			signature[i++] = signaturecount;
+			signature[i++] = 8;
+			signature[i++] = 8;
+			signature[i++] = 8;
+			signature[i++] = 0x0a;
+
+			signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
+
+		}
+#if MOC_DEBUG
+		cout &lt;&lt; qr-&gt;toAscii().constData() &lt;&lt; endl;
+		cout &lt;&lt; &quot;+== end metaobject dump ==+&quot; &lt;&lt; endl;
+#endif
+		return true;
+	} else {
+		return false;
+  	}
+}
+
+char*
+phpqt_checkForOperator(const char* fname){
+	return (char*) fname;
+}
+
+bool
+phpqt_SmokePHPObjectExists(zval* this_ptr)
+{
+	return obj_x_smokephp.contains(this_ptr-&gt;value.obj.handle);
+}
+
+smokephp_object*
+phpqt_getSmokePHPObjectFromZval(zval* this_ptr)
+{
+
+	if(this_ptr == NULL){
+	  php_error(E_ERROR,&quot;fatal: object does not exists and could not be fetched, %s&quot;,Z_OBJCE_P(this_ptr)-&gt;name);
+	}
+
+	// value.obj.handle
+ 	return (smokephp_object*) obj_x_smokephp.value(this_ptr-&gt;value.obj.handle);
+
+}
+
+void*
+phpqt_getQtObjectFromZval(zval* this_ptr){
+	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
+	return o-&gt;ptr;
+}
+
+smokephp_object*
+phpqt_getSmokePHPObjectFromQt(void* QtPtr){
+	return (smokephp_object*) SmokeQtObjects.value(QtPtr);
+}
+
+void
+phpqt_setSmokePHPObject(smokephp_object* o){
+	SmokeQtObjects.insert(o-&gt;ptr, o);
+}
+
+bool
+phpqt_SmokePHPObjectExists(void* ptr){
+	return (SmokeQtObjects.find(ptr) != SmokeQtObjects.end());
+}
+
+bool
+phpqt_unmapSmokePHPObject(zval* o)
+{
+	return (bool) obj_x_smokephp.remove(o-&gt;value.obj.handle);
+}
+
+/**
+ *	marshall_basetypes.h marshall_to_php&lt;SmokeClassWrapper&gt;(Marshall *m)
+ */
+
+smokephp_object*
+phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce, Smoke::Index classId){
+
+	Q_ASSERT (zval_ptr);
+	Q_ASSERT (ptr);
+
+ 	if(!ce) {
+ 		qFatal(&quot;no class entry!&quot;);
+ 	}
+
+	if(classId == QSTRING_CLASSID)
+	{
+		ce = qstring_ce;
+	} else if (classId == 0)
+	{
+		qDebug(&quot;\nno class id&quot;);
+		check_qobject(zval_ptr);
+		qFatal(&quot;php object creation failed&quot;);
+	}
+
+	Z_TYPE_P(zval_ptr) = IS_OBJECT;
+	object_init_ex(zval_ptr, ce);
+
+	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
+	o-&gt;allocated = true;
+	o-&gt;ptr = ptr;
+	o-&gt;zval_ptr = zval_ptr;
+	o-&gt;ce_ptr = ce;
+	o-&gt;parent_ce_ptr = ce;
+ 	o-&gt;classId = classId;
+	o-&gt;smoke = PQ::smoke();
+
+	Z_OBJ_HT_P(zval_ptr) = &amp;php_qt_handler;
+	phpqt_setSmokePHPObject(o);
+	zval_add_ref(&amp;zval_ptr);
+
+	obj_x_smokephp.insert(zval_ptr-&gt;value.obj.handle, o);
+
+	return o;
+
+}
+
+smokephp_object*
+phpqt_createOriginal(zval* zval_ptr, void* ptr)
+{
+	smokephp_object* o = phpqt_getSmokePHPObjectFromQt(ptr);
+/* 		ZVAL_ZVAL(zval_ptr, o-&gt;zval_ptr, 1, 0);
+// 		zval_ptr-&gt;is_ref = 1;
+		Z_OBJ_HT_P(zval_ptr) = &amp;php_qt_handler;
+		zval_x_smokephp.insert(zval_ptr, o);*/
+	Z_OBJ_HT_P(zval_ptr) = &amp;php_qt_handler;
+	zval_ptr = o-&gt;zval_ptr;
+	zval_add_ref(&amp;zval_ptr);
+
+	return o;
+}
+

Added: trunk/php_qt/phpqt_internals.h
===================================================================
--- trunk/php_qt/phpqt_internals.h	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/phpqt_internals.h	2007-06-06 21:19:56 UTC (rev 336)
@@ -0,0 +1,51 @@
+/*!
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006
+ * Thomas Moenicke &lt;thomas.moenicke at kdemail.net&gt;
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+
+#ifndef PHPQT_INTERNALS_H
+#define PHPQT_INTERNALS_H
+
+class QMetaObject;
+class QString;
+
+#include &quot;php_qt.h&quot;
+
+void 				phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc);
+
+zval* 				phpqt_callPHPMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params);
+bool 				phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname);
+bool 				phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* metachar, QString* meta_stringdata, uint* signature);
+int					phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
+char*				phpqt_checkForOperator(const char* fname);
+
+void* 				phpqt_getQtObjectFromZval(zval* this_ptr);
+smokephp_object* 	phpqt_getSmokePHPObjectFromZval(zval* this_ptr);
+smokephp_object*	phpqt_getSmokePHPObjectFromQt(void* QtPtr);
+void				phpqt_setSmokePHPObject(smokephp_object* o);
+bool 				phpqt_SmokePHPObjectExists(zval* this_ptr);
+bool				phpqt_SmokePHPObjectExists(void* ptr);
+
+bool				phpqt_unmapSmokePHPObject(zval* o);
+
+smokephp_object*	phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL, Smoke::Index classId = 0);
+smokephp_object*	phpqt_createOriginal(zval* zval_ptr, void* ptr);
+
+#endif

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/qstring.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -30,7 +30,9 @@
 
 #include &lt;QtCore/QString&gt;
 #include &lt;zend_interfaces.h&gt;
+
 #include &quot;php_qt.h&quot;
+#include &quot;phpqt_internals.h&quot;
 
 zend_class_entry* qstring_ce;
 extern Smoke* qt_Smoke;
@@ -243,7 +245,7 @@
  *    class     QString */
 /*
  *    function  insert
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, insert){
 
@@ -260,7 +262,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString &amp; return_object = (QString &amp;) obj-&gt;insert((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &amp;return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -295,7 +297,7 @@
  *    class     QString */
 /*
  *    function  clear
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, clear){
 	if (ZEND_NUM_ARGS() == 0){
@@ -310,7 +312,7 @@
  *    class     QString */
 /*
  *    function  setUtf16
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, setUtf16){
 
@@ -324,7 +326,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString &amp; return_object = (QString &amp;) obj-&gt;setUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &amp;return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -336,7 +338,7 @@
  *    class     QString */
 /*
  *    function  prepend
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, prepend){
 
@@ -355,14 +357,14 @@
 			if(Z_TYPE_P(z_0) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString &amp; return_object = (QString &amp;) obj-&gt;prepend((char) Z_LVAL_P(z_0));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &amp;return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_STRING){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString &amp; return_object = (QString &amp;) obj-&gt;prepend( (const char*) Z_STRVAL_P(z_0));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &amp;return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -395,7 +397,7 @@
  *    class     QString */
 /*
  *    function  chop
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, chop){
 
@@ -446,7 +448,7 @@
  *    class     QString */
 /*
  *    function  squeeze
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, squeeze){
 	if (ZEND_NUM_ARGS() == 0){
@@ -579,7 +581,7 @@
  *    class     QString */
 /*
  *    function  QString
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, __construct){
 
@@ -717,7 +719,7 @@
  *    class     QString */
 /*
  *    function  setNum
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, setNum){
 
@@ -731,7 +733,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString &amp; return_object = (QString &amp;) obj-&gt;setNum((short) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &amp;return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -752,14 +754,14 @@
 			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString &amp; return_object = (QString &amp;) obj-&gt;setNum((float) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &amp;return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString &amp; return_object = (QString &amp;) obj-&gt;setNum((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &amp;return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -798,12 +800,12 @@
  *    function  number
  *    flags:    s
  *
- *	QString number ( long n, int base = 10 ) 
- *	QString number ( ulong n, int base = 10 ) 
- *	QString number ( int n, int base = 10 ) 
- *	QString number ( uint n, int base = 10 ) 
- *	QString number ( qlonglong n, int base = 10 ) 
- *	QString number ( qulonglong n, int base = 10 ) 
+ *	QString number ( long n, int base = 10 )
+ *	QString number ( ulong n, int base = 10 )
+ *	QString number ( int n, int base = 10 )
+ *	QString number ( uint n, int base = 10 )
+ *	QString number ( qlonglong n, int base = 10 )
+ *	QString number ( qulonglong n, int base = 10 )
  *	QString number ( double n, char format = 'g', int precision = 6 )
  */
 ZEND_METHOD(QString, number){
@@ -814,17 +816,17 @@
 			if(Z_TYPE_P(z_0) == IS_LONG){
 				QString obj = (QString) QString::number((ulong) Z_LVAL_P(z_0));
 				QString *s1 = new QString(obj);
-				
+
 				phpqt_createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
 				return;
 			} else if(Z_TYPE_P(z_0) == IS_DOUBLE){
 				QString obj = (QString) QString::number((double) Z_DVAL_P(z_0));
 				QString *s1 = new QString(obj);
-				
+
 				phpqt_createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
 				return;
 			}
-			
+
 		}
 	}
 
@@ -1035,7 +1037,7 @@
  *    class     QString */
 /*
  *    function  truncate
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, truncate){
 
@@ -1112,7 +1114,7 @@
  *    class     QString */
 /*
  *    function  push_front
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, push_front){
 
@@ -1349,7 +1351,7 @@
  *    class     QString */
 /*
  *    function  remove
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, remove){
 
@@ -1387,7 +1389,7 @@
 			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString &amp; return_object = (QString &amp;) obj-&gt;remove((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &amp;return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -1535,7 +1537,7 @@
  *    class     QString */
 /*
  *    function  vsprintf
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, vsprintf){
 
@@ -1597,7 +1599,7 @@
  *    class     QString */
 /*
  *    function  reserve
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, reserve){
 
@@ -1714,7 +1716,7 @@
  *    class     QString */
 /*
  *    function  setUnicode
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, setUnicode){
 
@@ -1764,7 +1766,7 @@
  *    class     QString */
 /*
  *    function  data
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, data){
 	if (ZEND_NUM_ARGS() == 0){
@@ -1792,7 +1794,7 @@
  *    class     QString */
 /*
  *    function  end
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, end){
 	if (ZEND_NUM_ARGS() == 0){
@@ -1855,7 +1857,7 @@
  *    class     QString */
 /*
  *    function  resize
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, resize){
 
@@ -1880,7 +1882,7 @@
  *    class     QString */
 /*
  *    function  replace
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, replace){
 
@@ -1933,7 +1935,7 @@
 			{
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString &amp; return_object = (QString &amp;) obj-&gt;replace((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(char) Z_LVAL_P(z_2));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &amp;return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -1979,7 +1981,7 @@
   			    if(getThis() == NULL){
 				QString obj = (QString) QString::fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
 				QString *s1 = new QString(obj);
-				
+
 				phpqt_createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
 				return;
 
@@ -2019,7 +2021,7 @@
  *    class     QString */
 /*
  *    function  detach
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, detach){
 	if (ZEND_NUM_ARGS() == 0){
@@ -2033,7 +2035,7 @@
  *    class     QString */
 /*
  *    function  append
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, append){
 
@@ -2045,7 +2047,7 @@
 			{
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString &amp; return_object = (QString &amp;) obj-&gt;append((char) Z_LVAL_P(z_0));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &amp;return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -2129,7 +2131,7 @@
  *    class     QString */
 /*
  *    function  fill
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, fill){
 
@@ -2144,7 +2146,7 @@
 			{
 				QString *obj = (QString*) PHP_QT_FETCH();
 				QString &amp; return_object = (QString &amp;) obj-&gt;fill((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				return_value = (zval*) emalloc(sizeof(zval));				
+				return_value = (zval*) emalloc(sizeof(zval));
 				phpqt_createObject(return_value,(void*) &amp;return_object,qstring_ce, QSTRING_CLASSID);
 				return;
 			}
@@ -2167,7 +2169,7 @@
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) 
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS)
 		{
 			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG)
 			{
@@ -2294,7 +2296,7 @@
  *    class     QString */
 /*
  *    function  begin
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, begin){
 	if (ZEND_NUM_ARGS() == 0){
@@ -2307,7 +2309,7 @@
  *    class     QString */
 /*
  *    function  push_back
- *    flags:    
+ *    flags:
  */
 ZEND_METHOD(QString, push_back){
 

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-06-06 21:10:09 UTC (rev 335)
+++ trunk/php_qt/smokephp.cpp	2007-06-06 21:19:56 UTC (rev 336)
@@ -23,6 +23,8 @@
 #include &quot;php_qt.h&quot;
 #include &quot;smoke.h&quot;
 #include &quot;marshall_types.h&quot;
+#include &quot;phpqt_internals.h&quot;
+
 #include &lt;QtCore/QMetaMethod&gt;
 #include &lt;QtCore/QHash&gt;
 #include &lt;QtCore/QCoreApplication&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000179.html">[Php-qt-svn] r335 - trunk/php_qt
</A></li>
	<LI>Next message: <A HREF="000181.html">[Php-qt-svn] r337 - trunk/php_qt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#180">[ date ]</a>
              <a href="thread.html#180">[ thread ]</a>
              <a href="subject.html#180">[ subject ]</a>
              <a href="author.html#180">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/php-qt-svn">More information about the Php-qt-svn
mailing list</a><br>
</body></html>
