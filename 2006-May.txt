From tm243 at berlios.de  Wed May  3 18:49:46 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Wed, 3 May 2006 18:49:46 +0200
Subject: [Php-qt-svn] r230 - in trunk/qt: . classes
Message-ID: <200605031649.k43GnkTi012593@sheep.berlios.de>

Author: tm243
Date: 2006-05-03 18:49:42 +0200 (Wed, 03 May 2006)
New Revision: 230

Modified:
   trunk/qt/classes/qwidget.cpp
   trunk/qt/php_qt.cpp
   trunk/qt/php_qt.h
Log:
milestone: a first custom slot added, the name 'test' is still hardcoded.

Modified: trunk/qt/classes/qwidget.cpp
===================================================================
--- trunk/qt/classes/qwidget.cpp	2006-04-29 07:36:12 UTC (rev 229)
+++ trunk/qt/classes/qwidget.cpp	2006-05-03 16:49:42 UTC (rev 230)
@@ -32,7 +32,60 @@
 
 #include <QWidget>
 #include <QIcon>
+#include <QMetaMethod>
 
+const QMetaObject *QWidget::metaObject() const
+{
+
+    QMetaObject *superdata = (QMetaObject*) &staticMetaObject;
+
+    static const char stringdata[] = {"QWidget\0\0value\0test(int)\0"};
+    static const uint data[] = {
+
+       1,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,    10, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+
+       15,   10,    9,    9, 0x0a,
+
+    };
+
+    QMetaObject ob = {
+        {superdata,stringdata,data,0}
+    };
+
+    QMetaObject *meta = new QMetaObject;
+    *meta = ob;
+
+    return meta;
+
+}
+
+class QWidget_moc : public QWidget
+{
+    public:
+        zval* zend_ptr;
+        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+        
+};
+
+
+int QWidget_moc::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+
+    _id = QWidget::qt_metacall(_c, _id, _a);
+    if(_id == 0) 
+    {
+        php_qt_callmethod(this->zend_ptr,"test");
+    }
+    return _id;
+
+}
+
+
 /*!
  *    @class     QWidget
  *    @function  nextInFocusChain
@@ -2779,7 +2832,8 @@
 {
 ///QWidget*
   if (ZEND_NUM_ARGS() == 0) {
-          QWidget *QWidget_ptr = new QWidget();
+          QWidget_moc *QWidget_ptr = new QWidget_moc();
+          QWidget_ptr->zend_ptr = this_ptr;
 
           PHP_QT_REGISTER(QWidget_ptr);
           RETURN_NULL();

Modified: trunk/qt/php_qt.cpp
===================================================================
--- trunk/qt/php_qt.cpp	2006-04-29 07:36:12 UTC (rev 229)
+++ trunk/qt/php_qt.cpp	2006-05-03 16:49:42 UTC (rev 230)
@@ -32,6 +32,7 @@
 */
 /* $Id: header,v 1.15 2004/01/08 16:46:52 sniper Exp $ */
 
+#include <zend_interfaces.h>
 #include "php_qt.h"
 #include <QObject>
 #include <QApplication>
@@ -42,7 +43,6 @@
 #include <QLCDNumber>
 #include <QStringList>
 
-
 //QOUT();
 
 #include <iostream>
@@ -1137,7 +1137,24 @@
 #endif
 }
 
+void php_qt_callmethod(zval* this_ptr, char* methodname)
+{
 
+	if(this_ptr == NULL){
+	  php_error(E_ERROR,"fatal: object does not exists and could not be fetched, %s",Z_OBJCE_P(this_ptr)->name);
+	}    
+
+    zval *function_name;
+    MAKE_STD_ZVAL(function_name);
+    ZVAL_STRING(function_name,methodname,1);
+    
+    zval* retval;
+    MAKE_STD_ZVAL(retval);
+
+    call_user_function_ex(CG(function_table),&this_ptr,function_name,&retval,0,NULL,0,NULL);
+
+}
+
 ///
 static zend_function_entry QObject_methods[] = { 
     ZEND_ME(QObject,__construct,NULL,ZEND_ACC_PUBLIC)

Modified: trunk/qt/php_qt.h
===================================================================
--- trunk/qt/php_qt.h	2006-04-29 07:36:12 UTC (rev 229)
+++ trunk/qt/php_qt.h	2006-05-03 16:49:42 UTC (rev 230)
@@ -328,6 +328,7 @@
 void php_qt_register(zval* this_ptr, zend_rsrc_list_entry le);
 void php_qt_setObject(zval* this_ptr, void* obj);
 static void destroy_php_qt_hashtable(zend_rsrc_list_entry *rsrc);
+void php_qt_callmethod(zval* zend_ptr, char* methodname);
 
 extern int le_php_qt_hashtype;
 extern HashTable php_qt_objptr_hash;



From tm243 at berlios.de  Thu May  4 00:49:24 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Thu, 4 May 2006 00:49:24 +0200
Subject: [Php-qt-svn] r231 - in trunk/qt: . classes
Message-ID: <200605032249.k43MnOog026278@sheep.berlios.de>

Author: tm243
Date: 2006-05-04 00:49:22 +0200 (Thu, 04 May 2006)
New Revision: 231

Modified:
   trunk/qt/classes/qwidget.cpp
   trunk/qt/php_qt.cpp
   trunk/qt/php_qt.h
Log:
getStringData: a function which computes stringdata for Qt runtime.

Modified: trunk/qt/classes/qwidget.cpp
===================================================================
--- trunk/qt/classes/qwidget.cpp	2006-05-03 16:49:42 UTC (rev 230)
+++ trunk/qt/classes/qwidget.cpp	2006-05-03 22:49:22 UTC (rev 231)
@@ -34,12 +34,23 @@
 #include <QIcon>
 #include <QMetaMethod>
 
-const QMetaObject *QWidget::metaObject() const
+
+
+class QWidget_moc : public QWidget
 {
+    public:
+        zval* zend_ptr;
+        const QMetaObject* metaObject() const;
+        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+        
+};
 
+const QMetaObject *QWidget_moc::metaObject() const
+{
+
     QMetaObject *superdata = (QMetaObject*) &staticMetaObject;
 
-    static const char stringdata[] = {"QWidget\0\0value\0test(int)\0"};
+//    static const char stringdata[] = {"QWidget\0\0value\0test(int)\0"};
     static const uint data[] = {
 
        1,       // revision
@@ -50,9 +61,12 @@
        0,    0, // enums/sets
 
        15,   10,    9,    9, 0x0a,
+       15,   10,    9,    9, 0x0a,
 
     };
 
+    static const char* stringdata = php_qt_getStringdata(this->zend_ptr,"QWidget");
+
     QMetaObject ob = {
         {superdata,stringdata,data,0}
     };
@@ -64,15 +78,6 @@
 
 }
 
-class QWidget_moc : public QWidget
-{
-    public:
-        zval* zend_ptr;
-        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
-        
-};
-
-
 int QWidget_moc::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
 {
 

Modified: trunk/qt/php_qt.cpp
===================================================================
--- trunk/qt/php_qt.cpp	2006-05-03 16:49:42 UTC (rev 230)
+++ trunk/qt/php_qt.cpp	2006-05-03 22:49:22 UTC (rev 231)
@@ -1155,6 +1155,63 @@
 
 }
 
+// creates stringdata
+// example: char* stringdata = "QWidget\0\0value\0test(int)\0";
+
+char* php_qt_getStringdata(zval* this_ptr, char* classname){
+
+    char * r;
+    r = (char*) malloc(2 + strlen(classname));
+    strcpy(r, classname);  
+    strncat(r,"++",2);
+
+    char * value;
+    value = (char*) malloc(1 + strlen("value"));
+    strcpy(value, "value");
+
+    strcat(r,value);
+    strncat(r,"+",1);    
+
+    zval *s1 = zend_read_property(QWidget_ce_ptr,this_ptr,"slots",5,0);
+    zval **data;
+
+// TODO: is it really an array?
+    HashTable* hash = HASH_OF(s1);
+    char* assocKey;
+    ulong numKey;
+
+    zend_hash_internal_pointer_reset(hash);
+
+    while(zend_hash_has_more_elements(hash) == SUCCESS){
+        zend_hash_get_current_key(hash,&assocKey,&numKey,0);
+        zend_hash_get_current_data(hash,(void**)&data);
+        
+        convert_to_string(*data);
+
+        char *buf;
+        buf = (char*) malloc(1+strlen(Z_STRVAL_PP(data)));
+        strcpy(buf, Z_STRVAL_PP(data));
+
+        strncat(r,buf,strlen(Z_STRVAL_PP(data)));
+        strncat(r,"+",1);
+
+        zend_hash_move_forward(hash);
+    }
+
+    // transform '+' into \0
+    for(int i=0;i<44;i++){
+#ifdef DEBUG
+        cout << r[i] << "";
+#endif
+        if((int) r[i] == 43){
+            r[i] = NULL;
+        }
+    }
+
+    return r;
+
+}
+
 ///
 static zend_function_entry QObject_methods[] = { 
     ZEND_ME(QObject,__construct,NULL,ZEND_ACC_PUBLIC)

Modified: trunk/qt/php_qt.h
===================================================================
--- trunk/qt/php_qt.h	2006-05-03 16:49:42 UTC (rev 230)
+++ trunk/qt/php_qt.h	2006-05-03 22:49:22 UTC (rev 231)
@@ -329,6 +329,7 @@
 void php_qt_setObject(zval* this_ptr, void* obj);
 static void destroy_php_qt_hashtable(zend_rsrc_list_entry *rsrc);
 void php_qt_callmethod(zval* zend_ptr, char* methodname);
+char* php_qt_getStringdata(zval* this_ptr, char* classname);
 
 extern int le_php_qt_hashtype;
 extern HashTable php_qt_objptr_hash;



From tm243 at berlios.de  Sat May  6 09:56:51 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Sat, 6 May 2006 09:56:51 +0200
Subject: [Php-qt-svn] r232 - in trunk/qt: . classes
Message-ID: <200605060756.k467upri001680@sheep.berlios.de>

Author: tm243
Date: 2006-05-06 09:56:43 +0200 (Sat, 06 May 2006)
New Revision: 232

Modified:
   trunk/qt/classes/qwidget.cpp
   trunk/qt/php_qt.cpp
   trunk/qt/php_qt.h
Log:
getStringData() moved to getData() which computes and returns stringdata and signatures of slots in a struct.

Modified: trunk/qt/classes/qwidget.cpp
===================================================================
--- trunk/qt/classes/qwidget.cpp	2006-05-03 22:49:22 UTC (rev 231)
+++ trunk/qt/classes/qwidget.cpp	2006-05-06 07:56:43 UTC (rev 232)
@@ -50,25 +50,10 @@
 
     QMetaObject *superdata = (QMetaObject*) &staticMetaObject;
 
-//    static const char stringdata[] = {"QWidget\0\0value\0test(int)\0"};
-    static const uint data[] = {
+    static const moc* m = php_qt_getData(this->zend_ptr,"QWidget");
 
-       1,       // revision
-       0,       // classname
-       0,    0, // classinfo
-       1,    10, // methods
-       0,    0, // properties
-       0,    0, // enums/sets
-
-       15,   10,    9,    9, 0x0a,
-       15,   10,    9,    9, 0x0a,
-
-    };
-
-    static const char* stringdata = php_qt_getStringdata(this->zend_ptr,"QWidget");
-
     QMetaObject ob = {
-        {superdata,stringdata,data,0}
+        {superdata,m->stringdata,m->signature,0}
     };
 
     QMetaObject *meta = new QMetaObject;
@@ -86,6 +71,11 @@
     {
         php_qt_callmethod(this->zend_ptr,"test");
     }
+    if(_id == 1) 
+    {
+        php_qt_callmethod(this->zend_ptr,"meinSlot");
+    }
+
     return _id;
 
 }

Modified: trunk/qt/php_qt.cpp
===================================================================
--- trunk/qt/php_qt.cpp	2006-05-03 22:49:22 UTC (rev 231)
+++ trunk/qt/php_qt.cpp	2006-05-06 07:56:43 UTC (rev 232)
@@ -32,6 +32,8 @@
 */
 /* $Id: header,v 1.15 2004/01/08 16:46:52 sniper Exp $ */
 
+//#define DEBUG=0
+
 #include <zend_interfaces.h>
 #include "php_qt.h"
 #include <QObject>
@@ -1155,24 +1157,15 @@
 
 }
 
-// creates stringdata
-// example: char* stringdata = "QWidget\0\0value\0test(int)\0";
+/*! creates moc data
+ *  example: "QWidget\0\0value\0test(int)\0"
+ */
 
-char* php_qt_getStringdata(zval* this_ptr, char* classname){
+moc* php_qt_getData(zval* this_ptr, char* classname){
 
-    char * r;
-    r = (char*) malloc(2 + strlen(classname));
-    strcpy(r, classname);  
-    strncat(r,"++",2);
-
-    char * value;
-    value = (char*) malloc(1 + strlen("value"));
-    strcpy(value, "value");
-
-    strcat(r,value);
-    strncat(r,"+",1);    
-
-    zval *s1 = zend_read_property(QWidget_ce_ptr,this_ptr,"slots",5,0);
+    /*! readout the slots table */
+    zval *s1;
+    s1 = zend_read_property(QWidget_ce_ptr,this_ptr,"slots",5,0);
     zval **data;
 
 // TODO: is it really an array?
@@ -1180,9 +1173,37 @@
     char* assocKey;
     ulong numKey;
 
+    int signaturecount;
+    signaturecount = 2 + strlen(classname);
+
+    char* stringdata;
+    stringdata = (char*) malloc(2 + strlen(classname)+(zend_hash_num_elements(hash)*20));
+
+    uint* signature = (uint*) malloc(sizeof(uint)*zend_hash_num_elements(hash)*5+10);
+
+    /*! write class signature */
+    signature[0] = 1;
+    signature[1] = 0;
+    signature[2] = 0;
+    signature[3] = 0;
+    signature[4] = zend_hash_num_elements(hash);
+    signature[5] = 10;
+    signature[6] = 0;
+    signature[7] = 0;
+    signature[8] = 0;
+    signature[9] = 0;
+
+    /*! write classname */
+    strcpy(stringdata, classname);  
+    strncat(stringdata,"++",2);
+    int i;
+    i = 10;
+
     zend_hash_internal_pointer_reset(hash);
 
     while(zend_hash_has_more_elements(hash) == SUCCESS){
+
+        /* read slot from hashtable */
         zend_hash_get_current_key(hash,&assocKey,&numKey,0);
         zend_hash_get_current_data(hash,(void**)&data);
         
@@ -1192,24 +1213,35 @@
         buf = (char*) malloc(1+strlen(Z_STRVAL_PP(data)));
         strcpy(buf, Z_STRVAL_PP(data));
 
-        strncat(r,buf,strlen(Z_STRVAL_PP(data)));
-        strncat(r,"+",1);
+        strncat(stringdata,buf,strlen(Z_STRVAL_PP(data)));
+        strncat(stringdata,"+",1);
 
         zend_hash_move_forward(hash);
+
+        /*! write slot signature */
+        signature[i++] = signaturecount;
+        signature[i++] = 8;        
+        signature[i++] = 8;
+        signature[i++] = 8;
+        signature[i++] = 0x0a;
+
+        signaturecount += strlen(Z_STRVAL_PP(data)) + 1;
+
     }
 
-    // transform '+' into \0
-    for(int i=0;i<44;i++){
-#ifdef DEBUG
-        cout << r[i] << "";
-#endif
-        if((int) r[i] == 43){
-            r[i] = NULL;
+    /// transform '+' into \0
+    for(int i=0;i<=signaturecount;i++){
+        if((int) stringdata[i] == 43){
+            stringdata[i] = NULL;
         }
     }
 
-    return r;
+    moc *m = new moc;
+    m->stringdata = stringdata;
+    m->signature = signature;
 
+    return m;
+
 }
 
 ///

Modified: trunk/qt/php_qt.h
===================================================================
--- trunk/qt/php_qt.h	2006-05-03 22:49:22 UTC (rev 231)
+++ trunk/qt/php_qt.h	2006-05-06 07:56:43 UTC (rev 232)
@@ -324,12 +324,17 @@
 #include "ext/standard/info.h"
 #include "zend_php_qt.h"
 
+struct moc {
+    char* stringdata; 
+    uint* signature;
+};
+
 void* php_qt_fetch(zval* this_ptr);
 void php_qt_register(zval* this_ptr, zend_rsrc_list_entry le);
 void php_qt_setObject(zval* this_ptr, void* obj);
 static void destroy_php_qt_hashtable(zend_rsrc_list_entry *rsrc);
 void php_qt_callmethod(zval* zend_ptr, char* methodname);
-char* php_qt_getStringdata(zval* this_ptr, char* classname);
+moc* php_qt_getData(zval* this_ptr, char* classname);
 
 extern int le_php_qt_hashtype;
 extern HashTable php_qt_objptr_hash;



From tm243 at berlios.de  Mon May  8 19:32:52 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Mon, 8 May 2006 19:32:52 +0200
Subject: [Php-qt-svn] r233 - in trunk/qt: . classes
Message-ID: <200605081732.k48HWqQ2004121@sheep.berlios.de>

Author: tm243
Date: 2006-05-08 19:32:49 +0200 (Mon, 08 May 2006)
New Revision: 233

Modified:
   trunk/qt/classes/qwidget.cpp
   trunk/qt/php_qt.cpp
   trunk/qt/php_qt.h
Log:
automatic call of custom slots, with or without integer parameters

Modified: trunk/qt/classes/qwidget.cpp
===================================================================
--- trunk/qt/classes/qwidget.cpp	2006-05-06 07:56:43 UTC (rev 232)
+++ trunk/qt/classes/qwidget.cpp	2006-05-08 17:32:49 UTC (rev 233)
@@ -29,13 +29,10 @@
 
 #include "../php_qt.h"
 
-
 #include <QWidget>
 #include <QIcon>
 #include <QMetaMethod>
 
-
-
 class QWidget_moc : public QWidget
 {
     public:
@@ -50,7 +47,7 @@
 
     QMetaObject *superdata = (QMetaObject*) &staticMetaObject;
 
-    static const moc* m = php_qt_getData(this->zend_ptr,"QWidget");
+    static const moc* m = php_qt_getMocData(this->zend_ptr,"QWidget");
 
     QMetaObject ob = {
         {superdata,m->stringdata,m->signature,0}
@@ -66,16 +63,37 @@
 int QWidget_moc::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
 {
 
-    _id = QWidget::qt_metacall(_c, _id, _a);
-    if(_id == 0) 
-    {
-        php_qt_callmethod(this->zend_ptr,"test");
+    QMetaObject* d = (QMetaObject*) this->metaObject();
+    char* method_name = new char[strlen((d->method(_id)).signature())];
+    strcpy(method_name,(char*) (d->method(_id)).signature());
+
+    int i;
+    for(i = 0; i < strlen(method_name); i++){
+        if(method_name[i] == 40){
+            method_name[i] = 0;
+            break;
+        }
     }
-    if(_id == 1) 
-    {
-        php_qt_callmethod(this->zend_ptr,"meinSlot");
+
+    int j = 0;
+    zval** args[1];
+    QList<QByteArray> qargs = d->method(_id).parameterTypes();
+    for(i = 0; i < qargs.count(); i++){
+
+        if(!strncmp("int",(const char*) qargs[i],3)){
+            zval *arg;
+            MAKE_STD_ZVAL(arg);
+            ZVAL_LONG(arg, *reinterpret_cast< int*>(_a[1]));
+            args[j++] = &arg;
+        }
+
     }
 
+    php_qt_callmethod(this->zend_ptr, method_name, j, args);
+
+    delete d;
+    delete method_name;
+
     return _id;
 
 }
@@ -85,7 +103,7 @@
  *    @class     QWidget
  *    @function  nextInFocusChain
  *
- *    @flags    c
+ *    @flags     c
  *    @access    public
  *    @return    QWidget *
  *    @param    

Modified: trunk/qt/php_qt.cpp
===================================================================
--- trunk/qt/php_qt.cpp	2006-05-06 07:56:43 UTC (rev 232)
+++ trunk/qt/php_qt.cpp	2006-05-08 17:32:49 UTC (rev 233)
@@ -44,6 +44,7 @@
 #include <QSlider>
 #include <QLCDNumber>
 #include <QStringList>
+#include <QList>
 
 //QOUT();
 
@@ -1139,7 +1140,7 @@
 #endif
 }
 
-void php_qt_callmethod(zval* this_ptr, char* methodname)
+void php_qt_callmethod(zval* this_ptr, char* methodname, zend_uint param_count, zval** args[])
 {
 
 	if(this_ptr == NULL){
@@ -1153,7 +1154,7 @@
     zval* retval;
     MAKE_STD_ZVAL(retval);
 
-    call_user_function_ex(CG(function_table),&this_ptr,function_name,&retval,0,NULL,0,NULL);
+    call_user_function_ex(CG(function_table),&this_ptr,function_name,&retval,param_count,args,0,NULL);
 
 }
 
@@ -1161,15 +1162,15 @@
  *  example: "QWidget\0\0value\0test(int)\0"
  */
 
-moc* php_qt_getData(zval* this_ptr, char* classname){
+moc* php_qt_getMocData(zval* this_ptr, char* classname){
 
     /*! readout the slots table */
-    zval *s1;
-    s1 = zend_read_property(QWidget_ce_ptr,this_ptr,"slots",5,0);
-    zval **data;
+    zval *zslot;
+    zslot = zend_read_property(QWidget_ce_ptr,this_ptr,"slots",5,0);
+    zval **slotdata;
 
 // TODO: is it really an array?
-    HashTable* hash = HASH_OF(s1);
+    HashTable* hash = HASH_OF(zslot);
     char* assocKey;
     ulong numKey;
 
@@ -1178,7 +1179,6 @@
 
     char* stringdata;
     stringdata = (char*) malloc(2 + strlen(classname)+(zend_hash_num_elements(hash)*20));
-
     uint* signature = (uint*) malloc(sizeof(uint)*zend_hash_num_elements(hash)*5+10);
 
     /*! write class signature */
@@ -1205,15 +1205,15 @@
 
         /* read slot from hashtable */
         zend_hash_get_current_key(hash,&assocKey,&numKey,0);
-        zend_hash_get_current_data(hash,(void**)&data);
+        zend_hash_get_current_data(hash,(void**)&slotdata);
         
-        convert_to_string(*data);
+        convert_to_string(*slotdata);
 
         char *buf;
-        buf = (char*) malloc(1+strlen(Z_STRVAL_PP(data)));
-        strcpy(buf, Z_STRVAL_PP(data));
+        buf = (char*) malloc(1+strlen(Z_STRVAL_PP(slotdata)));
+        strcpy(buf, Z_STRVAL_PP(slotdata));
 
-        strncat(stringdata,buf,strlen(Z_STRVAL_PP(data)));
+        strncat(stringdata,buf,strlen(Z_STRVAL_PP(slotdata)));
         strncat(stringdata,"+",1);
 
         zend_hash_move_forward(hash);
@@ -1225,7 +1225,7 @@
         signature[i++] = 8;
         signature[i++] = 0x0a;
 
-        signaturecount += strlen(Z_STRVAL_PP(data)) + 1;
+        signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
 
     }
 

Modified: trunk/qt/php_qt.h
===================================================================
--- trunk/qt/php_qt.h	2006-05-06 07:56:43 UTC (rev 232)
+++ trunk/qt/php_qt.h	2006-05-08 17:32:49 UTC (rev 233)
@@ -333,8 +333,8 @@
 void php_qt_register(zval* this_ptr, zend_rsrc_list_entry le);
 void php_qt_setObject(zval* this_ptr, void* obj);
 static void destroy_php_qt_hashtable(zend_rsrc_list_entry *rsrc);
-void php_qt_callmethod(zval* zend_ptr, char* methodname);
-moc* php_qt_getData(zval* this_ptr, char* classname);
+void php_qt_callmethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params[]);
+moc* php_qt_getMocData(zval* this_ptr, char* classname);
 
 extern int le_php_qt_hashtype;
 extern HashTable php_qt_objptr_hash;



From tm243 at berlios.de  Wed May 10 00:47:58 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Wed, 10 May 2006 00:47:58 +0200
Subject: [Php-qt-svn] r234 - in trunk/qt: . classes
Message-ID: <200605092247.k49Mlwl1020221@sheep.berlios.de>

Author: tm243
Date: 2006-05-10 00:47:53 +0200 (Wed, 10 May 2006)
New Revision: 234

Modified:
   trunk/qt/classes/qwidget.cpp
   trunk/qt/php_qt.cpp
   trunk/qt/php_qt.h
Log:
the metaobject generator uses QString for unicode support in future, signals are computed.

Modified: trunk/qt/classes/qwidget.cpp
===================================================================
--- trunk/qt/classes/qwidget.cpp	2006-05-08 17:32:49 UTC (rev 233)
+++ trunk/qt/classes/qwidget.cpp	2006-05-09 22:47:53 UTC (rev 234)
@@ -36,7 +36,11 @@
 class QWidget_moc : public QWidget
 {
     public:
+        QWidget_moc(zval* zend_ptr);
+
         zval* zend_ptr;
+        QMetaObject* dynamicMetaObject;
+
         const QMetaObject* metaObject() const;
         int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
         
@@ -44,20 +48,14 @@
 
 const QMetaObject *QWidget_moc::metaObject() const
 {
+    return php_qt_getMocData(this->zend_ptr,"QWidget",&staticMetaObject);;
+}
 
-    QMetaObject *superdata = (QMetaObject*) &staticMetaObject;
-
-    static const moc* m = php_qt_getMocData(this->zend_ptr,"QWidget");
-
-    QMetaObject ob = {
-        {superdata,m->stringdata,m->signature,0}
-    };
-
-    QMetaObject *meta = new QMetaObject;
-    *meta = ob;
-
-    return meta;
-
+QWidget_moc::QWidget_moc(zval* zend_ptr)
+{
+    this->zend_ptr = zend_ptr;
+    dynamicMetaObject = new QMetaObject;
+    dynamicMetaObject = php_qt_getMocData(this->zend_ptr,"QWidget",&staticMetaObject);
 }
 
 int QWidget_moc::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
@@ -2845,13 +2843,14 @@
 {
 ///QWidget*
   if (ZEND_NUM_ARGS() == 0) {
-          QWidget_moc *QWidget_ptr = new QWidget_moc();
-          QWidget_ptr->zend_ptr = this_ptr;
 
+          QWidget_moc *QWidget_ptr = new QWidget_moc(this_ptr);
+
           PHP_QT_REGISTER(QWidget_ptr);
           RETURN_NULL();
-  }
 
+    }
+
 /*! ol public*/
 /*! QWidget* parent, int f,  */
   if (ZEND_NUM_ARGS() == 2) {

Modified: trunk/qt/php_qt.cpp
===================================================================
--- trunk/qt/php_qt.cpp	2006-05-08 17:32:49 UTC (rev 233)
+++ trunk/qt/php_qt.cpp	2006-05-09 22:47:53 UTC (rev 234)
@@ -1162,63 +1162,67 @@
  *  example: "QWidget\0\0value\0test(int)\0"
  */
 
-moc* php_qt_getMocData(zval* this_ptr, char* classname){
+QMetaObject* php_qt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata){
 
-    /*! readout the slots table */
+    /// readout the slots table
+    zval **slotdata;
+
     zval *zslot;
     zslot = zend_read_property(QWidget_ce_ptr,this_ptr,"slots",5,0);
-    zval **slotdata;
 
-// TODO: is it really an array?
-    HashTable* hash = HASH_OF(zslot);
-    char* assocKey;
-    ulong numKey;
+    zval *zsignal;
+    zsignal = zend_read_property(QWidget_ce_ptr,this_ptr,"signals",7,0);
 
-    int signaturecount;
-    signaturecount = 2 + strlen(classname);
 
-    char* stringdata;
-    stringdata = (char*) malloc(2 + strlen(classname)+(zend_hash_num_elements(hash)*20));
-    uint* signature = (uint*) malloc(sizeof(uint)*zend_hash_num_elements(hash)*5+10);
+    if((zslot)->type==IS_ARRAY && (zsignal)->type==IS_ARRAY ) {
 
-    /*! write class signature */
+        HashTable* slots_hash = HASH_OF(zslot);
+        HashTable* signals_hash = HASH_OF(zsignal);
+
+        char* assocKey;
+        ulong numKey;
+
+        int signaturecount;
+        signaturecount = 2 + strlen(classname);
+
+        uint* signature = (uint*) new uint[sizeof(uint)*zend_hash_num_elements(slots_hash)*zend_hash_num_elements(signals_hash)*5+10];
+        QString *q = new QString();
+
+
+    /// write class signature
     signature[0] = 1;
     signature[1] = 0;
     signature[2] = 0;
     signature[3] = 0;
-    signature[4] = zend_hash_num_elements(hash);
+    signature[4] = zend_hash_num_elements(slots_hash)+zend_hash_num_elements(signals_hash);
     signature[5] = 10;
     signature[6] = 0;
     signature[7] = 0;
     signature[8] = 0;
     signature[9] = 0;
 
-    /*! write classname */
-    strcpy(stringdata, classname);  
-    strncat(stringdata,"++",2);
+    /// write classname
+    q->append(classname);
+    q->append(QChar::Null);
+    q->append(QChar::Null);
+
     int i;
     i = 10;
 
-    zend_hash_internal_pointer_reset(hash);
+    zend_hash_internal_pointer_reset(signals_hash);
 
-    while(zend_hash_has_more_elements(hash) == SUCCESS){
+    while(zend_hash_has_more_elements(signals_hash) == SUCCESS){
 
-        /* read slot from hashtable */
-        zend_hash_get_current_key(hash,&assocKey,&numKey,0);
-        zend_hash_get_current_data(hash,(void**)&slotdata);
-        
-        convert_to_string(*slotdata);
+        /// read slot from hashtable
+        zend_hash_get_current_key(signals_hash,&assocKey,&numKey,0);
+        zend_hash_get_current_data(signals_hash,(void**)&slotdata);
 
-        char *buf;
-        buf = (char*) malloc(1+strlen(Z_STRVAL_PP(slotdata)));
-        strcpy(buf, Z_STRVAL_PP(slotdata));
+        q->append(Z_STRVAL_PP(slotdata));
+        q->append(QChar::Null);
 
-        strncat(stringdata,buf,strlen(Z_STRVAL_PP(slotdata)));
-        strncat(stringdata,"+",1);
+        zend_hash_move_forward(signals_hash);
 
-        zend_hash_move_forward(hash);
-
-        /*! write slot signature */
+        /// write slot signature
         signature[i++] = signaturecount;
         signature[i++] = 8;        
         signature[i++] = 8;
@@ -1229,19 +1233,47 @@
 
     }
 
-    /// transform '+' into \0
-    for(int i=0;i<=signaturecount;i++){
-        if((int) stringdata[i] == 43){
-            stringdata[i] = NULL;
-        }
+    zend_hash_internal_pointer_reset(slots_hash);
+
+    while(zend_hash_has_more_elements(slots_hash) == SUCCESS){
+
+        /// read slot from hashtable
+        zend_hash_get_current_key(slots_hash,&assocKey,&numKey,0);
+        zend_hash_get_current_data(slots_hash,(void**)&slotdata);
+
+        q->append(Z_STRVAL_PP(slotdata));
+        q->append(QChar::Null);
+
+        zend_hash_move_forward(slots_hash);
+
+        /// write slot signature
+        signature[i++] = signaturecount;
+        signature[i++] = 8;        
+        signature[i++] = 8;
+        signature[i++] = 8;
+        signature[i++] = 0x0a;
+
+        signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
+
     }
 
-    moc *m = new moc;
-    m->stringdata = stringdata;
-    m->signature = signature;
 
-    return m;
+    QMetaObject ob = {
+        {superdata,(q->toAscii()).data(),signature,0}
+    };
 
+
+    QMetaObject *meta = new QMetaObject;
+    *meta = ob;
+
+    return meta;
+
+  } else {
+
+    return (QMetaObject*) superdata;
+
+  }
+
 }
 
 ///

Modified: trunk/qt/php_qt.h
===================================================================
--- trunk/qt/php_qt.h	2006-05-08 17:32:49 UTC (rev 233)
+++ trunk/qt/php_qt.h	2006-05-09 22:47:53 UTC (rev 234)
@@ -334,7 +334,7 @@
 void php_qt_setObject(zval* this_ptr, void* obj);
 static void destroy_php_qt_hashtable(zend_rsrc_list_entry *rsrc);
 void php_qt_callmethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params[]);
-moc* php_qt_getMocData(zval* this_ptr, char* classname);
+QMetaObject* php_qt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata);
 
 extern int le_php_qt_hashtype;
 extern HashTable php_qt_objptr_hash;



From tm243 at berlios.de  Wed May 10 23:11:40 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Wed, 10 May 2006 23:11:40 +0200
Subject: [Php-qt-svn] r235 - in trunk: qt qt/classes qt/object_model tutorials tutorials/t7
Message-ID: <200605102111.k4ALBebc019429@sheep.berlios.de>

Author: tm243
Date: 2006-05-10 23:11:39 +0200 (Wed, 10 May 2006)
New Revision: 235

Added:
   trunk/tutorials/t7/
   trunk/tutorials/t7/main.php
Modified:
   trunk/qt/classes/qwidget.cpp
   trunk/qt/object_model/qobject.cpp
   trunk/qt/php_qt.cpp
Log:
custom signals implemented, tutorial 7 added.

Modified: trunk/qt/classes/qwidget.cpp
===================================================================
--- trunk/qt/classes/qwidget.cpp	2006-05-09 22:47:53 UTC (rev 234)
+++ trunk/qt/classes/qwidget.cpp	2006-05-10 21:11:39 UTC (rev 235)
@@ -56,6 +56,7 @@
     this->zend_ptr = zend_ptr;
     dynamicMetaObject = new QMetaObject;
     dynamicMetaObject = php_qt_getMocData(this->zend_ptr,"QWidget",&staticMetaObject);
+//    cout << dynamicMetaObject->indexOfSignal("valueChanged(int)")<<"\n";
 }
 
 int QWidget_moc::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
@@ -65,6 +66,7 @@
     char* method_name = new char[strlen((d->method(_id)).signature())];
     strcpy(method_name,(char*) (d->method(_id)).signature());
 
+    // breaks the string at the first bracket
     int i;
     for(i = 0; i < strlen(method_name); i++){
         if(method_name[i] == 40){
@@ -73,22 +75,30 @@
         }
     }
 
-    int j = 0;
-    zval** args[1];
-    QList<QByteArray> qargs = d->method(_id).parameterTypes();
-    for(i = 0; i < qargs.count(); i++){
+    // is a Slot
+    if(d->method(_id).methodType() == QMetaMethod::Slot){
+        int j = 0;
+        zval** args[1];
+        QList<QByteArray> qargs = d->method(_id).parameterTypes();
+        for(i = 0; i < qargs.count(); i++){
 
-        if(!strncmp("int",(const char*) qargs[i],3)){
-            zval *arg;
-            MAKE_STD_ZVAL(arg);
-            ZVAL_LONG(arg, *reinterpret_cast< int*>(_a[1]));
-            args[j++] = &arg;
+            if(!strncmp("int",(const char*) qargs[i],3)){
+                zval *arg;
+                MAKE_STD_ZVAL(arg);
+                ZVAL_LONG(arg, *reinterpret_cast< int*>(_a[1]));
+                args[j++] = &arg;
+            }
+
         }
 
+        php_qt_callmethod(this->zend_ptr, method_name, j, args);
+
+    // is a signal
+    } else {
+        void *_b[] = { 0, _a[1] };
+        QMetaObject::activate(this, d, 0, _b);
     }
 
-    php_qt_callmethod(this->zend_ptr, method_name, j, args);
-
     delete d;
     delete method_name;
 

Modified: trunk/qt/object_model/qobject.cpp
===================================================================
--- trunk/qt/object_model/qobject.cpp	2006-05-09 22:47:53 UTC (rev 234)
+++ trunk/qt/object_model/qobject.cpp	2006-05-10 21:11:39 UTC (rev 235)
@@ -85,20 +85,22 @@
     zval *sender;
     zval *signal;
     zval *slot;
- 
+
     int num_args = 0;
     num_args = ZEND_NUM_ARGS();
-    
+
     QObject *receiver_ptr;
 
     if(num_args == 4){
         zval *receiver;
         if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"ozoz", &sender, &signal, &receiver, &slot) == FAILURE) {
+            php_error(E_ERROR,"connect failed\n");
             RETURN_NULL(); 
         }
         receiver_ptr = static_cast<QObject*>(php_qt_fetch(receiver));    
     } else {
         if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"ozz", &sender, &signal, &slot) == FAILURE) {
+            php_error(E_ERROR,"connect failed\n");
             RETURN_NULL(); 
         }
         receiver_ptr = static_cast<QObject*>(PHP_QT_FETCH());

Modified: trunk/qt/php_qt.cpp
===================================================================
--- trunk/qt/php_qt.cpp	2006-05-09 22:47:53 UTC (rev 234)
+++ trunk/qt/php_qt.cpp	2006-05-10 21:11:39 UTC (rev 235)
@@ -1227,7 +1227,7 @@
         signature[i++] = 8;        
         signature[i++] = 8;
         signature[i++] = 8;
-        signature[i++] = 0x0a;
+        signature[i++] = 0x05;
 
         signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
 

Added: trunk/tutorials/t7/main.php
===================================================================
--- trunk/tutorials/t7/main.php	2006-05-09 22:47:53 UTC (rev 234)
+++ trunk/tutorials/t7/main.php	2006-05-10 21:11:39 UTC (rev 235)
@@ -0,0 +1,89 @@
+<?php
+    /****************************************************************
+    **
+    ** Qt tutorial 7
+    **
+    ** http://doc.trolltech.com/4.0/tutorial-t6.html
+    **
+    ****************************************************************/
+
+    if(!extension_loaded('php_qt')) {
+        dl('php_qt.' . PHP_SHLIB_SUFFIX);
+    }
+
+    class LCDRange extends QWidget
+    {
+        var $lcd;
+        var $slider;
+        var $layout;
+
+        var $slots = array("setValue(int)");
+        var $signals = array("valueChanged(int)");
+
+        function __construct(){
+
+            parent::__construct();
+
+            $this->lcd = new QLCDNumber(2,$this);
+            $this->slider = new QSlider($this);
+            $this->slider->setOrientation(QT_ORIENTATIONS_HORIZONTAL);
+
+            $this->slider->setRange(0, 99);
+            $this->slider->setValue(0);
+
+            $this->connect($this->slider, SIGNAL("valueChanged(int)"),
+                    $this->lcd, SLOT("display(int)"));
+
+            $this->connect($this->slider, SIGNAL("valueChanged(int)"),
+                    $this,SIGNAL("valueChanged(int)"));
+
+            $this->layout = new QVBoxLayout($this);
+            $this->layout->addWidget($this->lcd);
+            $this->layout->addWidget($this->slider);
+            $this->setLayout($this->layout);
+        }
+
+        function setValue($value){
+            $this->slider->setValue($value);
+        }
+
+    };
+
+    class MyWidget extends QWidget
+    {
+        var $quit;
+        var $grid;
+        var $layout;
+
+        function __construct(){
+
+            parent::__construct();
+
+            $this->quit = new QPushButton("Quit");
+    //        $this->quit->setFont(QFont("Times", 18, QFont::Bold));
+            $this->connect($this->quit, SIGNAL("clicked()"), QApplication::instance(), SLOT("quit()"));
+
+            $this->grid = new QGridLayout();
+            for ($row = 0; $row < 3; ++$row) {
+                for ($column = 0; $column < 3; ++$column) {
+                    $lcdRange = new LCDRange();
+                    $this->grid->addWidget($lcdRange, $row, $column);
+                    if($previousRange)
+                        $this->connect($lcdRange, SIGNAL("valueChanged(int)"), $previousRange, SLOT("setValue(int)"));
+                    $previousRange = $lcdRange;
+                }
+            }
+
+            $this->layout = new QVBoxLayout($this);
+            $this->layout->addWidget($this->quit);
+            $this->layout->addLayout($this->grid,0);
+            $this->setLayout($this->layout);
+        }
+    }
+
+    $app = new QApplication($argc,0);
+    $widget = new MyWidget();
+    $widget->show();
+    $app->exec();
+
+?>
\ No newline at end of file



From tm243 at berlios.de  Thu May 11 01:23:10 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Thu, 11 May 2006 01:23:10 +0200
Subject: [Php-qt-svn] r236 - trunk/qt/classes
Message-ID: <200605102323.k4ANNAJP019852@sheep.berlios.de>

Author: tm243
Date: 2006-05-11 01:23:04 +0200 (Thu, 11 May 2006)
New Revision: 236

Modified:
   trunk/qt/classes/qwidget.cpp
Log:
supported argument types for slots: int, char*, double, bool, objects. Any count of arguments.

Modified: trunk/qt/classes/qwidget.cpp
===================================================================
--- trunk/qt/classes/qwidget.cpp	2006-05-10 21:11:39 UTC (rev 235)
+++ trunk/qt/classes/qwidget.cpp	2006-05-10 23:23:04 UTC (rev 236)
@@ -82,13 +82,30 @@
         QList<QByteArray> qargs = d->method(_id).parameterTypes();
         for(i = 0; i < qargs.count(); i++){
 
+            zval *arg;
+            MAKE_STD_ZVAL(arg);
+
+            // invoke to zend types
             if(!strncmp("int",(const char*) qargs[i],3)){
-                zval *arg;
-                MAKE_STD_ZVAL(arg);
-                ZVAL_LONG(arg, *reinterpret_cast< int*>(_a[1]));
-                args[j++] = &arg;
+                ZVAL_LONG(arg, *reinterpret_cast< int*>(_a[i+1]));
+            } else if(!strncmp("char*",(const char*) qargs[i],5)){
+                ZVAL_STRING(arg, *reinterpret_cast< char**>(_a[i+1]), 1);
+            } else if(!strncmp("bool",(const char*) qargs[i],4)){
+                ZVAL_BOOL(arg, *reinterpret_cast< bool*>(_a[i+1]));
+            } else if(!strncmp("double",(const char*) qargs[i],4)){
+                ZVAL_DOUBLE(arg, *reinterpret_cast< double*>(_a[i+1]));
+            } else {
+                    // must be an object
+                    zend_class_entry *ce;
+                    object_init_ex(arg, QWidget_ce_ptr);
+                    zend_rsrc_list_entry le;
+                    le.ptr = *reinterpret_cast< QObject**>(_a[1]);
+                    php_qt_register(arg, le);
+                    
             }
 
+            args[j++] = &arg;
+
         }
 
         php_qt_callmethod(this->zend_ptr, method_name, j, args);



From tm243 at berlios.de  Sun May 14 16:10:31 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Sun, 14 May 2006 16:10:31 +0200
Subject: [Php-qt-svn] r237 - in trunk/qt: . text_related
Message-ID: <200605141410.k4EEAVZ8012401@sheep.berlios.de>

Author: tm243
Date: 2006-05-14 16:10:30 +0200 (Sun, 14 May 2006)
New Revision: 237

Modified:
   trunk/qt/ag_php_qt_cpp.inc
   trunk/qt/ag_zend_php_qt.inc
   trunk/qt/text_related/qstring.cpp
Log:
fixed a memory leak.

Modified: trunk/qt/ag_php_qt_cpp.inc
===================================================================
--- trunk/qt/ag_php_qt_cpp.inc	2006-05-10 23:23:04 UTC (rev 236)
+++ trunk/qt/ag_php_qt_cpp.inc	2006-05-14 14:10:30 UTC (rev 237)
@@ -1546,6 +1546,7 @@
 	ZEND_ME(QString,toLocal8Bit,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QString,toInt,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QString,isNull,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,__toString,NULL,ZEND_ACC_PUBLIC)
 
     {NULL,NULL,NULL}
 };

Modified: trunk/qt/ag_zend_php_qt.inc
===================================================================
--- trunk/qt/ag_zend_php_qt.inc	2006-05-10 23:23:04 UTC (rev 236)
+++ trunk/qt/ag_zend_php_qt.inc	2006-05-14 14:10:30 UTC (rev 237)
@@ -854,6 +854,7 @@
 ZEND_METHOD(QString, toLocal8Bit);
 ZEND_METHOD(QString, toInt);
 ZEND_METHOD(QString, isNull);
+ZEND_METHOD(QString, __toString);
 ZEND_METHOD(QTabletEvent, hiResGlobalX);
 ZEND_METHOD(QTabletEvent, pressure);
 ZEND_METHOD(QTabletEvent, hiResGlobalPos);

Modified: trunk/qt/text_related/qstring.cpp
===================================================================
--- trunk/qt/text_related/qstring.cpp	2006-05-10 23:23:04 UTC (rev 236)
+++ trunk/qt/text_related/qstring.cpp	2006-05-14 14:10:30 UTC (rev 237)
@@ -39,7 +39,7 @@
 
   char* c = (char*) (QString_ptr->toUtf8()).constData();
 
-  RETURN_STRING(c,l);
+  RETURN_STRINGL(c,l,1);
 }
 
 



From tm243 at berlios.de  Mon May 15 12:18:29 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Mon, 15 May 2006 12:18:29 +0200
Subject: [Php-qt-svn] r238 - trunk/qt/classes
Message-ID: <200605151018.k4FAIT9U030169@sheep.berlios.de>

Author: tm243
Date: 2006-05-15 12:18:29 +0200 (Mon, 15 May 2006)
New Revision: 238

Modified:
   trunk/qt/classes/qabstractbutton.cpp
   trunk/qt/classes/qgridlayout.cpp
   trunk/qt/classes/qlineedit.cpp
Log:
argument handling improved (addWidget(),text(),setText(),constructor),  bughunting.

Modified: trunk/qt/classes/qabstractbutton.cpp
===================================================================
--- trunk/qt/classes/qabstractbutton.cpp	2006-05-14 14:10:30 UTC (rev 237)
+++ trunk/qt/classes/qabstractbutton.cpp	2006-05-15 10:18:29 UTC (rev 238)
@@ -484,20 +484,18 @@
 		/* o public*/
 
 		/* const QString& text,  */
-
 	if (ZEND_NUM_ARGS() == 1){
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
 
+			    QAbstractButton *obj = static_cast<QAbstractButton*>(PHP_QT_FETCH());
+			    QObject* obj_z_0 = static_cast<QObject*>(php_qt_fetch(z_0));
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				obj->setText((const QString&) obj_z_0);
-			RETURN_NULL();
+		        obj->setText((const QString&) *obj_z_0);
+			    RETURN_NULL();
+
 			}
-			}
 		}
 	}
 }
@@ -511,11 +509,12 @@
 ZEND_METHOD(QAbstractButton, text){
 	if (ZEND_NUM_ARGS() == 0){
 			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->text();
+            QString *return_object = new QString;
+				*return_object = (QString) obj->text();
 				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
+				object_init_ex(return_value, QString_ce_ptr);     
 				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
+				le.ptr = (void*) return_object;                                       
 				php_qt_register(return_value,le);                   
 				return;                                             
 	}

Modified: trunk/qt/classes/qgridlayout.cpp
===================================================================
--- trunk/qt/classes/qgridlayout.cpp	2006-05-14 14:10:30 UTC (rev 237)
+++ trunk/qt/classes/qgridlayout.cpp	2006-05-15 10:18:29 UTC (rev 238)
@@ -518,20 +518,42 @@
 ZEND_METHOD(QGridLayout, addWidget)
 {
 ///QWidget*
+	if (ZEND_NUM_ARGS() == 5){
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+        zval *z_3; // define ZVAL
+        zval *z_4; // define ZVAL
+        
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzz", &z_0, &z_1, &z_2, &z_3, &z_4) == SUCCESS) {
+
+//			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG){
+
+			    QGridLayout *obj = (QGridLayout*) PHP_QT_FETCH();
+			    QWidget* obj_z_0 = static_cast<QWidget*>(php_qt_fetch(z_0));
+
+			    if(obj_z_0->inherits("QWidget")) {
+				    obj->addWidget(obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (Qt::Alignment) Z_LVAL_P(z_4));
+			        RETURN_NULL();
+			    } else { php_error(E_ERROR,"argument is no QWidget"); }
+//			} else { php_error(E_ERROR,"argument not allowed"); }
+		}
+	}
+///QWidget*
 	if (ZEND_NUM_ARGS() == 3){
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		zval *z_2; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QGridLayout *obj = (QGridLayout*) PHP_QT_FETCH();
-			QWidget* obj_z_0 = static_cast<QWidget*>(php_qt_fetch(z_0));
+//			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+			    QGridLayout *obj = (QGridLayout*) PHP_QT_FETCH();
+			    QWidget* obj_z_0 = static_cast<QWidget*>(php_qt_fetch(z_0));
 
-			if(obj_z_0->inherits("QWidget")) {
-				obj->addWidget(obj_z_0, (int) Z_LVAL_P(z_1), (Qt::Alignment) Z_LVAL_P(z_2));
-			    RETURN_NULL();
-			} else { php_error(E_ERROR,"argument is no QWidget"); }
-			} else { php_error(E_ERROR,"argument not allowed"); }
+			    if(obj_z_0->inherits("QWidget")) {
+				    obj->addWidget(obj_z_0, (int) Z_LVAL_P(z_1), (Qt::Alignment) Z_LVAL_P(z_2));
+			        RETURN_NULL();
+			    } else { php_error(E_ERROR,"argument is no QWidget"); }
+//			} else { php_error(E_ERROR,"argument not allowed"); }
 		}
 	}
 /*! o public*/

Modified: trunk/qt/classes/qlineedit.cpp
===================================================================
--- trunk/qt/classes/qlineedit.cpp	2006-05-14 14:10:30 UTC (rev 237)
+++ trunk/qt/classes/qlineedit.cpp	2006-05-15 10:18:29 UTC (rev 238)
@@ -276,7 +276,7 @@
 	if (ZEND_NUM_ARGS() == 1){
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
+			if(Z_TYPE_P(z_0) == IS_BOOL){
 			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
 
 
@@ -446,15 +446,34 @@
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+			    QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
 
 
-			if(obj_z_0->inherits("QWidget")) {
-				QLineEdit *QLineEdit_ptr = new QLineEdit((QWidget*) obj_z_0);
+			    if(obj_z_0->inherits("QWidget")) {
+				    QLineEdit *QLineEdit_ptr = new QLineEdit((QWidget*) obj_z_0);
+				    PHP_QT_REGISTER(QLineEdit_ptr);
+
+				    RETURN_NULL();
+			    }
+			} else if(Z_TYPE_P(z_0) == IS_STRING){
+
+			    QString *str = new QString("");
+			    *str = QString(QString::fromUtf8(Z_STRVAL_P(z_0)));
+
+			    zend_class_entry *ce;                                   
+			    object_init_ex(z_0, QString_ce_ptr);
+			    zend_rsrc_list_entry le_;                            
+			    le_.ptr = str;
+			    php_qt_register(z_0,le_);                                 
+
+			    QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+
+				QLineEdit *QLineEdit_ptr = new QLineEdit((const QString&) *obj_z_0);
 				PHP_QT_REGISTER(QLineEdit_ptr);
 				RETURN_NULL();
+
 			}
-			}
+            
 		}
 	}
 		/* oo public*/
@@ -480,7 +499,6 @@
 
 			}
 
-
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
 			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
 			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
@@ -567,9 +585,9 @@
 				php_error(E_ERROR,"Object not found");
 			}
 				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
+				object_init_ex(return_value, QString_ce_ptr);     
 				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
+				le.ptr = return_object;
 				php_qt_register(return_value,le);                   
 				return;                                             
 	}
@@ -1153,10 +1171,20 @@
 
 			if(!strcmp(Z_OBJCE_P(z_0)->name,"QString")) {
 				obj->setText((const QString&) *obj_z_0);
-			RETURN_NULL();
+			    RETURN_NULL();
 			}
 			}
+			if(Z_TYPE_P(z_0) == IS_STRING){
+
+			    QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+
+				obj->setText(Z_STRVAL_P(z_0));
+			    RETURN_NULL();
+			}
+			
+
 		}
+
 	}
 }
 



From tm243 at berlios.de  Mon May 15 12:21:41 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Mon, 15 May 2006 12:21:41 +0200
Subject: [Php-qt-svn] r239 - in trunk: . qt qt/classes
Message-ID: <200605151021.k4FALfc4030484@sheep.berlios.de>

Author: tm243
Date: 2006-05-15 12:21:40 +0200 (Mon, 15 May 2006)
New Revision: 239

Added:
   trunk/qt/classes/qdialog.cpp
   trunk/qt/classes/qtoolbutton.cpp
Modified:
   trunk/config.m4
   trunk/qt/ag_extern_zend_class_entry.inc
   trunk/qt/ag_php_qt_cpp.inc
   trunk/qt/ag_qt_minit.inc
   trunk/qt/ag_zend_class_entry.inc
   trunk/qt/ag_zend_php_qt.inc
Log:
new classes: qdialog, qtoolbutton.

Modified: trunk/config.m4
===================================================================
--- trunk/config.m4	2006-05-15 10:18:29 UTC (rev 238)
+++ trunk/config.m4	2006-05-15 10:21:40 UTC (rev 239)
@@ -111,6 +111,7 @@
 	qt/classes/qcontextmenuevent.cpp \
 	qt/classes/qdate.cpp \
 	qt/classes/qdatetime.cpp \
+	qt/classes/qdialog.cpp \ 
 	qt/classes/qdragenterevent.cpp \
 	qt/classes/qdragleaveevent.cpp \
 	qt/classes/qdragmoveevent.cpp \
@@ -148,6 +149,7 @@
 	qt/classes/qtimer.cpp \
 	qt/classes/qtimerevent.cpp \
 	qt/classes/qtoolbarchangeevent.cpp \
+	qt/classes/qtoolbutton.cpp \ 
 	qt/classes/qwhatsthisclickedevent.cpp \
 	qt/classes/qwheelevent.cpp \
 	qt/classes/qwidgetdata.cpp \

Modified: trunk/qt/ag_extern_zend_class_entry.inc
===================================================================
--- trunk/qt/ag_extern_zend_class_entry.inc	2006-05-15 10:18:29 UTC (rev 238)
+++ trunk/qt/ag_extern_zend_class_entry.inc	2006-05-15 10:21:40 UTC (rev 239)
@@ -26,6 +26,8 @@
 void 	_register_QDate();
 extern zend_class_entry *QDateTime_ce_ptr;
 void 	_register_QDateTime();
+extern zend_class_entry *QDialog_ce_ptr;
+void 	_register_QDialog();
 extern zend_class_entry *QDragEnterEvent_ce_ptr;
 void 	_register_QDragEnterEvent();
 extern zend_class_entry *QDragLeaveEvent_ce_ptr;
@@ -118,6 +120,8 @@
 void 	_register_QTimerEvent();
 extern zend_class_entry *QToolBarChangeEvent_ce_ptr;
 void 	_register_QToolBarChangeEvent();
+extern zend_class_entry *QToolButton_ce_ptr;
+void 	_register_QToolButton();
 extern zend_class_entry *QVBoxLayout_ce_ptr;
 void 	_register_QVBoxLayout();
 extern zend_class_entry *QWhatsThisClickedEvent_ce_ptr;

Modified: trunk/qt/ag_php_qt_cpp.inc
===================================================================
--- trunk/qt/ag_php_qt_cpp.inc	2006-05-15 10:18:29 UTC (rev 238)
+++ trunk/qt/ag_php_qt_cpp.inc	2006-05-15 10:21:40 UTC (rev 239)
@@ -457,6 +457,7 @@
     QDate_ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);
 
 }
+
 static zend_function_entry QDateTime_methods[] = {
 	ZEND_ME(QDateTime,time,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QDateTime,date,NULL,ZEND_ACC_PUBLIC)
@@ -492,6 +493,42 @@
     QDateTime_ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);
 
 }
+static zend_function_entry QDialog_methods[] = {
+	ZEND_ME(QDialog,tr,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+	ZEND_ME(QDialog,setSizeGripEnabled,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,setModal,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,exec,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,showExtension,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,rejected,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,isSizeGripEnabled,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,event,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,setExtension,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,finished,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,result,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,orientation,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog, __construct,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+	ZEND_ME(QDialog,qObject,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,sizeHint,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,minimumSizeHint,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,extension,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,setOrientation,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,setVisible,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,setResult,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,accepted,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QDialog,trUtf8,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+
+    {NULL,NULL,NULL}
+};
+
+void _register_QDialog(TSRMLS_D)
+{
+    zend_class_entry ce;
+    INIT_CLASS_ENTRY(ce,"QDialog",QDialog_methods);
+    QDialog_ce_ptr = zend_register_internal_class_ex(&ce TSRMLS_CC, QWidget_ce_ptr,NULL TSRMLS_CC);
+
+
+}
 static zend_function_entry QDragEnterEvent_methods[] = {
 
     {NULL,NULL,NULL}
@@ -1674,6 +1711,40 @@
 
 
 }
+static zend_function_entry QToolButton_methods[] = {
+	ZEND_ME(QToolButton,tr,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+	ZEND_ME(QToolButton,defaultAction,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,showMenu,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,autoRaise,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+	ZEND_ME(QToolButton,arrowType,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,setDefaultAction,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,popupMode,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,qObject,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,minimumSizeHint,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,sizeHint,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton, __construct,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,menu,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,triggered,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,toolButtonStyle,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,setPopupMode,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,setToolButtonStyle,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,trUtf8,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+	ZEND_ME(QToolButton,setMenu,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,setAutoRaise,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QToolButton,setArrowType,NULL,ZEND_ACC_PUBLIC)
+
+    {NULL,NULL,NULL}
+};
+
+void _register_QToolButton(TSRMLS_D)
+{
+    zend_class_entry ce;
+    INIT_CLASS_ENTRY(ce,"QToolButton",QToolButton_methods);
+    QToolButton_ce_ptr = zend_register_internal_class_ex(&ce TSRMLS_CC, QAbstractButton_ce_ptr,NULL TSRMLS_CC);
+
+
+}
 static zend_function_entry QVBoxLayout_methods[] = {
 	ZEND_ME(QVBoxLayout,tr,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QVBoxLayout,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)

Modified: trunk/qt/ag_qt_minit.inc
===================================================================
--- trunk/qt/ag_qt_minit.inc	2006-05-15 10:18:29 UTC (rev 238)
+++ trunk/qt/ag_qt_minit.inc	2006-05-15 10:21:40 UTC (rev 239)
@@ -175,6 +175,10 @@
 
 	_register_QDate(TSRMLS_C);
 
+	_register_QDialog(TSRMLS_C);
+//	  REGISTER_LONG_CONSTANT("QDIALOG_DIALOGCODE_REJECTED", QDialog::Rejected, CONST_CS | CONST_PERSISTENT);
+//	  REGISTER_LONG_CONSTANT("QDIALOG_DIALOGCODE_ACCEPTED", QDialog::Accepted, CONST_CS | CONST_PERSISTENT);
+
 	_register_QDateTime(TSRMLS_C);
 
 	_register_QDragEnterEvent(TSRMLS_C);
@@ -456,6 +460,11 @@
 
 	_register_QToolBarChangeEvent(TSRMLS_C);
 
+	_register_QToolButton(TSRMLS_C);
+//	  REGISTER_LONG_CONSTANT("QTOOLBUTTON_TOOLBUTTONPOPUPMODE_DELAYEDPOPUP", QToolButton::DelayedPopup, CONST_CS | CONST_PERSISTENT);
+//	  REGISTER_LONG_CONSTANT("QTOOLBUTTON_TOOLBUTTONPOPUPMODE_MENUBUTTONPOPUP", QToolButton::MenuButtonPopup, CONST_CS | CONST_PERSISTENT);
+//	  REGISTER_LONG_CONSTANT("QTOOLBUTTON_TOOLBUTTONPOPUPMODE_INSTANTPOPUP", QToolButton::InstantPopup, CONST_CS | CONST_PERSISTENT);
+
 	_register_QVBoxLayout(TSRMLS_C);
 
 	_register_QWhatsThisClickedEvent(TSRMLS_C);

Modified: trunk/qt/ag_zend_class_entry.inc
===================================================================
--- trunk/qt/ag_zend_class_entry.inc	2006-05-15 10:18:29 UTC (rev 238)
+++ trunk/qt/ag_zend_class_entry.inc	2006-05-15 10:21:40 UTC (rev 239)
@@ -12,6 +12,7 @@
 zend_class_entry *QCoreApplication_ce_ptr;
 zend_class_entry *QDate_ce_ptr;
 zend_class_entry *QDateTime_ce_ptr;
+zend_class_entry *QDialog_ce_ptr;
 zend_class_entry *QDragEnterEvent_ce_ptr;
 zend_class_entry *QDragLeaveEvent_ce_ptr;
 zend_class_entry *QDragMoveEvent_ce_ptr;
@@ -58,6 +59,7 @@
 zend_class_entry *QTimer_ce_ptr;
 zend_class_entry *QTimerEvent_ce_ptr;
 zend_class_entry *QToolBarChangeEvent_ce_ptr;
+zend_class_entry *QToolButton_ce_ptr;
 zend_class_entry *QVBoxLayout_ce_ptr;
 zend_class_entry *QWhatsThisClickedEvent_ce_ptr;
 zend_class_entry *QWheelEvent_ce_ptr;

Modified: trunk/qt/ag_zend_php_qt.inc
===================================================================
--- trunk/qt/ag_zend_php_qt.inc	2006-05-15 10:18:29 UTC (rev 238)
+++ trunk/qt/ag_zend_php_qt.inc	2006-05-15 10:21:40 UTC (rev 239)
@@ -314,6 +314,29 @@
 ZEND_METHOD(QDateTime, toUTC);
 ZEND_METHOD(QDateTime, toLocalTime);
 ZEND_METHOD(QDateTime, setTimeSpec);
+ZEND_METHOD(QDialog, tr);
+ZEND_METHOD(QDialog, setSizeGripEnabled);
+ZEND_METHOD(QDialog, setModal);
+ZEND_METHOD(QDialog, exec);
+ZEND_METHOD(QDialog, showExtension);
+ZEND_METHOD(QDialog, rejected);
+ZEND_METHOD(QDialog, isSizeGripEnabled);
+ZEND_METHOD(QDialog, event);
+ZEND_METHOD(QDialog, setExtension);
+ZEND_METHOD(QDialog, finished);
+ZEND_METHOD(QDialog, result);
+ZEND_METHOD(QDialog, orientation);
+ZEND_METHOD(QDialog, __construct);
+ZEND_METHOD(QDialog, staticMetaObject);
+ZEND_METHOD(QDialog, qObject);
+ZEND_METHOD(QDialog, sizeHint);
+ZEND_METHOD(QDialog, minimumSizeHint);
+ZEND_METHOD(QDialog, extension);
+ZEND_METHOD(QDialog, setOrientation);
+ZEND_METHOD(QDialog, setVisible);
+ZEND_METHOD(QDialog, setResult);
+ZEND_METHOD(QDialog, accepted);
+ZEND_METHOD(QDialog, trUtf8);
 ZEND_METHOD(QDragMoveEvent, accept);
 ZEND_METHOD(QDragMoveEvent, answerRect);
 ZEND_METHOD(QDragMoveEvent, ignore);
@@ -907,6 +930,27 @@
 ZEND_METHOD(QTimer, start);
 ZEND_METHOD(QTimerEvent, timerId);
 ZEND_METHOD(QToolBarChangeEvent, toggle);
+ZEND_METHOD(QToolButton, tr);
+ZEND_METHOD(QToolButton, defaultAction);
+ZEND_METHOD(QToolButton, showMenu);
+ZEND_METHOD(QToolButton, autoRaise);
+ZEND_METHOD(QToolButton, staticMetaObject);
+ZEND_METHOD(QToolButton, arrowType);
+ZEND_METHOD(QToolButton, setDefaultAction);
+ZEND_METHOD(QToolButton, popupMode);
+ZEND_METHOD(QToolButton, qObject);
+ZEND_METHOD(QToolButton, minimumSizeHint);
+ZEND_METHOD(QToolButton, sizeHint);
+ZEND_METHOD(QToolButton, __construct);
+ZEND_METHOD(QToolButton, menu);
+ZEND_METHOD(QToolButton, triggered);
+ZEND_METHOD(QToolButton, toolButtonStyle);
+ZEND_METHOD(QToolButton, setPopupMode);
+ZEND_METHOD(QToolButton, setToolButtonStyle);
+ZEND_METHOD(QToolButton, trUtf8);
+ZEND_METHOD(QToolButton, setMenu);
+ZEND_METHOD(QToolButton, setAutoRaise);
+ZEND_METHOD(QToolButton, setArrowType);
 ZEND_METHOD(QVBoxLayout, tr);
 ZEND_METHOD(QVBoxLayout, staticMetaObject);
 ZEND_METHOD(QVBoxLayout, qObject);

Added: trunk/qt/classes/qdialog.cpp
===================================================================
--- trunk/qt/classes/qdialog.cpp	2006-05-15 10:18:29 UTC (rev 238)
+++ trunk/qt/classes/qdialog.cpp	2006-05-15 10:21:40 UTC (rev 239)
@@ -0,0 +1,880 @@
+/*
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2005
+ * Thomas Moenicke <tm at ippfp.org>,
+ * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * QDialog.cpp - QDialog PHP implementation.
+ * begin           : Thu May 11 20:44:24 2006
+ * generated by    : moni using kalyptus 0.9.
+ */
+
+#include <iostream>
+using namespace std;
+
+#include "../php_qt.h"
+
+
+#include <QDialog>
+#include <QMetaMethod>
+
+class QDialog_moc : public QDialog
+{
+    public:
+        QDialog_moc(zval* zend_ptr);
+
+        zval* zend_ptr;
+        QMetaObject* dynamicMetaObject;
+
+        const QMetaObject* metaObject() const;
+        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+        
+};
+
+const QMetaObject *QDialog_moc::metaObject() const
+{
+    return php_qt_getMocData(this->zend_ptr,"QDialog",&staticMetaObject);;
+}
+
+QDialog_moc::QDialog_moc(zval* zend_ptr)
+{
+    this->zend_ptr = zend_ptr;
+    dynamicMetaObject = new QMetaObject;
+    dynamicMetaObject = php_qt_getMocData(this->zend_ptr,"QDialog",&staticMetaObject);
+}
+
+int QDialog_moc::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+
+    QMetaObject* d = (QMetaObject*) this->metaObject();
+    char* method_name = new char[strlen((d->method(_id)).signature())];
+    strcpy(method_name,(char*) (d->method(_id)).signature());
+
+    // breaks the string at the first bracket
+    int i;
+    for(i = 0; i < strlen(method_name); i++){
+        if(method_name[i] == 40){
+            method_name[i] = 0;
+            break;
+        }
+    }
+
+    // is a Slot
+    if(d->method(_id).methodType() == QMetaMethod::Slot){
+
+        int j = 0;
+        zval** args[1];
+        QList<QByteArray> qargs = d->method(_id).parameterTypes();
+
+        for(i = 0; i < qargs.count(); i++){
+
+            zval *arg;
+            MAKE_STD_ZVAL(arg);
+
+            // invoke to zend types
+            if(!strncmp("int",(const char*) qargs[i],3)){
+                ZVAL_LONG(arg, *reinterpret_cast< int*>(_a[i+1]));
+            } else if(!strncmp("char*",(const char*) qargs[i],5)){
+                ZVAL_STRING(arg, *reinterpret_cast< char**>(_a[i+1]), 1);
+            } else if(!strncmp("bool",(const char*) qargs[i],4)){
+                ZVAL_BOOL(arg, *reinterpret_cast< bool*>(_a[i+1]));
+            } else if(!strncmp("double",(const char*) qargs[i],4)){
+                ZVAL_DOUBLE(arg, *reinterpret_cast< double*>(_a[i+1]));
+            } else {
+                    // must be an object
+                    zend_class_entry *ce;
+                    object_init_ex(arg, QDialog_ce_ptr);
+                    zend_rsrc_list_entry le;
+                    le.ptr = *reinterpret_cast< QObject**>(_a[1]);
+                    php_qt_register(arg, le);
+                    
+            }
+
+            args[j++] = &arg;
+
+        }
+
+        php_qt_callmethod(this->zend_ptr, method_name, j, args);
+
+    // is a signal
+    } else {
+        void *_b[] = { 0, _a[1] };
+        QMetaObject::activate(this, d, 0, _b);
+    }
+
+    delete d;
+    delete method_name;
+
+    return _id;
+
+}
+
+
+/*		public enumDialogCode:long {
+			DialogCode = 0,
+			DialogCode = 1
+		}
+*/
+/*!
+ *    @class     QDialog
+ *    @function  tr
+ *
+ *    @flags    s
+ *    @access    public
+ *    @return    QString
+ *    @param     const char *, const char * = 0 
+ */
+ZEND_METHOD(QDialog, tr)
+{
+/*! ss public*/
+/*! const char* , const char* ,  */
+  if (ZEND_NUM_ARGS() == 2) {
+    zval *z_0;                  /// define ZVAL
+    zval *z_1;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING) {
+        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+        QString *return_object;
+
+        if (getThis() != NULL) {
+/// return value is object: QString
+          *return_object = static_cast < QString > (obj->tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
+/// check whether method call is static.
+        } else {
+          return_object = (QString *) malloc(sizeof (QDialog::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));       /// memory allocation
+          *return_object = static_cast < QString > (QDialog::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
+        } zend_class_entry *ce;
+
+        object_init_ex(return_value, QDialog_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = return_object;
+        php_qt_register(return_value, le);
+        return;
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARG
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_STRING) {
+        QString *return_object;
+        if (getThis() != NULL) {
+/// return value is object: QString
+        QDialog *obj = static_cast<QDialog *>(PHP_QT_FETCH());
+          *return_object = static_cast < QString > (obj->tr((const char *)Z_STRVAL_P(z_0)));
+/// check whether method call is static.
+        } else {
+          return_object = (QString *) malloc(sizeof (QDialog::tr((const char *)Z_STRVAL_P(z_0))));   /// memory allocation
+          *return_object = static_cast < QString > (QDialog::tr((const char *)Z_STRVAL_P(z_0)));
+        } zend_class_entry *ce;
+        object_init_ex(return_value, QToolButton_ce_ptr);
+        zend_rsrc_list_entry le;
+        le.ptr = return_object;
+        php_qt_register(return_value, le);
+        return;
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  setSizeGripEnabled
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    bool
+ */
+ZEND_METHOD(QDialog, setSizeGripEnabled)
+{
+/*! l public*/
+/*! int ,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_LONG) {
+        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+        void *return_object;
+
+        if (getThis() != NULL) {
+          obj->setSizeGripEnabled((bool) Z_LVAL_P(z_0));
+          RETURN_NULL();
+        }                       /// END getThis(), NULL
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  setModal
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    bool modal
+ */
+ZEND_METHOD(QDialog, setModal)
+{
+/*! l public*/
+/*! int modal,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_LONG) {
+        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+        void *return_object;
+
+        if (getThis() != NULL) {
+          obj->setModal((bool) Z_LVAL_P(z_0));
+          RETURN_NULL();
+        }                       /// END getThis(), NULL
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  exec
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    int
+ *    @param    
+ */
+ZEND_METHOD(QDialog, exec)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    int *return_object;
+
+    if (getThis() != NULL) {
+      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+      RETURN_LONG(obj->exec());
+    }                           /// 5 END getThis(), simple types
+  }
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  showExtension
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    bool
+ */
+ZEND_METHOD(QDialog, showExtension)
+{
+/*! l public*/
+/*! int ,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_LONG) {
+        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+        void *return_object;
+
+        if (getThis() != NULL) {
+          obj->showExtension((bool) Z_LVAL_P(z_0));
+          RETURN_NULL();
+        }                       /// END getThis(), NULL
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  rejected
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    
+ */
+ZEND_METHOD(QDialog, rejected)
+{
+/*  if (ZEND_NUM_ARGS() == 0) {
+    void *return_object;
+
+    if (getThis() != NULL) {
+      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+      obj->rejected();
+      RETURN_NULL();
+    }                           /// END getThis(), NULL
+  }*/
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  isSizeGripEnabled
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    bool
+ *    @param    
+ */
+ZEND_METHOD(QDialog, isSizeGripEnabled)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    bool *return_object;
+
+    if (getThis() != NULL) {
+      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+      RETURN_BOOL(obj->isSizeGripEnabled());
+    }                           /// 5 END getThis(), simple types
+  }
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  event
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    bool
+ *    @param    QEvent *
+ */
+ZEND_METHOD(QDialog, event)
+{
+///qt_QEvent*
+/*! o public*/
+/*! qt_QEvent* ,  */
+/*  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_OBJECT) {
+        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+
+        if (!strcmp(Z_OBJCE_P(z_0)->name, "QEvent")) {
+          bool *return_object;
+
+          if (getThis() != NULL) {
+            RETURN_BOOL(obj->event((QEvent *) obj_z_0));
+          }                     /// 5 END getThis(), simple types
+        }
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS*/
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  adjustPosition
+ *
+ *    @flags    
+ *    @access    protected
+ *    @return    void
+ *    @param    QWidget*
+ */
+// method adjustPosition is protected, skipped.
+
+/*!
+ *    @class     QDialog
+ *    @function  setExtension
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    QWidget* extension
+ */
+ZEND_METHOD(QDialog, setExtension)
+{
+///QWidget*
+/*! o public*/
+/*! QWidget* extension,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_OBJECT) {
+        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+
+        if (obj_z_0->inherits("QWidget")) {
+          void *return_object;
+
+          if (getThis() != NULL) {
+            obj->setExtension((QWidget *) obj_z_0);
+            RETURN_NULL();
+          }                     /// END getThis(), NULL
+        }
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  finished
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    Q_SIGNALS: void
+ *    @param    int result
+ */
+ZEND_METHOD(QDialog, finished)
+{
+/*! l public*/
+/*! int result,  */
+/*  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_LONG) {
+        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+        void *return_object;
+
+        if (getThis() != NULL) {
+          obj->finished((int)Z_LVAL_P(z_0));
+          RETURN_NULL();
+        }                       /// END getThis(), NULL
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS*/
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  result
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    int
+ *    @param    
+ */
+ZEND_METHOD(QDialog, result)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    int *return_object;
+
+    if (getThis() != NULL) {
+      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+      RETURN_LONG(obj->result());
+    }                           /// 5 END getThis(), simple types
+  }
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  orientation
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    Qt::Orientation
+ *    @param    
+ */
+ZEND_METHOD(QDialog, orientation)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    Qt::Orientation * return_object;
+    if (getThis() != NULL) {
+      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+      RETURN_LONG(obj->orientation());
+    }                           /// 5 END getThis(), simple types
+  }
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  QDialog
+ *
+ *    @flags    t
+ *    @access    public
+ *    @return    
+ *    @param    QWidget *parent = 0, Qt::WFlags f = 0
+ */
+ZEND_METHOD(QDialog, __construct)
+{
+///QWidget*
+/*! ol public*/
+/*! QWidget* parent, int f,  */
+
+  if (ZEND_NUM_ARGS() == 0) {
+
+    QDialog_moc *QDialog_ptr = new QDialog_moc(getThis());
+
+    PHP_QT_REGISTER(QDialog_ptr);
+    RETURN_NULL();
+                                /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+
+  if (ZEND_NUM_ARGS() == 2) {
+    zval *z_0;                  /// define ZVAL
+    zval *z_1;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG) {
+        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+
+        if (obj_z_0->inherits("QWidget")) {
+          QDialog *QDialog_ptr = new QDialog((QWidget *) obj_z_0, (Qt::WFlags) Z_LVAL_P(z_1));
+
+          PHP_QT_REGISTER(QDialog_ptr);
+          RETURN_NULL();
+        }
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  staticMetaObject
+ *
+ *    @flags    s
+ *    @access    public
+ *    @return    QMetaObject*
+ *    @param    
+ */
+ZEND_METHOD(QDialog, staticMetaObject)
+{
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  qObject
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    QObject*
+ *    @param    
+ */
+ZEND_METHOD(QDialog, qObject)
+{
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  sizeHint
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    QSize
+ *    @param    
+ */
+ZEND_METHOD(QDialog, sizeHint)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    QSize *return_object;
+
+    if (getThis() != NULL) {
+      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+/// return value is object: QSize
+      *return_object = static_cast < QSize > (obj->sizeHint());
+    } else {                    /// END getThis(), static
+      php_error(E_ERROR, "Object not found");
+    }
+    zend_class_entry *ce;
+
+    object_init_ex(return_value, QDialog_ce_ptr);
+    zend_rsrc_list_entry le;
+
+    le.ptr = return_object;
+    php_qt_register(return_value, le);
+    return;
+  }
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  minimumSizeHint
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    QSize
+ *    @param    
+ */
+ZEND_METHOD(QDialog, minimumSizeHint)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    QSize *return_object;
+
+    if (getThis() != NULL) {
+      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+/// return value is object: QSize
+      *return_object = static_cast < QSize > (obj->minimumSizeHint());
+    } else {                    /// END getThis(), static
+      php_error(E_ERROR, "Object not found");
+    }
+    zend_class_entry *ce;
+
+    object_init_ex(return_value, QDialog_ce_ptr);
+    zend_rsrc_list_entry le;
+
+    le.ptr = return_object;
+    php_qt_register(return_value, le);
+    return;
+  }
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  extension
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    QWidget*
+ *    @param    
+ */
+ZEND_METHOD(QDialog, extension)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    QWidget **return_object;
+
+    if (getThis() != NULL) {
+      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+/// return: pointer
+
+/// return value is object: QWidget*
+      *return_object = static_cast < QWidget * >(obj->extension());
+    } else {                    /// END getThis(), static
+      php_error(E_ERROR, "Object not found");
+    }
+    zend_class_entry *ce;
+
+    object_init_ex(return_value, QDialog_ce_ptr);
+    zend_rsrc_list_entry le;
+
+    le.ptr = return_object[0];
+    php_qt_register(return_value, le);
+    return;
+  }
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  setOrientation
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    Qt::Orientation orientation
+ */
+ZEND_METHOD(QDialog, setOrientation)
+{
+/*! l public*/
+/*! int orientation,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_LONG) {
+        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+        void *return_object;
+
+        if (getThis() != NULL) {
+          obj->setOrientation((Qt::Orientation) Z_LVAL_P(z_0));
+          RETURN_NULL();
+        }                       /// END getThis(), NULL
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  setVisible
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    bool visible
+ */
+ZEND_METHOD(QDialog, setVisible)
+{
+/*! l public*/
+/*! int visible,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_LONG) {
+        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+        void *return_object;
+
+        if (getThis() != NULL) {
+          obj->setVisible((bool) Z_LVAL_P(z_0));
+          RETURN_NULL();
+        }                       /// END getThis(), NULL
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  setResult
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    int r
+ */
+ZEND_METHOD(QDialog, setResult)
+{
+/*! l public*/
+/*! int r,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_LONG) {
+        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+        void *return_object;
+
+        if (getThis() != NULL) {
+          obj->setResult((int)Z_LVAL_P(z_0));
+          RETURN_NULL();
+        }                       /// END getThis(), NULL
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  eventFilter
+ *
+ *    @flags    
+ *    @access    protected
+ *    @return    bool
+ *    @param    QObject *, QEvent *
+ */
+// method eventFilter is protected, skipped.
+
+/*!
+ *    @class     QDialog
+ *    @function  accepted
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    
+ */
+ZEND_METHOD(QDialog, accepted)
+{
+/*  if (ZEND_NUM_ARGS() == 0) {
+    void *return_object;
+
+    if (getThis() != NULL) {
+      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+      obj->accepted();
+      RETURN_NULL();
+    }                           /// END getThis(), NULL
+  }*/
+}
+
+/*!
+ *    @class     QDialog
+ *    @function  trUtf8
+ *
+ *    @flags    s
+ *    @access    public
+ *    @return    QString
+ *    @param     const char *, const char * = 0 
+ */
+ZEND_METHOD(QDialog, trUtf8)
+{
+/*! ss public*/
+/*! const char* , const char* ,  */
+  if (ZEND_NUM_ARGS() == 2) {
+    zval *z_0;                  /// define ZVAL
+    zval *z_1;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING) {
+        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+
+        QString *return_object;
+
+        if (getThis() != NULL) {
+/// return value is object: QString
+          *return_object = static_cast < QString > (obj->trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
+/// check whether method call is static.
+        } else {
+          return_object = (QString *) malloc(sizeof (QDialog::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));   /// memory allocation
+          *return_object = static_cast < QString > (QDialog::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
+        } zend_class_entry *ce;
+
+        object_init_ex(return_value, QDialog_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = return_object;
+        php_qt_register(return_value, le);
+        return;
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+
+PHP_QT_DESTRUCT(QDialog);

Added: trunk/qt/classes/qtoolbutton.cpp
===================================================================
--- trunk/qt/classes/qtoolbutton.cpp	2006-05-15 10:18:29 UTC (rev 238)
+++ trunk/qt/classes/qtoolbutton.cpp	2006-05-15 10:21:40 UTC (rev 239)
@@ -0,0 +1,749 @@
+/*
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2005
+ * Thomas Moenicke <tm at ippfp.org>,
+ * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * QToolButton.cpp - QToolButton PHP implementation.
+ * begin           : Thu May 11 21:32:50 2006
+ * generated by    : moni using kalyptus 0.9.
+ */
+
+#include <iostream>
+using namespace std;
+
+#include "../php_qt.h"
+
+
+#include <QToolButton>
+
+
+/*		public enumToolButtonPopupMode:long {
+			ToolButtonPopupMode = 0,
+			ToolButtonPopupMode = 1,
+			ToolButtonPopupMode = 2
+		}
+*/
+/*!
+ *    @class     QToolButton
+ *    @function  tr
+ *
+ *    @flags    s
+ *    @access    public
+ *    @return    QString
+ *    @param     const char *, const char * = 0 
+ */
+ZEND_METHOD(QToolButton, tr)
+{
+/*! ss public*/
+/*! const char* , const char* ,  */
+  if (ZEND_NUM_ARGS() == 2) {
+    zval *z_0;                  /// define ZVAL
+    zval *z_1;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING) {
+        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+        QString *return_object;
+
+        if (getThis() != NULL) {
+/// return value is object: QString
+          *return_object = static_cast < QString > (obj->tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
+/// check whether method call is static.
+        } else {
+          return_object = (QString *) malloc(sizeof (QToolButton::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));   /// memory allocation
+          *return_object = static_cast < QString > (QToolButton::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
+        } zend_class_entry *ce;
+
+        object_init_ex(return_value, QToolButton_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = return_object;
+        php_qt_register(return_value, le);
+        return;
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_STRING) {
+        QString *return_object;
+
+        if (getThis() != NULL) {
+/// return value is object: QString
+          QToolButton *obj = static_cast<QToolButton *>(PHP_QT_FETCH());
+          *return_object = static_cast < QString > (obj->tr((const char *)Z_STRVAL_P(z_0)));
+/// check whether method call is static.
+        } else {
+          return_object = (QString *) malloc(sizeof (QToolButton::tr((const char *)Z_STRVAL_P(z_0))));   /// memory allocation
+          *return_object = static_cast < QString > (QToolButton::tr((const char *)Z_STRVAL_P(z_0)));
+        } zend_class_entry *ce;
+
+        object_init_ex(return_value, QToolButton_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = return_object;
+        php_qt_register(return_value, le);
+        return;
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  defaultAction
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    QAction *
+ *    @param    
+ */
+ZEND_METHOD(QToolButton, defaultAction)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    QAction **return_object;
+
+    if (getThis() != NULL) {
+      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+/// return: pointer
+
+/// return value is object: QAction *
+      *return_object = static_cast < QAction * >(obj->defaultAction());
+    } else {                    /// END getThis(), static
+      php_error(E_ERROR, "Object not found");
+    }
+    zend_class_entry *ce;
+
+    object_init_ex(return_value, QToolButton_ce_ptr);
+    zend_rsrc_list_entry le;
+
+    le.ptr = return_object[0];
+    php_qt_register(return_value, le);
+    return;
+  }
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  showMenu
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    
+ */
+ZEND_METHOD(QToolButton, showMenu)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    void *return_object;
+
+    if (getThis() != NULL) {
+      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+      obj->showMenu();
+      RETURN_NULL();
+    }                           /// END getThis(), NULL
+  }
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  autoRaise
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    bool
+ *    @param    
+ */
+ZEND_METHOD(QToolButton, autoRaise)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    bool *return_object;
+
+    if (getThis() != NULL) {
+      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+      RETURN_BOOL(obj->autoRaise());
+    }                           /// 5 END getThis(), simple types
+  }
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  staticMetaObject
+ *
+ *    @flags    s
+ *    @access    public
+ *    @return    QMetaObject*
+ *    @param    
+ */
+ZEND_METHOD(QToolButton, staticMetaObject)
+{
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  arrowType
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    Qt::ArrowType
+ *    @param    
+ */
+ZEND_METHOD(QToolButton, arrowType)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    Qt::ArrowType * return_object;
+    if (getThis() != NULL) {
+      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+      RETURN_LONG(obj->arrowType());
+    }                           /// 5 END getThis(), simple types
+  }
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  setDefaultAction
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    QAction *
+ */
+ZEND_METHOD(QToolButton, setDefaultAction)
+{
+///qt_QAction*
+/*! o public*/
+/*! qt_QAction* ,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_OBJECT) {
+        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+
+        if (obj_z_0->inherits("QAction")) {
+          void *return_object;
+
+          if (getThis() != NULL) {
+            obj->setDefaultAction((QAction *) obj_z_0);
+            RETURN_NULL();
+          }                     /// END getThis(), NULL
+        }
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  popupMode
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    ToolButtonPopupMode
+ *    @param    
+ */
+ZEND_METHOD(QToolButton, popupMode)
+{
+/*  if (ZEND_NUM_ARGS() == 0) {
+    ToolButtonPopupMode *return_object;
+
+    if (getThis() != NULL) {
+      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+      obj->popupMode();
+      RETURN_NULL();
+    }                           /// END getThis(), NULL
+  }*/
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  qObject
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    QObject*
+ *    @param    
+ */
+ZEND_METHOD(QToolButton, qObject)
+{
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  minimumSizeHint
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    QSize
+ *    @param    
+ */
+ZEND_METHOD(QToolButton, minimumSizeHint)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    QSize *return_object;
+
+    if (getThis() != NULL) {
+      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+/// return value is object: QSize
+      *return_object = static_cast < QSize > (obj->minimumSizeHint());
+    } else {                    /// END getThis(), static
+      php_error(E_ERROR, "Object not found");
+    }
+    zend_class_entry *ce;
+
+    object_init_ex(return_value, QToolButton_ce_ptr);
+    zend_rsrc_list_entry le;
+
+    le.ptr = return_object;
+    php_qt_register(return_value, le);
+    return;
+  }
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  sizeHint
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    QSize
+ *    @param    
+ */
+ZEND_METHOD(QToolButton, sizeHint)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    QSize *return_object;
+
+    if (getThis() != NULL) {
+      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+/// return value is object: QSize
+      *return_object = static_cast < QSize > (obj->sizeHint());
+    } else {                    /// END getThis(), static
+      php_error(E_ERROR, "Object not found");
+    }
+    zend_class_entry *ce;
+
+    object_init_ex(return_value, QToolButton_ce_ptr);
+    zend_rsrc_list_entry le;
+
+    le.ptr = return_object;
+    php_qt_register(return_value, le);
+    return;
+  }
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  QToolButton
+ *
+ *    @flags    t
+ *    @access    public
+ *    @return    
+ *    @param    QWidget * parent=0
+ */
+ZEND_METHOD(QToolButton, __construct)
+{
+///QWidget*
+/*! o public*/
+/*! QWidget* parent,  */
+
+  if (ZEND_NUM_ARGS() == 0) {
+
+    QToolButton *QToolButton_ptr = new QToolButton();
+    PHP_QT_REGISTER(QToolButton_ptr);
+    RETURN_NULL();
+
+  }                             /// END ZEND_NUM_ARGS
+
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_OBJECT) {
+        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+
+        if (obj_z_0->inherits("QWidget")) {
+          QToolButton *QToolButton_ptr = new QToolButton((QWidget *) obj_z_0);
+
+          PHP_QT_REGISTER(QToolButton_ptr);
+          RETURN_NULL();
+        }
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  menu
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    QMenu*
+ *    @param    
+ */
+ZEND_METHOD(QToolButton, menu)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    QMenu **return_object;
+
+    if (getThis() != NULL) {
+      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+/// return: pointer
+
+/// return value is object: QMenu*
+      *return_object = static_cast < QMenu * >(obj->menu());
+    } else {                    /// END getThis(), static
+      php_error(E_ERROR, "Object not found");
+    }
+    zend_class_entry *ce;
+
+    object_init_ex(return_value, QToolButton_ce_ptr);
+    zend_rsrc_list_entry le;
+
+    le.ptr = return_object[0];
+    php_qt_register(return_value, le);
+    return;
+  }
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  nextCheckState
+ *
+ *    @flags    
+ *    @access    protected
+ *    @return    void
+ *    @param    
+ */
+// method nextCheckState is protected, skipped.
+
+/*!
+ *    @class     QToolButton
+ *    @function  triggered
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    Q_SIGNALS: void
+ *    @param    QAction *
+ */
+ZEND_METHOD(QToolButton, triggered)
+{
+///qt_QAction*
+/*! o public*/
+/*! qt_QAction* ,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_OBJECT) {
+        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+
+        if (obj_z_0->inherits("QAction")) {
+          void *return_object;
+
+          if (getThis() != NULL) {
+//            obj->triggered((QAction *) obj_z_0);
+            RETURN_NULL();
+          }                     /// END getThis(), NULL
+        }
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  event
+ *
+ *    @flags    
+ *    @access    protected
+ *    @return    bool
+ *    @param    QEvent *e
+ */
+// method event is protected, skipped.
+
+/*!
+ *    @class     QToolButton
+ *    @function  toolButtonStyle
+ *
+ *    @flags    c
+ *    @access    public
+ *    @return    Qt::ToolButtonStyle
+ *    @param    
+ */
+ZEND_METHOD(QToolButton, toolButtonStyle)
+{
+  if (ZEND_NUM_ARGS() == 0) {
+    Qt::ToolButtonStyle * return_object;
+    if (getThis() != NULL) {
+      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+      obj->toolButtonStyle();
+      RETURN_NULL();
+    }                           /// END getThis(), NULL
+  }
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  setPopupMode
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    ToolButtonPopupMode mode
+ */
+ZEND_METHOD(QToolButton, setPopupMode)
+{
+///ToolButtonPopupMode
+/*! o public*/
+/*! ToolButtonPopupMode mode,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_OBJECT) {
+        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+
+        if (obj_z_0->inherits("ToolButtonPopupMode")) {
+          void *return_object;
+
+          if (getThis() != NULL) {
+//            obj->setPopupMode((ToolButtonPopupMode) obj_z_0);
+            RETURN_NULL();
+          }                     /// END getThis(), NULL
+        }
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  setToolButtonStyle
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    Qt::ToolButtonStyle style
+ */
+ZEND_METHOD(QToolButton, setToolButtonStyle)
+{
+///Qt::ToolButtonStyle
+/*! o public*/
+/*! Qt::ToolButtonStyle style,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_OBJECT) {
+        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+
+        if (obj_z_0->inherits("Qt::ToolButtonStyle")) {
+          void *return_object;
+
+          if (getThis() != NULL) {
+  //          obj->setToolButtonStyle((Qt::ToolButtonStyle) obj_z_0);
+            RETURN_NULL();
+          }                     /// END getThis(), NULL
+        }
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  trUtf8
+ *
+ *    @flags    s
+ *    @access    public
+ *    @return    QString
+ *    @param     const char *, const char * = 0 
+ */
+ZEND_METHOD(QToolButton, trUtf8)
+{
+/*! ss public*/
+/*! const char* , const char* ,  */
+  if (ZEND_NUM_ARGS() == 2) {
+    zval *z_0;                  /// define ZVAL
+    zval *z_1;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING) {
+        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+        QString *return_object;
+
+        if (getThis() != NULL) {
+/// return value is object: QString
+          *return_object = static_cast < QString > (obj->trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
+/// check whether method call is static.
+        } else {
+          return_object = (QString *) malloc(sizeof (QToolButton::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));       /// memory allocation
+          *return_object = static_cast < QString > (QToolButton::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
+        } zend_class_entry *ce;
+
+        object_init_ex(return_value, QToolButton_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = return_object;
+        php_qt_register(return_value, le);
+        return;
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  setMenu
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    QMenu* menu
+ */
+ZEND_METHOD(QToolButton, setMenu)
+{
+///QMenu*
+/*! o public*/
+/*! QMenu* menu,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_OBJECT) {
+        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+
+        if (obj_z_0->inherits("QMenu")) {
+          void *return_object;
+
+          if (getThis() != NULL) {
+            obj->setMenu((QMenu *) obj_z_0);
+            RETURN_NULL();
+          }                     /// END getThis(), NULL
+        }
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  setAutoRaise
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    bool enable
+ */
+ZEND_METHOD(QToolButton, setAutoRaise)
+{
+/*! l public*/
+/*! int enable,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_LONG) {
+        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+        void *return_object;
+
+        if (getThis() != NULL) {
+          obj->setAutoRaise((bool) Z_LVAL_P(z_0));
+          RETURN_NULL();
+        }                       /// END getThis(), NULL
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+/*!
+ *    @class     QToolButton
+ *    @function  setArrowType
+ *
+ *    @flags    
+ *    @access    public
+ *    @return    void
+ *    @param    Qt::ArrowType type
+ */
+ZEND_METHOD(QToolButton, setArrowType)
+{
+/*! l public*/
+/*! int type,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    zval *z_0;                  /// define ZVAL
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
+      if (Z_TYPE_P(z_0) == IS_LONG) {
+        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+
+        void *return_object;
+
+        if (getThis() != NULL) {
+          obj->setArrowType((Qt::ArrowType) Z_LVAL_P(z_0));
+          RETURN_NULL();
+        }                       /// END getThis(), NULL
+      } else {
+        php_error(E_ERROR, "argument not allowed");
+      }                         /// END check of argument types
+    }                           /// END zend_parse_parameters
+  }                             /// END ZEND_NUM_ARGS
+}
+
+
+PHP_QT_DESTRUCT(QToolButton);



From tm243 at berlios.de  Mon May 15 12:26:17 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Mon, 15 May 2006 12:26:17 +0200
Subject: [Php-qt-svn] r240 - in trunk/qt: . object_model text_related
Message-ID: <200605151026.k4FAQHKA030941@sheep.berlios.de>

Author: tm243
Date: 2006-05-15 12:26:16 +0200 (Mon, 15 May 2006)
New Revision: 240

Modified:
   trunk/qt/object_model/qobject.cpp
   trunk/qt/php_qt.cpp
   trunk/qt/text_related/qstring.cpp
   trunk/qt/zend_php_qt.h
Log:
new or improved methods: sender(), tr(), global function qobject_cast(), append(), prepend(), number(), toInt(), Signals/Slots in qobject.

Modified: trunk/qt/object_model/qobject.cpp
===================================================================
--- trunk/qt/object_model/qobject.cpp	2006-05-15 10:21:40 UTC (rev 239)
+++ trunk/qt/object_model/qobject.cpp	2006-05-15 10:26:16 UTC (rev 240)
@@ -24,9 +24,108 @@
 #include <QObject>
 #include "../php_qt.h"
 
+#include <QMetaMethod>
+
+class QObject_moc : public QObject
+{
+    public:
+        QObject_moc(zval* zend_ptr);
+
+        zval* zend_ptr;
+        QMetaObject* dynamicMetaObject;
+
+        const QMetaObject* metaObject() const;
+        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+        QObject* protected_sender() const;
+        
+};
+
+QObject *QObject_moc::protected_sender() const
+{
+    return this->sender();
+}
+
+const QMetaObject *QObject_moc::metaObject() const
+{
+    return php_qt_getMocData(this->zend_ptr,"QObject",&staticMetaObject);;
+}
+
+QObject_moc::QObject_moc(zval* zend_ptr)
+{
+    this->zend_ptr = zend_ptr;
+    dynamicMetaObject = new QMetaObject;
+    dynamicMetaObject = php_qt_getMocData(this->zend_ptr,"QObject",&staticMetaObject);
+//    cout << dynamicMetaObject->indexOfSignal("valueChanged(int)")<<"\n";
+}
+
+int QObject_moc::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+
+    QMetaObject* d = (QMetaObject*) this->metaObject();
+    char* method_name = new char[strlen((d->method(_id)).signature())];
+    strcpy(method_name,(char*) (d->method(_id)).signature());
+
+    // breaks the string at the first bracket
+    int i;
+    for(i = 0; i < strlen(method_name); i++){
+        if(method_name[i] == 40){
+            method_name[i] = 0;
+            break;
+        }
+    }
+
+    // is a Slot
+    if(d->method(_id).methodType() == QMetaMethod::Slot){
+        int j = 0;
+        zval** args[1];
+        QList<QByteArray> qargs = d->method(_id).parameterTypes();
+        for(i = 0; i < qargs.count(); i++){
+
+            zval *arg;
+            MAKE_STD_ZVAL(arg);
+
+            // invoke to zend types
+            if(!strncmp("int",(const char*) qargs[i],3)){
+                ZVAL_LONG(arg, *reinterpret_cast< int*>(_a[i+1]));
+            } else if(!strncmp("char*",(const char*) qargs[i],5)){
+                ZVAL_STRING(arg, *reinterpret_cast< char**>(_a[i+1]), 1);
+            } else if(!strncmp("bool",(const char*) qargs[i],4)){
+                ZVAL_BOOL(arg, *reinterpret_cast< bool*>(_a[i+1]));
+            } else if(!strncmp("double",(const char*) qargs[i],4)){
+                ZVAL_DOUBLE(arg, *reinterpret_cast< double*>(_a[i+1]));
+            } else {
+                    // must be an object
+                    zend_class_entry *ce;
+                    object_init_ex(arg, QObject_ce_ptr);
+                    zend_rsrc_list_entry le;
+                    le.ptr = *reinterpret_cast< QObject**>(_a[1]);
+                    php_qt_register(arg, le);
+                    
+            }
+
+            args[j++] = &arg;
+
+        }
+
+        php_qt_callmethod(this->zend_ptr, method_name, j, args);
+
+    // is a signal
+    } else {
+        void *_b[] = { 0, _a[1] };
+        QMetaObject::activate(this, d, 0, _b);
+    }
+
+    delete d;
+    delete method_name;
+
+    return _id;
+
+}
+
+
 ZEND_METHOD(QObject,__construct){
 
-    QObject *QObject_ptr = new QObject();
+    QObject *QObject_ptr = new QObject_moc(getThis());
 
     if(ZEND_NUM_ARGS() > 0){
         zval *object;
@@ -103,6 +202,9 @@
             php_error(E_ERROR,"connect failed\n");
             RETURN_NULL(); 
         }
+        if(getThis() == NULL){
+            php_error(E_ERROR,"zend object lost, cannot connect Signals/Slots. connect() should not be called statically without a this argument.\n");
+        }
         receiver_ptr = static_cast<QObject*>(PHP_QT_FETCH());
     }
 
@@ -383,3 +485,56 @@
 PHP_QT_RETURN_PROPERTY_OBJ_METHOD(QObject,parent);
 //PHP_QT_SET_PROPERTY_OBJ_METHOD(QObject,setParent,QObject);
 //PHP_QT_RETURN_OBJ_METHOD(QObject,property,QVariant);
+
+ZEND_METHOD(QObject,tr){
+
+  if (ZEND_NUM_ARGS() == 1) {
+
+    char *str;
+    if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s", &str) == FAILURE) {
+        return; 
+    }
+    
+    QString *return_object;
+
+    if (getThis() != NULL) {
+      QObject *obj = (QObject *) PHP_QT_FETCH();
+      *return_object = static_cast < QString > (obj->tr(str));
+    } else {
+      php_error(E_ERROR, "Object not found");
+    }
+    zend_class_entry *ce;
+
+    object_init_ex(return_value, QString_ce_ptr);
+    zend_rsrc_list_entry le;
+
+    le.ptr = return_object;
+    php_qt_register(return_value, le);
+    return;
+
+  }
+
+}
+
+ZEND_METHOD(QObject,sender){
+
+    QObject *return_object;
+
+    if (getThis() != NULL) {
+      QObject_moc *obj = (QObject_moc *) PHP_QT_FETCH();
+      return_object = obj->protected_sender();
+    } else {
+      php_error(E_ERROR, "Object not found");
+    }
+    zend_class_entry *ce;
+
+    object_init_ex(return_value, QObject_ce_ptr);
+    zend_rsrc_list_entry le;
+
+    le.ptr = return_object;
+    php_qt_register(return_value, le);
+    return;
+
+
+}
+

Modified: trunk/qt/php_qt.cpp
===================================================================
--- trunk/qt/php_qt.cpp	2006-05-15 10:21:40 UTC (rev 239)
+++ trunk/qt/php_qt.cpp	2006-05-15 10:26:16 UTC (rev 240)
@@ -19,7 +19,6 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * QFrame.cpp - QFrame PHP implementation.
  * begin           : Sun Dec 11 13:58:03 2005
  * generated by    : moni using kalyptus 0.9.
  */
@@ -78,6 +77,7 @@
 	PHP_FE(confirm_php_qt_compiled,	NULL)		/* For testing, remove later. */
     PHP_FE(SIGNAL,	NULL)
     PHP_FE(SLOT,	NULL)	
+    PHP_FE(qobject_cast,	NULL)	
 	{NULL, NULL, NULL}	/* Must be the last line in php_qt_functions[] */
 };
 /* }}} */
@@ -1081,6 +1081,31 @@
     return;
 }
 
+PHP_FUNCTION(qobject_cast){
+
+  if (ZEND_NUM_ARGS() == 2) {
+
+    zval *obj;
+    zval *cast_type;
+
+    if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &obj, &cast_type) == FAILURE) {
+        php_error(E_WARNING,"error while casting object, wrong parameters");
+        return; 
+    }
+
+    zend_class_entry *ce;
+
+    object_init_ex(return_value, Z_OBJCE_P(cast_type));
+
+    zend_rsrc_list_entry le;
+    le.ptr = php_qt_fetch(obj);
+    php_qt_register(return_value, le);
+
+    return;
+
+  }
+}
+
 /* }}} */
 /* {{{ */
 
@@ -1118,7 +1143,7 @@
 	TSRMLS_FETCH();
 
 	if(zend_hash_index_find(Z_OBJPROP_P(this_ptr), 0, (void**) &listhandle) == FAILURE){
-	  php_error(E_ERROR,"Object not found in list, %s",Z_OBJCE_P(this_ptr)->name);
+	  php_error(E_ERROR,"underlying Qt-Object missing. Make sure that the constructor of the parent is called, instance of type '%s' fails",Z_OBJCE_P(this_ptr)->name,Z_OBJCE_P(this_ptr)->name);
 	}
 	ptr = zend_list_find(Z_LVAL_PP(listhandle), &type);
 
@@ -1150,7 +1175,7 @@
     zval *function_name;
     MAKE_STD_ZVAL(function_name);
     ZVAL_STRING(function_name,methodname,1);
-    
+
     zval* retval;
     MAKE_STD_ZVAL(retval);
 
@@ -1168,10 +1193,10 @@
     zval **slotdata;
 
     zval *zslot;
-    zslot = zend_read_property(QWidget_ce_ptr,this_ptr,"slots",5,0);
+    zslot = zend_read_property(Z_OBJCE_P(this_ptr),this_ptr,"slots",5,0);
 
     zval *zsignal;
-    zsignal = zend_read_property(QWidget_ce_ptr,this_ptr,"signals",7,0);
+    zsignal = zend_read_property(Z_OBJCE_P(this_ptr),this_ptr,"signals",7,0);
 
 
     if((zslot)->type==IS_ARRAY && (zsignal)->type==IS_ARRAY ) {
@@ -1276,13 +1301,15 @@
 
 }
 
+
+
 ///
 static zend_function_entry QObject_methods[] = { 
     ZEND_ME(QObject,__construct,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(QObject,test,NULL,ZEND_ACC_PUBLIC)    
     ZEND_ME(QObject,blockSignals,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(QObject,children,NULL,ZEND_ACC_PUBLIC)
-    ZEND_ME(QObject,connect,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+    ZEND_ME(QObject,connect,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(QObject,disconnect,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
     ZEND_ME(QObject,dumpObjectInfo,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(QObject,dumpObjectTree,NULL,ZEND_ACC_PUBLIC)
@@ -1306,6 +1333,8 @@
     ZEND_ME(QObject,signalsBlocked,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(QObject,startTimer,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(QObject,thread,NULL,ZEND_ACC_PUBLIC)
+    ZEND_ME(QObject,tr,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+    ZEND_ME(QObject,sender,NULL,ZEND_ACC_PUBLIC)    // should be protected
 
     {NULL,NULL,NULL}
 };

Modified: trunk/qt/text_related/qstring.cpp
===================================================================
--- trunk/qt/text_related/qstring.cpp	2006-05-15 10:21:40 UTC (rev 239)
+++ trunk/qt/text_related/qstring.cpp	2006-05-15 10:26:16 UTC (rev 240)
@@ -36,7 +36,6 @@
   QString *QString_ptr = (QString *) PHP_QT_FETCH();
 
   int l = QString_ptr->size();
-
   char* c = (char*) (QString_ptr->toUtf8()).constData();
 
   RETURN_STRINGL(c,l,1);
@@ -291,10 +290,18 @@
 				return;                                             
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
 
+			    QString *obj = (QString*) PHP_QT_FETCH();
+			    QString* obj_z_0 = (QString*) php_qt_fetch(z_0);
 
+				QString & return_object = (QString &) obj->prepend(*obj_z_0);
+
+                zend_class_entry *ce;
+                object_init_ex(return_value, QObject_ce_ptr);
+                zend_rsrc_list_entry le;
+                le.ptr = &return_object;
+                php_qt_register(return_value, le);
+                return;
 			}
 		}
 	}
@@ -790,6 +797,29 @@
  */
 ZEND_METHOD(QString, number){
 
+	if (ZEND_NUM_ARGS() == 1){
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+
+                QString *return_object = new QString;
+                if(getThis()){
+			        QString *obj = (QString*) PHP_QT_FETCH();
+				    *return_object = (QString) obj->number((ulong) Z_LVAL_P(z_0));
+                } else {
+				    *return_object = (QString) QString::number((ulong) Z_LVAL_P(z_0));
+                }
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, QString_ce_ptr);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) return_object;                                       
+				php_qt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+
+
 	if (ZEND_NUM_ARGS() == 2){
 		/* ol public*/
 
@@ -1844,11 +1874,16 @@
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-
-
+			    QString *obj = (QString*) PHP_QT_FETCH();
+			    QString* obj_z_0 = (QString*) php_qt_fetch(z_0);
+			    bool a = obj->contains(*obj_z_0);
+                RETURN_BOOL(a);
 			}
+			if(Z_TYPE_P(z_0) == IS_STRING){
+			    QString *obj = (QString*) PHP_QT_FETCH();
+			    bool a = obj->contains(Z_STRVAL_P(z_0));
+                RETURN_BOOL(a);
+			}
 		}
 	}
 
@@ -1877,6 +1912,7 @@
 			}
 		}
 	}
+    RETURN_BOOL(false);
 }
 
 /*********************************
@@ -2098,9 +2134,7 @@
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-
-
+			    QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->append((char) Z_LVAL_P(z_0));
 				zend_class_entry *ce;                                   
 				object_init_ex(return_value, QString_ce_ptr);     
@@ -2111,8 +2145,6 @@
 			}
 			if(Z_TYPE_P(z_0) == IS_STRING){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString & return_object = (QString &) obj->append( (const char*) Z_STRVAL_P(z_0));
 				zend_class_entry *ce;                                   
 				object_init_ex(return_value, QString_ce_ptr);     
@@ -2122,10 +2154,16 @@
 				return;                                             
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+			    QString *obj = (QString*) PHP_QT_FETCH();
+			    QString* obj_z_0 = (QString*) php_qt_fetch(z_0);
 
-
+				QString & return_object = (QString &) obj->append(*obj_z_0);
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, QString_ce_ptr);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				php_qt_register(return_value,le);                   
+				return;
 			}
 		}
 	}
@@ -2176,14 +2214,19 @@
 		/* int* ok,  */
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+			if(Z_TYPE_P(z_0) == IS_BOOL){
 
-
-			RETURN_DOUBLE(obj->toDouble((bool*) Z_LVAL_P(z_0)));
+			    QString *obj = (QString*) PHP_QT_FETCH();
+			    RETURN_DOUBLE(obj->toDouble((bool*) Z_LVAL_P(z_0)));
 			}
 		}
 	}
+	if (ZEND_NUM_ARGS() == 0){
+
+		QString *obj = (QString*) PHP_QT_FETCH();
+        RETURN_DOUBLE(obj->toDouble());
+
+	}
 }
 
 /*********************************
@@ -2458,6 +2501,13 @@
  */
 ZEND_METHOD(QString, toInt){
 
+	if (ZEND_NUM_ARGS() == 0){
+		/* ll public*/
+
+		QString *obj = (QString*) PHP_QT_FETCH();
+		RETURN_LONG(obj->toInt());
+
+	}
 	if (ZEND_NUM_ARGS() == 2){
 		/* ll public*/
 

Modified: trunk/qt/zend_php_qt.h
===================================================================
--- trunk/qt/zend_php_qt.h	2006-05-15 10:21:40 UTC (rev 239)
+++ trunk/qt/zend_php_qt.h	2006-05-15 10:26:16 UTC (rev 240)
@@ -55,6 +55,7 @@
 /* emulate SIGNAL(), SLOT() macros */
 PHP_FUNCTION(SIGNAL);
 PHP_FUNCTION(SLOT);
+PHP_FUNCTION(qobject_cast);
 
 /* QObject */
 ZEND_METHOD(QObject,__construct);
@@ -86,6 +87,8 @@
 ZEND_METHOD(QObject,signalsBlocked);
 ZEND_METHOD(QObject,startTimer);
 ZEND_METHOD(QObject,thread);
+ZEND_METHOD(QObject,tr);
+ZEND_METHOD(QObject,sender);
 
 /* QEvent */
 ZEND_METHOD(QEvent,__construct);
@@ -98,6 +101,8 @@
 
 #include "ag_zend_php_qt.inc"
 
+
+
 /* 
   	Declare any global variables you may need between the BEGIN
 	and END macros here:     



From tm243 at berlios.de  Fri May 19 10:11:19 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Fri, 19 May 2006 10:11:19 +0200
Subject: [Php-qt-svn] r241 - trunk/qt/text_related
Message-ID: <200605190811.k4J8BJuF001278@sheep.berlios.de>

Author: tm243
Date: 2006-05-19 10:11:15 +0200 (Fri, 19 May 2006)
New Revision: 241

Modified:
   trunk/qt/text_related/qstring.cpp
Log:
handling of type 'double'

Modified: trunk/qt/text_related/qstring.cpp
===================================================================
--- trunk/qt/text_related/qstring.cpp	2006-05-15 10:26:16 UTC (rev 240)
+++ trunk/qt/text_related/qstring.cpp	2006-05-19 08:11:15 UTC (rev 241)
@@ -816,6 +816,23 @@
 				php_qt_register(return_value,le);                   
 				return;                                             
 			}
+			if(Z_TYPE_P(z_0) == IS_DOUBLE){
+
+                QString *return_object = new QString;
+                if(getThis()){
+			        QString *obj = (QString*) PHP_QT_FETCH();
+				    *return_object = (QString) obj->number((double) Z_DVAL_P(z_0),'g',10);
+                } else {
+				    *return_object = (QString) QString::number((double) Z_DVAL_P(z_0),'g',10);
+                }
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, QString_ce_ptr);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) return_object;                                       
+				php_qt_register(return_value,le);                   
+				return;                                             
+			}
+
 		}
 	}
 
@@ -830,10 +847,9 @@
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+//			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			    QString *obj = (QString*) PHP_QT_FETCH();
 
-
 				QString return_object = (QString) obj->number((ulong) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
 				zend_class_entry *ce;                                   
 				object_init_ex(return_value, QString_ce_ptr);     
@@ -841,7 +857,7 @@
 				le.ptr = (void*) &return_object;                                       
 				php_qt_register(return_value,le);                   
 				return;                                             
-			}
+//			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 



From tm243 at berlios.de  Fri May 19 10:17:17 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Fri, 19 May 2006 10:17:17 +0200
Subject: [Php-qt-svn] r242 - trunk/qt/classes
Message-ID: <200605190817.k4J8HHfh001840@sheep.berlios.de>

Author: tm243
Date: 2006-05-19 10:17:17 +0200 (Fri, 19 May 2006)
New Revision: 242

Modified:
   trunk/qt/classes/qdialog.cpp
Log:
class_entry_ptr repaired.

Modified: trunk/qt/classes/qdialog.cpp
===================================================================
--- trunk/qt/classes/qdialog.cpp	2006-05-19 08:11:15 UTC (rev 241)
+++ trunk/qt/classes/qdialog.cpp	2006-05-19 08:17:17 UTC (rev 242)
@@ -162,7 +162,7 @@
           *return_object = static_cast < QString > (QDialog::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
         } zend_class_entry *ce;
 
-        object_init_ex(return_value, QDialog_ce_ptr);
+        object_init_ex(return_value, QString_ce_ptr);
         zend_rsrc_list_entry le;
 
         le.ptr = return_object;
@@ -178,21 +178,21 @@
 
     if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
       if (Z_TYPE_P(z_0) == IS_STRING) {
-        QString *return_object;
+        QString *return_object = new QString;
         if (getThis() != NULL) {
 /// return value is object: QString
-        QDialog *obj = static_cast<QDialog *>(PHP_QT_FETCH());
-          *return_object = static_cast < QString > (obj->tr((const char *)Z_STRVAL_P(z_0)));
+            QDialog *obj = static_cast<QDialog *>(PHP_QT_FETCH());
+            *return_object = static_cast < QString > (obj->tr((const char *)Z_STRVAL_P(z_0)));
 /// check whether method call is static.
         } else {
-          return_object = (QString *) malloc(sizeof (QDialog::tr((const char *)Z_STRVAL_P(z_0))));   /// memory allocation
-          *return_object = static_cast < QString > (QDialog::tr((const char *)Z_STRVAL_P(z_0)));
-        } zend_class_entry *ce;
-        object_init_ex(return_value, QToolButton_ce_ptr);
-        zend_rsrc_list_entry le;
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
+            *return_object = static_cast < QString > (QDialog::tr((const char *)Z_STRVAL_P(z_0)));
+        } 
+            zend_class_entry *ce;
+            object_init_ex(return_value, QString_ce_ptr);
+            zend_rsrc_list_entry le;
+            le.ptr = return_object;
+            php_qt_register(return_value, le);
+            return;
       } else {
         php_error(E_ERROR, "argument not allowed");
       }                         /// END check of argument types



From tm243 at berlios.de  Fri May 19 10:20:28 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Fri, 19 May 2006 10:20:28 +0200
Subject: [Php-qt-svn] r243 - in trunk/tutorials: . calculator
Message-ID: <200605190820.k4J8KS1h002199@sheep.berlios.de>

Author: tm243
Date: 2006-05-19 10:20:28 +0200 (Fri, 19 May 2006)
New Revision: 243

Added:
   trunk/tutorials/calculator/
   trunk/tutorials/calculator/button.php
   trunk/tutorials/calculator/calculator.php
   trunk/tutorials/calculator/main.php
Log:
example 'calculator' added.

Added: trunk/tutorials/calculator/button.php
===================================================================
--- trunk/tutorials/calculator/button.php	2006-05-19 08:17:17 UTC (rev 242)
+++ trunk/tutorials/calculator/button.php	2006-05-19 08:20:28 UTC (rev 243)
@@ -0,0 +1,21 @@
+<?php
+    /****************************************************************
+    **
+    ** Qt Calculator
+    **
+    ** http://doc.trolltech.com/4.0/widgets-calculator.html
+    **
+    ****************************************************************/
+
+    class Button extends QToolButton {
+    
+        function __construct($text){
+
+            parent::__construct();
+//            $this->setSizePolicy("QSizePolicy::Expanding", "QSizePolicy::Preferred");
+            $this->setText(new QString($text));
+        }
+
+    }
+
+?>
\ No newline at end of file

Added: trunk/tutorials/calculator/calculator.php
===================================================================
--- trunk/tutorials/calculator/calculator.php	2006-05-19 08:17:17 UTC (rev 242)
+++ trunk/tutorials/calculator/calculator.php	2006-05-19 08:20:28 UTC (rev 243)
@@ -0,0 +1,389 @@
+<?php
+    /****************************************************************
+    **
+    ** Qt Calculator
+    **
+    ** http://doc.trolltech.com/4.0/widgets-calculator.html
+    **
+    ****************************************************************/
+
+    require_once("button.php");
+
+    class Calculator extends QDialog {
+    
+        var $sumInMemory = 0.0;
+        var $sumSoFar = 0.0;
+        var $factorSoFar = 0.0;
+        var $pendingAdditiveOperator;
+        var $pendingMultiplicativeOperator;
+        var $waitingForOperand = true;
+
+        var $display;           /// QLineEdit
+
+        var $NumDigitButtons = 10;
+        var $digitButtons;      /// Array of buttons
+
+        /// Buttons
+        var $pointButton;
+        var $changeSignButton;
+        var $backspaceButton;
+        var $clearButton;
+        var $clearAllButton;
+        var $clearMemoryButton;
+        var $readMemoryButton;
+        var $setMemoryButton;
+        var $addToMemoryButton;
+
+        var $divisionButton;
+        var $timesButton;
+        var $minusButton;
+        var $plusButton;
+        var $squareRootButton;
+        var $powerButton;
+        var $reciprocalButton;
+        var $equalButton;
+
+        var $slots = array(
+            "digitClicked()",
+            "unaryOperatorClicked()",
+            "additiveOperatorClicked()",
+            "multiplicativeOperatorClicked()",
+            "equalClicked()",
+            "pointClicked()",
+            "changeSignClicked()",
+            "backspaceClicked()",
+            "clear()",
+            "clearAll()",
+            "clearMemory()",
+            "read_Memory()",
+            "setMemory()",
+            "addToMemory()"
+        );
+        var $signals = array("");
+
+        function __construct() {
+
+            parent::__construct();
+
+            $this->pendingAdditiveOperator = new QString();
+            $this->pendingMultiplicativeOperator = new QString();
+
+            $this->display = new QLineEdit("0");
+            $this->display->setReadOnly(true);
+            $this->display->setAlignment(QT_ALIGNMENT_ALIGNRIGHT);
+            $this->display->setMaxLength(15);
+//            $this->display->installEventFilter($this);
+
+            for ($i = 0; $i < $this->NumDigitButtons; ++$i) {
+                    $this->digitButtons[$i] = $this->createButton($i."", SLOT("digitClicked()"));
+            }
+
+            $this->pointButton = $this->createButton(".", SLOT("pointClicked()"));
+            $this->changeSignButton = $this->createButton("\261", SLOT("changeSignClicked()"));
+
+            $this->backspaceButton = $this->createButton("Backspace", SLOT("backspaceClicked()"));
+            $this->clearButton = $this->createButton("Clear", SLOT("clear()"));
+            $this->clearAllButton = $this->createButton("Clear All", SLOT("clearAll()"));
+
+            $this->clearMemoryButton = $this->createButton("MC", SLOT("clearMemory()"));
+            $this->readMemoryButton = $this->createButton("MR", SLOT("read_Memory()"));
+            $this->setMemoryButton = $this->createButton("MS", SLOT("setMemory()"));
+            $this->addToMemoryButton = $this->createButton("M+", SLOT("addToMemory()"));
+
+            $this->divisionButton = $this->createButton("\367", SLOT("multiplicativeOperatorClicked()"));
+
+            $this->timesButton = $this->createButton("\327", SLOT("multiplicativeOperatorClicked()"));
+            $this->minusButton = $this->createButton("-", SLOT("additiveOperatorClicked()"));
+            $this->plusButton = $this->createButton("+", SLOT("additiveOperatorClicked()"));
+
+            $this->squareRootButton = $this->createButton("Sqrt", SLOT("unaryOperatorClicked()"));
+            $this->powerButton = $this->createButton("x\262", SLOT("unaryOperatorClicked()"));
+            $this->reciprocalButton = $this->createButton("1/x", SLOT("unaryOperatorClicked()"));
+            $this->equalButton = $this->createButton("=", SLOT("equalClicked()"));
+
+            $this->mainLayout = new QGridLayout($this);
+//            $this->mainLayout->setSizeConstraint("QLayout::SetFixedSize");
+
+            $this->mainLayout->addWidget($this->display, 0, 0, 1, 6);
+            $this->mainLayout->addWidget($this->backspaceButton, 1, 0, 1, 2);
+            $this->mainLayout->addWidget($this->clearButton, 1, 2, 1, 2);
+            $this->mainLayout->addWidget($this->clearAllButton, 1, 4, 1, 2);
+
+            $this->mainLayout->addWidget($this->clearMemoryButton, 2, 0);
+            $this->mainLayout->addWidget($this->readMemoryButton, 3, 0);
+            $this->mainLayout->addWidget($this->setMemoryButton, 4, 0);
+            $this->mainLayout->addWidget($this->addToMemoryButton, 5, 0);
+
+            for ($i = 1; $i < $this->NumDigitButtons; ++$i) {
+
+                    $row = ceil(((8 - ($i+1))) / 3) + 2;
+                    $column = ceil((($i-1) % 3)) + 1;
+
+                    $this->mainLayout->addWidget($this->digitButtons[$i], (int) $row, (int) $column);
+
+            }
+
+            $this->mainLayout->addWidget($this->digitButtons[0], 5, 1);
+            $this->mainLayout->addWidget($this->pointButton, 5, 2);
+            $this->mainLayout->addWidget($this->changeSignButton, 5, 3);
+
+            $this->mainLayout->addWidget($this->divisionButton, 2, 4);
+            $this->mainLayout->addWidget($this->timesButton, 3, 4);
+            $this->mainLayout->addWidget($this->minusButton, 4, 4);
+            $this->mainLayout->addWidget($this->plusButton, 5, 4);
+                                
+            $this->mainLayout->addWidget($this->squareRootButton, 2, 5);
+            $this->mainLayout->addWidget($this->powerButton, 3, 5);
+            $this->mainLayout->addWidget($this->reciprocalButton, 4, 5);
+            $this->mainLayout->addWidget($this->equalButton, 5, 5);
+
+            $this->setLayout($this->mainLayout);
+            $this->setWindowTitle(new QString("Calculator"));
+
+        }
+
+        function createButton($text, $member)
+        {
+            $button = new Button($text);
+            $this->connect($button, SIGNAL("clicked()"), $this, $member);
+            return $button;
+        }
+
+        function digitClicked()
+        {
+
+            $clickedButton = qobject_cast($this->sender(),new QToolButton());
+            $digitValue = $clickedButton->text()->toInt();
+            if ($this->display->text() == "0" && $digitValue == 0.0)
+                return;
+
+            if ($this->waitingForOperand) {
+                $this->display->clear();
+                $this->waitingForOperand = false;
+            }
+
+            $new_value = new QString();
+            $display_text = $this->display->text();
+            $number = QString::number($digitValue);
+
+            $new_value->append($display_text);
+            $new_value->append($number);
+
+            $this->display->setText($new_value);
+        }
+
+        function unaryOperatorClicked()
+        {
+            $clickedButton = qobject_cast($this->sender(), new Button(""));
+            $clickedOperator = $clickedButton->text();
+            $operand = $this->display->text()->toDouble();
+            $result;
+
+            if ($clickedOperator->toAscii() == $this->tr("Sqrt")->toAscii()) {
+                if ($operand < 0.0) {
+                    $this->abortOperation();
+                    return;
+                }
+                $result = sqrt($operand);
+            } else if ($clickedOperator->toAscii() == $this->tr("x\262")->toAscii()) {
+                $result = pow($operand, 2.0);
+            } else if ($clickedOperator->toAscii() == $this->tr("1/x")->toAscii()) {
+                if ($operand == 0.0) {
+                    $this->abortOperation();
+                    return;
+                }
+                $result = 1.0 / $operand;
+            }
+
+            $this->display->setText(QString::number($result));
+            $this->waitingForOperand = true;
+        }
+
+        function additiveOperatorClicked()
+        {
+            $clickedButton = qobject_cast($this->sender(), new Button(""));
+            $clickedOperator = $clickedButton->text();
+
+            $operand = $this->display->text()->toDouble();
+
+            if (!$this->pendingMultiplicativeOperator->isEmpty()) {
+                if (!calculate($operand, $this->pendingMultiplicativeOperator)) {
+                    $this->abortOperation();
+                    return;
+                }
+                $this->display->setText(QString::number($this->factorSoFar));
+                $operand = $this->factorSoFar;
+                $this->factorSoFar = 0.0;
+                $this->pendingMultiplicativeOperator->clear();
+            }
+
+            if (!$this->pendingAdditiveOperator->isEmpty()) {
+                if (!calculate(operand, $this->pendingAdditiveOperator)) {
+                    $this->abortOperation();
+                    return;
+                }
+                $this->display->setText(QString::number($this->sumSoFar));
+            } else {
+                $this->sumSoFar = $operand;
+            }
+
+            $this->pendingAdditiveOperator = $clickedOperator;
+            $this->waitingForOperand = true;
+
+        }
+
+        function multiplicativeOperatorClicked()
+        {
+            $clickedButton = qobject_cast($this->sender(), new Button(""));
+            $clickedOperator = $clickedButton->text();
+
+            $operand = $this->display->text()->toDouble();
+                                
+            if (!$this->pendingMultiplicativeOperator->isEmpty()) {
+                if (!$this->calculate($operand, $this->pendingMultiplicativeOperator)) {
+                    $this->abortOperation();
+                    return;
+                }
+                $this->display->setText(QString::number($this->factorSoFar));
+            } else {
+                $this->factorSoFar = $operand;
+            }
+            $this->pendingMultiplicativeOperator = $clickedOperator;
+            $this->waitingForOperand = true;
+        }
+
+        function equalClicked()
+        {
+            $operand = $this->display->text()->toDouble();
+
+            if (!$this->pendingMultiplicativeOperator->isEmpty()) {
+                if (!$this->calculate($operand, $this->pendingMultiplicativeOperator)) {
+                    $this->abortOperation();
+                    return;
+                }
+                $operand = $this->factorSoFar;
+                $this->factorSoFar = 0.0;
+                $this->pendingMultiplicativeOperator->clear();
+            }
+            if (!$this->pendingAdditiveOperator->isEmpty()) {
+                if (!$this->calculate($operand, $this->pendingAdditiveOperator)) {
+                    $this->abortOperation();
+                    return;
+                }
+                $this->pendingAdditiveOperator->clear();
+            } else {
+                $this->sumSoFar = $operand;
+            }
+
+            $this->display->setText(QString::number($this->sumSoFar));
+            $this->sumSoFar = 0.0;
+            $this->waitingForOperand = true;                                                                          
+        }
+
+        function pointClicked()
+        {
+            if ($this->waitingForOperand)
+                $this->display->setText("0");
+            if (!$this->display->text()->contains(".")){
+
+                $new_value = $this->display->text();
+                $new_value->append(".");
+                $this->display->setText($new_value);
+                
+            }
+            $this->waitingForOperand = false;
+        }
+
+        function changeSignClicked()
+        {
+            $text = $this->display->text();
+            $value = $text->toDouble();
+
+            if ($value > 0.0) {
+                $text->prepend("-");
+            } else if ($value < 0.0) {
+                $text->remove(0, 1);
+            }
+            $this->display->setText($text);
+        }
+
+        function backspaceClicked()
+        {
+            if ($this->waitingForOperand)
+                return;
+
+            $text = $this->display->text();
+            $text->chop(1);
+            if ($text->isEmpty()) {
+                $text = "0";
+                $this->waitingForOperand = true;
+            }
+            $this->display->setText($text);
+        }
+
+        function clear()
+        {
+            if ($this->waitingForOperand)
+                return;
+
+            $this->display->setText("0");
+            $this->waitingForOperand = true;
+        }
+
+        function clearAll()
+        {
+            $this->sumSoFar = 0.0;
+            $this->factorSoFar = 0.0;
+            $this->pendingAdditiveOperator->clear();
+            $this->pendingMultiplicativeOperator->clear();
+            $this->display->setText("0");
+            $this->waitingForOperand = true;
+        }
+
+        function clearMemory()
+        {
+            $this->sumInMemory = 0.0;
+        }
+                    
+        function read_Memory()
+        {
+            $this->display->setText(QString::number($this->sumInMemory));
+            $this->waitingForOperand = true;
+        }
+
+        function setMemory()
+        {
+            $this->equalClicked();
+            $this->sumInMemory = $this->display->text()->toDouble();
+        }
+                            
+        function addToMemory()
+        {
+            $this->equalClicked();
+            $this->sumInMemory += $this->display->text()->toDouble();
+        }
+
+        function abortOperation()
+        {
+            $this->clearAll();
+            $this->display->setText($this->tr("####"));
+        }
+
+        function calculate($rightOperand, $pendingOperator)
+        {
+            if ($pendingOperator->toAscii() == "+") {
+                $this->sumSoFar += $rightOperand;
+            } else if ($pendingOperator->toAscii() == "-") {
+                $this->sumSoFar -= $rightOperand;
+            } else if ($pendingOperator->toAscii() == "\327") {
+                $this->factorSoFar *= $rightOperand;
+            } else if ($pendingOperator->toAscii() == "\367") {
+                if ($rightOperand == 0.0)
+                    return false;
+                $this->factorSoFar /= $rightOperand;
+            }
+            return true;
+        }
+    }
+
+?>
\ No newline at end of file

Added: trunk/tutorials/calculator/main.php
===================================================================
--- trunk/tutorials/calculator/main.php	2006-05-19 08:17:17 UTC (rev 242)
+++ trunk/tutorials/calculator/main.php	2006-05-19 08:20:28 UTC (rev 243)
@@ -0,0 +1,22 @@
+<?php
+    /****************************************************************
+    **
+    ** Qt Calculator
+    **
+    ** http://doc.trolltech.com/4.0/widgets-calculator.html
+    **
+    ****************************************************************/
+
+    if(!extension_loaded('php_qt')) {
+        dl('php_qt.' . PHP_SHLIB_SUFFIX);
+    }
+
+    require_once('calculator.php');
+
+    $app = new QApplication($argc,0);
+
+    $calc = new Calculator();
+    $calc->show();
+    $app->exec();
+
+?>
\ No newline at end of file



From tm243 at berlios.de  Fri May 19 10:29:33 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Fri, 19 May 2006 10:29:33 +0200
Subject: [Php-qt-svn] r244 - trunk/tutorials/t7
Message-ID: <200605190829.k4J8TX4E002742@sheep.berlios.de>

Author: tm243
Date: 2006-05-19 10:29:33 +0200 (Fri, 19 May 2006)
New Revision: 244

Modified:
   trunk/tutorials/t7/main.php
Log:
typo.

Modified: trunk/tutorials/t7/main.php
===================================================================
--- trunk/tutorials/t7/main.php	2006-05-19 08:20:28 UTC (rev 243)
+++ trunk/tutorials/t7/main.php	2006-05-19 08:29:33 UTC (rev 244)
@@ -3,7 +3,7 @@
     **
     ** Qt tutorial 7
     **
-    ** http://doc.trolltech.com/4.0/tutorial-t6.html
+    ** http://doc.trolltech.com/4.0/tutorial-t7.html
     **
     ****************************************************************/
 



From tm243 at berlios.de  Wed May 24 17:30:38 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Wed, 24 May 2006 17:30:38 +0200
Subject: [Php-qt-svn] r245 - trunk/tools
Message-ID: <200605241530.k4OFUcYH031759@sheep.berlios.de>

Author: tm243
Date: 2006-05-24 17:30:37 +0200 (Wed, 24 May 2006)
New Revision: 245

Removed:
   trunk/tools/kalyptusCxxToPHP.pm
Log:
php extension for kalyptus will be replaced.

Deleted: trunk/tools/kalyptusCxxToPHP.pm
===================================================================
--- trunk/tools/kalyptusCxxToPHP.pm	2006-05-19 08:29:33 UTC (rev 244)
+++ trunk/tools/kalyptusCxxToPHP.pm	2006-05-24 15:30:37 UTC (rev 245)
@@ -1,1911 +0,0 @@
-#***************************************************************************
-#    copyright            : (C) 2005 Thomas Moenicke
-#    email                : tm at ippfp.org
-#    author               : Thomas Moenicke, based on the CSharp generation code
-#                            by Adam Treat & Richard Dale.
-#***************************************************************************/
-
-#/***************************************************************************
-# *                                                                         *
-# *   This program is free software; you can redistribute it and/or modify  *
-# *   it under the terms of the GNU General Public License as published by  *
-# *   the Free Software Foundation; either version 2 of the License, or     *
-# *   (at your option) any later version.                                   *
-# *                                                                         *
-#***************************************************************************/
-
-#   - multiple inherits
-#   - method overloading, marshalling
-#   - return values
-
-# TODO
-#   - support for all types in method calls
-#   - fit cplusplusToZEND, cplusplusToInvoke, cplusplusToMacro
-#   - setter methods support only one php property (adequate, I believe)
-
-#   php properties, enums
-#   RETURN_BYTE[]
-
-
-package kalyptusCxxToPHP;
-
-use File::Path;
-use File::Basename;
-
-use Carp;
-use Ast;
-use kdocAstUtil;
-use kdocUtil;
-use Iter;
-use kalyptusDataDict;
-
-use strict;
-no strict "subs";
-
-use vars qw/ @clist $host $who $now $gentext %functionId $docTop
-	$lib $rootnode $outputdir $opt $debug $typeprefix $eventHandlerCount
-	$pastaccess $pastname $pastreturn $pastparams $nullctor $ctorCount @properties @functions @constructors %methods *CLASS *HEADER *AG_ZEND_CLASS_ENTRY *AG_EXTERN_ZEND_CLASS_ENTRY *AG_VOID_REGISTER *AG_ZEND_PHP_QT *AG_CONFIGM4 *AG_QT_MINIT *AG_PHP_QT_CPP *QTCTYPES *KDETYPES /;
-
-BEGIN
-{
-    @clist = ();
-
-    # Page footer
-
-	$who = kdocUtil::userName();
-	$host = kdocUtil::hostName();
-	$now = localtime;
-	$gentext = "$who using kalyptus $main::Version.";
-
-	$docTop =<<EOF
- * begin           : $now
- * generated by    : $gentext
- */
-EOF
-}
-
-# TODO here:
-# one is needed for php types, one for zend types (e.q. zval)
-sub cplusplusToZEND
-{
-	my ( $cplusplusType )  = @_;
-	if ( $cplusplusType =~ /bool/ && kalyptusDataDict::ctypemap($cplusplusType) eq "int" ) {
-		return "bool";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*void\s*\**/ ) {
-		return "NULL";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*\bint\s*\&*/) {
-		return "long";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*\bint\s*\*/) {
-		return "int[]";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*double\s*\*/ ) {
-		return "double[]";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*short\s*\*/ ) {
-		return "short[]";
-	} elsif ( $cplusplusType =~ /QByteArray/ || $cplusplusType =~ /QBitArray/ ) {
-		return "byte[]";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\*\*/ ) {
-		return "char";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\**/ ) {
-		return "char* ";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned int\s*\**/ ) {
-		return "uint";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned short\s*\**/ ) {
-		return "ushort";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned long\s*\**/ ) {
-		return "ulong";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned char\s*\**/ ) {
-		return "string";
-	} elsif ( $cplusplusType =~ /^GUID/ ) {
-		return "System.Guid";
-	} elsif ( $cplusplusType =~ /^FILE/ ) {
-		return "string";
-	} elsif ( $cplusplusType =~ /^_NPStream/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^QPtrCollection/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^QStyleHintReturn/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^type/i ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^Key/ || $cplusplusType =~ /^key_type/ || $cplusplusType =~ /^K/) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^QUnknownInterface/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^GDHandle/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^QTextParag/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^QDiskFont/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^QDomNodePrivate/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^Display/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^QUuid/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^Q_REFCOUNT/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^EventRef/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^MSG/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^QWSEvent/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^XEvent/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^CGContextRef/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^QWSDecoration/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^QTextFormat/ || $cplusplusType =~ /^QTextDocument/ || $cplusplusType =~ /^QTextCursor/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^QSqlRecordPrivate/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^Text/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^Event/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /^NavDirection/ ) {
-		return "IntPtr";
-	} elsif (
-			$cplusplusType =~ /^pointer$/
-			 || $cplusplusType =~/T\*$/
-			 || $cplusplusType =~/T\&*$/
-			 || $cplusplusType =~/T1\&*$/
-			 || $cplusplusType =~/T2\&*$/
-			 || $cplusplusType =~/^Iterator/i
-			 || $cplusplusType =~/^_iterator/i
-			 || $cplusplusType =~/^reference/
-			 || $cplusplusType =~/^_reference/) {
-		return "IntPtr";
-	} elsif ($cplusplusType =~ /::/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /::/ ||
-			 $cplusplusType =~ /&$/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /&$/ ||
-			 $cplusplusType =~ /\*/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /\*/) {
-
-#		$cplusplusType =~ s/::/./g;
-#		$cplusplusType =~ s/&//g;
-#		$cplusplusType =~ s/\*//g;
-#		return $cplusplusType;
-        return "zval*";
-
-	} else {
- 		return kalyptusDataDict::ctypemap($cplusplusType);
-	}
-}
-
-# zend.h:
-#/* data types */
-#/* All data types <= IS_BOOL have their constructor/destructors skipped */
-#define IS_NULL		0
-#define IS_LONG		1
-#define IS_DOUBLE	2
-#define IS_BOOL		3
-#define IS_ARRAY	4
-#define IS_OBJECT	5
-#define IS_STRING	6
-#define IS_RESOURCE	7
-#define IS_CONSTANT	8
-#define IS_CONSTANT_ARRAY	9
-
-
-sub cplusplusToZENDType
-{
-	my ( $cplusplusType )  = @_;
-	if ( $cplusplusType =~ /bool/ && kalyptusDataDict::ctypemap($cplusplusType) eq "int" ) {
-		return "BOOL";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*void\s*\**/ ) {
-		return "NULL";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\&*/ ) {
-		return "LONG";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\*/) {
-		return "ARRAY";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*double\s*\*/ ) {
-		return "ARRAY";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*short\s*\*/ ) {
-		return "ARRAY";
-	} elsif ( $cplusplusType =~ /QByteArray/ || $cplusplusType =~ /QBitArray/ ) {
-		return "ARRAY";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\*\*/ ) {
-		return "STRING";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\**/ ) {
-		return "STRING";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned int\s*\**/ ) {
-		return "LONG";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned short\s*\**/ ) {
-		return "LONG";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned long\s*\**/ ) {
-		return "LONG";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned char\s*\**/ ) {
-		return "STRING";
-	} elsif ( $cplusplusType =~ /^GUID/ ) {
-		return "System.Guid";
-	} elsif ( $cplusplusType =~ /^FILE/ ) {
-		return "STRING";
-	} elsif ( $cplusplusType =~ /^_NPStream/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^QPtrCollection/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^QStyleHintReturn/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^type/i ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^Key/ || $cplusplusType =~ /^key_type/ || $cplusplusType =~ /^K/) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^QUnknownInterface/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^GDHandle/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^QTextParag/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^QDiskFont/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^QDomNodePrivate/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^Display/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^QUuid/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^Q_REFCOUNT/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^EventRef/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^MSG/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^QWSEvent/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^XEvent/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^CGContextRef/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^QWSDecoration/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^QTextFormat/ || $cplusplusType =~ /^QTextDocument/ || $cplusplusType =~ /^QTextCursor/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^QSqlRecordPrivate/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^Text/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^Event/ ) {
-		return "OBJECT";
-	} elsif ( $cplusplusType =~ /^NavDirection/ ) {
-		return "OBJECT";
-	} elsif (
-			$cplusplusType =~ /^pointer$/
-			 || $cplusplusType =~/T\*$/
-			 || $cplusplusType =~/T\&*$/
-			 || $cplusplusType =~/T1\&*$/
-			 || $cplusplusType =~/T2\&*$/
-			 || $cplusplusType =~/^Iterator/i
-			 || $cplusplusType =~/^_iterator/i
-			 || $cplusplusType =~/^reference/
-			 || $cplusplusType =~/^_reference/) {
-		return "OBJECT";
-	} elsif ($cplusplusType =~ /::/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /::/ ||
-			 $cplusplusType =~ /&$/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /&$/ ||
-			 $cplusplusType =~ /\*/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /\*/) {
-
-#		$cplusplusType =~ s/::/./g;
-#		$cplusplusType =~ s/&//g;
-#		$cplusplusType =~ s/\*//g;
-#		return $cplusplusType;
-        return "OBJECT";
-
-	} else {
- 		return kalyptusDataDict::ctypemap($cplusplusType);
-	}
-}
-
-# function is not used yet
-sub cplusplusToPInvoke
-{
-	my ( $cplusplusType )  = @_;
-	if ( $cplusplusType =~ /bool/ && kalyptusDataDict::ctypemap($cplusplusType) eq "int" ) {
-		return "bool";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*void\s*\*/ ) {
-		return "int";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\&*/ ) {
-		return "int";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\*/) {
-		return "int[]";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*double\s*\*/ ) {
-		return "double[]";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*short\s*\*/ ) {
-		return "short[]";
-	} elsif ( $cplusplusType =~ /QByteArray/ || $cplusplusType =~ /QBitArray/ ) {
-		return "byte[]";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\*\*/ ) {
-		return "string[]";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\**/ ) {
-		return "string";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned int\s*\**/ ) {
-		return "uint";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned short\s*\**&*/ ) {
-		return "ushort";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned long\s*\**/ ) {
-		return "ulong";
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned char\s*\**/ ) {
-		return "string";
-	} elsif ( $cplusplusType =~ /^GUID/ ) {
-		return "System.Guid";
-	} elsif ( $cplusplusType =~ /^FILE/ ) {
-		return "string";
-	} elsif ( $cplusplusType =~ /^_NPStream/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^QPtrCollection/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^QStyleHintReturn/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^type/i ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^Key/ || $cplusplusType =~ /^key_type/ || $cplusplusType =~ /^K/) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^QUnknownInterface/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^GDHandle/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^QTextParag/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^QDiskFont/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^QDomNodePrivate/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^Display/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^QUuid/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^Q_REFCOUNT/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^EventRef/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^MSG/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^QWSEvent/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^XEvent/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^CGContextRef/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^QWSDecoration/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^QTextFormat/ || $cplusplusType =~ /^QTextDocument/ || $cplusplusType =~ /^QTextCursor/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^QSqlRecordPrivate/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^Text/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^Event/ ) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /^NavDirection/ ) {
-		return "RawObject";
-	} elsif (
-			$cplusplusType =~ /^pointer$/
-			 || $cplusplusType =~/T\*$/
-			 || $cplusplusType =~/T\&*$/
-			 || $cplusplusType =~/T1\&*$/
-			 || $cplusplusType =~/T2\&*$/
-			 || $cplusplusType =~/^iterator/i
-			 || $cplusplusType =~/^_iterator/i
-			 || $cplusplusType =~/^reference/
-			 || $cplusplusType =~/^_reference/) {
-		return "RawObject";
-	} elsif ( $cplusplusType =~ /&$/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /&$/ ) {
-		return "IntPtr";
-	} elsif ( $cplusplusType =~ /\*/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /\*/ ) {
-		return "IntPtr";
-	} else {
-		return kalyptusDataDict::ctypemap($cplusplusType);
-	}
-}
-
-# deprecated
-sub cplusplusToMacro
-{
-	my ( $class, $cnode )  = @_;
-
-    my $functionname = $cnode->{astNodeName};
-    my $classname = $class->{astNodeName};
-
-    my $function = $cnode;  # for better reading
-    my $access = $function->{Access};
-    my $returntype = $function->{ReturnType};
-
-# skip
-    if ($functionname eq "qObject") {
-        print CLASS "// skip ",$functionname,"\n";
-        return;
-    }
-
-# make sure that this function will be added only at one time
-    my $mark = 0;
-    my $func;
-    foreach $func ( @functions ) {
-        if ( $func eq $functionname ) {
-            print CLASS "// marked for overloading: ",$functionname,"\n";
-            $mark = 1;
-        }
-    }
-
-# print doc in phpDocumentor style
-    if(!$mark){
-
-        my $c = @functions;
-        if($c>0){
-            print CLASS "\t}\n";
-            print CLASS "}\n";
-        }
-
-        push @functions, $functionname;
-        print CLASS "
-
-/*********************************
- *    class     ",$classname,"
- *    function  ",$functionname,"
- *    flags:    ",$function->{Flags},"
- *\n";
-
-        my $count = 0;
-        foreach $b ( @{$cnode->{ParamList}} ) {
-            print CLASS " *    \@param   ",$b->{ArgType},"\n";
-        }
-        if (!$count) {
-            print CLASS " *    \@param   -\n";
-        }
-
-        print CLASS "
- *    \@access   ",$access,"
- *    \@return   ",$returntype,"
-*********************************/
-";
-    } else {
-        print CLASS "\t}\n";
-    }
-
-    # skip virtuals
-    if ( $function->{Flags} =~ /v/ ){
-        print CLASS "ZEND_METHOD(",$classname,", ",$functionname,"){\n";
-        print CLASS "// marked as virtual, skipped\n";
-        print CLASS "\tphp_printf(\"%s(): virtual functions are not yet implemented",'\n',"\",get_active_function_name(TSRMLS_C));\n";
-        print CLASS "}\n";
-        return;
-    }
-
-    if(!$mark){
-        print CLASS "ZEND_METHOD(",$classname,", ",$functionname,"){\n";
-    }
-
-    my $p = @{$cnode->{ParamList}};
-    print CLASS "\tif (ZEND_NUM_ARGS() == ",$p,"){\n";
-
-    my $count = 0;
-    my $paratype; # for zend
-    my $short = ",\"";
-    my $paraf;  # for qt
-    my @objects;
-
-# write method implementation
-    foreach $b ( @{$cnode->{ParamList}} ) {
-
-        if($count > 0){
-            $paraf .= ", ";
-        }
-        print CLASS "\t// ",$b->{DefaultValue},"\n";
-# todo: long, double
-        if ( $b->{ArgType} =~ /char/ ) {
-            print CLASS "\t\tchar* var_",$count,";\n";
-            print CLASS "\t\tint* len_",$count,";\n\n";
-            $paratype .= ", &var_".$count.", &len_".$count;
-            $paraf .= " var_".$count;
-            $short .= "s";
-        } elsif ( $b->{ArgType} =~ /int/ ) {
-            print CLASS "\t\tlong var_",$count,";\n";
-            $paratype .= ", &var_".$count;
-            $paraf .= "(".$b->{ArgType}.") var_".$count;
-            $short .= "l";
-        } elsif ( $b->{ArgType} =~ /bool/ ) {
-            print CLASS "\t\tbool* var_",$count,";\n";
-            $paratype .= ", &var_".$count;
-            $paraf .= "(".$b->{ArgType}.") var_".$count;
-            $short .= "b";
-        }
-        else {
-            print CLASS "\t\tzval* var_",$count,";\n\n";
-            $paratype .= ", &var_".$count;
-            $paraf .= " var_".$count;
-            $short .= "o";
-            push @objects, "var_".$count;
-        }
-
-        $count++;
-    }
-    $short .= "\"";
-
-
-
-    if( $count ) {
-        print CLASS "\t\tif(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC",$short,$paratype,") == FAILURE) {\n";
-        print CLASS "\t\t\tRETURN_FALSE;\n";
-        print CLASS "\t\t}\n";
-    }
-
-# properties:
-    # we have a nxn relation
-    my $prop;
-    my $obj_tmp;
-
-    foreach $prop ( @properties ) {
-
-       if ( $prop->{WRITE} =~ /$functionname/ ) {
-        foreach $obj_tmp ( @properties ) {
-            # mostly these methods are setmethods with only one argument
-            # maybe source of error
-# todo: test with QLCDNumber
-            my $postfix = cplusplusToZEND($prop->{type});
-            $postfix =~ s/zval\*//;
-            if ( $postfix ) {
-                $postfix = "_".cplusplusToZEND($prop->{type});
-            }
-
-            print CLASS  "\t\tzend_update_property",$postfix,"(Z_OBJCE_P(getThis()),getThis(),\"",$prop->{astNodeName},"\",strlen(\"",$prop->{astNodeName},"\"),var_0 TSRMLS_CC);\n";
-            print CLASS "\t}\n";
-            return;
-        }
-       }
-    }
-
-    my $rt = cplusplusToZEND($returntype);
-
-    my $obj;
-
-        foreach $obj ( @objects ) {
-            print CLASS "\t\tQObject* tmp_",$obj," = (QObject*) php_qt_fetch(",$obj,");\n";
-            $paraf =~ s/$obj/tmp_$obj/;
-        }
-
-        print CLASS "\t\t$classname *o = ($classname*) PHP_QT_FETCH();\n";
-
-
-        if ( $rt eq "NULL" ) {
-            print CLASS "\t\to->",$functionname,"(",$paraf,");\n";
-            print CLASS "\t\tRETURN_NULL();\n";
-        } elsif ( $rt =~ /zval/ ) {
-
-# TODO: consider 'const',
-# and non-pointer types, pointer types
-            print CLASS "\t\t",$returntype," obj = (",$returntype,") o->",$functionname,"(",$paraf,");\n";
-            print CLASS "\t\tzend_class_entry *ce;                                   \n";
-#            print CLASS "\tif(obj != NULL) {                                       \n";
-            print CLASS "\t\t    object_init_ex(return_value, ",$classname,"_ce_ptr);     \n";
-            print CLASS "\t\t    zend_rsrc_list_entry le;                            \n";
-            print CLASS "\t\t    le.ptr = &obj;                                       \n";
-            print CLASS "\t\t    php_qt_register(return_value,le);                   \n";
-            print CLASS "\t\t    return;                                             \n";
-#            print CLASS "\t}                                                       \n";
-#            print CLASS "\telse                                                    \n";
-#            print CLASS "\t    RETURN_NULL();                                      \n";
-
-        } else {
-            print CLASS "\t\tRETURN_",uc($rt),"(o->",$functionname,"(",$paraf,"));\n" if defined $rt;
-        }
-
-    if( $cnode->{Flags} =~ /s/ ){
-        $access .= "|ZEND_ACC_STATIC";
-    }
-
-    print ZEND_PHP_QT "\nZEND_METHOD(",$class->{astNodeName},", ",$functionname,");";
-    print AG_ZEND_PHP_QT "\nZEND_METHOD(",$class->{astNodeName},", ",$functionname,");";
-
-# code snippets for php_qt.cpp here
-    $access = uc($access);
-    $access =~ s/_SLOTS//;
-    $access =~ s/_SIGNALS//;
-
-    print AG_PHP_QT_CPP "\tZEND_ME(",$classname,",",$functionname,",NULL,ZEND_ACC_",$access,")\n";
-
-}
-
-sub writeDoc
-{
-	( $lib, $rootnode, $outputdir, $opt ) = @_;
-
-	$debug = $main::debuggen;
-
-	mkpath( $outputdir ) unless -f $outputdir;
-    mkpath( $outputdir."/classes/" ) unless -f $outputdir."/classes/";
-
-# open files
-
-    # AG_ZEND_CLASS_ENTRY
-    my $file_ag_zend_class_entry = "$outputdir/ag_zend_class_entry.inc";
-    open( AG_ZEND_CLASS_ENTRY, ">$file_ag_zend_class_entry" ) || die "Couldn't create $file_ag_zend_class_entry\n";
-    $file_ag_zend_class_entry =~ s/\.h/.h/;
-
-    # AG_EXTERN_ZEND_CLASS_ENTRY
-    my $file_ag_extern_zend_class_entry = "$outputdir/ag_extern_zend_class_entry.inc";
-    open( AG_EXTERN_ZEND_CLASS_ENTRY, ">$file_ag_extern_zend_class_entry" ) || die "Couldn't create $file_ag_extern_zend_class_entry\n";
-    $file_ag_extern_zend_class_entry =~ s/\.h/.h/;
-
-    # AG_ZEND_PHP_QT
-    my $file_ag_zend_php_qt = "$outputdir/ag_zend_php_qt.inc";
-    open( AG_ZEND_PHP_QT, ">$file_ag_zend_php_qt" ) || die "Couldn't create $file_ag_zend_php_qt\n";
-    $file_ag_zend_php_qt =~ s/\.h/.h/;
-
-    # AG_CONFIGM4
-    my $file_ag_configm4 = "$outputdir/ag_configm4.inc";
-    open( AG_CONFIGM4, ">$file_ag_configm4" ) || die "Couldn't create $file_ag_configm4\n";
-    $file_ag_configm4 =~ s/\.h/.h/;
-
-    # AG_QT_MINIT
-    my $file_ag_qt_minit = "$outputdir/ag_qt_minit.inc";
-    open( AG_QT_MINIT, ">$file_ag_qt_minit" ) || die "Couldn't create $file_ag_qt_minit\n";
-    $file_ag_qt_minit =~ s/\.h/.h/;
-
-    # AG_PHP_QT_CPP
-    my $file_ag_php_qt_cpp = "$outputdir/ag_php_qt_cpp.inc";
-    open( AG_PHP_QT_CPP, ">$file_ag_php_qt_cpp" ) || die "Couldn't create $file_ag_php_qt_cpp\n";
-    $file_ag_php_qt_cpp =~ s/\.h/.h/;
-
-    print ZEND_PHP_QT "/*
- * PHP-Qt - The PHP language bindings for Qt
- *
- * Copyright (C) 2005 
- * Thomas Moenicke <tm at ippfp.org>, 
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- * 
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- * 
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * QFrame.cpp - QFrame PHP implementation.
- * begin           : Sun Dec 11 13:58:03 2005
- * generated by    : moni using kalyptus 0.9.
- */
-
-/*
- * Copyright (C) 2005
- * Thomas Moenicke <tm\@ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger\@freesurf.ch>
- *
-*/
-/* \$Id: header,v 1.15 2004/01/08 16:46:52 sniper Exp \$ */
-
-#ifndef PHP_PHP_QT_H
-#define PHP_PHP_QT_H
-
-extern zend_module_entry php_qt_module_entry;
-#define phpext_php_qt_ptr &php_qt_module_entry
-
-#ifdef ZTS
-#include \"TSRM.h\"
-#endif
-
-PHP_MINIT_FUNCTION(php_qt);
-PHP_MSHUTDOWN_FUNCTION(php_qt);
-PHP_RINIT_FUNCTION(php_qt);
-PHP_RSHUTDOWN_FUNCTION(php_qt);
-PHP_MINFO_FUNCTION(php_qt);
-
-PHP_FUNCTION(confirm_php_qt_compiled);	/* For testing, remove later. */
-
-/* emulate SIGNAL(), SLOT() macros */
-PHP_FUNCTION(SIGNAL);
-PHP_FUNCTION(SLOT);
-    \n\n";
-
-    print PHP_QT_MINIT "\n";
-
-	# Document all compound nodes
-	Iter::LocalCompounds( $rootnode, sub { writeClassDoc( shift ); } );
-
-    print ZEND_PHP_QT "\n/*
-  	Declare any global variables you may need between the BEGIN
-	and END macros here:
-
-ZEND_BEGIN_MODULE_GLOBALS(php_qt)
-	long  global_value;
-	char *global_string;
-ZEND_END_MODULE_GLOBALS(php_qt)
-*/
-
-/* In every utility function you add that needs to use variables
-   in php_php_qt_globals, call TSRMLS_FETCH(); after declaring other
-   variables used by that function, or better yet, pass in TSRMLS_CC
-   after the last function argument and declare your utility function
-   with TSRMLS_DC after the last declared argument.  Always refer to
-   the globals in your function as PHP_QT_G(variable).  You are
-   encouraged to rename these macros something shorter, see
-   examples in any other php module directory.
-*/
-
-#ifdef ZTS
-#define PHP_QT_G(v) TSRMG(php_qt_globals_id, zend_php_qt_globals *, v)
-#else
-#define PHP_QT_G(v) (php_qt_globals.v)
-#endif
-
-#endif	/* PHP_PHP_QT_H */
-
-
-/*
- * Local variables:
- * tab-width: 4
- * c-basic-offset: 4
- * End:
- * vim600: noet sw=4 ts=4 fdm=marker
- * vim<600: noet sw=4 ts=4
- */\n
-    ";
-
-# close files
-
-    close AG_ZEND_CLASS_ENTRY;
-    close AG_EXTERN_ZEND_CLASS_ENTRY;
-
-    print AG_ZEND_PHP_QT "\n";
-    close AG_ZEND_PHP_QT;
-    close AG_CONFIGM4;
-    close AG_QT_MINIT;
-    close AG_PHP_QT_CPP;
-
-}
-
-sub writeClassDoc
-{
-	my( $node ) = @_;
-
-    $ctorCount = 0;
-
-    if(
-            $node->{astNodeName} eq "QAbstractButton"
-        ||  $node->{astNodeName} eq "QLCDNumber"
-        ||  $node->{astNodeName} eq "QLatin1String"
-||  $node->{astNodeName} eq "QApplication"
-||  $node->{astNodeName} eq "QCoreApplication"
-||  $node->{astNodeName} eq "QBoxLayout"
-||  $node->{astNodeName} eq "QAbstractSlider"
-||  $node->{astNodeName} eq "QWidget"
-||  $node->{astNodeName} eq "QLayoutItem"
-||  $node->{astNodeName} eq "QLineEdit"
-||  $node->{astNodeName} eq "QObject"
-||  $node->{astNodeName} eq "QPushButton"
-||  $node->{astNodeName} eq "QLayout"
-||  $node->{astNodeName} eq "QHBoxLayout"
-||  $node->{astNodeName} eq "QFrame"
-||  $node->{astNodeName} eq "QPushButton"
-||  $node->{astNodeName} eq "QSlider"
-||  $node->{astNodeName} eq "QSpacerItem"
-||  $node->{astNodeName} eq "QString"
-||  $node->{astNodeName} eq "QVBoxLayout"
-||  $node->{astNodeName} eq "Qt"
-||  $node->{astNodeName} eq "QInternal"
-||  $node->{astNodeName} eq "Attribute"
-    ){
-        print $node->{astNodeName}," skipped\n";
-        return;
-    }
-
-	print "Enter: $node->{astNodeName}\n" if $debug;
-	if( exists $node->{ExtSource} ) {
-		warn "Trying to write doc for ".$node->{AstNodeName}.
-			" from ".$node->{ExtSource}."\n";
-		return;
-	}
-
-	my $typeName = $node->{astNodeName}."*";
-
-	if ( kalyptusDataDict::ctypemap($typeName) eq "" ) {
-		$typeprefix = ($typeName =~ /^Q/ ? "qt_" : "kde_");
-		kalyptusDataDict::setctypemap($typeName, $typeprefix.$node->{astNodeName}."*");
-		print "'$typeName' => '$typeprefix$typeName',\n";
-	} elsif ( kalyptusDataDict::ctypemap($typeName) =~ /^qt_/ ) {
-		$typeprefix = "qt_";
-	} elsif ( kalyptusDataDict::ctypemap($typeName) =~ /^kde_/ ) {
-		$typeprefix = "kde_";
-	} else {
-		$typeprefix = "kde_";
-	}
-# make the class file
-	my $file = join("__", kdocAstUtil::heritage($node)).".cpp";
-    $file = $outputdir."/classes/".lc($file);
-	my $docnode = $node->{DocNode};
-	my @list = ();
-	my $version = undef;
-	my $author = undef;
-
-	if( $#{$node->{Kids}} < 0 || $node->{Access} eq "private") {
-		return;
-	}
-
-	open( CLASS, ">$file" ) || die "Couldn't create $file\n";
-	$file =~ s/\.h/.cpp/;
-
-	my $short = "";
-	my $extra = "";
-
-print CLASS "/*
- * PHP-Qt - The PHP language bindings for Qt
- *
- * Copyright (C) 2005
- * Thomas Moenicke <tm\@ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger\@freesurf.ch>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
-";
-
-	print CLASS " * ", $node->{astNodeName}, ".cpp - ", $node->{astNodeName}, " PHP implementation.\n";
-	print CLASS $docTop;
-
-    print CLASS "
-#include <iostream>
-using namespace std;\n";
-
-    print CLASS "\n#include <$node->{astNodeName}>\n";
-    print CLASS "#include \"../php_qt.h\"\n\n";
-
-    print CLASS checkIncludes($node);
-
-    print AG_PHP_QT_CPP "static zend_function_entry ",$node->{astNodeName},"_methods[] = {\n";
-
-
-    print AG_ZEND_CLASS_ENTRY "zend_class_entry *",$node->{astNodeName},"_ce_ptr;\n";
-    print AG_CONFIGM4 "\tqt/classes/",lc($node->{astNodeName}),".cpp \\ \n";
-    print AG_EXTERN_ZEND_CLASS_ENTRY "extern zend_class_entry *",$node->{astNodeName},"_ce_ptr;\n";
-    print AG_EXTERN_ZEND_CLASS_ENTRY "void \t_register_",$node->{astNodeName},"();\n";
-
-
-    print PHP_QT_MINIT "\n\t_register_",$node->{astNodeName},"(TSRMLS_C);\n";
-    print AG_QT_MINIT "\n\t_register_",$node->{astNodeName},"(TSRMLS_C);\n";
-
-
-	# ancestors
-	my @ancestors = ();
-	Iter::Ancestors( $node, $rootnode, undef, undef,
-		sub { # print
-			my ( $ances, $name, $type, $template ) = @_;
-			push @ancestors, $name;
-			},
-			undef
-		);
-
-	if ( $#ancestors < 0 ) {
-# INTERFACE
-		if ( kalyptusDataDict::interfacemap($node->{astNodeName}) ne () ) {
-			$file = "$outputdir/".join("__", kdocAstUtil::heritage($node)).".cpp";
-			my $interfaceName = kalyptusDataDict::interfacemap($node->{astNodeName});
-			$file =~ s/$node->{astNodeName}/$interfaceName/;
-			open( INTERFACE, ">$file" ) || die "Couldn't create $file\n";
-			print INTERFACE "// ", kalyptusDataDict::interfacemap($node->{astNodeName}), ".cpp - ", kalyptusDataDict::interfacemap($node->{astNodeName}), " PHP implementation.";
-			print INTERFACE $docTop;	# header
-print INTERFACE "
-/*
- * PHP-Qt - The PHP language bindings for Qt
- *
- * Copyright (C) 2005
- * Thomas Moenicke <tm\@ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger\@freesurf.ch>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <iostream>
-using namespace std;
-
-#include \"../php_qt.h\"
-";
-		} # ancestors < 0
-
-#        print CLASS "\n#include <",$node->{astNodeName},">\n\n";
-
-# CLASS
-	} else {
-
-#        print CLASS "\n#include <",$node->{astNodeName},">\n\n";
-        print ZEND_PHP_QT "\n\n/* $node->{astNodeName} */";
-
-	}
-# JNISOURCE?
-	Iter::MembersByType ( $node,
-		sub { print CLASS "", $_[0], ""; print JNISOURCE "", $_[0], "";  },
-		sub {	my ($node, $kid ) = @_;
-
-                 generateClassMethodForEnum( $node, $kid );
-               },
-		sub { print CLASS ""; print JNISOURCE ""; }
-	);
-
-	Iter::MembersByType ( $node,
-		sub { print CLASS "", $_[0], ""; print CLASS "", $_[0], "";  },
-		sub {	my ($node, $kid ) = @_;
-            if ($kid->{NodeType} eq "property"){
-                push @properties, $kid;
-            }
-        },
-		sub { print CLASS ""; print CLASS ""; }
-	);
-
-# methods
-	%functionId = ();
-	$eventHandlerCount = 0;
-
-	Iter::MembersByType ( $node,
-		sub { print CLASS "", $_[0], ""; print CLASS "", $_[0], ""; },
-		sub {	my ($node, $kid ) = @_;
-                               listMember( $node, $kid );
-                         },
-		sub { print CLASS ""; print CLASS ""; }
-	);
-
-    # traverse
-    foreach my $key (keys %methods){
-        my $node_ = $methods{ $key };
-        my @methods_ = $node_->{"method"};
-# group
-        my @one;
-        my @two;
-        my @three;
-        my @four;
-        my @five;
-        my @six;
-        my @seven;
-        my @eight;
-        my @nine;
-        my @ten;
-
-
-        print CLASS "
-/*********************************
- *    class     ",$node->{astNodeName}," */\n";
-
-        my $first = 1;
-
-        foreach my $m_ (@methods_){
-# params
-            foreach my $n_ (@{$m_}){
-
-# skip destructor
-            if($n_->{ReturnType} =~ /~/){ next; }
-
-            if($first == 1){
-                $first = 0;
-                print CLASS "/*
- *    function  ",$n_->{astNodeName},"
- *    flags:    ",$n_->{Flags},"
- */\n";
-#print_r($n_);
-# write class related stuff
-# check whether method is a ctor
-                if($node->{astNodeName} eq $n_->{astNodeName}){
-                    print CLASS "ZEND_METHOD(",$node->{astNodeName},", __construct){\n";
-                    $n_->AddProp("ctor","ctor");
-                    print AG_ZEND_PHP_QT "\nZEND_METHOD(",$node->{astNodeName},", __construct);";
-                    print AG_PHP_QT_CPP "\tZEND_ME(",$node->{astNodeName},", __construct,NULL,ZEND_ACC_PUBLIC)\n";
-# normal
-                } else {
-                    print CLASS "ZEND_METHOD(",$node->{astNodeName},", ",$n_->{astNodeName},"){\n";
-
-                    my $access = $n_->{Access};
-                    if( $n_->{Flags} =~ /s/ ){
-                        $access .= "|ZEND_ACC_STATIC";
-                    }
-                    $access = uc($access);
-                    $access =~ s/_SLOTS//;
-                    $access =~ s/_SIGNALS//;
-                    print AG_PHP_QT_CPP "\tZEND_ME(",$node->{astNodeName},",",$n_->{astNodeName},",NULL,ZEND_ACC_",$access,")\n";
-                    print AG_ZEND_PHP_QT "\nZEND_METHOD(",$node->{astNodeName},", ",$n_->{astNodeName},");";
-                }
-            }
-
-                my $count = 0;
-                foreach $b ( @{$n_->{ParamList}} ) {
-                    $count++;
-                }
-# copy
-                if($count == 0){
-                    if(!(
-                        $n_->{astNodeName} =~ /className/
-                        || $n_->{astNodeName} =~ /qt_/
-                        || $n_->{astNodeName} =~ /staticMetaObject/
-                        || $n_->{astNodeName} =~ /qObject/
-                        )
-                    ){
-                        print CLASS "\tif (ZEND_NUM_ARGS() == 0){\n";
-                        print CLASS createReturn($node->{astNodeName}, $n_,"");
-                        print CLASS "\t}\n";
-                    }
-                } elsif($count == 1){
-                    push @one, $n_;
-                } elsif($count == 2){
-                    push @two, $n_;
-                } elsif($count == 3){
-                    push @three, $n_;
-                } elsif($count == 4){
-                    push @four, $n_;
-                } elsif($count == 5){
-                    push @five, $n_;
-                } elsif($count == 6){
-                    push @six, $n_;
-                } elsif($count == 7){
-                    push @seven, $n_;
-                } elsif($count == 8){
-                    push @eight, $n_;
-                } elsif($count == 9){
-                    push @nine, $n_;
-                } elsif($count == 10){
-                    push @ten, $n_;
-                } else {
-                    print "error, too much args: ",$count," ",$node->{astNodeName}," ",$n_->{astNodeName},"\n";
-                }
-            }
-
-            my %one_ = mergeEquals($node->{astNodeName},1, at one);
-            print CLASS marshal($node->{astNodeName},1,%one_);
-
-            my %two_ = mergeEquals($node->{astNodeName},2, at two);
-            print CLASS marshal($node->{astNodeName},2,%two_);
-
-            my %three_ = mergeEquals($node->{astNodeName},3, at three);
-            print CLASS marshal($node->{astNodeName},3,%three_);
-
-            my %four_ = mergeEquals($node->{astNodeName},4, at four);
-            print CLASS marshal($node->{astNodeName},4,%four_);
-
-            my %five_ = mergeEquals($node->{astNodeName},5, at five);
-            print CLASS marshal($node->{astNodeName},5,%five_);
-
-            my %six_ = mergeEquals($node->{astNodeName},6, at six);
-            print CLASS marshal($node->{astNodeName},6,%six_);
-
-            my %seven_ = mergeEquals($node->{astNodeName},7, at seven);
-            print CLASS marshal($node->{astNodeName},7,%seven_);
-
-            my %eight_ = mergeEquals($node->{astNodeName},8, at eight);
-            print CLASS marshal($node->{astNodeName},8,%eight_);
-
-            my %nine_ = mergeEquals($node->{astNodeName},9, at nine);
-            print CLASS marshal($node->{astNodeName},9,%nine_);
-
-            my %ten_ = mergeEquals($node->{astNodeName},10, at ten);
-            print CLASS marshal($node->{astNodeName},105,%ten_);
-
-#            print CLASS "}\n"; # ZEND_METHOD
-
-        }
-        print CLASS "}\n";
-    }
-
-    print CLASS "\n";
-
-
-# creating the constructor
-     my $function = $node->{astNodeName};
-
-#destructor
-    print CLASS "\nPHP_QT_DESTRUCT(",$function,");\n\n";
-
-	close CLASS;
-	$nullctor = 0;
-
-    print AG_PHP_QT_CPP "
-    {NULL,NULL,NULL}
-};\n";
-
-# inheritance
-    my $zend_inherit = $node->{astNodeName}."_ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);";
-    my $ancestor;
-
-    my $first = 1;
-	foreach $ancestor ( @ancestors ) {
-        if($first) {
-            $zend_inherit = $node->{astNodeName}."_ce_ptr = zend_register_internal_class_ex(&ce TSRMLS_CC, ".$ancestor."_ce_ptr,NULL TSRMLS_CC);\n";
-            $first = 0;
-        } else {
-           $zend_inherit .= "\tzend_do_inheritance(".$node->{astNodeName}."_ce_ptr, ".$ancestor."_ce_ptr TSRMLS_CC);\n";
-        }
-	}
-
-    print AG_PHP_QT_CPP "
-void _register_",$node->{astNodeName},"(TSRMLS_D)
-{
-    zend_class_entry ce;
-    INIT_CLASS_ENTRY(ce,\"",$node->{astNodeName},"\",",$node->{astNodeName},"_methods);
-    ",$zend_inherit,"
-";
-
-	Iter::MembersByType ( $node,
-		sub { print CLASS "", $_[0], ""; print CLASS "", $_[0], "";  },
-		sub {	my ($node, $kid ) = @_;
-            if ($kid->{NodeType} eq "property"){
-                print AG_PHP_QT_CPP
-#                    "zend_declare_property_string(",$node->{astNodeName},"_ce_ptr,\"",$kid->{astNodeName},"\",strlen(\"",$kid->{astNodeName},"\"),\"\",ZEND_ACC_PROTECTED TSRMLS_CC);";
-                     "\tPHP_QT_DECLARE_PROPERTY(\"$kid->{astNodeName}\");\n";
-
-            }
-        },
-		sub { print CLASS ""; print JNISOURCE ""; }
-	);
-
-    print AG_PHP_QT_CPP "
-}\n";
-
-
-
-	if ( kalyptusDataDict::interfacemap($node->{astNodeName}) ne () ) {
-		close INTERFACE;
-    }
-
-    undef @properties;
-    undef @functions;
-    undef @constructors;
-    undef %methods;
-}
-
-# for every node
-sub listMember
-{
-	my( $class, $m, $ancestorCount) = @_;
-	my $name;
-    my $function;
-	my $PHPaccess;
-	my $PHPparams;
-    my $pCount;
-
-    my @ctor_params;
-	my $returnType;
-
-	$name = $m->{astNodeName} ;
-	my $type = $m->{NodeType};
-	my $docnode = $m->{DocNode};
-
-	if ( $m->{ReturnType} =~ /~/ ) {
-		$name = "~".$name;
-	}
-
-    $function = $name;
-
-	$function =~ s/~//;
-
-	if( $type eq "method" && $m->{Access} ne "private" && $m->{Access} ne "private_slots" && $m->{Access} ne "signals" ) {
-		if ( $m->{ReturnType} =~ /[<>]/ || $m->{Params} =~ /[<>]/  || $m->{Params} =~ /\.\.\./ || $m->{Params} =~ /Impl/
-				|| $m->{ReturnType} =~ /QAuBucket/ || $m->{Params} =~ /QAuBucket/
-				|| $m->{ReturnType} =~ /QMember/ || $m->{Params} =~ /QMember/   ) {
-			return;
-		}
-
-# returntype
-		$returnType = $m->{ReturnType};
-		$returnType =~ s/const\s*//;
-		$returnType =~ s/inline\s*//;
-		$returnType =~ s/\s*([,\*\&])\s*/$1/;
-		$returnType =~ s/^\s*//;
-		$returnType =~ s/\s*$//;
-
-		if ( $returnType ne "" && cplusplusToPInvoke($returnType) eq () ) {
-			$returnType =~ s/^.*::.*$/int/;
-		} else {
-			$returnType = cplusplusToPInvoke($returnType);
-		}
-
-		if ( $returnType eq "RawObject") {
-			$returnType = "IntPtr";
-		}
-
-		my $cparams = $m->{Params};
-		my $cplusplusparams;
-		my $pinvokeparams;
-		my $pinvokeargs;
-
-		# TODO port to $m->{ParamList}
-		$cparams =~ s/\s+/ /g;
-		$cparams =~ s/\s*([,\*\&])\s*/$1 /g;
-		$cparams =~ s/^\s*void\s*$//;
-		my $argId = 0;
-		my @cargs = kdocUtil::splitUnnested(",", $cparams);
-		$cparams = "";
-		foreach my $arg ( @cargs ) {
-			my $argType;
-			my $cargType;
-			my $PHPargType;
-			my $pinvokeargType;
-			if ( $arg =~ /^\s*$/ ) {
-				next;
-			}
-
-			# A '<arg> = <value>' default parameter
-			$arg =~ s/\s*([^\s].*[^\s])\s*/$1/;
-			$arg =~ s/(\w+)\[\]/\* $1/;
-			$arg =~ s/=\s*(("[^\"]*")|(\'.\')|(([-\w:.]*)\s*(\|\s*[-\w]*)*(\(\w*\))?))//;
-
-			if ( $arg =~ /^(.*)\s+(\w+)\s*$/ ) {
-				$argType = $1;
-				$arg = $2;
-			} else {
-				$argType = $arg;
-				$argId++;
-				$arg = "arg".$argId;
-			}
-			$arg =~ s/^id$/identifier/;
-			$argType =~ s/\s*([^\s].*[^\s])\s*/$1/;
-			$argType =~ s/\s*const//g;
-			$argType =~ s/^\s*//;
-			$argType =~ s/([\*\&])\s*([\*\&])/$1$2/;
-			$cargType = kalyptusDataDict::ctypemap($argType);
-			$PHPargType = cplusplusToZEND($argType);
-			$pinvokeargType = cplusplusToPInvoke($argType);
-
-			if ( $PHPargType eq "" ) {
-				$PHPargType = $argType;
-				$PHPargType =~ s/\&/\*/;
-				$PHPargType =~ s/^.*::.*$/int/;
-			}
-			if ( $pinvokeargType eq "" ) {
-				$pinvokeargType = $argType;
-				$pinvokeargType =~ s/\&/\*/;
-				$pinvokeargType =~ s/^.*::.*$/int/;
-			}
-
-			if ( $pinvokeargType =~ /IntPtr/ ) {
-				$pinvokeargs .= "$arg.Ptr, ";
- 			} elsif ( $PHPargType =~ /\./ ) {
-				$pinvokeargs .= "($pinvokeargType)$arg, ";
-			} else {
-				$pinvokeargs .= "$arg, ";
-			}
-
-			if ( $pinvokeargType =~ /RawObject/ ) {
-				 $pinvokeargType =~ s/RawObject/IntPtr/;
-			}
-
-# save these attributes for ctor
-            @ctor_params[$pCount++] = [$PHPargType,$arg,$argType];
-
-            $PHPparams .= "$PHPargType $arg, ";
-            $pinvokeparams .= "$pinvokeargType $arg, ";
-		}
-		$cparams =~ s/, $//;
-		$cplusplusparams =~ s/, $//;
-		$PHPparams =~ s/, $//;
-		$pinvokeparams =~ s/, $//;
-		$pinvokeargs =~ s/, $//;
-
-		my $flags = $m->{Flags};
-
-		if ( !defined $flags ) {
-			warn "Method ".$m->{astNodeName}.  " has no flags\n";
-		}
-
-
-		my $extra = "";
-		$extra .= "static " if $flags =~ "s";
-
-		if ( $name =~ /operator/  ) {
-			return;
-		}
-
-		if ( $m->{Access} =~ /protected/ && $name ne $class->{astNodeName}  ) {
-			if ( $class->{Pure} ) {
-				return;
-			}
-
-			$name = "protected_".$name;
-		}
-
-		$m->{Access} =~ /([^_]*)(.*)?\s*/;
-		$PHPaccess = $1;
-		if ( $extra =~ /static/ ) {
-			$PHPaccess .= " static";
-		}
-
-		if ( $name eq $class->{astNodeName} && $class->{Pure} ) {
-			return;
-		}
-
-		if ( defined $docnode ) {
-			if ( defined $docnode->{Text} ) {
-				print CLASS "\n/** ";
-				my $node;
-				my $line;
-				foreach $node ( @{$docnode->{Text}} ) {
-					next if $node->{NodeType} ne "DocText";
-					$line = $node->{astNodeName};
-					print CLASS $line, "\n";
-				}
-				print CLASS "*/\n";
-			}
-		}
-
-		#This is to make sure we have no duplicate methods...
-		my $currentmethod .= "$name $returnType $PHPparams";
-		my $pastmethod .= "$pastname $pastreturn $pastparams";
-
-        if($currentmethod ne $pastmethod) {
-            if ( $name =~ /.*Event$/ ) {
-                return;
-            }
-# prepare arguments
-            mergeNumbers($class,$m);
-	    }
-	}
-	#Part of the duplicate methods check.
-	$pastname = $name;
-	$pastreturn = $returnType;
-	$pastparams = $PHPparams;
-
-	$PHPparams = "";
-
-}
-
-sub generateClassMethodForEnum
-{
-	my( $class, $m ) = @_;
-	my $enum = $m->{astNodeName};
-	my $PHPaccess;
-
-	$m->{Access} =~ /([^_]*)(.*)?\s*/;
-	$PHPaccess = $1;
-
-	if( $m->{NodeType} eq "enum" ) {
-		my $enum = $m->{astNodeName};
-		my @enums = split(",", $m->{Params});
-		my $enumCount = 0;
-
-		if($enum ne " ") {
-			print CLASS "\n\n/*\t\t$PHPaccess enum", $enum,":long {";
-
-			foreach my $enum_ ( @enums ) {
-				$enum_ =~ s/\s//g;
-				$enum_ =~ s/::/./g;
-				if($#enums == $enumCount){
-
-					if ( $enum_ =~ /(.*)=(.*)/ ) {
-						print CLASS "\n\t\t\t$1 = $2";
-					} else {
-						print CLASS "\n\t\t\t$enum = $enumCount";
-					}
-
-				} else {
-
-					if ( $enum_ =~ /(.*)=(.*)/ ) {
-						print CLASS "\n\t\t\t$1 = $2,";
-					} else {
-						print CLASS "\n\t\t\t$enum = $enumCount,";
-					}
-
-				}
-#                $enum =~ s/=//g;
-                my @constant = split(/=/,$enum_);
-
-# what to skip?
-                    if(!(
-                            $class->{astNodeName} =~ /QContextMenuEvent/
-                        ||  $class->{astNodeName} =~ /QInputMethodEvent/
-                        ||  $class->{astNodeName} =~ /QPainter/
-                        ||  $class->{astNodeName} =~ /QTabletEvent/
-                    )){
-                        print AG_QT_MINIT "\t  REGISTER_LONG_CONSTANT(\"",uc($class->{astNodeName}),"_",uc($enum),"_",uc($constant[0]),"\", ",$class->{astNodeName},"::",$constant[0],", CONST_CS | CONST_PERSISTENT);\n";
-                        $enumCount++;
-                    }
-			}
-
-			print CLASS "\n\t\t}\n*/";
-		}
-	}
-}
-
-sub print_r
-{
-    my ( $cnode ) = @_;
-
-    my @n = Ast::GetProps($cnode);
-    foreach $a ( @n ) {
-        print CLASS ">",$a,": ",$cnode->{$a},"\n";
-    }
-}
-
-# groups arguments regarding argument count
-
-sub mergeNumbers
-{
-	my ( $class, $cnode )  = @_;
-
-    my $functionname = $cnode->{astNodeName};
-    my $classname = $class->{astNodeName};
-
-    foreach my $key ( keys %methods ) {
-		if ( $key eq $functionname ) {
-            #add to existing
-			$methods{ $key }->AddPropList("method", $cnode);
-			return;
-		}
-    }
-
-    # add new
-    $methods{ $functionname } = Ast::New( $functionname );
-    $methods{ $functionname }->AddPropList("method",$cnode);
-
-}
-
-# finds equal strings and groups them
-
-sub mergeEquals {
-
-    my ($classname, $count, @args) = @_;
-    # find all equal strings
-
-    my @param_check;
-    my %tmp;
-    my $skip = 0;       # helping
-# create all strings
-    foreach my $method (@args){
-        my $paramstring = "";
-        foreach my $param ( @{$method->{ParamList}} ) {
-
-# add cast type
-            $param->AddProp("cast",$param->{ArgType});
-            $param->{cast} = checkCast($param->{cast});
-
-            $param = checkEnum($param);
-
-# TODO: test it with QByteArray
-            if ( $param->{ArgType} =~ /const char/ ) {
-                $paramstring .= "s";
-            } elsif ( $param->{ArgType} =~ /char/ ) {
-                $paramstring .= "l";
-            } elsif ( $param->{ArgType} =~ /int/ ) {
-                $paramstring .= "l";
-            } elsif ( $param->{ArgType} =~ /double/ ) {
-                $paramstring .= "l";
-            } elsif ( $param->{ArgType} =~ /bool/ ) {
-                $paramstring .= "b";
-            } else {
-                $paramstring .= "o";
-            }
-        }
-
-        push @param_check, $paramstring;
-
-# check if already available
-        foreach my $key ( keys %tmp ) {
-# yes: add
-            if ( $key eq $paramstring ) {
-                #add to existing
-                $tmp{ $key }->AddPropList("params", $method);
-                $skip = 1;
-                last;
-            }
-        }
-# no: create new
-        if($skip == 0){
-            $tmp{ $paramstring } = Ast::New( $paramstring );
-            $tmp{ $paramstring }->AddPropList("params",$method);
-        }
-        $skip = 0;
-# add method name
-        $tmp{ $paramstring }->AddProp("methodname",$method->{astNodeName});
-        $tmp{ $paramstring }->AddProp("ReturnType",$method->{ReturnType});
-        $tmp{ $paramstring }->AddProp("Access",$method->{Access});
-        $tmp{ $paramstring }->AddProp("Flags",$method->{Flags});
-
-        if($classname eq $tmp{ $paramstring }->{methodname} ) {
-            $tmp{ $paramstring }->AddProp("ctor","ctor");
-        }
-
-    }
-    
-    return %tmp;
-
-}
-
-# group by count and strings
-
-sub marshal {
-
-    my ($classname, $count, %args) = @_;
-    my $return;
-
-    my $not_empty = %args;
-    if($not_empty){
-        $return .= "\n\tif (ZEND_NUM_ARGS() == ".$count."){\n";
-    }
-
-    my $c = 0;                  # helping variable
-    my $run = 0;
-
-# node is the method
-    foreach my $key (keys %args){
-        # docu
-#        foreach $b ( @{$method->{ParamList}} ) {
-#            $return .= " *    \@param   ".$b->{ArgType}."\n";
-#            $return .= " */\n";
-#        }
-
-# handle arguments at first
-
-        # initialize vars and agruments for zend_parse_parameters
-        my $d = 0;                  # helping variable
-        my $paratype;               # for zend
-        my $shortstring = "\"";    # short string for zend function
-        my $param_zend_function;    # parameter for zend function
-        my @objects;                # object stack
-        my $method = $args{$key};   # helping
-# skip qt_xxx
-        if(
-            $method->{methodname} =~ /qt_/
-            || $method->{methodname} =~ /className/
-        ){
-            last;
-        }
-
-        my $object_selection = "";
-        my $tmp_count = 0;          # helping
-        my $c__ = $c;                # ugly
-        my $param_comment = "\t\t/* ";
-
-# identical strings grouped
-        $return .= "\t\t/* ".$key." ".$method->{Access}."*/\n";
-
-# skip protected method
-        if($method->{Access} eq "protected"){
-            next;
-        }
-
-        $run = $key."_";
-# first parameters are static, the others coincides with this
-# exception: objects
-        my $params = @{$method->{params}}[0];
-
-# parse the first parameters
-        foreach my $first_param (@{$params->{ParamList}})  {
-
-# just a comment
-            $param_comment .= $first_param->{ArgType}." ".$first_param->{ArgName}.", ";
-
-            # comma for param_zend_function params
-            if($d > 0){
-                $param_zend_function .= " ,";
-            }
-
-            $first_param = checkEnum($first_param);
-
-            # the types
-# char
-            if ( $first_param->{ArgType} =~ /const char/ ) {
-                $return .= "\t\tchar* var_".$run.$c__.";   // default: ".$first_param->{DefaultValue}."\n";
-                $return .= "\t\tint len_".$run.$c__.";\n\n";
-
-                $paratype .= ", &var_".$run.$c__.", len_".$run.$c__;
-                $param_zend_function .= " (".$first_param->{ArgType}.") var_".$run.$c__;
-                $shortstring .= "s";
-# int
-            } elsif (
-                $first_param->{ArgType} =~ /int/
-                || $first_param->{ArgType} =~ /char/
-                || $first_param->{ArgType} =~ /short/
-                || $first_param->{ArgType} =~ /double/
-            ) {
-
-                $return .= "\t\tlong var_".$run.$c__.";    // default: ".$first_param->{DefaultValue}."\n";
-
-                $paratype .= ", &var_".$run.$c__;
-# cast if param is an enum
-                if(defined $first_param->{cast}){
-                    $param_zend_function .= "(".$first_param->{cast}.") var_".$run.$c__;
-                } else {
-                    $param_zend_function .= "(".$first_param->{ArgType}.") var_".$run.$c__;
-                }
-                $shortstring .= "l";
-# bool
-            } elsif ( $first_param->{ArgType} =~ /bool/ ) {
-                $return .= "\t\tbool var_".$run.$c__.";   // _default: ".$first_param->{DefaultValue}."\n";
-
-                $paratype .= ", &var_".$run.$c__;
-                $param_zend_function .= "(".$first_param->{ArgType}.") var_".$run.$c__;
-                $shortstring .= "b";
-# objects
-            } else {
-# while overloading, only one object will be created, query for name
-
-                $return .= "\t\tzval* z_var_".$run.$c__.";   // default: ".$first_param->{DefaultValue}."\n";
-
-                $paratype .= ", &z_var_".$run.$c__;
-                $param_zend_function .= "() var_o_".$c__; # deprecated
-                $shortstring .= "o";
-                push @objects, "var_".$run.$c__;   # ?
-                # name query
-                $object_selection .= "\t\t\tQString tmp_".$run.$tmp_count++."(var_".$run.$c__."->metaObject()->className());\n";
-            }
-            if(exists $first_param->{DefaultValue} != ""){
-                $shortstring .= "|";
-            }
-            $c__++;
-            $d++;
-        }
-        $return .= "\n";
-# add additional objects
-        $param_comment .= " */\n";
-        $return .= $param_comment;
-
-        foreach my $params (@{$method->{params}}){
-
-            my $skip_first = 1;
-            $tmp_count = 0;
-#            $c = $c__;
-# found in qpainter
-            $c__ = $c;
-            my $c_ = 0;
-
-# skip first, this was already created
-            my $object_test;
-            my $object_call;
-            my $obj_first = 1;
-# parse the rest
-            foreach my $param ( @{$params->{ParamList}} ) {
-
-                $param = checkEnum($param);
-
-                if($skip_first == 1){
-                    $object_selection .= "\t\t\t";
-                    $skip_first = 0;
-                } else {
-                    $object_call .= ", ";
-                }
-
-# char
-                if ( $param->{ArgType} =~ /char/ ) {
-                    $object_call .= "(".$param->{ArgType}.") var_".$run.$c__;
-# int
-# short
-# double
-                } elsif (
-                    $param->{ArgType} =~ /int/
-                    || $param->{ArgType} =~ /short/
-                    || $param->{ArgType} =~ /double/
-                ) {
-                    if(defined $param->{cast}){
-                        $object_call .= "(".$param->{cast}.") var_".$run.$c__;
-                    } else {
-                        $object_call .= "(".$param->{ArgType}.") var_".$run.$c__;
-                    }
-# bool
-                } elsif ( $param->{ArgType} =~ /bool/ ) {
-                    $object_call .= "(".$param->{ArgType}.") var_".$run.$c__;
-# object
-                } else {
-                    if($obj_first == 1){
-                        $obj_first = 0;
-                    } else {
-                        $object_test .= " && ";
-                    }
-# temporarly
-                    my $objectname = $param->{ArgType};
-                    $objectname =~ s/[*&]//;
-                    $object_test .= "tmp_".$run.$tmp_count++." == \"".checkCast($objectname)."\"";
-                    $object_call .= "(".checkCast($param->{ArgType}).") ".$objects[$c_++];
-
-                }
-                $c__++;
-            } # foreach param
-
-            if(!$obj_first){
-                $object_selection .= "\n\t\t\tif(".$object_test.") {\n";
-                $object_selection .= "\t".createReturn($classname, $method, $object_call);
-                $object_selection .=  "\t\t\t}";
-            }
-        } # foreach params
-
-        $shortstring .= "\"";
-
-# write zend_parse_parameters method
-        $return .= "\t\tif(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,".$shortstring.$paratype.") == SUCCESS) {\n";
-# only if ctor
-        if(!($method->{ctor} eq "ctor")) {
-            $return .= "\t\t\t".$classname." *obj = (".$classname."*) PHP_QT_FETCH();\n";
-        }
-
-# objects as return type
-        my $obj;
-        my $objc = 0;
-        foreach $obj ( @objects ) {
-            $return .= "\t\t\tQObject* ".$obj." = (QObject*) php_qt_fetch(z_".$obj.");\n";
-            $objc++;
-        }
-
-# add object handling
-        my $not_empty = %args;
-        if($not_empty){
-            $return .= "\n".$object_selection;
-            undef $object_selection;
-            $return .= "\n";
-# $c counts objects, if there is no object the return mechanism has to be created
-            if($objc == 0){
-                $return .= createReturn($classname, $method, $param_zend_function);
-            }
-            if($c > 0){
-                $return .= "\t\t}\n";
-# break run if there are objects
-                next;
-            }
-        }
-
-# return handling
-#        $return .= createReturn($classname, $method, $param_zend_function);
-
-        $return .= "\t\t}\n";
-        $tmp_count=0;
-
-    } # foreach args
-
-    my $not_empty = %args;
-    if($not_empty){
-        $return .= "\t}\n";
-    }
-
-    return $return;
-}
-
-sub createReturn {
-
-    my ($classname, $method, $param_zend_function) = @_;
-    my $return;
-
-# sometimes it goes wrong
-# it is more secure to re-check that
-    if($classname eq $method->{astNodeName} ) {
-        $method->AddProp("ctor","ctor");
-    }
-
-
-# constructor
-    if($method->{ctor} eq "ctor"){
-        $return .= "\t\t\t".$classname." *".$classname."_ptr = new ".$classname."(".$param_zend_function.");\n";
-        $return .= "\t\t\tPHP_QT_REGISTER(".$classname."_ptr);\n";
-# php class members here
-        $return .= "\t\t\tRETURN_NULL();\n";
-        return $return;
-    }
-
-# no arguments, no object created
-    if($param_zend_function eq ""){
-        $return .= "\t\t\t".$classname." *obj = (".$classname."*) PHP_QT_FETCH();\n";
-    }
-
-    my $methodname;
-    if (defined $method->{methodname}) {
-        $methodname = $method->{methodname}
-    } else {
-        $methodname = $method->{astNodeName} if defined $method->{astNodeName};
-    }
-
-    my $returntype = $method->{ReturnType};
-
-    my $zend_return_type = cplusplusToZEND($returntype);
-
-# handle return value here
-# if no return type specified
-        if ( $zend_return_type eq "NULL" || !defined $zend_return_type) {
-            $return .=  "\t\t\tobj->".$methodname."(".$param_zend_function.");\n";
-            $return .=  "\t\t\tRETURN_NULL();\n";
-# const char*
-        } elsif ( $zend_return_type =~ /char/ ){
-            $return .=  "\t\t\tRETURN_STRING((char*) obj->".$methodname."(".$param_zend_function."), 1);\n" if defined $zend_return_type;
-        } elsif ( $zend_return_type =~ /byte/ ) {
-            $return .= "\t\t// bytearray, skipped\n";
-            $return .= "\t\tRETURN_NULL();\n";
-#if return type is an object
-        } elsif ( $zend_return_type =~ /zval/ ) {
-#        TODO: consider 'const',
-#        and non-pointer types, pointer types
-            $return .=  "\t\t\t".checkCast($returntype)." return_object = (".checkCast($returntype).") obj->".$methodname."(".$param_zend_function.");\n";
-            $return .=  "\t\t\t\tzend_class_entry *ce;                                   \n";
-            $return .=  "\t\t\t\tobject_init_ex(return_value, ".$classname."_ce_ptr);     \n";
-            $return .=  "\t\t\t\tzend_rsrc_list_entry le;                            \n";
-            $return .=  "\t\t\t\tle.ptr = (void*) &return_object;                                       \n";
-            $return .=  "\t\t\t\tphp_qt_register(return_value,le);                   \n";
-            $return .=  "\t\t\t\treturn;                                             \n";
-#simple types
-        } else {
-            $return .=  "\t\t\tRETURN_".uc($zend_return_type)."(obj->".$methodname."(".$param_zend_function."));\n" if defined $zend_return_type;
-        }
-
-    if(!defined $zend_return_type){
-        $return .= "";
-    }
-
-    return $return;
-
-}
-
-sub checkEnum(){
-    my ($param) = @_;
-
-        my $ArgType = kalyptusDataDict::ctypemap($param->{ArgType});
-
-    if(!($param->{ArgType} =~ /qt_/)){
-        if($ArgType eq ""){
-            $ArgType = "int";
-            $ArgType = $param->{ArgType};
-        }
-
-        $param->{ArgType} = $ArgType;
-    }
-
-    return $param;
-}
-
-# check additional header files
-sub checkIncludes(){
-    my ($class) = @_;
-    my $return;
-
-    if($class->{astNodeName} eq "QFont") {
-        $return .= "#include <QStringList>\n";
-    }
-    if($class->{astNodeName} eq "QPainter") {
-        $return .= "#include <QPainterPath>\n";
-    }
-
-    return $return;
-
-}
-
-sub checkCast(){
-
-    my ($returntype) = @_;
-
-    if($returntype eq 'Style') {
-        $returntype = "QFont::Style";
-    }
-    if($returntype eq 'StyleHint') {
-        $returntype = "QFont::StyleHint";
-    }
-    if($returntype eq 'StyleStrategy') {
-        $returntype = "QFont::StyleStrategy";
-    }
-    if($returntype eq 'CompositionMode') {
-        $returntype = "QPainter::CompositionMode";
-    }
-    if($returntype eq 'RenderHint') {
-        $returntype = "QPainter::RenderHint";
-    }
-
-    $returntype =~ s/qt_//;
-
-    return $returntype;
-}
-
-
-1;
-



From tm243 at berlios.de  Wed May 24 17:31:29 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Wed, 24 May 2006 17:31:29 +0200
Subject: [Php-qt-svn] r246 - trunk/tools
Message-ID: <200605241531.k4OFVTvL031847@sheep.berlios.de>

Author: tm243
Date: 2006-05-24 17:31:29 +0200 (Wed, 24 May 2006)
New Revision: 246

Added:
   trunk/tools/kalyptusCxxToPHP.pm
Log:
php extension for kalyptus rewritten.

Added: trunk/tools/kalyptusCxxToPHP.pm
===================================================================
--- trunk/tools/kalyptusCxxToPHP.pm	2006-05-24 15:30:37 UTC (rev 245)
+++ trunk/tools/kalyptusCxxToPHP.pm	2006-05-24 15:31:29 UTC (rev 246)
@@ -0,0 +1,907 @@
+#***************************************************************************
+#    copyright            : (C) 2006 Thomas Moenicke
+#    email                : tm at ippfp.org
+#    author               : Thomas Moenicke
+#***************************************************************************/
+
+#/***************************************************************************
+# *                                                                         *
+# *   This program is free software; you can redistribute it and/or modify  *
+# *   it under the terms of the GNU General Public License as published by  *
+# *   the Free Software Foundation; either version 2 of the License, or     *
+# *   (at your option) any later version.                                   *
+# *                                                                         *
+#***************************************************************************/
+
+# sub cplusplusToZEND               $cplusplusType
+# sub cplusplusToZENDType           $cplusplusType
+# sub cplusplusToPInvoke            $cplusplusType
+# sub cplusplusToMacro              $class, $cnode
+
+# sub writeDoc                      $lib, $rootnode, $outputdir, $opt
+# sub writeClassDoc                 $node
+
+
+package kalyptusCxxToPHP;
+
+use File::Path;
+use File::Basename;
+
+use Carp;
+use Ast;
+use kdocAstUtil;
+use kdocUtil;
+use Iter;
+use kalyptusDataDict;
+
+#use strict;
+no strict "subs";
+
+use vars qw/
+    @clist
+    $host $who $now $gentext %functionId $docTop
+	$lib $rootnode $outputdir $opt $debug $typeprefix $eventHandlerCount
+	$pastaccess $pastname $pastreturn $pastparams $nullctor $ctorCount @properties @functions @constructors
+
+    %methods
+
+    $classname;
+    *CLASS
+    *HEADER
+
+    *AG_ZEND_CLASS_ENTRY
+    *AG_EXTERN_ZEND_CLASS_ENTRY
+    *AG_VOID_REGISTER
+    *AG_ZEND_PHP_QT
+    *AG_CONFIGM4
+    *AG_QT_MINIT
+    *AG_PHP_QT_CPP
+
+    *QTCTYPES
+    *KDETYPES
+    /;
+
+
+BEGIN
+{
+    @clist = ();
+
+    # Page footer
+
+	$who = kdocUtil::userName();
+	$host = kdocUtil::hostName();
+	$now = localtime;
+	$gentext = "$who using kalyptus $main::Version.";
+
+	$docTop =<<EOF
+ * begin           : $now
+ * generated by    : $gentext
+ */
+EOF
+}
+
+#   for all header files
+
+#   $lib            not used
+#   $rootnode       rootnode of Ast
+#   $outputdir      string of dirname
+#   $opt            not used
+
+sub writeDoc
+{
+	my ( $lib, $rootnode, $outputdir_, $opt ) = @_;
+
+    $outputdir = $outputdir_;
+
+#    kdocAstUtil::dumpAst($rootnode);
+
+    openAllFiles();
+
+	# Document all compound nodes
+	Iter::LocalCompounds( $rootnode, sub { writeClassDoc( shift ); } );
+
+    closeAllFiles();
+
+}
+
+# for one class
+
+sub writeClassDoc
+{
+	my( $class ) = @_;
+    $classname = $class->{astNodeName};
+
+    openClassFile($class);
+
+    checkIncludes($class);
+    writeAllFiles($class);
+
+    DerivedClass($class);
+
+    handleAllMethods($class);
+    Inheritance($class);
+
+    closeClassFile();
+
+}
+
+# all methods of this class
+
+sub handleAllMethods
+{
+    my ($class) = @_;
+
+    %methods = ();
+
+	Iter::MembersByType ($class,sub{},
+		sub
+        {
+            my ($class, $kid ) = @_;
+            if ($kid->{NodeType} eq "property" )
+            {
+                push @properties, $kid;
+            }
+            if($kid->{NodeType} eq "method")
+            {
+                mergeMethods($kid);
+            }
+        },sub {}
+	);
+
+    foreach my $key (keys %methods)
+    {
+        $method = %methods->{$key};
+
+        writeMethodDoc($method);
+        handleMethod($method);
+
+    }
+}
+
+# all args of this method
+#
+# every method has a list of arguments from overloaded methods
+#
+sub handleMethod
+{
+    my ( $method ) = @_;
+
+    my $methodname = $method->{astNodeName};
+    $methodname = "__construct" if($methodname eq $classname);
+
+    print CLASS "ZEND_METHOD(".$classname.",".$methodname."){";
+    print CLASS "PHP_QT_FETCH_ARGS();";
+
+    my $first = "true";
+    # get _all_ arg
+    ARGLIST: foreach my $overloadedmethod (@{$method->{"argList"}})
+    {
+        if($first eq "true"){
+            $first = "false";
+            next;
+        }
+
+        my @cargs = kdocUtil::splitUnnested(",", $overloadedmethod->{Params});
+        my $params;     # collect args for every try
+
+        my $zend_args_query;        # parameter for the type check statement
+        my $ce_ptr_query;           # parameter for the class check statement
+        my $count_args=0;
+        my @stack = ();             # argument stack, regular parameters
+        my @stack_optional = ();    # argument stack, optional parameters
+
+        my @ifdef_stack = ();       # object safety
+
+        # check whether agument is optional or regular
+        foreach my $cpp_arg ( @cargs ) {
+
+            if($cpp_arg =~ /=/){
+                push(@stack_optional,$cpp_arg);
+            } else {
+                push(@stack,$cpp_arg);
+            }
+        }
+
+        #
+        # all regular args
+        #
+        foreach $cpp_arg (@stack){
+
+            $params .= $cpp_arg.","; # collect args for this try
+            $zend_arg = cplusplusToZVAL($cpp_arg);
+
+            # intercept unknown types
+            if($zend_arg eq "unknown"){
+                print CLASS "\n// notice: unknown argument ".$cpp_arg.", skipped\n";
+                next ARGLIST;
+            }
+
+            $zend_args_query .= " && Z_TYPE_P(args[".$count_args."]) == IS_".$zend_arg;
+            if($zend_arg eq "OBJECT"){
+                if($count_args > 1){
+                    $ce_ptr_query .= "&& ";
+                }
+                $ce_ptr_query .= "Z_OBJCE_P(args[".$count_args."]) == ".unwrapClassType($cpp_arg)."_ce_ptr";
+                push(@ifdef_stack,unwrapClassType($cpp_arg));
+            }
+            $count_args++;
+        }
+
+        # type check
+        print CLASS "\n\t///".$overloadedmethod->{Params}."\n";
+
+        # ifdef
+        print CLASS "#ifdef PHP_QT_".unwrapClassType($method->{ReturnType})." // return type\n\n"
+            if cplusplusToZVAL($method->{ReturnType}) eq "OBJECT";
+
+        print CLASS "if(ZEND_NUM_ARGS() == ".$count_args.$zend_args_query."){";
+
+        # class check if object
+        if($ce_ptr_query ne ""){
+            print CLASS "".expandIfdefs(@ifdef_stack);  # ifdef PHP_QT_QString
+            print CLASS " if(".$ce_ptr_query."){";
+            handleArguments($params,$method->{ReturnType},$method->{Flags}, $methodname); # argument handling
+            print CLASS "}\n";
+            print CLASS "".expandEndifs(@ifdef_stack);  # endif
+
+        # simple types
+        } else {
+            handleArguments($params,$method->{ReturnType},$method->{Flags}, $methodname); # argument handling
+        }
+        print CLASS "}";
+
+        #
+        # for all optional parameters
+        #
+        foreach $cpp_arg (@stack_optional){
+
+            $params .= $cpp_arg.","; # collect args for this try
+            $zend_arg = cplusplusToZVAL($cpp_arg);
+
+            # intercept unknown types
+            if($zend_arg eq "unknown"){
+                print CLASS "\n// notice: unknown argument ".$cpp_arg.", skipped\n";
+                next ARGLIST;
+            }
+
+            $zend_args_query .= " && Z_TYPE_P(args[".$count_args++."]) == IS_".$zend_arg;
+
+            # type check
+            print CLASS "if(ZEND_NUM_ARGS() == ".$count_args.$zend_args_query."){";
+
+            # if object
+            if($ce_ptr_query ne ""){
+                print CLASS "".expandIfdefs(@ifdef_stack);  # ifdef PHP_QT_QString
+                print CLASS " if(".$ce_ptr_query."){";  # ask object types
+                handleArguments($params,$method->{ReturnType},$method->{Flags}, $methodname); # argument handling
+                print CLASS "}\n";
+                print CLASS "".expandEndifs(@ifdef_stack);  # endif
+            # if simple type
+            } else {
+                # argument handling
+                handleArguments($params,$method->{ReturnType},$method->{Flags}, $methodname);
+            }
+            print CLASS "}"; # end type check
+
+        } # stack_optional
+
+        # ifdef
+        print CLASS "#endif // return type\n\n" if cplusplusToZVAL($method->{ReturnType}) eq "OBJECT";
+    }
+
+    print CLASS "php_error(E_ERROR,\"could not parse argument\");";
+    print CLASS "}\n";
+
+}
+
+#
+# prepare and invoke args for a try
+#
+
+sub handleArguments
+{
+    my ( $params, $return, $flags, $methodname ) = @_;
+
+    my $returnType = cplusplusToZVAL($return);      # example: BOOL, LONG, DOUBLE, STRING, OBJECT
+    if($returnType eq "unknown"){
+        print CLASS "php_error(E_ERROR,\"unsupported return type ".$return."\");";
+        return;
+    }
+
+    if($flags =~ /s/){
+    } else {
+        print CLASS "if(getThis() == NULL){php_error(E_ERROR,\"method '".$methodname."' is not static\"); RETURN_NULL;}";
+    }
+
+
+    my $preparation;    # invoke zend to cpp, prepare return object if necessary
+    my $cpp_call_params;    # the args passed to Qt method
+    my $count_args = 0;
+    my @cargs = kdocUtil::splitUnnested(",", $params);  # fetch args
+
+    $preparation .= "\n\t/// try ".$params."\n";
+    $preparation .= "if(getThis != NULL){".$classname." *selfpointer = static_cast<".$classname."*>(PHP_QT_FETCH());}";
+
+    # argument handling
+    foreach $arg (@cargs) {
+
+        $argType = cplusplusToZVAL($arg);
+
+        # should never happen, checked above
+        if($argType eq "unknown"){
+            print CLASS "\n// unknown, skipped: ".$arg."\n";
+            return; # return arg handling
+        }
+
+        # for all arg types, e.g. bool*
+        $classType = unwrapClassType($arg);
+
+        # handling of pointers, references
+        my $postfix, $prefix, $prefix_ZVAL;
+        if(checkRPN($arg) eq "reference"){
+            $postfix = "&"; # cast (old c cast)
+            $prefix = "*";  # dereferencing the pointer
+        } elsif (checkRPN($arg) eq "pointer"){
+            $postfix = "*"; # cast
+            $prefix = "";   # nothing, is already a pointer
+            $prefix_ZVAL = "&";
+        } elsif (checkRPN($arg) eq "normal"){
+            $prefix = "*";  # dereferencing the pointer
+            $postfix = "";  # nothing to do here
+        }
+
+        $cpp_call_params .= "(".checkConst($arg)." ".$classType.$postfix.")";
+
+        if($argType eq "OBJECT"){
+            # example: QString *cpp_arg_0 = static_cast<QString*>(php_qt_fetch(args[0]);
+            $preparation .= $classType." *cpp_arg_".$count_args." = static_cast<".$classType."*>(php_qt_fetch(args[".$count_args."]));\n";
+            $cpp_call_params .= $prefix."cpp_arg_".$count_args." ";
+        } else {
+            # example: Z_LVAL_P(arg_0), Z_STRVAL(arg_0)
+            $cpp_call_params .= $prefix_ZVAL."Z_".invokeTypeToZ_XVAL($argType)."VAL_P(args[".$count_args."]) ";
+        }
+
+        $cpp_call_params .= ",";
+        $count_args++;
+    }
+
+    chop($cpp_call_params); # remove last comma
+
+    print CLASS $preparation;   # printout declaration
+
+    # return handling
+    my $returnClassName = unwrapClassType($return); # example: QString (from QString &c)
+    my $prefix, $postfix, $infix;
+
+    if(checkRPN($return) eq "reference"){       # tested
+        $prefix = $returnClassName."&";
+        $infix = "&";
+    } elsif (checkRPN($return) eq "pointer"){
+        $prefix = $returnClassName."* ";
+    } elsif (checkRPN($return) eq "normal"){    # tested with non-objects
+        # allocate memory on the heap
+        if($returnType eq "OBJECT"){
+            print CLASS $returnClassName." *return_object = new ".$returnClassName.";\n";
+        }
+        $prefix = "*";
+    }
+
+    if($returnType eq "OBJECT"){
+        if($flags =~ /s/){
+            print CLASS "if(getThis() == NULL){".$prefix." return_object = static_cast<"                .$returnClassName.$infix.">(".$classname."::".$method->{astNodeName}."(".$cpp_call_params."));} else {print CLASS "                .$prefix." return_object = static_cast<"               .$returnClassName.$infix.">(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));}";
+        } else {
+            print CLASS $prefix." return_object = static_cast<"
+                .$returnClassName.$infix.">(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));";
+        }
+        print CLASS "zend_class_entry *ce;";
+        print CLASS "object_init_ex(return_value, QString_ce_ptr);";
+        print CLASS "zend_rsrc_list_entry le;";
+        print CLASS "le.ptr = (void*) ".$infix."return_object;";
+        print CLASS "php_qt_register(return_value,le);";
+        print CLASS "return;";
+    } else {
+        if($method->{astNodeName} eq $classname){
+            print CLASS "PHP_QT_REGISTER(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));";
+        } else {
+            if($flags =~ /s/){
+                print CLASS "if(getThis() == NULL){RETURN_".$returnType."(".$classname."::"
+                    .$method->{astNodeName}."(".$cpp_call_params."));} else {RETURN_"
+                    .$returnType."(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));}";
+            } else {
+                print CLASS "RETURN_".$returnType."(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));";
+            }
+        }
+    }
+}
+
+# group and merge methods by name, for argument handling
+
+sub mergeMethods
+{
+	my ( $method )  = @_;
+
+    # looking for existing list
+    foreach my $key ( %methods ) {
+        if ( $key->{astNodeName} eq $method->{astNodeName} ) {
+            #add to existing list
+            push(@{$methods{ $method->{astNodeName} }->{"argList"}},$method);
+	        return;
+ 		}
+    }
+
+    # add new list
+    $methods{ $method->{astNodeName} } = $method;
+
+    my $methodlist = ();
+    $methods{ $method->{astNodeName} }->AddProp("methodname", $method->{astNodeName});
+    $methods{ $method->{astNodeName} }->AddPropList("argList", $methodlist);
+
+    push(@{$methods{ $method->{astNodeName} }->{"argList"}},$method);
+
+}
+
+# write documentation for method
+
+sub writeMethodDoc
+{
+    my ( $method ) = @_;
+
+        print CLASS "/*!\n";
+        print CLASS " * method ".$method->{astNodeName}."\n";
+        print CLASS " * \n";
+
+        foreach my $overloadedmethod (@{$method->{"argList"}})
+        {
+            my @cargs = kdocUtil::splitUnnested(",", $overloadedmethod->{Params});
+
+            # mark as overloaded
+            if(@cargs>0) {
+                print CLASS " * \n";
+                print CLASS " * overloaded args:\n";
+            } else {
+                print CLASS " * \@param: -\n";
+            }
+
+            foreach my $arg ( @cargs ) {
+                print CLASS " * \@param\t".$arg."\n";
+            }
+
+        }
+
+        print CLASS " * \n";
+        print CLASS " * \@access\t".$method->{Access}."\n";
+        print CLASS " * \@return\t".$method->{ReturnType}."\n";
+        print CLASS " * \@flags\t".$method->{Flags}."\n";
+        print CLASS " */\n\n"
+
+}
+
+################################################################################
+#                                                                              #
+#   HELPER FUNCTIONS                                                           #
+#                                                                              #
+################################################################################
+
+sub openAllFiles
+{
+
+	mkpath( $outputdir ) unless -f $outputdir;
+    mkpath( $outputdir."/classes/" ) unless -f $outputdir."/classes/";
+
+    # AG_ZEND_CLASS_ENTRY
+    my $file_ag_zend_class_entry = "$outputdir/ag_zend_class_entry.inc";
+    open( AG_ZEND_CLASS_ENTRY, ">$file_ag_zend_class_entry" ) || die "Couldn't create $file_ag_zend_class_entry\n";
+    $file_ag_zend_class_entry =~ s/\.h/.h/;
+
+    # AG_EXTERN_ZEND_CLASS_ENTRY
+    my $file_ag_extern_zend_class_entry = "$outputdir/ag_extern_zend_class_entry.inc";
+    open( AG_EXTERN_ZEND_CLASS_ENTRY, ">$file_ag_extern_zend_class_entry" ) || die "Couldn't create $file_ag_extern_zend_class_entry\n";
+    $file_ag_extern_zend_class_entry =~ s/\.h/.h/;
+
+    # AG_ZEND_PHP_QT
+    my $file_ag_zend_php_qt = "$outputdir/ag_zend_php_qt.inc";
+    open( AG_ZEND_PHP_QT, ">$file_ag_zend_php_qt" ) || die "Couldn't create $file_ag_zend_php_qt\n";
+    $file_ag_zend_php_qt =~ s/\.h/.h/;
+
+    # AG_CONFIGM4
+    my $file_ag_configm4 = "$outputdir/ag_configm4.inc";
+    open( AG_CONFIGM4, ">$file_ag_configm4" ) || die "Couldn't create $file_ag_configm4\n";
+    $file_ag_configm4 =~ s/\.h/.h/;
+
+    # AG_QT_MINIT
+    my $file_ag_qt_minit = "$outputdir/ag_qt_minit.inc";
+    open( AG_QT_MINIT, ">$file_ag_qt_minit" ) || die "Couldn't create $file_ag_qt_minit\n";
+    $file_ag_qt_minit =~ s/\.h/.h/;
+
+    # AG_PHP_QT_CPP
+    my $file_ag_php_qt_cpp = "$outputdir/ag_php_qt_cpp.inc";
+    open( AG_PHP_QT_CPP, ">$file_ag_php_qt_cpp" ) || die "Couldn't create $file_ag_php_qt_cpp\n";
+    $file_ag_php_qt_cpp =~ s/\.h/.h/;
+
+    print AG_PHP_QT_MINIT "\n";
+    print AG_ZEND_PHP_QT "/*
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006
+ * Thomas Moenicke <tm\@ippfp.org>,
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef PHP_PHP_QT_H
+#define PHP_PHP_QT_H
+
+extern zend_module_entry php_qt_module_entry;
+#define phpext_php_qt_ptr &php_qt_module_entry
+
+#ifdef ZTS
+#include \"TSRM.h\"
+#endif
+
+PHP_MINIT_FUNCTION(php_qt);
+PHP_MSHUTDOWN_FUNCTION(php_qt);
+PHP_RINIT_FUNCTION(php_qt);
+PHP_RSHUTDOWN_FUNCTION(php_qt);
+PHP_MINFO_FUNCTION(php_qt);
+
+PHP_FUNCTION(confirm_php_qt_compiled);	/* For testing, remove later. */
+
+/* emulate SIGNAL(), SLOT() macros */
+PHP_FUNCTION(SIGNAL);
+PHP_FUNCTION(SLOT);
+    \n\n";
+
+}
+
+# write stuff to files
+sub writeAllFiles
+{
+    my ($node) = @_;
+
+    print AG_ZEND_CLASS_ENTRY "zend_class_entry *",$node->{astNodeName},"_ce_ptr;\n";
+    print AG_ZEND_CLASS_ENTRY "#ifndef PHP_QT_".$classname."\n#define PHP_QT_".$classname."\n\n";
+
+    print AG_CONFIGM4 "\tqt/classes/",lc($node->{astNodeName}),".cpp \\ \n";
+    print AG_EXTERN_ZEND_CLASS_ENTRY "extern zend_class_entry *",$node->{astNodeName},"_ce_ptr;\n";
+    print AG_EXTERN_ZEND_CLASS_ENTRY "void \t_register_",$node->{astNodeName},"();\n";
+
+
+    print PHP_QT_MINIT "\n\t_register_",$node->{astNodeName},"(TSRMLS_C);\n";
+    print AG_QT_MINIT "\n\t_register_",$node->{astNodeName},"(TSRMLS_C);\n";
+
+}
+
+sub closeAllFiles
+{
+
+    print AG_ZEND_PHP_QT "\n/*
+  	Declare any global variables you may need between the BEGIN
+	and END macros here:
+
+ZEND_BEGIN_MODULE_GLOBALS(php_qt)
+	long  global_value;
+	char *global_string;
+ZEND_END_MODULE_GLOBALS(php_qt)
+*/
+
+#ifdef ZTS
+#define PHP_QT_G(v) TSRMG(php_qt_globals_id, zend_php_qt_globals *, v)
+#else
+#define PHP_QT_G(v) (php_qt_globals.v)
+#endif
+
+#endif	/* PHP_PHP_QT_H */
+\n
+    ";
+
+    close AG_ZEND_CLASS_ENTRY;
+    close AG_EXTERN_ZEND_CLASS_ENTRY;
+    close AG_ZEND_PHP_QT;
+    close AG_CONFIGM4;
+    close AG_QT_MINIT;
+    close AG_PHP_QT_CPP;
+}
+
+sub openClassFile
+{
+
+    my ( $node ) = @_;
+
+	my $file = join("__", kdocAstUtil::heritage($node)).".cpp";
+    $file = $outputdir."/classes/".lc($file);
+
+	if( $#{$node->{Kids}} < 0 || $node->{Access} eq "private") {
+		return;
+	}
+	open( CLASS, ">$file" ) || die "Couldn't create $file\n";
+	$file =~ s/\.h/.cpp/;
+
+print CLASS "/*
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006
+ * Thomas Moenicke <tm\@ippfp.org>,
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+";
+
+	print CLASS " * ", $node->{astNodeName}, ".cpp - ", $node->{astNodeName}, " PHP implementation.\n";
+	print CLASS $docTop;
+
+    print CLASS "
+#include <iostream>
+using namespace std;\n";
+
+    print CLASS "#include \"../php_qt.h\"\n\n";
+    print CLASS "\n#include <$node->{astNodeName}>\n";
+
+}
+
+# check additional header files
+# hardcoded
+sub checkIncludes(){
+    my ($class) = @_;
+    my $return;
+
+    if($class->{astNodeName} eq "QFont") {
+        $return .= "#include <QStringList>\n";
+    }
+    if($class->{astNodeName} eq "QPainter") {
+        $return .= "#include <QPainterPath>\n";
+    }
+    if($class->{astNodeName} eq "QApplication") {
+        $return .= "#include <QPalette>\n#include <QFontMetrics>\n#include <QIcon>\n";
+    }
+    if($class->{astNodeName} eq "QCoreApplication") {
+        $return .= "#include <QStringList>\n";
+    }
+    if($class->{astNodeName} eq "QWidget") {
+        $return .= "#include <QIcon>\n";
+    }
+
+    print CLASS $return;
+}
+
+sub DerivedClass
+{
+    my ($node) = @_;
+
+    print CLASS "#include <QMetaMethod>
+    class ".$classname."_php_qt : public ".$classname."{
+
+    public:
+        ".$classname."_php_qt(zval* zend_ptr);
+
+        zval* zend_ptr;
+        QMetaObject* dynamicMetaObject;
+
+        const QMetaObject* metaObject() const;
+        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+    };
+    PHP_QT_MOC(".$classname.");
+";
+# TODO:
+# virtual and private classes
+
+}
+
+#
+
+sub Inheritance
+{
+    my ($node) = @_;
+
+    # find ancestors
+    my @ancestors = ();
+	Iter::Ancestors( $node, $rootnode, undef, undef,
+		sub {
+			my ( $ances, $name, $type, $template ) = @_;
+            push @ancestors, $name;
+		},
+		undef
+	);
+
+    # print mainfile stuff
+    print AG_PHP_QT_CPP "
+    {NULL,NULL,NULL}
+};\n";
+
+    my $zend_inherit = $node->{astNodeName}."_ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);";
+    my $ancestor;
+
+    my $first = 1;
+	foreach $ancestor ( @ancestors ) {
+        if($first) {
+            $zend_inherit = $node->{astNodeName}."_ce_ptr = zend_register_internal_class_ex(&ce TSRMLS_CC, ".$ancestor."_ce_ptr,NULL TSRMLS_CC);\n";
+            $first = 0;
+        } else {
+           $zend_inherit .= "\tzend_do_inheritance(".$node->{astNodeName}."_ce_ptr, ".$ancestor."_ce_ptr TSRMLS_CC);\n";
+        }
+	}
+
+    print AG_PHP_QT_CPP "
+void _register_",$node->{astNodeName},"(TSRMLS_D)
+{
+    zend_class_entry ce;
+    INIT_CLASS_ENTRY(ce,\"",$node->{astNodeName},"\",",$node->{astNodeName},"_methods);
+    ",$zend_inherit,"
+";
+
+# 	Iter::MembersByType ( $node,
+# 		sub { print CLASS "", $_[0], ""; print CLASS "", $_[0], "";  },
+# 		sub {	my ($node, $kid ) = @_;
+#             if ($kid->{NodeType} eq "property"){
+#                 print AG_PHP_QT_CPP "\tPHP_QT_DECLARE_PROPERTY(\"$kid->{astNodeName}\");\n";
+#             }
+#         },
+# 		sub { print CLASS ""; print JNISOURCE ""; }
+# 	);
+
+    print AG_PHP_QT_CPP "
+}\n";
+
+
+}
+
+sub closeClassFile
+{
+    close CLASS;
+}
+
+sub cplusplusToZVAL
+{
+	my ( $cplusplusType )  = @_;
+
+	if ( $cplusplusType =~ /bool/) {
+		return "BOOL";
+	} elsif ( $cplusplusType =~ /\s*void\s*\**/ ) {
+		return "NULL";
+	} elsif ( $cplusplusType =~ /\s*::\s*/) {
+		return "LONG";
+	} elsif ( $cplusplusType =~ /\s*\bint\s*\&*/) {
+		return "LONG";
+	} elsif ( $cplusplusType =~ /\s*int\s*\&*/) {
+		return "LONG";
+	} elsif ( $cplusplusType =~ /\s*short\s*\&*/) {
+		return "LONG";
+	} elsif ( $cplusplusType =~ /\s*char\s*\*\*/ ) {
+		return "STRING";
+	} elsif ( $cplusplusType =~ /\s*char\s*\**/ ) {
+		return "STRING";
+	} elsif ( $cplusplusType =~ /\s*unsigned int\s*\**/ ) {
+		return "LONG";
+	} elsif ( $cplusplusType =~ /\s*unsigned short\s*\**/ ) {
+        return "LONG";
+	} elsif ( $cplusplusType =~ /\s*unsigned long\s*\**/ ) {
+		return "LONG";
+	} elsif ( $cplusplusType =~ /\s*float\s*\**/ ) {
+        return "DOUBLE";
+	} elsif ( $cplusplusType =~ /\s*double\s*\**/ ) {
+        return "DOUBLE";
+	} elsif ( $cplusplusType =~ /\s*unsigned char\s*\**/ ) {
+		return "STRING";
+	} elsif ( $cplusplusType =~ /Q/ ) {
+        return "OBJECT";
+	} else {
+        return "unknown";
+    }
+}
+
+# helper: unwraps the classtype from arg string
+sub unwrapClassType
+{
+    my ($argString) = @_;
+
+    $argString =~ s/const//;
+    $argString =~ s/\*//;
+    $argString =~ s/\&//;
+
+    # skip spaces
+    @c = split(/ /,$argString);
+    foreach(@c){
+        if($_ ne ""){
+            return $_;
+        }
+    }
+
+    return $c[0];
+
+}
+
+# checks for references, pointers, objects
+
+sub checkRPN
+{
+    my ($e) = @_;
+
+    my $rpo;
+
+    if($e =~ /\*/){
+        $rpo = "pointer";
+    } elsif ($e =~ /\&/) {
+        $rpo = "reference";
+    } else {
+        $rpo = "normal";
+    }
+
+    return $rpo;
+
+}
+
+# checks for const
+sub checkConst
+{
+    my ($e) = @_;
+    if($e =~ /const/){
+        return "const";
+    }
+    return "";
+}
+
+# invokes types for the Z_XVAL macro
+sub invokeTypeToZ_XVAL
+{
+    my ($type) = @_;
+    my $Z_VAL = substr($type,0,1);
+    if($Z_VAL eq "S"){
+        return "STR";
+    }
+    # due problems with references
+    if($Z_VAL eq "B"){
+        return "L";
+    }
+
+    return $Z_VAL;
+}
+
+#
+# expand #ifdef PHP_QT_QString ... #endif statements
+#
+
+sub expandIfdefs
+{
+    my (@ifdef_stack) = @_;
+    my $ifdef;
+    foreach $def (@ifdef_stack){
+        $ifdef .= "#ifdef PHP_QT_".$def."\n";
+    }
+    return $ifdef;
+}
+
+sub expandEndifs
+{
+    my (@ifdef_stack) = @_;
+    my $endif;
+    foreach $def (@ifdef_stack){
+        $endif .= "#endif\n\n";
+    }
+    return $endif;
+}
+
+1;


Property changes on: trunk/tools/kalyptusCxxToPHP.pm
___________________________________________________________________
Name: svn:executable
   + *



From tm243 at berlios.de  Thu May 25 11:22:53 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Thu, 25 May 2006 11:22:53 +0200
Subject: [Php-qt-svn] r247 - trunk/tools
Message-ID: <200605250922.k4P9Mrkc010330@sheep.berlios.de>

Author: tm243
Date: 2006-05-25 11:22:52 +0200 (Thu, 25 May 2006)
New Revision: 247

Modified:
   trunk/tools/kalyptusCxxToPHP.pm
Log:
a lot of bugfixes were done.

Modified: trunk/tools/kalyptusCxxToPHP.pm
===================================================================
--- trunk/tools/kalyptusCxxToPHP.pm	2006-05-24 15:31:29 UTC (rev 246)
+++ trunk/tools/kalyptusCxxToPHP.pm	2006-05-25 09:22:52 UTC (rev 247)
@@ -50,6 +50,7 @@
     *HEADER
 
     *AG_ZEND_CLASS_ENTRY
+    *AG_DEFINES
     *AG_EXTERN_ZEND_CLASS_ENTRY
     *AG_VOID_REGISTER
     *AG_ZEND_PHP_QT
@@ -167,6 +168,11 @@
     my ( $method ) = @_;
 
     my $methodname = $method->{astNodeName};
+
+    if(IshouldSkip($method)){
+        return;
+    }
+
     $methodname = "__construct" if($methodname eq $classname);
 
     print CLASS "ZEND_METHOD(".$classname.",".$methodname."){";
@@ -303,14 +309,16 @@
     my ( $params, $return, $flags, $methodname ) = @_;
 
     my $returnType = cplusplusToZVAL($return);      # example: BOOL, LONG, DOUBLE, STRING, OBJECT
+    my $is_constructor = ($method->{astNodeName} eq $classname);
+
     if($returnType eq "unknown"){
         print CLASS "php_error(E_ERROR,\"unsupported return type ".$return."\");";
         return;
     }
 
-    if($flags =~ /s/){
+    if($flags =~ /s/){  # static
     } else {
-        print CLASS "if(getThis() == NULL){php_error(E_ERROR,\"method '".$methodname."' is not static\"); RETURN_NULL;}";
+        print CLASS "if(getThis() == NULL){php_error(E_ERROR,\"method '".$methodname."' is not static\"); RETURN_NULL();}";
     }
 
 
@@ -320,7 +328,9 @@
     my @cargs = kdocUtil::splitUnnested(",", $params);  # fetch args
 
     $preparation .= "\n\t/// try ".$params."\n";
-    $preparation .= "if(getThis != NULL){".$classname." *selfpointer = static_cast<".$classname."*>(PHP_QT_FETCH());}";
+    if(!$is_constructor){   # fetch self pointer
+        $preparation .= "".$classname." *selfpointer; if(getThis() != NULL){selfpointer = static_cast<".$classname."*>(PHP_QT_FETCH());}";
+    }
 
     # argument handling
     foreach $arg (@cargs) {
@@ -341,6 +351,7 @@
         if(checkRPN($arg) eq "reference"){
             $postfix = "&"; # cast (old c cast)
             $prefix = "*";  # dereferencing the pointer
+            $prefix_ZVAL = "";
         } elsif (checkRPN($arg) eq "pointer"){
             $postfix = "*"; # cast
             $prefix = "";   # nothing, is already a pointer
@@ -348,6 +359,7 @@
         } elsif (checkRPN($arg) eq "normal"){
             $prefix = "*";  # dereferencing the pointer
             $postfix = "";  # nothing to do here
+            $prefix_ZVAL = "";
         }
 
         $cpp_call_params .= "(".checkConst($arg)." ".$classType.$postfix.")";
@@ -387,8 +399,9 @@
     }
 
     if($returnType eq "OBJECT"){
-        if($flags =~ /s/){
-            print CLASS "if(getThis() == NULL){".$prefix." return_object = static_cast<"                .$returnClassName.$infix.">(".$classname."::".$method->{astNodeName}."(".$cpp_call_params."));} else {print CLASS "                .$prefix." return_object = static_cast<"               .$returnClassName.$infix.">(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));}";
+        if($flags =~ /s/){  # static
+            print CLASS "if(getThis() == NULL){".$prefix." return_object = static_cast<"                .$returnClassName.$infix.">(".$classname."::".$method->{astNodeName}."(".$cpp_call_params."));} else {"
+            .$prefix." return_object = static_cast<"               .$returnClassName.$infix.">(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));}";
         } else {
             print CLASS $prefix." return_object = static_cast<"
                 .$returnClassName.$infix.">(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));";
@@ -400,15 +413,20 @@
         print CLASS "php_qt_register(return_value,le);";
         print CLASS "return;";
     } else {
-        if($method->{astNodeName} eq $classname){
-            print CLASS "PHP_QT_REGISTER(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));";
+        my $for_string;
+        if($returnType eq "STRING"){    # RETURN_STRING macro needs 2 params
+            $for_string = ", 1";
+        }
+        if($is_constructor){   # constructor
+            print CLASS $classname." *selfpointer = new ".$classname."(".$cpp_call_params.");";
+            print CLASS "PHP_QT_REGISTER(selfpointer);";
         } else {
-            if($flags =~ /s/){
+            if($flags =~ /s/){  # static
                 print CLASS "if(getThis() == NULL){RETURN_".$returnType."(".$classname."::"
-                    .$method->{astNodeName}."(".$cpp_call_params."));} else {RETURN_"
-                    .$returnType."(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));}";
+                    .$method->{astNodeName}."(".$cpp_call_params.")".$for_string.");} else {RETURN_"
+                    .$returnType."(selfpointer->".$method->{astNodeName}."(".$cpp_call_params.")".$for_string.");}";
             } else {
-                print CLASS "RETURN_".$returnType."(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));";
+                print CLASS "RETURN_".$returnType."(selfpointer->".$method->{astNodeName}."(".$cpp_call_params.")".$for_string.");";
             }
         }
     }
@@ -493,6 +511,11 @@
     open( AG_ZEND_CLASS_ENTRY, ">$file_ag_zend_class_entry" ) || die "Couldn't create $file_ag_zend_class_entry\n";
     $file_ag_zend_class_entry =~ s/\.h/.h/;
 
+    # AG_ZEND_CLASS_ENTRY
+    my $file_ag_defines = "$outputdir/defined.h";
+    open( AG_DEFINES, ">$file_ag_defines" ) || die "Couldn't create $file_ag_defines\n";
+    $file_ag_defines =~ s/\.h/.h/;
+
     # AG_EXTERN_ZEND_CLASS_ENTRY
     my $file_ag_extern_zend_class_entry = "$outputdir/ag_extern_zend_class_entry.inc";
     open( AG_EXTERN_ZEND_CLASS_ENTRY, ">$file_ag_extern_zend_class_entry" ) || die "Couldn't create $file_ag_extern_zend_class_entry\n";
@@ -572,7 +595,7 @@
     my ($node) = @_;
 
     print AG_ZEND_CLASS_ENTRY "zend_class_entry *",$node->{astNodeName},"_ce_ptr;\n";
-    print AG_ZEND_CLASS_ENTRY "#ifndef PHP_QT_".$classname."\n#define PHP_QT_".$classname."\n\n";
+    print AG_DEFINES "#ifndef PHP_QT_".$classname."\n#define PHP_QT_".$classname."\n#endif\n\n";
 
     print AG_CONFIGM4 "\tqt/classes/",lc($node->{astNodeName}),".cpp \\ \n";
     print AG_EXTERN_ZEND_CLASS_ENTRY "extern zend_class_entry *",$node->{astNodeName},"_ce_ptr;\n";
@@ -608,6 +631,7 @@
     ";
 
     close AG_ZEND_CLASS_ENTRY;
+    close AG_DEFINES;
     close AG_EXTERN_ZEND_CLASS_ENTRY;
     close AG_ZEND_PHP_QT;
     close AG_CONFIGM4;
@@ -704,7 +728,7 @@
         const QMetaObject* metaObject() const;
         int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
     };
-    PHP_QT_MOC(".$classname.");
+    //PHP_QT_MOC(".$classname.");
 ";
 # TODO:
 # virtual and private classes
@@ -778,10 +802,14 @@
 {
 	my ( $cplusplusType )  = @_;
 
+    if($cplusplusType eq ""){
+        return "";
+    }
+
 	if ( $cplusplusType =~ /bool/) {
 		return "BOOL";
 	} elsif ( $cplusplusType =~ /\s*void\s*\**/ ) {
-		return "NULL";
+		return "VOID";
 	} elsif ( $cplusplusType =~ /\s*::\s*/) {
 		return "LONG";
 	} elsif ( $cplusplusType =~ /\s*\bint\s*\&*/) {
@@ -904,4 +932,40 @@
     return $endif;
 }
 
+# flags:
+# virtual           v
+# static            's'
+# pure              p
+# const             c
+# slots             l
+# inline            i
+# signal            n
+# k_dcop            d
+# k_dcop_signals    z
+# k_dcop_hidden     y
+# explicit          t
+
+sub IshouldSkip
+{
+    my ($method) = @_;
+
+    if($method->{astNodeName} =~ /qt_/)
+    {   # skip qt_cast, ...
+        return 1;
+    }
+#    if($method->{Flags} =~ /n|v|t/){    # skip slots
+    if($method->{Flags} =~ /n|v/){    # skip slots
+        return 1;
+    }
+    if($method->{Access} eq "protected"){
+        return 1;
+    }
+    if($method->{astNodeName} eq "className"
+        || $method->{astNodeName} eq "qObject")
+    {
+        return 1;
+    }
+
+}
+
 1;



From tm243 at berlios.de  Mon May 29 13:21:17 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Mon, 29 May 2006 13:21:17 +0200
Subject: [Php-qt-svn] r248 - trunk/tools
Message-ID: <200605291121.k4TBLH9q019495@sheep.berlios.de>

Author: tm243
Date: 2006-05-29 13:21:15 +0200 (Mon, 29 May 2006)
New Revision: 248

Modified:
   trunk/tools/kalyptusCxxToPHP.pm
Log:
implementation of protected methods and metaobject handling.

Modified: trunk/tools/kalyptusCxxToPHP.pm
===================================================================
--- trunk/tools/kalyptusCxxToPHP.pm	2006-05-25 09:22:52 UTC (rev 247)
+++ trunk/tools/kalyptusCxxToPHP.pm	2006-05-29 11:21:15 UTC (rev 248)
@@ -21,7 +21,6 @@
 # sub writeDoc                      $lib, $rootnode, $outputdir, $opt
 # sub writeClassDoc                 $node
 
-
 package kalyptusCxxToPHP;
 
 use File::Path;
@@ -44,6 +43,9 @@
 	$pastaccess $pastname $pastreturn $pastparams $nullctor $ctorCount @properties @functions @constructors
 
     %methods
+    @protected;
+    @virtual;
+    @addIncludes;
 
     $classname;
     *CLASS
@@ -122,6 +124,8 @@
     handleAllMethods($class);
     Inheritance($class);
 
+
+
     closeClassFile();
 
 }
@@ -418,7 +422,8 @@
             $for_string = ", 1";
         }
         if($is_constructor){   # constructor
-            print CLASS $classname." *selfpointer = new ".$classname."(".$cpp_call_params.");";
+            my $comma = "," if($cpp_call_params);
+            print CLASS $classname."_php_qt *selfpointer = new ".$classname."_php_qt(getThis()".$comma.$cpp_call_params.");";
             print CLASS "PHP_QT_REGISTER(selfpointer);";
         } else {
             if($flags =~ /s/){  # static
@@ -601,7 +606,6 @@
     print AG_EXTERN_ZEND_CLASS_ENTRY "extern zend_class_entry *",$node->{astNodeName},"_ce_ptr;\n";
     print AG_EXTERN_ZEND_CLASS_ENTRY "void \t_register_",$node->{astNodeName},"();\n";
 
-
     print PHP_QT_MINIT "\n\t_register_",$node->{astNodeName},"(TSRMLS_C);\n";
     print AG_QT_MINIT "\n\t_register_",$node->{astNodeName},"(TSRMLS_C);\n";
 
@@ -714,21 +718,62 @@
 
 sub DerivedClass
 {
-    my ($node) = @_;
+    my ($class) = @_;
 
+    $constructor = findConstructor($class);
+
+    my $prepared_params;
+    my @paramList = kdocUtil::splitUnnested(",", $constructor->{Params});
+    foreach my $param (@paramList){
+
+        @ch = split(/=/, $param);
+
+        $prepared_params .= ",". at ch[0];
+    }
+
+    $comma = "," if ($prepared_params);
+
+    my $protected_declaration, $protected_implementation;
+    if(@protected){
+        $protected_declaration = "\nprotected:\n";
+        foreach my $method (@protected){
+            if($method->{astNodeName} eq "metaObject" || $method->{astNodeName} eq "className"){
+                next;
+            }
+            checkAddIncludes($method);
+            $protected_declaration .= "\n".checkConst($method->{Flags})." ".checkFlags($method->{Flags})." ".$method->{ReturnType}." ".$method->{astNodeName}."(".$method->{Params}.");";
+            $protected_implementation .= "\n ".$method->{ReturnType}." ".$classname."_php_qt::".$method->{astNodeName}."(".$method->{Params}."){}";
+        }
+    }
+
+    my $includes;
+    foreach $include (@addIncludes){
+        print CLASS "#include <".$include.">\n";
+    }
+
     print CLASS "#include <QMetaMethod>
     class ".$classname."_php_qt : public ".$classname."{
 
     public:
-        ".$classname."_php_qt(zval* zend_ptr);
+        ".$classname."_php_qt(zval* zend_ptr".$comma.$constructor->{Params}.");
 
         zval* zend_ptr;
         QMetaObject* dynamicMetaObject;
 
         const QMetaObject* metaObject() const;
         int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+    ".$protected_declaration."
     };
-    //PHP_QT_MOC(".$classname.");
+    ".$classname."_php_qt::".$classname."_php_qt(zval* zend_ptr".$prepared_params.")
+    {
+        this->zend_ptr = zend_ptr;
+        dynamicMetaObject = new QMetaObject;
+        dynamicMetaObject = php_qt_getMocData(this->zend_ptr,\"".$classname."\",&staticMetaObject);
+    }";
+
+    print CLASS $protected_implementation;
+
+    print CLASS "\nPHP_QT_MOC(".$classname.");
 ";
 # TODO:
 # virtual and private classes
@@ -892,6 +937,18 @@
     return "";
 }
 
+# checks for const
+sub checkFlags
+{
+    my ($e) = @_;
+    my $return;
+    if($e =~ /v/){
+        $return .= "virtual";
+    }
+
+    return $return;
+}
+
 # invokes types for the Z_XVAL macro
 sub invokeTypeToZ_XVAL
 {
@@ -954,12 +1011,19 @@
         return 1;
     }
 #    if($method->{Flags} =~ /n|v|t/){    # skip slots
-    if($method->{Flags} =~ /n|v/){    # skip slots
+    if($method->{Flags} =~ /n/){    # skip slots
         return 1;
     }
+
     if($method->{Access} eq "protected"){
+        push @protected, $method;
         return 1;
     }
+
+    if($method->{Flags} =~ /v/){    # skip slots
+        return 1;
+    }
+
     if($method->{astNodeName} eq "className"
         || $method->{astNodeName} eq "qObject")
     {
@@ -968,4 +1032,64 @@
 
 }
 
+#
+#   finds the constructor
+#
+sub findConstructor
+{
+    my ($class) = @_;
+
+    my @return;
+
+    Iter::MembersByType ($class,sub{},
+	sub
+    {
+        my ($class, $kid ) = @_;
+        if($kid->{NodeType} eq "method")
+        {
+            # there are some additional protected constructors, skip
+            if($kid->{Access} ne "protected"){
+                if($kid->{astNodeName} eq $classname){
+                    push @return, $kid;
+                }
+            }
+        }
+    },sub {}
+	);
+
+    # first is the constructor, second is destructor
+    return @return[0];
+
+}
+
+sub checkAddIncludes
+{
+    my ($method) = @_;
+
+    my @cargs = kdocUtil::splitUnnested(",", $method->{Params});
+
+    foreach my $arg (@cargs){
+        my @arg_ = split(/ /,$arg);
+        foreach my $m (@addIncludes){
+            # skip 'const'
+            if(@arg_[0] eq "const"){
+                if($m eq @arg_[1]){
+                    return;
+                }
+            } else {
+                if($m eq @arg_[0]){
+                    return;
+                }
+            }
+        }
+        if(@arg_[0] eq "const"){
+            push @addIncludes, @arg_[1];
+        } else {
+            push @addIncludes, @arg_[0];
+        }
+
+    }
+
+}
+
 1;



