From tm243 at berlios.de  Tue Jun  6 22:26:17 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Tue, 6 Jun 2006 22:26:17 +0200
Subject: [Php-qt-svn] r249 - in trunk: . qt
Message-ID: <200606062026.k56KQH90019568@sheep.berlios.de>

Author: tm243
Date: 2006-06-06 22:26:16 +0200 (Tue, 06 Jun 2006)
New Revision: 249

Added:
   trunk/qt/inheritance.cpp
Modified:
   trunk/config.m4
Log:
hardcoded table for fast look-up of inheritance.

Modified: trunk/config.m4
===================================================================
--- trunk/config.m4	2006-05-29 11:21:15 UTC (rev 248)
+++ trunk/config.m4	2006-06-06 20:26:16 UTC (rev 249)
@@ -155,7 +155,9 @@
 	qt/classes/qwidgetdata.cpp \
 	qt/classes/qwidgetitem.cpp \
 	qt/classes/qwindowstatechangeevent.cpp \
-  qt/php_qt.cpp,$ext_shared,cli)
+  qt/php_qt.cpp \
+  qt/inheritance.cpp \
+  ,$ext_shared,cli)
   PHP_ADD_BUILD_DIR($ext_builddir/qt)
 
 fi

Added: trunk/qt/inheritance.cpp
===================================================================
--- trunk/qt/inheritance.cpp	2006-05-29 11:21:15 UTC (rev 248)
+++ trunk/qt/inheritance.cpp	2006-06-06 20:26:16 UTC (rev 249)
@@ -0,0 +1,890 @@
+
+
+#include "php_qt.h"
+bool
+inherits(zend_class_entry * ace, uint objectId, int recursion)
+{
+
+/// QAbstractButton, ID: 1 
+  if (ace == QAbstractButton_ce_ptr) {
+    switch (objectId) {
+    case 1:                    //QAbstractButton
+      return true;
+    case 71:                   //QWidget
+      return true;
+    case 46:                   //QObject
+      return true;
+    case 49:                   //QPaintDevice
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QAbstractSlider, ID: 2 
+  if (ace == QAbstractSlider_ce_ptr) {
+    switch (objectId) {
+    case 2:                    //QAbstractSlider
+      return true;
+    case 71:                   //QWidget
+      return true;
+    case 46:                   //QObject
+      return true;
+    case 49:                   //QPaintDevice
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QActionEvent, ID: 3 
+  if (ace == QActionEvent_ce_ptr) {
+    switch (objectId) {
+    case 3:                    //QActionEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QApplication, ID: 4 
+  if (ace == QApplication_ce_ptr) {
+    switch (objectId) {
+    case 4:                    //QApplication
+      return true;
+    case 12:                   //QCoreApplication
+      return true;
+    case 46:                   //QObject
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QBoxLayout, ID: 5 
+  if (ace == QBoxLayout_ce_ptr) {
+    switch (objectId) {
+    case 5:                    //QBoxLayout
+      return true;
+    case 41:                   //QLayout
+      return true;
+    case 42:                   //QLayoutItem
+      return true;
+    case 46:                   //QObject
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QChar, ID: 6 
+  if (ace == QChar_ce_ptr) {
+    switch (objectId) {
+    case 6:                    //QChar
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QCharRef, ID: 7 
+  if (ace == QCharRef_ce_ptr) {
+    switch (objectId) {
+    case 7:                    //QCharRef
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QChildEvent, ID: 8 
+  if (ace == QChildEvent_ce_ptr) {
+    switch (objectId) {
+    case 8:                    //QChildEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QClipboardEvent, ID: 9 
+  if (ace == QClipboardEvent_ce_ptr) {
+    switch (objectId) {
+    case 9:                    //QClipboardEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QCloseEvent, ID: 10 
+  if (ace == QCloseEvent_ce_ptr) {
+    switch (objectId) {
+    case 10:                   //QCloseEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QContextMenuEvent, ID: 11 
+  if (ace == QContextMenuEvent_ce_ptr) {
+    switch (objectId) {
+    case 11:                   //QContextMenuEvent
+      return true;
+    case 32:                   //QInputEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QCoreApplication, ID: 12 
+  if (ace == QCoreApplication_ce_ptr) {
+    switch (objectId) {
+    case 12:                   //QCoreApplication
+      return true;
+    case 46:                   //QObject
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QDate, ID: 13 
+  if (ace == QDate_ce_ptr) {
+    switch (objectId) {
+    case 13:                   //QDate
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QDateTime, ID: 14 
+  if (ace == QDateTime_ce_ptr) {
+    switch (objectId) {
+    case 14:                   //QDateTime
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QDialog, ID: 15 
+  if (ace == QDialog_ce_ptr) {
+  
+    switch (objectId) {
+    case 15:                   //QDialog
+      return true;
+    case 71:                   //QWidget
+      return true;
+    case 46:                   //QObject
+      return true;
+    case 49:                   //QPaintDevice
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QDragEnterEvent, ID: 16 
+  if (ace == QDragEnterEvent_ce_ptr) {
+    switch (objectId) {
+    case 16:                   //QDragEnterEvent
+      return true;
+    case 18:                   //QDragMoveEvent
+      return true;
+    case 20:                   //QDropEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QDragLeaveEvent, ID: 17 
+  if (ace == QDragLeaveEvent_ce_ptr) {
+    switch (objectId) {
+    case 17:                   //QDragLeaveEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QDragMoveEvent, ID: 18 
+  if (ace == QDragMoveEvent_ce_ptr) {
+    switch (objectId) {
+    case 18:                   //QDragMoveEvent
+      return true;
+    case 20:                   //QDropEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QDragResponseEvent, ID: 19 
+  if (ace == QDragResponseEvent_ce_ptr) {
+    switch (objectId) {
+    case 19:                   //QDragResponseEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QDropEvent, ID: 20 
+  if (ace == QDropEvent_ce_ptr) {
+    switch (objectId) {
+    case 20:                   //QDropEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QEvent, ID: 21 
+  if (ace == QEvent_ce_ptr) {
+    switch (objectId) {
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QFileOpenEvent, ID: 22 
+  if (ace == QFileOpenEvent_ce_ptr) {
+    switch (objectId) {
+    case 22:                   //QFileOpenEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QFocusEvent, ID: 23 
+  if (ace == QFocusEvent_ce_ptr) {
+    switch (objectId) {
+    case 23:                   //QFocusEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QFont, ID: 24 
+  if (ace == QFont_ce_ptr) {
+    switch (objectId) {
+    case 24:                   //QFont
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QFrame, ID: 25 
+  if (ace == QFrame_ce_ptr) {
+    switch (objectId) {
+    case 25:                   //QFrame
+      return true;
+    case 71:                   //QWidget
+      return true;
+    case 46:                   //QObject
+      return true;
+    case 49:                   //QPaintDevice
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QGridLayout, ID: 26 
+  if (ace == QGridLayout_ce_ptr) {
+    switch (objectId) {
+    case 26:                   //QGridLayout
+      return true;
+    case 41:                   //QLayout
+      return true;
+    case 42:                   //QLayoutItem
+      return true;
+    case 46:                   //QObject
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QHBoxLayout, ID: 27 
+  if (ace == QHBoxLayout_ce_ptr) {
+    switch (objectId) {
+    case 27:                   //QHBoxLayout
+      return true;
+    case 5:                    //QBoxLayout
+      return true;
+    case 41:                   //QLayout
+      return true;
+    case 42:                   //QLayoutItem
+      return true;
+    case 46:                   //QObject
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QHelpEvent, ID: 28 
+  if (ace == QHelpEvent_ce_ptr) {
+    switch (objectId) {
+    case 28:                   //QHelpEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QHideEvent, ID: 29 
+  if (ace == QHideEvent_ce_ptr) {
+    switch (objectId) {
+    case 29:                   //QHideEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QHoverEvent, ID: 30 
+  if (ace == QHoverEvent_ce_ptr) {
+    switch (objectId) {
+    case 30:                   //QHoverEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QIconDragEvent, ID: 31 
+  if (ace == QIconDragEvent_ce_ptr) {
+    switch (objectId) {
+    case 31:                   //QIconDragEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QInputEvent, ID: 32 
+  if (ace == QInputEvent_ce_ptr) {
+    switch (objectId) {
+    case 32:                   //QInputEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QInputMethodEvent, ID: 33 
+  if (ace == QInputMethodEvent_ce_ptr) {
+    switch (objectId) {
+    case 33:                   //QInputMethodEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// Attribute, ID: 34 
+  if (ace == Attribute_ce_ptr) {
+    switch (objectId) {
+    case 34:                   //Attribute
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QInternal, ID: 35 
+  if (ace == QInternal_ce_ptr) {
+    switch (objectId) {
+    case 35:                   //QInternal
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QKeyEvent, ID: 36 
+  if (ace == QKeyEvent_ce_ptr) {
+    switch (objectId) {
+    case 36:                   //QKeyEvent
+      return true;
+    case 32:                   //QInputEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QLCDNumber, ID: 37 
+  if (ace == QLCDNumber_ce_ptr) {
+    switch (objectId) {
+    case 37:                   //QLCDNumber
+      return true;
+    case 25:                   //QFrame
+      return true;
+    case 71:                   //QWidget
+      return true;
+    case 46:                   //QObject
+      return true;
+    case 49:                   //QPaintDevice
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QLabel, ID: 38 
+  if (ace == QLabel_ce_ptr) {
+    switch (objectId) {
+    case 38:                   //QLabel
+      return true;
+    case 25:                   //QFrame
+      return true;
+    case 71:                   //QWidget
+      return true;
+    case 46:                   //QObject
+      return true;
+    case 49:                   //QPaintDevice
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QLatin1Char, ID: 39 
+  if (ace == QLatin1Char_ce_ptr) {
+    switch (objectId) {
+    case 39:                   //QLatin1Char
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QLatin1String, ID: 40 
+  if (ace == QLatin1String_ce_ptr) {
+    switch (objectId) {
+    case 40:                   //QLatin1String
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QLayout, ID: 41 
+  if (ace == QLayout_ce_ptr) {
+    switch (objectId) {
+    case 41:                   //QLayout
+      return true;
+    case 42:                   //QLayoutItem
+      return true;
+    case 46:                   //QObject
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QLayoutItem, ID: 42 
+  if (ace == QLayoutItem_ce_ptr) {
+    switch (objectId) {
+    case 42:                   //QLayoutItem
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QLineEdit, ID: 43 
+  if (ace == QLineEdit_ce_ptr) {
+    switch (objectId) {
+    case 43:                   //QLineEdit
+      return true;
+    case 71:                   //QWidget
+      return true;
+    case 46:                   //QObject
+      return true;
+    case 49:                   //QPaintDevice
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QMouseEvent, ID: 44 
+  if (ace == QMouseEvent_ce_ptr) {
+    switch (objectId) {
+    case 44:                   //QMouseEvent
+      return true;
+    case 32:                   //QInputEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QMoveEvent, ID: 45 
+  if (ace == QMoveEvent_ce_ptr) {
+    switch (objectId) {
+    case 45:                   //QMoveEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QObject, ID: 46 
+  if (ace == QObject_ce_ptr) {
+    switch (objectId) {
+    case 46:                   //QObject
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QObjectData, ID: 47 
+  if (ace == QObjectData_ce_ptr) {
+    switch (objectId) {
+    case 47:                   //QObjectData
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QObjectUserData, ID: 48 
+  if (ace == QObjectUserData_ce_ptr) {
+    switch (objectId) {
+    case 48:                   //QObjectUserData
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QPaintDevice, ID: 49 
+  if (ace == QPaintDevice_ce_ptr) {
+    switch (objectId) {
+    case 49:                   //QPaintDevice
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QPaintEvent, ID: 50 
+  if (ace == QPaintEvent_ce_ptr) {
+    switch (objectId) {
+    case 50:                   //QPaintEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QPainter, ID: 51 
+  if (ace == QPainter_ce_ptr) {
+    switch (objectId) {
+    case 51:                   //QPainter
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QPushButton, ID: 52 
+  if (ace == QPushButton_ce_ptr) {
+    switch (objectId) {
+    case 52:                   //QPushButton
+      return true;
+    case 1:                    //QAbstractButton
+      return true;
+    case 71:                   //QWidget
+      return true;
+    case 46:                   //QObject
+      return true;
+    case 49:                   //QPaintDevice
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QResizeEvent, ID: 53 
+  if (ace == QResizeEvent_ce_ptr) {
+    switch (objectId) {
+    case 53:                   //QResizeEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QShortcutEvent, ID: 54 
+  if (ace == QShortcutEvent_ce_ptr) {
+    switch (objectId) {
+    case 54:                   //QShortcutEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QShowEvent, ID: 55 
+  if (ace == QShowEvent_ce_ptr) {
+    switch (objectId) {
+    case 55:                   //QShowEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QSlider, ID: 56 
+  if (ace == QSlider_ce_ptr) {
+    switch (objectId) {
+    case 56:                   //QSlider
+      return true;
+    case 2:                    //QAbstractSlider
+      return true;
+    case 71:                   //QWidget
+      return true;
+    case 46:                   //QObject
+      return true;
+    case 49:                   //QPaintDevice
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QSpacerItem, ID: 57 
+  if (ace == QSpacerItem_ce_ptr) {
+    switch (objectId) {
+    case 57:                   //QSpacerItem
+      return true;
+    case 42:                   //QLayoutItem
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QStatusTipEvent, ID: 58 
+  if (ace == QStatusTipEvent_ce_ptr) {
+    switch (objectId) {
+    case 58:                   //QStatusTipEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QString, ID: 59 
+  if (ace == QString_ce_ptr) {
+    switch (objectId) {
+    case 59:                   //QString
+      return true;
+    default:
+      return false;
+    }
+  }
+/// Data, ID: 60 
+  if (ace == Data_ce_ptr) {
+    switch (objectId) {
+    case 60:                   //Data
+      return true;
+    default:
+      return false;
+    }
+  }
+/// Null, ID: 61 
+  if (ace == Null_ce_ptr) {
+    switch (objectId) {
+    case 61:                   //Null
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QTabletEvent, ID: 62 
+  if (ace == QTabletEvent_ce_ptr) {
+    switch (objectId) {
+    case 62:                   //QTabletEvent
+      return true;
+    case 32:                   //QInputEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QTime, ID: 63 
+  if (ace == QTime_ce_ptr) {
+    switch (objectId) {
+    case 63:                   //QTime
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QTimer, ID: 64 
+  if (ace == QTimer_ce_ptr) {
+    switch (objectId) {
+    case 64:                   //QTimer
+      return true;
+    case 46:                   //QObject
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QTimerEvent, ID: 65 
+  if (ace == QTimerEvent_ce_ptr) {
+    switch (objectId) {
+    case 65:                   //QTimerEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QToolBarChangeEvent, ID: 66 
+  if (ace == QToolBarChangeEvent_ce_ptr) {
+    switch (objectId) {
+    case 66:                   //QToolBarChangeEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QToolButton, ID: 67 
+  if (ace == QToolButton_ce_ptr) {
+    switch (objectId) {
+    case 67:                   //QToolButton
+      return true;
+    case 1:                    //QAbstractButton
+      return true;
+    case 71:                   //QWidget
+      return true;
+    case 46:                   //QObject
+      return true;
+    case 49:                   //QPaintDevice
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QVBoxLayout, ID: 68 
+  if (ace == QVBoxLayout_ce_ptr) {
+    switch (objectId) {
+    case 68:                   //QVBoxLayout
+      return true;
+    case 5:                    //QBoxLayout
+      return true;
+    case 41:                   //QLayout
+      return true;
+    case 42:                   //QLayoutItem
+      return true;
+    case 46:                   //QObject
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QWhatsThisClickedEvent, ID: 69 
+  if (ace == QWhatsThisClickedEvent_ce_ptr) {
+    switch (objectId) {
+    case 69:                   //QWhatsThisClickedEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QWheelEvent, ID: 70 
+  if (ace == QWheelEvent_ce_ptr) {
+    switch (objectId) {
+    case 70:                   //QWheelEvent
+      return true;
+    case 32:                   //QInputEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QWidget, ID: 71 
+  if (ace == QWidget_ce_ptr) {
+    switch (objectId) {
+    case 71:                   //QWidget
+      return true;
+    case 46:                   //QObject
+      return true;
+    case 49:                   //QPaintDevice
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QWidgetData, ID: 72 
+  if (ace == QWidgetData_ce_ptr) {
+    switch (objectId) {
+    case 72:                   //QWidgetData
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QWidgetItem, ID: 73 
+  if (ace == QWidgetItem_ce_ptr) {
+    switch (objectId) {
+    case 73:                   //QWidgetItem
+      return true;
+    case 42:                   //QLayoutItem
+      return true;
+    default:
+      return false;
+    }
+  }
+/// QWindowStateChangeEvent, ID: 74 
+  if (ace == QWindowStateChangeEvent_ce_ptr) {
+    switch (objectId) {
+    case 74:                   //QWindowStateChangeEvent
+      return true;
+    case 21:                   //QEvent
+      return true;
+    default:
+      return false;
+    }
+  }
+/// Qt, ID: 75 
+  if (ace == Qt_ce_ptr) {
+    switch (objectId) {
+    case 75:                   //Qt
+      return true;
+    default:
+      return false;
+    }
+  }
+  
+  // break recursion
+  if(recursion == 10){
+    return false;
+  }
+  inherits(ace->parent, objectId,recursion++);
+// final: 
+  
+}



From tm243 at berlios.de  Tue Jun  6 22:27:58 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Tue, 6 Jun 2006 22:27:58 +0200
Subject: [Php-qt-svn] r250 - trunk/qt
Message-ID: <200606062027.k56KRwAw022645@sheep.berlios.de>

Author: tm243
Date: 2006-06-06 22:27:57 +0200 (Tue, 06 Jun 2006)
New Revision: 250

Added:
   trunk/qt/defined.h
Log:
cpp defines of implemented classes for safety compilation.

Added: trunk/qt/defined.h
===================================================================
--- trunk/qt/defined.h	2006-06-06 20:26:16 UTC (rev 249)
+++ trunk/qt/defined.h	2006-06-06 20:27:57 UTC (rev 250)
@@ -0,0 +1,292 @@
+#ifndef PHP_QT_QAbstractButton
+#define PHP_QT_QAbstractButton
+#endif
+
+#ifndef PHP_QT_QAbstractSlider
+#define PHP_QT_QAbstractSlider
+#endif
+
+#ifndef PHP_QT_QActionEvent
+#define PHP_QT_QActionEvent
+#endif
+
+#ifndef PHP_QT_QApplication
+#define PHP_QT_QApplication
+#endif
+
+#ifndef PHP_QT_QBoxLayout
+#define PHP_QT_QBoxLayout
+#endif
+
+#ifndef PHP_QT_QChar
+#define PHP_QT_QChar
+#endif
+
+#ifndef PHP_QT_QCharRef
+#define PHP_QT_QCharRef
+#endif
+
+#ifndef PHP_QT_QChildEvent
+#define PHP_QT_QChildEvent
+#endif
+
+#ifndef PHP_QT_QClipboardEvent
+#define PHP_QT_QClipboardEvent
+#endif
+
+#ifndef PHP_QT_QCloseEvent
+#define PHP_QT_QCloseEvent
+#endif
+
+#ifndef PHP_QT_QContextMenuEvent
+#define PHP_QT_QContextMenuEvent
+#endif
+
+#ifndef PHP_QT_QCoreApplication
+#define PHP_QT_QCoreApplication
+#endif
+
+#ifndef PHP_QT_QDate
+#define PHP_QT_QDate
+#endif
+
+#ifndef PHP_QT_QDateTime
+#define PHP_QT_QDateTime
+#endif
+
+#ifndef PHP_QT_QDragEnterEvent
+#define PHP_QT_QDragEnterEvent
+#endif
+
+#ifndef PHP_QT_QDragLeaveEvent
+#define PHP_QT_QDragLeaveEvent
+#endif
+
+#ifndef PHP_QT_QDragMoveEvent
+#define PHP_QT_QDragMoveEvent
+#endif
+
+#ifndef PHP_QT_QDragResponseEvent
+#define PHP_QT_QDragResponseEvent
+#endif
+
+#ifndef PHP_QT_QDropEvent
+#define PHP_QT_QDropEvent
+#endif
+
+#ifndef PHP_QT_QEvent
+#define PHP_QT_QEvent
+#endif
+
+#ifndef PHP_QT_QFileOpenEvent
+#define PHP_QT_QFileOpenEvent
+#endif
+
+#ifndef PHP_QT_QFocusEvent
+#define PHP_QT_QFocusEvent
+#endif
+
+#ifndef PHP_QT_QFont
+#define PHP_QT_QFont
+#endif
+
+#ifndef PHP_QT_QFrame
+#define PHP_QT_QFrame
+#endif
+
+#ifndef PHP_QT_QGridLayout
+#define PHP_QT_QGridLayout
+#endif
+
+#ifndef PHP_QT_QHBoxLayout
+#define PHP_QT_QHBoxLayout
+#endif
+
+#ifndef PHP_QT_QHelpEvent
+#define PHP_QT_QHelpEvent
+#endif
+
+#ifndef PHP_QT_QHideEvent
+#define PHP_QT_QHideEvent
+#endif
+
+#ifndef PHP_QT_QHoverEvent
+#define PHP_QT_QHoverEvent
+#endif
+
+#ifndef PHP_QT_QIconDragEvent
+#define PHP_QT_QIconDragEvent
+#endif
+
+#ifndef PHP_QT_QInputEvent
+#define PHP_QT_QInputEvent
+#endif
+
+#ifndef PHP_QT_QInputMethodEvent
+#define PHP_QT_QInputMethodEvent
+#endif
+
+#ifndef PHP_QT_Attribute
+#define PHP_QT_Attribute
+#endif
+
+#ifndef PHP_QT_QInternal
+#define PHP_QT_QInternal
+#endif
+
+#ifndef PHP_QT_QKeyEvent
+#define PHP_QT_QKeyEvent
+#endif
+
+#ifndef PHP_QT_QLCDNumber
+#define PHP_QT_QLCDNumber
+#endif
+
+#ifndef PHP_QT_QLabel
+#define PHP_QT_QLabel
+#endif
+
+#ifndef PHP_QT_QLatin1Char
+#define PHP_QT_QLatin1Char
+#endif
+
+#ifndef PHP_QT_QLatin1String
+#define PHP_QT_QLatin1String
+#endif
+
+#ifndef PHP_QT_QLayout
+#define PHP_QT_QLayout
+#endif
+
+#ifndef PHP_QT_QLayoutItem
+#define PHP_QT_QLayoutItem
+#endif
+
+#ifndef PHP_QT_QLineEdit
+#define PHP_QT_QLineEdit
+#endif
+
+#ifndef PHP_QT_QMouseEvent
+#define PHP_QT_QMouseEvent
+#endif
+
+#ifndef PHP_QT_QMoveEvent
+#define PHP_QT_QMoveEvent
+#endif
+
+#ifndef PHP_QT_QObject
+#define PHP_QT_QObject
+#endif
+
+#ifndef PHP_QT_QObjectData
+#define PHP_QT_QObjectData
+#endif
+
+#ifndef PHP_QT_QObjectUserData
+#define PHP_QT_QObjectUserData
+#endif
+
+#ifndef PHP_QT_QPaintDevice
+#define PHP_QT_QPaintDevice
+#endif
+
+#ifndef PHP_QT_QPaintEvent
+#define PHP_QT_QPaintEvent
+#endif
+
+#ifndef PHP_QT_QPainter
+#define PHP_QT_QPainter
+#endif
+
+#ifndef PHP_QT_QPushButton
+#define PHP_QT_QPushButton
+#endif
+
+#ifndef PHP_QT_QResizeEvent
+#define PHP_QT_QResizeEvent
+#endif
+
+#ifndef PHP_QT_QShortcutEvent
+#define PHP_QT_QShortcutEvent
+#endif
+
+#ifndef PHP_QT_QShowEvent
+#define PHP_QT_QShowEvent
+#endif
+
+#ifndef PHP_QT_QSlider
+#define PHP_QT_QSlider
+#endif
+
+#ifndef PHP_QT_QSpacerItem
+#define PHP_QT_QSpacerItem
+#endif
+
+#ifndef PHP_QT_QStatusTipEvent
+#define PHP_QT_QStatusTipEvent
+#endif
+
+#ifndef PHP_QT_QString
+#define PHP_QT_QString
+#endif
+
+#ifndef PHP_QT_Data
+#define PHP_QT_Data
+#endif
+
+#ifndef PHP_QT_Null
+#define PHP_QT_Null
+#endif
+
+#ifndef PHP_QT_QTabletEvent
+#define PHP_QT_QTabletEvent
+#endif
+
+#ifndef PHP_QT_QTime
+#define PHP_QT_QTime
+#endif
+
+#ifndef PHP_QT_QTimer
+#define PHP_QT_QTimer
+#endif
+
+#ifndef PHP_QT_QTimerEvent
+#define PHP_QT_QTimerEvent
+#endif
+
+#ifndef PHP_QT_QToolBarChangeEvent
+#define PHP_QT_QToolBarChangeEvent
+#endif
+
+#ifndef PHP_QT_QVBoxLayout
+#define PHP_QT_QVBoxLayout
+#endif
+
+#ifndef PHP_QT_QWhatsThisClickedEvent
+#define PHP_QT_QWhatsThisClickedEvent
+#endif
+
+#ifndef PHP_QT_QWheelEvent
+#define PHP_QT_QWheelEvent
+#endif
+
+#ifndef PHP_QT_QWidget
+#define PHP_QT_QWidget
+#endif
+
+#ifndef PHP_QT_QWidgetData
+#define PHP_QT_QWidgetData
+#endif
+
+#ifndef PHP_QT_QWidgetItem
+#define PHP_QT_QWidgetItem
+#endif
+
+#ifndef PHP_QT_QWindowStateChangeEvent
+#define PHP_QT_QWindowStateChangeEvent
+#endif
+
+#ifndef PHP_QT_Qt
+#define PHP_QT_Qt
+#endif
+



From tm243 at berlios.de  Tue Jun  6 22:34:18 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Tue, 6 Jun 2006 22:34:18 +0200
Subject: [Php-qt-svn] r251 - trunk/tools
Message-ID: <200606062034.k56KYIlW028173@sheep.berlios.de>

Author: tm243
Date: 2006-06-06 22:34:16 +0200 (Tue, 06 Jun 2006)
New Revision: 251

Modified:
   trunk/tools/kalyptusCxxToPHP.pm
Log:
much more work on parser: generates well-compiling cpp code with support for moc, type checking etc.

Modified: trunk/tools/kalyptusCxxToPHP.pm
===================================================================
--- trunk/tools/kalyptusCxxToPHP.pm	2006-06-06 20:27:57 UTC (rev 250)
+++ trunk/tools/kalyptusCxxToPHP.pm	2006-06-06 20:34:16 UTC (rev 251)
@@ -13,14 +13,11 @@
 # *                                                                         *
 #***************************************************************************/
 
-# sub cplusplusToZEND               $cplusplusType
-# sub cplusplusToZENDType           $cplusplusType
-# sub cplusplusToPInvoke            $cplusplusType
-# sub cplusplusToMacro              $class, $cnode
-
 # sub writeDoc                      $lib, $rootnode, $outputdir, $opt
 # sub writeClassDoc                 $node
 
+# support for return types, access (can switch from public to private)
+
 package kalyptusCxxToPHP;
 
 use File::Path;
@@ -40,12 +37,22 @@
     @clist
     $host $who $now $gentext %functionId $docTop
 	$lib $rootnode $outputdir $opt $debug $typeprefix $eventHandlerCount
-	$pastaccess $pastname $pastreturn $pastparams $nullctor $ctorCount @properties @functions @constructors
+	$pastaccess $pastname $pastreturn $pastparams $nullctor $ctorCount
 
+    $onlyPrivateConstructor
+    $classId
+
+    @properties
+    @functions
+    @constructors
+
     %methods
-    @protected;
-    @virtual;
-    @addIncludes;
+    %classes
+    @protected
+    @virtual
+    @addIncludes
+    @enums
+    @pure
 
     $classname;
     *CLASS
@@ -59,6 +66,7 @@
     *AG_CONFIGM4
     *AG_QT_MINIT
     *AG_PHP_QT_CPP
+    *INHERITANCE
 
     *QTCTYPES
     *KDETYPES
@@ -95,11 +103,18 @@
 	my ( $lib, $rootnode, $outputdir_, $opt ) = @_;
 
     $outputdir = $outputdir_;
+    $global_rootnode = $rootnode;
+    $onlyPrivateConstructor = 1;
+    $classId = 1;
+    %classes = ();
 
 #    kdocAstUtil::dumpAst($rootnode);
+    report("reimplementation of protected and virtual methods temporarily disabled");
 
     openAllFiles();
 
+    generateInheritanceList();
+
 	# Document all compound nodes
 	Iter::LocalCompounds( $rootnode, sub { writeClassDoc( shift ); } );
 
@@ -114,49 +129,82 @@
 	my( $class ) = @_;
     $classname = $class->{astNodeName};
 
+    @addIncludes = ();
+    @virtual = ();
+    @protected = ();
+    @pure = ();
+    %methods = ();
+
     openClassFile($class);
 
     checkIncludes($class);
     writeAllFiles($class);
 
+    prepareMethods($class);
     DerivedClass($class);
 
     handleAllMethods($class);
     Inheritance($class);
 
-
-
     closeClassFile();
 
 }
 
-# all methods of this class
-
-sub handleAllMethods
+sub prepareMethods
 {
     my ($class) = @_;
 
     %methods = ();
+    @enums = ();
 
 	Iter::MembersByType ($class,sub{},
 		sub
         {
             my ($class, $kid ) = @_;
+            if ($kid->{NodeType} eq "enum" )
+            {
+                push @enums, $kid;
+            }
+
             if ($kid->{NodeType} eq "property" )
             {
                 push @properties, $kid;
             }
             if($kid->{NodeType} eq "method")
             {
+                # to handle overloaded methods
                 mergeMethods($kid);
             }
         },sub {}
 	);
 
+    foreach my $key (%methods){
+
+        $method = %methods->{$key};
+
+        if($method->{Flags} =~ /p/) {
+            push(@pure, $method);
+        } elsif($method->{Access} eq "protected" || $method->{Flags} =~ /v/){
+            if($method->{astNodeName} eq $classname){
+                report("protected constructor", 3);
+                next;
+            }
+            push @protected, $method;
+        } else {
+            report($method->{astNodeName}." skipped in prepareMethods()", 3) if ($method->{astNodeName} ne "" && $method->{astNodeName} =~ /v/);
+        }
+    }
+}
+
+# all methods of this class
+
+sub handleAllMethods
+{
     foreach my $key (keys %methods)
     {
         $method = %methods->{$key};
 
+        $method = prepareArgs($method);
         writeMethodDoc($method);
         handleMethod($method);
 
@@ -171,7 +219,7 @@
 {
     my ( $method ) = @_;
 
-    my $methodname = $method->{astNodeName};
+    my $methodname = $method->{astNodeName};    # for better reading
 
     if(IshouldSkip($method)){
         return;
@@ -180,7 +228,6 @@
     $methodname = "__construct" if($methodname eq $classname);
 
     print CLASS "ZEND_METHOD(".$classname.",".$methodname."){";
-    print CLASS "PHP_QT_FETCH_ARGS();";
 
     my $first = "true";
     # get _all_ arg
@@ -196,15 +243,15 @@
 
         my $zend_args_query;        # parameter for the type check statement
         my $ce_ptr_query;           # parameter for the class check statement
-        my $count_args=0;
+        my $count_args = 0;
         my @stack = ();             # argument stack, regular parameters
         my @stack_optional = ();    # argument stack, optional parameters
+        my $specialQString;         # converts php strings into QStrings
 
         my @ifdef_stack = ();       # object safety
 
         # check whether agument is optional or regular
         foreach my $cpp_arg ( @cargs ) {
-
             if($cpp_arg =~ /=/){
                 push(@stack_optional,$cpp_arg);
             } else {
@@ -226,39 +273,58 @@
                 next ARGLIST;
             }
 
-            $zend_args_query .= " && Z_TYPE_P(args[".$count_args."]) == IS_".$zend_arg;
+            # skip abstract class
+            if(isAbstract(unwrapClassType($overloadedmethod->{ReturnType}))){
+                print CLASS "\n// notice: abstract class ".unwrapClassType($overloadedmethod->{ReturnType})." cannot be instanciated, skipped\n";
+                next ARGLIST;
+            }
+
+            $zend_args_query .= " && Z_TYPE_P(arg_".$count_args.") == IS_".$zend_arg;
             if($zend_arg eq "OBJECT"){
-                if($count_args > 1){
-                    $ce_ptr_query .= "&& ";
+                my $classId = %classes->{ unwrapClassType($cpp_arg) };
+                if($classId == 0){
+                    $classId = "0";
                 }
-                $ce_ptr_query .= "Z_OBJCE_P(args[".$count_args."]) == ".unwrapClassType($cpp_arg)."_ce_ptr";
-                push(@ifdef_stack,unwrapClassType($cpp_arg));
+                $ce_ptr_query .= "inherits(Z_OBJCE_P(arg_".$count_args."), ".$classId.")";
+                push(@ifdef_stack,unwrapClassType(removeGeneric($cpp_arg)));
+                $ce_ptr_query .= "&&";
             }
+            if($cpp_arg =~ /QString/){
+                $specialQString = "arg_".$count_args." = invokeToQString(arg_".$count_args.");\n";
+            }
             $count_args++;
         }
 
+        # remove last '&&'
+        chop($ce_ptr_query);
+        chop($ce_ptr_query);
+
         # type check
         print CLASS "\n\t///".$overloadedmethod->{Params}."\n";
 
         # ifdef
-        print CLASS "#ifdef PHP_QT_".unwrapClassType($method->{ReturnType})." // return type\n\n"
-            if cplusplusToZVAL($method->{ReturnType}) eq "OBJECT";
+        print CLASS "#ifdef PHP_QT_".unwrapClassType(removeGeneric($overloadedmethod->{ReturnType}))." // return type\n\n"
+            if cplusplusToZVAL($overloadedmethod->{ReturnType}) eq "OBJECT";
 
-        print CLASS "if(ZEND_NUM_ARGS() == ".$count_args.$zend_args_query."){";
+        print CLASS "if(ZEND_NUM_ARGS() == ".$count_args."){";
+        print CLASS "PHP_QT_FETCH_".$count_args."_ARGS();";
 
+        print CLASS $specialQString."\n";
+        print CLASS "if(1 ".$zend_args_query."){";
+
         # class check if object
         if($ce_ptr_query ne ""){
             print CLASS "".expandIfdefs(@ifdef_stack);  # ifdef PHP_QT_QString
             print CLASS " if(".$ce_ptr_query."){";
-            handleArguments($params,$method->{ReturnType},$method->{Flags}, $methodname); # argument handling
+            handleArguments($params,$overloadedmethod->{ReturnType},$overloadedmethod->{Flags}, $methodname, $overloadedmethod); # argument handling
             print CLASS "}\n";
             print CLASS "".expandEndifs(@ifdef_stack);  # endif
 
         # simple types
         } else {
-            handleArguments($params,$method->{ReturnType},$method->{Flags}, $methodname); # argument handling
+            handleArguments($params,$overloadedmethod->{ReturnType},$overloadedmethod->{Flags}, $methodname, $overloadedmethod); # argument handling
         }
-        print CLASS "}";
+        print CLASS "}}"; # end if ZEND_NUM_ARGS
 
         #
         # for all optional parameters
@@ -271,35 +337,48 @@
             # intercept unknown types
             if($zend_arg eq "unknown"){
                 print CLASS "\n// notice: unknown argument ".$cpp_arg.", skipped\n";
+                # ifdef
+                print CLASS "#endif // return type\n\n" if cplusplusToZVAL($overloadedmethod->{ReturnType}) eq "OBJECT";
+
                 next ARGLIST;
             }
 
-            $zend_args_query .= " && Z_TYPE_P(args[".$count_args++."]) == IS_".$zend_arg;
+            $zend_args_query .= " && Z_TYPE_P(arg_".$count_args++.") == IS_".$zend_arg;
 
             # type check
-            print CLASS "if(ZEND_NUM_ARGS() == ".$count_args.$zend_args_query."){";
+            print CLASS "if(ZEND_NUM_ARGS() == ".$count_args."){";
+            print CLASS "PHP_QT_FETCH_".$count_args."_ARGS();";
 
+            # regular arg
+            print CLASS $specialQString;
+
+            # optional arg
+            if($cpp_arg =~ /QString/){
+                print CLASS "arg_".$count_args." = invokeToQString(arg_".$count_args.");\n";
+            }
+            print CLASS "if(1 ".$zend_args_query."){";
+
             # if object
             if($ce_ptr_query ne ""){
                 print CLASS "".expandIfdefs(@ifdef_stack);  # ifdef PHP_QT_QString
                 print CLASS " if(".$ce_ptr_query."){";  # ask object types
-                handleArguments($params,$method->{ReturnType},$method->{Flags}, $methodname); # argument handling
+                handleArguments($params,$overloadedmethod->{ReturnType},$overloadedmethod->{Flags}, $methodname, , $overloadedmethod); # argument handling
                 print CLASS "}\n";
                 print CLASS "".expandEndifs(@ifdef_stack);  # endif
             # if simple type
             } else {
                 # argument handling
-                handleArguments($params,$method->{ReturnType},$method->{Flags}, $methodname);
+                handleArguments($params,$overloadedmethod->{ReturnType},$overloadedmethod->{Flags}, $methodname, , $overloadedmethod);
             }
-            print CLASS "}"; # end type check
+            print CLASS "}}"; # end type check
 
         } # stack_optional
 
         # ifdef
-        print CLASS "#endif // return type\n\n" if cplusplusToZVAL($method->{ReturnType}) eq "OBJECT";
+        print CLASS "#endif // return type\n\n" if cplusplusToZVAL($overloadedmethod->{ReturnType}) eq "OBJECT";
     }
 
-    print CLASS "php_error(E_ERROR,\"could not parse argument\");";
+    print CLASS "php_error(E_ERROR,\"could not parse argument in ".$classname."::".$method->{astNodeName}."(...) \");";
     print CLASS "}\n";
 
 }
@@ -310,22 +389,39 @@
 
 sub handleArguments
 {
-    my ( $params, $return, $flags, $methodname ) = @_;
+    my ( $params, $return, $flags, $methodname, $overloadedmethod ) = @_;
 
     my $returnType = cplusplusToZVAL($return);      # example: BOOL, LONG, DOUBLE, STRING, OBJECT
     my $is_constructor = ($method->{astNodeName} eq $classname);
 
+#    print CLASS "#ifdef MONITOR\n cout << \"(".$classname.")\" << getThis() << \"::".$methodname."(".$params.")\\n\";\n#endif\n";
+#    print CLASS "#ifdef MONITOR\n php_error(E_NOTICE, \"".$classname."::".$methodname."(".$params.") accepted.\\n\");\n#endif\n";
+
     if($returnType eq "unknown"){
         print CLASS "php_error(E_ERROR,\"unsupported return type ".$return."\");";
         return;
     }
 
+    if($overloadedmethod->{Access} eq "protected"){
+        print CLASS "\n/// overloaded method is protected, skipped.\n";
+        report("overloaded protected method ".$methodname, 3);
+        return if ($methodname ne "__construct");
+    }
+
+    # QCharRef *selfpointer = new QCharRef(...);
+    if($onlyPrivateConstructor || $overloadedmethod->{Access} eq "private"){
+        report($classname." has only private constructors", 4);
+        print CLASS "\n/// method is private, skip\n";
+        print CLASS "php_error(E_ERROR,\"".$classname."::".$methodname."(...) cannot be called with '".$params."'.\");";
+        return;
+    }
+
+
     if($flags =~ /s/){  # static
     } else {
         print CLASS "if(getThis() == NULL){php_error(E_ERROR,\"method '".$methodname."' is not static\"); RETURN_NULL();}";
     }
 
-
     my $preparation;    # invoke zend to cpp, prepare return object if necessary
     my $cpp_call_params;    # the args passed to Qt method
     my $count_args = 0;
@@ -347,6 +443,15 @@
             return; # return arg handling
         }
 
+        # Dummy
+        if($argType eq "ARRAY"){
+            $cpp_call_params .= "new char*[1],";
+            next;
+        }
+
+        # the Z_STRVAL_P macro delivers char*, but we simply need the first and only char
+        my $charSpecial = "[0]" if isChar($arg);
+
         # for all arg types, e.g. bool*
         $classType = unwrapClassType($arg);
 
@@ -370,11 +475,11 @@
 
         if($argType eq "OBJECT"){
             # example: QString *cpp_arg_0 = static_cast<QString*>(php_qt_fetch(args[0]);
-            $preparation .= $classType." *cpp_arg_".$count_args." = static_cast<".$classType."*>(php_qt_fetch(args[".$count_args."]));\n";
+            $preparation .= $classType." *cpp_arg_".$count_args." = static_cast<".$classType."*>(php_qt_fetch(arg_".$count_args."));\n";
             $cpp_call_params .= $prefix."cpp_arg_".$count_args." ";
         } else {
             # example: Z_LVAL_P(arg_0), Z_STRVAL(arg_0)
-            $cpp_call_params .= $prefix_ZVAL."Z_".invokeTypeToZ_XVAL($argType)."VAL_P(args[".$count_args."]) ";
+            $cpp_call_params .= $prefix_ZVAL."Z_".invokeTypeToZ_XVAL($argType)."VAL_P(arg_".$count_args.")".$charSpecial." ";
         }
 
         $cpp_call_params .= ",";
@@ -387,35 +492,74 @@
 
     # return handling
     my $returnClassName = unwrapClassType($return); # example: QString (from QString &c)
-    my $prefix, $postfix, $infix;
+    my $prefix, my $postfix, my $infix, my $le_ptr;
+    my $yrr, my $rxrr, my $pxrr;
 
+    # yrr,rxrr,pxrr defined for prefix
+    my $leftAssignment;
+    if($returnType eq "OBJECT"){
+        print CLASS "zend_class_entry *ce;";
+        print CLASS "object_init_ex(return_value, QString_ce_ptr);";
+        print CLASS "zend_rsrc_list_entry le;";
+        $yrr = "";
+    } else {
+        $yrr = $returnClassName;
+        $rxrr = "&";
+        $pxrr = "*";
+    }
+
+    # static_cast<...> or const_cast<...>
+    my $castWay = "static";
+    if($return =~ /const/){
+        $castWay = "const";
+    }
+
+    my $returnCast;
+    $returnCast = "(char*)" if isChar($return);
+    $returnCast = "(char*)" if ($returnType eq "STRING");
+
     if(checkRPN($return) eq "reference"){       # tested
-        $prefix = $returnClassName."&";
+        $prefix = $yrr.$rxrr;
+        # const_cast<...> => &const_cast<...>
+        $castWay = "&".$castWay;
         $infix = "&";
+        $le_ptr = "&";
     } elsif (checkRPN($return) eq "pointer"){
-        $prefix = $returnClassName."* ";
+        $prefix = $yrr.$pxrr;
+        $infix = "*";    # for static_cast, return_object
+        $le_ptr = "";
     } elsif (checkRPN($return) eq "normal"){    # tested with non-objects
-        # allocate memory on the heap
-        if($returnType eq "OBJECT"){
+        $infix = "";
+        $prefix = "*";
+        $le_ptr = "";
+    }
+
+    # allocate memory on the heap if object
+    # QString *return_object = new QString;
+    # leftAssignment:
+    # *return_object = static_cast<.....
+    if($returnType eq "OBJECT"){
+        if (checkRPN($return) eq "normal"){
             print CLASS $returnClassName." *return_object = new ".$returnClassName.";\n";
+            $leftAssignment = $prefix." return_object";
+        } else {
+            $leftAssignment = "le.ptr"; #le.ptr
         }
-        $prefix = "*";
     }
 
     if($returnType eq "OBJECT"){
         if($flags =~ /s/){  # static
-            print CLASS "if(getThis() == NULL){".$prefix." return_object = static_cast<"                .$returnClassName.$infix.">(".$classname."::".$method->{astNodeName}."(".$cpp_call_params."));} else {"
-            .$prefix." return_object = static_cast<"               .$returnClassName.$infix.">(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));}";
-        } else {
-            print CLASS $prefix." return_object = static_cast<"
+            print CLASS "if(getThis() == NULL){".$leftAssignment." = ".$castWay."_cast<"                .$returnClassName.$infix.">(".$classname."::".$method->{astNodeName}."(".$cpp_call_params."));} else {"
+            .$leftAssignment." = ".$castWay."_cast<"               .$returnClassName.$infix.">(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));}";
+        } else { #non-static
+            print CLASS $leftAssignment." = ".$castWay."_cast<"
                 .$returnClassName.$infix.">(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));";
         }
-        print CLASS "zend_class_entry *ce;";
-        print CLASS "object_init_ex(return_value, QString_ce_ptr);";
-        print CLASS "zend_rsrc_list_entry le;";
-        print CLASS "le.ptr = (void*) ".$infix."return_object;";
+        # normal
+        print CLASS "le.ptr = (void*) ".$le_ptr."return_object;" if (checkRPN($return) eq "normal");
         print CLASS "php_qt_register(return_value,le);";
         print CLASS "return;";
+
     } else {
         my $for_string;
         if($returnType eq "STRING"){    # RETURN_STRING macro needs 2 params
@@ -423,15 +567,30 @@
         }
         if($is_constructor){   # constructor
             my $comma = "," if($cpp_call_params);
+
+            # constructor:
+            # QString_php_qt *selfpointer = new QString_php_qt(...);
+            # there are two ways: allocate memory on heap or with emalloc
+
+            # cpp-way
             print CLASS $classname."_php_qt *selfpointer = new ".$classname."_php_qt(getThis()".$comma.$cpp_call_params.");";
-            print CLASS "PHP_QT_REGISTER(selfpointer);";
+
+            # experiment, do not use
+#            print CLASS $classname."_php_qt *selfpointer = static_cast<".$classname."_php_qt*>(new ".$classname."(".$cpp_call_params."));";
+#            print CLASS "selfpointer->zend_ptr = getThis();";
+
+            # zend-way with emalloc()
+#            print CLASS $classname."_php_qt *selfpointer = static_cast<".$classname."_php_qt*>(emalloc(sizeof(".$classname."_php_qt)));";
+#            print CLASS "new (selfpointer) ".$classname."_php_qt(getThis()".$comma.$cpp_call_params.");";
+
+            print CLASS "PHP_QT_REGISTER(selfpointer);RETURN_NULL();";
         } else {
             if($flags =~ /s/){  # static
                 print CLASS "if(getThis() == NULL){RETURN_".$returnType."(".$classname."::"
                     .$method->{astNodeName}."(".$cpp_call_params.")".$for_string.");} else {RETURN_"
                     .$returnType."(selfpointer->".$method->{astNodeName}."(".$cpp_call_params.")".$for_string.");}";
             } else {
-                print CLASS "RETURN_".$returnType."(selfpointer->".$method->{astNodeName}."(".$cpp_call_params.")".$for_string.");";
+                print CLASS "RETURN_".$returnType."(".$returnCast."selfpointer->".$method->{astNodeName}."(".$cpp_call_params.")".$for_string.");";
             }
         }
     }
@@ -443,10 +602,21 @@
 {
 	my ( $method )  = @_;
 
+    # skip destructor
+    if($method->{ReturnType} =~ /~/){
+        return;
+    }
+
     # looking for existing list
     foreach my $key ( %methods ) {
         if ( $key->{astNodeName} eq $method->{astNodeName} ) {
-            #add to existing list
+
+            # report
+#             if($key->{ReturnType} ne $method->{ReturnType}){
+#                 report($classname .", ". $method->{astNodeName} .": <". $key->{ReturnType} ."> <". $method->{ReturnType}.">\n");
+#             }
+
+            # add to existing list
             push(@{$methods{ $method->{astNodeName} }->{"argList"}},$method);
 	        return;
  		}
@@ -511,6 +681,11 @@
 	mkpath( $outputdir ) unless -f $outputdir;
     mkpath( $outputdir."/classes/" ) unless -f $outputdir."/classes/";
 
+    # INHERITANCE
+    my $file_inheritance = "$outputdir/inheritance.cpp";
+    open( INHERITANCE, ">$file_inheritance" ) || die "Couldn't create $file_inheritance\n";
+    $file_inheritance =~ s/\.h/.h/;
+
     # AG_ZEND_CLASS_ENTRY
     my $file_ag_zend_class_entry = "$outputdir/ag_zend_class_entry.inc";
     open( AG_ZEND_CLASS_ENTRY, ">$file_ag_zend_class_entry" ) || die "Couldn't create $file_ag_zend_class_entry\n";
@@ -641,6 +816,7 @@
     close AG_CONFIGM4;
     close AG_QT_MINIT;
     close AG_PHP_QT_CPP;
+    close INHERITANCE;
 }
 
 sub openClassFile
@@ -720,61 +896,205 @@
 {
     my ($class) = @_;
 
-    $constructor = findConstructor($class);
+    # handle enums
+    my $public_enum_declaration;
+    my $protected_enum_declaration;
+    foreach $enum (@enums){
+        # deactivated
+        $public_enum_declaration .= declareEnums($enum,"public");
+        $protected_enum_declaration .= declareEnums($enum,"protected");
+    }
 
-    my $prepared_params;
-    my @paramList = kdocUtil::splitUnnested(",", $constructor->{Params});
-    foreach my $param (@paramList){
+    # handle constructors
+    @constructors = findConstructor($class);
 
-        @ch = split(/=/, $param);
+    # nothing to do
+    return if($onlyPrivateConstructor);
 
-        $prepared_params .= ",". at ch[0];
+    my $constructors_declaration, my $constructors_implementation;
+
+
+    foreach my $constructor (@constructors){
+
+        my $prepared_params, my $comma, my $call_params;
+        $call_params = prepareParamsForCall($constructor);
+
+        my @paramList = kdocUtil::splitUnnested(",", $constructor->{Params});
+        if(@paramList > 0){
+            foreach my $param (@paramList){
+                @ch = split(/=/, $param);
+                $prepared_params .= ",". at ch[0];
+            }
+            $comma = "," if ($prepared_params);
+        }
+
+        $constructors_declaration .= $classname."_php_qt(zval* zend_ptr".$comma.$constructor->{Params}.");";
+        $constructors_implementation .= $classname."_php_qt::".$classname."_php_qt(zval* zend_ptr".$prepared_params.") : ".$classname."(".$call_params.")
+        {
+            this->zend_ptr = zend_ptr;";
+
+        if(hasMetaObject()){
+            $constructors_implementation .= "
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,\"".$classname."\",&staticMetaObject));";
+        }
+        $constructors_implementation .= "\n}\n";
     }
 
-    $comma = "," if ($prepared_params);
+    my $protected_declaration, my $protected_implementation;
+    my $virtual_declaration, my $virtual_implementation;
 
-    my $protected_declaration, $protected_implementation;
-    if(@protected){
-        $protected_declaration = "\nprotected:\n";
+    # handle pure methods
+    if(@pure){
+        foreach my $method (@pure){
+
+            if(IshouldSkipForReimplementation($method)){
+                next;
+            }
+
+            # add const to declaration and implementation
+            # someMethod() const
+            my $constant;
+            if($method->{Flags} =~ /c/){
+                $constant = "const\n";
+            }
+
+            writeMethodDoc($method);
+
+            if($method->{ReturnType} eq "void"){
+                $return = "";
+            } else {
+                $return = "return ";
+            }
+
+            checkAddIncludes($method);
+
+            $call_params = prepareParamsForCall($method);
+
+            # virtual protected methods will be implemented
+            if($method->{Flags} =~ /v/){
+                $virtual_declaration .= "\n".checkConst($method->{Flags})." ".checkFlags($method->{Flags})." ".$method->{ReturnType}." ".$method->{astNodeName}."(".$method->{Params}.")".$constant."; // pure \n";
+
+                $virtual_implementation .= "\n// virtual, pure \n\n ".$method->{ReturnType}." ".$classname."_php_qt::".$method->{astNodeName}."(".prepareParamsForArg($method).")".$constant."{}";
+
+            # protected methods with proxy methods
+            } else {
+
+                # SliderAction => QbstractSlider_php_qt::SliderAction
+                my $returnIType;
+                if(isEnum($method->{ReturnType})){
+                    $returnIType = $classname."::".$method->{ReturnType};
+                } else {
+                    $returnIType = $method->{ReturnType};
+                }
+
+                #   void protected_adjustPosition(QWidget * QWidget * s0);
+                $protected_declaration .= "\n".checkConst($method->{Flags})." ".checkFlags($method->{Flags})." ".$returnIType." protected_".$method->{astNodeName}."(".prepareParamsForDeclaration($method).")".$constant."; // pure \n";
+
+                $protected_implementation .= "\n ".$returnIType." ".$classname."_php_qt::protected_".$method->{astNodeName}."(".prepareParamsForArg($method).")".$constant."{".$return."this->".$method->{astNodeName}."(".$call_params.");}";
+            }
+
+        }
+    } # end pure
+
+    # handle protected methods
+    # temp. disabled
+    if(@protected && 0){
+
+        $protected_declaration;
+        my $return, my $call_params;
+
         foreach my $method (@protected){
-            if($method->{astNodeName} eq "metaObject" || $method->{astNodeName} eq "className"){
+
+            if(IshouldSkipForReimplementation($method)){
                 next;
             }
+
+            # add const to declaration and implementation
+            # someMethod() const
+            my $constant;
+            if($method->{Flags} =~ /c/){
+                $constant = "const\n";
+            }
+
+            writeMethodDoc($method);
+
+            if($method->{ReturnType} eq "void"){
+                $return = "";
+            } else {
+                $return = "return ";
+            }
+            # skip special methods
+            if($method->{astNodeName} eq "metaObject"
+            || $method->{astNodeName} eq "className"){
+                next;
+            }
             checkAddIncludes($method);
-            $protected_declaration .= "\n".checkConst($method->{Flags})." ".checkFlags($method->{Flags})." ".$method->{ReturnType}." ".$method->{astNodeName}."(".$method->{Params}.");";
-            $protected_implementation .= "\n ".$method->{ReturnType}." ".$classname."_php_qt::".$method->{astNodeName}."(".$method->{Params}."){}";
+
+            $call_params = prepareParamsForCall($method);
+
+            # virtual protected methods will be implemented
+            if($method->{Flags} =~ /v/){
+                $virtual_declaration .= "\n".checkConst($method->{Flags})." ".checkFlags($method->{Flags})." ".$method->{ReturnType}." ".$method->{astNodeName}."(".$method->{Params}.")".$constant.";";
+
+                $virtual_implementation .= "\n// virtual \n\n ".$method->{ReturnType}." ".$classname."_php_qt::".$method->{astNodeName}."(".prepareParamsForArg($method).")".$constant."{}";
+
+            # protected methods with proxy methods
+            } else {
+
+                # SliderAction => QbstractSlider_php_qt::SliderAction
+                my $returnIType;
+                if(isEnum($method->{ReturnType})){
+                    $returnIType = $classname."::".$method->{ReturnType};
+                } else {
+                    $returnIType = $method->{ReturnType};
+                }
+
+                #   void protected_adjustPosition(QWidget * QWidget * s0);
+                $protected_declaration .= "\n".checkConst($method->{Flags})." ".checkFlags($method->{Flags})." ".$returnIType." protected_".$method->{astNodeName}."(".prepareParamsForDeclaration($method).")".$constant.";";
+
+                $protected_implementation .= "\n ".$returnIType." ".$classname."_php_qt::protected_".$method->{astNodeName}."(".prepareParamsForArg($method).")".$constant."{".$return."this->".$method->{astNodeName}."(".$call_params.");}";
+            }
         }
+
     }
 
     my $includes;
     foreach $include (@addIncludes){
-        print CLASS "#include <".$include.">\n";
+        $include =~ s/\*|\&//;
+        print CLASS "#include <".$include.">\n" if $include ne "";
     }
 
+    # handle moc implementation
+    my $moc_declaration, my $moc_implementation;
+    if(hasMetaObject()){
+        $moc_declaration = "
+        const QMetaObject* metaObject() const;
+        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);";
+        $moc_implementation = "\nPHP_QT_MOC(".$classname.");\n";
+    }
+
     print CLASS "#include <QMetaMethod>
     class ".$classname."_php_qt : public ".$classname."{
 
     public:
-        ".$classname."_php_qt(zval* zend_ptr".$comma.$constructor->{Params}.");
+        ".$constructors_declaration."
+        ".$public_enum_declaration."
 
-        zval* zend_ptr;
-        QMetaObject* dynamicMetaObject;
+        zval* zend_ptr;";
+    print CLASS $moc_declaration;
+    print CLASS $virtual_declaration;
+    print CLASS "protected:" if $protected_declaration;
+    print CLASS $protected_enum_declaration;
+    print CLASS $protected_declaration;
+    print CLASS "};";
 
-        const QMetaObject* metaObject() const;
-        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
-    ".$protected_declaration."
-    };
-    ".$classname."_php_qt::".$classname."_php_qt(zval* zend_ptr".$prepared_params.")
-    {
-        this->zend_ptr = zend_ptr;
-        dynamicMetaObject = new QMetaObject;
-        dynamicMetaObject = php_qt_getMocData(this->zend_ptr,\"".$classname."\",&staticMetaObject);
-    }";
-
+    print CLASS $constructors_implementation;
+    print CLASS $virtual_implementation;
     print CLASS $protected_implementation;
+    print CLASS $moc_implementation;
 
-    print CLASS "\nPHP_QT_MOC(".$classname.");
-";
+    print CLASS "\n";
+
 # TODO:
 # virtual and private classes
 
@@ -859,12 +1179,17 @@
 		return "LONG";
 	} elsif ( $cplusplusType =~ /\s*\bint\s*\&*/) {
 		return "LONG";
-	} elsif ( $cplusplusType =~ /\s*int\s*\&*/) {
+	} elsif ( $cplusplusType =~ /\s*\buint\s*\&*/) {
 		return "LONG";
+#	} elsif ( $cplusplusType =~ /\s*int\s*\&*/) {
+#		return "LONG";
 	} elsif ( $cplusplusType =~ /\s*short\s*\&*/) {
 		return "LONG";
 	} elsif ( $cplusplusType =~ /\s*char\s*\*\*/ ) {
-		return "STRING";
+        # should e array
+		return "ARRAY";
+	} elsif ( $cplusplusType =~ /\s*uchar\s*\**/ ) {
+		return "unknown";
 	} elsif ( $cplusplusType =~ /\s*char\s*\**/ ) {
 		return "STRING";
 	} elsif ( $cplusplusType =~ /\s*unsigned int\s*\**/ ) {
@@ -1011,27 +1336,48 @@
         return 1;
     }
 #    if($method->{Flags} =~ /n|v|t/){    # skip slots
-    if($method->{Flags} =~ /n/){    # skip slots
+    if($method->{Flags} =~ /n|v/){    # skip slots
         return 1;
     }
 
     if($method->{Access} eq "protected"){
-        push @protected, $method;
         return 1;
     }
 
-    if($method->{Flags} =~ /v/){    # skip slots
+    if($method->{astNodeName} eq "className"
+        || $method->{astNodeName} eq "qObject"
+        || $method->{astNodeName} =~ /operator/
+        || $method->{astNodeName} =~ /qt_/
+    ){
         return 1;
     }
 
+}
+
+sub IshouldSkipForReimplementation
+{
+    my ($method) = @_;
+
+    if($method->{astNodeName} =~ /qt_/)
+    {   # skip qt_cast, ...
+        return 1;
+    }
+
+    if($method->{Flags} =~ /n/){    # skip slots
+        return 1;
+    }
+
     if($method->{astNodeName} eq "className"
-        || $method->{astNodeName} eq "qObject")
-    {
+        || $method->{astNodeName} eq "qObject"
+        || $method->{astNodeName} =~ /operator/
+        || $method->{astNodeName} =~ /qt_/
+    ){
         return 1;
     }
 
 }
 
+
 #
 #   finds the constructor
 #
@@ -1039,8 +1385,11 @@
 {
     my ($class) = @_;
 
-    my @return;
+    my @return, my $safetyConstructor;
 
+    $onlyPrivateConstructor = 1;
+    $main::doPrivate = 1;
+
     Iter::MembersByType ($class,sub{},
 	sub
     {
@@ -1049,17 +1398,32 @@
         {
             # there are some additional protected constructors, skip
             if($kid->{Access} ne "protected"){
+                if($kid->{Access} eq "private"){
+                    next;
+                }
                 if($kid->{astNodeName} eq $classname){
-                    push @return, $kid;
+                    if($kid->{ReturnType} =~ /~/){
+                        debug("destructor skipped");
+                    } else {
+                        $onlyPrivateConstructor = 0;
+                        push @return, $kid;
+                    }
                 }
             }
+            if($kid->{Access} ne "protected" && $kid->{astNodeName} eq $classname){
+                $safetyConstructor = $kid;
+            }
         }
     },sub {}
 	);
 
-    # first is the constructor, second is destructor
-    return @return[0];
+    if (@return == 0){
+        report("none or only protected constructors detected, we declared an empty destructor ".$safetyConstructor->{Params}, 3);
+        push @return, $safetyConstructor;
+    }
 
+    return @return;
+
 }
 
 sub checkAddIncludes
@@ -1069,6 +1433,11 @@
     my @cargs = kdocUtil::splitUnnested(",", $method->{Params});
 
     foreach my $arg (@cargs){
+
+        if($arg =~ /::/){
+            return;
+        }
+
         my @arg_ = split(/ /,$arg);
         foreach my $m (@addIncludes){
             # skip 'const'
@@ -1076,20 +1445,446 @@
                 if($m eq @arg_[1]){
                     return;
                 }
+            # skip enums
             } else {
                 if($m eq @arg_[0]){
                     return;
                 }
             }
         }
-        if(@arg_[0] eq "const"){
-            push @addIncludes, @arg_[1];
+
+        if(@arg_[0] =~ /Q/ || @arg_[1] =~ /Q/){
+            if(@arg_[0] eq "const"){
+                push @addIncludes, @arg_[1];
+            } else {
+                push @addIncludes, @arg_[0];
+            }
+        }
+    }
+
+}
+
+#
+#   for reimplementing of protected methods
+#   QFocusEvent * e => e
+#   int repeatTime = 50 s
+#
+#   warn: $method->{Params} will be modified!
+
+sub prepareParamsForCall
+{
+    my ($method) = @_;
+
+    # for typos:
+    # QWidget* => QWidget *, see
+    $method->{Params} =~ s/\*/ \*/;
+    $method->{Params} =~ s/\&/ \&/;
+    $method->{Params} =~ s/  / /;
+
+    my @cargs = kdocUtil::splitUnnested(",", $method->{Params});
+    my $param, my $params_replacement, my $safetyCount=0;
+
+    foreach my $arg (@cargs){
+
+        my $type_tmp = $arg;  # needed for @arg_ == 1
+
+        # safety
+        # QAbstractSlider::timerEvent(QTimerEvent*)
+        my $arg_s;
+        if($arg =~ /=/){
         } else {
-            push @addIncludes, @arg_[0];
+            $/ = " ";
+            chomp($arg);
+
+            # ' Type' => 'Type'
+            $arg =~ s/^ //;
+            my $c = ($arg =~ tr/ //);
+
+            if($c == 0){
+                # to prevent 'PaintDeviceMetrics0',
+                # should be 'PaintDeviceMetric s0' (see QWidget)
+                $arg = "";
+                $arg .= "s".$safetyCount;# if $arg =~ /^:/;
+            } else {
+                $arg .= "s".$safetyCount;# if $arg =~ /^:/;
+            }
+            $arg .= "s".$safetyCount if $arg =~ /^:/;
+            $arg_s = "s".$safetyCount++;    # for @arg_ == 1, to prevent 'bool bools0'
         }
 
+        my @arg_ = split(/ /,$arg);
+        if(@arg_[0] eq ""){
+            shift(@arg_);
+        }
+        if(@arg_ == 1){
+            $params_replacement .= $type_tmp." ".$arg_s.",";
+        } else {
+            $params_replacement .= $arg.",";
+        }
+
+        #   int repeatTime = 50 s => repeatTime
+        if($arg =~ /=/){
+
+            # remove special signs
+            $arg_c = $arg;              # work with a copy
+            $arg_c =~ s/=/ /;           # remove '='
+            $arg_c =~ s/\*|\&|const//;  # remove special signs
+            $arg_c =~ s/  / /;          # remove double spaces
+
+            my @arg_c = split(/ /,$arg_c);
+            my @arg_stack;
+            foreach my $a (@arg_c){
+                next if($a eq "" | $a eq "const");
+                push (@arg_stack, $a);
+            }
+            if(@arg_stack == 2){
+                $param .= "s".$safetyCount.",";
+            } else {
+                pop (@arg_stack);
+                $param .= pop (@arg_stack).",";
+            }
+        #   QFocusEvent * e => e
+        } else {
+            my $arg__ = pop(@arg_);
+            $arg__ =~ s/\*|&//;
+            $param .= $arg__.",";
+
+        }
     }
 
+    chop($param);
+    chop($params_replacement);
+    $param =~ s/\*|\&//;
+
+    $method->{Params} = $params_replacement;
+    return $param;
+
 }
 
+#
+#   prepare for implementation of protected methods
+#
+
+sub prepareParamsForArg
+{
+    my ($method) = @_;
+
+    my @cargs = kdocUtil::splitUnnested(",", $method->{Params});
+    my $arg_return;
+
+    foreach $param (@cargs){
+        my $arg_chunk;
+        if($param =~ /=/){
+            my @arg = split(/=/,$param);
+            $arg_chunk = shift(@arg);
+
+            # WId => 'WId s0'
+            my $c = ($arg_chunk =~ tr/ //);
+            if($c == 1){
+                report("Warning: parameter 's0' hardcoded, maybe dangerous!");
+                $arg_chunk .= "s0";
+            }
+
+        } else {
+            $arg_chunk = $param;
+        }
+
+        # SliderAction => QAbstractSlider::SliderAction
+        @arg_ = split(/ /,$arg_chunk);
+        if(isEnum(@arg_[0])){
+            $arg_chunk = $classname."::".$arg_chunk;
+        }
+
+        $arg_return .= $arg_chunk;
+
+        $arg_return .= ",";
+    }
+
+    chop($arg_return);
+
+    return $arg_return;
+
+}
+
+#
+#   prepare for implementation of protected methods
+#
+
+sub prepareParamsForDeclaration
+{
+    my ($method) = @_;
+
+    my @cargs = kdocUtil::splitUnnested(",", $method->{Params});
+    my $arg_return;
+
+    foreach $param (@cargs){
+        my $arg_chunk;
+
+        $arg_chunk = $param;
+
+        # SliderAction => QAbstractSlider::SliderAction
+        @arg_ = split(/ /,$arg_chunk);
+        if(isEnum(@arg_[0])){
+            $arg_chunk = $classname."::".$arg_chunk;
+        }
+
+        $arg_return .= $arg_chunk;
+
+        $arg_return .= ",";
+    }
+
+    chop($arg_return);
+
+    return $arg_return;
+
+}
+
+
+#
+#   for _all_ methods in class
+#   QEvent* => QEvent* s0
+
+sub prepareArgs
+{
+    my ($method) = @_;
+
+    # for typos:
+    # QWidget* => QWidget *
+    $method->{Params} =~ s/\*/ \*/;
+    $method->{Params} =~ s/\&/ \&/;
+    $method->{Params} =~ s/  / /;
+
+    my @cargs = kdocUtil::splitUnnested(",", $method->{Params});
+    my $params_replacement, my $safetyCount;
+
+    foreach $arg (@cargs){
+        my $type_tmp = $arg;  # needed for @arg_ == 1
+
+        # safety
+        # QAbstractSlider::timerEvent(QTimerEvent*)
+        $arg .= "s".$safetyCount++;
+
+        my @arg_ = split(/ /,$arg);
+        if(@arg_[0] eq ""){
+            shift(@arg_);
+        }
+
+        if(@arg_ == 1){
+            $params_replacement .= $type_tmp." ".$arg.",";
+        } else {
+            $params_replacement .= $arg.",";
+        }
+
+    }
+
+    chop($params_replacement);
+
+    $method->{Params} = $params_replacement;
+
+    return $method;
+
+}
+
+sub declareEnums
+{
+	my( $enum, $specifier ) = @_;
+
+	$enum->{Access} =~ /([^_]*)(.*)?\s*/;
+
+	if( $enum->{NodeType} eq "/* enum" && $enum->{Access} eq $specifier) {
+
+        my $enum_declaration = "enum ".$enum->{astNodeName}." {";   # return value
+
+		my @enums = split(",", $enum->{Params});
+		my $enumCount = 0;
+
+		if($enum->{astNodeName} ne " ") {
+
+			foreach my $enum_ ( @enums ) {
+				$enum_ =~ s/\s//g;
+				$enum_ =~ s/::/./g;
+				if($#enums == $enumCount){
+
+					if ( $enum_ =~ /(.*)=(.*)/ ) {
+						$enum_declaration .= "\n\t\t\t$1 = $2";
+					} else {
+						$enum_declaration .= "\n\t\t\t".$enum_." = $enumCount";
+					}
+
+				} else {
+
+					if ( $enum_ =~ /(.*)=(.*)/ ) {
+						$enum_declaration .= "\n\t\t\t$1 = $2,";
+					} else {
+						$enum_declaration .= "\n\t\t\t".$enum_." = $enumCount,";
+					}
+
+				}
+#                my @constant = split(/=/,$enum_);
+# what to skip?
+                    if(!(
+                            $classname =~ /QContextMenuEvent/
+                        ||  $classname =~ /QInputMethodEvent/
+                        ||  $classname =~ /QPainter/
+                        ||  $classname =~ /QTabletEvent/
+                    )){
+                        print AG_QT_MINIT "\t  REGISTER_LONG_CONSTANT(\"",uc($classname),"_",uc($enum->{astNodeName}),"_",uc($constant[0]),"\", ",$classname,"::",$constant[0],", CONST_CS | CONST_PERSISTENT);\n";
+                        $enumCount++;
+                    }
+			}
+
+			$enum_declaration .= "\n\t\t};*/\n";
+
+            return $enum_declaration;
+		}
+	}
+
+}
+
+#   remove generic syntax
+#   QList<Attribute> => QList
+sub removeGeneric
+{
+    my($myarg) = @_;
+    $myarg =~ s/<.*>//;
+    return $myarg;
+}
+
+sub generateInheritanceList
+{
+
+    print INHERITANCE "\n\n#include \"php_qt.h\"\nbool inherits(zend_class_entry* ace, uint objectId, int recursion){";
+
+    # generate list of Id's
+    my $classId;
+	Iter::LocalCompounds( $global_rootnode, sub {
+        $class = shift;
+        $classes{ $class->{astNodeName} } = ++$classId;
+    });
+
+    $classId = 0;   # reset
+
+    # write code
+	Iter::LocalCompounds( $global_rootnode, sub {
+
+        $class = shift;
+        $classId++;
+
+        # ask for all ancestors
+        @c = superclass_list($class);
+
+        print INHERITANCE "\n\n/// ".$class->{astNodeName}.", ID: ".$classId." \n";
+        print INHERITANCE "if(ace == ".$class->{astNodeName}."_ce_ptr){ switch(objectId){";
+        print INHERITANCE "case ".$classId.": //".$class->{astNodeName}."\nreturn true;";
+
+        # walk through relevant ancestors
+        foreach my $a (@c){
+            next if $a->{astNodeName} eq "";
+            print INHERITANCE "case ".%classes->{ $a->{astNodeName} }.": //".$a->{astNodeName}."\nreturn true;"
+        }
+
+        print INHERITANCE "default: return false;";
+        print INHERITANCE "}}";
+
+    } );
+
+    print INHERITANCE "\n// final: \nif(recursion == 10) {return false;} inherits(ace->parent, objectId, recursion++);}\n";
+
+}
+
+# helper function
+sub superclass_list($)
+{
+    my $classNode = shift;
+    my @super;
+    Iter::Ancestors( $classNode, $global_rootnode, undef, undef, sub {
+                        push @super, @_[0];
+                        push @super, superclass_list( @_[0] );
+                     }, undef );
+    return @super;
+}
+
+#
+#   returns 1 if enum
+#
+sub isEnum
+{
+    my ($name) = @_;
+
+    foreach $enum (@enums){
+        if($name eq $enum->{astNodeName}){
+            return 1;
+        }
+    }
+    return 0;
+}
+
+# returns 1 if moc is needed
+
+sub hasMetaObject
+{
+    foreach my $key (keys %methods)
+    {
+        $method = %methods->{$key};
+        if($method->{astNodeName} eq "metaObject"){
+            return 1;
+        }
+    }
+    return 0;
+}
+
+#
+# returns 1 if class is abstract
+# abstract classes cannot be instanciated
+
+sub isAbstract
+{
+    my ($className) = @_;
+
+    if($className eq "") {return 0;}
+
+    my $iter_class = kdocAstUtil::findRef( $global_rootnode, $className, sub{});
+
+    if($iter_class->{Pure} == 1){
+        return 1;
+    } else {
+        return 0;
+    }
+
+}
+
+sub isChar
+{
+
+    my ($arg) = @_;
+
+    my @arg_ = split(/ /,$arg);
+
+    foreach $chunk (@arg_){
+        return 1 if($chunk eq "char");
+    }
+
+    return 0;
+
+}
+
+sub debug
+{
+    my ($string) = @_;
+
+    print CLASS "/// DEBUG:".$string.".\n";
+
+}
+
+# 3     important hints
+# 4     informations for later
+
+sub report
+{
+    my ($string, $level) = @_;
+
+    print "REPORT ".$classname.": ".$string.".\n" if $level < 5;
+
+}
+
 1;



From tm243 at berlios.de  Tue Jun  6 22:38:19 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Tue, 6 Jun 2006 22:38:19 +0200
Subject: [Php-qt-svn] r252 - trunk/qt
Message-ID: <200606062038.k56KcJDw029650@sheep.berlios.de>

Author: tm243
Date: 2006-06-06 22:38:18 +0200 (Tue, 06 Jun 2006)
New Revision: 252

Modified:
   trunk/qt/php_qt.cpp
   trunk/qt/php_qt.h
Log:
new functions: storing the moc objects, auto-invokation of strings to QStrings, new macros for moc-related implementations and fetching arguments.

Modified: trunk/qt/php_qt.cpp
===================================================================
--- trunk/qt/php_qt.cpp	2006-06-06 20:34:16 UTC (rev 251)
+++ trunk/qt/php_qt.cpp	2006-06-06 20:38:18 UTC (rev 252)
@@ -60,10 +60,15 @@
 /* True global resources - no need for thread safety here */
 static int le_php_qt;
 
+// object list
 int le_php_qt_hashtype;
 HashTable php_qt_objptr_hash;
 
-zend_class_entry *QObject_ce_ptr;
+// metaobject list
+int le_php_qt_moc_hashtype;
+HashTable php_qt_objptr_moc_hash;
+
+//zend_class_entry *QObject_ce_ptr;
 //zend_class_entry *QEvent_ce_ptr;
 zend_class_entry *QMimeSource_ce_ptr;
 
@@ -956,14 +961,18 @@
 	  REGISTER_LONG_CONSTANT("QT_WINDOWMODALITY_WINDOWMODAL", Qt::WindowModal, CONST_CS | CONST_PERSISTENT);
 	  REGISTER_LONG_CONSTANT("QT_WINDOWMODALITY_APPLICATIONMODAL", Qt::ApplicationModal, CONST_CS | CONST_PERSISTENT);
 */
+	  REGISTER_LONG_CONSTANT("QBOXLAYOUT_DIRECTION_TOP_TO_BOTTOM", QBoxLayout::TopToBottom, CONST_CS | CONST_PERSISTENT);
 
 #include "ag_qt_minit.inc"
 
 
+    // object list
 	le_php_qt_hashtype = zend_register_list_destructors_ex(destroy_php_qt_hashtable, NULL, "PHP-Qt object list", module_number);
-
 	zend_hash_init_ex(&php_qt_objptr_hash, 50, NULL, NULL, 1, 0);
 
+    // metaobject list
+	le_php_qt_moc_hashtype = zend_register_list_destructors_ex(destroy_php_qt_hashtable, NULL, "PHP-Qt metaobject list", module_number);
+	zend_hash_init_ex(&php_qt_objptr_moc_hash, 50, NULL, NULL, 1, 0);
 
 	return SUCCESS;
 }
@@ -1151,7 +1160,7 @@
 		php_error(E_ERROR,"reference to Qt object missing, %s",Z_OBJCE_P(this_ptr)->name);
 	} 
 	if(type != le_php_qt_hashtype){
-		php_error(E_ERROR,"wrong type, %s",Z_OBJCE_P(this_ptr)->name);
+		php_error(E_ERROR,"php_qt_fetch(): wrong type, %s",Z_OBJCE_P(this_ptr)->name);
 	}
 
 	return ptr;
@@ -1165,6 +1174,53 @@
 #endif
 }
 
+void php_qt_register_moc(zval* this_ptr, zend_rsrc_list_entry le){
+
+	zval *listhandle;
+	MAKE_STD_ZVAL(listhandle);
+	Z_TYPE_P(listhandle) = IS_LONG;
+	Z_LVAL_P(listhandle) = zend_list_insert(le.ptr, le_php_qt_moc_hashtype);
+
+	if(zend_hash_index_update(Z_OBJPROP_P(this_ptr), 1, &listhandle, sizeof(zval*), NULL) == FAILURE){
+		php_error(E_ERROR,"php_qt_register_moc(): could not bind resource to object.");
+	}
+
+	zval_add_ref(&this_ptr);
+
+	if(zend_hash_index_update(&php_qt_objptr_moc_hash, (long) le.ptr, (void*) &this_ptr, sizeof(zval *), NULL) == FAILURE){
+		php_error(E_ERROR,"php_qt_register_moc(): could not register MetaObject in resource table.");
+	}
+
+}
+
+void* php_qt_fetch_moc(zval* this_ptr){
+
+	if(this_ptr == NULL){
+	  php_error(E_ERROR,"fatal: object does not exists and could not be fetched, %s",Z_OBJCE_P(this_ptr)->name);
+	}
+
+	void *ptr;
+	zval **listhandle;
+	int type;
+	TSRMLS_FETCH();
+
+	if(zend_hash_index_find(Z_OBJPROP_P(this_ptr), 1, (void**) &listhandle) == FAILURE){
+	  php_error(E_ERROR,"MetaObject missing. '%s' fails",Z_OBJCE_P(this_ptr)->name,Z_OBJCE_P(this_ptr)->name);
+	}
+	ptr = zend_list_find(Z_LVAL_PP(listhandle), &type);
+
+	if(!ptr){
+		php_error(E_ERROR,"reference to MetaObject missing, %s",Z_OBJCE_P(this_ptr)->name);
+	} 
+	if(type != le_php_qt_moc_hashtype){
+		php_error(E_ERROR,"php_qt_fetch_moc(): wrong type, %s",Z_OBJCE_P(this_ptr)->name);
+	}
+
+	return ptr;
+
+}
+
+
 void php_qt_callmethod(zval* this_ptr, char* methodname, zend_uint param_count, zval** args[])
 {
 
@@ -1301,8 +1357,23 @@
 
 }
 
+zval* invokeToQString(zval* arg)
+{
+    if(Z_TYPE_P(arg) != IS_STRING){
+        return arg;
+    }
 
+    zend_class_entry *ce;
+    zval* return_value = (zval*) emalloc(sizeof(zval*));
+    object_init_ex(return_value, QString_ce_ptr);
+    zend_rsrc_list_entry le;
+    le.ptr = new QString(Z_STRVAL_P(arg));
+    php_qt_register(return_value, le);
+    return return_value;
 
+}
+
+
 ///
 static zend_function_entry QObject_methods[] = { 
     ZEND_ME(QObject,__construct,NULL,ZEND_ACC_PUBLIC)

Modified: trunk/qt/php_qt.h
===================================================================
--- trunk/qt/php_qt.h	2006-06-06 20:34:16 UTC (rev 251)
+++ trunk/qt/php_qt.h	2006-06-06 20:38:18 UTC (rev 252)
@@ -22,9 +22,17 @@
 
 /* define macros */
 #define debug
+#define MONITOR
 
+#include <iostream>
+using namespace std;
+
+#include "defined.h"
+
 #include <QTextStream>
 #include <QVariant>
+#include <QWidget>
+
 #define QOUT()                                              \
     extern QTextStream qout(stdout, QIODevice::WriteOnly);  \
 
@@ -315,6 +323,190 @@
     RETURN_NULL();                                                              \
 }                                                                     
 
+//    zval** args = new zval*[ZEND_NUM_ARGS()*sizeof(zval)];          \
+
+#define PHP_QT_FETCH_ARGS();                                        \
+    zval** args = (zval**) malloc(ZEND_NUM_ARGS()*sizeof(zval));          \
+    for(int i=0;i<ZEND_NUM_ARGS();i++){                             \
+        zend_parse_parameters(1 TSRMLS_CC, "z", &args[i]);          \
+    }                                                               
+
+//     char* format = (char*) emalloc(ZEND_NUM_ARGS());    \
+
+//#define PHP_QT_FETCH_ARGS();                                        \
+//    zval* args[10];    \
+//    string format = "";\
+//    for(int i=0;i<ZEND_NUM_ARGS();i++){                             \
+//        format += "z";                 \
+//    }                                   \
+//    cout << format << ",\n";\
+//    zend_parse_parameters(1 TSRMLS_CC, (char*) format.data(), &args[0], &args[1], &args[2], &args[3], &args[4], &args[5], &args[6], &args[7], &args[8], &args[9]);          \
+
+#define PHP_QT_FETCH_0_ARGS();                                        \
+
+#define PHP_QT_FETCH_1_ARGS();                                        \
+    zval* arg_0;    \
+    zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, 1 TSRMLS_CC, "z", &arg_0);          
+
+#define PHP_QT_FETCH_2_ARGS();                                        \
+    zval* arg_0;    \
+    zval* arg_1;    \
+    zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, 2 TSRMLS_CC, "zz", &arg_0, &arg_1);          \
+
+#define PHP_QT_FETCH_3_ARGS();                                        \
+    zval* arg_0;    \
+    zval* arg_1;    \
+    zval* arg_2;    \
+    zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, 3 TSRMLS_CC, "zzz", &arg_0, &arg_1, &arg_2);          
+
+#define PHP_QT_FETCH_4_ARGS();                                        \
+    zval* arg_0;    \
+    zval* arg_1;    \
+    zval* arg_2;    \
+    zval* arg_3;    \
+    zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, 4 TSRMLS_CC, "zzzz", &arg_0, &arg_1, &arg_2, &arg_3);          
+
+#define PHP_QT_FETCH_5_ARGS();                                        \
+    zval* arg_0;    \
+    zval* arg_1;    \
+    zval* arg_2;    \
+    zval* arg_3;    \
+    zval* arg_4;    \
+    zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, 5 TSRMLS_CC, "zzzzz", &arg_0, &arg_1, &arg_2, &arg_3, &arg_4);          
+
+#define PHP_QT_FETCH_6_ARGS();                                        \
+    zval* arg_0;    \
+    zval* arg_1;    \
+    zval* arg_2;    \
+    zval* arg_3;    \
+    zval* arg_4;    \
+    zval* arg_5;    \
+    zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, 6 TSRMLS_CC, "zzzzzz", &arg_0, &arg_1, &arg_2, &arg_3, &arg_4, &arg_5);          
+
+#define PHP_QT_FETCH_7_ARGS();                                        \
+    zval* arg_0;    \
+    zval* arg_1;    \
+    zval* arg_2;    \
+    zval* arg_3;    \
+    zval* arg_4;    \
+    zval* arg_5;    \
+    zval* arg_6;    \
+    zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, 7 TSRMLS_CC, "zzzzzzz", &arg_0, &arg_1, &arg_2, &arg_3, &arg_4, &arg_5, &arg_6);          
+
+#define PHP_QT_FETCH_8_ARGS();                                        \
+    zval* arg_0;    \
+    zval* arg_1;    \
+    zval* arg_2;    \
+    zval* arg_3;    \
+    zval* arg_4;    \
+    zval* arg_5;    \
+    zval* arg_6;    \
+    zval* arg_7;    \
+    zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, 8 TSRMLS_CC, "zzzzzzzz", &arg_0, &arg_1, &arg_2, &arg_3, &arg_4, &arg_5, &arg_6, &arg_7);          
+
+#define PHP_QT_FETCH_9_ARGS();                                        \
+    zval* arg_0;    \
+    zval* arg_1;    \
+    zval* arg_2;    \
+    zval* arg_3;    \
+    zval* arg_4;    \
+    zval* arg_5;    \
+    zval* arg_6;    \
+    zval* arg_7;    \
+    zval* arg_8;    \
+    zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, 9 TSRMLS_CC, "zzzzzzzzz", &arg_0, &arg_1, &arg_2, &arg_3, &arg_4, &arg_5, &arg_6, &arg_7, &arg_8);          
+
+#define PHP_QT_FETCH_10_ARGS();                                        \
+    zval* arg_0;    \
+    zval* arg_1;    \
+    zval* arg_2;    \
+    zval* arg_3;    \
+    zval* arg_4;    \
+    zval* arg_5;    \
+    zval* arg_6;    \
+    zval* arg_7;    \
+    zval* arg_8;    \
+    zval* arg_9;    \
+    zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, 10 TSRMLS_CC, "zzzzzzzzzz", &arg_0, &arg_1, &arg_2, &arg_3, &arg_4, &arg_5, &arg_6, &arg_7, &arg_8, &arg_9);          
+
+
+#define PHP_QT_REGISTER_MOC(object)     \
+    zend_rsrc_list_entry le;        \
+    le.ptr = object;                \
+    php_qt_register_moc(this->zend_ptr,le);  \
+
+#define PHP_QT_FETCH_MOC()  \
+	php_qt_fetch_moc(this->zend_ptr) \
+
+
+#define PHP_QT_MOC(classname)                                               \
+const QMetaObject * classname##_php_qt::metaObject() const                  \
+{                                                                           \
+    QMetaObject* d = php_qt_getMocData(this->zend_ptr,#classname,&staticMetaObject); \
+}                                                                           \
+                                                                            \
+int classname##_php_qt::qt_metacall(QMetaObject::Call _c, int _id, void **_a)    \
+{                                                                           \
+    int _id2 = _id;                                                         \
+    _id = classname::qt_metacall(_c,_id,_a);                                \
+    QMetaObject* d = (QMetaObject*) classname##_php_qt::metaObject();       \
+    if (_id < 0)                                                            \
+        return _id;                                                         \
+    else _id = _id2;                                                        \
+    if (_c == QMetaObject::InvokeMetaMethod) {                              \
+     QMetaObject* d = (QMetaObject*) this->metaObject();                    \
+     char* method_name = new char[strlen((d->method(_id)).signature())];    \
+     strcpy(method_name,(char*) (d->method(_id)).signature());              \
+     int i;                                                                 \
+     for(i = 0; i < strlen(method_name); i++){                              \
+        if(method_name[i] == 40){                                           \
+            method_name[i] = 0;                                             \
+            break;                                                          \
+        }                                                                   \
+     }                                                                      \
+     if(d->method(_id).methodType() == QMetaMethod::Slot){                  \
+        int j = 0;                                                          \
+        zval** args[1];                                                     \
+        QList<QByteArray> qargs = d->method(_id).parameterTypes();          \
+        for(i = 0; i < qargs.count(); i++){                                 \
+            zval *arg;                                                      \
+            MAKE_STD_ZVAL(arg);                                             \
+            if(!strncmp("int",(const char*) qargs[i],3)){                   \
+                ZVAL_LONG(arg, *reinterpret_cast< int*>(_a[i+1]));          \
+            } else if(!strncmp("char*",(const char*) qargs[i],5)){          \
+                ZVAL_STRING(arg, *reinterpret_cast< char**>(_a[i+1]), 1);   \
+            } else if(!strncmp("bool",(const char*) qargs[i],4)){           \
+                ZVAL_BOOL(arg, *reinterpret_cast< bool*>(_a[i+1]));         \
+            } else if(!strncmp("double",(const char*) qargs[i],4)){         \
+                ZVAL_DOUBLE(arg, *reinterpret_cast< double*>(_a[i+1]));     \
+            } else {                                                        \
+                    zend_class_entry *ce;                                   \
+                    object_init_ex(arg, classname##_ce_ptr);                \
+                    zend_rsrc_list_entry le;                                \
+                    le.ptr = *reinterpret_cast< classname **>(_a[1]);       \
+                    php_qt_register(arg, le);                               \
+            }                                                               \
+            args[j++] = &arg;                                               \
+        }                                                                   \
+        php_qt_callmethod(this->zend_ptr, method_name, j, args);            \
+     } else {                                                               \
+        void *_b[] = { 0, _a[1] };                                          \
+        QMetaObject::activate(this, d, 0, _b);                              \
+     }                                                                      \
+     delete d;                                                              \
+     delete method_name;                                                    \
+    }                                                                       \
+    return _id;                                                             \
+}                                                                           
+
+#define RETURN_VOID(a) \
+a; \
+return;
+
+#define RETURN_ARRAY(a)\
+a; \
+return;
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -333,8 +525,14 @@
 void php_qt_register(zval* this_ptr, zend_rsrc_list_entry le);
 void php_qt_setObject(zval* this_ptr, void* obj);
 static void destroy_php_qt_hashtable(zend_rsrc_list_entry *rsrc);
+
+void* php_qt_fetch_moc(zval* this_ptr);
+void php_qt_register_moc(zval* this_ptr, zend_rsrc_list_entry le);
+
 void php_qt_callmethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params[]);
 QMetaObject* php_qt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata);
+zval* invokeToQString(zval* arg);
+bool inherits(zend_class_entry* ace, uint objectId, int recursion = 0);
 
 extern int le_php_qt_hashtype;
 extern HashTable php_qt_objptr_hash;
@@ -342,7 +540,9 @@
 void _register_QObject();
 void _register_QEvent();
 
-extern zend_class_entry *QObject_ce_ptr;
+
+
+//extern zend_class_entry *QObject_ce_ptr;
 extern zend_class_entry *QEvent_ce_ptr;
 
 extern zend_class_entry *QCharRef_ce_ptr;



From tm243 at berlios.de  Tue Jun  6 22:42:01 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Tue, 6 Jun 2006 22:42:01 +0200
Subject: [Php-qt-svn] r253 - trunk/qt/text_related
Message-ID: <200606062042.k56Kg1VU030030@sheep.berlios.de>

Author: tm243
Date: 2006-06-06 22:42:00 +0200 (Tue, 06 Jun 2006)
New Revision: 253

Modified:
   trunk/qt/text_related/qstring.cpp
Log:
more methods implemented

Modified: trunk/qt/text_related/qstring.cpp
===================================================================
--- trunk/qt/text_related/qstring.cpp	2006-06-06 20:38:18 UTC (rev 252)
+++ trunk/qt/text_related/qstring.cpp	2006-06-06 20:42:00 UTC (rev 253)
@@ -533,6 +533,7 @@
  *    flags:    
  */
 ZEND_METHOD(QString, __construct){
+
 	if (ZEND_NUM_ARGS() == 0){
 			QString *QString_ptr = new QString();
 				PHP_QT_REGISTER(QString_ptr);
@@ -597,6 +598,8 @@
 			}
 		}
 	}
+
+    
 }
 
 /*********************************
@@ -1411,12 +1414,21 @@
  *    function  remove
  *    flags:    
  */
+ /*
+ 
+QString & remove ( int pos, int len ) 
+QString & remove ( const QString & str, Qt::CaseSensitivity cs = Qt::CaseSensitive ) 
+QString & remove ( QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive ) 
+QString & remove ( const QRegExp & rx )
+ 
+ */
+ 
 ZEND_METHOD(QString, remove){
-
+/*
 	if (ZEND_NUM_ARGS() == 1){
-		/* o public*/
+		// o public
 
-		/* const QRegExp& rx,  */
+		// const QRegExp& rx,  
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
@@ -1429,12 +1441,12 @@
 	}
 
 	if (ZEND_NUM_ARGS() == 2){
-		/* ol public*/
+		// ol public
 
-		/* const QString& s, int cs,  */
-		/* ll public*/
+		// const QString& s, int cs,  
+		// ll public
 
-		/* int i, int len,  */
+		// int i, int len,  
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
@@ -1457,7 +1469,256 @@
 				return;                                             
 			}
 		}
-	}
+	}*/
+/*
+    zval** args = new zval*[ZEND_NUM_ARGS()];
+
+    char* parse_types = new char[ZEND_NUM_ARGS()];
+    int i;
+    for(i=0;i<ZEND_NUM_ARGS();i++){
+        parse_types[i] = 'z';
+    }
+    parse_types[i] = NULL;
+
+    if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, parse_types, args) != SUCCESS){
+        php_error(E_ERROR,"argument could not be parsed\n");
+        return;
+    }
+
+    QString *obj = (QString*) PHP_QT_FETCH();
+
+    if(ZEND_NUM_ARGS() == 0){
+        php_error(E_ERROR,"more arguments needed.\n");
+
+    } else if(ZEND_NUM_ARGS() == 1 && Z_TYPE_P(args[0]) == IS_OBJECT){
+        if(Z_OBJCE_P(args[0]) == QChar_ce_ptr){
+            QChar *c = static_cast<QChar*>(php_qt_fetch(args[0]));
+            obj->remove((QChar) *c);
+        } else if(Z_OBJCE_P(args[0]) == QString_ce_ptr){
+            QString *c = static_cast<QString*>(php_qt_fetch(args[0]));
+            obj->remove((const QString&) *c);
+#ifdef PHP_QT_QREGEXP
+        } else if(Z_OBJCE_P(args[0]) == QRegExp_ce_ptr){
+            QRegExp *c = static_cast<QRegExp*>(php_qt_fetch(args[0]));
+            obj->remove((const QRegExp&) *c);
+#endif
+        }
+
+
+    } //else if (ZEND_NUM_ARGS() == 2 && Z_TYPE_P(args[0]) == IS_LONG && Z_TYPE_P(args[1]) == IS_LONG){
+      //  RETURN_LONG(obj->toInt((bool*) Z_LVAL_P(args[0]) ,(int) Z_LVAL_P(args[1])));
+
+    //} else {
+        php_error(E_ERROR,"argument could not be accepted\n");
+    }
+
+*/
+
+  ///int i, int len
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'remove' is not static");
+        RETURN_NULL();
+      }
+      /// try int i, int len,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      QString & return_object = static_cast < QString & >(selfpointer->remove((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = (void *)&return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (Z_OBJCE_P(arg_0) == QChar_ce_ptr) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'remove' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar c,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+
+        QString & return_object = static_cast < QString & >(selfpointer->remove((QChar) * cpp_arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = (void *)&return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (Z_OBJCE_P(arg_0) == QChar_ce_ptr) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'remove' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+
+        QString & return_object = static_cast < QString & >(selfpointer->remove((QChar) * cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = (void *)&return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (Z_OBJCE_P(arg_0) == QString_ce_ptr) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'remove' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        QString & return_object = static_cast < QString & >(selfpointer->remove((const QString &)*cpp_arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = (void *)&return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (Z_OBJCE_P(arg_0) == QString_ce_ptr) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'remove' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        QString & return_object = static_cast < QString & >(selfpointer->remove((const QString &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = (void *)&return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QRegExp &rx
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (Z_OBJCE_P(arg_0) == QRegExp_ce_ptr) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'remove' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegExp &rx,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
+
+        QString & return_object = static_cast < QString & >(selfpointer->remove((const QRegExp &)*cpp_arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = (void *)&return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument");
+
+
 }
 
 /*********************************
@@ -2517,28 +2778,76 @@
  */
 ZEND_METHOD(QString, toInt){
 
-	if (ZEND_NUM_ARGS() == 0){
-		/* ll public*/
+/*	if (ZEND_NUM_ARGS() == 0){
+		// ll public
 
 		QString *obj = (QString*) PHP_QT_FETCH();
 		RETURN_LONG(obj->toInt());
 
 	}
 	if (ZEND_NUM_ARGS() == 2){
-		/* ll public*/
+		// ll public
 
-		/* int* ok, int base,  */
+		// int* ok, int base, 
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+			    QString *obj = (QString*) PHP_QT_FETCH();
+			    RETURN_LONG(obj->toInt((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}*/
+/*
+    zval** args = new zval*[ZEND_NUM_ARGS()];
 
+    char* parse_types = new char[ZEND_NUM_ARGS()];
+    for(int i=0;i<ZEND_NUM_ARGS();i++){
+        parse_types[i] = 'z';
+    }
 
-			RETURN_LONG(obj->toInt((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+    if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, parse_types, args) != SUCCESS){
+        php_error(E_ERROR,"argument could not be parsed\n");
+        return;
+    }
+
+    QString *obj = (QString*) PHP_QT_FETCH();
+
+    if(ZEND_NUM_ARGS() == 0){
+        RETURN_LONG(obj->toInt());
+
+    } else if(ZEND_NUM_ARGS() == 1 && Z_TYPE_P(args[0]) == IS_BOOL){
+        RETURN_LONG(obj->toInt((bool*) &Z_LVAL_P(args[0])));
+
+    } else if (ZEND_NUM_ARGS() == 2 && Z_TYPE_P(args[0]) == IS_LONG && Z_TYPE_P(args[1]) == IS_LONG){
+        RETURN_LONG(obj->toInt((bool*) Z_LVAL_P(args[0]) ,(int) Z_LVAL_P(args[1])));
+
+    } else {
+        php_error(E_ERROR,"argument could not be accepted\n");
+    }*/
+
+  PHP_QT_FETCH_ARGS();
+  ///bool *ok=0, int base=10
+  if (ZEND_NUM_ARGS() == 0) {
+    /// try 
+    QString *selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+
+    RETURN_LONG(selfpointer->toInt());
+  }
+  if (ZEND_NUM_ARGS() == 1 && Z_TYPE_P(args[0]) == IS_BOOL) {
+    /// try bool *ok=0,
+    QString *selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+
+    RETURN_LONG(selfpointer->toInt((bool *) & Z_LVAL_P(args[0])));
+  }
+  if (ZEND_NUM_ARGS() == 2 && Z_TYPE_P(args[0]) == IS_BOOL && Z_TYPE_P(args[1]) == IS_LONG) {
+    /// try bool *ok=0, int base=10,
+    QString *selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+
+    RETURN_LONG(selfpointer->toInt((bool *) & Z_LVAL_P(args[0]), (int)&Z_LVAL_P(args[1])));
+  }
+  php_error(E_ERROR, "argument could not be accepted.");
+
 }
 
 /*********************************



From tm243 at berlios.de  Tue Jun  6 22:52:32 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Tue, 6 Jun 2006 22:52:32 +0200
Subject: [Php-qt-svn] r255 - in trunk: tests tutorials/calculator tutorials/t1 tutorials/t2 tutorials/t3 tutorials/t4 tutorials/t5 tutorials/t6 tutorials/t7
Message-ID: <200606062052.k56KqWRP031631@sheep.berlios.de>

Author: tm243
Date: 2006-06-06 22:52:31 +0200 (Tue, 06 Jun 2006)
New Revision: 255

Modified:
   trunk/tests/box2buttons.php
   trunk/tests/instances.php
   trunk/tests/unicode.php
   trunk/tutorials/calculator/calculator.php
   trunk/tutorials/calculator/main.php
   trunk/tutorials/t1/main.php
   trunk/tutorials/t2/main.php
   trunk/tutorials/t3/main.php
   trunk/tutorials/t4/main.php
   trunk/tutorials/t5/main.php
   trunk/tutorials/t6/main.php
   trunk/tutorials/t7/main.php
Log:
constructor of QApplication has been changed, adjusted; two bugs in calculator with 'this' pointer.

Modified: trunk/tests/box2buttons.php
===================================================================
--- trunk/tests/box2buttons.php	2006-06-06 20:44:55 UTC (rev 254)
+++ trunk/tests/box2buttons.php	2006-06-06 20:52:31 UTC (rev 255)
@@ -32,7 +32,7 @@
 	}
 	
 	
-	$app = new QApplication();
+	$app = new QApplication($argc,$argv);
 
 	$box = new Box();
 	$box->show();

Modified: trunk/tests/instances.php
===================================================================
--- trunk/tests/instances.php	2006-06-06 20:44:55 UTC (rev 254)
+++ trunk/tests/instances.php	2006-06-06 20:52:31 UTC (rev 255)
@@ -3,7 +3,7 @@
     dl('php_qt.' . PHP_SHLIB_SUFFIX);
   }
  
-  $app = new QCoreApplication();
+  $app = new QCoreApplication($argc,$argv);
 
   echo $app." app\n";  
 

Modified: trunk/tests/unicode.php
===================================================================
--- trunk/tests/unicode.php	2006-06-06 20:44:55 UTC (rev 254)
+++ trunk/tests/unicode.php	2006-06-06 20:52:31 UTC (rev 255)
@@ -27,6 +27,11 @@
 			foreach($dataNodes as $data)
 			{
 				$this->buttons[] = new QLineEdit(QString::fromUtf8($data->nodeValue, -1),$this);
+
+	            foreach($data->attributes as $attribute){
+                    $this->layout->addWidget(new QLabel($attribute->name.": ".$attribute->value));
+                }
+
 				$this->layout->addWidget($this->buttons[count($this->buttons)-1]);
 			}
 
@@ -40,7 +45,7 @@
 
 	}
 
-    $app = new QApplication();
+    $app = new QApplication($argc,$argv);
 	$widget = new TestButtons();
 	$widget->show();
 	$app->exec();

Modified: trunk/tutorials/calculator/calculator.php
===================================================================
--- trunk/tutorials/calculator/calculator.php	2006-06-06 20:44:55 UTC (rev 254)
+++ trunk/tutorials/calculator/calculator.php	2006-06-06 20:52:31 UTC (rev 255)
@@ -68,7 +68,7 @@
             $this->pendingAdditiveOperator = new QString();
             $this->pendingMultiplicativeOperator = new QString();
 
-            $this->display = new QLineEdit("0");
+            $this->display = new QLineEdit("Thor");
             $this->display->setReadOnly(true);
             $this->display->setAlignment(QT_ALIGNMENT_ALIGNRIGHT);
             $this->display->setMaxLength(15);
@@ -102,13 +102,13 @@
             $this->equalButton = $this->createButton("=", SLOT("equalClicked()"));
 
             $this->mainLayout = new QGridLayout($this);
+
 //            $this->mainLayout->setSizeConstraint("QLayout::SetFixedSize");
 
             $this->mainLayout->addWidget($this->display, 0, 0, 1, 6);
             $this->mainLayout->addWidget($this->backspaceButton, 1, 0, 1, 2);
             $this->mainLayout->addWidget($this->clearButton, 1, 2, 1, 2);
             $this->mainLayout->addWidget($this->clearAllButton, 1, 4, 1, 2);
-
             $this->mainLayout->addWidget($this->clearMemoryButton, 2, 0);
             $this->mainLayout->addWidget($this->readMemoryButton, 3, 0);
             $this->mainLayout->addWidget($this->setMemoryButton, 4, 0);
@@ -207,7 +207,7 @@
             $operand = $this->display->text()->toDouble();
 
             if (!$this->pendingMultiplicativeOperator->isEmpty()) {
-                if (!calculate($operand, $this->pendingMultiplicativeOperator)) {
+                if (!$this->calculate($operand, $this->pendingMultiplicativeOperator)) {
                     $this->abortOperation();
                     return;
                 }
@@ -218,7 +218,7 @@
             }
 
             if (!$this->pendingAdditiveOperator->isEmpty()) {
-                if (!calculate(operand, $this->pendingAdditiveOperator)) {
+                if (!$this->calculate(operand, $this->pendingAdditiveOperator)) {
                     $this->abortOperation();
                     return;
                 }

Modified: trunk/tutorials/calculator/main.php
===================================================================
--- trunk/tutorials/calculator/main.php	2006-06-06 20:44:55 UTC (rev 254)
+++ trunk/tutorials/calculator/main.php	2006-06-06 20:52:31 UTC (rev 255)
@@ -13,7 +13,7 @@
 
     require_once('calculator.php');
 
-    $app = new QApplication($argc,0);
+    $app = new QApplication($argc,$argv);
 
     $calc = new Calculator();
     $calc->show();

Modified: trunk/tutorials/t1/main.php
===================================================================
--- trunk/tutorials/t1/main.php	2006-06-06 20:44:55 UTC (rev 254)
+++ trunk/tutorials/t1/main.php	2006-06-06 20:52:31 UTC (rev 255)
@@ -12,7 +12,7 @@
 	}
 
 
-    $app = new QApplication($argc,0);
+    $app = new QApplication($argc,$argv);
 
     $hello = new QPushButton("Hello world!");
 //    hello.resize(100, 30);

Modified: trunk/tutorials/t2/main.php
===================================================================
--- trunk/tutorials/t2/main.php	2006-06-06 20:44:55 UTC (rev 254)
+++ trunk/tutorials/t2/main.php	2006-06-06 20:52:31 UTC (rev 255)
@@ -13,13 +13,14 @@
 	}
 
 
-    $app = new QApplication($argc,0);
+    $app = new QApplication($argc,$argv);
 
     $quit = new QPushButton("Quit");
     $quit->resize(75,30);
 //    $quit->setFont();
 
-    QObject::connect($quit,SIGNAL("clicked()"),$app,SLOT("quit()"));
+//    QObject::connect($quit,SIGNAL("clicked()"),$app,SLOT("quit()"));
+    $quit->connect($quit,SIGNAL("clicked()"),$app,SLOT("quit()"));
 
     $quit->show();
 

Modified: trunk/tutorials/t3/main.php
===================================================================
--- trunk/tutorials/t3/main.php	2006-06-06 20:44:55 UTC (rev 254)
+++ trunk/tutorials/t3/main.php	2006-06-06 20:52:31 UTC (rev 255)
@@ -13,16 +13,20 @@
 	}
 
 
-    $app = new QApplication($argc,0);
+    $app = new QApplication($argc,$argv);
 
     $window = new QWidget();
     $window->resize(200,120);
 
+    $window->setAccessibleName("Julchen");
+echo $window->accessibleName();
+
     $quit = new QPushButton("Quit", $window);
 //    $quit->setFont();
     $quit->setGeometry(10, 40, 180, 40);
 
-    QObject::connect($quit,SIGNAL("clicked()"),$app,SLOT("quit()"));
+//    QObject::connect($quit,SIGNAL("clicked()"),$app,SLOT("quit()"));
+    $quit->connect($quit,SIGNAL("clicked()"),$app,SLOT("quit()"));
 
     $window->show();
 

Modified: trunk/tutorials/t4/main.php
===================================================================
--- trunk/tutorials/t4/main.php	2006-06-06 20:44:55 UTC (rev 254)
+++ trunk/tutorials/t4/main.php	2006-06-06 20:52:31 UTC (rev 255)
@@ -35,7 +35,7 @@
     
     }
 
-    $app = new QApplication($argc,0);
+    $app = new QApplication($argc,$argv);
 
     $widget = new MyWidget();
 

Modified: trunk/tutorials/t5/main.php
===================================================================
--- trunk/tutorials/t5/main.php	2006-06-06 20:44:55 UTC (rev 254)
+++ trunk/tutorials/t5/main.php	2006-06-06 20:52:31 UTC (rev 255)
@@ -47,7 +47,7 @@
     }
 
 
-    $app = new QApplication($argc,0);
+    $app = new QApplication($argc,$argv);
     $widget = new MyWidget();
     $widget->show();
 

Modified: trunk/tutorials/t6/main.php
===================================================================
--- trunk/tutorials/t6/main.php	2006-06-06 20:44:55 UTC (rev 254)
+++ trunk/tutorials/t6/main.php	2006-06-06 20:52:31 UTC (rev 255)
@@ -65,7 +65,7 @@
         }
     }
 
-    $app = new QApplication($argc,0);
+    $app = new QApplication($argc,$argv);
     $widget = new MyWidget();
     $widget->show();
     $app->exec();

Modified: trunk/tutorials/t7/main.php
===================================================================
--- trunk/tutorials/t7/main.php	2006-06-06 20:44:55 UTC (rev 254)
+++ trunk/tutorials/t7/main.php	2006-06-06 20:52:31 UTC (rev 255)
@@ -3,7 +3,7 @@
     **
     ** Qt tutorial 7
     **
-    ** http://doc.trolltech.com/4.0/tutorial-t7.html
+    ** http://doc.trolltech.com/4.0/tutorial-t6.html
     **
     ****************************************************************/
 
@@ -26,6 +26,7 @@
 
             $this->lcd = new QLCDNumber(2,$this);
             $this->slider = new QSlider($this);
+
             $this->slider->setOrientation(QT_ORIENTATIONS_HORIZONTAL);
 
             $this->slider->setRange(0, 99);
@@ -47,6 +48,10 @@
             $this->slider->setValue($value);
         }
 
+        function meinSlot(){
+            echo "meinSlot";
+        }
+
     };
 
     class MyWidget extends QWidget
@@ -60,9 +65,10 @@
             parent::__construct();
 
             $this->quit = new QPushButton("Quit");
-    //        $this->quit->setFont(QFont("Times", 18, QFont::Bold));
+            $this->quit->setFont(new QFont("Times", 18, 1));
             $this->connect($this->quit, SIGNAL("clicked()"), QApplication::instance(), SLOT("quit()"));
 
+
             $this->grid = new QGridLayout();
             for ($row = 0; $row < 3; ++$row) {
                 for ($column = 0; $column < 3; ++$column) {
@@ -72,6 +78,7 @@
                         $this->connect($lcdRange, SIGNAL("valueChanged(int)"), $previousRange, SLOT("setValue(int)"));
                     $previousRange = $lcdRange;
                 }
+
             }
 
             $this->layout = new QVBoxLayout($this);
@@ -81,7 +88,7 @@
         }
     }
 
-    $app = new QApplication($argc,0);
+    $app = new QApplication($argc,$argv);
     $widget = new MyWidget();
     $widget->show();
     $app->exec();



From tm243 at berlios.de  Tue Jun  6 22:46:19 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Tue, 6 Jun 2006 22:46:19 +0200
Subject: [Php-qt-svn] r254 - in trunk/qt: . classes
Message-ID: <200606062046.k56KkJjU030684@sheep.berlios.de>

Author: tm243
Date: 2006-06-06 22:44:55 +0200 (Tue, 06 Jun 2006)
New Revision: 254

Modified:
   trunk/qt/ag_extern_zend_class_entry.inc
   trunk/qt/ag_php_qt_cpp.inc
   trunk/qt/ag_zend_class_entry.inc
   trunk/qt/ag_zend_php_qt.inc
   trunk/qt/classes/qabstractbutton.cpp
   trunk/qt/classes/qabstractslider.cpp
   trunk/qt/classes/qactionevent.cpp
   trunk/qt/classes/qapplication.cpp
   trunk/qt/classes/qboxlayout.cpp
   trunk/qt/classes/qchar.cpp
   trunk/qt/classes/qcharref.cpp
   trunk/qt/classes/qchildevent.cpp
   trunk/qt/classes/qclipboardevent.cpp
   trunk/qt/classes/qcloseevent.cpp
   trunk/qt/classes/qcontextmenuevent.cpp
   trunk/qt/classes/qcoreapplication.cpp
   trunk/qt/classes/qdate.cpp
   trunk/qt/classes/qdatetime.cpp
   trunk/qt/classes/qdialog.cpp
   trunk/qt/classes/qdragenterevent.cpp
   trunk/qt/classes/qdragleaveevent.cpp
   trunk/qt/classes/qdragmoveevent.cpp
   trunk/qt/classes/qdragresponseevent.cpp
   trunk/qt/classes/qdropevent.cpp
   trunk/qt/classes/qfileopenevent.cpp
   trunk/qt/classes/qfocusevent.cpp
   trunk/qt/classes/qfont.cpp
   trunk/qt/classes/qframe.cpp
   trunk/qt/classes/qgridlayout.cpp
   trunk/qt/classes/qhboxlayout.cpp
   trunk/qt/classes/qhelpevent.cpp
   trunk/qt/classes/qhideevent.cpp
   trunk/qt/classes/qhoverevent.cpp
   trunk/qt/classes/qicondragevent.cpp
   trunk/qt/classes/qinputevent.cpp
   trunk/qt/classes/qinputmethodevent.cpp
   trunk/qt/classes/qinputmethodevent__attribute.cpp
   trunk/qt/classes/qinternal.cpp
   trunk/qt/classes/qkeyevent.cpp
   trunk/qt/classes/qlabel.cpp
   trunk/qt/classes/qlatin1char.cpp
   trunk/qt/classes/qlatin1string.cpp
   trunk/qt/classes/qlayout.cpp
   trunk/qt/classes/qlayoutitem.cpp
   trunk/qt/classes/qlcdnumber.cpp
   trunk/qt/classes/qlineedit.cpp
   trunk/qt/classes/qmouseevent.cpp
   trunk/qt/classes/qmoveevent.cpp
   trunk/qt/classes/qobject.cpp
   trunk/qt/classes/qobjectdata.cpp
   trunk/qt/classes/qobjectuserdata.cpp
   trunk/qt/classes/qpaintdevice.cpp
   trunk/qt/classes/qpainter.cpp
   trunk/qt/classes/qpaintevent.cpp
   trunk/qt/classes/qpushbutton.cpp
   trunk/qt/classes/qresizeevent.cpp
   trunk/qt/classes/qshortcutevent.cpp
   trunk/qt/classes/qshowevent.cpp
   trunk/qt/classes/qslider.cpp
   trunk/qt/classes/qspaceritem.cpp
   trunk/qt/classes/qstatustipevent.cpp
   trunk/qt/classes/qstring.cpp
   trunk/qt/classes/qt.cpp
   trunk/qt/classes/qtabletevent.cpp
   trunk/qt/classes/qtime.cpp
   trunk/qt/classes/qtimer.cpp
   trunk/qt/classes/qtimerevent.cpp
   trunk/qt/classes/qtoolbarchangeevent.cpp
   trunk/qt/classes/qtoolbutton.cpp
   trunk/qt/classes/qvboxlayout.cpp
   trunk/qt/classes/qwhatsthisclickedevent.cpp
   trunk/qt/classes/qwheelevent.cpp
   trunk/qt/classes/qwidget.cpp
   trunk/qt/classes/qwidgetdata.cpp
   trunk/qt/classes/qwidgetitem.cpp
   trunk/qt/classes/qwindowstatechangeevent.cpp
Log:
classes reimplemented with improved kalyptus script.

Modified: trunk/qt/ag_extern_zend_class_entry.inc
===================================================================
--- trunk/qt/ag_extern_zend_class_entry.inc	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/ag_extern_zend_class_entry.inc	2006-06-06 20:44:55 UTC (rev 254)
@@ -64,6 +64,10 @@
 void 	_register_QInputEvent();
 extern zend_class_entry *QInputMethodEvent_ce_ptr;
 void 	_register_QInputMethodEvent();
+extern zend_class_entry *Attribute_ce_ptr;
+void 	_register_Attribute();
+extern zend_class_entry *QInternal_ce_ptr;
+void 	_register_QInternal();
 extern zend_class_entry *QKeyEvent_ce_ptr;
 void 	_register_QKeyEvent();
 extern zend_class_entry *QLCDNumber_ce_ptr;
@@ -84,6 +88,8 @@
 void 	_register_QMouseEvent();
 extern zend_class_entry *QMoveEvent_ce_ptr;
 void 	_register_QMoveEvent();
+extern zend_class_entry *QObject_ce_ptr;
+void 	_register_QObject();
 extern zend_class_entry *QObjectData_ce_ptr;
 void 	_register_QObjectData();
 extern zend_class_entry *QObjectUserData_ce_ptr;
@@ -110,6 +116,10 @@
 void 	_register_QStatusTipEvent();
 extern zend_class_entry *QString_ce_ptr;
 void 	_register_QString();
+extern zend_class_entry *Data_ce_ptr;
+void 	_register_Data();
+extern zend_class_entry *Null_ce_ptr;
+void 	_register_Null();
 extern zend_class_entry *QTabletEvent_ce_ptr;
 void 	_register_QTabletEvent();
 extern zend_class_entry *QTime_ce_ptr;
@@ -136,3 +146,5 @@
 void 	_register_QWidgetItem();
 extern zend_class_entry *QWindowStateChangeEvent_ce_ptr;
 void 	_register_QWindowStateChangeEvent();
+extern zend_class_entry *Qt_ce_ptr;
+void 	_register_Qt();

Modified: trunk/qt/ag_php_qt_cpp.inc
===================================================================
--- trunk/qt/ag_php_qt_cpp.inc	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/ag_php_qt_cpp.inc	2006-06-06 20:44:55 UTC (rev 254)
@@ -16,7 +16,6 @@
 	ZEND_ME(QAbstractButton,animateClick,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractButton,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QAbstractButton,autoRepeat,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QAbstractButton,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractButton,group,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractButton,setText,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractButton,text,NULL,ZEND_ACC_PUBLIC)
@@ -58,7 +57,6 @@
 	ZEND_ME(QAbstractSlider,orientation,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractSlider,setValue,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractSlider,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QAbstractSlider,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractSlider,invertedControls,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractSlider,setSingleStep,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractSlider,isSliderDown,NULL,ZEND_ACC_PUBLIC)
@@ -119,7 +117,6 @@
 	ZEND_ME(QCoreApplication,translate,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QCoreApplication,applicationDirPath,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QCoreApplication,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QCoreApplication,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QCoreApplication,argc,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QCoreApplication,quit,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QCoreApplication, __construct,NULL,ZEND_ACC_PUBLIC)
@@ -167,7 +164,6 @@
 	ZEND_ME(QApplication,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QApplication,colorSpec,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QApplication,quitOnLastWindowClosed,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QApplication,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QApplication,wheelScrollLines,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QApplication,mouseButtons,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QApplication,topLevelWidgets,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
@@ -239,7 +235,6 @@
 	ZEND_ME(QBoxLayout,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QBoxLayout,itemAt,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QBoxLayout,direction,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QBoxLayout,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QBoxLayout,minimumSize,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QBoxLayout,sizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QBoxLayout,heightForWidth,NULL,ZEND_ACC_PUBLIC)
@@ -508,7 +503,6 @@
 	ZEND_ME(QDialog,orientation,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QDialog, __construct,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QDialog,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QDialog,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QDialog,sizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QDialog,minimumSizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QDialog,extension,NULL,ZEND_ACC_PUBLIC)
@@ -736,7 +730,6 @@
 	ZEND_ME(QFrame, __construct,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QFrame,midLineWidth,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QFrame,frameShadow,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QFrame,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QFrame,frameShape,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QFrame,setFrameShape,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QFrame,sizeHint,NULL,ZEND_ACC_PUBLIC)
@@ -779,7 +772,6 @@
 	ZEND_ME(QGridLayout,takeAt,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QGridLayout,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QGridLayout,itemAt,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QGridLayout,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QGridLayout,minimumSize,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QGridLayout,sizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QGridLayout,setColumnMinimumWidth,NULL,ZEND_ACC_PUBLIC)
@@ -811,7 +803,6 @@
 static zend_function_entry QHBoxLayout_methods[] = {
 	ZEND_ME(QHBoxLayout,tr,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QHBoxLayout,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QHBoxLayout,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QHBoxLayout, __construct,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QHBoxLayout,trUtf8,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 
@@ -946,7 +937,6 @@
 	ZEND_ME(QLCDNumber,display,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLCDNumber,setSegmentStyle,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLCDNumber,setHexMode,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QLCDNumber,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLCDNumber,setSmallDecimalPoint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLCDNumber,sizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLCDNumber,value,NULL,ZEND_ACC_PUBLIC)
@@ -990,7 +980,6 @@
 	ZEND_ME(QLabel,wordWrap,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLabel,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QLabel,setTextFormat,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QLabel,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLabel,setText,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLabel,text,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLabel,alignment,NULL,ZEND_ACC_PUBLIC)
@@ -1064,7 +1053,6 @@
 	ZEND_ME(QLayout,addWidget,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLayout,removeItem,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLayout,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QLayout,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLayout,totalMinimumSize,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLayout,minimumSize,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLayout,setSpacing,NULL,ZEND_ACC_PUBLIC)
@@ -1124,7 +1112,6 @@
 	ZEND_ME(QLineEdit,setAlignment,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLineEdit, __construct,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLineEdit,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QLineEdit,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLineEdit,inputMethodQuery,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLineEdit,text,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLineEdit,minimumSizeHint,NULL,ZEND_ACC_PUBLIC)
@@ -1374,7 +1361,6 @@
 	ZEND_ME(QPushButton,showMenu,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QPushButton,setFlat,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QPushButton,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QPushButton,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QPushButton,isDefault,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QPushButton,setAutoDefault,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QPushButton,sizeHint,NULL,ZEND_ACC_PUBLIC)
@@ -1444,7 +1430,6 @@
 static zend_function_entry QSlider_methods[] = {
 	ZEND_ME(QSlider,tr,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QSlider,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QSlider,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QSlider, __construct,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QSlider,minimumSizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QSlider,sizeHint,NULL,ZEND_ACC_PUBLIC)
@@ -1660,7 +1645,6 @@
 	ZEND_ME(QTimer,tr,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QTimer,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QTimer,setInterval,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QTimer,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QTimer,timerId,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QTimer,singleShot,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QTimer,stop,NULL,ZEND_ACC_PUBLIC)
@@ -1720,7 +1704,6 @@
 	ZEND_ME(QToolButton,arrowType,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QToolButton,setDefaultAction,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QToolButton,popupMode,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QToolButton,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QToolButton,minimumSizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QToolButton,sizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QToolButton, __construct,NULL,ZEND_ACC_PUBLIC)
@@ -1748,7 +1731,6 @@
 static zend_function_entry QVBoxLayout_methods[] = {
 	ZEND_ME(QVBoxLayout,tr,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QVBoxLayout,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QVBoxLayout,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QVBoxLayout,trUtf8,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QVBoxLayout, __construct,NULL,ZEND_ACC_PUBLIC)
 
@@ -1839,7 +1821,6 @@
 	ZEND_ME(QWidget,grabShortcut,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QWidget,releaseKeyboard,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QWidget,setAccessibleDescription,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QWidget,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QWidget,maximumWidth,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QWidget,setWindowOpacity,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QWidget,isTopLevel,NULL,ZEND_ACC_PUBLIC)

Modified: trunk/qt/ag_zend_class_entry.inc
===================================================================
--- trunk/qt/ag_zend_class_entry.inc	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/ag_zend_class_entry.inc	2006-06-06 20:44:55 UTC (rev 254)
@@ -31,6 +31,8 @@
 zend_class_entry *QIconDragEvent_ce_ptr;
 zend_class_entry *QInputEvent_ce_ptr;
 zend_class_entry *QInputMethodEvent_ce_ptr;
+zend_class_entry *Attribute_ce_ptr;
+zend_class_entry *QInternal_ce_ptr;
 zend_class_entry *QKeyEvent_ce_ptr;
 zend_class_entry *QLCDNumber_ce_ptr;
 zend_class_entry *QLabel_ce_ptr;
@@ -41,6 +43,7 @@
 zend_class_entry *QLineEdit_ce_ptr;
 zend_class_entry *QMouseEvent_ce_ptr;
 zend_class_entry *QMoveEvent_ce_ptr;
+zend_class_entry *QObject_ce_ptr;
 zend_class_entry *QObjectData_ce_ptr;
 zend_class_entry *QObjectUserData_ce_ptr;
 zend_class_entry *QPaintDevice_ce_ptr;
@@ -54,6 +57,8 @@
 zend_class_entry *QSpacerItem_ce_ptr;
 zend_class_entry *QStatusTipEvent_ce_ptr;
 zend_class_entry *QString_ce_ptr;
+zend_class_entry *Data_ce_ptr;
+zend_class_entry *Null_ce_ptr;
 zend_class_entry *QTabletEvent_ce_ptr;
 zend_class_entry *QTime_ce_ptr;
 zend_class_entry *QTimer_ce_ptr;
@@ -67,3 +72,4 @@
 zend_class_entry *QWidgetData_ce_ptr;
 zend_class_entry *QWidgetItem_ce_ptr;
 zend_class_entry *QWindowStateChangeEvent_ce_ptr;
+zend_class_entry *Qt_ce_ptr;

Modified: trunk/qt/ag_zend_php_qt.inc
===================================================================
--- trunk/qt/ag_zend_php_qt.inc	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/ag_zend_php_qt.inc	2006-06-06 20:44:55 UTC (rev 254)
@@ -16,7 +16,6 @@
 ZEND_METHOD(QAbstractButton, animateClick);
 ZEND_METHOD(QAbstractButton, staticMetaObject);
 ZEND_METHOD(QAbstractButton, autoRepeat);
-ZEND_METHOD(QAbstractButton, qObject);
 ZEND_METHOD(QAbstractButton, group);
 ZEND_METHOD(QAbstractButton, setText);
 ZEND_METHOD(QAbstractButton, text);
@@ -45,7 +44,6 @@
 ZEND_METHOD(QAbstractSlider, orientation);
 ZEND_METHOD(QAbstractSlider, setValue);
 ZEND_METHOD(QAbstractSlider, staticMetaObject);
-ZEND_METHOD(QAbstractSlider, qObject);
 ZEND_METHOD(QAbstractSlider, invertedControls);
 ZEND_METHOD(QAbstractSlider, setSingleStep);
 ZEND_METHOD(QAbstractSlider, isSliderDown);
@@ -81,7 +79,6 @@
 ZEND_METHOD(QApplication, staticMetaObject);
 ZEND_METHOD(QApplication, colorSpec);
 ZEND_METHOD(QApplication, quitOnLastWindowClosed);
-ZEND_METHOD(QApplication, qObject);
 ZEND_METHOD(QApplication, wheelScrollLines);
 ZEND_METHOD(QApplication, mouseButtons);
 ZEND_METHOD(QApplication, topLevelWidgets);
@@ -140,7 +137,6 @@
 ZEND_METHOD(QBoxLayout, staticMetaObject);
 ZEND_METHOD(QBoxLayout, itemAt);
 ZEND_METHOD(QBoxLayout, direction);
-ZEND_METHOD(QBoxLayout, qObject);
 ZEND_METHOD(QBoxLayout, minimumSize);
 ZEND_METHOD(QBoxLayout, sizeHint);
 ZEND_METHOD(QBoxLayout, heightForWidth);
@@ -253,7 +249,6 @@
 ZEND_METHOD(QCoreApplication, translate);
 ZEND_METHOD(QCoreApplication, applicationDirPath);
 ZEND_METHOD(QCoreApplication, staticMetaObject);
-ZEND_METHOD(QCoreApplication, qObject);
 ZEND_METHOD(QCoreApplication, argc);
 ZEND_METHOD(QCoreApplication, quit);
 ZEND_METHOD(QCoreApplication, __construct);
@@ -328,7 +323,6 @@
 ZEND_METHOD(QDialog, orientation);
 ZEND_METHOD(QDialog, __construct);
 ZEND_METHOD(QDialog, staticMetaObject);
-ZEND_METHOD(QDialog, qObject);
 ZEND_METHOD(QDialog, sizeHint);
 ZEND_METHOD(QDialog, minimumSizeHint);
 ZEND_METHOD(QDialog, extension);
@@ -427,7 +421,6 @@
 ZEND_METHOD(QFrame, __construct);
 ZEND_METHOD(QFrame, midLineWidth);
 ZEND_METHOD(QFrame, frameShadow);
-ZEND_METHOD(QFrame, qObject);
 ZEND_METHOD(QFrame, frameShape);
 ZEND_METHOD(QFrame, setFrameShape);
 ZEND_METHOD(QFrame, sizeHint);
@@ -457,7 +450,6 @@
 ZEND_METHOD(QGridLayout, takeAt);
 ZEND_METHOD(QGridLayout, staticMetaObject);
 ZEND_METHOD(QGridLayout, itemAt);
-ZEND_METHOD(QGridLayout, qObject);
 ZEND_METHOD(QGridLayout, minimumSize);
 ZEND_METHOD(QGridLayout, sizeHint);
 ZEND_METHOD(QGridLayout, setColumnMinimumWidth);
@@ -476,7 +468,6 @@
 ZEND_METHOD(QGridLayout, rowStretch);
 ZEND_METHOD(QHBoxLayout, tr);
 ZEND_METHOD(QHBoxLayout, staticMetaObject);
-ZEND_METHOD(QHBoxLayout, qObject);
 ZEND_METHOD(QHBoxLayout, __construct);
 ZEND_METHOD(QHBoxLayout, trUtf8);
 ZEND_METHOD(QHelpEvent, y);
@@ -507,7 +498,6 @@
 ZEND_METHOD(QLCDNumber, display);
 ZEND_METHOD(QLCDNumber, setSegmentStyle);
 ZEND_METHOD(QLCDNumber, setHexMode);
-ZEND_METHOD(QLCDNumber, qObject);
 ZEND_METHOD(QLCDNumber, setSmallDecimalPoint);
 ZEND_METHOD(QLCDNumber, sizeHint);
 ZEND_METHOD(QLCDNumber, value);
@@ -538,7 +528,6 @@
 ZEND_METHOD(QLabel, wordWrap);
 ZEND_METHOD(QLabel, staticMetaObject);
 ZEND_METHOD(QLabel, setTextFormat);
-ZEND_METHOD(QLabel, qObject);
 ZEND_METHOD(QLabel, setText);
 ZEND_METHOD(QLabel, text);
 ZEND_METHOD(QLabel, alignment);
@@ -575,7 +564,6 @@
 ZEND_METHOD(QLayout, addWidget);
 ZEND_METHOD(QLayout, removeItem);
 ZEND_METHOD(QLayout, staticMetaObject);
-ZEND_METHOD(QLayout, qObject);
 ZEND_METHOD(QLayout, totalMinimumSize);
 ZEND_METHOD(QLayout, minimumSize);
 ZEND_METHOD(QLayout, setSpacing);
@@ -609,7 +597,6 @@
 ZEND_METHOD(QLineEdit, setAlignment);
 ZEND_METHOD(QLineEdit, __construct);
 ZEND_METHOD(QLineEdit, staticMetaObject);
-ZEND_METHOD(QLineEdit, qObject);
 ZEND_METHOD(QLineEdit, inputMethodQuery);
 ZEND_METHOD(QLineEdit, text);
 ZEND_METHOD(QLineEdit, minimumSizeHint);
@@ -759,7 +746,6 @@
 ZEND_METHOD(QPushButton, showMenu);
 ZEND_METHOD(QPushButton, setFlat);
 ZEND_METHOD(QPushButton, staticMetaObject);
-ZEND_METHOD(QPushButton, qObject);
 ZEND_METHOD(QPushButton, isDefault);
 ZEND_METHOD(QPushButton, setAutoDefault);
 ZEND_METHOD(QPushButton, sizeHint);
@@ -777,7 +763,6 @@
 ZEND_METHOD(QShortcutEvent, key);
 ZEND_METHOD(QSlider, tr);
 ZEND_METHOD(QSlider, staticMetaObject);
-ZEND_METHOD(QSlider, qObject);
 ZEND_METHOD(QSlider, __construct);
 ZEND_METHOD(QSlider, minimumSizeHint);
 ZEND_METHOD(QSlider, sizeHint);
@@ -917,7 +902,6 @@
 ZEND_METHOD(QTimer, tr);
 ZEND_METHOD(QTimer, staticMetaObject);
 ZEND_METHOD(QTimer, setInterval);
-ZEND_METHOD(QTimer, qObject);
 ZEND_METHOD(QTimer, timerId);
 ZEND_METHOD(QTimer, singleShot);
 ZEND_METHOD(QTimer, stop);
@@ -938,7 +922,6 @@
 ZEND_METHOD(QToolButton, arrowType);
 ZEND_METHOD(QToolButton, setDefaultAction);
 ZEND_METHOD(QToolButton, popupMode);
-ZEND_METHOD(QToolButton, qObject);
 ZEND_METHOD(QToolButton, minimumSizeHint);
 ZEND_METHOD(QToolButton, sizeHint);
 ZEND_METHOD(QToolButton, __construct);
@@ -953,7 +936,6 @@
 ZEND_METHOD(QToolButton, setArrowType);
 ZEND_METHOD(QVBoxLayout, tr);
 ZEND_METHOD(QVBoxLayout, staticMetaObject);
-ZEND_METHOD(QVBoxLayout, qObject);
 ZEND_METHOD(QVBoxLayout, trUtf8);
 ZEND_METHOD(QVBoxLayout, __construct);
 ZEND_METHOD(QWhatsThisClickedEvent, href);
@@ -1005,7 +987,6 @@
 ZEND_METHOD(QWidget, grabShortcut);
 ZEND_METHOD(QWidget, releaseKeyboard);
 ZEND_METHOD(QWidget, setAccessibleDescription);
-ZEND_METHOD(QWidget, qObject);
 ZEND_METHOD(QWidget, maximumWidth);
 ZEND_METHOD(QWidget, setWindowOpacity);
 ZEND_METHOD(QWidget, isTopLevel);

Modified: trunk/qt/classes/qabstractbutton.cpp
===================================================================
--- trunk/qt/classes/qabstractbutton.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qabstractbutton.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,605 +19,1511 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QAbstractButton.cpp - QAbstractButton PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QAbstractButton>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  tr
- *    flags:    s
+#include <QAbstractButton>
+/// DEBUG:destructor skipped.
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *e
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	pv
  */
-ZEND_METHOD(QAbstractButton, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+#include <QPaintEvent>
+#include <QMetaMethod>
+class QAbstractButton_php_qt:public QAbstractButton
+{
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+public:
+  QAbstractButton_php_qt(zval * zend_ptr, QWidget * parent = 0);
 
 
-				QString return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+  virtual void paintEvent(QPaintEvent * es0);   // pure 
+};
+
+QAbstractButton_php_qt::QAbstractButton_php_qt(zval * zend_ptr, QWidget * parent):QAbstractButton(parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QAbstractButton",&staticMetaObject));
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setAutoRepeat
- *    flags:    
+// virtual, pure 
+
+void
+QAbstractButton_php_qt::paintEvent(QPaintEvent * es0)
+{
+}
+
+PHP_QT_MOC(QAbstractButton);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QAbstractButton, setAutoRepeat){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractButton, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QAbstractButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setAutoRepeat((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QAbstractButton::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QAbstractButton::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::tr(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  isDown
- *    flags:    c
+/*!
+ * method mouseMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, isDown){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isDown());
-	}
+
+/*!
+ * method setAutoRepeat
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QAbstractButton, setAutoRepeat)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setAutoRepeat' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setAutoRepeat((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::setAutoRepeat(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  qt_invoke
- *    flags:    v
+/*!
+ * method isDown
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractButton, qt_invoke){
+
+ZEND_METHOD(QAbstractButton, isDown)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isDown' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isDown());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::isDown(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setAutoExclusive
- *    flags:    
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QAbstractButton, setAutoExclusive){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method setAutoExclusive
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+ZEND_METHOD(QAbstractButton, setAutoExclusive)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setAutoExclusive' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractButton *selfpointer;
 
-
-			obj->setAutoExclusive((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setAutoExclusive((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::setAutoExclusive(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setIconSize
- *    flags:    l
+/*!
+ * method setIconSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &sizes0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QAbstractButton, setIconSize){
-		/* o public_slots*/
 
-		/* const QSize& size,  */
+ZEND_METHOD(QAbstractButton, setIconSize)
+{
+  ///const QSize &sizes0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setIconSize' is not static");
+          RETURN_NULL();
+        }
+        /// try const QSize &sizes0,
+        QAbstractButton *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+        }
+        QSize *cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setIconSize((const QSize &)*cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0->inherits("QSize")) {
-				obj->setIconSize((const QSize&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::setIconSize(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QAbstractButton, qt_cast){
-}
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  metaObject
- *    flags:    cv
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QAbstractButton, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-				QMetaObject * return_object = (QMetaObject *) obj->metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setIcon
- *    flags:    
+/*!
+ * method toggled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool checkeds0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QAbstractButton, setIcon){
-		/* o public*/
 
-		/* const QIcon& icon,  */
+/*!
+ * method setIcon
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QIcon &icons0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QAbstractButton, setIcon)
+{
+  ///const QIcon &icons0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QIcon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setIcon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QIcon &icons0,
+        QAbstractButton *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+        }
+        QIcon *cpp_arg_0 = static_cast < QIcon * >(php_qt_fetch(arg_0));
 
-			if(obj_z_0->inherits("QIcon")) {
-				obj->setIcon((const QIcon&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_VOID(selfpointer->setIcon((const QIcon &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::setIcon(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method focusOutEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, qt_emit){
+
+/*!
+ * method nextCheckState
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method released
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
+
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *es0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
+ */
+
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
+
+/*!
+ * method autoExclusive
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+ZEND_METHOD(QAbstractButton, autoExclusive)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'autoExclusive' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->autoExclusive());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::autoExclusive(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  autoExclusive
- *    flags:    c
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QAbstractButton, autoExclusive){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->autoExclusive());
-	}
+
+/*!
+ * method toggle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
+
+ZEND_METHOD(QAbstractButton, toggle)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toggle' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->toggle());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::toggle(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method setCheckable
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, className){
+
+ZEND_METHOD(QAbstractButton, setCheckable)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setCheckable' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setCheckable((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::setCheckable(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  toggle
- *    flags:    l
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *es0s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	pv
  */
-ZEND_METHOD(QAbstractButton, toggle){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			obj->toggle();
-			RETURN_NULL();
-	}
+
+/*!
+ * method setDown
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QAbstractButton, setDown)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setDown' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setDown((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::setDown(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setCheckable
- *    flags:    
+/*!
+ * method shortcut
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QKeySequence
+ * @flags	c
  */
-ZEND_METHOD(QAbstractButton, setCheckable){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractButton, shortcut)
+{
+  ///
+#ifdef PHP_QT_QKeySequence      // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'shortcut' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setCheckable((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QKeySequence *return_object = new QKeySequence;
+
+      *return_object = static_cast < QKeySequence > (selfpointer->shortcut());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::shortcut(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setDown
- *    flags:    
+/*!
+ * method icon
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QIcon
+ * @flags	c
  */
-ZEND_METHOD(QAbstractButton, setDown){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractButton, icon)
+{
+  ///
+#ifdef PHP_QT_QIcon             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'icon' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setDown((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QIcon *return_object = new QIcon;
+
+      *return_object = static_cast < QIcon > (selfpointer->icon());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::icon(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  shortcut
- *    flags:    c
+/*!
+ * method setChecked
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QAbstractButton, shortcut){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-				QKeySequence return_object = (QKeySequence) obj->shortcut();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QAbstractButton, setChecked)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setChecked' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setChecked((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::setChecked(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  icon
- *    flags:    c
+/*!
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, icon){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			obj->icon();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setChecked
- *    flags:    l
+/*!
+ * method timerEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTimerEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, setChecked){
-		/* l public_slots*/
 
-		/* int ,  */
+/*!
+ * method setShortcut
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QKeySequence &keys0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+ZEND_METHOD(QAbstractButton, setShortcut)
+{
+  ///const QKeySequence &keys0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QKeySequence
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setShortcut' is not static");
+          RETURN_NULL();
+        }
+        /// try const QKeySequence &keys0,
+        QAbstractButton *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+        }
+        QKeySequence *cpp_arg_0 = static_cast < QKeySequence * >(php_qt_fetch(arg_0));
 
-			obj->setChecked((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        RETURN_VOID(selfpointer->setShortcut((const QKeySequence &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::setShortcut(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setShortcut
- *    flags:    
+/*!
+ * method animateClick
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int msec = 100s0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QAbstractButton, setShortcut){
-		/* o public*/
 
-		/* const QKeySequence& key,  */
+ZEND_METHOD(QAbstractButton, animateClick)
+{
+  ///int msec = 100s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'animateClick' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->animateClick());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'animateClick' is not static");
+        RETURN_NULL();
+      }
+      /// try int msec = 100s0,
+      QAbstractButton *selfpointer;
 
-
-			if(obj_z_0->inherits("QKeySequence")) {
-				obj->setShortcut((const QKeySequence&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->animateClick((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::animateClick(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  animateClick
- *    flags:    l
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QAbstractButton, animateClick){
-		/* l public_slots*/
 
-		/* int msec,  */
+ZEND_METHOD(QAbstractButton, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QAbstractButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->animateClick((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QAbstractButton::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method mouseReleaseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, staticMetaObject){
-}
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  autoRepeat
- *    flags:    c
+/*!
+ * method autoRepeat
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractButton, autoRepeat){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->autoRepeat());
-	}
+
+ZEND_METHOD(QAbstractButton, autoRepeat)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'autoRepeat' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->autoRepeat());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::autoRepeat(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method mousePressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, qObject){
-}
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  group
- *    flags:    c
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, group){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-				QButtonGroup * return_object = (QButtonGroup *) obj->group();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method group
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QButtonGroup *
+ * @flags	c
+ */
+
+ZEND_METHOD(QAbstractButton, group)
+{
+  ///
+#ifdef PHP_QT_QButtonGroup      // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'group' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QButtonGroup * >(selfpointer->group());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::group(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setText
- *    flags:    
+/*!
+ * method setText
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &texts0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, setText){
-		/* o public*/
 
-		/* const QString& text,  */
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
+ZEND_METHOD(QAbstractButton, setText)
+{
+  ///const QString &texts0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-			    QAbstractButton *obj = static_cast<QAbstractButton*>(PHP_QT_FETCH());
-			    QObject* obj_z_0 = static_cast<QObject*>(php_qt_fetch(z_0));
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setText' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &texts0,
+        QAbstractButton *selfpointer;
 
-		        obj->setText((const QString&) *obj_z_0);
-			    RETURN_NULL();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			}
-		}
-	}
+        RETURN_VOID(selfpointer->setText((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::setText(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  text
- *    flags:    c
+/*!
+ * method hitButton
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &poss0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	cv
  */
-ZEND_METHOD(QAbstractButton, text){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-            QString *return_object = new QString;
-				*return_object = (QString) obj->text();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method text
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
+
+ZEND_METHOD(QAbstractButton, text)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'text' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->text());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::text(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  isChecked
- *    flags:    c
+/*!
+ * method isChecked
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractButton, isChecked){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isChecked());
-	}
+
+ZEND_METHOD(QAbstractButton, isChecked)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isChecked' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isChecked());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::isChecked(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  iconSize
- *    flags:    c
+/*!
+ * method clicked
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool checked = falses0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QAbstractButton, iconSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj->iconSize();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method keyPressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
+
+/*!
+ * method keyReleaseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
+
+/*!
+ * method focusInEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
+
+/*!
+ * method iconSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
+ */
+
+ZEND_METHOD(QAbstractButton, iconSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'iconSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->iconSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::iconSize(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  isCheckable
- *    flags:    c
+/*!
+ * method pressed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QAbstractButton, isCheckable){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isCheckable());
-	}
+
+/*!
+ * method QAbstractButton
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * parent=0s0
+ * 
+ * overloaded args:
+ * @param	QAbstractButtonPrivate &dd
+ * @param	 QWidget* parent = 0
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
+ */
+
+ZEND_METHOD(QAbstractButton, __construct)
+{
+  ///QWidget * parent=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton_php_qt *selfpointer = new QAbstractButton_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget * parent=0s0,
+      QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QAbstractButton_php_qt *selfpointer = new QAbstractButton_php_qt(getThis(), (QWidget *) cpp_arg_0);
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QAbstractButtonPrivate &dd, QWidget* parent = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAbstractButtonPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QAbstractButtonPrivate &dd,
+        QAbstractButtonPrivate *cpp_arg_0 = static_cast < QAbstractButtonPrivate * >(php_qt_fetch(arg_0));
+        QAbstractButton_php_qt *selfpointer = new QAbstractButton_php_qt(getThis(), (QAbstractButtonPrivate &) * cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QAbstractButtonPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QAbstractButtonPrivate &dd, QWidget* parent = 0,
+        QAbstractButtonPrivate *cpp_arg_0 = static_cast < QAbstractButtonPrivate * >(php_qt_fetch(arg_0));
+        QWidget *cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+        QAbstractButton_php_qt *selfpointer = new QAbstractButton_php_qt(getThis(), (QAbstractButtonPrivate &) * cpp_arg_0, (QWidget *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::QAbstractButton(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  click
- *    flags:    l
+/*!
+ * method isCheckable
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractButton, click){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			obj->click();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QAbstractButton, isCheckable)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isCheckable' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isCheckable());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::isCheckable(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method click
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QAbstractButton, qt_property){
+
+ZEND_METHOD(QAbstractButton, click)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'click' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->click());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::click(...) ");
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QAbstractButton, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QAbstractButton, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QAbstractButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QAbstractButton::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QAbstractButton::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QAbstractButton::trUtf8(...) ");
 }
 
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-PHP_QT_DESTRUCT(QAbstractButton);
-
+/*!
+ * method checkStateSet
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */

Modified: trunk/qt/classes/qabstractslider.cpp
===================================================================
--- trunk/qt/classes/qabstractslider.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qabstractslider.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,705 +19,1443 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QAbstractSlider.cpp - QAbstractSlider PHP implementation.
- * begin           : Thu Feb 23 16:30:02 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
+
 #include "../php_qt.h"
 
 
 #include <QAbstractSlider>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QAbstractSlider_php_qt:public QAbstractSlider
+{
 
+public:
+  QAbstractSlider_php_qt(zval * zend_ptr, QWidget * parent = 0);
 
-/*		public enumSliderAction:long {
-			SliderAction = 0,
-			SliderAction = 1,
-			SliderAction = 2,
-			SliderAction = 3,
-			SliderAction = 4,
-			SliderAction = 5,
-			SliderAction = 6,
-			SliderAction = 7
-		}
-*/
 
-/*		protected enumSliderChange:long {
-			SliderChange = 0,
-			SliderChange = 1,
-			SliderChange = 2,
-			SliderChange = 3
-		}
-*/
-/*********************************
- *    class     QAbstractSlider
- *    function  tr
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+
+QAbstractSlider_php_qt::QAbstractSlider_php_qt(zval * zend_ptr, QWidget * parent):QAbstractSlider(parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QAbstractSlider",&staticMetaObject));
+}
+
+PHP_QT_MOC(QAbstractSlider);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QAbstractSlider, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QAbstractSlider, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QAbstractSlider *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QAbstractSlider::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QAbstractSlider::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QAbstractSlider::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::tr(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setMaximum
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method wheelEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWheelEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, setMaximum){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method rangeChanged
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int mins0
+ * @param	 int maxs1
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+/*!
+ * method setMaximum
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QAbstractSlider, setMaximum)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMaximum' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QAbstractSlider *
+        selfpointer;
 
-			obj->setMaximum((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMaximum((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::setMaximum(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setInvertedAppearance
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    bool
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QAbstractSlider, setInvertedAppearance){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method sliderMoved
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int positions0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+/*!
+ * method setInvertedAppearance
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QAbstractSlider, setInvertedAppearance)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setInvertedAppearance' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractSlider *
+        selfpointer;
 
-			obj->setInvertedAppearance((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setInvertedAppearance((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::setInvertedAppearance(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  value
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method sliderChange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	SliderChange changes0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QAbstractSlider, value){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj->value());
-	}
-}
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setSliderDown
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    bool
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QAbstractSlider, setSliderDown){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+/*!
+ * method value
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QAbstractSlider, value)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'value' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
-			obj->setSliderDown((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->value());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::value(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  triggerAction
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    SliderAction action
+/*!
+ * method setSliderDown
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, triggerAction){
-		/* l public*/
 
-		/* int action,  */
+ZEND_METHOD(QAbstractSlider, setSliderDown)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setSliderDown' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractSlider *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setSliderDown((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::setSliderDown(...) ");
+}
 
+/*!
+ * method triggerAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	SliderAction actions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj->triggerAction((QAbstractSlider::SliderAction) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+ZEND_METHOD(QAbstractSlider, triggerAction)
+{
+// notice: unknown argument SliderAction actions0, skipped
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::triggerAction(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setRange
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int min, int max
+/*!
+ * method valueChanged
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int values0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QAbstractSlider, setRange){
-		/* ll public*/
 
-		/* int min, int max,  */
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+/*!
+ * method singleStep
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QAbstractSlider, singleStep)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'singleStep' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
-			obj->setRange((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->singleStep());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::singleStep(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  singleStep
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method setRange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int mins0
+ * @param	 int maxs1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, singleStep){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj->singleStep());
-	}
+
+ZEND_METHOD(QAbstractSlider, setRange)
+{
+  ///int mins0, int maxs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setRange' is not static");
+        RETURN_NULL();
+      }
+      /// try int mins0, int maxs1,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setRange((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::setRange(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  repeatAction
- *    flags:    c
- *    access:    protected
- *    return:    SliderAction
- *    params:    
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-// method repeatAction is protected, skipped.
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setTracking
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    bool enable
+/*!
+ * method repeatAction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	SliderAction
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, setTracking){
-		/* l public*/
 
-		/* int enable,  */
+/*!
+ * method setTracking
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enables0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+ZEND_METHOD(QAbstractSlider, setTracking)
+{
+  ///bool enables0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setTracking' is not static");
+        RETURN_NULL();
+      }
+      /// try bool enables0,
+      QAbstractSlider *
+        selfpointer;
 
-
-			obj->setTracking((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setTracking((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::setTracking(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  QAbstractSlider
- *    flags:    t
- *    access:    public
- *    return:    
- *    params:    QWidget *parent=0
+/*!
+ * method QAbstractSlider
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parent=0s0
+ * 
+ * overloaded args:
+ * @param	QAbstractSliderPrivate &dd
+ * @param	 QWidget *parent=0
+ * 
+ * overloaded args:
+ * @param	const QAbstractSlider &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QAbstractSlider, __construct){
-//qt_QWidget*
-		/* o public*/
 
-		/* qt_QWidget* parent,  */
+ZEND_METHOD(QAbstractSlider, __construct)
+{
+  ///QWidget *parent=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider_php_qt *
+        selfpointer = new QAbstractSlider_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget *parent=0s0,
+      QWidget *
+        cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QAbstractSlider_php_qt *
+        selfpointer = new QAbstractSlider_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QAbstractSliderPrivate &dd, QWidget *parent=0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAbstractSliderPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QAbstractSliderPrivate &dd,
+        QAbstractSliderPrivate *
+          cpp_arg_0 = static_cast < QAbstractSliderPrivate * >(php_qt_fetch(arg_0));
+        QAbstractSlider_php_qt *
+          selfpointer = new QAbstractSlider_php_qt(getThis(), (QAbstractSliderPrivate &) * cpp_arg_0);
 
-			if(obj_z_0->inherits("QWidget")) {
-				QAbstractSlider *QAbstractSlider_ptr = new QAbstractSlider((QWidget*) obj_z_0);
-				PHP_QT_REGISTER(QAbstractSlider_ptr);
-				RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QAbstractSliderPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QAbstractSliderPrivate &dd, QWidget *parent=0,
+        QAbstractSliderPrivate *
+          cpp_arg_0 = static_cast < QAbstractSliderPrivate * >(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+        QAbstractSlider_php_qt *
+          selfpointer = new QAbstractSlider_php_qt(getThis(), (QAbstractSliderPrivate &) * cpp_arg_0, (QWidget *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QAbstractSlider &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAbstractSlider
+      if (inherits(Z_OBJCE_P(arg_0), 2)) {
+/// method is private, skip
+        php_error(E_ERROR, "QAbstractSlider::__construct(...) cannot be called with 'const QAbstractSlider &,'.");
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::QAbstractSlider(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  sliderPosition
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method sliderPosition
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, sliderPosition){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj->sliderPosition());
-	}
+
+ZEND_METHOD(QAbstractSlider, sliderPosition)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sliderPosition' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->sliderPosition());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::sliderPosition(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setMinimum
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method invertedAppearance
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, setMinimum){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractSlider, invertedAppearance)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'invertedAppearance' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->invertedAppearance());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::invertedAppearance(...) ");
+}
 
+/*!
+ * method setSliderPosition
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj->setMinimum((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+ZEND_METHOD(QAbstractSlider, setSliderPosition)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setSliderPosition' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setSliderPosition((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::setSliderPosition(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  minimum
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method setPageStep
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, minimum){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj->minimum());
-	}
+
+ZEND_METHOD(QAbstractSlider, setPageStep)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setPageStep' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setPageStep((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::setPageStep(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setPageStep
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method minimum
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, setPageStep){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractSlider, minimum)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimum' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->minimum());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::minimum(...) ");
+}
 
+/*!
+ * method setMinimum
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj->setPageStep((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+ZEND_METHOD(QAbstractSlider, setMinimum)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMinimum' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMinimum((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::setMinimum(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setSliderPosition
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, setSliderPosition){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method maximum
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+ZEND_METHOD(QAbstractSlider, maximum)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'maximum' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
-
-			obj->setSliderPosition((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->maximum());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::maximum(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  invertedAppearance
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
+/*!
+ * method timerEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTimerEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, invertedAppearance){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->invertedAppearance());
-	}
-}
 
-/*********************************
- *    class     QAbstractSlider
- *    function  maximum
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method setValue
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QAbstractSlider, maximum){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj->maximum());
-	}
+
+ZEND_METHOD(QAbstractSlider, setValue)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setValue' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setValue((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::setValue(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  orientation
- *    flags:    c
- *    access:    public
- *    return:    Qt::Orientation
- *    params:    
+/*!
+ * method orientation
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientation
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, orientation){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj->orientation());
-	}
+
+ZEND_METHOD(QAbstractSlider, orientation)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'orientation' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->orientation());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::orientation(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setValue
- *    flags:    l
- *    access:    public_slots
- *    return:    void
- *    params:    int
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QAbstractSlider, setValue){
-		/* l public_slots*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractSlider, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj->setValue((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QAbstractSlider::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  staticMetaObject
- *    flags:    s
- *    access:    public
- *    return:    QMetaObject*
- *    params:    
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, staticMetaObject){
-}
 
-/*********************************
- *    class     QAbstractSlider
- *    function  qObject
- *    flags:    
- *    access:    public
- *    return:    QObject*
- *    params:    
+/*!
+ * method setRepeatAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	SliderAction actions0
+ * @param	 int thresholdTime = 500s1
+ * @param	 int repeatTime = 50s2
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, qObject){
-}
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setRepeatAction
- *    flags:    
- *    access:    protected
- *    return:    void
- *    params:    SliderAction action, int thresholdTime = 500, int repeatTime = 50
+/*!
+ * method invertedControls
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-// method setRepeatAction is protected, skipped.
 
-/*********************************
- *    class     QAbstractSlider
- *    function  invertedControls
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
- */
-ZEND_METHOD(QAbstractSlider, invertedControls){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->invertedControls());
-	}
+ZEND_METHOD(QAbstractSlider, invertedControls)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'invertedControls' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->invertedControls());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::invertedControls(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setSingleStep
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method isSliderDown
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, setSingleStep){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractSlider, isSliderDown)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isSliderDown' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isSliderDown());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::isSliderDown(...) ");
+}
 
+/*!
+ * method setSingleStep
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj->setSingleStep((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+ZEND_METHOD(QAbstractSlider, setSingleStep)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setSingleStep' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setSingleStep((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::setSingleStep(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  isSliderDown
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
+/*!
+ * method keyPressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *evs0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, isSliderDown){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isSliderDown());
-	}
-}
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setOrientation
- *    flags:    l
- *    access:    public_slots
- *    return:    void
- *    params:    Qt::Orientation
+/*!
+ * method setOrientation
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Orientation Qt::Orientations0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QAbstractSlider, setOrientation){
-		/* l public_slots*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractSlider, setOrientation)
+{
+  ///Qt::Orientation Qt::Orientations0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setOrientation' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::Orientation Qt::Orientations0,
+      QAbstractSlider *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setOrientation((Qt::Orientation) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::setOrientation(...) ");
+}
 
+/*!
+ * method pageStep
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-			obj->setOrientation((Qt::Orientation) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+ZEND_METHOD(QAbstractSlider, pageStep)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pageStep' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->pageStep());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::pageStep(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  pageStep
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method sliderPressed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QAbstractSlider, pageStep){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj->pageStep());
-	}
-}
 
-/*********************************
- *    class     QAbstractSlider
- *    function  hasTracking
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
+/*!
+ * method hasTracking
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, hasTracking){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->hasTracking());
-	}
+
+ZEND_METHOD(QAbstractSlider, hasTracking)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hasTracking' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->hasTracking());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::hasTracking(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setInvertedControls
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    bool
+/*!
+ * method sliderReleased
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QAbstractSlider, setInvertedControls){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method setInvertedControls
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+ZEND_METHOD(QAbstractSlider, setInvertedControls)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setInvertedControls' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractSlider *
+        selfpointer;
 
-
-			obj->setInvertedControls((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setInvertedControls((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::setInvertedControls(...) ");
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  trUtf8
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QAbstractSlider, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QAbstractSlider, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QAbstractSlider *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QAbstractSlider::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QAbstractSlider::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QAbstractSlider * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QAbstractSlider::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QAbstractSlider::trUtf8(...) ");
 }
 
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-PHP_QT_DESTRUCT(QAbstractSlider);
-
+/*!
+ * method actionTriggered
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int actions0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */

Modified: trunk/qt/classes/qactionevent.cpp
===================================================================
--- trunk/qt/classes/qactionevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qactionevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,55 +19,180 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QActionEvent.cpp - QActionEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QActionEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QActionEvent */
-/*
- *    function  action
- *    flags:    c
+#include <QActionEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QActionEvent_php_qt:public QActionEvent
+{
+
+public:
+  QActionEvent_php_qt(zval * zend_ptr, int types0, QAction * actions1, QAction * before = 0);
+
+
+  zval *zend_ptr;
+};
+QActionEvent_php_qt::QActionEvent_php_qt(zval * zend_ptr, int types0, QAction * actions1, QAction * before):
+QActionEvent(types0, actions1, before)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QActionEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int types0s0
+ * @param	QAction *actions1s1
+ * @param	 QAction *before = 0s2
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QActionEvent, action){
-	if (ZEND_NUM_ARGS() == 0){
-			QActionEvent *obj = (QActionEvent*) PHP_QT_FETCH();
-				QAction * return_object = (QAction *) obj->action();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QActionEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QActionEvent, __construct)
+{
+  ///int types0s0,QAction *actions1s1, QAction *before = 0s2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try int types0s0,QAction *actions1s1,
+        QAction *cpp_arg_1 = static_cast < QAction * >(php_qt_fetch(arg_1));
+        QActionEvent_php_qt *selfpointer = new QActionEvent_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (QAction *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try int types0s0,QAction *actions1s1, QAction *before = 0s2,
+        QAction *cpp_arg_1 = static_cast < QAction * >(php_qt_fetch(arg_1));
+        QAction *cpp_arg_2 = static_cast < QAction * >(php_qt_fetch(arg_2));
+        QActionEvent_php_qt *selfpointer = new QActionEvent_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (QAction *) cpp_arg_1, (QAction *) cpp_arg_2);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QActionEvent::QActionEvent(...) ");
 }
 
-/*********************************
- *    class     QActionEvent */
-/*
- *    function  before
- *    flags:    c
+/*!
+ * method before
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QAction *
+ * @flags	c
  */
-ZEND_METHOD(QActionEvent, before){
-	if (ZEND_NUM_ARGS() == 0){
-			QActionEvent *obj = (QActionEvent*) PHP_QT_FETCH();
-				QAction * return_object = (QAction *) obj->before();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QActionEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QActionEvent, before)
+{
+  ///
+#ifdef PHP_QT_QAction           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'before' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QActionEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QActionEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QAction * >(selfpointer->before());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QActionEvent::before(...) ");
 }
 
+/*!
+ * method action
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QAction *
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QActionEvent);
+ZEND_METHOD(QActionEvent, action)
+{
+  ///
+#ifdef PHP_QT_QAction           // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'action' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QActionEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QActionEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QAction * >(selfpointer->action());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QActionEvent::action(...) ");
+}

Modified: trunk/qt/classes/qapplication.cpp
===================================================================
--- trunk/qt/classes/qapplication.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qapplication.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,12 +19,13 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QApplication.cpp - QApplication PHP implementation.
- * begin           : Thu Feb 23 12:34:50 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
+
 #include "../php_qt.h"
 
 
@@ -33,1496 +33,3181 @@
 #include <QPalette>
 #include <QFontMetrics>
 #include <QIcon>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QApplication_php_qt:public QApplication
+{
 
-int argc__;
-char *argv__[1];
+public:
+  QApplication_php_qt(zval * zend_ptr, int &argcs0, char **argvs1);
+    QApplication_php_qt(zval * zend_ptr, int &argcs0, char **argvs1, bool GUIenableds2);
+    QApplication_php_qt(zval * zend_ptr, int &argcs0, char **argvs1, Type s2);
 
 
-/*		public enumType:long {
-			Type = 0,
-			Type = 1,
-			Type = 2
-		}
-*/
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+QApplication_php_qt::QApplication_php_qt(zval * zend_ptr, int &argcs0, char **argvs1):
+QApplication(argcs0, argvs1)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QApplication",&staticMetaObject));
+}
+QApplication_php_qt::QApplication_php_qt(zval * zend_ptr, int &argcs0, char **argvs1, bool GUIenableds2):
+QApplication(argcs0, argvs1, GUIenableds2)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QApplication",&staticMetaObject));
+}
+QApplication_php_qt::QApplication_php_qt(zval * zend_ptr, int &argcs0, char **argvs1, Type s2):
+QApplication(argcs0, argvs1, s2)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QApplication",&staticMetaObject));
+}
 
-/*		public enumColorSpec:long {
-			NormalColor = 0,
-			CustomColor = 1,
-			ManyColor = 2
-		}
-*/
-/*********************************
- *    class     QApplication
- *    function  sessionKey
- *    flags:    c
+PHP_QT_MOC(QApplication);
+
+/*!
+ * method sessionKey
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QApplication, sessionKey){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->sessionKey();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, sessionKey)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sessionKey' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->sessionKey());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::sessionKey(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  tr
- *    flags:    s
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QApplication, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QApplication, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QApplication::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QApplication::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QApplication::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::tr(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  clipboard
- *    flags:    s
+/*!
+ * method clipboard
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QClipboard *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, clipboard){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QClipboard ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QClipboard *) obj->clipboard();
-			} else {
-				*return_object = (QClipboard *) QApplication::clipboard();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, clipboard)
+{
+  ///
+#ifdef PHP_QT_QClipboard        // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QClipboard * >(QApplication::clipboard());
+      } else {
+        le.ptr = static_cast < QClipboard * >(selfpointer->clipboard());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::clipboard(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  startDragTime
- *    flags:    s
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QApplication, startDragTime){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj->startDragTime());
-	}
-}
 
-/*********************************
- *    class     QApplication
- *    function  sessionId
- *    flags:    c
+/*!
+ * method commitData
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QSessionManager & sms0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QApplication, sessionId){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->sessionId();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QApplication
- *    function  isSessionRestored
- *    flags:    c
+/*!
+ * method startDragTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, isSessionRestored){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isSessionRestored());
-	}
+
+ZEND_METHOD(QApplication, startDragTime)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::startDragTime());
+      } else {
+        RETURN_LONG(selfpointer->startDragTime());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::startDragTime(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setColorSpec
- *    flags:    s
+/*!
+ * method sessionId
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QApplication, setColorSpec){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QApplication, sessionId)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sessionId' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setColorSpec((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->sessionId());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::sessionId(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setStartDragDistance
- *    flags:    s
+/*!
+ * method isSessionRestored
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QApplication, setStartDragDistance){
-		/* l public*/
 
-		/* int l,  */
+ZEND_METHOD(QApplication, isSessionRestored)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isSessionRestored' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isSessionRestored());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::isSessionRestored(...) ");
+}
 
+/*!
+ * method setColorSpec
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-			obj->setStartDragDistance((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+ZEND_METHOD(QApplication, setColorSpec)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ints0,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setColorSpec((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->setColorSpec((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setColorSpec(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setLayoutDirection
- *    flags:    s
+/*!
+ * method setStartDragDistance
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ls0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setLayoutDirection){
-		/* l public*/
 
-		/* int direction,  */
+ZEND_METHOD(QApplication, setStartDragDistance)
+{
+  ///int ls0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ls0,
+      QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setStartDragDistance((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->setStartDragDistance((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setStartDragDistance(...) ");
+}
 
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
+ */
 
-			obj->setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+/*!
+ * method setLayoutDirection
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::LayoutDirection directions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
+
+ZEND_METHOD(QApplication, setLayoutDirection)
+{
+  ///Qt::LayoutDirection directions0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try Qt::LayoutDirection directions0,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(arg_0)));
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setLayoutDirection(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  keyboardInputInterval
- *    flags:    s
+/*!
+ * method keyboardInputInterval
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, keyboardInputInterval){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj->keyboardInputInterval());
-	}
-}
 
-/*********************************
- *    class     QApplication
- *    function  allWidgets
- *    flags:    s
- */
-ZEND_METHOD(QApplication, allWidgets){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QWidgetList* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidgetList) obj->allWidgets();
-			} else {
-				*return_object = (QWidgetList) QApplication::allWidgets();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QApplication, keyboardInputInterval)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::keyboardInputInterval());
+      } else {
+        RETURN_LONG(selfpointer->keyboardInputInterval());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::keyboardInputInterval(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setCursorFlashTime
- *    flags:    s
+/*!
+ * method allWidgets
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidgetList
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setCursorFlashTime){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QApplication, allWidgets)
+{
+  ///
+#ifdef PHP_QT_QWidgetList       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setCursorFlashTime((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QWidgetList *return_object = new QWidgetList;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QWidgetList > (QApplication::allWidgets());
+      } else {
+        *return_object = static_cast < QWidgetList > (selfpointer->allWidgets());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::allWidgets(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setWheelScrollLines
- *    flags:    s
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QApplication, setWheelScrollLines){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method setCursorFlashTime
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+ZEND_METHOD(QApplication, setCursorFlashTime)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ints0,
+      QApplication *selfpointer;
 
-
-			obj->setWheelScrollLines((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setCursorFlashTime((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->setCursorFlashTime((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setCursorFlashTime(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setEffectEnabled
- *    flags:    s
+/*!
+ * method setWheelScrollLines
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setEffectEnabled){
-		/* ll public*/
 
-		/* int , int enable,  */
+ZEND_METHOD(QApplication, setWheelScrollLines)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ints0,
+      QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-
-
-			obj->setEffectEnabled((Qt::UIEffect) Z_LVAL_P(z_0) ,(bool) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setWheelScrollLines((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->setWheelScrollLines((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setWheelScrollLines(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setStyle
- *    flags:    s
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QApplication, setStyle){
-//qt_QStyle*
-		/* o public*/
 
-		/* qt_QStyle* ,  */
+/*!
+ * method setEffectEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::UIEffect Qt::UIEffects0
+ * @param	 bool enable = trues1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QApplication, setEffectEnabled)
+{
+  ///Qt::UIEffect Qt::UIEffects0, bool enable = trues1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try Qt::UIEffect Qt::UIEffects0,
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setEffectEnabled((Qt::UIEffect) Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->setEffectEnabled((Qt::UIEffect) Z_LVAL_P(arg_0)));
+      }
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_BOOL) {
+      /// try Qt::UIEffect Qt::UIEffects0, bool enable = trues1,
+      QApplication *selfpointer;
 
-			if(obj_z_0->inherits("QStyle")) {
-				obj->setStyle((QStyle*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setEffectEnabled((Qt::UIEffect) Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
+      } else {
+        RETURN_VOID(selfpointer->setEffectEnabled((Qt::UIEffect) Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setEffectEnabled(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  isRightToLeft
- *    flags:    s
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QApplication, isRightToLeft){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isRightToLeft());
-	}
-}
 
-/*********************************
- *    class     QApplication
- *    function  setDesktopSettingsAware
- *    flags:    s
+/*!
+ * method setStyle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QStyle *s0
+ * 
+ * overloaded args:
+ * @param	const QString&
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setDesktopSettingsAware){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QApplication, setStyle)
+{
+  ///QStyle *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QStyle
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try QStyle *s0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QStyle *cpp_arg_0 = static_cast < QStyle * >(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setStyle((QStyle *) cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->setStyle((QStyle *) cpp_arg_0));
+        }
+      }
+#endif
 
-			obj->setDesktopSettingsAware((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  ///const QString&
+#ifdef PHP_QT_QStyle            // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString&,
+        QApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        if (getThis() == NULL) {
+          le.ptr = static_cast < QStyle * >(QApplication::setStyle((const QString &)*cpp_arg_0));
+        } else {
+          le.ptr = static_cast < QStyle * >(selfpointer->setStyle((const QString &)*cpp_arg_0));
+        } php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::setStyle(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  inputContext
- *    flags:    c
+/*!
+ * method isRightToLeft
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QApplication, inputContext){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QInputContext ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QInputContext *) obj->inputContext();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, isRightToLeft)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QApplication::isRightToLeft());
+      } else {
+        RETURN_BOOL(selfpointer->isRightToLeft());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::isRightToLeft(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  palette
- *    flags:    s
+/*!
+ * method setDesktopSettingsAware
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, palette){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QPalette* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QPalette) obj->palette();
-			} else {
-				*return_object = (QPalette) QApplication::palette();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, setDesktopSettingsAware)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      /// try bool bools0,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setDesktopSettingsAware((bool) Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->setDesktopSettingsAware((bool) Z_LVAL_P(arg_0)));
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setDesktopSettingsAware(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  desktopSettingsAware
- *    flags:    s
+/*!
+ * method palette
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QWidget *
+ * 
+ * overloaded args:
+ * @param	const char *className
+ * 
+ * @access	public
+ * @return	QPalette
+ * @flags	s
  */
-ZEND_METHOD(QApplication, desktopSettingsAware){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->desktopSettingsAware());
-	}
+
+ZEND_METHOD(QApplication, palette)
+{
+  ///
+#ifdef PHP_QT_QPalette          // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QPalette *return_object = new QPalette;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QPalette > (QApplication::palette());
+      } else {
+        *return_object = static_cast < QPalette > (selfpointer->palette());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const QWidget *
+#ifdef PHP_QT_QPalette          // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        /// try const QWidget *,
+        QApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QPalette *return_object = new QPalette;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast < QPalette > (QApplication::palette((const QWidget *)cpp_arg_0));
+        } else {
+          *return_object = static_cast < QPalette > (selfpointer->palette((const QWidget *)cpp_arg_0));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const char *className
+#ifdef PHP_QT_QPalette          // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *className,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QPalette *return_object = new QPalette;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QPalette > (QApplication::palette((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QPalette > (selfpointer->palette((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::palette(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  fontMetrics
- *    flags:    s
+/*!
+ * method inputContext
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QInputContext *
+ * @flags	c
  */
-ZEND_METHOD(QApplication, fontMetrics){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QFontMetrics* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QFontMetrics) obj->fontMetrics();
-			} else {
-				*return_object = (QFontMetrics) QApplication::fontMetrics();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, inputContext)
+{
+  ///
+#ifdef PHP_QT_QInputContext     // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'inputContext' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QInputContext * >(selfpointer->inputContext());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::inputContext(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  desktop
- *    flags:    s
+/*!
+ * method desktopSettingsAware
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QApplication, desktop){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QDesktopWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QDesktopWidget *) obj->desktop();
-			} else {
-				*return_object = (QDesktopWidget *) QApplication::desktop();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, desktopSettingsAware)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QApplication::desktopSettingsAware());
+      } else {
+        RETURN_BOOL(selfpointer->desktopSettingsAware());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::desktopSettingsAware(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method fontMetrics
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QFontMetrics
+ * @flags	s
  */
-ZEND_METHOD(QApplication, staticMetaObject){
+
+ZEND_METHOD(QApplication, fontMetrics)
+{
+  ///
+#ifdef PHP_QT_QFontMetrics      // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QFontMetrics *return_object = new QFontMetrics;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QFontMetrics > (QApplication::fontMetrics());
+      } else {
+        *return_object = static_cast < QFontMetrics > (selfpointer->fontMetrics());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::fontMetrics(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  colorSpec
- *    flags:    s
+/*!
+ * method desktop
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QDesktopWidget *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, colorSpec){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj->colorSpec());
-	}
+
+ZEND_METHOD(QApplication, desktop)
+{
+  ///
+#ifdef PHP_QT_QDesktopWidget    // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QDesktopWidget * >(QApplication::desktop());
+      } else {
+        le.ptr = static_cast < QDesktopWidget * >(selfpointer->desktop());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::desktop(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  quitOnLastWindowClosed
- *    flags:    s
+/*!
+ * method colorSpec
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, quitOnLastWindowClosed){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->quitOnLastWindowClosed());
-	}
+
+ZEND_METHOD(QApplication, colorSpec)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::colorSpec());
+      } else {
+        RETURN_LONG(selfpointer->colorSpec());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::colorSpec(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  qObject
- *    flags:    
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QApplication, qObject){
+
+ZEND_METHOD(QApplication, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QApplication::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  wheelScrollLines
- *    flags:    s
+/*!
+ * method quitOnLastWindowClosed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QApplication, wheelScrollLines){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj->wheelScrollLines());
-	}
+
+ZEND_METHOD(QApplication, quitOnLastWindowClosed)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QApplication::quitOnLastWindowClosed());
+      } else {
+        RETURN_BOOL(selfpointer->quitOnLastWindowClosed());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::quitOnLastWindowClosed(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  mouseButtons
- *    flags:    s
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QApplication, mouseButtons){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj->mouseButtons();
-			RETURN_NULL();
-	}
+
+/*!
+ * method wheelScrollLines
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
+ */
+
+ZEND_METHOD(QApplication, wheelScrollLines)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::wheelScrollLines());
+      } else {
+        RETURN_LONG(selfpointer->wheelScrollLines());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::wheelScrollLines(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  topLevelWidgets
- *    flags:    s
+/*!
+ * method mouseButtons
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::MouseButtons
+ * @flags	s
  */
-ZEND_METHOD(QApplication, topLevelWidgets){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QWidgetList* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidgetList) obj->topLevelWidgets();
-			} else {
-				*return_object = (QWidgetList) QApplication::topLevelWidgets();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, mouseButtons)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::mouseButtons());
+      } else {
+        RETURN_LONG(selfpointer->mouseButtons());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::mouseButtons(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  QApplication
- *    flags:    
+/*!
+ * method topLevelWidgets
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidgetList
+ * @flags	s
  */
-ZEND_METHOD(QApplication, __construct){
-		/* ll public*/
 
-		/* int argc, char* * argv,  */
+ZEND_METHOD(QApplication, topLevelWidgets)
+{
+  ///
+#ifdef PHP_QT_QWidgetList       // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
 
-//			QApplication *QApplication_ptr = new QApplication((int&) Z_LVAL_P(z_0) ,(char* *) Z_LVAL_P(z_1));
-				QApplication *QApplication_ptr = new QApplication(argc__, argv__);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				PHP_QT_REGISTER(QApplication_ptr);
-				RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QWidgetList *return_object = new QWidgetList;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QWidgetList > (QApplication::topLevelWidgets());
+      } else {
+        *return_object = static_cast < QWidgetList > (selfpointer->topLevelWidgets());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::topLevelWidgets(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  aboutQt
- *    flags:    sl
+/*!
+ * method QApplication
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int &argcs0s0
+ * @param	char   **argvs1s1
+ * 
+ * overloaded args:
+ * @param	int &argcs0
+ * @param	char  **argvs1
+ * @param	bool GUIenableds2
+ * 
+ * overloaded args:
+ * @param	int &argcs0
+ * @param	char  **argvs1
+ * @param	 Type s2
+ * 
+ * overloaded args:
+ * @param	const QApplication &
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QApplication, aboutQt){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj->aboutQt();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, __construct)
+{
+  ///int &argcs0s0,char   **argvs1s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_ARRAY) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try int &argcs0s0,char   **argvs1s1,
+      QApplication_php_qt *selfpointer = new QApplication_php_qt(getThis(), (int &)Z_LVAL_P(arg_0), new char *[1]);
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///int &argcs0,char  **argvs1,bool GUIenableds2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_ARRAY && Z_TYPE_P(arg_2) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try int &argcs0,char  **argvs1,bool GUIenableds2,
+      QApplication_php_qt *selfpointer = new QApplication_php_qt(getThis(), (int &)Z_LVAL_P(arg_0), new char *[1], (bool) Z_LVAL_P(arg_1));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+// notice: unknown argument  Type s2, skipped
+
+  ///const QApplication &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QApplication
+      if (inherits(Z_OBJCE_P(arg_0), 4)) {
+/// method is private, skip
+        php_error(E_ERROR, "QApplication::__construct(...) cannot be called with 'const QApplication &,'.");
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::QApplication(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  layoutDirection
- *    flags:    s
+/*!
+ * method aboutQt
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	sl
  */
-ZEND_METHOD(QApplication, layoutDirection){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj->layoutDirection());
-	}
+
+ZEND_METHOD(QApplication, aboutQt)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::aboutQt());
+      } else {
+        RETURN_VOID(selfpointer->aboutQt());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::aboutQt(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  windowIcon
- *    flags:    s
+/*!
+ * method layoutDirection
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::LayoutDirection
+ * @flags	s
  */
-ZEND_METHOD(QApplication, windowIcon){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj->windowIcon();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, layoutDirection)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::layoutDirection());
+      } else {
+        RETURN_LONG(selfpointer->layoutDirection());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::layoutDirection(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  style
- *    flags:    s
+/*!
+ * method windowIcon
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QIcon
+ * @flags	s
  */
-ZEND_METHOD(QApplication, style){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QStyle ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QStyle *) obj->style();
-			} else {
-				*return_object = (QStyle *) QApplication::style();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, windowIcon)
+{
+  ///
+#ifdef PHP_QT_QIcon             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QIcon *return_object = new QIcon;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QIcon > (QApplication::windowIcon());
+      } else {
+        *return_object = static_cast < QIcon > (selfpointer->windowIcon());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::windowIcon(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  activeModalWidget
- *    flags:    s
+/*!
+ * method style
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QStyle *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, activeModalWidget){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj->activeModalWidget();
-			} else {
-				*return_object = (QWidget *) QApplication::activeModalWidget();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, style)
+{
+  ///
+#ifdef PHP_QT_QStyle            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QStyle * >(QApplication::style());
+      } else {
+        le.ptr = static_cast < QStyle * >(selfpointer->style());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::style(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setKeyboardInputInterval
- *    flags:    s
+/*!
+ * method activeModalWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setKeyboardInputInterval){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QApplication, activeModalWidget)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setKeyboardInputInterval((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QWidget * >(QApplication::activeModalWidget());
+      } else {
+        le.ptr = static_cast < QWidget * >(selfpointer->activeModalWidget());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::activeModalWidget(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  restoreOverrideCursor
- *    flags:    s
+/*!
+ * method setKeyboardInputInterval
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, restoreOverrideCursor){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj->restoreOverrideCursor();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, setKeyboardInputInterval)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ints0,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setKeyboardInputInterval((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->setKeyboardInputInterval((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setKeyboardInputInterval(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setDoubleClickInterval
- *    flags:    s
+/*!
+ * method restoreOverrideCursor
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setDoubleClickInterval){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QApplication, restoreOverrideCursor)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::restoreOverrideCursor());
+      } else {
+        RETURN_VOID(selfpointer->restoreOverrideCursor());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::restoreOverrideCursor(...) ");
+}
 
+/*!
+ * method lastWindowClosed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
 
-			obj->setDoubleClickInterval((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
-}
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-/*********************************
- *    class     QApplication
- *    function  activeWindow
- *    flags:    s
+/*!
+ * method setDoubleClickInterval
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, activeWindow){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj->activeWindow();
-			} else {
-				*return_object = (QWidget *) QApplication::activeWindow();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, setDoubleClickInterval)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ints0,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setDoubleClickInterval((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->setDoubleClickInterval((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setDoubleClickInterval(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setActiveWindow
- *    flags:    s
+/*!
+ * method activeWindow
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setActiveWindow){
-//qt_QWidget*
-		/* o public*/
 
-		/* qt_QWidget* act,  */
+ZEND_METHOD(QApplication, activeWindow)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0->inherits("QWidget")) {
-				obj->setActiveWindow((QWidget*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QWidget * >(QApplication::activeWindow());
+      } else {
+        le.ptr = static_cast < QWidget * >(selfpointer->activeWindow());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::activeWindow(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  widgetAt
- *    flags:    s
+/*!
+ * method setActiveWindow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * acts0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, widgetAt){
-		/* l public*/
 
-		/* const QPoint& p,  */
+ZEND_METHOD(QApplication, setActiveWindow)
+{
+  ///QWidget * acts0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        /// try QWidget * acts0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setActiveWindow((QWidget *) cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->setActiveWindow((QWidget *) cpp_arg_0));
+        }
+      }
+#endif
 
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj->widgetAt((const QPoint&) Z_LVAL_P(z_0));
-			} else {
-				*return_object = (QWidget *) QApplication::widgetAt((const QPoint&) Z_LVAL_P(z_0));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setActiveWindow(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  isEffectEnabled
- *    flags:    s
+/*!
+ * method widgetAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &ps0
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, isEffectEnabled){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QApplication, widgetAt)
+{
+  ///const QPoint &ps0
+#ifdef PHP_QT_QWidget           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QPoint &ps0,
+        QApplication *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QPoint *cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			RETURN_BOOL(obj->isEffectEnabled((Qt::UIEffect) Z_LVAL_P(z_0)));
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        if (getThis() == NULL) {
+          le.ptr = static_cast < QWidget * >(QApplication::widgetAt((const QPoint &)*cpp_arg_0));
+        } else {
+          le.ptr = static_cast < QWidget * >(selfpointer->widgetAt((const QPoint &)*cpp_arg_0));
+        } php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///int x, int y
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try int x, int y,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QWidget * >(QApplication::widgetAt((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } else {
+        le.ptr = static_cast < QWidget * >(selfpointer->widgetAt((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::widgetAt(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setPalette
- *    flags:    s
+/*!
+ * method isEffectEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::UIEffect Qt::UIEffects0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setPalette){
-//const QPalette&
-		/* os public*/
 
-		/* const QPalette& , const char* className,  */
+ZEND_METHOD(QApplication, isEffectEnabled)
+{
+  ///Qt::UIEffect Qt::UIEffects0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try Qt::UIEffect Qt::UIEffects0,
+      QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_STRING){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QApplication::isEffectEnabled((Qt::UIEffect) Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_BOOL(selfpointer->isEffectEnabled((Qt::UIEffect) Z_LVAL_P(arg_0)));
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::isEffectEnabled(...) ");
+}
 
+/*!
+ * method setPalette
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPalette &s0
+ * @param	 const char * className = 0s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-			if(obj_z_0->inherits("QPalette")) {
-				obj->setPalette((const QPalette&) *obj_z_0, (const char*) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+ZEND_METHOD(QApplication, setPalette)
+{
+  ///const QPalette &s0, const char * className = 0s1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPalette
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QPalette &s0,
+        QApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QPalette *cpp_arg_0 = static_cast < QPalette * >(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setPalette((const QPalette &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->setPalette((const QPalette &)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_STRING) {
+#ifdef PHP_QT_QPalette
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QPalette &s0, const char * className = 0s1,
+        QApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QPalette *cpp_arg_0 = static_cast < QPalette * >(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setPalette((const QPalette &)*cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0]));
+        } else {
+          RETURN_VOID(selfpointer->setPalette((const QPalette &)*cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0]));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setPalette(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  doubleClickInterval
- *    flags:    s
+/*!
+ * method doubleClickInterval
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, doubleClickInterval){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj->doubleClickInterval());
-	}
+
+ZEND_METHOD(QApplication, doubleClickInterval)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::doubleClickInterval());
+      } else {
+        RETURN_LONG(selfpointer->doubleClickInterval());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::doubleClickInterval(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  font
- *    flags:    s
+/*!
+ * method font
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QWidget * = 0s0
+ * 
+ * @access	public
+ * @return	QFont
+ * @flags	s
  */
-ZEND_METHOD(QApplication, font){
-//const QWidget*
-		/* o public*/
 
-		/* const QWidget* ,  */
+ZEND_METHOD(QApplication, font)
+{
+  ///const QWidget * = 0s0
+#ifdef PHP_QT_QFont             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0->inherits("QWidget")) {
-				QFont* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QFont) obj->font((const QWidget*) obj_z_0);
-			} else {
-				*return_object = (QFont) QApplication::font((const QWidget*) obj_z_0);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QFont *return_object = new QFont;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QFont > (QApplication::font());
+      } else {
+        *return_object = static_cast < QFont > (selfpointer->font());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      /// try const QWidget * = 0s0,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QFont *return_object = new QFont;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QFont > (QApplication::font((const QWidget *)cpp_arg_0));
+      } else {
+        *return_object = static_cast < QFont > (selfpointer->font((const QWidget *)cpp_arg_0));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::font(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  globalStrut
- *    flags:    s
+/*!
+ * method globalStrut
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	s
  */
-ZEND_METHOD(QApplication, globalStrut){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->globalStrut();
-			} else {
-				*return_object = (QSize) QApplication::globalStrut();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, globalStrut)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QSize > (QApplication::globalStrut());
+      } else {
+        *return_object = static_cast < QSize > (selfpointer->globalStrut());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::globalStrut(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setGlobalStrut
- *    flags:    s
+/*!
+ * method setGlobalStrut
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setGlobalStrut){
-//const QSize&
-		/* o public*/
 
-		/* const QSize& ,  */
+ZEND_METHOD(QApplication, setGlobalStrut)
+{
+  ///const QSize &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QSize &s0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QSize *cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setGlobalStrut((const QSize &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->setGlobalStrut((const QSize &)*cpp_arg_0));
+      }}
+#endif
 
-			if(obj_z_0->inherits("QSize")) {
-				obj->setGlobalStrut((const QSize&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setGlobalStrut(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  exec
- *    flags:    s
+/*!
+ * method exec
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, exec){
-	if (ZEND_NUM_ARGS() == 0){
-//			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(QApplication::exec());
-	}
+
+ZEND_METHOD(QApplication, exec)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::exec());
+      } else {
+        RETURN_LONG(selfpointer->exec());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::exec(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  changeOverrideCursor
- *    flags:    s
+/*!
+ * method changeOverrideCursor
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QCursor &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, changeOverrideCursor){
-//const QCursor&
-		/* o public*/
 
-		/* const QCursor& ,  */
+ZEND_METHOD(QApplication, changeOverrideCursor)
+{
+  ///const QCursor &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QCursor
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QCursor &s0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QCursor *cpp_arg_0 = static_cast < QCursor * >(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::changeOverrideCursor((const QCursor &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->changeOverrideCursor((const QCursor &)*cpp_arg_0));
+      }}
+#endif
 
-			if(obj_z_0->inherits("QCursor")) {
-				obj->changeOverrideCursor((const QCursor&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::changeOverrideCursor(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setWindowIcon
- *    flags:    s
+/*!
+ * method setWindowIcon
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QIcon &icons0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setWindowIcon){
-//const QIcon&
-		/* o public*/
 
-		/* const QIcon& icon,  */
+ZEND_METHOD(QApplication, setWindowIcon)
+{
+  ///const QIcon &icons0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QIcon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QIcon &icons0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QIcon *cpp_arg_0 = static_cast < QIcon * >(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setWindowIcon((const QIcon &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->setWindowIcon((const QIcon &)*cpp_arg_0));
+      }}
+#endif
 
-			if(obj_z_0->inherits("QIcon")) {
-				obj->setWindowIcon((const QIcon&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setWindowIcon(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  keyboardModifiers
- *    flags:    s
+/*!
+ * method keyboardModifiers
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::KeyboardModifiers
+ * @flags	s
  */
-ZEND_METHOD(QApplication, keyboardModifiers){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj->keyboardModifiers();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, keyboardModifiers)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::keyboardModifiers());
+      } else {
+        RETURN_LONG(selfpointer->keyboardModifiers());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::keyboardModifiers(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  event
- *    flags:    
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QApplication, event){
-		/* o protected*/
-}
 
-/*********************************
- *    class     QApplication
- *    function  beep
- *    flags:    s
+/*!
+ * method beep
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, beep){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj->beep();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, beep)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::beep());
+      } else {
+        RETURN_VOID(selfpointer->beep());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::beep(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  overrideCursor
- *    flags:    s
+/*!
+ * method overrideCursor
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QCursor *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, overrideCursor){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QCursor ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QCursor *) obj->overrideCursor();
-			} else {
-				*return_object = (QCursor *) QApplication::overrideCursor();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, overrideCursor)
+{
+  ///
+#ifdef PHP_QT_QCursor           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QCursor * >(QApplication::overrideCursor());
+      } else {
+        le.ptr = static_cast < QCursor * >(selfpointer->overrideCursor());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::overrideCursor(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  isLeftToRight
- *    flags:    s
+/*!
+ * method isLeftToRight
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QApplication, isLeftToRight){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isLeftToRight());
-	}
+
+ZEND_METHOD(QApplication, isLeftToRight)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QApplication::isLeftToRight());
+      } else {
+        RETURN_BOOL(selfpointer->isLeftToRight());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::isLeftToRight(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  syncX
- *    flags:    s
+/*!
+ * method syncX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, syncX){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj->syncX();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, syncX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::syncX());
+      } else {
+        RETURN_VOID(selfpointer->syncX());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::syncX(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  type
- *    flags:    s
+/*!
+ * method type
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Type
+ * @flags	s
  */
-ZEND_METHOD(QApplication, type){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj->type());
-	}
+
+ZEND_METHOD(QApplication, type)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type Type");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::type(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setOverrideCursor
- *    flags:    s
+/*!
+ * method setOverrideCursor
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QCursor &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setOverrideCursor){
-//const QCursor&
-		/* o public*/
 
-		/* const QCursor& ,  */
+ZEND_METHOD(QApplication, setOverrideCursor)
+{
+  ///const QCursor &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QCursor
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QCursor &s0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QCursor *cpp_arg_0 = static_cast < QCursor * >(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setOverrideCursor((const QCursor &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->setOverrideCursor((const QCursor &)*cpp_arg_0));
+      }}
+#endif
 
-			if(obj_z_0->inherits("QCursor")) {
-				obj->setOverrideCursor((const QCursor&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setOverrideCursor(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  focusWidget
- *    flags:    s
+/*!
+ * method focusWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, focusWidget){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj->focusWidget();
-			} else {
-				*return_object = (QWidget *) QApplication::focusWidget();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, focusWidget)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QWidget * >(QApplication::focusWidget());
+      } else {
+        le.ptr = static_cast < QWidget * >(selfpointer->focusWidget());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::focusWidget(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  topLevelAt
- *    flags:    s
+/*!
+ * method topLevelAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &ps0
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, topLevelAt){
-		/* l public*/
 
-		/* const QPoint& p,  */
+ZEND_METHOD(QApplication, topLevelAt)
+{
+  ///const QPoint &ps0
+#ifdef PHP_QT_QWidget           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QPoint &ps0,
+        QApplication *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QPoint *cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj->topLevelAt((const QPoint&) Z_LVAL_P(z_0));
-			} else {
-				*return_object = (QWidget *) QApplication::topLevelAt((const QPoint&) Z_LVAL_P(z_0));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        if (getThis() == NULL) {
+          le.ptr = static_cast < QWidget * >(QApplication::topLevelAt((const QPoint &)*cpp_arg_0));
+        } else {
+          le.ptr = static_cast < QWidget * >(selfpointer->topLevelAt((const QPoint &)*cpp_arg_0));
+        } php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///int x, int y
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try int x, int y,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QWidget * >(QApplication::topLevelAt((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } else {
+        le.ptr = static_cast < QWidget * >(selfpointer->topLevelAt((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::topLevelAt(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  cursorFlashTime
- *    flags:    s
+/*!
+ * method cursorFlashTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, cursorFlashTime){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj->cursorFlashTime());
-	}
+
+ZEND_METHOD(QApplication, cursorFlashTime)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::cursorFlashTime());
+      } else {
+        RETURN_LONG(selfpointer->cursorFlashTime());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::cursorFlashTime(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  startDragDistance
- *    flags:    s
+/*!
+ * method startDragDistance
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, startDragDistance){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj->startDragDistance());
-	}
+
+ZEND_METHOD(QApplication, startDragDistance)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::startDragDistance());
+      } else {
+        RETURN_LONG(selfpointer->startDragDistance());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::startDragDistance(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  closeAllWindows
- *    flags:    sl
+/*!
+ * method closeAllWindows
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	sl
  */
-ZEND_METHOD(QApplication, closeAllWindows){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj->closeAllWindows();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, closeAllWindows)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::closeAllWindows());
+      } else {
+        RETURN_VOID(selfpointer->closeAllWindows());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::closeAllWindows(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setFont
- *    flags:    s
+/*!
+ * method setFont
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &s0
+ * @param	 const char * className = 0s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setFont){
-//const QFont&
-		/* os public*/
 
-		/* const QFont& , const char* className,  */
+ZEND_METHOD(QApplication, setFont)
+{
+  ///const QFont &s0, const char * className = 0s1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        /// try const QFont &s0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_STRING){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QFont *cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setFont((const QFont &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->setFont((const QFont &)*cpp_arg_0));
+      }}
+#endif
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QFont")) {
-				obj->setFont((const QFont&) *obj_z_0, (const char*) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_STRING) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        /// try const QFont &s0, const char * className = 0s1,
+        QApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QFont *cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setFont((const QFont &)*cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0]));
+        } else {
+          RETURN_VOID(selfpointer->setFont((const QFont &)*cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0]));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setFont(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  notify
- *    flags:    
+/*!
+ * method notify
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * @param	 QEvent *s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QApplication, notify){
-//qt_QObject*
-//qt_QEvent*
-		/* oo public*/
 
-		/* qt_QObject* , qt_QEvent* ,  */
+ZEND_METHOD(QApplication, notify)
+{
+  ///QObject *s0, QEvent *s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 46) && inherits(Z_OBJCE_P(arg_1), 21)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'notify' is not static");
+          RETURN_NULL();
+        }
+        /// try QObject *s0, QEvent *s1,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QObject *cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+        QEvent *cpp_arg_1 = static_cast < QEvent * >(php_qt_fetch(arg_1));
 
+        RETURN_BOOL(selfpointer->notify((QObject *) cpp_arg_0, (QEvent *) cpp_arg_1));
+      }
+#endif
 
-			if(obj_z_0->inherits("QObject") && !strcmp(Z_OBJCE_P(z_1)->name,"QEvent")) {
-				RETURN_BOOL(obj->notify((QObject*) obj_z_0, (QEvent*) obj_z_1));
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::notify(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setStartDragTime
- *    flags:    s
+/*!
+ * method setStartDragTime
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int mss0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setStartDragTime){
-		/* l public*/
 
-		/* int ms,  */
+ZEND_METHOD(QApplication, setStartDragTime)
+{
+  ///int mss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int mss0,
+      QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setStartDragTime((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->setStartDragTime((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setStartDragTime(...) ");
+}
 
+/*!
+ * method activePopupWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
+ */
 
-			obj->setStartDragTime((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
-}
+ZEND_METHOD(QApplication, activePopupWidget)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
 
-/*********************************
- *    class     QApplication
- *    function  activePopupWidget
- *    flags:    s
- */
-ZEND_METHOD(QApplication, activePopupWidget){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj->activePopupWidget();
-			} else {
-				*return_object = (QWidget *) QApplication::activePopupWidget();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QWidget * >(QApplication::activePopupWidget());
+      } else {
+        le.ptr = static_cast < QWidget * >(selfpointer->activePopupWidget());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::activePopupWidget(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setInputContext
- *    flags:    
+/*!
+ * method setInputContext
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QInputContext *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QApplication, setInputContext){
-//QInputContext*
-		/* o public*/
 
-		/* QInputContext* ,  */
+ZEND_METHOD(QApplication, setInputContext)
+{
+  ///QInputContext *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QInputContext
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setInputContext' is not static");
+          RETURN_NULL();
+        }
+        /// try QInputContext *s0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+        }
+        QInputContext *cpp_arg_0 = static_cast < QInputContext * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setInputContext((QInputContext *) cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0->inherits("QInputContext")) {
-				obj->setInputContext((QInputContext*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setInputContext(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  setQuitOnLastWindowClosed
- *    flags:    s
+/*!
+ * method compressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * @param	 QObject *receivers1
+ * @param	 QPostEventList *s2
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QApplication, setQuitOnLastWindowClosed){
-		/* l public*/
 
-		/* int quit,  */
+/*!
+ * method setQuitOnLastWindowClosed
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool quits0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+ZEND_METHOD(QApplication, setQuitOnLastWindowClosed)
+{
+  ///bool quits0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      /// try bool quits0,
+      QApplication *selfpointer;
 
-
-			obj->setQuitOnLastWindowClosed((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setQuitOnLastWindowClosed((bool) Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->setQuitOnLastWindowClosed((bool) Z_LVAL_P(arg_0)));
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QApplication::setQuitOnLastWindowClosed(...) ");
 }
 
-/*********************************
- *    class     QApplication
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QApplication, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QApplication, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QApplication::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QApplication::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QApplication *selfpointer;
 
-PHP_QT_DESTRUCT(QApplication);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QApplication::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QApplication::trUtf8(...) ");
+}
+
+/*!
+ * method saveState
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QSessionManager & sms0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	v
+ */

Modified: trunk/qt/classes/qboxlayout.cpp
===================================================================
--- trunk/qt/classes/qboxlayout.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qboxlayout.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,859 +19,1533 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QBoxLayout.cpp - QBoxLayout PHP implementation.
- * begin           : Thu Feb 23 16:39:38 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
+
 #include "../php_qt.h"
 
 
 #include <QBoxLayout>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QBoxLayout_php_qt:public QBoxLayout
+{
 
+public:
+  QBoxLayout_php_qt(zval * zend_ptr, Direction s0, QWidget * parent = 0);
 
-/*		public enumDirection:long {
-			Direction = 0,
-			Direction = 1,
-			Direction = 2,
-			Direction = 3,
-			Down = TopToBottom,
-			Up = BottomToTop
-		}
-*/
-/*********************************
- *    class     QBoxLayout
- *    function  tr
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+
+QBoxLayout_php_qt::QBoxLayout_php_qt(zval * zend_ptr, Direction s0, QWidget * parent):QBoxLayout(s0, parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QBoxLayout",&staticMetaObject));
+}
+
+PHP_QT_MOC(QBoxLayout);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QBoxLayout, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QBoxLayout, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QBoxLayout *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QBoxLayout::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-/*********************************
- *    class     QBoxLayout
- *    function  addLayout
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QLayout *layout, int stretch = 0
- */
-ZEND_METHOD(QBoxLayout, addLayout){
-//qt_QLayout*
-		/* ol public*/
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QBoxLayout::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QBoxLayout *
+        selfpointer;
 
-		/* qt_QLayout* layout, int stretch,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QBoxLayout::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			if(obj_z_0->inherits("QLayout")) {
-				obj->addLayout((QLayout*) obj_z_0, (int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::tr(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  setStretchFactor
- *    flags:    
- *    access:    public
- *    return:    bool
- *    params:    QWidget *w, int stretch
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QBoxLayout, setStretchFactor){
-//qt_QWidget*
-		/* ol public*/
 
-		/* qt_QWidget* w, int stretch,  */
+/*!
+ * method setDirection
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Direction Directions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-
-
-			if(obj_z_0->inherits("QWidget")) {
-				RETURN_BOOL(obj->setStretchFactor((QWidget*) obj_z_0, (int) Z_LVAL_P(z_1)));
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+ZEND_METHOD(QBoxLayout, setDirection)
+{
+// notice: unknown argument Direction Directions0, skipped
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::setDirection(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  setDirection
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    Direction
+/*!
+ * method addItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, setDirection){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QBoxLayout, addItem)
+{
+  ///QLayoutItem *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addItem' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayoutItem *s0,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QLayoutItem *
+          cpp_arg_0 = static_cast < QLayoutItem * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->addItem((QLayoutItem *) cpp_arg_0));
+      }
+#endif
 
-			obj->setDirection((QBoxLayout::Direction) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::addItem(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  addItem
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QLayoutItem *
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QBoxLayout, addItem){
-//qt_QLayoutItem*
-		/* o public*/
 
-		/* qt_QLayoutItem* ,  */
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method count
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QBoxLayout, count)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'count' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
 
-			if(obj_z_0->inherits("QLayoutItem")) {
-				obj->addItem((QLayoutItem*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->count());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::count(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  insertSpacing
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int index, int size
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QBoxLayout, insertSpacing){
-		/* ll public*/
 
-		/* int index, int size,  */
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
+ */
 
+ZEND_METHOD(QBoxLayout, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-			obj->insertSpacing((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QBoxLayout::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  count
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method itemAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	c
  */
-ZEND_METHOD(QBoxLayout, count){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			RETURN_LONG(obj->count());
-	}
+
+ZEND_METHOD(QBoxLayout, itemAt)
+{
+// notice: abstract class QLayoutItem cannot be instanciated, skipped
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::itemAt(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  invalidate
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    
+/*!
+ * method direction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Direction
+ * @flags	c
  */
-ZEND_METHOD(QBoxLayout, invalidate){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			obj->invalidate();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QBoxLayout, direction)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type Direction");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::direction(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  setGeometry
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    const QRect&
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, setGeometry){
-//const QRect&
-		/* o public*/
 
-		/* const QRect& ,  */
+/*!
+ * method heightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QBoxLayout, heightForWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'heightForWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QBoxLayout *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->heightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::heightForWidth(...) ");
+}
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QRect")) {
-				obj->setGeometry((const QRect&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+/*!
+ * method addSpacing
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int sizes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QBoxLayout, addSpacing)
+{
+  ///int sizes0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addSpacing' is not static");
+        RETURN_NULL();
+      }
+      /// try int sizes0,
+      QBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->addSpacing((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::addSpacing(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  addWidget
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QWidget *, int stretch = 0, Qt::Alignment alignment = 0
+/*!
+ * method hasHeightForWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QBoxLayout, addWidget){
-//qt_QWidget*
-		/* oll public*/
 
-		/* qt_QWidget* , int stretch, int alignment,  */
+ZEND_METHOD(QBoxLayout, hasHeightForWidth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hasHeightForWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->hasHeightForWidth());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::hasHeightForWidth(...) ");
+}
 
+/*!
+ * method addStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int stretch = 0s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			if(obj_z_0->inherits("QWidget")) {
-				obj->addWidget((QWidget*) obj_z_0, (int) Z_LVAL_P(z_1), (Qt::Alignment) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
-    if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
+ZEND_METHOD(QBoxLayout, addStretch)
+{
+  ///int stretch = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addStretch' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
 
-			    QBoxLayout *obj = static_cast<QBoxLayout*>(PHP_QT_FETCH());
-			    QWidget* obj_z_0 = static_cast<QWidget*>(php_qt_fetch(z_0));
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->addStretch());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addStretch' is not static");
+        RETURN_NULL();
+      }
+      /// try int stretch = 0s0,
+      QBoxLayout *
+        selfpointer;
 
-//			if(obj_z_0->inherits("QWidget")) {
-				obj->addWidget(obj_z_0);
-			    RETURN_NULL();
-//			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->addStretch((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::addStretch(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  addStrut
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method insertLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0
+ * @param	 QLayout *layouts1
+ * @param	 int stretch = 0s2
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, addStrut){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QBoxLayout, insertLayout)
+{
+  ///int indexs0, QLayout *layouts1, int stretch = 0s2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_1), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'insertLayout' is not static");
+          RETURN_NULL();
+        }
+        /// try int indexs0, QLayout *layouts1,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_1 = static_cast < QLayout * >(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer->insertLayout((int)Z_LVAL_P(arg_0), (QLayout *) cpp_arg_1));
+      }
+#endif
 
-			obj->addStrut((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_1), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'insertLayout' is not static");
+          RETURN_NULL();
+        }
+        /// try int indexs0, QLayout *layouts1, int stretch = 0s2,
+        QBoxLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_1 = static_cast < QLayout * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->insertLayout((int)Z_LVAL_P(arg_0), (QLayout *) cpp_arg_1, (int)Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::insertLayout(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  takeAt
- *    flags:    
- *    access:    public
- *    return:    QLayoutItem *
- *    params:    int
+/*!
+ * method minimumHeightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QBoxLayout, takeAt){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QBoxLayout, minimumHeightForWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumHeightForWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QBoxLayout *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->minimumHeightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::minimumHeightForWidth(...) ");
+}
 
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-			QLayoutItem ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QLayoutItem *) obj->takeAt((int) Z_LVAL_P(z_0));
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	c
+ */
+
+ZEND_METHOD(QBoxLayout, expandingDirections)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'expandingDirections' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->expandingDirections());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::expandingDirections(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  staticMetaObject
- *    flags:    s
- *    access:    public
- *    return:    QMetaObject*
- *    params:    
+/*!
+ * method addLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayout *layouts0
+ * @param	 int stretch = 0s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, staticMetaObject){
+
+ZEND_METHOD(QBoxLayout, addLayout)
+{
+  ///QLayout *layouts0, int stretch = 0s1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addLayout' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayout *layouts0,
+        QBoxLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast < QLayout * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->addLayout((QLayout *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addLayout' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayout *layouts0, int stretch = 0s1,
+        QBoxLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast < QLayout * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->addLayout((QLayout *) cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::addLayout(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  itemAt
- *    flags:    c
- *    access:    public
- *    return:    QLayoutItem *
- *    params:    int
+/*!
+ * method setStretchFactor
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * @param	 int stretchs1
+ * 
+ * overloaded args:
+ * @param	QLayout *l
+ * @param	 int stretch
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, itemAt){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QBoxLayout, setStretchFactor)
+{
+  ///QWidget *ws0, int stretchs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setStretchFactor' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0, int stretchs1,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
+        RETURN_BOOL(selfpointer->setStretchFactor((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			QLayoutItem ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QLayoutItem *) obj->itemAt((int) Z_LVAL_P(z_0));
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  ///QLayout *l, int stretch
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setStretchFactor' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayout *l, int stretch,
+        QBoxLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast < QLayout * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->setStretchFactor((QLayout *) cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::setStretchFactor(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  direction
- *    flags:    c
- *    access:    public
- *    return:    Direction
- *    params:    
+/*!
+ * method insertSpacing
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0
+ * @param	 int sizes1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, direction){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			RETURN_LONG(obj->direction());
-	}
-}
 
-/*********************************
- *    class     QBoxLayout
- *    function  qObject
- *    flags:    
- *    access:    public
- *    return:    QObject*
- *    params:    
- */
-ZEND_METHOD(QBoxLayout, qObject){
+ZEND_METHOD(QBoxLayout, insertSpacing)
+{
+  ///int indexs0, int sizes1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'insertSpacing' is not static");
+        RETURN_NULL();
+      }
+      /// try int indexs0, int sizes1,
+      QBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->insertSpacing((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::insertSpacing(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  minimumSize
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method invalidate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, minimumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->minimumSize();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QBoxLayout
- *    function  sizeHint
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
- */
-ZEND_METHOD(QBoxLayout, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->sizeHint();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QBoxLayout, invalidate)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'invalidate' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->invalidate());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::invalidate(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  heightForWidth
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    int
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, heightForWidth){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QBoxLayout, setGeometry)
+{
+  ///const QRect &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setGeometry' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &s0,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setGeometry((const QRect &)*cpp_arg_0));
+      }
+#endif
 
-			RETURN_LONG(obj->heightForWidth((int) Z_LVAL_P(z_0)));
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::setGeometry(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  addSpacing
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int size
+/*!
+ * method takeAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, addSpacing){
-		/* l public*/
 
-		/* int size,  */
+ZEND_METHOD(QBoxLayout, takeAt)
+{
+// notice: abstract class QLayoutItem cannot be instanciated, skipped
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::takeAt(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+/*!
+ * method addStrut
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QBoxLayout, addStrut)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addStrut' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QBoxLayout *
+        selfpointer;
 
-			obj->addSpacing((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->addStrut((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::addStrut(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  addStretch
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int stretch = 0
+/*!
+ * method addWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * @param	 int stretch = 0s1
+ * @param	 Qt::Alignment alignment = 0s2
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, addStretch){
-		/* l public*/
 
-		/* int stretch,  */
+ZEND_METHOD(QBoxLayout, addWidget)
+{
+  ///QWidget *s0, int stretch = 0s1, Qt::Alignment alignment = 0s2
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *s0,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->addWidget((QWidget *) cpp_arg_0));
+      }
+#endif
 
-			obj->addStretch((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
-}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *s0, int stretch = 0s1,
+        QBoxLayout *
+          selfpointer;
 
-/*********************************
- *    class     QBoxLayout
- *    function  hasHeightForWidth
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
- */
-ZEND_METHOD(QBoxLayout, hasHeightForWidth){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->hasHeightForWidth());
-	}
-}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
-/*********************************
- *    class     QBoxLayout
- *    function  QBoxLayout
- *    flags:    t
- *    access:    public
- *    return:    
- *    params:    Direction, QWidget *parent = 0
- */
-ZEND_METHOD(QBoxLayout, __construct){
-//qt_QWidget*
-		/* lo public*/
+        RETURN_VOID(selfpointer->addWidget((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-		/* int , qt_QWidget* parent,  */
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *s0, int stretch = 0s1, Qt::Alignment alignment = 0s2,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->addWidget((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::Alignment) Z_LVAL_P(arg_2)));
+      }
+#endif
 
-			if(obj_z_1->inherits("QWidget")) {
-				QBoxLayout *QBoxLayout_ptr = new QBoxLayout((QBoxLayout::Direction) Z_LVAL_P(z_0), (QWidget*) obj_z_1);
-				PHP_QT_REGISTER(QBoxLayout_ptr);
-				RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::addWidget(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  insertStretch
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int index, int stretch = 0
+/*!
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QBoxLayout, insertStretch){
-		/* ll public*/
 
-		/* int index, int stretch,  */
+ZEND_METHOD(QBoxLayout, minimumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj->insertStretch((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->minimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::minimumSize(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  insertWidget
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int index, QWidget *widget, int stretch = 0, Qt::Alignment alignment = 0
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QBoxLayout, insertWidget){
-//qt_QWidget*
-		/* loll public*/
 
-		/* int index, qt_QWidget* widget, int stretch, int alignment,  */
+ZEND_METHOD(QBoxLayout, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			if(obj_z_1->inherits("QWidget")) {
-				obj->insertWidget((int) Z_LVAL_P(z_0), (QWidget*) obj_z_1, (int) Z_LVAL_P(z_2), (Qt::Alignment) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::sizeHint(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  insertLayout
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int index, QLayout *layout, int stretch = 0
+/*!
+ * method insertWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0
+ * @param	 QWidget *widgets1
+ * @param	 int stretch = 0s2
+ * @param	 Qt::Alignment alignment = 0s3
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, insertLayout){
-//qt_QLayout*
-		/* lol public*/
 
-		/* int index, qt_QLayout* layout, int stretch,  */
+ZEND_METHOD(QBoxLayout, insertWidget)
+{
+  ///int indexs0, QWidget *widgets1, int stretch = 0s2, Qt::Alignment alignment = 0s3
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_1), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'insertWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try int indexs0, QWidget *widgets1,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer->insertWidget((int)Z_LVAL_P(arg_0), (QWidget *) cpp_arg_1));
+      }
+#endif
 
-			if(obj_z_1->inherits("QLayout")) {
-				obj->insertLayout((int) Z_LVAL_P(z_0), (QLayout*) obj_z_1, (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_1), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'insertWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try int indexs0, QWidget *widgets1, int stretch = 0s2,
+        QBoxLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->insertWidget((int)Z_LVAL_P(arg_0), (QWidget *) cpp_arg_1, (int)Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_1), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'insertWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try int indexs0, QWidget *widgets1, int stretch = 0s2, Qt::Alignment alignment = 0s3,
+        QBoxLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->insertWidget((int)Z_LVAL_P(arg_0), (QWidget *) cpp_arg_1, (int)Z_LVAL_P(arg_2), (Qt::Alignment) Z_LVAL_P(arg_3)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::insertWidget(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  trUtf8
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+/*!
+ * method insertStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0
+ * @param	 int stretch = 0s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QBoxLayout, insertStretch)
+{
+  ///int indexs0, int stretch = 0s1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'insertStretch' is not static");
+        RETURN_NULL();
+      }
+      /// try int indexs0,
+      QBoxLayout *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->insertStretch((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'insertStretch' is not static");
+        RETURN_NULL();
+      }
+      /// try int indexs0, int stretch = 0s1,
+      QBoxLayout *
+        selfpointer;
 
-
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QBoxLayout::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->insertStretch((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::insertStretch(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  maximumSize
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method QBoxLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Direction s0s0
+ * @param	 QWidget *parent = 0s1
+ * 
+ * overloaded args:
+ * @param	const QBoxLayout &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QBoxLayout, maximumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->maximumSize();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QBoxLayout, __construct)
+{
+// notice: unknown argument Direction s0s0, skipped
+
+  ///const QBoxLayout &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QBoxLayout
+      if (inherits(Z_OBJCE_P(arg_0), 5)) {
+/// method is private, skip
+        php_error(E_ERROR, "QBoxLayout::__construct(...) cannot be called with 'const QBoxLayout &,'.");
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::QBoxLayout(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  minimumHeightForWidth
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    int
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QBoxLayout, minimumHeightForWidth){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QBoxLayout, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QBoxLayout *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			RETURN_LONG(obj->minimumHeightForWidth((int) Z_LVAL_P(z_0)));
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QBoxLayout::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QBoxLayout::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::trUtf8(...) ");
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  insertItem
- *    flags:    
- *    access:    protected
- *    return:    void
- *    params:    int index, QLayoutItem *
+/*!
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-// method insertItem is protected, skipped.
 
-/*********************************
- *    class     QBoxLayout
- *    function  expandingDirections
- *    flags:    c
- *    access:    public
- *    return:    Qt::Orientations
- *    params:    
- */
-ZEND_METHOD(QBoxLayout, expandingDirections){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			obj->expandingDirections();
-			RETURN_NULL();
-	}
-}
+ZEND_METHOD(QBoxLayout, maximumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'maximumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
 
-PHP_QT_DESTRUCT(QBoxLayout);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->maximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QBoxLayout::maximumSize(...) ");
+}
+
+/*!
+ * method insertItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0
+ * @param	 QLayoutItem *s1
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */

Modified: trunk/qt/classes/qchar.cpp
===================================================================
--- trunk/qt/classes/qchar.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qchar.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,746 +19,1399 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QChar.cpp - QChar PHP implementation.
- * begin           : Sun Jan 22 20:52:15 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QChar>
 #include "../php_qt.h"
 
 
+#include <QChar>
+#include <QMetaMethod>
+class QChar_php_qt:public QChar
+{
 
-/*		public enumSpecialCharacter:long {
-			Null = 0x0000,
-			Nbsp = 0x00a0,
-			ReplacementCharacter = 0xfffd,
-			ObjectReplacementCharacter = 0xfffc,
-			ByteOrderMark = 0xfeff,
-			ByteOrderSwapped = 0xfffe,
-			ParagraphSeparator = 0x2029,
-			LineSeparator = 0x2028
-		}
-*/
+public:
+  QChar_php_qt(zval * zend_ptr);
+  QChar_php_qt(zval * zend_ptr, char cs0);
+    QChar_php_qt(zval * zend_ptr, uchar cs0);
+    QChar_php_qt(zval * zend_ptr, QLatin1Char chs0);
+    QChar_php_qt(zval * zend_ptr, uchar cs0, uchar rs1);
+    QChar_php_qt(zval * zend_ptr, ushort rcs0);
+    QChar_php_qt(zval * zend_ptr, short rcs0);
+    QChar_php_qt(zval * zend_ptr, uint rcs0);
+    QChar_php_qt(zval * zend_ptr, int rcs0);
+    QChar_php_qt(zval * zend_ptr, SpecialCharacter scs0);
 
-/*		public enumCategory:long {
-			Category = 0,
-			Category = 1,
-			Category = 2,
-			Category = 3,
-			Category = 4,
-			Category = 5,
-			Category = 6,
-			Category = 7,
-			Category = 8,
-			Category = 9,
-			Category = 10,
-			Category = 11,
-			Category = 12,
-			Category = 13,
-			Category = 14,
-			Category = 15,
-			Category = 16,
-			Category = 17,
-			Category = 18,
-			Category = 19,
-			Category = 20,
-			Category = 21,
-			Category = 22,
-			Category = 23,
-			Category = 24,
-			Category = 25,
-			Category = 26,
-			Category = 27,
-			Category = 28,
-			Category = 29,
-			Category = 30,
-			Punctuation_Dask = Punctuation_Dash
-		}
-*/
 
-/*		public enumDirection:long {
-			Direction = 0,
-			Direction = 1,
-			Direction = 2,
-			Direction = 3,
-			Direction = 4,
-			Direction = 5,
-			Direction = 6,
-			Direction = 7,
-			Direction = 8,
-			Direction = 9,
-			Direction = 10,
-			Direction = 11,
-			Direction = 12,
-			Direction = 13,
-			Direction = 14,
-			Direction = 15,
-			Direction = 16,
-			Direction = 17,
-			Direction = 18
-		}
-*/
+  zval *zend_ptr;
+};
 
-/*		public enumDecomposition:long {
-			Decomposition = 0,
-			Decomposition = 1,
-			Decomposition = 2,
-			Decomposition = 3,
-			Decomposition = 4,
-			Decomposition = 5,
-			Decomposition = 6,
-			Decomposition = 7,
-			Decomposition = 8,
-			Decomposition = 9,
-			Decomposition = 10,
-			Decomposition = 11,
-			Decomposition = 12,
-			Decomposition = 13,
-			Decomposition = 14,
-			Decomposition = 15,
-			Decomposition = 16,
-			Decomposition = 17
-		}
-*/
+QChar_php_qt::QChar_php_qt(zval * zend_ptr):QChar()
+{
+  this->zend_ptr = zend_ptr;
+}
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, char cs0):
+QChar(cs0)
+{
+  this->zend_ptr = zend_ptr;
+}
 
-/*		public enumJoining:long {
-			Joining = 0,
-			Joining = 1,
-			Joining = 2,
-			Joining = 3
-		}
-*/
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, uchar cs0):QChar(cs0)
+{
+  this->zend_ptr = zend_ptr;
+}
 
-/*		public enumCombiningClass:long {
-			Combining_BelowLeftAttached = 200,
-			Combining_BelowAttached = 202,
-			Combining_BelowRightAttached = 204,
-			Combining_LeftAttached = 208,
-			Combining_RightAttached = 210,
-			Combining_AboveLeftAttached = 212,
-			Combining_AboveAttached = 214,
-			Combining_AboveRightAttached = 216,
-			Combining_BelowLeft = 218,
-			Combining_Below = 220,
-			Combining_BelowRight = 222,
-			Combining_Left = 224,
-			Combining_Right = 226,
-			Combining_AboveLeft = 228,
-			Combining_Above = 230,
-			Combining_AboveRight = 232,
-			Combining_DoubleBelow = 233,
-			Combining_DoubleAbove = 234,
-			Combining_IotaSubscript = 240
-		}
-*/
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, QLatin1Char chs0):QChar(chs0)
+{
+  this->zend_ptr = zend_ptr;
+}
 
-/*		public enumUnicodeVersion:long {
-			UnicodeVersion = 0,
-			UnicodeVersion = 1,
-			UnicodeVersion = 2,
-			UnicodeVersion = 3,
-			UnicodeVersion = 4,
-			UnicodeVersion = 5,
-			UnicodeVersion = 6,
-			UnicodeVersion = 7
-		}
-*/
-/*********************************
- *    class     QChar */
-/*
- *    function  combiningClass
- *    flags:    c
- */
-ZEND_METHOD(QChar, combiningClass){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj->combiningClass(), 1);
-	}
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, uchar cs0, uchar rs1):QChar(cs0, rs1)
+{
+  this->zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isUpper
- *    flags:    c
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, ushort rcs0):QChar(rcs0)
+{
+  this->zend_ptr = zend_ptr;
+}
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, short rcs0):
+QChar(rcs0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, uint rcs0):QChar(rcs0)
+{
+  this->zend_ptr = zend_ptr;
+}
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, int rcs0):
+QChar(rcs0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, SpecialCharacter scs0):QChar(scs0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method row
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uchar
+ * @flags	c
  */
-ZEND_METHOD(QChar, isUpper){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isUpper());
-	}
+
+ZEND_METHOD(QChar, row)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type uchar");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::row(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  joining
- *    flags:    c
+/*!
+ * method isSymbol
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, joining){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj->joining();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QChar, isSymbol)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isSymbol' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isSymbol());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::isSymbol(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  row
- *    flags:    c
+/*!
+ * method category
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Category
+ * @flags	c
  */
-ZEND_METHOD(QChar, row){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj->row(), 1);
-	}
+
+ZEND_METHOD(QChar, category)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type Category");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::category(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  QChar
- *    flags:    
+/*!
+ * method isPrint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *QChar_ptr = new QChar();
-				PHP_QT_REGISTER(QChar_ptr);
-				RETURN_NULL();
-	}
-		/* l public*/
 
-		/* char c,  */
-		/* o public*/
+ZEND_METHOD(QChar, isPrint)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isPrint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
-		/* QLatin1Char ch,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isPrint());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::isPrint(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
+/*!
+ * method digitValue
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QChar, digitValue)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'digitValue' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
-			QChar *QChar_ptr = new QChar((char) Z_LVAL_P(z_0));
-				PHP_QT_REGISTER(QChar_ptr);
-				RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->digitValue());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::digitValue(...) ");
+}
 
+/*!
+ * method mirroredChar
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)->name == "QLatin1Char") {
-/*				QChar *QChar_ptr = new QChar((QLatin1Char) obj_z_0);
-				PHP_QT_REGISTER(QChar_ptr);
-*/				RETURN_NULL();
-			}
-			if(obj_z_0->inherits("SpecialCharacter")) {
-/*				QChar *QChar_ptr = new QChar((SpecialCharacter) obj_z_0);
-				PHP_QT_REGISTER(QChar_ptr);
-*/				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ll public*/
+ZEND_METHOD(QChar, mirroredChar)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
 
-		/* unsigned char c, unsigned char r,  */
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'mirroredChar' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QChar *
+        return_object = new QChar;
 
-			QChar *QChar_ptr = new QChar((uchar) Z_LVAL_P(z_0) ,(uchar) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QChar_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
-}
+      *return_object = static_cast < QChar > (selfpointer->mirroredChar());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isSymbol
- *    flags:    c
- */
-ZEND_METHOD(QChar, isSymbol){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isSymbol());
-	}
+  php_error(E_ERROR, "could not parse argument in QChar::mirroredChar(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  category
- *    flags:    c
+/*!
+ * method fromAscii
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	char cs0
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	s
  */
-ZEND_METHOD(QChar, category){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj->category();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isPrint
- *    flags:    c
- */
-ZEND_METHOD(QChar, isPrint){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isPrint());
-	}
+ZEND_METHOD(QChar, fromAscii)
+{
+  ///char cs0
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try char cs0,
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QChar *
+        return_object = new QChar;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QChar > (QChar::fromAscii((char)Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QChar > (selfpointer->fromAscii((char)Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QChar::fromAscii(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  digitValue
- *    flags:    c
+/*!
+ * method isSpace
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, digitValue){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_LONG(obj->digitValue());
-	}
-}
 
-/*********************************
- *    class     QChar */
-/*
- *    function  mirroredChar
- *    flags:    c
- */
-ZEND_METHOD(QChar, mirroredChar){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-				QChar return_object = (QChar) obj->mirroredChar();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QChar, isSpace)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isSpace' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isSpace());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::isSpace(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  fromLatin1
- *    flags:    s
+/*!
+ * method decomposition
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QChar, fromLatin1){
-		/* l public*/
 
-		/* char c,  */
+ZEND_METHOD(QChar, decomposition)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'decomposition' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-				QChar return_object = (QChar) obj->fromLatin1((char) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->decomposition());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QChar::decomposition(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  fromAscii
- *    flags:    s
+/*!
+ * method toUpper
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	c
  */
-ZEND_METHOD(QChar, fromAscii){
-		/* l public*/
 
-		/* char c,  */
+ZEND_METHOD(QChar, toUpper)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toUpper' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-				QChar return_object = (QChar) obj->fromAscii((char) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QChar *
+        return_object = new QChar;
+
+      *return_object = static_cast < QChar > (selfpointer->toUpper());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QChar::toUpper(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isSpace
- *    flags:    c
+/*!
+ * method isPunct
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, isSpace){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isSpace());
-	}
+
+ZEND_METHOD(QChar, isPunct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isPunct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isPunct());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::isPunct(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  toLatin1
- *    flags:    c
+/*!
+ * method direction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Direction
+ * @flags	c
  */
-ZEND_METHOD(QChar, toLatin1){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj->toLatin1();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QChar, direction)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type Direction");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::direction(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  toUpper
- *    flags:    c
+/*!
+ * method hasMirrored
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, toUpper){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-				QChar return_object = (QChar) obj->toUpper();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QChar, hasMirrored)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hasMirrored' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->hasMirrored());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::hasMirrored(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  decomposition
- *    flags:    c
+/*!
+ * method setRow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uchar rows0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QChar, decomposition){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->decomposition();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QChar, setRow)
+{
+// notice: unknown argument uchar rows0, skipped
+  php_error(E_ERROR, "could not parse argument in QChar::setRow(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isPunct
- *    flags:    c
+/*!
+ * method isLetter
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, isPunct){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isPunct());
-	}
+
+ZEND_METHOD(QChar, isLetter)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isLetter' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isLetter());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::isLetter(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isDigit
- *    flags:    c
+/*!
+ * method unicodeVersion
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	UnicodeVersion
+ * @flags	c
  */
-ZEND_METHOD(QChar, isDigit){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isDigit());
-	}
+
+ZEND_METHOD(QChar, unicodeVersion)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type UnicodeVersion");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::unicodeVersion(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  decompositionTag
- *    flags:    c
+/*!
+ * method toAscii
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char
+ * @flags	c
  */
-ZEND_METHOD(QChar, decompositionTag){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj->decompositionTag();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QChar, toAscii)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toAscii' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer->toAscii(), 1);
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::toAscii(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isLower
- *    flags:    c
+/*!
+ * method combiningClass
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	unsigned char
+ * @flags	c
  */
-ZEND_METHOD(QChar, isLower){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isLower());
-	}
+
+ZEND_METHOD(QChar, combiningClass)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'combiningClass' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer->combiningClass(), 1);
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::combiningClass(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  direction
- *    flags:    c
+/*!
+ * method isUpper
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, direction){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_LONG(obj->direction());
-	}
+
+ZEND_METHOD(QChar, isUpper)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isUpper' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isUpper());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::isUpper(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  hasMirrored
- *    flags:    c
+/*!
+ * method joining
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Joining
+ * @flags	c
  */
-ZEND_METHOD(QChar, hasMirrored){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->hasMirrored());
-	}
+
+ZEND_METHOD(QChar, joining)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type Joining");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::joining(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  toLower
- *    flags:    c
+/*!
+ * method QChar
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	char cs0
+ * 
+ * overloaded args:
+ * @param	uchar cs0
+ * 
+ * overloaded args:
+ * @param	QLatin1Char chs0
+ * 
+ * overloaded args:
+ * @param	uchar cs0
+ * @param	uchar rs1
+ * 
+ * overloaded args:
+ * @param	ushort rcs0
+ * 
+ * overloaded args:
+ * @param	short rcs0
+ * 
+ * overloaded args:
+ * @param	uint rcs0
+ * 
+ * overloaded args:
+ * @param	int rcs0
+ * 
+ * overloaded args:
+ * @param	SpecialCharacter scs0
+ * 
+ * overloaded args:
+ * @param	char c
+ * 
+ * overloaded args:
+ * @param	uchar c
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QChar, toLower){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-				QChar return_object = (QChar) obj->toLower();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QChar, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar_php_qt *
+        selfpointer = new QChar_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///char cs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try char cs0,
+      QChar_php_qt *
+        selfpointer = new QChar_php_qt(getThis(), (char)Z_STRVAL_P(arg_0)[0]);
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+// notice: unknown argument uchar cs0, skipped
+
+  ///QLatin1Char chs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1Char
+      if (inherits(Z_OBJCE_P(arg_0), 39)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QLatin1Char chs0,
+        QLatin1Char *
+          cpp_arg_0 = static_cast < QLatin1Char * >(php_qt_fetch(arg_0));
+        QChar_php_qt *
+          selfpointer = new QChar_php_qt(getThis(), (QLatin1Char) * cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument uchar cs0, skipped
+
+  ///ushort rcs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try ushort rcs0,
+      QChar_php_qt *
+        selfpointer = new QChar_php_qt(getThis(), (ushort) Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///short rcs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try short rcs0,
+      QChar_php_qt *
+        selfpointer = new QChar_php_qt(getThis(), (short)Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///uint rcs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try uint rcs0,
+      QChar_php_qt *
+        selfpointer = new QChar_php_qt(getThis(), (uint) Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///int rcs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try int rcs0,
+      QChar_php_qt *
+        selfpointer = new QChar_php_qt(getThis(), (int)Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+// notice: unknown argument SpecialCharacter scs0, skipped
+
+  ///char c
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+/// method is private, skip
+      php_error(E_ERROR, "QChar::__construct(...) cannot be called with 'char c,'.");
+    }
+  }
+// notice: unknown argument uchar c, skipped
+  php_error(E_ERROR, "could not parse argument in QChar::QChar(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  unicode
- *    flags:    c
+/*!
+ * method fromLatin1
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	char cs0
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	s
  */
-ZEND_METHOD(QChar, unicode){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj->unicode();
-			RETURN_NULL();
-	}
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-				ushort & return_object = (ushort &) obj->unicode();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QChar, fromLatin1)
+{
+  ///char cs0
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try char cs0,
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QChar *
+        return_object = new QChar;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QChar > (QChar::fromLatin1((char)Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QChar > (selfpointer->fromLatin1((char)Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QChar::fromLatin1(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isLetter
- *    flags:    c
+/*!
+ * method toLatin1
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char
+ * @flags	c
  */
-ZEND_METHOD(QChar, isLetter){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isLetter());
-	}
+
+ZEND_METHOD(QChar, toLatin1)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toLatin1' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer->toLatin1(), 1);
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::toLatin1(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  setRow
- *    flags:    
+/*!
+ * method isDigit
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, setRow){
-		/* l public*/
 
-		/* unsigned char row,  */
+ZEND_METHOD(QChar, isDigit)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isDigit' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isDigit());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::isDigit(...) ");
+}
 
+/*!
+ * method decompositionTag
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Decomposition
+ * @flags	c
+ */
 
-			obj->setRow((uchar) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QChar, decompositionTag)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type Decomposition");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::decompositionTag(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isLetterOrNumber
- *    flags:    c
+/*!
+ * method isLower
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, isLetterOrNumber){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isLetterOrNumber());
-	}
+
+ZEND_METHOD(QChar, isLower)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isLower' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isLower());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::isLower(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  cell
- *    flags:    c
+/*!
+ * method toLower
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	c
  */
-ZEND_METHOD(QChar, cell){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj->cell(), 1);
-	}
+
+ZEND_METHOD(QChar, toLower)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toLower' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QChar *
+        return_object = new QChar;
+
+      *return_object = static_cast < QChar > (selfpointer->toLower());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QChar::toLower(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isNumber
- *    flags:    c
+/*!
+ * method unicode
+ * 
+ * @param: -
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const ushort
+ * @flags	c
  */
-ZEND_METHOD(QChar, isNumber){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isNumber());
-	}
+
+ZEND_METHOD(QChar, unicode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'unicode' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->unicode());
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'unicode' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->unicode());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::unicode(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  setCell
- *    flags:    
+/*!
+ * method cell
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uchar
+ * @flags	c
  */
-ZEND_METHOD(QChar, setCell){
-		/* l public*/
 
-		/* unsigned char cell,  */
+ZEND_METHOD(QChar, cell)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type uchar");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::cell(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
+/*!
+ * method isLetterOrNumber
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
+ZEND_METHOD(QChar, isLetterOrNumber)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isLetterOrNumber' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
-			obj->setCell((uchar) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isLetterOrNumber());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::isLetterOrNumber(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  unicodeVersion
- *    flags:    c
+/*!
+ * method setCell
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uchar cells0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QChar, unicodeVersion){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj->unicodeVersion();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QChar, setCell)
+{
+// notice: unknown argument uchar cells0, skipped
+  php_error(E_ERROR, "could not parse argument in QChar::setCell(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  toAscii
- *    flags:    c
+/*!
+ * method isNumber
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, toAscii){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj->toAscii();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QChar, isNumber)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isNumber' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isNumber());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::isNumber(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isMark
- *    flags:    c
+/*!
+ * method isMark
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, isMark){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isMark());
-	}
+
+ZEND_METHOD(QChar, isMark)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isMark' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isMark());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::isMark(...) ");
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isNull
- *    flags:    c
+/*!
+ * method isNull
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, isNull){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isNull());
-	}
-}
 
+ZEND_METHOD(QChar, isNull)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isNull' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
-PHP_QT_DESTRUCT(QChar);
-
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isNull());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QChar::isNull(...) ");
+}

Modified: trunk/qt/classes/qcharref.cpp
===================================================================
--- trunk/qt/classes/qcharref.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qcharref.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,432 +19,767 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QCharRef.cpp - QCharRef PHP implementation.
- * begin           : Sun Jan 22 20:52:15 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QCharRef>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isDigit
- *    flags:    c
+#include <QCharRef>
+/*!
+ * method row
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uchar
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isDigit){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isDigit());
-	}
+
+ZEND_METHOD(QCharRef, row)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type uchar");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::row(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  combiningClass
- *    flags:    c
+/*!
+ * method category
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar::Category
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, combiningClass){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj->combiningClass(), 1);
-	}
+
+ZEND_METHOD(QCharRef, category)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::category(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::category(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  decompositionTag
- *    flags:    c
+/*!
+ * method digitValue
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, decompositionTag){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_LONG(obj->decompositionTag());
-	}
+
+ZEND_METHOD(QCharRef, digitValue)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::digitValue(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::digitValue(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  joining
- *    flags:    c
+/*!
+ * method isPrint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, joining){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_LONG(obj->joining());
-	}
+
+ZEND_METHOD(QCharRef, isPrint)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::isPrint(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::isPrint(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  direction
- *    flags:    c
+/*!
+ * method mirroredChar
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, direction){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_LONG(obj->direction());
-	}
+
+ZEND_METHOD(QCharRef, mirroredChar)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::mirroredChar(...) cannot be called with ''.");
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCharRef::mirroredChar(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  hasMirrored
- *    flags:    c
+/*!
+ * method isSpace
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, hasMirrored){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->hasMirrored());
-	}
+
+ZEND_METHOD(QCharRef, isSpace)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::isSpace(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::isSpace(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  toLower
- *    flags:    c
+/*!
+ * method decomposition
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, toLower){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-				QChar return_object = (QChar) obj->toLower();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCharRef_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCharRef, decomposition)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::decomposition(...) cannot be called with ''.");
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCharRef::decomposition(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  unicode
- *    flags:    c
+/*!
+ * method toUpper
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, unicode){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			obj->unicode();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QCharRef, toUpper)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::toUpper(...) cannot be called with ''.");
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCharRef::toUpper(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  row
- *    flags:    c
+/*!
+ * method isPunct
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, row){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj->row(), 1);
-	}
+
+ZEND_METHOD(QCharRef, isPunct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::isPunct(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::isPunct(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  setRow
- *    flags:    
+/*!
+ * method direction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar::Direction
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, setRow){
-		/* l public*/
 
-		/* unsigned char row,  */
+ZEND_METHOD(QCharRef, direction)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::direction(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::direction(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
+/*!
+ * method hasMirrored
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-
-			obj->setRow((uchar) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QCharRef, hasMirrored)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::hasMirrored(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::hasMirrored(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  category
- *    flags:    c
+/*!
+ * method setRow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uchar rows0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QCharRef, category){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_LONG(obj->category());
-	}
+
+ZEND_METHOD(QCharRef, setRow)
+{
+// notice: unknown argument uchar rows0, skipped
+  php_error(E_ERROR, "could not parse argument in QCharRef::setRow(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isLetter
- *    flags:    c
+/*!
+ * method isLetter
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isLetter){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isLetter());
-	}
+
+ZEND_METHOD(QCharRef, isLetter)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::isLetter(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::isLetter(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  cell
- *    flags:    c
+/*!
+ * method unicodeVersion
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar::UnicodeVersion
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, cell){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj->cell(), 1);
-	}
+
+ZEND_METHOD(QCharRef, unicodeVersion)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::unicodeVersion(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::unicodeVersion(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  digitValue
- *    flags:    c
+/*!
+ * method toAscii
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, digitValue){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_LONG(obj->digitValue());
-	}
+
+ZEND_METHOD(QCharRef, toAscii)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::toAscii(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::toAscii(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isPrint
- *    flags:    c
+/*!
+ * method combiningClass
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uchar
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isPrint){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isPrint());
-	}
+
+ZEND_METHOD(QCharRef, combiningClass)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type uchar");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::combiningClass(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isLetterOrNumber
- *    flags:    
+/*!
+ * method joining
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar::Joining
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isLetterOrNumber){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isLetterOrNumber());
-	}
+
+ZEND_METHOD(QCharRef, joining)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::joining(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::joining(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  mirroredChar
- *    flags:    c
+/*!
+ * method toLatin1
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, mirroredChar){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-				QChar return_object = (QChar) obj->mirroredChar();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCharRef_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCharRef, toLatin1)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::toLatin1(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::toLatin1(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  setCell
- *    flags:    
+/*!
+ * method QCharRef
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QString &strs0
+ * @param	 int idxs1
+ * 
+ * @access	private
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QCharRef, setCell){
-		/* l public*/
 
-		/* unsigned char cell,  */
+ZEND_METHOD(QCharRef, __construct)
+{
+  ///QString &strs0, int idxs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+/// method is private, skip
+        php_error(E_ERROR, "QCharRef::__construct(...) cannot be called with 'QString &strs0, int idxs1,'.");
+      }
+#endif
 
-
-			obj->setCell((uchar) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::QCharRef(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isNumber
- *    flags:    c
+/*!
+ * method operator QChar
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isNumber){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isNumber());
-	}
-}
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  unicodeVersion
- *    flags:    c
+/*!
+ * method isDigit
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, unicodeVersion){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_LONG(obj->unicodeVersion());
-	}
+
+ZEND_METHOD(QCharRef, isDigit)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::isDigit(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::isDigit(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isSpace
- *    flags:    c
+/*!
+ * method decompositionTag
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar::Decomposition
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isSpace){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isSpace());
-	}
+
+ZEND_METHOD(QCharRef, decompositionTag)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::decompositionTag(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::decompositionTag(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  toLatin1
- *    flags:    c
+/*!
+ * method toLower
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, toLatin1){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			obj->toLatin1();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QCharRef, toLower)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::toLower(...) cannot be called with ''.");
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCharRef::toLower(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  toAscii
- *    flags:    c
+/*!
+ * method unicode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const ushort
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, toAscii){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			obj->toAscii();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QCharRef, unicode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::unicode(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::unicode(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  decomposition
- *    flags:    c
+/*!
+ * method cell
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uchar
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, decomposition){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->decomposition();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCharRef_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCharRef, cell)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type uchar");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::cell(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  toUpper
- *    flags:    c
+/*!
+ * method isLetterOrNumber
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QCharRef, toUpper){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-				QChar return_object = (QChar) obj->toUpper();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCharRef_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCharRef, isLetterOrNumber)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::isLetterOrNumber(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::isLetterOrNumber(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isMark
- *    flags:    c
+/*!
+ * method setCell
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uchar cells0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QCharRef, isMark){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isMark());
-	}
+
+ZEND_METHOD(QCharRef, setCell)
+{
+// notice: unknown argument uchar cells0, skipped
+  php_error(E_ERROR, "could not parse argument in QCharRef::setCell(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isPunct
- *    flags:    c
+/*!
+ * method isNumber
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isPunct){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isPunct());
-	}
+
+ZEND_METHOD(QCharRef, isNumber)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::isNumber(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::isNumber(...) ");
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isNull
- *    flags:    c
+/*!
+ * method isMark
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isNull){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isNull());
-	}
+
+ZEND_METHOD(QCharRef, isMark)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::isMark(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::isMark(...) ");
 }
 
+/*!
+ * method isNull
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QCharRef);
+ZEND_METHOD(QCharRef, isNull)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCharRef::isNull(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCharRef::isNull(...) ");
+}
 
+/*!
+ * method operator=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QChar &cs0
+ * 
+ * overloaded args:
+ * @param	char c
+ * 
+ * overloaded args:
+ * @param	uchar c
+ * 
+ * overloaded args:
+ * @param	const QCharRef &c
+ * 
+ * overloaded args:
+ * @param	ushort rc
+ * 
+ * overloaded args:
+ * @param	short rc
+ * 
+ * overloaded args:
+ * @param	uint rc
+ * 
+ * overloaded args:
+ * @param	int rc
+ * 
+ * @access	public
+ * @return	QCharRef &
+ * @flags	
+ */

Modified: trunk/qt/classes/qchildevent.cpp
===================================================================
--- trunk/qt/classes/qchildevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qchildevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QChildEvent.cpp - QChildEvent PHP implementation.
- * begin           : Tue Apr 11 10:33:13 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -31,107 +30,188 @@
 
 
 #include <QChildEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QChildEvent_php_qt:public QChildEvent
+{
 
+public:
+  QChildEvent_php_qt(zval * zend_ptr, Type types0, QObject * childs1);
+
+
+  zval *zend_ptr;
+};
+
+QChildEvent_php_qt::QChildEvent_php_qt(zval * zend_ptr, Type types0, QObject * childs1):QChildEvent(types0, childs1)
+{
+  this->zend_ptr = zend_ptr;
+}
+
 /*!
- *    @class     QChildEvent
- *    @function  polished
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method polished
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QChildEvent, polished)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'polished' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChildEvent *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QChildEvent *obj = (QChildEvent *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->polished());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChildEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->polished());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QChildEvent::polished(...) ");
 }
 
 /*!
- *    @class     QChildEvent
- *    @function  removed
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method added
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChildEvent, removed)
+
+ZEND_METHOD(QChildEvent, added)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'added' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChildEvent *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QChildEvent *obj = (QChildEvent *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->removed());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChildEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->added());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QChildEvent::added(...) ");
 }
 
 /*!
- *    @class     QChildEvent
- *    @function  added
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method child
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject *
+ * @flags	c
  */
-ZEND_METHOD(QChildEvent, added)
+
+ZEND_METHOD(QChildEvent, child)
 {
+  ///
+#ifdef PHP_QT_QObject           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'child' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChildEvent *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QChildEvent *obj = (QChildEvent *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChildEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-      RETURN_BOOL(obj->added());
-    }                           /// 5 END getThis(), simple types
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast < QObject * >(selfpointer->child());
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QChildEvent::child(...) ");
 }
 
 /*!
- *    @class     QChildEvent
- *    @function  child
- *
- *    @flags    c
- *    @access    public
- *    @return    QObject *
- *    @param    
+ * method removed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChildEvent, child)
+
+ZEND_METHOD(QChildEvent, removed)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    QObject **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'removed' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QChildEvent *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QChildEvent *obj = (QChildEvent *) PHP_QT_FETCH();
-
-/// return: pointer
-
-/// return value is object: QObject *
-      *return_object = static_cast < QObject * >(obj->child());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QChildEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->removed());
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QChildEvent_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, "could not parse argument in QChildEvent::removed(...) ");
 }
 
+/*!
+ * method QChildEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	QObject *childs1s1
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QChildEvent);
+ZEND_METHOD(QChildEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+  php_error(E_ERROR, "could not parse argument in QChildEvent::QChildEvent(...) ");
+}

Modified: trunk/qt/classes/qclipboardevent.cpp
===================================================================
--- trunk/qt/classes/qclipboardevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qclipboardevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,36 +19,118 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QClipboardEvent.cpp - QClipboardEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QClipboardEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QClipboardEvent */
-/*
- *    function  data
- *    flags:    
+#include <QClipboardEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QClipboardEvent_php_qt:public QClipboardEvent
+{
+
+public:
+  QClipboardEvent_php_qt(zval * zend_ptr, QEventPrivate * datas0);
+
+
+  zval *zend_ptr;
+};
+
+QClipboardEvent_php_qt::QClipboardEvent_php_qt(zval * zend_ptr, QEventPrivate * datas0):QClipboardEvent(datas0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QClipboardEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEventPrivate *datas0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QClipboardEvent, data){
-	if (ZEND_NUM_ARGS() == 0){
-			QClipboardEvent *obj = (QClipboardEvent*) PHP_QT_FETCH();
-				QEventPrivate * return_object = (QEventPrivate *) obj->data();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QClipboardEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QClipboardEvent, __construct)
+{
+  ///QEventPrivate *datas0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QEventPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QEventPrivate *datas0s0,
+        QEventPrivate *
+          cpp_arg_0 = static_cast < QEventPrivate * >(php_qt_fetch(arg_0));
+        QClipboardEvent_php_qt *
+          selfpointer = new QClipboardEvent_php_qt(getThis(), (QEventPrivate *) cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QClipboardEvent::QClipboardEvent(...) ");
 }
 
+/*!
+ * method data
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QEventPrivate *
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QClipboardEvent);
+ZEND_METHOD(QClipboardEvent, data)
+{
+  ///
+#ifdef PHP_QT_QEventPrivate     // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'data' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QClipboardEvent *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QClipboardEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast < QEventPrivate * >(selfpointer->data());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QClipboardEvent::data(...) ");
+}

Modified: trunk/qt/classes/qcloseevent.cpp
===================================================================
--- trunk/qt/classes/qcloseevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qcloseevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,62 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QCloseEvent.cpp - QCloseEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QCloseEvent>
 #include "../php_qt.h"
 
 
+#include <QCloseEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QCloseEvent_php_qt:public QCloseEvent
+{
 
-PHP_QT_DESTRUCT(QCloseEvent);
+public:
+  QCloseEvent_php_qt(zval * zend_ptr);
 
+
+  zval *zend_ptr;
+};
+
+QCloseEvent_php_qt::QCloseEvent_php_qt(zval * zend_ptr):QCloseEvent()
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QCloseEvent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QCloseEvent, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QCloseEvent_php_qt *
+        selfpointer = new QCloseEvent_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCloseEvent::QCloseEvent(...) ");
+}

Modified: trunk/qt/classes/qcontextmenuevent.cpp
===================================================================
--- trunk/qt/classes/qcontextmenuevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qcontextmenuevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,128 +19,306 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QContextMenuEvent.cpp - QContextMenuEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QContextMenuEvent>
 #include "../php_qt.h"
 
 
+#include <QContextMenuEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QContextMenuEvent_php_qt:public QContextMenuEvent
+{
 
-/*		public enumReason:long {
-			Reason = 0,
-			Reason = 0,
-			Reason = 0,
-		}
-*/
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  y
- *    flags:    c
+public:
+  QContextMenuEvent_php_qt(zval * zend_ptr, Reason reasons0, const QPoint & poss1, const QPoint & globalPoss2);
+    QContextMenuEvent_php_qt(zval * zend_ptr, Reason reasons0, const QPoint & poss1);
+
+
+  zval *zend_ptr;
+};
+QContextMenuEvent_php_qt::QContextMenuEvent_php_qt(zval * zend_ptr, Reason reasons0, const QPoint & poss1, const QPoint & globalPoss2):
+QContextMenuEvent(reasons0, poss1, globalPoss2)
+{
+  this->zend_ptr = zend_ptr;
+}
+QContextMenuEvent_php_qt::QContextMenuEvent_php_qt(zval * zend_ptr, Reason reasons0, const QPoint & poss1):
+QContextMenuEvent(reasons0, poss1)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method y
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QContextMenuEvent, y){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->y());
-	}
+
+ZEND_METHOD(QContextMenuEvent, y)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'y' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QContextMenuEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QContextMenuEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->y());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QContextMenuEvent::y(...) ");
 }
 
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  reason
- *    flags:    c
+/*!
+ * method reason
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Reason
+ * @flags	c
  */
-ZEND_METHOD(QContextMenuEvent, reason){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-			obj->reason();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QContextMenuEvent, reason)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type Reason");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QContextMenuEvent::reason(...) ");
 }
 
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  globalY
- *    flags:    c
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint&
+ * @flags	c
  */
-ZEND_METHOD(QContextMenuEvent, globalY){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->globalY());
-	}
+
+ZEND_METHOD(QContextMenuEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QContextMenuEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QContextMenuEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QContextMenuEvent::pos(...) ");
 }
 
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method QContextMenuEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Reason reasons0s0
+ * @param	const QPoint &poss1s1
+ * @param	const QPoint &globalPoss2s2
+ * 
+ * overloaded args:
+ * @param	Reason reasons0
+ * @param	const QPoint &poss1
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QContextMenuEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-				const QPoint& return_object = (const QPoint&) obj->pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QContextMenuEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QContextMenuEvent, __construct)
+{
+// notice: unknown argument Reason reasons0s0, skipped
+
+// notice: unknown argument Reason reasons0, skipped
+  php_error(E_ERROR, "could not parse argument in QContextMenuEvent::QContextMenuEvent(...) ");
 }
 
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  x
- *    flags:    c
+/*!
+ * method globalPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint&
+ * @flags	c
  */
-ZEND_METHOD(QContextMenuEvent, x){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->x());
-	}
+
+ZEND_METHOD(QContextMenuEvent, globalPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalPos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QContextMenuEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QContextMenuEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->globalPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QContextMenuEvent::globalPos(...) ");
 }
 
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  globalPos
- *    flags:    c
+/*!
+ * method globalX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QContextMenuEvent, globalPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-				const QPoint& return_object = (const QPoint&) obj->globalPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QContextMenuEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QContextMenuEvent, globalX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalX' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QContextMenuEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QContextMenuEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->globalX());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QContextMenuEvent::globalX(...) ");
 }
 
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  globalX
- *    flags:    c
+/*!
+ * method x
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QContextMenuEvent, globalX){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->globalX());
-	}
+
+ZEND_METHOD(QContextMenuEvent, x)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'x' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QContextMenuEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QContextMenuEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->x());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QContextMenuEvent::x(...) ");
 }
 
+/*!
+ * method globalY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QContextMenuEvent);
+ZEND_METHOD(QContextMenuEvent, globalY)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalY' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QContextMenuEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QContextMenuEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->globalY());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QContextMenuEvent::globalY(...) ");
+}

Modified: trunk/qt/classes/qcoreapplication.cpp
===================================================================
--- trunk/qt/classes/qcoreapplication.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qcoreapplication.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,818 +19,1913 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QCoreApplication.cpp - QCoreApplication PHP implementation.
- * begin           : Thu Feb 23 15:23:15 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
+
 #include "../php_qt.h"
 
 
 #include <QCoreApplication>
 #include <QStringList>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QCoreApplication_php_qt:public QCoreApplication
+{
 
+public:
+  QCoreApplication_php_qt(zval * zend_ptr, int &argcs0, char **argvs1);
 
-/*		public enumEncoding:long {
-			Encoding = 0,
-			Encoding = 1
-		}
-*/
-/*********************************
- *    class     QCoreApplication
- *    function  removeTranslator
- *    flags:    s
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+QCoreApplication_php_qt::QCoreApplication_php_qt(zval * zend_ptr, int &argcs0, char **argvs1):
+QCoreApplication(argcs0, argvs1)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QCoreApplication",&staticMetaObject));
+}
+
+PHP_QT_MOC(QCoreApplication);
+
+/*!
+ * method removeTranslator
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTranslator *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, removeTranslator){
-//qt_QTranslator*
-		/* o public*/
 
-		/* qt_QTranslator* ,  */
+ZEND_METHOD(QCoreApplication, removeTranslator)
+{
+  ///QTranslator *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QTranslator
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try QTranslator *s0,
+        QCoreApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+        }
+        QTranslator *cpp_arg_0 = static_cast < QTranslator * >(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::removeTranslator((QTranslator *) cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->removeTranslator((QTranslator *) cpp_arg_0));
+        }
+      }
+#endif
 
-			if(obj_z_0->inherits("QTranslator")) {
-				obj->removeTranslator((QTranslator*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::removeTranslator(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  tr
- *    flags:    s
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QCoreApplication, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QCoreApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QCoreApplication::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QCoreApplication::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QCoreApplication::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::tr(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  installTranslator
- *    flags:    s
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QCoreApplication, installTranslator){
-//qt_QTranslator*
-		/* o public*/
 
-		/* qt_QTranslator* ,  */
+/*!
+ * method postEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *receivers0
+ * @param	 QEvent *events1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QCoreApplication, postEvent)
+{
+  ///QObject *receivers0, QEvent *events1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 46) && inherits(Z_OBJCE_P(arg_1), 21)) {
+        /// try QObject *receivers0, QEvent *events1,
+        QCoreApplication *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+        }
+        QObject *cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+        QEvent *cpp_arg_1 = static_cast < QEvent * >(php_qt_fetch(arg_1));
 
-			if(obj_z_0->inherits("QTranslator")) {
-				obj->installTranslator((QTranslator*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::postEvent((QObject *) cpp_arg_0, (QEvent *) cpp_arg_1));
+        } else {
+          RETURN_VOID(selfpointer->postEvent((QObject *) cpp_arg_0, (QEvent *) cpp_arg_1));
+        }
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::postEvent(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  startingUp
- *    flags:    s
+/*!
+ * method init
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	private
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QCoreApplication, startingUp){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->startingUp());
-	}
+
+ZEND_METHOD(QCoreApplication, init)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QCoreApplication::init(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::init(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  exit
- *    flags:    s
+/*!
+ * method addLibraryPath
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, exit){
-		/* l public*/
 
-		/* int retcode,  */
+ZEND_METHOD(QCoreApplication, addLibraryPath)
+{
+  ///const QString &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &s0,
+        QCoreApplication *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			obj->exit((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::addLibraryPath((const QString &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->addLibraryPath((const QString &)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::addLibraryPath(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  addLibraryPath
- *    flags:    s
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QCoreApplication, addLibraryPath){
-//const QString&
-		/* o public*/
 
-		/* const QString& ,  */
+/*!
+ * method libraryPaths
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QStringList
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QCoreApplication, libraryPaths)
+{
+  ///
+#ifdef PHP_QT_QStringList       // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QString")) {
-				obj->addLibraryPath((const QString&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QStringList *return_object = new QStringList;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QStringList > (QCoreApplication::libraryPaths());
+      } else {
+        *return_object = static_cast < QStringList > (selfpointer->libraryPaths());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::libraryPaths(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  setOrganizationDomain
- *    flags:    s
+/*!
+ * method aboutToQuit
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QCoreApplication, setOrganizationDomain){
-//const QString&
-		/* o public*/
 
-		/* const QString& orgDomain,  */
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method bool
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 *EventFilter)(void *messages0
+ * @param	 long *results1
+ * 
+ * @access	public
+ * @return	typedef
+ * @flags	
+ */
 
-
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QString")) {
-				obj->setOrganizationDomain((const QString&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+ZEND_METHOD(QCoreApplication, bool)
+{
+// notice: unknown argument  long *results1, skipped
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::bool(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  argv
- *    flags:    s
+/*!
+ * method removeLibraryPath
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, argv){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			char *** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (char **) obj->argv();
-			} else {
-				*return_object = (char **) QCoreApplication::argv();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCoreApplication, removeLibraryPath)
+{
+  ///const QString &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &s0,
+        QCoreApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::removeLibraryPath((const QString &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->removeLibraryPath((const QString &)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::removeLibraryPath(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  libraryPaths
- *    flags:    s
+/*!
+ * method organizationName
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, libraryPaths){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QStringList* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QStringList) obj->libraryPaths();
-			} else {
-				*return_object = (QStringList) QCoreApplication::libraryPaths();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCoreApplication, organizationName)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QCoreApplication::organizationName());
+      } else {
+        *return_object = static_cast < QString > (selfpointer->organizationName());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::organizationName(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  exec
- *    flags:    s
+/*!
+ * method instance
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QCoreApplication *
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, exec){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj->exec());
-	}
+
+ZEND_METHOD(QCoreApplication, instance)
+{
+  ///
+#ifdef PHP_QT_QCoreApplication  // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QCoreApplication * >(QCoreApplication::instance());
+      } else {
+        le.ptr = static_cast < QCoreApplication * >(selfpointer->instance());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::instance(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  setLibraryPaths
- *    flags:    s
+/*!
+ * method organizationDomain
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, setLibraryPaths){
-//const QStringList&
-		/* o public*/
 
-		/* const QStringList& ,  */
+ZEND_METHOD(QCoreApplication, organizationDomain)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QStringList")) {
-				obj->setLibraryPaths((const QStringList&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QCoreApplication::organizationDomain());
+      } else {
+        *return_object = static_cast < QString > (selfpointer->organizationDomain());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::organizationDomain(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  removeLibraryPath
- *    flags:    s
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QCoreApplication, removeLibraryPath){
-//const QString&
-		/* o public*/
 
-		/* const QString& ,  */
+/*!
+ * method hasPendingEvents
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QCoreApplication, hasPendingEvents)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QCoreApplication::hasPendingEvents());
+      } else {
+        RETURN_BOOL(selfpointer->hasPendingEvents());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::hasPendingEvents(...) ");
+}
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QString")) {
-				obj->removeLibraryPath((const QString&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+/*!
+ * method sendPostedEvents
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *receivers0
+ * @param	 int event_types1
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
+
+ZEND_METHOD(QCoreApplication, sendPostedEvents)
+{
+  ///QObject *receivers0, int event_types1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        /// try QObject *receivers0, int event_types1,
+        QCoreApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+        }
+        QObject *cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::sendPostedEvents((QObject *) cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        } else {
+          RETURN_VOID(selfpointer->sendPostedEvents((QObject *) cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }}
+#endif
+
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::sendPostedEvents());
+      } else {
+        RETURN_VOID(selfpointer->sendPostedEvents());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::sendPostedEvents(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  organizationName
- *    flags:    s
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QCoreApplication, organizationName){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->organizationName();
-			} else {
-				*return_object = (QString) QCoreApplication::organizationName();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method flush
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
+
+ZEND_METHOD(QCoreApplication, flush)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::flush());
+      } else {
+        RETURN_VOID(selfpointer->flush());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::flush(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  setOrganizationName
- *    flags:    s
+/*!
+ * method translate
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char * contexts0
+ * @param	 const char * keys1
+ * @param	 const char * comment = 0s2
+ * @param	 Encoding encoding = DefaultCodecs3
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, setOrganizationName){
-//const QString&
-		/* o public*/
 
-		/* const QString& orgName,  */
+ZEND_METHOD(QCoreApplication, translate)
+{
+  ///const char * contexts0, const char * keys1, const char * comment = 0s2, Encoding encoding = DefaultCodecs3
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try const char * contexts0, const char * keys1,
+      QCoreApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QString")) {
-				obj->setOrganizationName((const QString&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QCoreApplication::translate((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->translate((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING && Z_TYPE_P(arg_2) == IS_STRING) {
+      /// try const char * contexts0, const char * keys1, const char * comment = 0s2,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object =
+          static_cast < QString >
+          (QCoreApplication::translate((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0], (const char *)&Z_STRVAL_P(arg_2)[0]));
+      } else {
+        *return_object =
+          static_cast < QString >
+          (selfpointer->translate((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0], (const char *)&Z_STRVAL_P(arg_2)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+// notice: unknown argument  Encoding encoding = DefaultCodecs3, skipped
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::translate(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  event
- *    flags:    
+/*!
+ * method setEventFilter
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	EventFilter filters0
+ * 
+ * @access	public
+ * @return	EventFilter
+ * @flags	
  */
-ZEND_METHOD(QCoreApplication, event){
-		/* o protected*/
+
+ZEND_METHOD(QCoreApplication, setEventFilter)
+{
+// notice: unknown argument EventFilter filters0, skipped
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::setEventFilter(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  instance
- *    flags:    s
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, instance){
-	if (ZEND_NUM_ARGS() == 0){
 
-			QCoreApplication ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-			    QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-				*return_object = static_cast<QCoreApplication*>(obj->instance());
-			} else {
-                return_object = (QCoreApplication **) malloc(sizeof(QCoreApplication::instance()));
-				*return_object = static_cast<QCoreApplication *>(QCoreApplication::instance());
-			}
-			zend_class_entry *ce;                                   
-			object_init_ex(return_value, QCoreApplication_ce_ptr);     
-			zend_rsrc_list_entry le;                            
-			le.ptr = return_object[0];
-			php_qt_register(return_value,le);                   
-			return;                                             
-	}
+ZEND_METHOD(QCoreApplication, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QCoreApplication::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  organizationDomain
- *    flags:    s
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QCoreApplication, organizationDomain){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->organizationDomain();
-			} else {
-				*return_object = (QString) QCoreApplication::organizationDomain();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method sendEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *receivers0
+ * @param	 QEvent *events1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
+ */
+
+ZEND_METHOD(QCoreApplication, sendEvent)
+{
+  ///QObject *receivers0, QEvent *events1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 46) && inherits(Z_OBJCE_P(arg_1), 21)) {
+        /// try QObject *receivers0, QEvent *events1,
+        QCoreApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+        }
+        QObject *cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+        QEvent *cpp_arg_1 = static_cast < QEvent * >(php_qt_fetch(arg_1));
+
+        if (getThis() == NULL) {
+          RETURN_BOOL(QCoreApplication::sendEvent((QObject *) cpp_arg_0, (QEvent *) cpp_arg_1));
+        } else {
+          RETURN_BOOL(selfpointer->sendEvent((QObject *) cpp_arg_0, (QEvent *) cpp_arg_1));
+        }
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::sendEvent(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  hasPendingEvents
- *    flags:    s
+/*!
+ * method argc
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, hasPendingEvents){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->hasPendingEvents());
-	}
+
+ZEND_METHOD(QCoreApplication, argc)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QCoreApplication::argc());
+      } else {
+        RETURN_LONG(selfpointer->argc());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::argc(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  sendPostedEvents
- *    flags:    s
+/*!
+ * method QCoreApplication
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int &argcs0s0
+ * @param	char   **argvs1s1
+ * 
+ * overloaded args:
+ * @param	QCoreApplicationPrivate &p
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QCoreApplication, sendPostedEvents){
-//qt_QObject*
-		/* ol public*/
 
-		/* qt_QObject* receiver, int event_type,  */
+ZEND_METHOD(QCoreApplication, __construct)
+{
+  ///int &argcs0s0,char   **argvs1s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_ARRAY) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try int &argcs0s0,char   **argvs1s1,
+      QCoreApplication_php_qt *selfpointer = new QCoreApplication_php_qt(getThis(), (int &)Z_LVAL_P(arg_0), new char *[1]);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QCoreApplicationPrivate &p
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QCoreApplicationPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QCoreApplicationPrivate &p,
+        QCoreApplicationPrivate *cpp_arg_0 = static_cast < QCoreApplicationPrivate * >(php_qt_fetch(arg_0));
+        QCoreApplication_php_qt *selfpointer = new QCoreApplication_php_qt(getThis(), (QCoreApplicationPrivate &) * cpp_arg_0);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-			if(obj_z_0->inherits("QObject")) {
-				obj->sendPostedEvents((QObject*) obj_z_0, (int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::QCoreApplication(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  applicationName
- *    flags:    s
+/*!
+ * method watchUnixSignal
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int signals0
+ * @param	 bool watchs1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, applicationName){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->applicationName();
-			} else {
-				*return_object = (QString) QCoreApplication::applicationName();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCoreApplication, watchUnixSignal)
+{
+  ///int signals0, bool watchs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_BOOL) {
+      /// try int signals0, bool watchs1,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::watchUnixSignal((int)Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
+      } else {
+        RETURN_VOID(selfpointer->watchUnixSignal((int)Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::watchUnixSignal(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  flush
- *    flags:    s
+/*!
+ * method applicationFilePath
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, flush){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			obj->flush();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QCoreApplication, applicationFilePath)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QCoreApplication::applicationFilePath());
+      } else {
+        *return_object = static_cast < QString > (selfpointer->applicationFilePath());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::applicationFilePath(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  processEvents
- *    flags:    s
+/*!
+ * method removePostedEvents
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *receivers0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, processEvents){
-		/* l public*/
 
-		/* unsigned int flags,  */
+ZEND_METHOD(QCoreApplication, removePostedEvents)
+{
+  ///QObject *receivers0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        /// try QObject *receivers0,
+        QCoreApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+        }
+        QObject *cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::removePostedEvents((QObject *) cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->removePostedEvents((QObject *) cpp_arg_0));
+        }
+      }
+#endif
 
-			obj->processEvents((QEventLoop::ProcessEventsFlags) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::removePostedEvents(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  translate
- *    flags:    s
+/*!
+ * method unixSignal
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QCoreApplication, translate){
-		/* sssl public*/
 
-		/* const char* context, const char* key, const char* comment, int encoding,  */
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING && Z_TYPE_P(z_2) == IS_STRING && Z_TYPE_P(z_3) == IS_LONG){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
+/*!
+ * method installTranslator
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTranslator *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
+ZEND_METHOD(QCoreApplication, installTranslator)
+{
+  ///QTranslator *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QTranslator
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try QTranslator *s0,
+        QCoreApplication *selfpointer;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->translate( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1) , (const char*) Z_STRVAL_P(z_2) ,(QCoreApplication::Encoding) Z_LVAL_P(z_3));
-			} else {
-				*return_object = (QString) QCoreApplication::translate( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1) , (const char*) Z_STRVAL_P(z_2) ,(QCoreApplication::Encoding) Z_LVAL_P(z_3));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+        }
+        QTranslator *cpp_arg_0 = static_cast < QTranslator * >(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::installTranslator((QTranslator *) cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->installTranslator((QTranslator *) cpp_arg_0));
+        }
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::installTranslator(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  applicationDirPath
- *    flags:    s
+/*!
+ * method startingUp
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, applicationDirPath){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->applicationDirPath();
-			} else {
-				*return_object = (QString) QCoreApplication::applicationDirPath();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCoreApplication, startingUp)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QCoreApplication::startingUp());
+      } else {
+        RETURN_BOOL(selfpointer->startingUp());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::startingUp(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method exit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int retcode=0s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, staticMetaObject){
+
+ZEND_METHOD(QCoreApplication, exit)
+{
+  ///int retcode=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::exit());
+      } else {
+        RETURN_VOID(selfpointer->exit());
+      }
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int retcode=0s0,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::exit((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->exit((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::exit(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  qObject
- *    flags:    
+/*!
+ * method setOrganizationDomain
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &orgDomains0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, qObject){
+
+ZEND_METHOD(QCoreApplication, setOrganizationDomain)
+{
+  ///const QString &orgDomains0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &orgDomains0,
+        QCoreApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::setOrganizationDomain((const QString &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->setOrganizationDomain((const QString &)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::setOrganizationDomain(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  argc
- *    flags:    s
+/*!
+ * method argv
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	char **
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, argc){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj->argc());
-	}
+
+ZEND_METHOD(QCoreApplication, argv)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_ARRAY(QCoreApplication::argv());
+      } else {
+        RETURN_ARRAY(selfpointer->argv());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::argv(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  quit
- *    flags:    sl
+/*!
+ * method exec
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, quit){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			obj->quit();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QCoreApplication, exec)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QCoreApplication::exec());
+      } else {
+        RETURN_LONG(selfpointer->exec());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::exec(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  QCoreApplication
- *    flags:    
+/*!
+ * method setLibraryPaths
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QStringList &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, __construct){
-		/* ll public*/
 
-		/* int argc, char* * argv,  */
+ZEND_METHOD(QCoreApplication, setLibraryPaths)
+{
+  ///const QStringList &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QStringList
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QStringList &s0,
+        QCoreApplication *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+        }
+        QStringList *cpp_arg_0 = static_cast < QStringList * >(php_qt_fetch(arg_0));
 
-			QCoreApplication *QCoreApplication_ptr = new QCoreApplication((int&) Z_LVAL_P(z_0) ,(char* *) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QCoreApplication_ptr);
-				RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::setLibraryPaths((const QStringList &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->setLibraryPaths((const QStringList &)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::setLibraryPaths(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  watchUnixSignal
- *    flags:    s
+/*!
+ * method setOrganizationName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &orgNames0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, watchUnixSignal){
-		/* ll public*/
 
-		/* int signal, int watch,  */
+ZEND_METHOD(QCoreApplication, setOrganizationName)
+{
+  ///const QString &orgNames0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &orgNames0,
+        QCoreApplication *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			obj->watchUnixSignal((int) Z_LVAL_P(z_0) ,(bool) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::setOrganizationName((const QString &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->setOrganizationName((const QString &)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::setOrganizationName(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  removePostedEvents
- *    flags:    s
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QCoreApplication, removePostedEvents){
-//qt_QObject*
-		/* o public*/
 
-		/* qt_QObject* receiver,  */
+/*!
+ * method applicationName
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QCoreApplication, applicationName)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
 
-			if(obj_z_0->inherits("QObject")) {
-				obj->removePostedEvents((QObject*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QCoreApplication::applicationName());
+      } else {
+        *return_object = static_cast < QString > (selfpointer->applicationName());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::applicationName(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  applicationFilePath
- *    flags:    s
+/*!
+ * method processEvents
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEventLoop::ProcessEventsFlags flags = QEventLoop::AllEventss0
+ * 
+ * overloaded args:
+ * @param	QEventLoop::ProcessEventsFlags flags
+ * @param	 int maxtime
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, applicationFilePath){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->applicationFilePath();
-			} else {
-				*return_object = (QString) QCoreApplication::applicationFilePath();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCoreApplication, processEvents)
+{
+  ///QEventLoop::ProcessEventsFlags flags = QEventLoop::AllEventss0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::processEvents());
+      } else {
+        RETURN_VOID(selfpointer->processEvents());
+      }
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try QEventLoop::ProcessEventsFlags flags = QEventLoop::AllEventss0,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::processEvents((QEventLoop::ProcessEventsFlags) Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer->processEvents((QEventLoop::ProcessEventsFlags) Z_LVAL_P(arg_0)));
+      }
+    }
+  }
+  ///QEventLoop::ProcessEventsFlags flags, int maxtime
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try QEventLoop::ProcessEventsFlags flags, int maxtime,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::processEvents((QEventLoop::ProcessEventsFlags) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } else {
+        RETURN_VOID(selfpointer->processEvents((QEventLoop::ProcessEventsFlags) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::processEvents(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  setApplicationName
- *    flags:    s
+/*!
+ * method applicationDirPath
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, setApplicationName){
-//const QString&
-		/* o public*/
 
-		/* const QString& application,  */
+ZEND_METHOD(QCoreApplication, applicationDirPath)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QString")) {
-				obj->setApplicationName((const QString&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QCoreApplication::applicationDirPath());
+      } else {
+        *return_object = static_cast < QString > (selfpointer->applicationDirPath());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::applicationDirPath(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method sendSpontaneousEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *receivers0
+ * @param	 QEvent *events1
+ * 
+ * @access	private
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QCoreApplication, sendSpontaneousEvent)
+{
+  ///QObject *receivers0, QEvent *events1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 46) && inherits(Z_OBJCE_P(arg_1), 21)) {
+/// method is private, skip
+        php_error(E_ERROR, "QCoreApplication::sendSpontaneousEvent(...) cannot be called with 'QObject *receivers0, QEvent *events1,'.");
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
+#endif
 
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::sendSpontaneousEvent(...) ");
+}
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QCoreApplication::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+/*!
+ * method notify
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * @param	 QEvent *s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
+
+/*!
+ * method quit
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	sl
+ */
+
+ZEND_METHOD(QCoreApplication, quit)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::quit());
+      } else {
+        RETURN_VOID(selfpointer->quit());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::quit(...) ");
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  closingDown
- *    flags:    s
+/*!
+ * method filterEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	void *messages0
+ * @param	 long *results1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QCoreApplication, closingDown){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->closingDown());
-	}
+
+ZEND_METHOD(QCoreApplication, filterEvent)
+{
+// notice: unknown argument  long *results1, skipped
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::filterEvent(...) ");
 }
 
+/*!
+ * method setApplicationName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &applications0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-PHP_QT_DESTRUCT(QCoreApplication);
+ZEND_METHOD(QCoreApplication, setApplicationName)
+{
+  ///const QString &applications0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &applications0,
+        QCoreApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::setApplicationName((const QString &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->setApplicationName((const QString &)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::setApplicationName(...) ");
+}
+
+/*!
+ * method compressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * @param	 QObject *receivers1
+ * @param	 QPostEventList *s2
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	v
+ */
+
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
+
+ZEND_METHOD(QCoreApplication, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QCoreApplication::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QCoreApplication::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::trUtf8(...) ");
+}
+
+/*!
+ * method closingDown
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
+ */
+
+ZEND_METHOD(QCoreApplication, closingDown)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QCoreApplication * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QCoreApplication::closingDown());
+      } else {
+        RETURN_BOOL(selfpointer->closingDown());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QCoreApplication::closingDown(...) ");
+}

Modified: trunk/qt/classes/qdate.cpp
===================================================================
--- trunk/qt/classes/qdate.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdate.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,711 +19,1425 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDate.cpp - QDate PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QDate>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QDate */
-/*
- *    function  longDayName
- *    flags:    s
- */
-ZEND_METHOD(QDate, longDayName){
-		/* l public*/
+#include <QDate>
+#include <QMetaMethod>
+class QDate_php_qt:public QDate
+{
 
-		/* int weekday,  */
+public:
+  QDate_php_qt(zval * zend_ptr);
+  QDate_php_qt(zval * zend_ptr, int ys0, int ms1, int ds2);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
 
+  zval *zend_ptr;
+};
 
-				QString return_object = (QString) obj->longDayName((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+QDate_php_qt::QDate_php_qt(zval * zend_ptr):QDate()
+{
+  this->zend_ptr = zend_ptr;
 }
-
-/*********************************
- *    class     QDate */
-/*
- *    function  dayOfWeek
- *    flags:    c
- */
-ZEND_METHOD(QDate, dayOfWeek){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj->dayOfWeek());
-	}
+QDate_php_qt::QDate_php_qt(zval * zend_ptr, int ys0, int ms1, int ds2):
+QDate(ys0, ms1, ds2)
+{
+  this->zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  daysInMonth
- *    flags:    c
+/*!
+ * method isValid
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int y
+ * @param	 int m
+ * @param	 int d
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDate, daysInMonth){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj->daysInMonth());
-	}
-}
 
-/*********************************
- *    class     QDate */
-/*
- *    function  month
- *    flags:    c
- */
-ZEND_METHOD(QDate, month){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj->month());
-	}
+ZEND_METHOD(QDate, isValid)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isValid' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isValid());
+    }
+  }
+  ///int y, int m, int d
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      /// try int y, int m, int d,
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QDate::isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      } else {
+        RETURN_BOOL(selfpointer->isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::isValid(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  isValid
- *    flags:    c
+/*!
+ * method shortMonthName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int months0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QDate, isValid){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isValid());
-	}
-		/* lll public*/
 
-		/* int y, int m, int d,  */
+ZEND_METHOD(QDate, shortMonthName)
+{
+  ///int months0
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int months0,
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_BOOL(obj->isValid((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QDate::shortMonthName((int)Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->shortMonthName((int)Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDate::shortMonthName(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  setYMD
- *    flags:    
+/*!
+ * method fromJulianDay
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int jds0
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	s
  */
-ZEND_METHOD(QDate, setYMD){
-		/* lll public*/
 
-		/* int y, int m, int d,  */
+ZEND_METHOD(QDate, fromJulianDay)
+{
+  ///int jds0
+#ifdef PHP_QT_QDate             // return type
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int jds0,
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_BOOL(obj->setYMD((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDate *return_object = new QDate;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QDate > (QDate::fromJulianDay((int)Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast < QDate > (selfpointer->fromJulianDay((int)Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDate::fromJulianDay(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  shortMonthName
- *    flags:    s
+/*!
+ * method currentDate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	s
  */
-ZEND_METHOD(QDate, shortMonthName){
-		/* l public*/
 
-		/* int month,  */
+ZEND_METHOD(QDate, currentDate)
+{
+  ///
+#ifdef PHP_QT_QDate             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj->shortMonthName((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDate *return_object = new QDate;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QDate > (QDate::currentDate());
+      } else {
+        *return_object = static_cast < QDate > (selfpointer->currentDate());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDate::currentDate(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  toString
- *    flags:    c
+/*!
+ * method addDays
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int dayss0
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	c
  */
-ZEND_METHOD(QDate, toString){
-		/* l public*/
 
-		/* int f,  */
-		/* o public*/
+ZEND_METHOD(QDate, addDays)
+{
+  ///int dayss0
+#ifdef PHP_QT_QDate             // return type
 
-		/* const QString& format,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addDays' is not static");
+        RETURN_NULL();
+      }
+      /// try int dayss0,
+      QDate *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDate *return_object = new QDate;
 
-				QString return_object = (QString) obj->toString((Qt::DateFormat) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      *return_object = static_cast < QDate > (selfpointer->addDays((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
+  php_error(E_ERROR, "could not parse argument in QDate::addDays(...) ");
+}
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QString return_object = (QString) obj->toString((const QString&) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+/*!
+ * method day
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QDate, day)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'day' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->day());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::day(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  isLeapYear
- *    flags:    s
+/*!
+ * method fromString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * @param	 Qt::DateFormat f = Qt::TextDates1
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * @param	 const QString &format
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	s
  */
-ZEND_METHOD(QDate, isLeapYear){
-		/* l public*/
 
-		/* int year,  */
+ZEND_METHOD(QDate, fromString)
+{
+  ///const QString &ss0, Qt::DateFormat f = Qt::TextDates1
+#ifdef PHP_QT_QDate             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &ss0,
+        QDate *selfpointer;
 
-			RETURN_BOOL(obj->isLeapYear((int) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QDate *return_object = new QDate;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast < QDate > (QDate::fromString((const QString &)*cpp_arg_0));
+        } else {
+          *return_object = static_cast < QDate > (selfpointer->fromString((const QString &)*cpp_arg_0));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &ss0, Qt::DateFormat f = Qt::TextDates1,
+        QDate *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QDate *return_object = new QDate;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast < QDate > (QDate::fromString((const QString &)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
+        } else {
+          *return_object = static_cast < QDate > (selfpointer->fromString((const QString &)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &s, const QString &format
+#ifdef PHP_QT_QDate             // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        /// try const QString &s, const QString &format,
+        QDate *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QDate *return_object = new QDate;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast < QDate > (QDate::fromString((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        } else {
+          *return_object = static_cast < QDate > (selfpointer->fromString((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDate::fromString(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  fromJulianDay
- *    flags:    s
+/*!
+ * method daysTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDate, fromJulianDay){
-		/* l public*/
 
-		/* int jd,  */
+ZEND_METHOD(QDate, daysTo)
+{
+  ///const QDate &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDate
+      if (inherits(Z_OBJCE_P(arg_0), 13)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'daysTo' is not static");
+          RETURN_NULL();
+        }
+        /// try const QDate &s0,
+        QDate *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+        }
+        QDate *cpp_arg_0 = static_cast < QDate * >(php_qt_fetch(arg_0));
 
+        RETURN_LONG(selfpointer->daysTo((const QDate &)*cpp_arg_0));
+      }
+#endif
 
-				QDate return_object = (QDate) obj->fromJulianDay((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::daysTo(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  currentDate
- *    flags:    s
+/*!
+ * method month
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDate, currentDate){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-				QDate return_object = (QDate) obj->currentDate();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDate, month)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'month' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->month());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::month(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  addDays
- *    flags:    c
+/*!
+ * method operator<
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDate, addDays){
-		/* l public*/
 
-		/* int days,  */
+/*!
+ * method operator==
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+/*!
+ * method isLeapYear
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int years0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
+ */
 
+ZEND_METHOD(QDate, isLeapYear)
+{
+  ///int years0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int years0,
+      QDate *selfpointer;
 
-				QDate return_object = (QDate) obj->addDays((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QDate::isLeapYear((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_BOOL(selfpointer->isLeapYear((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::isLeapYear(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  day
- *    flags:    c
+/*!
+ * method gregorianToJulian
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ys0
+ * @param	 int ms1
+ * @param	 int ds2
+ * 
+ * @access	public
+ * @return	uint
+ * @flags	s
  */
-ZEND_METHOD(QDate, day){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj->day());
-	}
+
+ZEND_METHOD(QDate, gregorianToJulian)
+{
+  ///int ys0, int ms1, int ds2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      /// try int ys0, int ms1, int ds2,
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QDate::gregorianToJulian((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      } else {
+        RETURN_LONG(selfpointer->gregorianToJulian((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::gregorianToJulian(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  gregorianToJulian
- *    flags:    s
+/*!
+ * method julianToGregorian
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uint jds0
+ * @param	 int &ys1
+ * @param	 int &ms2
+ * @param	 int &ds3
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QDate, gregorianToJulian){
-		/* lll public*/
 
-		/* int y, int m, int d,  */
+ZEND_METHOD(QDate, julianToGregorian)
+{
+  ///uint jds0, int &ys1, int &ms2, int &ds3
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      /// try uint jds0, int &ys1, int &ms2, int &ds3,
+      QDate *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-
-
-			RETURN_LONG(obj->gregorianToJulian((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QDate::julianToGregorian((uint) Z_LVAL_P(arg_0), (int &)Z_LVAL_P(arg_1), (int &)Z_LVAL_P(arg_2), (int &)Z_LVAL_P(arg_3)));
+      } else {
+        RETURN_VOID(selfpointer->julianToGregorian((uint) Z_LVAL_P(arg_0), (int &)Z_LVAL_P(arg_1), (int &)Z_LVAL_P(arg_2), (int &)Z_LVAL_P(arg_3)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::julianToGregorian(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  longMonthName
- *    flags:    s
+/*!
+ * method QDate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ys0
+ * @param	int ms1
+ * @param	int ds2
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QDate, longMonthName){
-		/* l public*/
 
-		/* int month,  */
+ZEND_METHOD(QDate, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate_php_qt *selfpointer = new QDate_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///int ys0,int ms1,int ds2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try int ys0,int ms1,int ds2,
+      QDate_php_qt *selfpointer = new QDate_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2));
 
-
-				QString return_object = (QString) obj->longMonthName((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::QDate(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  julianToGregorian
- *    flags:    s
+/*!
+ * method weekNumber
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int *yearNum = 0s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDate, julianToGregorian){
-		/* llll public*/
 
-		/* unsigned int jd, int y, int m, int d,  */
+ZEND_METHOD(QDate, weekNumber)
+{
+  ///int *yearNum = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'weekNumber' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->weekNumber());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'weekNumber' is not static");
+        RETURN_NULL();
+      }
+      /// try int *yearNum = 0s0,
+      QDate *selfpointer;
 
-
-			obj->julianToGregorian((uint) Z_LVAL_P(z_0) ,(int&) Z_LVAL_P(z_1) ,(int&) Z_LVAL_P(z_2) ,(int&) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->weekNumber((int *)&Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::weekNumber(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  QDate
- *    flags:    
+/*!
+ * method addMonths
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int monthss0
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	c
  */
-ZEND_METHOD(QDate, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *QDate_ptr = new QDate();
-				PHP_QT_REGISTER(QDate_ptr);
-				RETURN_NULL();
-	}
-		/* lll public*/
 
-		/* int y, int m, int d,  */
+ZEND_METHOD(QDate, addMonths)
+{
+  ///int monthss0
+#ifdef PHP_QT_QDate             // return type
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addMonths' is not static");
+        RETURN_NULL();
+      }
+      /// try int monthss0,
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			QDate *QDate_ptr = new QDate((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				PHP_QT_REGISTER(QDate_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDate *return_object = new QDate;
+
+      *return_object = static_cast < QDate > (selfpointer->addMonths((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDate::addMonths(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  shortDayName
- *    flags:    s
+/*!
+ * method year
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDate, shortDayName){
-		/* l public*/
 
-		/* int weekday,  */
+ZEND_METHOD(QDate, year)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'year' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->year());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::year(...) ");
+}
 
+/*!
+ * method dayOfWeek
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-				QString return_object = (QString) obj->shortDayName((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+ZEND_METHOD(QDate, dayOfWeek)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'dayOfWeek' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->dayOfWeek());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::dayOfWeek(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  fromString
- *    flags:    s
+/*!
+ * method operator!=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDate, fromString){
-		/* ol public*/
 
-		/* const QString& s, int f,  */
-		/* oo public*/
+/*!
+ * method setYMD
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ys0
+ * @param	 int ms1
+ * @param	 int ds2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
 
-		/* const QString& s, const QString& format,  */
+ZEND_METHOD(QDate, setYMD)
+{
+  ///int ys0, int ms1, int ds2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setYMD' is not static");
+        RETURN_NULL();
+      }
+      /// try int ys0, int ms1, int ds2,
+      QDate *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->setYMD((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::setYMD(...) ");
+}
 
+/*!
+ * method operator>
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QDate return_object = (QDate) obj->fromString((const QString&) obj_z_0, (Qt::DateFormat) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+/*!
+ * method dayOfYear
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QDate, dayOfYear)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'dayOfYear' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && Z_OBJCE_P(z_1)->name == "QString") {
-					QDate return_object = (QDate) obj->fromString((const QString&) obj_z_0, (const QString&) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->dayOfYear());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::dayOfYear(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  dayOfYear
- *    flags:    c
+/*!
+ * method toJulianDay
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDate, dayOfYear){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj->dayOfYear());
-	}
+
+ZEND_METHOD(QDate, toJulianDay)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toJulianDay' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toJulianDay());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::toJulianDay(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  weekNumber
- *    flags:    c
+/*!
+ * method addYears
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int yearss0
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	c
  */
-ZEND_METHOD(QDate, weekNumber){
-		/* l public*/
 
-		/* int* yearNum,  */
+ZEND_METHOD(QDate, addYears)
+{
+  ///int yearss0
+#ifdef PHP_QT_QDate             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addYears' is not static");
+        RETURN_NULL();
+      }
+      /// try int yearss0,
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_LONG(obj->weekNumber((int*) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDate *return_object = new QDate;
+
+      *return_object = static_cast < QDate > (selfpointer->addYears((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDate::addYears(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  addMonths
- *    flags:    c
+/*!
+ * method longDayName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int weekdays0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QDate, addMonths){
-		/* l public*/
 
-		/* int months,  */
+ZEND_METHOD(QDate, longDayName)
+{
+  ///int weekdays0
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int weekdays0,
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QDate return_object = (QDate) obj->addMonths((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QDate::longDayName((int)Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->longDayName((int)Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDate::longDayName(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  toJulianDay
- *    flags:    c
+/*!
+ * method daysInMonth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDate, toJulianDay){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj->toJulianDay());
-	}
+
+ZEND_METHOD(QDate, daysInMonth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'daysInMonth' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->daysInMonth());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::daysInMonth(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  addYears
- *    flags:    c
+/*!
+ * method operator<=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDate, addYears){
-		/* l public*/
 
-		/* int years,  */
+/*!
+ * method toString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::DateFormat f = Qt::TextDates0
+ * 
+ * overloaded args:
+ * @param	const QString &format
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+ZEND_METHOD(QDate, toString)
+{
+  ///Qt::DateFormat f = Qt::TextDates0
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toString' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
 
-				QDate return_object = (QDate) obj->addYears((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->toString());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toString' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::DateFormat f = Qt::TextDates0,
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->toString((Qt::DateFormat) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const QString &format
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'toString' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &format,
+        QDate *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->toString((const QString &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDate::toString(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  daysTo
- *    flags:    c
+/*!
+ * method longMonthName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int months0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QDate, daysTo){
-		/* o public*/
 
-		/* const QDate& ,  */
+ZEND_METHOD(QDate, longMonthName)
+{
+  ///int months0
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int months0,
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)->name == "QDate") {
-				RETURN_LONG(obj->daysTo((const QDate&) obj_z_0));
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QDate::longMonthName((int)Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->longMonthName((int)Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDate::longMonthName(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  isNull
- *    flags:    c
+/*!
+ * method shortDayName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int weekdays0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QDate, isNull){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isNull());
-	}
+
+ZEND_METHOD(QDate, shortDayName)
+{
+  ///int weekdays0
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int weekdays0,
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QDate::shortDayName((int)Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->shortDayName((int)Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDate::shortDayName(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  year
- *    flags:    c
+/*!
+ * method isNull
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDate, year){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj->year());
-	}
+
+ZEND_METHOD(QDate, isNull)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isNull' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isNull());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::isNull(...) ");
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  daysInYear
- *    flags:    c
+/*!
+ * method operator>=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDate, daysInYear){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj->daysInYear());
-	}
-}
 
+/*!
+ * method daysInYear
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QDate);
+ZEND_METHOD(QDate, daysInYear)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'daysInYear' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->daysInYear());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDate::daysInYear(...) ");
+}

Modified: trunk/qt/classes/qdatetime.cpp
===================================================================
--- trunk/qt/classes/qdatetime.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdatetime.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,635 +19,1384 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDateTime.cpp - QDateTime PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QDateTime>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  time
- *    flags:    c
+#include <QDateTime>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QDateTime_php_qt:public QDateTime
+{
+
+public:
+  QDateTime_php_qt(zval * zend_ptr);
+  QDateTime_php_qt(zval * zend_ptr, const QDate & s0);
+    QDateTime_php_qt(zval * zend_ptr, const QDate & s0, const QTime & s1, Qt::TimeSpec spec = Qt::LocalTime);
+    QDateTime_php_qt(zval * zend_ptr, const QDateTime & others0);
+
+
+  zval *zend_ptr;
+};
+
+QDateTime_php_qt::QDateTime_php_qt(zval * zend_ptr):QDateTime()
+{
+  this->zend_ptr = zend_ptr;
+}
+QDateTime_php_qt::QDateTime_php_qt(zval * zend_ptr, const QDate & s0):
+QDateTime(s0)
+{
+  this->zend_ptr = zend_ptr;
+}
+QDateTime_php_qt::QDateTime_php_qt(zval * zend_ptr, const QDate & s0, const QTime & s1, Qt::TimeSpec spec):
+QDateTime(s0, s1, spec)
+{
+  this->zend_ptr = zend_ptr;
+}
+QDateTime_php_qt::QDateTime_php_qt(zval * zend_ptr, const QDateTime & others0):
+QDateTime(others0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method date
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, time){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-				QTime return_object = (QTime) obj->time();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDateTime, date)
+{
+  ///
+#ifdef PHP_QT_QDate             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'date' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDate *return_object = new QDate;
+
+      *return_object = static_cast < QDate > (selfpointer->date());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDateTime::date(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  date
- *    flags:    c
+/*!
+ * method isValid
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, date){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-				QDate return_object = (QDate) obj->date();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDateTime, isValid)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isValid' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isValid());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDateTime::isValid(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  isValid
- *    flags:    c
+/*!
+ * method toTime_t
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uint
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, isValid){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isValid());
-	}
+
+ZEND_METHOD(QDateTime, toTime_t)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toTime_t' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toTime_t());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDateTime::toTime_t(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  toString
- *    flags:    c
+/*!
+ * method addDays
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int dayss0
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, toString){
-		/* l public*/
 
-		/* int f,  */
-		/* o public*/
+ZEND_METHOD(QDateTime, addDays)
+{
+  ///int dayss0
+#ifdef PHP_QT_QDateTime         // return type
 
-		/* const QString& format,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addDays' is not static");
+        RETURN_NULL();
+      }
+      /// try int dayss0,
+      QDateTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
 
-				QString return_object = (QString) obj->toString((Qt::DateFormat) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      *return_object = static_cast < QDateTime > (selfpointer->addDays((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QString return_object = (QString) obj->toString((const QString&) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+  php_error(E_ERROR, "could not parse argument in QDateTime::addDays(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  toTime_t
- *    flags:    c
+/*!
+ * method fromString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * @param	 Qt::DateFormat f = Qt::TextDates1
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * @param	 const QString &format
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	s
  */
-ZEND_METHOD(QDateTime, toTime_t){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj->toTime_t());
-	}
+
+ZEND_METHOD(QDateTime, fromString)
+{
+  ///const QString &ss0, Qt::DateFormat f = Qt::TextDates1
+#ifdef PHP_QT_QDateTime         // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &ss0,
+        QDateTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QDateTime *return_object = new QDateTime;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast < QDateTime > (QDateTime::fromString((const QString &)*cpp_arg_0));
+        } else {
+          *return_object = static_cast < QDateTime > (selfpointer->fromString((const QString &)*cpp_arg_0));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &ss0, Qt::DateFormat f = Qt::TextDates1,
+        QDateTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QDateTime *return_object = new QDateTime;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast < QDateTime > (QDateTime::fromString((const QString &)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
+        } else {
+          *return_object = static_cast < QDateTime > (selfpointer->fromString((const QString &)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &s, const QString &format
+#ifdef PHP_QT_QDateTime         // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        /// try const QString &s, const QString &format,
+        QDateTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QDateTime *return_object = new QDateTime;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast < QDateTime > (QDateTime::fromString((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        } else {
+          *return_object = static_cast < QDateTime > (selfpointer->fromString((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDateTime::fromString(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  setTime_t
- *    flags:    
+/*!
+ * method setDate
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &dates0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDateTime, setTime_t){
-		/* l public*/
 
-		/* unsigned int secsSince1Jan1970UTC,  */
+ZEND_METHOD(QDateTime, setDate)
+{
+  ///const QDate &dates0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDate
+      if (inherits(Z_OBJCE_P(arg_0), 13)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setDate' is not static");
+          RETURN_NULL();
+        }
+        /// try const QDate &dates0,
+        QDateTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+        }
+        QDate *cpp_arg_0 = static_cast < QDate * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setDate((const QDate &)*cpp_arg_0));
+      }
+#endif
 
-			obj->setTime_t((uint) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDateTime::setDate(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  addDays
- *    flags:    c
+/*!
+ * method currentDateTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	s
  */
-ZEND_METHOD(QDateTime, addDays){
-		/* l public*/
 
-		/* int days,  */
+ZEND_METHOD(QDateTime, currentDateTime)
+{
+  ///
+#ifdef PHP_QT_QDateTime         // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QDateTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QDateTime return_object = (QDateTime) obj->addDays((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QDateTime > (QDateTime::currentDateTime());
+      } else {
+        *return_object = static_cast < QDateTime > (selfpointer->currentDateTime());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDateTime::currentDateTime(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  secsTo
- *    flags:    c
+/*!
+ * method daysTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, secsTo){
-		/* o public*/
 
-		/* const QDateTime& ,  */
+ZEND_METHOD(QDateTime, daysTo)
+{
+  ///const QDateTime &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDateTime
+      if (inherits(Z_OBJCE_P(arg_0), 14)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'daysTo' is not static");
+          RETURN_NULL();
+        }
+        /// try const QDateTime &s0,
+        QDateTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+        }
+        QDateTime *cpp_arg_0 = static_cast < QDateTime * >(php_qt_fetch(arg_0));
 
+        RETURN_LONG(selfpointer->daysTo((const QDateTime &)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QDateTime") {
-				RETURN_LONG(obj->secsTo((const QDateTime&) obj_z_0));
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDateTime::daysTo(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  toTimeSpec
- *    flags:    c
+/*!
+ * method toUTC
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, toTimeSpec){
-		/* l public*/
 
-		/* int spec,  */
+ZEND_METHOD(QDateTime, toUTC)
+{
+  ///
+#ifdef PHP_QT_QDateTime         // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toUTC' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QDateTime return_object = (QDateTime) obj->toTimeSpec((Qt::TimeSpec) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
+
+      *return_object = static_cast < QDateTime > (selfpointer->toUTC());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDateTime::toUTC(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  fromString
- *    flags:    s
+/*!
+ * method setTimeSpec
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::TimeSpec specs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDateTime, fromString){
-		/* ol public*/
 
-		/* const QString& s, int f,  */
-		/* oo public*/
+ZEND_METHOD(QDateTime, setTimeSpec)
+{
+  ///Qt::TimeSpec specs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setTimeSpec' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::TimeSpec specs0,
+      QDateTime *selfpointer;
 
-		/* const QString& s, const QString& format,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setTimeSpec((Qt::TimeSpec) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDateTime::setTimeSpec(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method time
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QTime
+ * @flags	c
+ */
 
+ZEND_METHOD(QDateTime, time)
+{
+  ///
+#ifdef PHP_QT_QTime             // return type
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QDateTime return_object = (QDateTime) obj->fromString((const QString&) obj_z_0, (Qt::DateFormat) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'time' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && Z_OBJCE_P(z_1)->name == "QString") {
-					QDateTime return_object = (QDateTime) obj->fromString((const QString&) obj_z_0, (const QString&) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QTime *return_object = new QTime;
+
+      *return_object = static_cast < QTime > (selfpointer->time());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDateTime::time(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  timeSpec
- *    flags:    c
+/*!
+ * method operator<
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, timeSpec){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj->timeSpec());
-	}
-}
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  setTime
- *    flags:    
+/*!
+ * method operator==
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, setTime){
-		/* o public*/
 
-		/* const QTime& time,  */
+/*!
+ * method addMonths
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int monthss0
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QDateTime, addMonths)
+{
+  ///int monthss0
+#ifdef PHP_QT_QDateTime         // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addMonths' is not static");
+        RETURN_NULL();
+      }
+      /// try int monthss0,
+      QDateTime *selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QTime") {
-				obj->setTime((const QTime&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
+
+      *return_object = static_cast < QDateTime > (selfpointer->addMonths((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDateTime::addMonths(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  addMonths
- *    flags:    c
+/*!
+ * method addSecs
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int secss0
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, addMonths){
-		/* l public*/
 
-		/* int months,  */
+ZEND_METHOD(QDateTime, addSecs)
+{
+  ///int secss0
+#ifdef PHP_QT_QDateTime         // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addSecs' is not static");
+        RETURN_NULL();
+      }
+      /// try int secss0,
+      QDateTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QDateTime return_object = (QDateTime) obj->addMonths((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
+
+      *return_object = static_cast < QDateTime > (selfpointer->addSecs((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDateTime::addSecs(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  QDateTime
- *    flags:    
+/*!
+ * method operator!=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *QDateTime_ptr = new QDateTime();
-				PHP_QT_REGISTER(QDateTime_ptr);
-				RETURN_NULL();
-	}
-		/* o public*/
 
-		/* const QDate& ,  */
+/*!
+ * method operator>
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method secsTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QDateTime, secsTo)
+{
+  ///const QDateTime &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDateTime
+      if (inherits(Z_OBJCE_P(arg_0), 14)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'secsTo' is not static");
+          RETURN_NULL();
+        }
+        /// try const QDateTime &s0,
+        QDateTime *selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QDate") {
-				QDateTime *QDateTime_ptr = new QDateTime((const QDate&) obj_z_0);
-				PHP_QT_REGISTER(QDateTime_ptr);
-				RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QDateTime") {
-				QDateTime *QDateTime_ptr = new QDateTime((const QDateTime&) obj_z_0);
-				PHP_QT_REGISTER(QDateTime_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ool public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+        }
+        QDateTime *cpp_arg_0 = static_cast < QDateTime * >(php_qt_fetch(arg_0));
 
-		/* const QDate& , const QTime& , int spec,  */
+        RETURN_LONG(selfpointer->secsTo((const QDateTime &)*cpp_arg_0));
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDateTime::secsTo(...) ");
+}
 
+/*!
+ * method toTimeSpec
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::TimeSpec specs0
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)->name == "QDate" && Z_OBJCE_P(z_1)->name == "QTime") {
-				QDateTime *QDateTime_ptr = new QDateTime((const QDate&) obj_z_0, (const QTime&) obj_z_1, (Qt::TimeSpec) Z_LVAL_P(z_2));
-				PHP_QT_REGISTER(QDateTime_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QDateTime, toTimeSpec)
+{
+  ///Qt::TimeSpec specs0
+#ifdef PHP_QT_QDateTime         // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toTimeSpec' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::TimeSpec specs0,
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
+
+      *return_object = static_cast < QDateTime > (selfpointer->toTimeSpec((Qt::TimeSpec) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDateTime::toTimeSpec(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  addSecs
- *    flags:    c
+/*!
+ * method setTime
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &times0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDateTime, addSecs){
-		/* l public*/
 
-		/* int secs,  */
+ZEND_METHOD(QDateTime, setTime)
+{
+  ///const QTime &times0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QTime
+      if (inherits(Z_OBJCE_P(arg_0), 63)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setTime' is not static");
+          RETURN_NULL();
+        }
+        /// try const QTime &times0,
+        QDateTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+        }
+        QTime *cpp_arg_0 = static_cast < QTime * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setTime((const QTime &)*cpp_arg_0));
+      }
+#endif
 
-				QDateTime return_object = (QDateTime) obj->addSecs((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDateTime::setTime(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  setDate
- *    flags:    
+/*!
+ * method addYears
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int yearss0
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, setDate){
-		/* o public*/
 
-		/* const QDate& date,  */
+ZEND_METHOD(QDateTime, addYears)
+{
+  ///int yearss0
+#ifdef PHP_QT_QDateTime         // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addYears' is not static");
+        RETURN_NULL();
+      }
+      /// try int yearss0,
+      QDateTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)->name == "QDate") {
-				obj->setDate((const QDate&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
+
+      *return_object = static_cast < QDateTime > (selfpointer->addYears((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDateTime::addYears(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  currentDateTime
- *    flags:    s
+/*!
+ * method detach
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	private
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDateTime, currentDateTime){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-				QDateTime return_object = (QDateTime) obj->currentDateTime();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDateTime, detach)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QDateTime::detach(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDateTime::detach(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  daysTo
- *    flags:    c
+/*!
+ * method operator<=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, daysTo){
-		/* o public*/
 
-		/* const QDateTime& ,  */
+/*!
+ * method toString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::DateFormat f = Qt::TextDates0
+ * 
+ * overloaded args:
+ * @param	const QString &format
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QDateTime, toString)
+{
+  ///Qt::DateFormat f = Qt::TextDates0
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toString' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QDateTime") {
-				RETURN_LONG(obj->daysTo((const QDateTime&) obj_z_0));
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->toString());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toString' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::DateFormat f = Qt::TextDates0,
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->toString((Qt::DateFormat) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const QString &format
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'toString' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &format,
+        QDateTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->toString((const QString &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDateTime::toString(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  addYears
- *    flags:    c
+/*!
+ * method setTime_t
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uint secsSince1Jan1970UTCs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDateTime, addYears){
-		/* l public*/
 
-		/* int years,  */
+ZEND_METHOD(QDateTime, setTime_t)
+{
+  ///uint secsSince1Jan1970UTCs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setTime_t' is not static");
+        RETURN_NULL();
+      }
+      /// try uint secsSince1Jan1970UTCs0,
+      QDateTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setTime_t((uint) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDateTime::setTime_t(...) ");
+}
 
+/*!
+ * method timeSpec
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::TimeSpec
+ * @flags	c
+ */
 
-				QDateTime return_object = (QDateTime) obj->addYears((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+ZEND_METHOD(QDateTime, timeSpec)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'timeSpec' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->timeSpec());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDateTime::timeSpec(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  isNull
- *    flags:    c
+/*!
+ * method QDateTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &s0
+ * 
+ * overloaded args:
+ * @param	const QDate &s0
+ * @param	const QTime &s1
+ * @param	 Qt::TimeSpec spec = Qt::LocalTime
+ * 
+ * overloaded args:
+ * @param	const QDateTime &others0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QDateTime, isNull){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isNull());
-	}
+
+ZEND_METHOD(QDateTime, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QDate &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDate
+      if (inherits(Z_OBJCE_P(arg_0), 13)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QDate &s0,
+        QDate *cpp_arg_0 = static_cast < QDate * >(php_qt_fetch(arg_0));
+        QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis(), (const QDate &)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QDate &s0,const QTime &s1, Qt::TimeSpec spec = Qt::LocalTime
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QDate
+#ifdef PHP_QT_QTime
+      if (inherits(Z_OBJCE_P(arg_0), 13) && inherits(Z_OBJCE_P(arg_1), 63)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QDate &s0,const QTime &s1,
+        QDate *cpp_arg_0 = static_cast < QDate * >(php_qt_fetch(arg_0));
+        QTime *cpp_arg_1 = static_cast < QTime * >(php_qt_fetch(arg_1));
+        QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis(), (const QDate &)*cpp_arg_0, (const QTime &)*cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QDate
+#ifdef PHP_QT_QTime
+      if (inherits(Z_OBJCE_P(arg_0), 13) && inherits(Z_OBJCE_P(arg_1), 63)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QDate &s0,const QTime &s1, Qt::TimeSpec spec = Qt::LocalTime,
+        QDate *cpp_arg_0 = static_cast < QDate * >(php_qt_fetch(arg_0));
+        QTime *cpp_arg_1 = static_cast < QTime * >(php_qt_fetch(arg_1));
+        QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis(), (const QDate &)*cpp_arg_0, (const QTime &)*cpp_arg_1, (Qt::TimeSpec) Z_LVAL_P(arg_2));
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QDateTime &others0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDateTime
+      if (inherits(Z_OBJCE_P(arg_0), 14)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QDateTime &others0,
+        QDateTime *cpp_arg_0 = static_cast < QDateTime * >(php_qt_fetch(arg_0));
+        QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis(), (const QDateTime &)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDateTime::QDateTime(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  toUTC
- *    flags:    c
+/*!
+ * method isNull
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, toUTC){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-				QDateTime return_object = (QDateTime) obj->toUTC();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDateTime, isNull)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isNull' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isNull());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDateTime::isNull(...) ");
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  toLocalTime
- *    flags:    c
+/*!
+ * method operator=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &others0
+ * 
+ * @access	public
+ * @return	QDateTime &
+ * @flags	
  */
-ZEND_METHOD(QDateTime, toLocalTime){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-				QDateTime return_object = (QDateTime) obj->toLocalTime();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  setTimeSpec
- *    flags:    
+/*!
+ * method operator>=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, setTimeSpec){
-		/* l public*/
 
-		/* int spec,  */
+/*!
+ * method toLocalTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+ZEND_METHOD(QDateTime, toLocalTime)
+{
+  ///
+#ifdef PHP_QT_QDateTime         // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toLocalTime' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
 
-			obj->setTimeSpec((Qt::TimeSpec) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
 
-PHP_QT_DESTRUCT(QDateTime);
+      *return_object = static_cast < QDateTime > (selfpointer->toLocalTime());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
+  php_error(E_ERROR, "could not parse argument in QDateTime::toLocalTime(...) ");
+}

Modified: trunk/qt/classes/qdialog.cpp
===================================================================
--- trunk/qt/classes/qdialog.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdialog.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDialog.cpp - QDialog PHP implementation.
- * begin           : Thu May 11 20:44:24 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -31,850 +30,1285 @@
 
 
 #include <QDialog>
+/// DEBUG:destructor skipped.
 #include <QMetaMethod>
-
-class QDialog_moc : public QDialog
+class QDialog_php_qt:public QDialog
 {
-    public:
-        QDialog_moc(zval* zend_ptr);
 
-        zval* zend_ptr;
-        QMetaObject* dynamicMetaObject;
+public:
+  QDialog_php_qt(zval * zend_ptr, QWidget * parent = 0, Qt::WFlags f = 0);
 
-        const QMetaObject* metaObject() const;
-        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
-        
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
 };
 
-const QMetaObject *QDialog_moc::metaObject() const
+QDialog_php_qt::QDialog_php_qt(zval * zend_ptr, QWidget * parent, Qt::WFlags f):QDialog(parent, f)
 {
-    return php_qt_getMocData(this->zend_ptr,"QDialog",&staticMetaObject);;
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QDialog",&staticMetaObject));
 }
 
-QDialog_moc::QDialog_moc(zval* zend_ptr)
-{
-    this->zend_ptr = zend_ptr;
-    dynamicMetaObject = new QMetaObject;
-    dynamicMetaObject = php_qt_getMocData(this->zend_ptr,"QDialog",&staticMetaObject);
-}
+PHP_QT_MOC(QDialog);
 
-int QDialog_moc::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
+
+ZEND_METHOD(QDialog, tr)
 {
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-    QMetaObject* d = (QMetaObject*) this->metaObject();
-    char* method_name = new char[strlen((d->method(_id)).signature())];
-    strcpy(method_name,(char*) (d->method(_id)).signature());
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QDialog *
+        selfpointer;
 
-    // breaks the string at the first bracket
-    int i;
-    for(i = 0; i < strlen(method_name); i++){
-        if(method_name[i] == 40){
-            method_name[i] = 0;
-            break;
-        }
-    }
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-    // is a Slot
-    if(d->method(_id).methodType() == QMetaMethod::Slot){
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        int j = 0;
-        zval** args[1];
-        QList<QByteArray> qargs = d->method(_id).parameterTypes();
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QDialog::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QDialog *
+        selfpointer;
 
-        for(i = 0; i < qargs.count(); i++){
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-            zval *arg;
-            MAKE_STD_ZVAL(arg);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-            // invoke to zend types
-            if(!strncmp("int",(const char*) qargs[i],3)){
-                ZVAL_LONG(arg, *reinterpret_cast< int*>(_a[i+1]));
-            } else if(!strncmp("char*",(const char*) qargs[i],5)){
-                ZVAL_STRING(arg, *reinterpret_cast< char**>(_a[i+1]), 1);
-            } else if(!strncmp("bool",(const char*) qargs[i],4)){
-                ZVAL_BOOL(arg, *reinterpret_cast< bool*>(_a[i+1]));
-            } else if(!strncmp("double",(const char*) qargs[i],4)){
-                ZVAL_DOUBLE(arg, *reinterpret_cast< double*>(_a[i+1]));
-            } else {
-                    // must be an object
-                    zend_class_entry *ce;
-                    object_init_ex(arg, QDialog_ce_ptr);
-                    zend_rsrc_list_entry le;
-                    le.ptr = *reinterpret_cast< QObject**>(_a[1]);
-                    php_qt_register(arg, le);
-                    
-            }
-
-            args[j++] = &arg;
-
-        }
-
-        php_qt_callmethod(this->zend_ptr, method_name, j, args);
-
-    // is a signal
-    } else {
-        void *_b[] = { 0, _a[1] };
-        QMetaObject::activate(this, d, 0, _b);
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QDialog::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
+  }
+#endif // return type
 
-    delete d;
-    delete method_name;
-
-    return _id;
-
+  php_error(E_ERROR, "could not parse argument in QDialog::tr(...) ");
 }
 
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-/*		public enumDialogCode:long {
-			DialogCode = 0,
-			DialogCode = 1
-		}
-*/
 /*!
- *    @class     QDialog
- *    @function  tr
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method setModal
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool modals0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, tr)
+
+ZEND_METHOD(QDialog, setModal)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  ///bool modals0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setModal' is not static");
+        RETURN_NULL();
+      }
+      /// try bool modals0,
+      QDialog *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setModal((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDialog::setModal(...) ");
+}
 
-        QString *return_object;
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
+ */
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast < QString > (obj->tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QDialog::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));       /// memory allocation
-          *return_object = static_cast < QString > (QDialog::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-        object_init_ex(return_value, QString_ce_ptr);
-        zend_rsrc_list_entry le;
+/*!
+ * method isSizeGripEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARG
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+ZEND_METHOD(QDialog, isSizeGripEnabled)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isSizeGripEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING) {
-        QString *return_object = new QString;
-        if (getThis() != NULL) {
-/// return value is object: QString
-            QDialog *obj = static_cast<QDialog *>(PHP_QT_FETCH());
-            *return_object = static_cast < QString > (obj->tr((const char *)Z_STRVAL_P(z_0)));
-/// check whether method call is static.
-        } else {
-            *return_object = static_cast < QString > (QDialog::tr((const char *)Z_STRVAL_P(z_0)));
-        } 
-            zend_class_entry *ce;
-            object_init_ex(return_value, QString_ce_ptr);
-            zend_rsrc_list_entry le;
-            le.ptr = return_object;
-            php_qt_register(return_value, le);
-            return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isSizeGripEnabled());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDialog::isSizeGripEnabled(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  setSizeGripEnabled
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QDialog, setSizeGripEnabled)
-{
-/*! l public*/
-/*! int ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+/*!
+ * method adjustPosition
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-        void *return_object;
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-        if (getThis() != NULL) {
-          obj->setSizeGripEnabled((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
-
 /*!
- *    @class     QDialog
- *    @function  setModal
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool modal
+ * method setExtension
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * extensions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, setModal)
+
+ZEND_METHOD(QDialog, setExtension)
 {
-/*! l public*/
-/*! int modal,  */
+  ///QWidget * extensions0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setExtension' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget * extensions0,
+        QDialog *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
-        void *return_object;
+        RETURN_VOID(selfpointer->setExtension((QWidget *) cpp_arg_0));
+      }
+#endif
 
-        if (getThis() != NULL) {
-          obj->setModal((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDialog::setExtension(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  exec
- *
- *    @flags    
- *    @access    public
- *    @return    int
- *    @param    
+ * method result
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDialog, exec)
+
+ZEND_METHOD(QDialog, result)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'result' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->exec());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->result());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QDialog::result(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  showExtension
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QDialog, showExtension)
+
+ZEND_METHOD(QDialog, staticMetaObject)
 {
-/*! l public*/
-/*! int ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QDialog *
+        selfpointer;
 
-        void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-          obj->showExtension((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QDialog::staticMetaObject());
       } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDialog::staticMetaObject(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  rejected
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method QDialog
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parent = 0s0
+ * @param	 Qt::WFlags f = 0s1
+ * 
+ * overloaded args:
+ * @param	QDialogPrivate &
+ * @param	 QWidget *parent
+ * @param	 Qt::WFlags f = 0
+ * 
+ * overloaded args:
+ * @param	const QDialog &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QDialog, rejected)
+
+ZEND_METHOD(QDialog, __construct)
 {
-/*  if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+  ///QWidget *parent = 0s0, Qt::WFlags f = 0s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog_php_qt *
+        selfpointer = new QDialog_php_qt(getThis());
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget *parent = 0s0,
+      QWidget *
+        cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QDialog_php_qt *
+        selfpointer = new QDialog_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-      obj->rejected();
+      PHP_QT_REGISTER(selfpointer);
       RETURN_NULL();
-    }                           /// END getThis(), NULL
-  }*/
-}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget *parent = 0s0, Qt::WFlags f = 0s1,
+      QWidget *
+        cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QDialog_php_qt *
+        selfpointer = new QDialog_php_qt(getThis(), (QWidget *) cpp_arg_0, (Qt::WFlags) Z_LVAL_P(arg_1));
 
-/*!
- *    @class     QDialog
- *    @function  isSizeGripEnabled
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
- */
-ZEND_METHOD(QDialog, isSizeGripEnabled)
-{
-  if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QDialogPrivate &, QWidget *parent, Qt::WFlags f = 0
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QDialogPrivate
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 71)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QDialogPrivate &, QWidget *parent,
+        QDialogPrivate *
+          cpp_arg_0 = static_cast < QDialogPrivate * >(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+        QDialog_php_qt *
+          selfpointer = new QDialog_php_qt(getThis(), (QDialogPrivate &) * cpp_arg_0, (QWidget *) cpp_arg_1);
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-      RETURN_BOOL(obj->isSizeGripEnabled());
-    }                           /// 5 END getThis(), simple types
+#endif
+
+    }
   }
-}
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QDialogPrivate
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 71)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QDialogPrivate &, QWidget *parent, Qt::WFlags f = 0,
+        QDialogPrivate *
+          cpp_arg_0 = static_cast < QDialogPrivate * >(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+        QDialog_php_qt *
+          selfpointer = new QDialog_php_qt(getThis(), (QDialogPrivate &) * cpp_arg_0, (QWidget *) cpp_arg_1, (Qt::WFlags) Z_LVAL_P(arg_2));
 
-/*!
- *    @class     QDialog
- *    @function  event
- *
- *    @flags    
- *    @access    public
- *    @return    bool
- *    @param    QEvent *
- */
-ZEND_METHOD(QDialog, event)
-{
-///qt_QEvent*
-/*! o public*/
-/*! qt_QEvent* ,  */
-/*  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+#endif
 
-        if (!strcmp(Z_OBJCE_P(z_0)->name, "QEvent")) {
-          bool *return_object;
+    }
+  }
+  ///const QDialog &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDialog
+      if (inherits(Z_OBJCE_P(arg_0), 15)) {
+/// method is private, skip
+        php_error(E_ERROR, "QDialog::__construct(...) cannot be called with 'const QDialog &,'.");
+      }
+#endif
 
-          if (getThis() != NULL) {
-            RETURN_BOOL(obj->event((QEvent *) obj_z_0));
-          }                     /// 5 END getThis(), simple types
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS*/
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDialog::QDialog(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  adjustPosition
- *
- *    @flags    
- *    @access    protected
- *    @return    void
- *    @param    QWidget*
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-// method adjustPosition is protected, skipped.
 
 /*!
- *    @class     QDialog
- *    @function  setExtension
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QWidget* extension
+ * method minimumSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QDialog, setExtension)
+
+ZEND_METHOD(QDialog, minimumSizeHint)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* extension,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumSizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-        if (obj_z_0->inherits("QWidget")) {
-          void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-          if (getThis() != NULL) {
-            obj->setExtension((QWidget *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->minimumSizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDialog::minimumSizeHint(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  finished
- *
- *    @flags    
- *    @access    public
- *    @return    Q_SIGNALS: void
- *    @param    int result
+ * method setOrientation
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Orientation orientations0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, finished)
+
+ZEND_METHOD(QDialog, setOrientation)
 {
-/*! l public*/
-/*! int result,  */
-/*  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///Qt::Orientation orientations0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setOrientation' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::Orientation orientations0,
+      QDialog *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->finished((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS*/
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setOrientation((Qt::Orientation) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDialog::setOrientation(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  result
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method setResult
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int rs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, result)
+
+ZEND_METHOD(QDialog, setResult)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+  ///int rs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setResult' is not static");
+        RETURN_NULL();
+      }
+      /// try int rs0,
+      QDialog *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->result());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setResult((int)Z_LVAL_P(arg_0)));
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QDialog::setResult(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  orientation
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::Orientation
- *    @param    
+ * method eventFilter
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * @param	 QEvent *s1
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QDialog, orientation)
+
+/*!
+ * method contextMenuEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QContextMenuEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
+
+/*!
+ * method accepted
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QDialog, accepted)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::Orientation * return_object;
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'accepted' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-      RETURN_LONG(obj->orientation());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->accepted());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QDialog::accepted(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  QDialog
- *
- *    @flags    t
- *    @access    public
- *    @return    
- *    @param    QWidget *parent = 0, Qt::WFlags f = 0
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QDialog, __construct)
-{
-///QWidget*
-/*! ol public*/
-/*! QWidget* parent, int f,  */
 
-  if (ZEND_NUM_ARGS() == 0) {
+/*!
+ * method done
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	v
+ */
 
-    QDialog_moc *QDialog_ptr = new QDialog_moc(getThis());
+/*!
+ * method closeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QCloseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-    PHP_QT_REGISTER(QDialog_ptr);
-    RETURN_NULL();
-                                /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+/*!
+ * method setSizeGripEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+ZEND_METHOD(QDialog, setSizeGripEnabled)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setSizeGripEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QDialog *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG) {
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
-
-        if (obj_z_0->inherits("QWidget")) {
-          QDialog *QDialog_ptr = new QDialog((QWidget *) obj_z_0, (Qt::WFlags) Z_LVAL_P(z_1));
-
-          PHP_QT_REGISTER(QDialog_ptr);
-          RETURN_NULL();
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setSizeGripEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDialog::setSizeGripEnabled(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  staticMetaObject
- *
- *    @flags    s
- *    @access    public
- *    @return    QMetaObject*
- *    @param    
+ * method resizeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QResizeEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, staticMetaObject)
-{
-}
 
 /*!
- *    @class     QDialog
- *    @function  qObject
- *
- *    @flags    
- *    @access    public
- *    @return    QObject*
- *    @param    
+ * method exec
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	
  */
-ZEND_METHOD(QDialog, qObject)
+
+ZEND_METHOD(QDialog, exec)
 {
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'exec' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->exec());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDialog::exec(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  sizeHint
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method showExtension
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, sizeHint)
+
+ZEND_METHOD(QDialog, showExtension)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'showExtension' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QDialog *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
-
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->sizeHint());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->showExtension((bool) Z_LVAL_P(arg_0)));
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QDialog_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, "could not parse argument in QDialog::showExtension(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  minimumSizeHint
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method rejected
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, minimumSizeHint)
+
+ZEND_METHOD(QDialog, rejected)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'rejected' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
-
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->minimumSizeHint());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->rejected());
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QDialog_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, "could not parse argument in QDialog::rejected(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  extension
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget*
- *    @param    
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QDialog, extension)
+
+ZEND_METHOD(QDialog, event)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+  ///QEvent *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 21)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'event' is not static");
+          RETURN_NULL();
+        }
+        /// try QEvent *s0,
+        QDialog *
+          selfpointer;
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+        }
+        QEvent *
+          cpp_arg_0 = static_cast < QEvent * >(php_qt_fetch(arg_0));
 
-/// return: pointer
+        RETURN_BOOL(selfpointer->event((QEvent *) cpp_arg_0));
+      }
+#endif
 
-/// return value is object: QWidget*
-      *return_object = static_cast < QWidget * >(obj->extension());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QDialog_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, "could not parse argument in QDialog::event(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  setOrientation
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::Orientation orientation
+ * method showEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QShowEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, setOrientation)
+
+/*!
+ * method finished
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int results0
+ * 
+ * @access	public
+ * @return	Q_SIGNALS: void
+ * @flags	
+ */
+
+ZEND_METHOD(QDialog, finished)
 {
-/*! l public*/
-/*! int orientation,  */
+  ///int results0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'finished' is not static");
+        RETURN_NULL();
+      }
+      /// try int results0,
+      QDialog *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->finished((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDialog::finished(...) ");
+}
 
-        void *return_object;
+/*!
+ * method orientation
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientation
+ * @flags	c
+ */
 
-        if (getThis() != NULL) {
-          obj->setOrientation((Qt::Orientation) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+ZEND_METHOD(QDialog, orientation)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'orientation' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->orientation());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDialog::orientation(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  setVisible
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool visible
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QDialog, setVisible)
+
+ZEND_METHOD(QDialog, sizeHint)
 {
-/*! l public*/
-/*! int visible,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-        void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-          obj->setVisible((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDialog::sizeHint(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  setResult
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int r
+ * method extension
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget*
+ * @flags	c
  */
-ZEND_METHOD(QDialog, setResult)
+
+ZEND_METHOD(QDialog, extension)
 {
-/*! l public*/
-/*! int r,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QWidget           // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'extension' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-        void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-          obj->setResult((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast < QWidget * >(selfpointer->extension());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDialog::extension(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  eventFilter
- *
- *    @flags    
- *    @access    protected
- *    @return    bool
- *    @param    QObject *, QEvent *
+ * method keyPressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method eventFilter is protected, skipped.
 
 /*!
- *    @class     QDialog
- *    @function  accepted
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method accept
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QDialog, accepted)
+
+/*!
+ * method setVisible
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool visibles0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QDialog, setVisible)
 {
-/*  if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+  ///bool visibles0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setVisible' is not static");
+        RETURN_NULL();
+      }
+      /// try bool visibles0,
+      QDialog *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
-
-      obj->accepted();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
-  }*/
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setVisible((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDialog::setVisible(...) ");
 }
 
 /*!
- *    @class     QDialog
- *    @function  trUtf8
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
+
 ZEND_METHOD(QDialog, trUtf8)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QDialog *
+        selfpointer;
 
-        QString *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast < QString > (obj->trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QDialog::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));   /// memory allocation
-          *return_object = static_cast < QString > (QDialog::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        object_init_ex(return_value, QDialog_ce_ptr);
-        zend_rsrc_list_entry le;
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QDialog::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QDialog *
+        selfpointer;
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QDialog::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
       } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDialog::trUtf8(...) ");
 }
 
-
-PHP_QT_DESTRUCT(QDialog);
+/*!
+ * method reject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	v
+ */

Modified: trunk/qt/classes/qdragenterevent.cpp
===================================================================
--- trunk/qt/classes/qdragenterevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdragenterevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,81 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDragEnterEvent.cpp - QDragEnterEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QDragEnterEvent>
 #include "../php_qt.h"
 
 
+#include <QDragEnterEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QDragEnterEvent_php_qt:public QDragEnterEvent
+{
 
-PHP_QT_DESTRUCT(QDragEnterEvent);
+public:
+  QDragEnterEvent_php_qt(zval * zend_ptr, const QPoint & poss0, Qt::DropActions actionss1, const QMimeData * datas2, Qt::MouseButtons buttonss3,
+                         Qt::KeyboardModifiers modifierss4);
 
+
+  zval *zend_ptr;
+};
+QDragEnterEvent_php_qt::QDragEnterEvent_php_qt(zval * zend_ptr, const QPoint & poss0, Qt::DropActions actionss1, const QMimeData * datas2,
+                                               Qt::MouseButtons buttonss3, Qt::KeyboardModifiers modifierss4):
+QDragEnterEvent(poss0, actionss1, datas2, buttonss3, modifierss4)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QDragEnterEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &poss0s0
+ * @param	Qt::DropActions actionss1s1
+ * @param	const QMimeData   *datas2s2
+ * @param	Qt::MouseButtons buttonss3s3
+ * @param	Qt::KeyboardModifiers modifierss4s4
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QDragEnterEvent, __construct)
+{
+  ///const QPoint &poss0s0,Qt::DropActions actionss1s1,const QMimeData   *datas2s2,Qt::MouseButtons buttonss3s3,Qt::KeyboardModifiers modifierss4s4
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QMimeData
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &poss0s0,Qt::DropActions actionss1s1,const QMimeData   *datas2s2,Qt::MouseButtons buttonss3s3,Qt::KeyboardModifiers modifierss4s4,
+        QPoint *cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QMimeData *cpp_arg_2 = static_cast < QMimeData * >(php_qt_fetch(arg_2));
+        QDragEnterEvent_php_qt *selfpointer =
+          new QDragEnterEvent_php_qt(getThis(), (const QPoint &)*cpp_arg_0, (Qt::DropActions) Z_LVAL_P(arg_1), (const QMimeData *)cpp_arg_2,
+                                     (Qt::MouseButtons) Z_LVAL_P(arg_3), (Qt::KeyboardModifiers) Z_LVAL_P(arg_4));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDragEnterEvent::QDragEnterEvent(...) ");
+}

Modified: trunk/qt/classes/qdragleaveevent.cpp
===================================================================
--- trunk/qt/classes/qdragleaveevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdragleaveevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,62 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDragLeaveEvent.cpp - QDragLeaveEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QDragLeaveEvent>
 #include "../php_qt.h"
 
 
+#include <QDragLeaveEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QDragLeaveEvent_php_qt:public QDragLeaveEvent
+{
 
-PHP_QT_DESTRUCT(QDragLeaveEvent);
+public:
+  QDragLeaveEvent_php_qt(zval * zend_ptr);
 
+
+  zval *zend_ptr;
+};
+
+QDragLeaveEvent_php_qt::QDragLeaveEvent_php_qt(zval * zend_ptr):QDragLeaveEvent()
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QDragLeaveEvent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QDragLeaveEvent, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDragLeaveEvent_php_qt *
+        selfpointer = new QDragLeaveEvent_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDragLeaveEvent::QDragLeaveEvent(...) ");
+}

Modified: trunk/qt/classes/qdragmoveevent.cpp
===================================================================
--- trunk/qt/classes/qdragmoveevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdragmoveevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,102 +19,249 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDragMoveEvent.cpp - QDragMoveEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QDragMoveEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QDragMoveEvent */
-/*
- *    function  accept
- *    flags:    
+#include <QDragMoveEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QDragMoveEvent_php_qt:public QDragMoveEvent
+{
+
+public:
+  QDragMoveEvent_php_qt(zval * zend_ptr, const QPoint & poss0, Qt::DropActions actionss1, const QMimeData * datas2, Qt::MouseButtons buttonss3,
+                        Qt::KeyboardModifiers modifierss4, Type type = DragMove);
+
+
+  zval *zend_ptr;
+};
+QDragMoveEvent_php_qt::QDragMoveEvent_php_qt(zval * zend_ptr, const QPoint & poss0, Qt::DropActions actionss1, const QMimeData * datas2,
+                                             Qt::MouseButtons buttonss3, Qt::KeyboardModifiers modifierss4, Type type):
+QDragMoveEvent(poss0, actionss1, datas2, buttonss3, modifierss4, type)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method ignore
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect & r
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDragMoveEvent, accept){
-	if (ZEND_NUM_ARGS() == 0){
-			QDragMoveEvent *obj = (QDragMoveEvent*) PHP_QT_FETCH();
-			obj->accept();
-			RETURN_NULL();
-	}
-		/* o public*/
 
-		/* const QRect& r,  */
+ZEND_METHOD(QDragMoveEvent, ignore)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'ignore' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDragMoveEvent *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDragMoveEvent *obj = (QDragMoveEvent*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDragMoveEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->ignore());
+    }
+  }
+  ///const QRect & r
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'ignore' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect & r,
+        QDragMoveEvent *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDragMoveEvent * >(PHP_QT_FETCH());
+        }
+        QRect *cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)->name == "QRect") {
-				obj->accept((const QRect&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_VOID(selfpointer->ignore((const QRect &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDragMoveEvent::ignore(...) ");
 }
 
-/*********************************
- *    class     QDragMoveEvent */
-/*
- *    function  answerRect
- *    flags:    c
+/*!
+ * method answerRect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-ZEND_METHOD(QDragMoveEvent, answerRect){
-	if (ZEND_NUM_ARGS() == 0){
-			QDragMoveEvent *obj = (QDragMoveEvent*) PHP_QT_FETCH();
-				QRect return_object = (QRect) obj->answerRect();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDragMoveEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDragMoveEvent, answerRect)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'answerRect' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDragMoveEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDragMoveEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QRect *return_object = new QRect;
+
+      *return_object = static_cast < QRect > (selfpointer->answerRect());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDragMoveEvent::answerRect(...) ");
 }
 
-/*********************************
- *    class     QDragMoveEvent */
-/*
- *    function  ignore
- *    flags:    
+/*!
+ * method QDragMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &poss0s0
+ * @param	Qt::DropActions actionss1s1
+ * @param	const QMimeData   *datas2s2
+ * @param	Qt::MouseButtons buttonss3s3
+ * @param	Qt::KeyboardModifiers modifierss4s4
+ * @param	 Type type = DragMoves5
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QDragMoveEvent, ignore){
-	if (ZEND_NUM_ARGS() == 0){
-			QDragMoveEvent *obj = (QDragMoveEvent*) PHP_QT_FETCH();
-			obj->ignore();
-			RETURN_NULL();
-	}
-		/* o public*/
 
-		/* const QRect& r,  */
+ZEND_METHOD(QDragMoveEvent, __construct)
+{
+  ///const QPoint &poss0s0,Qt::DropActions actionss1s1,const QMimeData   *datas2s2,Qt::MouseButtons buttonss3s3,Qt::KeyboardModifiers modifierss4s4, Type type = DragMoves5
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QMimeData
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &poss0s0,Qt::DropActions actionss1s1,const QMimeData   *datas2s2,Qt::MouseButtons buttonss3s3,Qt::KeyboardModifiers modifierss4s4,
+        QPoint *cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QMimeData *cpp_arg_2 = static_cast < QMimeData * >(php_qt_fetch(arg_2));
+        QDragMoveEvent_php_qt *selfpointer =
+          new QDragMoveEvent_php_qt(getThis(), (const QPoint &)*cpp_arg_0, (Qt::DropActions) Z_LVAL_P(arg_1), (const QMimeData *)cpp_arg_2,
+                                    (Qt::MouseButtons) Z_LVAL_P(arg_3), (Qt::KeyboardModifiers) Z_LVAL_P(arg_4));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDragMoveEvent *obj = (QDragMoveEvent*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+#endif
 
-
-			if(Z_OBJCE_P(z_0)->name == "QRect") {
-				obj->ignore((const QRect&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+// notice: unknown argument  Type type = DragMoves5, skipped
+  php_error(E_ERROR, "could not parse argument in QDragMoveEvent::QDragMoveEvent(...) ");
 }
 
+/*!
+ * method accept
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect & r
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QDragMoveEvent);
+ZEND_METHOD(QDragMoveEvent, accept)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'accept' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDragMoveEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDragMoveEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->accept());
+    }
+  }
+  ///const QRect & r
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'accept' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect & r,
+        QDragMoveEvent *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QDragMoveEvent * >(PHP_QT_FETCH());
+        }
+        QRect *cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->accept((const QRect &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDragMoveEvent::accept(...) ");
+}

Modified: trunk/qt/classes/qdragresponseevent.cpp
===================================================================
--- trunk/qt/classes/qdragresponseevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdragresponseevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,30 +19,98 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDragResponseEvent.cpp - QDragResponseEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QDragResponseEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QDragResponseEvent */
-/*
- *    function  dragAccepted
- *    flags:    c
+#include <QDragResponseEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QDragResponseEvent_php_qt:public QDragResponseEvent
+{
+
+public:
+  QDragResponseEvent_php_qt(zval * zend_ptr, bool accepteds0);
+
+
+  zval *zend_ptr;
+};
+
+QDragResponseEvent_php_qt::QDragResponseEvent_php_qt(zval * zend_ptr, bool accepteds0):QDragResponseEvent(accepteds0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method dragAccepted
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDragResponseEvent, dragAccepted){
-	if (ZEND_NUM_ARGS() == 0){
-			QDragResponseEvent *obj = (QDragResponseEvent*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->dragAccepted());
-	}
+
+ZEND_METHOD(QDragResponseEvent, dragAccepted)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'dragAccepted' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDragResponseEvent *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDragResponseEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->dragAccepted());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDragResponseEvent::dragAccepted(...) ");
 }
 
+/*!
+ * method QDragResponseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool accepteds0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QDragResponseEvent);
+ZEND_METHOD(QDragResponseEvent, __construct)
+{
+  ///bool accepteds0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try bool accepteds0s0,
+      QDragResponseEvent_php_qt *
+        selfpointer = new QDragResponseEvent_php_qt(getThis(), (bool) Z_LVAL_P(arg_0));
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDragResponseEvent::QDragResponseEvent(...) ");
+}

Modified: trunk/qt/classes/qdropevent.cpp
===================================================================
--- trunk/qt/classes/qdropevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdropevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,274 +19,582 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDropEvent.cpp - QDropEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QDropEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  encodedData
- *    flags:    c
- */
-ZEND_METHOD(QDropEvent, encodedData){
-		/* s public*/
+#include <QDropEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QDropEvent_php_qt:public QDropEvent
+{
 
-		/* const char* ,  */
+public:
+  QDropEvent_php_qt(zval * zend_ptr, const QPoint & poss0, Qt::DropActions actionss1, const QMimeData * datas2, Qt::MouseButtons buttonss3,
+                    Qt::KeyboardModifiers modifierss4, Type type = Drop);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING){
-//			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
 
-
-//			RETURN_STRING((char*) obj->encodedData( (const char*) Z_STRVAL_P(z_0)), 1);
-			}
-		}
-	}
+  zval *zend_ptr;
+};
+QDropEvent_php_qt::QDropEvent_php_qt(zval * zend_ptr, const QPoint & poss0, Qt::DropActions actionss1, const QMimeData * datas2, Qt::MouseButtons buttonss3,
+                                     Qt::KeyboardModifiers modifierss4, Type type):
+QDropEvent(poss0, actionss1, datas2, buttonss3, modifierss4, type)
+{
+  this->zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  source
- *    flags:    c
+/*!
+ * method dropAction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::DropAction
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, source){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-				QWidget* return_object = (QWidget*) obj->source();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDropEvent, dropAction)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'dropAction' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->dropAction());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDropEvent::dropAction(...) ");
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  keyboardModifiers
- *    flags:    c
+/*!
+ * method acceptProposedAction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDropEvent, keyboardModifiers){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-				Qt::KeyboardModifiers return_object = (Qt::KeyboardModifiers) obj->keyboardModifiers();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDropEvent, acceptProposedAction)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'acceptProposedAction' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->acceptProposedAction());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDropEvent::acceptProposedAction(...) ");
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  setDropAction
- *    flags:    
+/*!
+ * method mimeData
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QMimeData *
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, setDropAction){
-		/* l public*/
 
-		/* int action,  */
+ZEND_METHOD(QDropEvent, mimeData)
+{
+  ///
+#ifdef PHP_QT_QMimeData         // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'mimeData' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setDropAction((Qt::DropAction) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast < QMimeData * >(selfpointer->mimeData());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDropEvent::mimeData(...) ");
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  acceptProposedAction
- *    flags:    
+/*!
+ * method provides
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, acceptProposedAction){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-			obj->acceptProposedAction();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QDropEvent, provides)
+{
+  ///const char *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'provides' is not static");
+        RETURN_NULL();
+      }
+      /// try const char *s0,
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->provides((const char *)&Z_STRVAL_P(arg_0)[0]));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDropEvent::provides(...) ");
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  dropAction
- *    flags:    c
+/*!
+ * method source
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget*
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, dropAction){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->dropAction());
-	}
+
+ZEND_METHOD(QDropEvent, source)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'source' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QWidget * >(selfpointer->source());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDropEvent::source(...) ");
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  mimeData
- *    flags:    c
+/*!
+ * method mouseButtons
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::MouseButtons
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, mimeData){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-				const QMimeData * return_object = (const QMimeData *) obj->mimeData();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDropEvent, mouseButtons)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'mouseButtons' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->mouseButtons());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDropEvent::mouseButtons(...) ");
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  provides
- *    flags:    c
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, provides){
-		/* s public*/
 
-		/* const char* ,  */
+ZEND_METHOD(QDropEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_BOOL(obj->provides( (const char*) Z_STRVAL_P(z_0)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDropEvent::pos(...) ");
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  format
- *    flags:    c
+/*!
+ * method possibleActions
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::DropActions
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, format){
-		/* l public*/
 
-		/* int n,  */
+ZEND_METHOD(QDropEvent, possibleActions)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'possibleActions' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->possibleActions());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDropEvent::possibleActions(...) ");
+}
 
+/*!
+ * method proposedAction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::DropAction
+ * @flags	c
+ */
 
-				const char* return_object = (const char*) obj->format((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+ZEND_METHOD(QDropEvent, proposedAction)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'proposedAction' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->proposedAction());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDropEvent::proposedAction(...) ");
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  mouseButtons
- *    flags:    c
+/*!
+ * method keyboardModifiers
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::KeyboardModifiers
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, mouseButtons){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-				Qt::MouseButtons return_object = (Qt::MouseButtons) obj->mouseButtons();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDropEvent, keyboardModifiers)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'keyboardModifiers' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->keyboardModifiers());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDropEvent::keyboardModifiers(...) ");
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  proposedAction
- *    flags:    c
+/*!
+ * method setDropAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::DropAction actions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDropEvent, proposedAction){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->proposedAction());
-	}
+
+ZEND_METHOD(QDropEvent, setDropAction)
+{
+  ///Qt::DropAction actions0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setDropAction' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::DropAction actions0,
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setDropAction((Qt::DropAction) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDropEvent::setDropAction(...) ");
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method encodedData
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *s0
+ * 
+ * @access	public
+ * @return	QByteArray
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-				const QPoint & return_object = (const QPoint &) obj->pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDropEvent, encodedData)
+{
+  ///const char *s0
+#ifdef PHP_QT_QByteArray        // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'encodedData' is not static");
+        RETURN_NULL();
+      }
+      /// try const char *s0,
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QByteArray *return_object = new QByteArray;
+
+      *return_object = static_cast < QByteArray > (selfpointer->encodedData((const char *)&Z_STRVAL_P(arg_0)[0]));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QDropEvent::encodedData(...) ");
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  possibleActions
- *    flags:    c
+/*!
+ * method QDropEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint & poss0s0
+ * @param	Qt::DropActions actionss1s1
+ * @param	const QMimeData  *datas2s2
+ * @param	Qt::MouseButtons buttonss3s3
+ * @param	Qt::KeyboardModifiers modifierss4s4
+ * @param	 Type type = Drops5
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QDropEvent, possibleActions){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-				Qt::DropActions return_object = (Qt::DropActions) obj->possibleActions();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDropEvent, __construct)
+{
+  ///const QPoint & poss0s0,Qt::DropActions actionss1s1,const QMimeData  *datas2s2,Qt::MouseButtons buttonss3s3,Qt::KeyboardModifiers modifierss4s4, Type type = Drops5
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QMimeData
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint & poss0s0,Qt::DropActions actionss1s1,const QMimeData  *datas2s2,Qt::MouseButtons buttonss3s3,Qt::KeyboardModifiers modifierss4s4,
+        QPoint *cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QMimeData *cpp_arg_2 = static_cast < QMimeData * >(php_qt_fetch(arg_2));
+        QDropEvent_php_qt *selfpointer =
+          new QDropEvent_php_qt(getThis(), (const QPoint &)*cpp_arg_0, (Qt::DropActions) Z_LVAL_P(arg_1), (const QMimeData *)cpp_arg_2,
+                                (Qt::MouseButtons) Z_LVAL_P(arg_3), (Qt::KeyboardModifiers) Z_LVAL_P(arg_4));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+// notice: unknown argument  Type type = Drops5, skipped
+  php_error(E_ERROR, "could not parse argument in QDropEvent::QDropEvent(...) ");
 }
 
+/*!
+ * method format
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int n = 0s0
+ * 
+ * @access	public
+ * @return	const char*
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QDropEvent);
+ZEND_METHOD(QDropEvent, format)
+{
+  ///int n = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'format' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer->format(), 1);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'format' is not static");
+        RETURN_NULL();
+      }
+      /// try int n = 0s0,
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QDropEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer->format((int)Z_LVAL_P(arg_0)), 1);
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QDropEvent::format(...) ");
+}

Modified: trunk/qt/classes/qfileopenevent.cpp
===================================================================
--- trunk/qt/classes/qfileopenevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qfileopenevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,36 +19,117 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QFileOpenEvent.cpp - QFileOpenEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QFileOpenEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QFileOpenEvent */
-/*
- *    function  file
- *    flags:    c
+#include <QFileOpenEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QFileOpenEvent_php_qt:public QFileOpenEvent
+{
+
+public:
+  QFileOpenEvent_php_qt(zval * zend_ptr, const QString & files0);
+
+
+  zval *zend_ptr;
+};
+QFileOpenEvent_php_qt::QFileOpenEvent_php_qt(zval * zend_ptr, const QString & files0):
+QFileOpenEvent(files0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method file
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QFileOpenEvent, file){
-	if (ZEND_NUM_ARGS() == 0){
-			QFileOpenEvent *obj = (QFileOpenEvent*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->file();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFileOpenEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFileOpenEvent, file)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'file' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFileOpenEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFileOpenEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->file());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFileOpenEvent::file(...) ");
 }
 
+/*!
+ * method QFileOpenEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &files0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QFileOpenEvent);
+ZEND_METHOD(QFileOpenEvent, __construct)
+{
+  ///const QString &files0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &files0s0,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QFileOpenEvent_php_qt *selfpointer = new QFileOpenEvent_php_qt(getThis(), (const QString &)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFileOpenEvent::QFileOpenEvent(...) ");
+}

Modified: trunk/qt/classes/qfocusevent.cpp
===================================================================
--- trunk/qt/classes/qfocusevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qfocusevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,62 +19,152 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QFocusEvent.cpp - QFocusEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QFocusEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QFocusEvent */
-/*
- *    function  lostFocus
- *    flags:    c
+#include <QFocusEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QFocusEvent_php_qt:public QFocusEvent
+{
+
+public:
+  QFocusEvent_php_qt(zval * zend_ptr, Type types0, Qt::FocusReason reason = Qt::OtherFocusReason);
+
+
+  zval *zend_ptr;
+};
+
+QFocusEvent_php_qt::QFocusEvent_php_qt(zval * zend_ptr, Type types0, Qt::FocusReason reason):QFocusEvent(types0, reason)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method gotFocus
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFocusEvent, lostFocus){
-	if (ZEND_NUM_ARGS() == 0){
-			QFocusEvent *obj = (QFocusEvent*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->lostFocus());
-	}
+
+ZEND_METHOD(QFocusEvent, gotFocus)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'gotFocus' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFocusEvent *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFocusEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->gotFocus());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFocusEvent::gotFocus(...) ");
 }
 
-/*********************************
- *    class     QFocusEvent */
-/*
- *    function  reason
- *    flags:    
+/*!
+ * method reason
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::FocusReason
+ * @flags	
  */
-ZEND_METHOD(QFocusEvent, reason){
-	if (ZEND_NUM_ARGS() == 0){
-			QFocusEvent *obj = (QFocusEvent*) PHP_QT_FETCH();
-				Qt::FocusReason return_object = (Qt::FocusReason) obj->reason();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFocusEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFocusEvent, reason)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'reason' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFocusEvent *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFocusEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->reason());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFocusEvent::reason(...) ");
 }
 
-/*********************************
- *    class     QFocusEvent */
-/*
- *    function  gotFocus
- *    flags:    c
+/*!
+ * method lostFocus
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFocusEvent, gotFocus){
-	if (ZEND_NUM_ARGS() == 0){
-			QFocusEvent *obj = (QFocusEvent*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->gotFocus());
-	}
+
+ZEND_METHOD(QFocusEvent, lostFocus)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'lostFocus' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFocusEvent *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFocusEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->lostFocus());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFocusEvent::lostFocus(...) ");
 }
 
+/*!
+ * method QFocusEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	 Qt::FocusReason reason=Qt::OtherFocusReasons1
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QFocusEvent);
-
+ZEND_METHOD(QFocusEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+  php_error(E_ERROR, "could not parse argument in QFocusEvent::QFocusEvent(...) ");
+}

Modified: trunk/qt/classes/qfont.cpp
===================================================================
--- trunk/qt/classes/qfont.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qfont.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,1302 +19,2362 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QFont.cpp - QFont PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QFont>
 #include "../php_qt.h"
 
+
+#include <QFont>
 #include <QStringList>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QFont_php_qt:public QFont
+{
 
+public:
+  QFont_php_qt(zval * zend_ptr);
+  QFont_php_qt(zval * zend_ptr, const QString & familys0, int pointSize = -1, int weight = -1, bool italic = false);
+    QFont_php_qt(zval * zend_ptr, const QFont & s0, QPaintDevice * pds1);
+    QFont_php_qt(zval * zend_ptr, const QFont & s0);
 
-/*		public enumStyleHint:long {
-			StyleHint = 0,
-			SansSerif = Helvetica,
-			StyleHint = 2,
-			Serif = Times,
-			StyleHint = 4,
-			TypeWriter = Courier,
-			StyleHint = 6,
-			Decorative = OldEnglish,
-			StyleHint = 8,
-			StyleHint = 9
-		}
-*/
 
-/*		public enumStyleStrategy:long {
-			PreferDefault = 0x0001,
-			PreferBitmap = 0x0002,
-			PreferDevice = 0x0004,
-			PreferOutline = 0x0008,
-			ForceOutline = 0x0010,
-			PreferMatch = 0x0020,
-			PreferQuality = 0x0040,
-			PreferAntialias = 0x0080,
-			NoAntialias = 0x0100,
-			OpenGLCompatible = 0x0200
-		}
-*/
+  zval *zend_ptr;
+};
 
-/*		public enumWeight:long {
-			Light = 25,
-			Normal = 50,
-			DemiBold = 63,
-			Bold = 75,
-			Black = 87
-		}
-*/
+QFont_php_qt::QFont_php_qt(zval * zend_ptr):QFont()
+{
+  this->zend_ptr = zend_ptr;
+}
+QFont_php_qt::QFont_php_qt(zval * zend_ptr, const QString & familys0, int pointSize, int weight, bool italic):
+QFont(familys0, pointSize, weight, italic)
+{
+  this->zend_ptr = zend_ptr;
+}
+QFont_php_qt::QFont_php_qt(zval * zend_ptr, const QFont & s0, QPaintDevice * pds1):
+QFont(s0, pds1)
+{
+  this->zend_ptr = zend_ptr;
+}
+QFont_php_qt::QFont_php_qt(zval * zend_ptr, const QFont & s0):
+QFont(s0)
+{
+  this->zend_ptr = zend_ptr;
+}
 
-/*		public enumStyle:long {
-			Style = 0,
-			Style = 1,
-			Style = 2
-		}
-*/
-
-/*		public enumStretch:long {
-			UltraCondensed = 50,
-			ExtraCondensed = 62,
-			Condensed = 75,
-			SemiCondensed = 87,
-			Unstretched = 100,
-			SemiExpanded = 112,
-			Expanded = 125,
-			ExtraExpanded = 150,
-			UltraExpanded = 200
-		}
-*/
-/*********************************
- *    class     QFont */
-/*
- *    function  setOverline
- *    flags:    
+/*!
+ * method stretch
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFont, setOverline){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, stretch)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'stretch' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->stretch());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::stretch(...) ");
+}
 
+/*!
+ * method underline
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-			obj->setOverline((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QFont, underline)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'underline' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->underline());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::underline(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  insertSubstitution
- *    flags:    s
+/*!
+ * method fixedPitch
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, insertSubstitution){
-		/* oo public*/
 
-		/* const QString& , const QString& ,  */
+ZEND_METHOD(QFont, fixedPitch)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'fixedPitch' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->fixedPitch());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::fixedPitch(...) ");
+}
 
+/*!
+ * method italic
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && Z_OBJCE_P(z_1)->name == "QString") {
-				obj->insertSubstitution((const QString&) obj_z_0, (const QString&) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QFont, italic)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'italic' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->italic());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::italic(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  stretch
- *    flags:    c
+/*!
+ * method pixelSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFont, stretch){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj->stretch());
-	}
+
+ZEND_METHOD(QFont, pixelSize)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pixelSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->pixelSize());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::pixelSize(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  styleStrategy
- *    flags:    c
+/*!
+ * method insertSubstitutions
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * @param	 const QStringList &s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QFont, styleStrategy){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj->styleStrategy());
-	}
+
+ZEND_METHOD(QFont, insertSubstitutions)
+{
+  ///const QString &s0, const QStringList &s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QStringList
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        /// try const QString &s0, const QStringList &s1,
+        QFont *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QStringList *cpp_arg_1 = static_cast < QStringList * >(php_qt_fetch(arg_1));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QFont::insertSubstitutions((const QString &)*cpp_arg_0, (const QStringList &)*cpp_arg_1));
+        } else {
+          RETURN_VOID(selfpointer->insertSubstitutions((const QString &)*cpp_arg_0, (const QStringList &)*cpp_arg_1));
+      }}
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::insertSubstitutions(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setKerning
- *    flags:    
+/*!
+ * method key
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QFont, setKerning){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, key)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'key' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setKerning((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->key());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFont::key(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  underline
- *    flags:    c
+/*!
+ * method setStrikeOut
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, underline){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->underline());
-	}
+
+ZEND_METHOD(QFont, setStrikeOut)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setStrikeOut' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setStrikeOut((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setStrikeOut(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  removeSubstitution
- *    flags:    s
+/*!
+ * method fromString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QFont, removeSubstitution){
-		/* o public*/
 
-		/* const QString& ,  */
+ZEND_METHOD(QFont, fromString)
+{
+  ///const QString &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'fromString' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QFont *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				obj->removeSubstitution((const QString&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_BOOL(selfpointer->fromString((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::fromString(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  substitute
- *    flags:    s
+/*!
+ * method exactMatch
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, substitute){
-		/* o public*/
 
-		/* const QString& ,  */
+ZEND_METHOD(QFont, exactMatch)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'exactMatch' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->exactMatch());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::exactMatch(...) ");
+}
 
+/*!
+ * method handle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::HANDLE
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QString return_object = (QString) obj->substitute((const QString&) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+ZEND_METHOD(QFont, handle)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'handle' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->handle());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::handle(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setBold
- *    flags:    
+/*!
+ * method setStyle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Style styles0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, setBold){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, setStyle)
+{
+// notice: unknown argument Style styles0, skipped
+  php_error(E_ERROR, "could not parse argument in QFont::setStyle(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+/*!
+ * method setUnderline
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QFont, setUnderline)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setUnderline' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
 
-			obj->setBold((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setUnderline((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setUnderline(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  resolve
- *    flags:    c
+/*!
+ * method family
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QFont, resolve){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj->resolve());
-	}
-		/* l public*/
 
-		/* unsigned int mask,  */
-		/* o public*/
+ZEND_METHOD(QFont, family)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-		/* const QFont& ,  */
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'family' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-			obj->resolve((uint) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      *return_object = static_cast < QString > (selfpointer->family());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-
-			if(Z_OBJCE_P(z_0)->name == "QFont") {
-					QFont return_object = (QFont) obj->resolve((const QFont&) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+  php_error(E_ERROR, "could not parse argument in QFont::family(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  fixedPitch
- *    flags:    c
+/*!
+ * method rawMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, fixedPitch){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->fixedPitch());
-	}
+
+ZEND_METHOD(QFont, rawMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'rawMode' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->rawMode());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::rawMode(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  italic
- *    flags:    c
+/*!
+ * method operator QVariant
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	c
  */
-ZEND_METHOD(QFont, italic){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->italic());
-	}
-}
 
-/*********************************
- *    class     QFont */
-/*
- *    function  pixelSize
- *    flags:    c
+/*!
+ * method setStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, pixelSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj->pixelSize());
-	}
+
+ZEND_METHOD(QFont, setStretch)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setStretch' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setStretch((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setStretch(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  insertSubstitutions
- *    flags:    s
+/*!
+ * method operator<
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, insertSubstitutions){
-		/* oo public*/
 
-		/* const QString& , const QStringList& ,  */
+/*!
+ * method operator==
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+/*!
+ * method defaultFamily
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
+ZEND_METHOD(QFont, defaultFamily)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && Z_OBJCE_P(z_1)->name == "QStringList") {
-				obj->insertSubstitutions((const QString&) obj_z_0, (const QStringList&) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'defaultFamily' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->defaultFamily());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFont::defaultFamily(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  key
- *    flags:    c
+/*!
+ * method kerning
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, key){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->key();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFont, kerning)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'kerning' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->kerning());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::kerning(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setStrikeOut
- *    flags:    
+/*!
+ * method QFont
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &familys0
+ * @param	 int pointSize = -1
+ * @param	 int weight = -1
+ * @param	 bool italic = false
+ * 
+ * overloaded args:
+ * @param	const QFont &s0
+ * @param	QPaintDevice  *pds1
+ * 
+ * overloaded args:
+ * @param	const QFont &s0
+ * 
+ * overloaded args:
+ * @param	QFontPrivate *
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QFont, setStrikeOut){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont_php_qt *selfpointer = new QFont_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QString &familys0, int pointSize = -1, int weight = -1, bool italic = false
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &familys0,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QString &)*cpp_arg_0);
 
-			obj->setStrikeOut((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &familys0, int pointSize = -1,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1));
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &familys0, int pointSize = -1, int weight = -1,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2));
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_BOOL) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &familys0, int pointSize = -1, int weight = -1, bool italic = false,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QFont_php_qt *selfpointer =
+          new QFont_php_qt(getThis(), (const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (bool) Z_LVAL_P(arg_3));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QFont &s0,QPaintDevice  *pds1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+#ifdef PHP_QT_QPaintDevice
+      if (inherits(Z_OBJCE_P(arg_0), 24) && inherits(Z_OBJCE_P(arg_1), 49)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QFont &s0,QPaintDevice  *pds1,
+        QFont *cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));
+        QPaintDevice *cpp_arg_1 = static_cast < QPaintDevice * >(php_qt_fetch(arg_1));
+        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QFont &)*cpp_arg_0, (QPaintDevice *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QFont &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QFont &s0,
+        QFont *cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));
+        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QFont &)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///QFontPrivate *
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFontPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// method is private, skip
+        php_error(E_ERROR, "QFont::__construct(...) cannot be called with 'QFontPrivate *,'.");
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::QFont(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  weight
- *    flags:    c
+/*!
+ * method bold
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, weight){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj->weight());
-	}
+
+ZEND_METHOD(QFont, bold)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'bold' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->bold());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::bold(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  pointSize
- *    flags:    c
+/*!
+ * method style
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Style
+ * @flags	c
  */
-ZEND_METHOD(QFont, pointSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj->pointSize());
-	}
+
+ZEND_METHOD(QFont, style)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type Style");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::style(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  cleanup
- *    flags:    s
+/*!
+ * method setStyleStrategy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	StyleStrategy ss0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, cleanup){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			obj->cleanup();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QFont, setStyleStrategy)
+{
+// notice: unknown argument StyleStrategy ss0, skipped
+  php_error(E_ERROR, "could not parse argument in QFont::setStyleStrategy(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  fromString
- *    flags:    
+/*!
+ * method cacheStatistics
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QFont, fromString){
-		/* o public*/
 
-		/* const QString& ,  */
+ZEND_METHOD(QFont, cacheStatistics)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QFont::cacheStatistics());
+      } else {
+        RETURN_VOID(selfpointer->cacheStatistics());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::cacheStatistics(...) ");
+}
 
+/*!
+ * method lastResortFont
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				RETURN_BOOL(obj->fromString((const QString&) obj_z_0));
-			}
-			}
-		}
-	}
+ZEND_METHOD(QFont, lastResortFont)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'lastResortFont' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->lastResortFont());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFont::lastResortFont(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  exactMatch
- *    flags:    c
+/*!
+ * method lastResortFamily
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QFont, exactMatch){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->exactMatch());
-	}
+
+ZEND_METHOD(QFont, lastResortFamily)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'lastResortFamily' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->lastResortFamily());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFont::lastResortFamily(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setWeight
- *    flags:    
+/*!
+ * method overline
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, setWeight){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, overline)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'overline' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->overline());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::overline(...) ");
+}
 
+/*!
+ * method setPointSizeF
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	qreal qreals0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj->setWeight((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QFont, setPointSizeF)
+{
+// notice: unknown argument qreal qreals0, skipped
+  php_error(E_ERROR, "could not parse argument in QFont::setPointSizeF(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  styleHint
- *    flags:    c
+/*!
+ * method pointSizeF
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
-ZEND_METHOD(QFont, styleHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj->styleHint());
-	}
+
+ZEND_METHOD(QFont, pointSizeF)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type qreal");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::pointSizeF(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  handle
- *    flags:    c
+/*!
+ * method setOverline
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, handle){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				Qt::HANDLE return_object = (Qt::HANDLE) obj->handle();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFont, setOverline)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setOverline' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setOverline((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setOverline(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setStyle
- *    flags:    
+/*!
+ * method insertSubstitution
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * @param	 const QString &s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QFont, setStyle){
-		/* o public*/
 
-		/* QFont::Style style,  */
+ZEND_METHOD(QFont, insertSubstitution)
+{
+  ///const QString &s0, const QString &s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        /// try const QString &s0, const QString &s1,
+        QFont *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
 
-			obj->setStyle((QFont::Style) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_VOID(QFont::insertSubstitution((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        } else {
+          RETURN_VOID(selfpointer->insertSubstitution((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+      }}
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::insertSubstitution(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  rawName
- *    flags:    c
+/*!
+ * method operator!=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, rawName){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->rawName();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setUnderline
- *    flags:    
+/*!
+ * method styleStrategy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	StyleStrategy
+ * @flags	c
  */
-ZEND_METHOD(QFont, setUnderline){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, styleStrategy)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type StyleStrategy");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::styleStrategy(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+/*!
+ * method setKerning
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QFont, setKerning)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setKerning' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
 
-			obj->setUnderline((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setKerning((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setKerning(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  family
- *    flags:    c
+/*!
+ * method removeSubstitution
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QFont, family){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->family();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFont, removeSubstitution)
+{
+  ///const QString &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &s0,
+        QFont *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QFont::removeSubstitution((const QString &)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->removeSubstitution((const QString &)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::removeSubstitution(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  isCopyOf
- *    flags:    c
+/*!
+ * method substitute
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QFont, isCopyOf){
-		/* o public*/
 
-		/* const QFont& ,  */
+ZEND_METHOD(QFont, substitute)
+{
+  ///const QString &s0
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &s0,
+        QFont *selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QFont") {
-				RETURN_BOOL(obj->isCopyOf((const QFont&) obj_z_0));
-			}
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast < QString > (QFont::substitute((const QString &)*cpp_arg_0));
+        } else {
+          *return_object = static_cast < QString > (selfpointer->substitute((const QString &)*cpp_arg_0));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFont::substitute(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  rawMode
- *    flags:    c
+/*!
+ * method setBold
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, rawMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->rawMode());
-	}
+
+ZEND_METHOD(QFont, setBold)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setBold' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setBold((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setBold(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  substitutes
- *    flags:    s
+/*!
+ * method resolve
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &s0
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uint mask
+ * 
+ * @access	public
+ * @return	QFont
+ * @flags	c
  */
-ZEND_METHOD(QFont, substitutes){
-		/* o public*/
 
-		/* const QString& ,  */
+ZEND_METHOD(QFont, resolve)
+{
+  ///const QFont &s0
+#ifdef PHP_QT_QFont             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'resolve' is not static");
+          RETURN_NULL();
+        }
+        /// try const QFont &s0,
+        QFont *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+        }
+        QFont *cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QStringList return_object = (QStringList) obj->substitutes((const QString&) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QFont *return_object = new QFont;
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setStretch
- *    flags:    
- */
-ZEND_METHOD(QFont, setStretch){
-		/* l public*/
+        *return_object = static_cast < QFont > (selfpointer->resolve((const QFont &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-		/* int ,  */
+    }
+  }
+#endif // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
 
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'resolve' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-			obj->setStretch((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->resolve());
+    }
+  }
+  ///uint mask
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'resolve' is not static");
+        RETURN_NULL();
+      }
+      /// try uint mask,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->resolve((uint) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::resolve(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  initialize
- *    flags:    s
+/*!
+ * method weight
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFont, initialize){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			obj->initialize();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QFont, weight)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'weight' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->weight());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::weight(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  toString
- *    flags:    c
+/*!
+ * method pointSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFont, toString){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->toString();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFont, pointSize)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pointSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->pointSize());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::pointSize(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  defaultFamily
- *    flags:    c
+/*!
+ * method cleanup
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QFont, defaultFamily){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->defaultFamily();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFont, cleanup)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QFont::cleanup());
+      } else {
+        RETURN_VOID(selfpointer->cleanup());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::cleanup(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setRawMode
- *    flags:    
+/*!
+ * method setWeight
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, setRawMode){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, setWeight)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setWeight' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-
-
-			obj->setRawMode((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setWeight((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setWeight(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  kerning
- *    flags:    c
+/*!
+ * method styleHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	StyleHint
+ * @flags	c
  */
-ZEND_METHOD(QFont, kerning){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->kerning());
-	}
+
+ZEND_METHOD(QFont, styleHint)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type StyleHint");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::styleHint(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setStyleHint
- *    flags:    
+/*!
+ * method rawName
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QFont, setStyleHint){
-		/* ll public*/
 
-		/* int , int ,  */
+ZEND_METHOD(QFont, rawName)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'rawName' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setStyleHint((QFont::StyleHint) Z_LVAL_P(z_0) ,(QFont::StyleStrategy) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-/*********************************
- *    class     QFont */
-/*
- *    function  substitutions
- *    flags:    s
- */
-ZEND_METHOD(QFont, substitutions){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QStringList return_object = (QStringList) obj->substitutions();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+      *return_object = static_cast < QString > (selfpointer->rawName());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFont::rawName(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setFamily
- *    flags:    
+/*!
+ * method isCopyOf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, setFamily){
-		/* o public*/
 
-		/* const QString& ,  */
+ZEND_METHOD(QFont, isCopyOf)
+{
+  ///const QFont &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'isCopyOf' is not static");
+          RETURN_NULL();
+        }
+        /// try const QFont &s0,
+        QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+        }
+        QFont *cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));
 
+        RETURN_BOOL(selfpointer->isCopyOf((const QFont &)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				obj->setFamily((const QString&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::isCopyOf(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  QFont
- *    flags:    
+/*!
+ * method substitutes
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	QStringList
+ * @flags	s
  */
-ZEND_METHOD(QFont, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *QFont_ptr = new QFont();
-				PHP_QT_REGISTER(QFont_ptr);
-				RETURN_NULL();
-	}
-		/* o public*/
 
-		/* const QFont& ,  */
+ZEND_METHOD(QFont, substitutes)
+{
+  ///const QString &s0
+#ifdef PHP_QT_QStringList       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &s0,
+        QFont *selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QFont") {
-				QFont *QFont_ptr = new QFont((const QFont&) obj_z_0);
-				PHP_QT_REGISTER(QFont_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ol public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-		/* const QFont& , qt_QPaintDevice* pd,  */
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QStringList *return_object = new QStringList;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() == NULL) {
+          *return_object = static_cast < QStringList > (QFont::substitutes((const QString &)*cpp_arg_0));
+        } else {
+          *return_object = static_cast < QStringList > (selfpointer->substitutes((const QString &)*cpp_arg_0));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
+    }
+  }
+#endif // return type
 
-			if(Z_OBJCE_P(z_0)->name == "QFont") {
-				QFont *QFont_ptr = new QFont((const QFont&) obj_z_0, (QPaintDevice*) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QFont_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* olll public*/
+  php_error(E_ERROR, "could not parse argument in QFont::substitutes(...) ");
+}
 
-		/* const QString& family, int pointSize, int weight, int italic,  */
+/*!
+ * method detach
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	private
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-
-
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				QFont *QFont_ptr = new QFont((const QString&) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (bool) Z_LVAL_P(z_3));
-				PHP_QT_REGISTER(QFont_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QFont, detach)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QFont::detach(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::detach(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  bold
- *    flags:    c
+/*!
+ * method initialize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QFont, bold){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->bold());
-	}
-}
 
-/*********************************
- *    class     QFont */
-/*
- *    function  style
- *    flags:    c
- */
-ZEND_METHOD(QFont, style){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QFont::Style return_object = (QFont::Style) obj->style();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QFont, initialize)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QFont::initialize());
+      } else {
+        RETURN_VOID(selfpointer->initialize());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::initialize(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setPointSize
- *    flags:    
+/*!
+ * method toString
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QFont, setPointSize){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, toString)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toString' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setPointSize((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->toString());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFont::toString(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setRawName
- *    flags:    
+/*!
+ * method setRawMode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, setRawName){
-		/* o public*/
 
-		/* const QString& ,  */
+ZEND_METHOD(QFont, setRawMode)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setRawMode' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setRawMode((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setRawMode(...) ");
+}
 
+/*!
+ * method setStyleHint
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	StyleHint StyleHints0
+ * @param	 StyleStrategy = PreferDefaults1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				obj->setRawName((const QString&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QFont, setStyleHint)
+{
+// notice: unknown argument StyleHint StyleHints0, skipped
+  php_error(E_ERROR, "could not parse argument in QFont::setStyleHint(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setStyleStrategy
- *    flags:    
+/*!
+ * method substitutions
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QStringList
+ * @flags	s
  */
-ZEND_METHOD(QFont, setStyleStrategy){
-		/* l public*/
 
-		/* int s,  */
+ZEND_METHOD(QFont, substitutions)
+{
+  ///
+#ifdef PHP_QT_QStringList       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QFont *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setStyleStrategy((QFont::StyleStrategy) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QStringList *return_object = new QStringList;
 
-/*********************************
- *    class     QFont */
-/*
- *    function  cacheStatistics
- *    flags:    s
- */
-ZEND_METHOD(QFont, cacheStatistics){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			obj->cacheStatistics();
-			RETURN_NULL();
-	}
+      if (getThis() == NULL) {
+        *return_object = static_cast < QStringList > (QFont::substitutions());
+      } else {
+        *return_object = static_cast < QStringList > (selfpointer->substitutions());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFont::substitutions(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setPixelSize
- *    flags:    
+/*!
+ * method setFamily
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, setPixelSize){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, setFamily)
+{
+  ///const QString &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setFamily' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QFont *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			obj->setPixelSize((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        RETURN_VOID(selfpointer->setFamily((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setFamily(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setFixedPitch
- *    flags:    
+/*!
+ * method setPointSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, setFixedPitch){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, setPointSize)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setPointSize' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-
-
-			obj->setFixedPitch((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setPointSize((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setPointSize(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setItalic
- *    flags:    
+/*!
+ * method setRawName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, setItalic){
-		/* l public*/
 
-		/* int b,  */
+ZEND_METHOD(QFont, setRawName)
+{
+  ///const QString &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setRawName' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QFont *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			obj->setItalic((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        RETURN_VOID(selfpointer->setRawName((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setRawName(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  strikeOut
- *    flags:    c
+/*!
+ * method setFixedPitch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, strikeOut){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->strikeOut());
-	}
+
+ZEND_METHOD(QFont, setFixedPitch)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setFixedPitch' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setFixedPitch((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setFixedPitch(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  lastResortFont
- *    flags:    c
+/*!
+ * method setPixelSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, lastResortFont){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->lastResortFont();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QFont */
-/*
- *    function  lastResortFamily
- *    flags:    c
- */
-ZEND_METHOD(QFont, lastResortFamily){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->lastResortFamily();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QFont, setPixelSize)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setPixelSize' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setPixelSize((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setPixelSize(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  overline
- *    flags:    c
+/*!
+ * method setItalic
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, overline){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->overline());
-	}
-}
 
-/*********************************
- *    class     QFont */
-/*
- *    function  pointSizeF
- *    flags:    c
- */
-ZEND_METHOD(QFont, pointSizeF){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj->pointSizeF());
-	}
+ZEND_METHOD(QFont, setItalic)
+{
+  ///bool bs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setItalic' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bs0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setItalic((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::setItalic(...) ");
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setPointSizeF
- *    flags:    
+/*!
+ * method strikeOut
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, setPointSizeF){
-		/* l public*/
 
-		/* double ,  */
+ZEND_METHOD(QFont, strikeOut)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'strikeOut' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-
-
-			obj->setPointSizeF((qreal) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->strikeOut());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFont::strikeOut(...) ");
 }
 
-
-PHP_QT_DESTRUCT(QFont);
-
+/*!
+ * method operator=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &s0
+ * 
+ * @access	public
+ * @return	QFont &
+ * @flags	
+ */

Modified: trunk/qt/classes/qframe.cpp
===================================================================
--- trunk/qt/classes/qframe.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qframe.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,495 +19,1006 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QFrame.cpp - QFrame PHP implementation.
- * begin           : Thu Feb 23 16:34:20 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
+
 #include "../php_qt.h"
 
 
 #include <QFrame>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QFrame_php_qt:public QFrame
+{
 
+public:
+  QFrame_php_qt(zval * zend_ptr, QWidget * parent = 0, Qt::WFlags f = 0);
 
-/*		public enumShape:long {
-			NoFrame = 0,
-			Box = 0x0001,
-			Panel = 0x0002,
-			WinPanel = 0x0003,
-			HLine = 0x0004,
-			VLine = 0x0005,
-			StyledPanel = 0x0006
-		}
-*/
 
-/*		public enumShadow:long {
-			Plain = 0x0010,
-			Raised = 0x0020,
-			Sunken = 0x0030
-		}
-*/
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
-/*		public enum:long {
-			Shadow_Mask = 0x00f0,
-			Shape_Mask = 0x000f
-		}
-*/
-/*********************************
- *    class     QFrame
- *    function  tr
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+QFrame_php_qt::QFrame_php_qt(zval * zend_ptr, QWidget * parent, Qt::WFlags f):QFrame(parent, f)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QFrame",&staticMetaObject));
+}
+
+PHP_QT_MOC(QFrame);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QFrame, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QFrame, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QFrame *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QFrame::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFrame_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QFrame::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QFrame::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFrame::tr(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  setLineWidth
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QFrame, setLineWidth){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method QFrame
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * parent = 0s0
+ * @param	 Qt::WFlags f = 0s1
+ * 
+ * overloaded args:
+ * @param	QFramePrivate &dd
+ * @param	 QWidget* parent = 0
+ * @param	 Qt::WFlags f = 0
+ * 
+ * overloaded args:
+ * @param	const QFrame &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+ZEND_METHOD(QFrame, __construct)
+{
+  ///QWidget * parent = 0s0, Qt::WFlags f = 0s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame_php_qt *
+        selfpointer = new QFrame_php_qt(getThis());
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget * parent = 0s0,
+      QWidget *
+        cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QFrame_php_qt *
+        selfpointer = new QFrame_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-			obj->setLineWidth((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget * parent = 0s0, Qt::WFlags f = 0s1,
+      QWidget *
+        cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QFrame_php_qt *
+        selfpointer = new QFrame_php_qt(getThis(), (QWidget *) cpp_arg_0, (Qt::WFlags) Z_LVAL_P(arg_1));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QFramePrivate &dd, QWidget* parent = 0, Qt::WFlags f = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFramePrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QFramePrivate &dd,
+        QFramePrivate *
+          cpp_arg_0 = static_cast < QFramePrivate * >(php_qt_fetch(arg_0));
+        QFrame_php_qt *
+          selfpointer = new QFrame_php_qt(getThis(), (QFramePrivate &) * cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QFramePrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QFramePrivate &dd, QWidget* parent = 0,
+        QFramePrivate *
+          cpp_arg_0 = static_cast < QFramePrivate * >(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+        QFrame_php_qt *
+          selfpointer = new QFrame_php_qt(getThis(), (QFramePrivate &) * cpp_arg_0, (QWidget *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QFramePrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QFramePrivate &dd, QWidget* parent = 0, Qt::WFlags f = 0,
+        QFramePrivate *
+          cpp_arg_0 = static_cast < QFramePrivate * >(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+        QFrame_php_qt *
+          selfpointer = new QFrame_php_qt(getThis(), (QFramePrivate &) * cpp_arg_0, (QWidget *) cpp_arg_1, (Qt::WFlags) Z_LVAL_P(arg_2));
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QFrame &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFrame
+      if (inherits(Z_OBJCE_P(arg_0), 25)) {
+/// method is private, skip
+        php_error(E_ERROR, "QFrame::__construct(...) cannot be called with 'const QFrame &,'.");
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFrame::QFrame(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  frameWidth
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method frameShadow
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Shadow
+ * @flags	c
  */
-ZEND_METHOD(QFrame, frameWidth){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			RETURN_LONG(obj->frameWidth());
-	}
+
+ZEND_METHOD(QFrame, frameShadow)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type Shadow");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFrame::frameShadow(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  staticMetaObject
- *    flags:    s
- *    access:    public
- *    return:    QMetaObject*
- *    params:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QFrame, staticMetaObject){
-}
 
-/*********************************
- *    class     QFrame
- *    function  QFrame
- *    flags:    t
- *    access:    public
- *    return:    
- *    params:    QWidget* parent = 0, Qt::WFlags f = 0
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QFrame, __construct){
-//qt_QWidget*
-		/* ol public*/
 
-		/* qt_QWidget* parent, int f,  */
+/*!
+ * method drawFrame
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPainter *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-			if(obj_z_0->inherits("QWidget")) {
-				QFrame *QFrame_ptr = new QFrame((QWidget*) obj_z_0, (Qt::WFlags) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QFrame_ptr);
-				RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+/*!
+ * method setFrameShadow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Shadow Shadows0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QFrame, setFrameShadow)
+{
+// notice: unknown argument Shadow Shadows0, skipped
+  php_error(E_ERROR, "could not parse argument in QFrame::setFrameShadow(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  midLineWidth
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method frameStyle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFrame, midLineWidth){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			RETURN_LONG(obj->midLineWidth());
-	}
+
+ZEND_METHOD(QFrame, frameStyle)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'frameStyle' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->frameStyle());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFrame::frameStyle(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  frameShadow
- *    flags:    c
- *    access:    public
- *    return:    Shadow
- *    params:    
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QFrame, frameShadow){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			obj->frameShadow();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QFrame, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QFrame::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFrame::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  qObject
- *    flags:    
- *    access:    public
- *    return:    QObject*
- *    params:    
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QFrame, qObject){
-}
 
-/*********************************
- *    class     QFrame
- *    function  frameShape
- *    flags:    c
- *    access:    public
- *    return:    Shape
- *    params:    
+/*!
+ * method setFrameShape
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Shape Shapes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFrame, frameShape){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			obj->frameShape();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QFrame, setFrameShape)
+{
+// notice: unknown argument Shape Shapes0, skipped
+  php_error(E_ERROR, "could not parse argument in QFrame::setFrameShape(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  setFrameShape
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    Shape
+/*!
+ * method setFrameStyle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFrame, setFrameShape){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFrame, setFrameStyle)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setFrameStyle' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFrame *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setFrameStyle((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFrame::setFrameStyle(...) ");
+}
 
+/*!
+ * method setMidLineWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj->setFrameShape((QFrame::Shape) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+ZEND_METHOD(QFrame, setMidLineWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMidLineWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMidLineWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFrame::setMidLineWidth(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  sizeHint
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QFrame, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->sizeHint();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFrame_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method frameWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QFrame, frameWidth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'frameWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->frameWidth());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFrame::frameWidth(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  setFrameRect
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    const QRect &
+/*!
+ * method midLineWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFrame, setFrameRect){
-//const QRect&
-		/* o public*/
 
-		/* const QRect& ,  */
+ZEND_METHOD(QFrame, midLineWidth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'midLineWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->midLineWidth());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFrame::midLineWidth(...) ");
+}
 
+/*!
+ * method frameShape
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Shape
+ * @flags	c
+ */
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QRect")) {
-				obj->setFrameRect((const QRect&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+ZEND_METHOD(QFrame, frameShape)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type Shape");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFrame::frameShape(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  setFrameStyle
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method setFrameRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFrame, setFrameStyle){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFrame, setFrameRect)
+{
+  ///const QRect &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setFrameRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &s0,
+        QFrame *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setFrameRect((const QRect &)*cpp_arg_0));
+      }
+#endif
 
-			obj->setFrameStyle((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFrame::setFrameRect(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  lineWidth
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method lineWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFrame, lineWidth){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			RETURN_LONG(obj->lineWidth());
-	}
+
+ZEND_METHOD(QFrame, lineWidth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'lineWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->lineWidth());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFrame::lineWidth(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  drawFrame
- *    flags:    
- *    access:    protected
- *    return:    void
- *    params:    QPainter *
+/*!
+ * method frameRect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-// method drawFrame is protected, skipped.
 
-/*********************************
- *    class     QFrame
- *    function  setMidLineWidth
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
- */
-ZEND_METHOD(QFrame, setMidLineWidth){
-		/* l public*/
+ZEND_METHOD(QFrame, frameRect)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
 
-		/* int ,  */
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'frameRect' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
 
-			obj->setMidLineWidth((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      *return_object = static_cast < QRect > (selfpointer->frameRect());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFrame::frameRect(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  setFrameShadow
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    Shadow
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFrame, setFrameShadow){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+/*!
+ * method setLineWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QFrame, setLineWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setLineWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFrame *
+        selfpointer;
 
-			obj->setFrameShadow((QFrame::Shadow) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setLineWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QFrame::setLineWidth(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  trUtf8
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QFrame, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QFrame, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QFrame::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFrame_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
 
-/*********************************
- *    class     QFrame
- *    function  frameRect
- *    flags:    c
- *    access:    public
- *    return:    QRect
- *    params:    
- */
-ZEND_METHOD(QFrame, frameRect){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			QRect* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QRect) obj->frameRect();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFrame_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+      *return_object = static_cast < QSize > (selfpointer->sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFrame::sizeHint(...) ");
 }
 
-/*********************************
- *    class     QFrame
- *    function  frameStyle
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QFrame, frameStyle){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			RETURN_LONG(obj->frameStyle());
-	}
-}
 
+ZEND_METHOD(QFrame, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-PHP_QT_DESTRUCT(QFrame);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QFrame *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QFrame::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QFrame * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QFrame::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QFrame::trUtf8(...) ");
+}

Modified: trunk/qt/classes/qgridlayout.cpp
===================================================================
--- trunk/qt/classes/qgridlayout.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qgridlayout.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QGridLayout.cpp - QGridLayout PHP implementation.
- * begin           : Tue Apr 11 10:33:13 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -31,1177 +30,1844 @@
 
 
 #include <QGridLayout>
-#include <QWidget>
-
-/*!
- *    @class     QGridLayout
- *    @function  tr
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
- */
-ZEND_METHOD(QGridLayout, tr)
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QGridLayout_php_qt:public QGridLayout
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+public:
+  QGridLayout_php_qt(zval * zend_ptr, QWidget * parents0);
+  QGridLayout_php_qt(zval * zend_ptr);
 
-        QString *return_object;
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast < QString > (obj->tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QGridLayout::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));   /// memory allocation
-          *return_object = static_cast < QString > (QGridLayout::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
-        object_init_ex(return_value, QGridLayout_ce_ptr);
-        zend_rsrc_list_entry le;
+QGridLayout_php_qt::QGridLayout_php_qt(zval * zend_ptr, QWidget * parents0):QGridLayout(parents0)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QGridLayout",&staticMetaObject));
+}
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+QGridLayout_php_qt::QGridLayout_php_qt(zval * zend_ptr):QGridLayout()
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QGridLayout",&staticMetaObject));
 }
 
+PHP_QT_MOC(QGridLayout);
+
 /*!
- *    @class     QGridLayout
- *    @function  addLayout
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QLayout *, int row, int column, Qt::Alignment = 0
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QGridLayout, addLayout)
+
+ZEND_METHOD(QGridLayout, tr)
 {
-///qt_QLayout*
-/*! olll public*/
-/*! qt_QLayout* , int row, int column, int ,  */
-  if (ZEND_NUM_ARGS() == 4) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QGridLayout *
+        selfpointer;
 
-        if (obj_z_0->inherits("QLayout")) {
-          void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-          if (getThis() != NULL) {
-            obj->addLayout((QLayout *) obj_z_0, (int)Z_LVAL_P(z_1), (int)Z_LVAL_P(z_2), (Qt::Alignment) Z_LVAL_P(z_3));
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QGridLayout::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
       } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QGridLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QGridLayout::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QGridLayout::tr(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  QGridLayout
- *
- *    @flags    t
- *    @access    public
- *    @return    
- *    @param    QWidget *parent
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QGridLayout, __construct)
+
+/*!
+ * method addItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *items0
+ * @param	 int rows1
+ * @param	 int columns2
+ * @param	 int rowSpan = 1s3
+ * @param	 int columnSpan = 1s4
+ * @param	 Qt::Alignment = 0s5
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QGridLayout, addItem)
 {
-///QWidget*
-	if (ZEND_NUM_ARGS() == 0){
-			QGridLayout *QGridLayout_ptr = new QGridLayout();
-				PHP_QT_REGISTER(QGridLayout_ptr);
-				RETURN_NULL();
-	}
-/*! o public*/
-/*! QWidget* parent,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///QLayoutItem *items0, int rows1, int columns2, int rowSpan = 1s3, int columnSpan = 1s4, Qt::Alignment = 0s5
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addItem' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayoutItem *items0, int rows1, int columns2,
+        QGridLayout *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QLayoutItem *
+          cpp_arg_0 = static_cast < QLayoutItem * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QWidget")) {
-          QGridLayout *QGridLayout_ptr = new QGridLayout((QWidget *) obj_z_0);
+        RETURN_VOID(selfpointer->addItem((QLayoutItem *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-          PHP_QT_REGISTER(QGridLayout_ptr);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addItem' is not static");
           RETURN_NULL();
         }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
+        /// try QLayoutItem *items0, int rows1, int columns2, int rowSpan = 1s3,
+        QGridLayout *
+          selfpointer;
 
-/*!
- *    @class     QGridLayout
- *    @function  addItem
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QLayoutItem *item, int row, int column, int rowSpan = 1, int columnSpan = 1, Qt::Alignment = 0
- */
-ZEND_METHOD(QGridLayout, addItem)
-{
-///qt_QLayoutItem*
-/*! olllll public*/
-/*! qt_QLayoutItem* item, int row, int column, int rowSpan, int columnSpan, int ,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QLayoutItem *
+          cpp_arg_0 = static_cast < QLayoutItem * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->addItem((QLayoutItem *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addItem' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayoutItem *items0, int rows1, int columns2, int rowSpan = 1s3, int columnSpan = 1s4,
+        QGridLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QLayoutItem *
+          cpp_arg_0 = static_cast < QLayoutItem * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->addItem((QLayoutItem *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4)));
+      }
+#endif
+
+    }
+  }
   if (ZEND_NUM_ARGS() == 6) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
-    zval *z_4;                  /// define ZVAL
-    zval *z_5;                  /// define ZVAL
+    PHP_QT_FETCH_6_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG && Z_TYPE_P(arg_5) == IS_LONG) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addItem' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayoutItem *items0, int rows1, int columns2, int rowSpan = 1s3, int columnSpan = 1s4, Qt::Alignment = 0s5,
+        QGridLayout *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zzzzzz", &z_0, &z_1, &z_2, &z_3, &z_4, &z_5) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG &&
-          Z_TYPE_P(z_5) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QLayoutItem *
+          cpp_arg_0 = static_cast < QLayoutItem * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QLayoutItem")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->
+                    addItem((QLayoutItem *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                            (Qt::Alignment) Z_LVAL_P(arg_5)));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->addItem((QLayoutItem *) obj_z_0, (int)Z_LVAL_P(z_1), (int)Z_LVAL_P(z_2), (int)Z_LVAL_P(z_3), (int)Z_LVAL_P(z_4),
-                         (Qt::Alignment) Z_LVAL_P(z_5));
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  ///QLayoutItem *
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+/// overloaded method is protected, skipped.
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::addItem(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  rowMinimumHeight
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    int row
+ * method rowMinimumHeight
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int rows0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QGridLayout, rowMinimumHeight)
 {
-/*! l public*/
-/*! int row,  */
+  ///int rows0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'rowMinimumHeight' is not static");
+        RETURN_NULL();
+      }
+      /// try int rows0,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-        int *return_object;
-
-        if (getThis() != NULL) {
-          RETURN_LONG(obj->rowMinimumHeight((int)Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->rowMinimumHeight((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::rowMinimumHeight(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  setOriginCorner
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::Corner
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QGridLayout, setOriginCorner)
-{
-/*! l public*/
-/*! int ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setOriginCorner((Qt::Corner) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
-
 /*!
- *    @class     QGridLayout
- *    @function  count
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method count
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QGridLayout, count)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'count' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->count());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->count());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::count(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  originCorner
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::Corner
- *    @param    
+ * method originCorner
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Corner
+ * @flags	c
  */
+
 ZEND_METHOD(QGridLayout, originCorner)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::Corner * return_object;
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'originCorner' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-      RETURN_LONG(obj->originCorner());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->originCorner());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::originCorner(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  invalidate
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method setRowStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int rows0
+ * @param	 int stretchs1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, invalidate)
+
+ZEND_METHOD(QGridLayout, setRowStretch)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+  ///int rows0, int stretchs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setRowStretch' is not static");
+        RETURN_NULL();
+      }
+      /// try int rows0, int stretchs1,
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-      obj->invalidate();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setRowStretch((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::setRowStretch(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  setGeometry
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QRect&
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QGridLayout, setGeometry)
-{
-///const QRect&
-/*! o public*/
-/*! const QRect& ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-        if (!strcmp(Z_OBJCE_P(z_0)->name, "QRect")) {
-          void *return_object;
-
-          if (getThis() != NULL) {
-            obj->setGeometry((const QRect &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
-
 /*!
- *    @class     QGridLayout
- *    @function  setRowStretch
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int row, int stretch
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QGridLayout, setRowStretch)
+
+ZEND_METHOD(QGridLayout, staticMetaObject)
 {
-/*! ll public*/
-/*! int row, int stretch,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-        void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-          obj->setRowStretch((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QGridLayout::staticMetaObject());
       } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QGridLayout::staticMetaObject(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  getItemPosition
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int idx, int *row, int *column, int *rowSpan, int *columnSpan
+ * method itemAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, getItemPosition)
+
+ZEND_METHOD(QGridLayout, itemAt)
 {
-/*! lllll public*/
-/*! int idx, int* row, int* column, int* rowSpan, int* columnSpan,  */
-  if (ZEND_NUM_ARGS() == 5) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
-    zval *z_4;                  /// define ZVAL
-
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zzzzz", &z_0, &z_1, &z_2, &z_3, &z_4) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->getItemPosition((int)Z_LVAL_P(z_0), (int *)Z_LVAL_P(z_1), (int *)Z_LVAL_P(z_2), (int *)Z_LVAL_P(z_3), (int *)Z_LVAL_P(z_4));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+// notice: abstract class QLayoutItem cannot be instanciated, skipped
+  php_error(E_ERROR, "could not parse argument in QGridLayout::itemAt(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  setDefaultPositioning
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int n, Qt::Orientation orient
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, setDefaultPositioning)
+
+/*!
+ * method setColumnMinimumWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int columns0
+ * @param	 int minSizes1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QGridLayout, setColumnMinimumWidth)
 {
-/*! ll public*/
-/*! int n, int orient,  */
+  ///int columns0, int minSizes1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setColumnMinimumWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int columns0, int minSizes1,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setDefaultPositioning((int)Z_LVAL_P(z_0), (Qt::Orientation) Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setColumnMinimumWidth((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::setColumnMinimumWidth(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  columnStretch
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    int column
+ * method heightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, columnStretch)
+
+ZEND_METHOD(QGridLayout, heightForWidth)
 {
-/*! l public*/
-/*! int column,  */
+  ///int ints0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'heightForWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->heightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::heightForWidth(...) ");
+}
 
-        int *return_object;
+/*!
+ * method hasHeightForWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-        if (getThis() != NULL) {
-          RETURN_LONG(obj->columnStretch((int)Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+ZEND_METHOD(QGridLayout, hasHeightForWidth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hasHeightForWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->hasHeightForWidth());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::hasHeightForWidth(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  addWidget
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QWidget *w
+ * method rowCount
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, addWidget)
+
+ZEND_METHOD(QGridLayout, rowCount)
 {
-///QWidget*
-	if (ZEND_NUM_ARGS() == 5){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-        zval *z_3; // define ZVAL
-        zval *z_4; // define ZVAL
-        
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzz", &z_0, &z_1, &z_2, &z_3, &z_4) == SUCCESS) {
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'rowCount' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-//			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG){
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->rowCount());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::rowCount(...) ");
+}
 
-			    QGridLayout *obj = (QGridLayout*) PHP_QT_FETCH();
-			    QWidget* obj_z_0 = static_cast<QWidget*>(php_qt_fetch(z_0));
+/*!
+ * method cellRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int rows0
+ * @param	 int columns1
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
+ */
 
-			    if(obj_z_0->inherits("QWidget")) {
-				    obj->addWidget(obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (Qt::Alignment) Z_LVAL_P(z_4));
-			        RETURN_NULL();
-			    } else { php_error(E_ERROR,"argument is no QWidget"); }
-//			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
-///QWidget*
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-//			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			    QGridLayout *obj = (QGridLayout*) PHP_QT_FETCH();
-			    QWidget* obj_z_0 = static_cast<QWidget*>(php_qt_fetch(z_0));
+ZEND_METHOD(QGridLayout, cellRect)
+{
+  ///int rows0, int columns1
+#ifdef PHP_QT_QRect             // return type
 
-			    if(obj_z_0->inherits("QWidget")) {
-				    obj->addWidget(obj_z_0, (int) Z_LVAL_P(z_1), (Qt::Alignment) Z_LVAL_P(z_2));
-			        RETURN_NULL();
-			    } else { php_error(E_ERROR,"argument is no QWidget"); }
-//			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
-/*! o public*/
-/*! QWidget* w,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'cellRect' is not static");
+        RETURN_NULL();
+      }
+      /// try int rows0, int columns1,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (obj_z_0->inherits("QWidget")) {
-          void *return_object;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
 
-          if (getThis() != NULL) {
-            obj->addWidget((QWidget *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      *return_object = static_cast < QRect > (selfpointer->cellRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QGridLayout::cellRect(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  takeAt
- *
- *    @flags    
- *    @access    public
- *    @return    QLayoutItem *
- *    @param    int
+ * method columnMinimumWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int columns0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, takeAt)
+
+ZEND_METHOD(QGridLayout, columnMinimumWidth)
 {
-/*! l public*/
-/*! int ,  */
+  ///int columns0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'columnMinimumWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int columns0,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->columnMinimumWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::columnMinimumWidth(...) ");
+}
 
-        QLayoutItem **return_object;
+/*!
+ * method minimumHeightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-        if (getThis() != NULL) {
-/// return: pointer
+ZEND_METHOD(QGridLayout, minimumHeightForWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumHeightForWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QGridLayout *
+        selfpointer;
 
-/// return value is object: QLayoutItem *
-          *return_object = static_cast < QLayoutItem * >(obj->takeAt((int)Z_LVAL_P(z_0)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, "Object not found");
-        }
-        zend_class_entry *ce;
-
-        object_init_ex(return_value, QGridLayout_ce_ptr);
-        zend_rsrc_list_entry le;
-
-        le.ptr = return_object[0];
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->minimumHeightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::minimumHeightForWidth(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  staticMetaObject
- *
- *    @flags    s
- *    @access    public
- *    @return    QMetaObject*
- *    @param    
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QGridLayout, staticMetaObject)
+
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	c
+ */
+
+ZEND_METHOD(QGridLayout, expandingDirections)
 {
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'expandingDirections' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->expandingDirections());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::expandingDirections(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  itemAt
- *
- *    @flags    c
- *    @access    public
- *    @return    QLayoutItem *
- *    @param    int
+ * method addLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayout *s0
+ * @param	 int rows1
+ * @param	 int columns2
+ * @param	 Qt::Alignment = 0s3
+ * 
+ * overloaded args:
+ * @param	QLayout *
+ * @param	 int row
+ * @param	 int column
+ * @param	 int rowSpan
+ * @param	 int columnSpan
+ * @param	 Qt::Alignment = 0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, itemAt)
+
+ZEND_METHOD(QGridLayout, addLayout)
 {
-/*! l public*/
-/*! int ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///QLayout *s0, int rows1, int columns2, Qt::Alignment = 0s3
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addLayout' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayout *s0, int rows1, int columns2,
+        QGridLayout *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast < QLayout * >(php_qt_fetch(arg_0));
 
-        QLayoutItem **return_object;
+        RETURN_VOID(selfpointer->addLayout((QLayout *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addLayout' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayout *s0, int rows1, int columns2, Qt::Alignment = 0s3,
+        QGridLayout *
+          selfpointer;
+
         if (getThis() != NULL) {
-/// return: pointer
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast < QLayout * >(php_qt_fetch(arg_0));
 
-/// return value is object: QLayoutItem *
-          *return_object = static_cast < QLayoutItem * >(obj->itemAt((int)Z_LVAL_P(z_0)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, "Object not found");
+        RETURN_VOID(selfpointer->addLayout((QLayout *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (Qt::Alignment) Z_LVAL_P(arg_3)));
+      }
+#endif
+
+    }
+  }
+  ///QLayout *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addLayout' is not static");
+          RETURN_NULL();
         }
-        zend_class_entry *ce;
+        /// try QLayout *, int row, int column, int rowSpan, int columnSpan,
+        QGridLayout *
+          selfpointer;
 
-        object_init_ex(return_value, QGridLayout_ce_ptr);
-        zend_rsrc_list_entry le;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast < QLayout * >(php_qt_fetch(arg_0));
 
-        le.ptr = return_object[0];
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->addLayout((QLayout *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG && Z_TYPE_P(arg_5) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addLayout' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayout *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0,
+        QGridLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast < QLayout * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->
+                    addLayout((QLayout *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                              (Qt::Alignment) Z_LVAL_P(arg_5)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::addLayout(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  qObject
- *
- *    @flags    
- *    @access    public
- *    @return    QObject*
- *    @param    
+ * method QGridLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parents0s0
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QGridLayout &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QGridLayout, qObject)
-{
-}
 
-/*!
- *    @class     QGridLayout
- *    @function  minimumSize
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
- */
-ZEND_METHOD(QGridLayout, minimumSize)
+ZEND_METHOD(QGridLayout, __construct)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+  ///QWidget *parents0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *parents0s0,
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+        QGridLayout_php_qt *
+          selfpointer = new QGridLayout_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->minimumSize());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
     }
-    zend_class_entry *ce;
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout_php_qt *
+        selfpointer = new QGridLayout_php_qt(getThis());
 
-    object_init_ex(return_value, QGridLayout_ce_ptr);
-    zend_rsrc_list_entry le;
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QGridLayout &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QGridLayout
+      if (inherits(Z_OBJCE_P(arg_0), 26)) {
+/// method is private, skip
+        php_error(E_ERROR, "QGridLayout::__construct(...) cannot be called with 'const QGridLayout &,'.");
+      }
+#endif
 
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::QGridLayout(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  sizeHint
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method setOriginCorner
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Corner Qt::Corners0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, sizeHint)
+
+ZEND_METHOD(QGridLayout, setOriginCorner)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+  ///Qt::Corner Qt::Corners0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setOriginCorner' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::Corner Qt::Corners0,
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->sizeHint());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setOriginCorner((Qt::Corner) Z_LVAL_P(arg_0)));
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QGridLayout_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::setOriginCorner(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  setColumnMinimumWidth
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int column, int minSize
+ * method invalidate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, setColumnMinimumWidth)
+
+ZEND_METHOD(QGridLayout, invalidate)
 {
-/*! ll public*/
-/*! int column, int minSize,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'invalidate' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setColumnMinimumWidth((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->invalidate());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::invalidate(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  heightForWidth
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    int
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, heightForWidth)
+
+ZEND_METHOD(QGridLayout, setGeometry)
 {
-/*! l public*/
-/*! int ,  */
+  ///const QRect &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setGeometry' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &s0,
+        QGridLayout *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
-        int *return_object;
+        RETURN_VOID(selfpointer->setGeometry((const QRect &)*cpp_arg_0));
+      }
+#endif
 
-        if (getThis() != NULL) {
-          RETURN_LONG(obj->heightForWidth((int)Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::setGeometry(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  hasHeightForWidth
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method getItemPosition
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int idxs0
+ * @param	 int *rows1
+ * @param	 int *columns2
+ * @param	 int *rowSpans3
+ * @param	 int *columnSpans4
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, hasHeightForWidth)
+
+ZEND_METHOD(QGridLayout, getItemPosition)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+  ///int idxs0, int *rows1, int *columns2, int *rowSpans3, int *columnSpans4
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'getItemPosition' is not static");
+        RETURN_NULL();
+      }
+      /// try int idxs0, int *rows1, int *columns2, int *rowSpans3, int *columnSpans4,
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->hasHeightForWidth());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->
+                  getItemPosition((int)Z_LVAL_P(arg_0), (int *)&Z_LVAL_P(arg_1), (int *)&Z_LVAL_P(arg_2), (int *)&Z_LVAL_P(arg_3), (int *)&Z_LVAL_P(arg_4)));
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::getItemPosition(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  setColumnStretch
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int column, int stretch
+ * method setDefaultPositioning
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ns0
+ * @param	 Qt::Orientation orients1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, setColumnStretch)
+
+ZEND_METHOD(QGridLayout, setDefaultPositioning)
 {
-/*! ll public*/
-/*! int column, int stretch,  */
+  ///int ns0, Qt::Orientation orients1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setDefaultPositioning' is not static");
+        RETURN_NULL();
+      }
+      /// try int ns0, Qt::Orientation orients1,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setColumnStretch((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setDefaultPositioning((int)Z_LVAL_P(arg_0), (Qt::Orientation) Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::setDefaultPositioning(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  rowCount
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method columnStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int columns0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, rowCount)
+
+ZEND_METHOD(QGridLayout, columnStretch)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+  ///int columns0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'columnStretch' is not static");
+        RETURN_NULL();
+      }
+      /// try int columns0,
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->rowCount());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->columnStretch((int)Z_LVAL_P(arg_0)));
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::columnStretch(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  columnMinimumWidth
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    int column
+ * method takeAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, columnMinimumWidth)
+
+ZEND_METHOD(QGridLayout, takeAt)
 {
-/*! l public*/
-/*! int column,  */
+// notice: abstract class QLayoutItem cannot be instanciated, skipped
+  php_error(E_ERROR, "could not parse argument in QGridLayout::takeAt(...) ");
+}
+
+/*!
+ * method addWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * 
+ * overloaded args:
+ * @param	QWidget *
+ * @param	 int row
+ * @param	 int column
+ * @param	 Qt::Alignment = 0
+ * 
+ * overloaded args:
+ * @param	QWidget *
+ * @param	 int row
+ * @param	 int column
+ * @param	 int rowSpan
+ * @param	 int columnSpan
+ * @param	 Qt::Alignment = 0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QGridLayout, addWidget)
+{
+  ///QWidget *ws0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0,
+        QGridLayout *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
-        int *return_object;
+        RETURN_VOID(selfpointer->addWidget((QWidget *) cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///QWidget *, int row, int column, Qt::Alignment = 0
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *, int row, int column,
+        QGridLayout *
+          selfpointer;
+
         if (getThis() != NULL) {
-          RETURN_LONG(obj->columnMinimumWidth((int)Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
-/*!
- *    @class     QGridLayout
- *    @function  cellRect
- *
- *    @flags    c
- *    @access    public
- *    @return    QRect
- *    @param    int row, int column
- */
-ZEND_METHOD(QGridLayout, cellRect)
-{
-/*! ll public*/
-/*! int row, int column,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+        RETURN_VOID(selfpointer->addWidget((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *, int row, int column, Qt::Alignment = 0,
+        QGridLayout *
+          selfpointer;
 
-        QRect *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->addWidget((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (Qt::Alignment) Z_LVAL_P(arg_3)));
+      }
+#endif
+
+    }
+  }
+  ///QWidget *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *, int row, int column, int rowSpan, int columnSpan,
+        QGridLayout *
+          selfpointer;
+
         if (getThis() != NULL) {
-/// return value is object: QRect
-          *return_object = static_cast < QRect > (obj->cellRect((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, "Object not found");
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
         }
-        zend_class_entry *ce;
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
-        object_init_ex(return_value, QGridLayout_ce_ptr);
-        zend_rsrc_list_entry le;
+        RETURN_VOID(selfpointer->addWidget((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4)));
+      }
+#endif
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG && Z_TYPE_P(arg_5) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0,
+        QGridLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->
+                    addWidget((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                              (Qt::Alignment) Z_LVAL_P(arg_5)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::addWidget(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  columnCount
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, columnCount)
+
+ZEND_METHOD(QGridLayout, minimumSize)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-      RETURN_LONG(obj->columnCount());
-    }                           /// 5 END getThis(), simple types
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->minimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QGridLayout::minimumSize(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  setRowMinimumHeight
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int row, int minSize
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, setRowMinimumHeight)
+
+ZEND_METHOD(QGridLayout, sizeHint)
 {
-/*! ll public*/
-/*! int row, int minSize,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-        void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-          obj->setRowMinimumHeight((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QGridLayout::sizeHint(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  trUtf8
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method setColumnStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int columns0
+ * @param	 int stretchs1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, trUtf8)
+
+ZEND_METHOD(QGridLayout, setColumnStretch)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
+  ///int columns0, int stretchs1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setColumnStretch' is not static");
+        RETURN_NULL();
+      }
+      /// try int columns0, int stretchs1,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setColumnStretch((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::setColumnStretch(...) ");
+}
 
-        QString *return_object;
+/*!
+ * method columnCount
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast < QString > (obj->trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QGridLayout::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));       /// memory allocation
-          *return_object = static_cast < QString > (QGridLayout::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+ZEND_METHOD(QGridLayout, columnCount)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'columnCount' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-        object_init_ex(return_value, QGridLayout_ce_ptr);
-        zend_rsrc_list_entry le;
-
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->columnCount());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::columnCount(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  maximumSize
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method setRowMinimumHeight
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int rows0
+ * @param	 int minSizes1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, maximumSize)
+
+ZEND_METHOD(QGridLayout, setRowMinimumHeight)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+  ///int rows0, int minSizes1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setRowMinimumHeight' is not static");
+        RETURN_NULL();
+      }
+      /// try int rows0, int minSizes1,
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->maximumSize());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setRowMinimumHeight((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QGridLayout_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::setRowMinimumHeight(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  minimumHeightForWidth
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    int
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QGridLayout, minimumHeightForWidth)
+
+ZEND_METHOD(QGridLayout, trUtf8)
 {
-/*! l public*/
-/*! int ,  */
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        int *return_object;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        if (getThis() != NULL) {
-          RETURN_LONG(obj->minimumHeightForWidth((int)Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QGridLayout::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
       } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QGridLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QGridLayout::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QGridLayout::trUtf8(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  expandingDirections
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::Orientations
- *    @param    
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, expandingDirections)
+
+ZEND_METHOD(QGridLayout, maximumSize)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::Orientations * return_object;
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'maximumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-      obj->expandingDirections();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->maximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QGridLayout::maximumSize(...) ");
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  rowStretch
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    int row
+ * method rowStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int rows0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QGridLayout, rowStretch)
 {
-/*! l public*/
-/*! int row,  */
+  ///int rows0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'rowStretch' is not static");
+        RETURN_NULL();
+      }
+      /// try int rows0,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-        int *return_object;
-
-        if (getThis() != NULL) {
-          RETURN_LONG(obj->rowStretch((int)Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QGridLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->rowStretch((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QGridLayout::rowStretch(...) ");
 }
-
-
-PHP_QT_DESTRUCT(QGridLayout);

Modified: trunk/qt/classes/qhboxlayout.cpp
===================================================================
--- trunk/qt/classes/qhboxlayout.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qhboxlayout.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,133 +19,412 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QHBoxLayout.cpp - QHBoxLayout PHP implementation.
- * begin           : Thu Feb 23 16:39:38 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
+
 #include "../php_qt.h"
 
 
 #include <QHBoxLayout>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QHBoxLayout_php_qt:public QHBoxLayout
+{
 
-/*********************************
- *    class     QHBoxLayout
- *    function  tr
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
- */
-ZEND_METHOD(QHBoxLayout, tr){
-		/* ss public*/
+public:
+  QHBoxLayout_php_qt(zval * zend_ptr);
+  QHBoxLayout_php_qt(zval * zend_ptr, QWidget * parents0);
 
-		/* const char* , const char* ,  */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QHBoxLayout *obj = (QHBoxLayout*) PHP_QT_FETCH();
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
+QHBoxLayout_php_qt::QHBoxLayout_php_qt(zval * zend_ptr):QHBoxLayout()
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QHBoxLayout",&staticMetaObject));
+}
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QHBoxLayout::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QHBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+QHBoxLayout_php_qt::QHBoxLayout_php_qt(zval * zend_ptr, QWidget * parents0):QHBoxLayout(parents0)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QHBoxLayout",&staticMetaObject));
 }
 
-/*********************************
- *    class     QHBoxLayout
- *    function  staticMetaObject
- *    flags:    s
- *    access:    public
- *    return:    QMetaObject*
- *    params:    
+PHP_QT_MOC(QHBoxLayout);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QHBoxLayout, staticMetaObject){
+
+ZEND_METHOD(QHBoxLayout, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QHBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QHBoxLayout::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QHBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QHBoxLayout::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QHBoxLayout::tr(...) ");
 }
 
-/*********************************
- *    class     QHBoxLayout
- *    function  qObject
- *    flags:    
- *    access:    public
- *    return:    QObject*
- *    params:    
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QHBoxLayout, qObject){
-}
 
-/*********************************
- *    class     QHBoxLayout
- *    function  QHBoxLayout
- *    flags:    
- *    access:    public
- *    return:    
- *    params:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QHBoxLayout, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QHBoxLayout *QHBoxLayout_ptr = new QHBoxLayout();
-				PHP_QT_REGISTER(QHBoxLayout_ptr);
-				RETURN_NULL();
-	}
+
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
+
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
+
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
+
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
+ */
+
+ZEND_METHOD(QHBoxLayout, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QHBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QHBoxLayout::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QHBoxLayout::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QHBoxLayout
- *    function  trUtf8
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QHBoxLayout, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+/*!
+ * method QHBoxLayout
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parents0
+ * 
+ * overloaded args:
+ * @param	const QHBoxLayout &
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QHBoxLayout *obj = (QHBoxLayout*) PHP_QT_FETCH();
+ZEND_METHOD(QHBoxLayout, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QHBoxLayout_php_qt *
+        selfpointer = new QHBoxLayout_php_qt(getThis());
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QWidget *parents0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *parents0,
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+        QHBoxLayout_php_qt *
+          selfpointer = new QHBoxLayout_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QHBoxLayout::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QHBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QHBoxLayout &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QHBoxLayout
+      if (inherits(Z_OBJCE_P(arg_0), 27)) {
+/// method is private, skip
+        php_error(E_ERROR, "QHBoxLayout::__construct(...) cannot be called with 'const QHBoxLayout &,'.");
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QHBoxLayout::QHBoxLayout(...) ");
 }
 
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-PHP_QT_DESTRUCT(QHBoxLayout);
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
 
+ZEND_METHOD(QHBoxLayout, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QHBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QHBoxLayout::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QHBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QHBoxLayout::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QHBoxLayout::trUtf8(...) ");
+}

Modified: trunk/qt/classes/qhelpevent.cpp
===================================================================
--- trunk/qt/classes/qhelpevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qhelpevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,107 +19,271 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QHelpEvent.cpp - QHelpEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QHelpEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QHelpEvent */
-/*
- *    function  y
- *    flags:    c
+#include <QHelpEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QHelpEvent_php_qt:public QHelpEvent
+{
+
+public:
+  QHelpEvent_php_qt(zval * zend_ptr, Type types0, const QPoint & poss1, const QPoint & globalPoss2);
+
+
+  zval *zend_ptr;
+};
+QHelpEvent_php_qt::QHelpEvent_php_qt(zval * zend_ptr, Type types0, const QPoint & poss1, const QPoint & globalPoss2):
+QHelpEvent(types0, poss1, globalPoss2)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method y
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QHelpEvent, y){
-	if (ZEND_NUM_ARGS() == 0){
-			QHelpEvent *obj = (QHelpEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->y());
-	}
+
+ZEND_METHOD(QHelpEvent, y)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'y' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QHelpEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHelpEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->y());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QHelpEvent::y(...) ");
 }
 
-/*********************************
- *    class     QHelpEvent */
-/*
- *    function  globalY
- *    flags:    c
+/*!
+ * method QHelpEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	const QPoint &poss1s1
+ * @param	const QPoint &globalPoss2s2
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QHelpEvent, globalY){
-	if (ZEND_NUM_ARGS() == 0){
-			QHelpEvent *obj = (QHelpEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->globalY());
-	}
+
+ZEND_METHOD(QHelpEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+  php_error(E_ERROR, "could not parse argument in QHelpEvent::QHelpEvent(...) ");
 }
 
-/*********************************
- *    class     QHelpEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint&
+ * @flags	c
  */
-ZEND_METHOD(QHelpEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QHelpEvent *obj = (QHelpEvent*) PHP_QT_FETCH();
-				const QPoint& return_object = (const QPoint&) obj->pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QHelpEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QHelpEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QHelpEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHelpEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QHelpEvent::pos(...) ");
 }
 
-/*********************************
- *    class     QHelpEvent */
-/*
- *    function  x
- *    flags:    c
+/*!
+ * method globalPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint&
+ * @flags	c
  */
-ZEND_METHOD(QHelpEvent, x){
-	if (ZEND_NUM_ARGS() == 0){
-			QHelpEvent *obj = (QHelpEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->x());
-	}
+
+ZEND_METHOD(QHelpEvent, globalPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalPos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QHelpEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHelpEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->globalPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QHelpEvent::globalPos(...) ");
 }
 
-/*********************************
- *    class     QHelpEvent */
-/*
- *    function  globalPos
- *    flags:    c
+/*!
+ * method globalX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QHelpEvent, globalPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QHelpEvent *obj = (QHelpEvent*) PHP_QT_FETCH();
-				const QPoint& return_object = (const QPoint&) obj->globalPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QHelpEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QHelpEvent, globalX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalX' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QHelpEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHelpEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->globalX());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QHelpEvent::globalX(...) ");
 }
 
-/*********************************
- *    class     QHelpEvent */
-/*
- *    function  globalX
- *    flags:    c
+/*!
+ * method x
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QHelpEvent, globalX){
-	if (ZEND_NUM_ARGS() == 0){
-			QHelpEvent *obj = (QHelpEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->globalX());
-	}
+
+ZEND_METHOD(QHelpEvent, x)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'x' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QHelpEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHelpEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->x());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QHelpEvent::x(...) ");
 }
 
+/*!
+ * method globalY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QHelpEvent);
+ZEND_METHOD(QHelpEvent, globalY)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalY' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QHelpEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHelpEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->globalY());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QHelpEvent::globalY(...) ");
+}

Modified: trunk/qt/classes/qhideevent.cpp
===================================================================
--- trunk/qt/classes/qhideevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qhideevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,62 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QHideEvent.cpp - QHideEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QHideEvent>
 #include "../php_qt.h"
 
 
+#include <QHideEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QHideEvent_php_qt:public QHideEvent
+{
 
-PHP_QT_DESTRUCT(QHideEvent);
+public:
+  QHideEvent_php_qt(zval * zend_ptr);
 
+
+  zval *zend_ptr;
+};
+
+QHideEvent_php_qt::QHideEvent_php_qt(zval * zend_ptr):QHideEvent()
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QHideEvent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QHideEvent, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QHideEvent_php_qt *
+        selfpointer = new QHideEvent_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QHideEvent::QHideEvent(...) ");
+}

Modified: trunk/qt/classes/qhoverevent.cpp
===================================================================
--- trunk/qt/classes/qhoverevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qhoverevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,55 +19,139 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QHoverEvent.cpp - QHoverEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QHoverEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QHoverEvent */
-/*
- *    function  oldPos
- *    flags:    c
+#include <QHoverEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QHoverEvent_php_qt:public QHoverEvent
+{
+
+public:
+  QHoverEvent_php_qt(zval * zend_ptr, Type types0, const QPoint & poss1, const QPoint & oldPoss2);
+
+
+  zval *zend_ptr;
+};
+QHoverEvent_php_qt::QHoverEvent_php_qt(zval * zend_ptr, Type types0, const QPoint & poss1, const QPoint & oldPoss2):
+QHoverEvent(types0, poss1, oldPoss2)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &
+ * @flags	c
  */
-ZEND_METHOD(QHoverEvent, oldPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QHoverEvent *obj = (QHoverEvent*) PHP_QT_FETCH();
-				const QPoint & return_object = (const QPoint &) obj->oldPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QHoverEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QHoverEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QHoverEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHoverEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QHoverEvent::pos(...) ");
 }
 
-/*********************************
- *    class     QHoverEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method QHoverEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	const QPoint &poss1s1
+ * @param	const QPoint &oldPoss2s2
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QHoverEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QHoverEvent *obj = (QHoverEvent*) PHP_QT_FETCH();
-				const QPoint & return_object = (const QPoint &) obj->pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QHoverEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QHoverEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+  php_error(E_ERROR, "could not parse argument in QHoverEvent::QHoverEvent(...) ");
 }
 
+/*!
+ * method oldPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QHoverEvent);
+ZEND_METHOD(QHoverEvent, oldPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'oldPos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QHoverEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QHoverEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->oldPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QHoverEvent::oldPos(...) ");
+}

Modified: trunk/qt/classes/qicondragevent.cpp
===================================================================
--- trunk/qt/classes/qicondragevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qicondragevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,62 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QIconDragEvent.cpp - QIconDragEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QIconDragEvent>
 #include "../php_qt.h"
 
 
+#include <QIconDragEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QIconDragEvent_php_qt:public QIconDragEvent
+{
 
-PHP_QT_DESTRUCT(QIconDragEvent);
+public:
+  QIconDragEvent_php_qt(zval * zend_ptr);
 
+
+  zval *zend_ptr;
+};
+
+QIconDragEvent_php_qt::QIconDragEvent_php_qt(zval * zend_ptr):QIconDragEvent()
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QIconDragEvent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QIconDragEvent, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QIconDragEvent_php_qt *
+        selfpointer = new QIconDragEvent_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QIconDragEvent::QIconDragEvent(...) ");
+}

Modified: trunk/qt/classes/qinputevent.cpp
===================================================================
--- trunk/qt/classes/qinputevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qinputevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,36 +19,84 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QInputEvent.cpp - QInputEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QInputEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QInputEvent */
-/*
- *    function  modifiers
- *    flags:    c
+#include <QInputEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QInputEvent_php_qt:public QInputEvent
+{
+
+public:
+  QInputEvent_php_qt(zval * zend_ptr, Type types0, Qt::KeyboardModifiers modifiers = Qt::NoModifier);
+
+
+  zval *zend_ptr;
+};
+
+QInputEvent_php_qt::QInputEvent_php_qt(zval * zend_ptr, Type types0, Qt::KeyboardModifiers modifiers):QInputEvent(types0, modifiers)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QInputEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	 Qt::KeyboardModifiers modifiers = Qt::NoModifiers1
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QInputEvent, modifiers){
-	if (ZEND_NUM_ARGS() == 0){
-			QInputEvent *obj = (QInputEvent*) PHP_QT_FETCH();
-				Qt::KeyboardModifiers return_object = (Qt::KeyboardModifiers) obj->modifiers();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QInputEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QInputEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+  php_error(E_ERROR, "could not parse argument in QInputEvent::QInputEvent(...) ");
 }
 
+/*!
+ * method modifiers
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::KeyboardModifiers
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QInputEvent);
+ZEND_METHOD(QInputEvent, modifiers)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'modifiers' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QInputEvent *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QInputEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->modifiers());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QInputEvent::modifiers(...) ");
+}

Modified: trunk/qt/classes/qinputmethodevent.cpp
===================================================================
--- trunk/qt/classes/qinputmethodevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qinputmethodevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,119 +19,420 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QInputMethodEvent.cpp - QInputMethodEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QInputMethodEvent>
 #include "../php_qt.h"
 
 
+#include <QInputMethodEvent>
+#include <QMetaMethod>
+class QInputMethodEvent_php_qt:public QInputMethodEvent
+{
 
-/*		public enumAttributeType:long {
-			AttributeType = 0,
-			AttributeType = 0,
-			AttributeType = 0,
-			AttributeType = 0,
-		}
-*/
-/*********************************
- *    class     QInputMethodEvent */
-/*
- *    function  commitString
- *    flags:    c
+public:
+  QInputMethodEvent_php_qt(zval * zend_ptr);
+  QInputMethodEvent_php_qt(zval * zend_ptr, const QString & preeditTexts0, const QList < Attribute > &attributess1);
+    QInputMethodEvent_php_qt(zval * zend_ptr, const QInputMethodEvent & others0);
+
+
+  zval *zend_ptr;
+};
+
+QInputMethodEvent_php_qt::QInputMethodEvent_php_qt(zval * zend_ptr):QInputMethodEvent()
+{
+  this->zend_ptr = zend_ptr;
+}
+QInputMethodEvent_php_qt::QInputMethodEvent_php_qt(zval * zend_ptr, const QString & preeditTexts0, const QList < Attribute > &attributess1):
+QInputMethodEvent(preeditTexts0, attributess1)
+{
+  this->zend_ptr = zend_ptr;
+}
+QInputMethodEvent_php_qt::QInputMethodEvent_php_qt(zval * zend_ptr, const QInputMethodEvent & others0):
+QInputMethodEvent(others0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method commitString
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QString &
+ * @flags	c
  */
-ZEND_METHOD(QInputMethodEvent, commitString){
-	if (ZEND_NUM_ARGS() == 0){
-			QInputMethodEvent *obj = (QInputMethodEvent*) PHP_QT_FETCH();
-				const QString & return_object = (const QString &) obj->commitString();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QInputMethodEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QInputMethodEvent, commitString)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'commitString' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QInputMethodEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QInputMethodEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QString & >(selfpointer->commitString());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QInputMethodEvent::commitString(...) ");
 }
 
-/*********************************
- *    class     QInputMethodEvent */
-/*
- *    function  replacementStart
- *    flags:    c
+/*!
+ * method attributes
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QList<Attribute> &
+ * @flags	c
  */
-ZEND_METHOD(QInputMethodEvent, replacementStart){
-	if (ZEND_NUM_ARGS() == 0){
-			QInputMethodEvent *obj = (QInputMethodEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->replacementStart());
-	}
+
+ZEND_METHOD(QInputMethodEvent, attributes)
+{
+  ///
+#ifdef PHP_QT_QList             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'attributes' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QInputMethodEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QInputMethodEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QList < Attribute > &>(selfpointer->attributes());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QInputMethodEvent::attributes(...) ");
 }
 
-/*********************************
- *    class     QInputMethodEvent */
-/*
- *    function  setCommitString
- *    flags:    
+/*!
+ * method replacementLength
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QInputMethodEvent, setCommitString){
-		/* oll public*/
 
-		/* const QString& commitString, int replaceFrom, int replaceLength,  */
+ZEND_METHOD(QInputMethodEvent, replacementLength)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'replacementLength' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QInputMethodEvent *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QInputMethodEvent *obj = (QInputMethodEvent*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QInputMethodEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->replacementLength());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QInputMethodEvent::replacementLength(...) ");
+}
 
+/*!
+ * method replacementStart
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				obj->setCommitString((const QString&) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QInputMethodEvent, replacementStart)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'replacementStart' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QInputMethodEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QInputMethodEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->replacementStart());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QInputMethodEvent::replacementStart(...) ");
 }
 
-/*********************************
- *    class     QInputMethodEvent */
-/*
- *    function  replacementLength
- *    flags:    c
+/*!
+ * method preeditString
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QString &
+ * @flags	c
  */
-ZEND_METHOD(QInputMethodEvent, replacementLength){
-	if (ZEND_NUM_ARGS() == 0){
-			QInputMethodEvent *obj = (QInputMethodEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->replacementLength());
-	}
+
+ZEND_METHOD(QInputMethodEvent, preeditString)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'preeditString' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QInputMethodEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QInputMethodEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QString & >(selfpointer->preeditString());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QInputMethodEvent::preeditString(...) ");
 }
 
-/*********************************
- *    class     QInputMethodEvent */
-/*
- *    function  preeditString
- *    flags:    c
+/*!
+ * method setCommitString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &commitStrings0
+ * @param	 int replaceFrom = 0s1
+ * @param	 int replaceLength = 0s2
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QInputMethodEvent, preeditString){
-	if (ZEND_NUM_ARGS() == 0){
-			QInputMethodEvent *obj = (QInputMethodEvent*) PHP_QT_FETCH();
-				const QString & return_object = (const QString &) obj->preeditString();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QInputMethodEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QInputMethodEvent, setCommitString)
+{
+  ///const QString &commitStrings0, int replaceFrom = 0s1, int replaceLength = 0s2
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setCommitString' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &commitStrings0,
+        QInputMethodEvent *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QInputMethodEvent * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setCommitString((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setCommitString' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &commitStrings0, int replaceFrom = 0s1,
+        QInputMethodEvent *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QInputMethodEvent * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setCommitString((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setCommitString' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &commitStrings0, int replaceFrom = 0s1, int replaceLength = 0s2,
+        QInputMethodEvent *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QInputMethodEvent * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setCommitString((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QInputMethodEvent::setCommitString(...) ");
 }
 
+/*!
+ * method QInputMethodEvent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &preeditTexts0
+ * @param	const QList<Attribute> &attributess1
+ * 
+ * overloaded args:
+ * @param	const QInputMethodEvent &others0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QInputMethodEvent);
+ZEND_METHOD(QInputMethodEvent, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QInputMethodEvent_php_qt *selfpointer = new QInputMethodEvent_php_qt(getThis());
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QString &preeditTexts0,const QList<Attribute> &attributess1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QList
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &preeditTexts0,const QList<Attribute> &attributess1,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        QList < Attribute > *cpp_arg_1 = static_cast < QList < Attribute > *>(php_qt_fetch(arg_1));
+        QInputMethodEvent_php_qt *selfpointer = new QInputMethodEvent_php_qt(getThis(), (const QString &)*cpp_arg_0, (const QList < Attribute > &)*cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QInputMethodEvent &others0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QInputMethodEvent
+      if (inherits(Z_OBJCE_P(arg_0), 33)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QInputMethodEvent &others0,
+        QInputMethodEvent *cpp_arg_0 = static_cast < QInputMethodEvent * >(php_qt_fetch(arg_0));
+        QInputMethodEvent_php_qt *selfpointer = new QInputMethodEvent_php_qt(getThis(), (const QInputMethodEvent &)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QInputMethodEvent::QInputMethodEvent(...) ");
+}

Modified: trunk/qt/classes/qinputmethodevent__attribute.cpp
===================================================================
--- trunk/qt/classes/qinputmethodevent__attribute.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qinputmethodevent__attribute.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,50 +19,51 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Attribute.cpp - Attribute PHP implementation.
- * begin           : Wed Jan 11 20:29:53 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <Attribute>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     Attribute */
-/*
- *    function  Attribute
- *    flags:    
- */
-ZEND_METHOD(Attribute, __construct){
+#include <Attribute>
+#include <QMetaMethod>
+class Attribute_php_qt:public Attribute
+{
 
-	if (ZEND_NUM_ARGS() == 4){
-		/* ollo */
-		zval* z_var_ollo_0;   // default: 
-		long var_ollo_1;    // default: 
-		long var_ollo_2;    // default: 
-		zval* z_var_ollo_3;   // default: 
+public:
+  Attribute_php_qt(zval * zend_ptr, AttributeType ts0, int ss1, int ls2, QVariant vals3);
 
-		/* AttributeType t, int s, int l, QVariant val,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"ollo", &z_var_ollo_0, &var_ollo_1, &var_ollo_2, &z_var_ollo_3) == SUCCESS) {
-			Attribute *obj = (Attribute*) PHP_QT_FETCH();
-			QObject* var_ollo_0 = (QObject*) php_qt_fetch(z_var_ollo_0);
-			QObject* var_ollo_3 = (QObject*) php_qt_fetch(z_var_ollo_3);
 
-			QString tmp_ollo_0(var_ollo_0->metaObject()->className());
-			QString tmp_ollo_1(var_ollo_3->metaObject()->className());
-			
-			if(tmp_ollo_0 == "AttributeType" && tmp_ollo_1 == "QVariant") {
-				Attribute *Attribute_ptr = new Attribute((AttributeType) var_ollo_0, (int) var_ollo_1, (int) var_ollo_2, (QVariant) var_ollo_3);
-			PHP_QT_REGISTER(Attribute_ptr);
-			RETURN_NULL();
-			}
-		}
-	}
+  zval *zend_ptr;
+};
+Attribute_php_qt::Attribute_php_qt(zval * zend_ptr, AttributeType ts0, int ss1, int ls2, QVariant vals3):
+Attribute(ts0, ss1, ls2, vals3)
+{
+  this->zend_ptr = zend_ptr;
 }
 
+/*!
+ * method Attribute
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	AttributeType ts0s0
+ * @param	int ss1s1
+ * @param	int ls2s2
+ * @param	QVariant vals3s3
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(Attribute);
-
+ZEND_METHOD(Attribute, __construct)
+{
+// notice: unknown argument AttributeType ts0s0, skipped
+  php_error(E_ERROR, "could not parse argument in Attribute::Attribute(...) ");
+}

Modified: trunk/qt/classes/qinternal.cpp
===================================================================
--- trunk/qt/classes/qinternal.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qinternal.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,35 +19,14 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QInternal.cpp - QInternal PHP implementation.
- * begin           : Wed Jan 11 20:29:53 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QInternal>
 #include "../php_qt.h"
 
 
-
-/*		public enumPaintDeviceFlags:long {
-			UnknownDevice = 0x00,
-			Widget = 0x01,
-			Pixmap = 0x02,
-			Image = 0x03,
-			Printer = 0x04,
-			Picture = 0x05,
-			Pbuffer = 0x06
-		}
-*/
-
-/*		public enumRelayoutType:long {
-			RelayoutType = 0,
-			RelayoutType = 1,
-			RelayoutType = 2
-		}
-*/
-
-PHP_QT_DESTRUCT(QInternal);
-
+#include <QInternal>

Modified: trunk/qt/classes/qkeyevent.cpp
===================================================================
--- trunk/qt/classes/qkeyevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qkeyevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,94 +19,234 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QKeyEvent.cpp - QKeyEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QKeyEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QKeyEvent */
-/*
- *    function  count
- *    flags:    c
+#include <QKeyEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QKeyEvent_php_qt:public QKeyEvent
+{
+
+public:
+  QKeyEvent_php_qt(zval * zend_ptr, Type types0, int keys1, Qt::KeyboardModifiers modifierss2, const QString & text = QString(), bool autorep =
+                   false, ushort count = 1);
+
+
+  zval *zend_ptr;
+};
+QKeyEvent_php_qt::QKeyEvent_php_qt(zval * zend_ptr, Type types0, int keys1, Qt::KeyboardModifiers modifierss2, const QString & text, bool autorep,
+                                   ushort count):
+QKeyEvent(types0, keys1, modifierss2, text, autorep, count)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method key
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QKeyEvent, count){
-	if (ZEND_NUM_ARGS() == 0){
-			QKeyEvent *obj = (QKeyEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->count());
-	}
+
+ZEND_METHOD(QKeyEvent, key)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'key' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QKeyEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QKeyEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->key());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QKeyEvent::key(...) ");
 }
 
-/*********************************
- *    class     QKeyEvent */
-/*
- *    function  text
- *    flags:    c
+/*!
+ * method count
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QKeyEvent, text){
-	if (ZEND_NUM_ARGS() == 0){
-			QKeyEvent *obj = (QKeyEvent*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->text();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QKeyEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QKeyEvent, count)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'count' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QKeyEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QKeyEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->count());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QKeyEvent::count(...) ");
 }
 
-/*********************************
- *    class     QKeyEvent */
-/*
- *    function  isAutoRepeat
- *    flags:    c
+/*!
+ * method text
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QKeyEvent, isAutoRepeat){
-	if (ZEND_NUM_ARGS() == 0){
-			QKeyEvent *obj = (QKeyEvent*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isAutoRepeat());
-	}
+
+ZEND_METHOD(QKeyEvent, text)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'text' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QKeyEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QKeyEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->text());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QKeyEvent::text(...) ");
 }
 
-/*********************************
- *    class     QKeyEvent */
-/*
- *    function  modifiers
- *    flags:    c
+/*!
+ * method QKeyEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	int keys1s1
+ * @param	Qt::KeyboardModifiers modifierss2s2
+ * @param	 const QString & text = QString()s3
+ * @param	 bool autorep = falses4
+ * @param	 ushort count = 1s5
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QKeyEvent, modifiers){
-	if (ZEND_NUM_ARGS() == 0){
-			QKeyEvent *obj = (QKeyEvent*) PHP_QT_FETCH();
-				Qt::KeyboardModifiers return_object = (Qt::KeyboardModifiers) obj->modifiers();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QKeyEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QKeyEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+  php_error(E_ERROR, "could not parse argument in QKeyEvent::QKeyEvent(...) ");
 }
 
-/*********************************
- *    class     QKeyEvent */
-/*
- *    function  key
- *    flags:    c
+/*!
+ * method modifiers
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::KeyboardModifiers
+ * @flags	c
  */
-ZEND_METHOD(QKeyEvent, key){
-	if (ZEND_NUM_ARGS() == 0){
-			QKeyEvent *obj = (QKeyEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->key());
-	}
+
+ZEND_METHOD(QKeyEvent, modifiers)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'modifiers' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QKeyEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QKeyEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->modifiers());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QKeyEvent::modifiers(...) ");
 }
 
+/*!
+ * method isAutoRepeat
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QKeyEvent);
+ZEND_METHOD(QKeyEvent, isAutoRepeat)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isAutoRepeat' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QKeyEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QKeyEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isAutoRepeat());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QKeyEvent::isAutoRepeat(...) ");
+}

Modified: trunk/qt/classes/qlabel.cpp
===================================================================
--- trunk/qt/classes/qlabel.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlabel.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,786 +19,1567 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLabel.cpp - QLabel PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QLabel>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  tr
- *    flags:    s
- */
-ZEND_METHOD(QLabel, tr){
-		/* ss public*/
+#include <QLabel>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QLabel_php_qt:public QLabel
+{
 
-		/* const char* , const char* ,  */
+public:
+  QLabel_php_qt(zval * zend_ptr, QWidget * parent = 0, Qt::WFlags f = 0);
+  QLabel_php_qt(zval * zend_ptr, const QString & texts0, QWidget * parent = 0, Qt::WFlags f = 0);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
 
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
-				QString return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+QLabel_php_qt::QLabel_php_qt(zval * zend_ptr, QWidget * parent, Qt::WFlags f):QLabel(parent, f)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QLabel",&staticMetaObject));
 }
+QLabel_php_qt::QLabel_php_qt(zval * zend_ptr, const QString & texts0, QWidget * parent, Qt::WFlags f):
+QLabel(texts0, parent, f)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QLabel",&staticMetaObject));
+}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setMargin
- *    flags:    
+PHP_QT_MOC(QLabel);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLabel, setMargin){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLabel, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setMargin((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLabel::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLabel::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLabel::tr(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  clear
- *    flags:    l
+/*!
+ * method setMargin
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLabel, clear){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			obj->clear();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLabel, setMargin)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMargin' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMargin((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::setMargin(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  qt_invoke
- *    flags:    v
+/*!
+ * method clear
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLabel, qt_invoke){
+
+ZEND_METHOD(QLabel, clear)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'clear' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->clear());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::clear(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setBuddy
- *    flags:    
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLabel, setBuddy){
-		/* o public*/
 
-		/* qt_QWidget* ,  */
+/*!
+ * method hasScaledContents
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QLabel, hasScaledContents)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hasScaledContents' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
 
-
-			if(obj_z_0->inherits("QWidget")) {
-				obj->setBuddy((QWidget*) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->hasScaledContents());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::hasScaledContents(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  movie
- *    flags:    c
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QLabel, movie){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				QMovie * return_object = (QMovie *) obj->movie();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  hasScaledContents
- *    flags:    c
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QLabel, hasScaledContents){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->hasScaledContents());
-	}
+
+/*!
+ * method setScaledContents
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLabel, setScaledContents)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setScaledContents' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setScaledContents((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::setScaledContents(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method indent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLabel, qt_cast){
+
+ZEND_METHOD(QLabel, indent)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'indent' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->indent());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::indent(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  metaObject
- *    flags:    cv
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLabel, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				QMetaObject * return_object = (QMetaObject *) obj->metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method setAlignment
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Alignment Qt::Alignments0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLabel, setAlignment)
+{
+  ///Qt::Alignment Qt::Alignments0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setAlignment' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::Alignment Qt::Alignments0,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setAlignment((Qt::Alignment) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::setAlignment(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setScaledContents
- *    flags:    
+/*!
+ * method pixmap
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPixmap *
+ * @flags	c
  */
-ZEND_METHOD(QLabel, setScaledContents){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLabel, pixmap)
+{
+  ///
+#ifdef PHP_QT_QPixmap           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pixmap' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setScaledContents((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast < QPixmap * >(selfpointer->pixmap());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLabel::pixmap(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  event
- *    flags:    
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QLabel, event){
-		/* o protected*/
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  indent
- *    flags:    c
+/*!
+ * method buddy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
-ZEND_METHOD(QLabel, indent){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			RETURN_LONG(obj->indent());
-	}
+
+ZEND_METHOD(QLabel, buddy)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'buddy' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QWidget * >(selfpointer->buddy());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLabel::buddy(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method setMovie
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMovie *movies0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLabel, qt_emit){
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  pixmap
- *    flags:    c
- */
-ZEND_METHOD(QLabel, pixmap){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				const QPixmap * return_object = (const QPixmap *) obj->pixmap();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QLabel, setMovie)
+{
+  ///QMovie *movies0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QMovie
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setMovie' is not static");
+          RETURN_NULL();
+        }
+        /// try QMovie *movies0,
+        QLabel *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+        }
+        QMovie *cpp_arg_0 = static_cast < QMovie * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setMovie((QMovie *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::setMovie(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setAlignment
- *    flags:    
+/*!
+ * method setPicture
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPicture &s0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLabel, setAlignment){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLabel, setPicture)
+{
+  ///const QPicture &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPicture
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setPicture' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPicture &s0,
+        QLabel *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+        }
+        QPicture *cpp_arg_0 = static_cast < QPicture * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setPicture((const QPicture &)*cpp_arg_0));
+      }
+#endif
 
-			obj->setAlignment((Qt::Alignment) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::setPicture(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method setNum
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * overloaded args:
+ * @param	double
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLabel, className){
+
+ZEND_METHOD(QLabel, setNum)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setNum((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  ///double
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try double,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setNum((double)Z_DVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::setNum(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  buddy
- *    flags:    c
+/*!
+ * method wordWrap
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLabel, buddy){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				QWidget * return_object = (QWidget *) obj->buddy();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  textFormat
- *    flags:    c
- */
-ZEND_METHOD(QLabel, textFormat){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			RETURN_LONG(obj->textFormat());
-	}
+ZEND_METHOD(QLabel, wordWrap)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'wordWrap' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->wordWrap());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::wordWrap(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setMovie
- *    flags:    l
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QLabel, setMovie){
-		/* o public_slots*/
 
-		/* qt_QMovie* movie,  */
+ZEND_METHOD(QLabel, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0->inherits("QMovie")) {
-				obj->setMovie((QMovie*) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QLabel::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLabel::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setPicture
- *    flags:    l
+/*!
+ * method setTextFormat
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::TextFormat Qt::TextFormats0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLabel, setPicture){
-		/* o public_slots*/
 
-		/* const QPicture& ,  */
+ZEND_METHOD(QLabel, setTextFormat)
+{
+  ///Qt::TextFormat Qt::TextFormats0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setTextFormat' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::TextFormat Qt::TextFormats0,
+      QLabel *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setTextFormat((Qt::TextFormat) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::setTextFormat(...) ");
+}
 
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
+ */
 
-			if(obj_z_0->inherits("QPicture")) {
-				obj->setPicture((const QPicture&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+/*!
+ * method text
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
+
+ZEND_METHOD(QLabel, text)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'text' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->text());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLabel::text(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setNum
- *    flags:    l
+/*!
+ * method minimumSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLabel, setNum){
-		/* l public_slots*/
 
-		/* int ,  */
+ZEND_METHOD(QLabel, minimumSizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumSizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setNum((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->minimumSizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLabel::minimumSizeHint(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  wordWrap
- *    flags:    c
+/*!
+ * method heightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLabel, wordWrap){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->wordWrap());
-	}
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  staticMetaObject
- *    flags:    s
- */
-ZEND_METHOD(QLabel, staticMetaObject){
+ZEND_METHOD(QLabel, heightForWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'heightForWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->heightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::heightForWidth(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setTextFormat
- *    flags:    
+/*!
+ * method setPixmap
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPixmap &s0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLabel, setTextFormat){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLabel, setPixmap)
+{
+  ///const QPixmap &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPixmap &s0,
+        QLabel *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+        }
+        QPixmap *cpp_arg_0 = static_cast < QPixmap * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setPixmap((const QPixmap &)*cpp_arg_0));
+      }
+#endif
 
-			obj->setTextFormat((Qt::TextFormat) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::setPixmap(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLabel, qObject){
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setText
- *    flags:    l
+/*!
+ * method setBuddy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLabel, setText){
-		/* o public_slots*/
 
-		/* const QString& ,  */
+ZEND_METHOD(QLabel, setBuddy)
+{
+  ///QWidget *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setBuddy' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *s0,
+        QLabel *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setBuddy((QWidget *) cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				obj->setText((const QString&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::setBuddy(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  text
- *    flags:    c
+/*!
+ * method movie
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMovie *
+ * @flags	c
  */
-ZEND_METHOD(QLabel, text){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->text();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLabel, movie)
+{
+  ///
+#ifdef PHP_QT_QMovie            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'movie' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QMovie * >(selfpointer->movie());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLabel::movie(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  alignment
- *    flags:    c
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *es0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QLabel, alignment){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			RETURN_LONG(obj->alignment());
-	}
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method textFormat
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::TextFormat
+ * @flags	c
  */
-ZEND_METHOD(QLabel, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj->sizeHint();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLabel, textFormat)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'textFormat' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->textFormat());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::textFormat(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  minimumSizeHint
- *    flags:    c
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLabel, minimumSizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj->minimumSizeHint();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  heightForWidth
- *    flags:    c
+/*!
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLabel, heightForWidth){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method setText
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+ZEND_METHOD(QLabel, setText)
+{
+  ///const QString &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setText' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QLabel *selfpointer;
 
-			RETURN_LONG(obj->heightForWidth((int) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setText((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::setText(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setPixmap
- *    flags:    l
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLabel, setPixmap){
-		/* o public_slots*/
 
-		/* const QPixmap& ,  */
+ZEND_METHOD(QLabel, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0->inherits("QPixmap")) {
-				obj->setPixmap((const QPixmap&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  picture
- *    flags:    c
- */
-ZEND_METHOD(QLabel, picture){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				const QPicture * return_object = (const QPicture *) obj->picture();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+      *return_object = static_cast < QSize > (selfpointer->sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLabel::sizeHint(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setWordWrap
- *    flags:    
+/*!
+ * method alignment
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Alignment
+ * @flags	c
  */
-ZEND_METHOD(QLabel, setWordWrap){
-		/* l public*/
 
-		/* int on,  */
+ZEND_METHOD(QLabel, alignment)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'alignment' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-
-
-			obj->setWordWrap((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->alignment());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::alignment(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method picture
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPicture *
+ * @flags	c
  */
-ZEND_METHOD(QLabel, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QLabel, picture)
+{
+  ///
+#ifdef PHP_QT_QPicture          // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'picture' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast < QPicture * >(selfpointer->picture());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLabel::picture(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method setWordWrap
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool ons0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLabel, qt_property){
+
+ZEND_METHOD(QLabel, setWordWrap)
+{
+  ///bool ons0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setWordWrap' is not static");
+        RETURN_NULL();
+      }
+      /// try bool ons0,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setWordWrap((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::setWordWrap(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  QLabel
- *    flags:    t
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLabel, __construct){
-		/* ol public*/
 
-		/* qt_QWidget* parent, int f,  */
+ZEND_METHOD(QLabel, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0->inherits("QWidget")) {
-				QLabel *QLabel_ptr = new QLabel((QWidget*) obj_z_0, (Qt::WFlags) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QLabel_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ool public*/
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-		/* const QString& text, qt_QWidget* parent, int f,  */
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLabel::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLabel *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && obj_z_1->inherits("QWidget")) {
-				QLabel *QLabel_ptr = new QLabel((const QString&) obj_z_0, (QWidget*) obj_z_1, (Qt::WFlags) Z_LVAL_P(z_2));
-				PHP_QT_REGISTER(QLabel_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLabel::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLabel::trUtf8(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setIndent
- *    flags:    
+/*!
+ * method QLabel
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parent=0s0
+ * @param	 Qt::WFlags f=0s1
+ * 
+ * overloaded args:
+ * @param	const QString &texts0
+ * @param	 QWidget  *parent=0
+ * @param	 Qt::WFlags f=0
+ * 
+ * overloaded args:
+ * @param	const QLabel &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QLabel, setIndent){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLabel, __construct)
+{
+  ///QWidget *parent=0s0, Qt::WFlags f=0s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel_php_qt *selfpointer = new QLabel_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget *parent=0s0,
+      QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QLabel_php_qt *selfpointer = new QLabel_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget *parent=0s0, Qt::WFlags f=0s1,
+      QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QLabel_php_qt *selfpointer = new QLabel_php_qt(getThis(), (QWidget *) cpp_arg_0, (Qt::WFlags) Z_LVAL_P(arg_1));
 
-			obj->setIndent((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QString &texts0, QWidget  *parent=0, Qt::WFlags f=0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &texts0,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QLabel_php_qt *selfpointer = new QLabel_php_qt(getThis(), (const QString &)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &texts0, QWidget  *parent=0,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QWidget *cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+        QLabel_php_qt *selfpointer = new QLabel_php_qt(getThis(), (const QString &)*cpp_arg_0, (QWidget *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &texts0, QWidget  *parent=0, Qt::WFlags f=0,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QWidget *cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+        QLabel_php_qt *selfpointer = new QLabel_php_qt(getThis(), (const QString &)*cpp_arg_0, (QWidget *) cpp_arg_1, (Qt::WFlags) Z_LVAL_P(arg_2));
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QLabel &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLabel
+      if (inherits(Z_OBJCE_P(arg_0), 38)) {
+/// method is private, skip
+        php_error(E_ERROR, "QLabel::__construct(...) cannot be called with 'const QLabel &,'.");
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::QLabel(...) ");
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  margin
- *    flags:    c
+/*!
+ * method margin
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLabel, margin){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			RETURN_LONG(obj->margin());
-	}
+
+ZEND_METHOD(QLabel, margin)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'margin' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->margin());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::margin(...) ");
 }
 
+/*!
+ * method setIndent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QLabel);
+ZEND_METHOD(QLabel, setIndent)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setIndent' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLabel * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setIndent((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLabel::setIndent(...) ");
+}

Modified: trunk/qt/classes/qlatin1char.cpp
===================================================================
--- trunk/qt/classes/qlatin1char.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlatin1char.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,70 +19,128 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLatin1Char.cpp - QLatin1Char PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QLatin1Char>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QLatin1Char */
-/*
- *    function  unicode
- *    flags:    c
- */
-ZEND_METHOD(QLatin1Char, unicode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLatin1Char *obj = (QLatin1Char*) PHP_QT_FETCH();
-			obj->unicode();
-			RETURN_NULL();
-	}
+#include <QLatin1Char>
+#include <QMetaMethod>
+class QLatin1Char_php_qt:public QLatin1Char
+{
+
+public:
+  QLatin1Char_php_qt(zval * zend_ptr, char cs0);
+
+
+  zval *zend_ptr;
+};
+QLatin1Char_php_qt::QLatin1Char_php_qt(zval * zend_ptr, char cs0):
+QLatin1Char(cs0)
+{
+  this->zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QLatin1Char */
-/*
- *    function  QLatin1Char
- *    flags:    t
+/*!
+ * method QLatin1Char
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	char cs0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QLatin1Char, __construct){
-		/* l public*/
 
-		/* char c,  */
+ZEND_METHOD(QLatin1Char, __construct)
+{
+  ///char cs0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try char cs0s0,
+      QLatin1Char_php_qt *selfpointer = new QLatin1Char_php_qt(getThis(), (char)Z_STRVAL_P(arg_0)[0]);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLatin1Char::QLatin1Char(...) ");
+}
 
+/*!
+ * method toLatin1
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char
+ * @flags	c
+ */
 
-			QLatin1Char *QLatin1Char_ptr = new QLatin1Char((char) Z_LVAL_P(z_0));
-				PHP_QT_REGISTER(QLatin1Char_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QLatin1Char, toLatin1)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toLatin1' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLatin1Char *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLatin1Char * >(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer->toLatin1(), 1);
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLatin1Char::toLatin1(...) ");
 }
 
-/*********************************
- *    class     QLatin1Char */
-/*
- *    function  toLatin1
- *    flags:    c
+/*!
+ * method unicode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const ushort
+ * @flags	c
  */
-ZEND_METHOD(QLatin1Char, toLatin1){
-	if (ZEND_NUM_ARGS() == 0){
-			QLatin1Char *obj = (QLatin1Char*) PHP_QT_FETCH();
-			obj->toLatin1();
-			RETURN_NULL();
-	}
-}
 
+ZEND_METHOD(QLatin1Char, unicode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'unicode' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLatin1Char *selfpointer;
 
-PHP_QT_DESTRUCT(QLatin1Char);
-
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLatin1Char * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->unicode());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLatin1Char::unicode(...) ");
+}

Modified: trunk/qt/classes/qlatin1string.cpp
===================================================================
--- trunk/qt/classes/qlatin1string.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlatin1string.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,61 +19,173 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLatin1String.cpp - QLatin1String PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QLatin1String>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QLatin1String */
-/*
- *    function  QLatin1String
- *    flags:    t
- */
-ZEND_METHOD(QLatin1String, __construct){
-		/* s public*/
+#include <QLatin1String>
+#include <QMetaMethod>
+class QLatin1String_php_qt:public QLatin1String
+{
 
-		/* const char* s,  */
+public:
+  QLatin1String_php_qt(zval * zend_ptr, const char *ss0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING){
 
-
-			QLatin1String *QLatin1String_ptr = new QLatin1String( (const char*) Z_STRVAL_P(z_0));
-				PHP_QT_REGISTER(QLatin1String_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
+  zval *zend_ptr;
+};
+QLatin1String_php_qt::QLatin1String_php_qt(zval * zend_ptr, const char *ss0):
+QLatin1String(ss0)
+{
+  this->zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QLatin1String */
-/*
- *    function  latin1
- *    flags:    c
+/*!
+ * method QLatin1String
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *ss0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QLatin1String, latin1){
-	if (ZEND_NUM_ARGS() == 0){
-			QLatin1String *obj = (QLatin1String*) PHP_QT_FETCH();
-				const char * return_object = (const char *) obj->latin1();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLatin1String_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLatin1String, __construct)
+{
+  ///const char *ss0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try const char *ss0s0,
+      QLatin1String_php_qt *selfpointer = new QLatin1String_php_qt(getThis(), (const char *)&Z_STRVAL_P(arg_0)[0]);
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLatin1String::QLatin1String(...) ");
 }
 
+/*!
+ * method operator<
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QLatin1String);
+/*!
+ * method operator==
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
+/*!
+ * method operator!=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+/*!
+ * method operator>
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+/*!
+ * method operator<=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+/*!
+ * method latin1
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	c
+ */
+
+ZEND_METHOD(QLatin1String, latin1)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'latin1' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLatin1String *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLatin1String * >(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer->latin1(), 1);
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLatin1String::latin1(...) ");
+}
+
+/*!
+ * method operator>=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */

Modified: trunk/qt/classes/qlayout.cpp
===================================================================
--- trunk/qt/classes/qlayout.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlayout.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,873 +19,1904 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLayout.cpp - QLayout PHP implementation.
- * begin           : Thu Feb 23 16:36:28 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
+
 #include "../php_qt.h"
 
 
 #include <QLayout>
+/// DEBUG:destructor skipped.
+/*!
+ * method addItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *
+ * 
+ * @access	public
+ * @return	void
+ * @flags	pv
+ */
 
+/*!
+ * method count
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cpv
+ */
 
-/*		public enumSizeConstraint:long {
-			SizeConstraint = 0,
-			SizeConstraint = 1,
-			SizeConstraint = 2,
-			SizeConstraint = 3,
-			SizeConstraint = 4,
-			SizeConstraint = 5
-		}
-*/
-/*********************************
- *    class     QLayout
- *    function  totalHeightForWidth
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    int w
+/*!
+ * method itemAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int index
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	cpv
  */
-ZEND_METHOD(QLayout, totalHeightForWidth){
-		/* l public*/
 
-		/* int w,  */
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect&
+ * 
+ * @access	public
+ * @return	void
+ * @flags	p
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+/*!
+ * method takeAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int index
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	pv
+ */
 
+#include <QLayoutItem>
+#include <QRect>
+#include <QMetaMethod>
+class QLayout_php_qt:public QLayout
+{
 
-			RETURN_LONG(obj->totalHeightForWidth((int) Z_LVAL_P(z_0)));
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+public:
+  QLayout_php_qt(zval * zend_ptr, QWidget * parents0);
+  QLayout_php_qt(zval * zend_ptr);
+
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+  virtual void addItem(QLayoutItem * s0);       // pure 
+
+  virtual int count() const;    // pure 
+
+  virtual QLayoutItem *itemAt(int indexs0) const;       // pure 
+
+  virtual QLayoutItem *takeAt(int indexs0);     // pure 
+protected:
+  void protected_setGeometry(const QRect & s0); // pure 
+};
+
+QLayout_php_qt::QLayout_php_qt(zval * zend_ptr, QWidget * parents0):QLayout(parents0)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QLayout",&staticMetaObject));
 }
 
-/*********************************
- *    class     QLayout
- *    function  tr
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
- */
-ZEND_METHOD(QLayout, tr){
-		/* ss public*/
+QLayout_php_qt::QLayout_php_qt(zval * zend_ptr):QLayout()
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QLayout",&staticMetaObject));
+}
 
-		/* const char* , const char* ,  */
+// virtual, pure 
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+void
+QLayout_php_qt::addItem(QLayoutItem * s0)
+{
+}
 
+// virtual, pure 
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QLayout::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+int
+QLayout_php_qt::count() const
+{
 }
 
-/*********************************
- *    class     QLayout
- *    function  isEmpty
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
+// virtual, pure 
+
+QLayoutItem *
+QLayout_php_qt::itemAt(int indexs0) const
+{
+}
+
+// virtual, pure 
+
+QLayoutItem *
+QLayout_php_qt::takeAt(int indexs0)
+{
+}
+void
+QLayout_php_qt::protected_setGeometry(const QRect & s0)
+{
+  this->setGeometry(s0);
+}
+
+PHP_QT_MOC(QLayout);
+
+/*!
+ * method totalHeightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ws0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLayout, isEmpty){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isEmpty());
-	}
+
+ZEND_METHOD(QLayout, totalHeightForWidth)
+{
+  ///int ws0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'totalHeightForWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int ws0,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->totalHeightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::totalHeightForWidth(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  setMargin
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLayout, setMargin){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLayout, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLayout *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setMargin((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLayout::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLayout::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::tr(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  activate
- *    flags:    
- *    access:    public
- *    return:    bool
- *    params:    
+/*!
+ * method setMargin
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, activate){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->activate());
-	}
+
+ZEND_METHOD(QLayout, setMargin)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMargin' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMargin((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::setMargin(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  setMenuBar
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QWidget *w
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLayout, setMenuBar){
-//qt_QWidget*
-		/* o public*/
 
-		/* qt_QWidget* w,  */
+/*!
+ * method addItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *s0s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	pv
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method activate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
 
+ZEND_METHOD(QLayout, activate)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'activate' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
 
-			if(obj_z_0->inherits("QWidget")) {
-				obj->setMenuBar((QWidget*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->activate());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::activate(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  layout
- *    flags:    
- *    access:    public
- *    return:    QLayout *
- *    params:    
+/*!
+ * method setMenuBar
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, layout){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QLayout ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QLayout *) obj->layout();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLayout, setMenuBar)
+{
+  ///QWidget *ws0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setMenuBar' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0,
+        QLayout *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setMenuBar((QWidget *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::setMenuBar(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  totalMaximumSize
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method layout
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QLayout *
+ * @flags	
  */
-ZEND_METHOD(QLayout, totalMaximumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->totalMaximumSize();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLayout, layout)
+{
+  ///
+#ifdef PHP_QT_QLayout           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'layout' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QLayout * >(selfpointer->layout());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::layout(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  sizeConstraint
- *    flags:    c
- *    access:    public
- *    return:    SizeConstraint
- *    params:    
+/*!
+ * method totalMaximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLayout, sizeConstraint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			obj->sizeConstraint();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLayout, totalMaximumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'totalMaximumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->totalMaximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::totalMaximumSize(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  geometry
- *    flags:    c
- *    access:    public
- *    return:    QRect
- *    params:    
+/*!
+ * method sizeConstraint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	SizeConstraint
+ * @flags	c
  */
-ZEND_METHOD(QLayout, geometry){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QRect* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QRect) obj->geometry();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLayout, sizeConstraint)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type SizeConstraint");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::sizeConstraint(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  invalidate
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QLayout, invalidate){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			obj->invalidate();
-			RETURN_NULL();
-	}
+
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
+
+/*!
+ * method count
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cpv
+ */
+
+/*!
+ * method widgetEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
+
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
+
+/*!
+ * method setAlignment
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * @param	 Qt::Alignment alignments1
+ * 
+ * overloaded args:
+ * @param	QLayout *l
+ * @param	 Qt::Alignment alignment
+ * 
+ * overloaded args:
+ * @param	Qt::Alignment alignment
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
+
+ZEND_METHOD(QLayout, setAlignment)
+{
+  ///QWidget *ws0, Qt::Alignment alignments1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setAlignment' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0, Qt::Alignment alignments1,
+        QLayout *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->setAlignment((QWidget *) cpp_arg_0, (Qt::Alignment) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///QLayout *l, Qt::Alignment alignment
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setAlignment' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayout *l, Qt::Alignment alignment,
+        QLayout *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+        }
+        QLayout *cpp_arg_0 = static_cast < QLayout * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->setAlignment((QLayout *) cpp_arg_0, (Qt::Alignment) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///Qt::Alignment alignment
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setAlignment' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::Alignment alignment,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setAlignment((Qt::Alignment) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::setAlignment(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  setGeometry
- *    flags:    p
- *    access:    public
- *    return:    void
- *    params:    const QRect&
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QLayout, setGeometry){
-//const QRect&
-		/* o public*/
 
-		/* const QRect& ,  */
+/*!
+ * method removeWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QLayout, removeWidget)
+{
+  ///QWidget *ws0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'removeWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0,
+        QLayout *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QRect")) {
-				obj->setGeometry((const QRect&) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+        RETURN_VOID(selfpointer->removeWidget((QWidget *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::removeWidget(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  setAlignment
- *    flags:    
- *    access:    public
- *    return:    bool
- *    params:    QWidget *w, Qt::Alignment alignment
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QLayout, setAlignment){
-//qt_QWidget*
-		/* ol public*/
 
-		/* qt_QWidget* w, int alignment,  */
+ZEND_METHOD(QLayout, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QLayout *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0->inherits("QWidget")) {
-				RETURN_BOOL(obj->setAlignment((QWidget*) obj_z_0, (Qt::Alignment) Z_LVAL_P(z_1)));
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QLayout::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  removeWidget
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QWidget *w
+/*!
+ * method itemAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0s0
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	cpv
  */
-ZEND_METHOD(QLayout, removeWidget){
-//qt_QWidget*
-		/* o public*/
 
-		/* qt_QWidget* w,  */
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method totalMinimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
+ */
 
+ZEND_METHOD(QLayout, totalMinimumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-			if(obj_z_0->inherits("QWidget")) {
-				obj->removeWidget((QWidget*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'totalMinimumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->totalMinimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::totalMinimumSize(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  setEnabled
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    bool
+/*!
+ * method childEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChildEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, setEnabled){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method QLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parents0s0
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutPrivate &d
+ * @param	 QLayout*
+ * @param	 QWidget*
+ * 
+ * overloaded args:
+ * @param	const QLayout &
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+ZEND_METHOD(QLayout, __construct)
+{
+  ///QWidget *parents0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *parents0s0,
+        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+        QLayout_php_qt *selfpointer = new QLayout_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-			obj->setEnabled((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout_php_qt *selfpointer = new QLayout_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QLayoutPrivate &d, QLayout*, QWidget*
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QLayoutPrivate
+#ifdef PHP_QT_QLayout
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 41) && inherits(Z_OBJCE_P(arg_2), 71)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayoutPrivate &d, QLayout*, QWidget*,
+        QLayoutPrivate *cpp_arg_0 = static_cast < QLayoutPrivate * >(php_qt_fetch(arg_0));
+        QLayout *cpp_arg_1 = static_cast < QLayout * >(php_qt_fetch(arg_1));
+        QWidget *cpp_arg_2 = static_cast < QWidget * >(php_qt_fetch(arg_2));
+        QLayout_php_qt *selfpointer = new QLayout_php_qt(getThis(), (QLayoutPrivate &) * cpp_arg_0, (QLayout *) cpp_arg_1, (QWidget *) cpp_arg_2);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+  ///const QLayout &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+/// method is private, skip
+        php_error(E_ERROR, "QLayout::__construct(...) cannot be called with 'const QLayout &,'.");
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::QLayout(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  addWidget
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QWidget *w
+/*!
+ * method setSpacing
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, addWidget){
-//qt_QWidget*
-		/* o public*/
 
-		/* qt_QWidget* w,  */
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
+ZEND_METHOD(QLayout, setSpacing)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setSpacing' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLayout *selfpointer;
 
-			    QLayout *obj = static_cast<QLayout*>(PHP_QT_FETCH());
-			    QWidget* obj_z_0 = static_cast<QWidget*>(php_qt_fetch(z_0));
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setSpacing((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::setSpacing(...) ");
+}
 
-//			if(obj_z_0->inherits("QWidget")) {
-				obj->addWidget(obj_z_0);
-			    RETURN_NULL();
-//			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+/*!
+ * method setSizeConstraint
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	SizeConstraint SizeConstraints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLayout, setSizeConstraint)
+{
+// notice: unknown argument SizeConstraint SizeConstraints0, skipped
+  php_error(E_ERROR, "could not parse argument in QLayout::setSizeConstraint(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  removeItem
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QLayoutItem *
+/*!
+ * method menuBar
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
-ZEND_METHOD(QLayout, removeItem){
-//qt_QLayoutItem*
-		/* o public*/
 
-		/* qt_QLayoutItem* ,  */
+ZEND_METHOD(QLayout, menuBar)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'menuBar' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0->inherits("QLayoutItem")) {
-				obj->removeItem((QLayoutItem*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QWidget * >(selfpointer->menuBar());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::menuBar(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  staticMetaObject
- *    flags:    s
- *    access:    public
- *    return:    QMetaObject*
- *    params:    
+/*!
+ * method totalSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLayout, staticMetaObject){
+
+ZEND_METHOD(QLayout, totalSizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'totalSizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->totalSizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::totalSizeHint(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  qObject
- *    flags:    
- *    access:    public
- *    return:    QObject*
- *    params:    
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLayout, qObject){
+
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	c
+ */
+
+ZEND_METHOD(QLayout, expandingDirections)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'expandingDirections' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->expandingDirections());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::expandingDirections(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  totalMinimumSize
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method indexOf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cv
  */
-ZEND_METHOD(QLayout, totalMinimumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->totalMinimumSize();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method update
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLayout, update)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'update' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->update());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::update(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  minimumSize
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method addChildWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, minimumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->minimumSize();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method alignmentRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &s0
+ * 
+ * @access	protected
+ * @return	QRect
+ * @flags	c
+ */
+
+/*!
+ * method isEmpty
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+ZEND_METHOD(QLayout, isEmpty)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isEmpty' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isEmpty());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::isEmpty(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  setSpacing
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method geometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-ZEND_METHOD(QLayout, setSpacing){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLayout, geometry)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'geometry' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setSpacing((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QRect *return_object = new QRect;
+
+      *return_object = static_cast < QRect > (selfpointer->geometry());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::geometry(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  isEnabled
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
+/*!
+ * method invalidate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, isEnabled){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isEnabled());
-	}
+
+ZEND_METHOD(QLayout, invalidate)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'invalidate' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->invalidate());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::invalidate(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  setSizeConstraint
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    SizeConstraint
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &s0s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	p
  */
-ZEND_METHOD(QLayout, setSizeConstraint){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLayout, setGeometry)
+{
+  ///const QRect &s0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setGeometry' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &s0s0,
+        QLayout *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+        }
+        QRect *cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setGeometry((const QRect &)*cpp_arg_0));
+      }
+#endif
 
-			obj->setSizeConstraint((QLayout::SizeConstraint) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::setGeometry(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  menuBar
- *    flags:    c
- *    access:    public
- *    return:    QWidget *
- *    params:    
+/*!
+ * method addChildLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayout *ls0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, menuBar){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj->menuBar();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method setEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLayout, setEnabled)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::setEnabled(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  totalSizeHint
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method takeAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0s0
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	pv
  */
-ZEND_METHOD(QLayout, totalSizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->totalSizeHint();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method removeItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLayout, removeItem)
+{
+  ///QLayoutItem *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'removeItem' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayoutItem *s0,
+        QLayout *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+        }
+        QLayoutItem *cpp_arg_0 = static_cast < QLayoutItem * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->removeItem((QLayoutItem *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::removeItem(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  closestAcceptableSize
- *    flags:    s
- *    access:    public
- *    return:    QSize
- *    params:    const QWidget *w, const QSize &s
+/*!
+ * method addWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, closestAcceptableSize){
-//const QWidget*
-//const QSize&
-		/* oo public*/
 
-		/* const QWidget* w, const QSize& s,  */
+ZEND_METHOD(QLayout, addWidget)
+{
+  ///QWidget *ws0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addWidget' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0,
+        QLayout *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->addWidget((QWidget *) cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0->inherits("QWidget") && obj_z_1->inherits("QSize")) {
-				QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->closestAcceptableSize((const QWidget*) obj_z_0, (const QSize&) *obj_z_1);
-			} else {
-				*return_object = (QSize) QLayout::closestAcceptableSize((const QWidget*) obj_z_0, (const QSize&) *obj_z_1);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::addWidget(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  parentWidget
- *    flags:    c
- *    access:    public
- *    return:    QWidget *
- *    params:    
+/*!
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLayout, parentWidget){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj->parentWidget();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLayout, minimumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->minimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::minimumSize(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  trUtf8
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+/*!
+ * method isEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLayout, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QLayout, isEnabled)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isEnabled());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::isEnabled(...) ");
+}
 
+/*!
+ * method closestAcceptableSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QWidget *ws0
+ * @param	 const QSize  &ss1
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	s
+ */
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QLayout::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+ZEND_METHOD(QLayout, closestAcceptableSize)
+{
+  ///const QWidget *ws0, const QSize  &ss1
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 71) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        /// try const QWidget *ws0, const QSize  &ss1,
+        QLayout *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+        QSize *cpp_arg_1 = static_cast < QSize * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QSize *return_object = new QSize;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast < QSize > (QLayout::closestAcceptableSize((const QWidget *)cpp_arg_0, (const QSize &)*cpp_arg_1));
+        } else {
+          *return_object = static_cast < QSize > (selfpointer->closestAcceptableSize((const QWidget *)cpp_arg_0, (const QSize &)*cpp_arg_1));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::closestAcceptableSize(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  maximumSize
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method parentWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
-ZEND_METHOD(QLayout, maximumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->maximumSize();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLayout, parentWidget)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'parentWidget' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QWidget * >(selfpointer->parentWidget());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::parentWidget(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  margin
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLayout, margin){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			RETURN_LONG(obj->margin());
-	}
+
+ZEND_METHOD(QLayout, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLayout::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLayout::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::trUtf8(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  expandingDirections
- *    flags:    c
- *    access:    public
- *    return:    Qt::Orientations
- *    params:    
+/*!
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLayout, expandingDirections){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			obj->expandingDirections();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLayout, maximumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'maximumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->maximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLayout::maximumSize(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  spacing
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method margin
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLayout, spacing){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			RETURN_LONG(obj->spacing());
-	}
+
+ZEND_METHOD(QLayout, margin)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'margin' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->margin());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::margin(...) ");
 }
 
-/*********************************
- *    class     QLayout
- *    function  update
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    
+/*!
+ * method spacing
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLayout, update){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			obj->update();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLayout, spacing)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'spacing' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->spacing());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::spacing(...) ");
 }
 
+/*!
+ * method activateRecursiveHelper
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *items0
+ * 
+ * @access	private
+ * @return	void
+ * @flags	s
+ */
 
-PHP_QT_DESTRUCT(QLayout);
+ZEND_METHOD(QLayout, activateRecursiveHelper)
+{
+  ///QLayoutItem *items0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+/// method is private, skip
+        php_error(E_ERROR, "QLayout::activateRecursiveHelper(...) cannot be called with 'QLayoutItem *items0,'.");
+      }
+#endif
 
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayout::activateRecursiveHelper(...) ");
+}

Modified: trunk/qt/classes/qlayoutitem.cpp
===================================================================
--- trunk/qt/classes/qlayoutitem.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlayoutitem.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,59 +19,446 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLayoutItem.cpp - QLayoutItem PHP implementation.
- * begin           : Thu Feb 23 16:34:20 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
+
 #include "../php_qt.h"
 
 
 #include <QLayoutItem>
+/// DEBUG:destructor skipped.
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	cpv
+ */
 
-/*********************************
- *    class     QLayoutItem
- *    function  alignment
- *    flags:    c
- *    access:    public
- *    return:    Qt::Alignment
- *    params:    
+/*!
+ * method isEmpty
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	cpv
  */
-ZEND_METHOD(QLayoutItem, alignment){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayoutItem *obj = (QLayoutItem*) PHP_QT_FETCH();
-			RETURN_LONG(obj->alignment());
-	}
+
+/*!
+ * method geometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	cpv
+ */
+
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect&
+ * 
+ * @access	public
+ * @return	void
+ * @flags	pv
+ */
+
+/*!
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cpv
+ */
+
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cpv
+ */
+
+/*!
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cpv
+ */
+
+#include <QRect>
+#include <QMetaMethod>
+class QLayoutItem_php_qt:public QLayoutItem
+{
+
+public:
+  QLayoutItem_php_qt(zval * zend_ptr, Qt::Alignment alignment = 0);
+
+
+  zval *zend_ptr;
+  virtual Qt::Orientations expandingDirections() const; // pure 
+
+  virtual bool isEmpty() const; // pure 
+
+  virtual QRect geometry() const;       // pure 
+
+  virtual void setGeometry(const QRect & s0);   // pure 
+
+  virtual QSize minimumSize() const;    // pure 
+
+  virtual QSize sizeHint() const;       // pure 
+
+  virtual QSize maximumSize() const;    // pure 
+};
+
+QLayoutItem_php_qt::QLayoutItem_php_qt(zval * zend_ptr, Qt::Alignment alignment):QLayoutItem(alignment)
+{
+  this->zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QLayoutItem
- *    function  setAlignment
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    Qt::Alignment a
+// virtual, pure 
+
+Qt::Orientations QLayoutItem_php_qt::expandingDirections() const
+{
+}
+
+// virtual, pure 
+
+bool
+QLayoutItem_php_qt::isEmpty() const
+{
+}
+
+// virtual, pure 
+
+QRect
+QLayoutItem_php_qt::geometry() const
+{
+}
+
+// virtual, pure 
+
+void
+QLayoutItem_php_qt::setGeometry(const QRect & s0)
+{
+}
+
+// virtual, pure 
+
+QSize
+QLayoutItem_php_qt::minimumSize() const
+{
+}
+
+// virtual, pure 
+
+QSize
+QLayoutItem_php_qt::sizeHint() const
+{
+}
+
+// virtual, pure 
+
+QSize
+QLayoutItem_php_qt::maximumSize() const
+{
+}
+
+/*!
+ * method layout
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QLayout *
+ * @flags	v
  */
-ZEND_METHOD(QLayoutItem, setAlignment){
-		/* l public*/
 
-		/* int a,  */
+/*!
+ * method spacerItem
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSpacerItem *
+ * @flags	v
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLayoutItem *obj = (QLayoutItem*) PHP_QT_FETCH();
+/*!
+ * method QLayoutItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Alignment alignment = 0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
+ */
 
+ZEND_METHOD(QLayoutItem, __construct)
+{
+  ///Qt::Alignment alignment = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayoutItem_php_qt *selfpointer = new QLayoutItem_php_qt(getThis());
 
-			obj->setAlignment((Qt::Alignment) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::Alignment alignment = 0s0,
+      QLayoutItem_php_qt *selfpointer = new QLayoutItem_php_qt(getThis(), (Qt::Alignment) Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayoutItem::QLayoutItem(...) ");
 }
 
+/*!
+ * method setAlignment
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Alignment as0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QLayoutItem);
+ZEND_METHOD(QLayoutItem, setAlignment)
+{
+  ///Qt::Alignment as0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setAlignment' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::Alignment as0,
+      QLayoutItem *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayoutItem * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setAlignment((Qt::Alignment) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayoutItem::setAlignment(...) ");
+}
+
+/*!
+ * method heightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cv
+ */
+
+/*!
+ * method hasHeightForWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	cv
+ */
+
+/*!
+ * method minimumHeightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cv
+ */
+
+/*!
+ * method widget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	v
+ */
+
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	cpv
+ */
+
+/*!
+ * method isEmpty
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	cpv
+ */
+
+/*!
+ * method geometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	cpv
+ */
+
+/*!
+ * method invalidate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &s0s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	pv
+ */
+
+/*!
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cpv
+ */
+
+/*!
+ * method alignment
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Alignment
+ * @flags	c
+ */
+
+ZEND_METHOD(QLayoutItem, alignment)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'alignment' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLayoutItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLayoutItem * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->alignment());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLayoutItem::alignment(...) ");
+}
+
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cpv
+ */
+
+/*!
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cpv
+ */

Modified: trunk/qt/classes/qlcdnumber.cpp
===================================================================
--- trunk/qt/classes/qlcdnumber.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlcdnumber.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,545 +19,1089 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLCDNumber.cpp - QLCDNumber PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QLCDNumber>
 #include "../php_qt.h"
 
 
+#include <QLCDNumber>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QLCDNumber_php_qt:public QLCDNumber
+{
 
-/*		public enumMode:long {
-			Mode = 0,
-			Mode = 1,
-			Mode = 2,
-			Mode = 3
-		}
-*/
+public:
+  QLCDNumber_php_qt(zval * zend_ptr, QWidget * parent = 0);
+  QLCDNumber_php_qt(zval * zend_ptr, uint numDigitss0, QWidget * parent = 0);
 
-/*		public enumSegmentStyle:long {
-			SegmentStyle = 0,
-			SegmentStyle = 1,
-			SegmentStyle = 2
-		}
-*/
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  tr
- *    flags:    s
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+
+QLCDNumber_php_qt::QLCDNumber_php_qt(zval * zend_ptr, QWidget * parent):QLCDNumber(parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QLCDNumber",&staticMetaObject));
+}
+
+QLCDNumber_php_qt::QLCDNumber_php_qt(zval * zend_ptr, uint numDigitss0, QWidget * parent):QLCDNumber(numDigitss0, parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QLCDNumber",&staticMetaObject));
+}
+
+PHP_QT_MOC(QLCDNumber);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLCDNumber, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QLCDNumber, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLCDNumber *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-				QString return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLCDNumber_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLCDNumber::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLCDNumber::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::tr(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  segmentStyle
- *    flags:    c
+/*!
+ * method mode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Mode
+ * @flags	c
  */
-ZEND_METHOD(QLCDNumber, segmentStyle){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-				QLCDNumber::SegmentStyle return_object = (QLCDNumber::SegmentStyle) obj->segmentStyle();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLCDNumber_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  mode
- *    flags:    c
- */
-ZEND_METHOD(QLCDNumber, mode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			RETURN_LONG(obj->mode());
-	}
+ZEND_METHOD(QLCDNumber, mode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type Mode");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::mode(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  checkOverflow
- *    flags:    c
+/*!
+ * method checkOverflow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	double nums0
+ * 
+ * overloaded args:
+ * @param	int num
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLCDNumber, checkOverflow){
-		/* l public*/
 
-		/* double num,  */
+ZEND_METHOD(QLCDNumber, checkOverflow)
+{
+  ///double nums0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'checkOverflow' is not static");
+        RETURN_NULL();
+      }
+      /// try double nums0,
+      QLCDNumber *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->checkOverflow((double)Z_DVAL_P(arg_0)));
+    }
+  }
+  ///int num
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'checkOverflow' is not static");
+        RETURN_NULL();
+      }
+      /// try int num,
+      QLCDNumber *
+        selfpointer;
 
-
-			RETURN_BOOL(obj->checkOverflow((double) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->checkOverflow((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::checkOverflow(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  qt_invoke
- *    flags:    v
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLCDNumber, qt_invoke){
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method setSegmentStyle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	SegmentStyle SegmentStyles0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLCDNumber, staticMetaObject){
+
+ZEND_METHOD(QLCDNumber, setSegmentStyle)
+{
+// notice: unknown argument SegmentStyle SegmentStyles0, skipped
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::setSegmentStyle(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setOctMode
- *    flags:    l
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QLCDNumber, setOctMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			obj->setOctMode();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  display
- *    flags:    l
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QLCDNumber, display){
-		/* l public_slots*/
 
-		/* int num,  */
-		/* o public_slots*/
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-		/* const QString& str,  */
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+/*!
+ * method intValue
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QLCDNumber, intValue)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'intValue' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
 
-			obj->display((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->intValue());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::intValue(...) ");
+}
 
+/*!
+ * method smallDecimalPoint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				obj->display((const QString&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QLCDNumber, smallDecimalPoint)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'smallDecimalPoint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->smallDecimalPoint());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::smallDecimalPoint(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setSegmentStyle
- *    flags:    
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QLCDNumber, setSegmentStyle){
-		/* o public*/
 
-		/* QLCDNumber::SegmentStyle ,  */
+ZEND_METHOD(QLCDNumber, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QLCDNumber *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj->setSegmentStyle((QLCDNumber::SegmentStyle) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QLCDNumber::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setHexMode
- *    flags:    l
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QLCDNumber, setHexMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			obj->setHexMode();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method overflow
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QLCDNumber, qObject){
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setSmallDecimalPoint
- *    flags:    l
+/*!
+ * method setNumDigits
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int nDigitss0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLCDNumber, setSmallDecimalPoint){
-		/* l public_slots*/
 
-		/* int ,  */
+ZEND_METHOD(QLCDNumber, setNumDigits)
+{
+  ///int nDigitss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNumDigits' is not static");
+        RETURN_NULL();
+      }
+      /// try int nDigitss0,
+      QLCDNumber *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-
-
-			obj->setSmallDecimalPoint((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setNumDigits((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::setNumDigits(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLCDNumber, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj->sizeHint();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLCDNumber_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method setBinMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLCDNumber, qt_cast){
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  metaObject
- *    flags:    cv
- */
-ZEND_METHOD(QLCDNumber, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-				QMetaObject * return_object = (QMetaObject *) obj->metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLCDNumber_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
+ZEND_METHOD(QLCDNumber, setBinMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setBinMode' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  value
- *    flags:    c
- */
-ZEND_METHOD(QLCDNumber, value){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj->value());
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setBinMode());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::setBinMode(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setDecMode
- *    flags:    l
+/*!
+ * method segmentStyle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	SegmentStyle
+ * @flags	c
  */
-ZEND_METHOD(QLCDNumber, setDecMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			obj->setDecMode();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  qt_emit
- *    flags:    v
- */
-ZEND_METHOD(QLCDNumber, qt_emit){
+ZEND_METHOD(QLCDNumber, segmentStyle)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type SegmentStyle");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::segmentStyle(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method setOctMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLCDNumber, className){
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  intValue
- *    flags:    c
- */
-ZEND_METHOD(QLCDNumber, intValue){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			RETURN_LONG(obj->intValue());
-	}
+ZEND_METHOD(QLCDNumber, setOctMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setOctMode' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setOctMode());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::setOctMode(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  QLCDNumber
- *    flags:    t
+/*!
+ * method display
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &strs0
+ * 
+ * overloaded args:
+ * @param	int num
+ * 
+ * overloaded args:
+ * @param	double num
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLCDNumber, __construct){
-		/* o public*/
 
-		/* qt_QWidget* parent,  */
+ZEND_METHOD(QLCDNumber, display)
+{
+  ///const QString &strs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'display' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &strs0,
+        QLCDNumber *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			if(obj_z_0->inherits("QWidget")) {
-				QLCDNumber *QLCDNumber_ptr = new QLCDNumber((QWidget*) obj_z_0);
-				PHP_QT_REGISTER(QLCDNumber_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* lo public*/
+        RETURN_VOID(selfpointer->display((const QString &)*cpp_arg_0));
+      }
+#endif
 
-		/* unsigned int numDigits, qt_QWidget* parent,  */
+    }
+  }
+  ///int num
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'display' is not static");
+        RETURN_NULL();
+      }
+      /// try int num,
+      QLCDNumber *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->display((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  ///double num
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'display' is not static");
+        RETURN_NULL();
+      }
+      /// try double num,
+      QLCDNumber *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->display((double)Z_DVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::display(...) ");
+}
 
-			if(obj_z_1->inherits("QWidget")) {
-				QLCDNumber *QLCDNumber_ptr = new QLCDNumber((uint) Z_LVAL_P(z_0), (QWidget*) obj_z_1);
-				PHP_QT_REGISTER(QLCDNumber_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+/*!
+ * method value
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	double
+ * @flags	c
+ */
+
+ZEND_METHOD(QLCDNumber, value)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'value' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_DOUBLE(selfpointer->value());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::value(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setNumDigits
- *    flags:    
+/*!
+ * method QLCDNumber
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * parent = 0s0
+ * 
+ * overloaded args:
+ * @param	uint numDigitss0
+ * @param	 QWidget * parent = 0
+ * 
+ * overloaded args:
+ * @param	const QLCDNumber &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QLCDNumber, setNumDigits){
-		/* l public*/
 
-		/* int nDigits,  */
+ZEND_METHOD(QLCDNumber, __construct)
+{
+  ///QWidget * parent = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber_php_qt *
+        selfpointer = new QLCDNumber_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget * parent = 0s0,
+      QWidget *
+        cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QLCDNumber_php_qt *
+        selfpointer = new QLCDNumber_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///uint numDigitss0, QWidget * parent = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try uint numDigitss0,
+      QLCDNumber_php_qt *
+        selfpointer = new QLCDNumber_php_qt(getThis(), (uint) Z_LVAL_P(arg_0));
 
-			obj->setNumDigits((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try uint numDigitss0, QWidget * parent = 0,
+      QWidget *
+        cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+      QLCDNumber_php_qt *
+        selfpointer = new QLCDNumber_php_qt(getThis(), (uint) Z_LVAL_P(arg_0), (QWidget *) cpp_arg_1);
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QLCDNumber &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLCDNumber
+      if (inherits(Z_OBJCE_P(arg_0), 37)) {
+/// method is private, skip
+        php_error(E_ERROR, "QLCDNumber::__construct(...) cannot be called with 'const QLCDNumber &,'.");
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::QLCDNumber(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  numDigits
- *    flags:    c
+/*!
+ * method numDigits
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLCDNumber, numDigits){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			RETURN_LONG(obj->numDigits());
-	}
+
+ZEND_METHOD(QLCDNumber, numDigits)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'numDigits' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->numDigits());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::numDigits(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setMode
- *    flags:    
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLCDNumber, setMode){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method setHexMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+ZEND_METHOD(QLCDNumber, setHexMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setHexMode' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setHexMode());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::setHexMode(...) ");
+}
 
-			obj->setMode((QLCDNumber::Mode) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+/*!
+ * method setSmallDecimalPoint
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
+
+ZEND_METHOD(QLCDNumber, setSmallDecimalPoint)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setSmallDecimalPoint' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setSmallDecimalPoint((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::setSmallDecimalPoint(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLCDNumber, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QLCDNumber, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-				QString return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLCDNumber_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::sizeHint(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method setDecMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLCDNumber, qt_property){
+
+ZEND_METHOD(QLCDNumber, setDecMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setDecMode' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setDecMode());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::setDecMode(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  smallDecimalPoint
- *    flags:    c
+/*!
+ * method setMode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Mode Modes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLCDNumber, smallDecimalPoint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->smallDecimalPoint());
-	}
+
+ZEND_METHOD(QLCDNumber, setMode)
+{
+// notice: unknown argument Mode Modes0, skipped
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::setMode(...) ");
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setBinMode
- *    flags:    l
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLCDNumber, setBinMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			obj->setBinMode();
-			RETURN_NULL();
-	}
-}
 
+ZEND_METHOD(QLCDNumber, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-PHP_QT_DESTRUCT(QLCDNumber);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLCDNumber *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLCDNumber::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLCDNumber * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLCDNumber::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLCDNumber::trUtf8(...) ");
+}

Modified: trunk/qt/classes/qlineedit.cpp
===================================================================
--- trunk/qt/classes/qlineedit.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlineedit.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLineEdit.cpp - QLineEdit PHP implementation.
- * begin           : Thu Feb  9 23:08:03 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -28,1358 +27,2655 @@
 using namespace std;
 
 #include "../php_qt.h"
+
+
 #include <QLineEdit>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QLineEdit_php_qt:public QLineEdit
+{
 
+public:
+  QLineEdit_php_qt(zval * zend_ptr, QWidget * parent = 0);
+  QLineEdit_php_qt(zval * zend_ptr, const QString & s0, QWidget * parent = 0);
 
 
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
-/*		public enumEchoMode:long {
-			EchoMode = 0,
-			EchoMode = 1,
-			EchoMode = 2
-		}
-*/
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  tr
- *    flags:    s
+QLineEdit_php_qt::QLineEdit_php_qt(zval * zend_ptr, QWidget * parent):QLineEdit(parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QLineEdit",&staticMetaObject));
+}
+QLineEdit_php_qt::QLineEdit_php_qt(zval * zend_ptr, const QString & s0, QWidget * parent):
+QLineEdit(s0, parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QLineEdit",&staticMetaObject));
+}
+
+PHP_QT_MOC(QLineEdit);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLineEdit, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QLineEdit, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QLineEdit::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLineEdit::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLineEdit::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLineEdit::tr(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  inputMask
- *    flags:    c
+/*!
+ * method inputMask
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, inputMask){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj->inputMask();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, inputMask)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'inputMask' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->inputMask());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLineEdit::inputMask(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  insert
- *    flags:    
+/*!
+ * method insert
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, insert){
-		/* o public*/
 
-		/* const QString& ,  */
+ZEND_METHOD(QLineEdit, insert)
+{
+  ///const QString &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'insert' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QLineEdit *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QString")) {
-				obj->insert((const QString&) *obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_VOID(selfpointer->insert((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::insert(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cursorPosition
- *    flags:    c
+/*!
+ * method cursorPosition
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, cursorPosition){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_LONG(obj->cursorPosition());
-	}
+
+ZEND_METHOD(QLineEdit, cursorPosition)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'cursorPosition' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->cursorPosition());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::cursorPosition(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  clear
- *    flags:    l
+/*!
+ * method mouseMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, clear){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj->clear();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  selectionStart
- *    flags:    c
+/*!
+ * method clear
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, selectionStart){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_LONG(obj->selectionStart());
-	}
+
+ZEND_METHOD(QLineEdit, clear)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'clear' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->clear());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::clear(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setMaxLength
- *    flags:    
+/*!
+ * method selectionStart
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, setMaxLength){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLineEdit, selectionStart)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'selectionStart' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->selectionStart());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::selectionStart(...) ");
+}
 
+/*!
+ * method setMaxLength
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj->setMaxLength((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QLineEdit, setMaxLength)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMaxLength' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMaxLength((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::setMaxLength(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  qt_invoke
- *    flags:    v
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLineEdit, qt_invoke){
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setModified
- *    flags:    
+/*!
+ * method setModified
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, setModified){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLineEdit, setModified)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setModified' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setModified((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::setModified(...) ");
+}
 
+/*!
+ * method setFrame
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj->setModified((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QLineEdit, setFrame)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setFrame' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setFrame((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::setFrame(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setFrame
- *    flags:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QLineEdit, setFrame){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method setReadOnly
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+ZEND_METHOD(QLineEdit, setReadOnly)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setReadOnly' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QLineEdit *selfpointer;
 
-
-			obj->setFrame((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setReadOnly((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::setReadOnly(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method setEchoMode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	EchoMode EchoModes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, qt_cast){
+
+ZEND_METHOD(QLineEdit, setEchoMode)
+{
+// notice: unknown argument EchoMode EchoModes0, skipped
+  php_error(E_ERROR, "could not parse argument in QLineEdit::setEchoMode(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setReadOnly
- *    flags:    
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QLineEdit, setReadOnly){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method cursorBackward
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool marks0
+ * @param	 int steps = 1s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_BOOL){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+ZEND_METHOD(QLineEdit, cursorBackward)
+{
+  ///bool marks0, int steps = 1s1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'cursorBackward' is not static");
+        RETURN_NULL();
+      }
+      /// try bool marks0,
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->cursorBackward((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'cursorBackward' is not static");
+        RETURN_NULL();
+      }
+      /// try bool marks0, int steps = 1s1,
+      QLineEdit *selfpointer;
 
-			obj->setReadOnly((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->cursorBackward((bool) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::cursorBackward(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setEchoMode
- *    flags:    
+/*!
+ * method cursorWordBackward
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool marks0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, setEchoMode){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLineEdit, cursorWordBackward)
+{
+  ///bool marks0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'cursorWordBackward' is not static");
+        RETURN_NULL();
+      }
+      /// try bool marks0,
+      QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->cursorWordBackward((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::cursorWordBackward(...) ");
+}
 
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-			obj->setEchoMode((QLineEdit::EchoMode) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+/*!
+ * method setAlignment
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Alignment flags0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLineEdit, setAlignment)
+{
+  ///Qt::Alignment flags0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setAlignment' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::Alignment flags0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setAlignment((Qt::Alignment) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::setAlignment(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  metaObject
- *    flags:    cv
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QLineEdit, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QMetaObject ** return_object = new QMetaObject *;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QMetaObject *) obj->metaObject();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cursorBackward
- *    flags:    
+/*!
+ * method dragLeaveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDragLeaveEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, cursorBackward){
-		/* ll public*/
 
-		/* int mark, int steps,  */
+/*!
+ * method QLineEdit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * parent=0s0
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * @param	 QWidget * parent=0
+ * 
+ * overloaded args:
+ * @param	const QLineEdit &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+ZEND_METHOD(QLineEdit, __construct)
+{
+  ///QWidget * parent=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit_php_qt *selfpointer = new QLineEdit_php_qt(getThis());
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget * parent=0s0,
+      QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QLineEdit_php_qt *selfpointer = new QLineEdit_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-			obj->cursorBackward((bool) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QString &s0, QWidget * parent=0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cursorWordBackward
- *    flags:    
- */
-ZEND_METHOD(QLineEdit, cursorWordBackward){
-		/* l public*/
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QLineEdit_php_qt *selfpointer = new QLineEdit_php_qt(getThis(), (const QString &)*cpp_arg_0);
 
-		/* int mark,  */
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0, QWidget * parent=0,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QWidget *cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+        QLineEdit_php_qt *selfpointer = new QLineEdit_php_qt(getThis(), (const QString &)*cpp_arg_0, (QWidget *) cpp_arg_1);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-			obj->cursorWordBackward((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+    }
+  }
+  ///const QLineEdit &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLineEdit
+      if (inherits(Z_OBJCE_P(arg_0), 43)) {
+/// method is private, skip
+        php_error(E_ERROR, "QLineEdit::__construct(...) cannot be called with 'const QLineEdit &,'.");
+      }
+#endif
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  qt_emit
- *    flags:    v
- */
-ZEND_METHOD(QLineEdit, qt_emit){
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::QLineEdit(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setAlignment
- *    flags:    
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QLineEdit, setAlignment){
-		/* l public*/
 
-		/* int flag,  */
+ZEND_METHOD(QLineEdit, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setAlignment((Qt::Alignment) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QLineEdit::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLineEdit::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method mouseReleaseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, className){
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  QLineEdit
- *    flags:    t
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, __construct){
-		/* o public*/
 
-		/* qt_QWidget* parent,  */
+/*!
+ * method inputMethodQuery
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::InputMethodQuery Qt::InputMethodQuerys0
+ * 
+ * @access	public
+ * @return	QVariant
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			    QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QLineEdit, inputMethodQuery)
+{
+  ///Qt::InputMethodQuery Qt::InputMethodQuerys0
+#ifdef PHP_QT_QVariant          // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'inputMethodQuery' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::InputMethodQuery Qt::InputMethodQuerys0,
+      QLineEdit *selfpointer;
 
-			    if(obj_z_0->inherits("QWidget")) {
-				    QLineEdit *QLineEdit_ptr = new QLineEdit((QWidget*) obj_z_0);
-				    PHP_QT_REGISTER(QLineEdit_ptr);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				    RETURN_NULL();
-			    }
-			} else if(Z_TYPE_P(z_0) == IS_STRING){
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QVariant *return_object = new QVariant;
 
-			    QString *str = new QString("");
-			    *str = QString(QString::fromUtf8(Z_STRVAL_P(z_0)));
+      *return_object = static_cast < QVariant > (selfpointer->inputMethodQuery((Qt::InputMethodQuery) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			    zend_class_entry *ce;                                   
-			    object_init_ex(z_0, QString_ce_ptr);
-			    zend_rsrc_list_entry le_;                            
-			    le_.ptr = str;
-			    php_qt_register(z_0,le_);                                 
+  php_error(E_ERROR, "could not parse argument in QLineEdit::inputMethodQuery(...) ");
+}
 
-			    QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method text
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-				QLineEdit *QLineEdit_ptr = new QLineEdit((const QString&) *obj_z_0);
-				PHP_QT_REGISTER(QLineEdit_ptr);
-				RETURN_NULL();
+ZEND_METHOD(QLineEdit, text)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-			}
-            
-		}
-	}
-		/* oo public*/
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'text' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-		/* const QString& , qt_QWidget* parent,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
+      *return_object = static_cast < QString > (selfpointer->text());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			if(Z_TYPE_P(z_0) == IS_STRING){
+  php_error(E_ERROR, "could not parse argument in QLineEdit::text(...) ");
+}
 
-			  QString *str = new QString("");
-			  *str = QString(QString::fromUtf8(Z_STRVAL_P(z_0)));
+/*!
+ * method minimumSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
+ */
 
-			  zend_class_entry *ce;                                   
-			  object_init_ex(z_0, QString_ce_ptr);
-			  zend_rsrc_list_entry le;                            
-			  le.ptr = str;
-			  php_qt_register(z_0,le);                                 
+ZEND_METHOD(QLineEdit, minimumSizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-			}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumSizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
 
-//			if(!strcmp(Z_OBJCE_P(z_0)->name,"QString") && obj_z_1->inherits("QWidget")) {
-				QLineEdit *QLineEdit_ptr = new QLineEdit((const QString&) *obj_z_0, (QWidget*) obj_z_1);
-				PHP_QT_REGISTER(QLineEdit_ptr);
-				RETURN_NULL();
-//			}
-			}
-		}
-	}
+      *return_object = static_cast < QSize > (selfpointer->minimumSizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLineEdit::minimumSizeHint(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method home
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool marks0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, staticMetaObject){
+
+ZEND_METHOD(QLineEdit, home)
+{
+  ///bool marks0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'home' is not static");
+        RETURN_NULL();
+      }
+      /// try bool marks0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->home((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::home(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method returnPressed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QLineEdit, qObject){
+
+/*!
+ * method del
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLineEdit, del)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'del' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->del());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::del(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  inputMethodQuery
- *    flags:    c
+/*!
+ * method dropEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDropEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, inputMethodQuery){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method cursorForward
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool marks0
+ * @param	 int steps = 1s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+ZEND_METHOD(QLineEdit, cursorForward)
+{
+  ///bool marks0, int steps = 1s1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'cursorForward' is not static");
+        RETURN_NULL();
+      }
+      /// try bool marks0,
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->cursorForward((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'cursorForward' is not static");
+        RETURN_NULL();
+      }
+      /// try bool marks0, int steps = 1s1,
+      QLineEdit *selfpointer;
 
-			QVariant* return_object = new QVariant;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QVariant) obj->inputMethodQuery((Qt::InputMethodQuery) Z_LVAL_P(z_0));
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->cursorForward((bool) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::cursorForward(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  text
- *    flags:    c
+/*!
+ * method setDragEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, text){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj->text();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, setDragEnabled)
+{
+  ///bool bs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setDragEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bs0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setDragEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::setDragEnabled(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  minimumSizeHint
- *    flags:    c
+/*!
+ * method contextMenuEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QContextMenuEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, minimumSizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QSize* return_object = new QSize;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->minimumSizeHint();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  home
- *    flags:    
+/*!
+ * method cursorPositionChanged
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * @param	 int  ints1
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QLineEdit, home){
-		/* l public*/
 
-		/* int mark,  */
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+/*!
+ * method echoMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	EchoMode
+ * @flags	c
+ */
 
-
-			obj->home((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QLineEdit, echoMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type EchoMode");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::echoMode(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  del
- *    flags:    
+/*!
+ * method inputMethodEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QInputMethodEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, del){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj->del();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cursorForward
- *    flags:    
+/*!
+ * method setValidator
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QValidator *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, cursorForward){
-		/* ll public*/
 
-		/* int mark, int steps,  */
+ZEND_METHOD(QLineEdit, setValidator)
+{
+  ///const QValidator *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QValidator
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setValidator' is not static");
+          RETURN_NULL();
+        }
+        /// try const QValidator *s0,
+        QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+        }
+        QValidator *cpp_arg_0 = static_cast < QValidator * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setValidator((const QValidator *)cpp_arg_0));
+      }
+#endif
 
-			obj->cursorForward((bool) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::setValidator(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setDragEnabled
- *    flags:    
+/*!
+ * method hasSelectedText
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, setDragEnabled){
-		/* l public*/
 
-		/* int b,  */
+ZEND_METHOD(QLineEdit, hasSelectedText)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hasSelectedText' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-
-
-			obj->setDragEnabled((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->hasSelectedText());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::hasSelectedText(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method textChanged
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QLineEdit, qt_property){
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  echoMode
- *    flags:    c
+/*!
+ * method paste
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, echoMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_LONG(obj->echoMode());
-	}
+
+ZEND_METHOD(QLineEdit, paste)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'paste' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->paste());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::paste(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setValidator
- *    flags:    
+/*!
+ * method hasAcceptableInput
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, setValidator){
-		/* o public*/
 
-		/* const QValidator* ,  */
+ZEND_METHOD(QLineEdit, hasAcceptableInput)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hasAcceptableInput' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->hasAcceptableInput());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::hasAcceptableInput(...) ");
+}
 
+/*!
+ * method copy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	cl
+ */
 
-			if(obj_z_0->inherits("QValidator")) {
-				obj->setValidator((const QValidator*) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QLineEdit, copy)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'copy' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->copy());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::copy(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  hasSelectedText
- *    flags:    c
+/*!
+ * method redo
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, hasSelectedText){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->hasSelectedText());
-	}
+
+ZEND_METHOD(QLineEdit, redo)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'redo' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->redo());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::redo(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  hasAcceptableInput
- *    flags:    c
+/*!
+ * method dragEnterEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDragEnterEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, hasAcceptableInput){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->hasAcceptableInput());
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  paste
- *    flags:    l
+/*!
+ * method undo
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, paste){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj->paste();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLineEdit, undo)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'undo' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->undo());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::undo(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  redo
- *    flags:    l
+/*!
+ * method cursorWordForward
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool marks0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, redo){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj->redo();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLineEdit, cursorWordForward)
+{
+  ///bool marks0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'cursorWordForward' is not static");
+        RETURN_NULL();
+      }
+      /// try bool marks0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->cursorWordForward((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::cursorWordForward(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  copy
- *    flags:    cl
+/*!
+ * method displayText
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, copy){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj->copy();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLineEdit, displayText)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'displayText' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->displayText());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLineEdit::displayText(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  undo
- *    flags:    l
+/*!
+ * method focusOutEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, undo){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj->undo();
-			RETURN_NULL();
-	}
+
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
+
+ZEND_METHOD(QLineEdit, event)
+{
+  ///QEvent *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 21)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'event' is not static");
+          RETURN_NULL();
+        }
+        /// try QEvent *s0,
+        QLineEdit *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+        }
+        QEvent *cpp_arg_0 = static_cast < QEvent * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->event((QEvent *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::event(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  displayText
- *    flags:    c
+/*!
+ * method end
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool marks0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, displayText){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj->displayText();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, end)
+{
+  ///bool marks0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'end' is not static");
+        RETURN_NULL();
+      }
+      /// try bool marks0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->end((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::end(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cursorWordForward
- *    flags:    
+/*!
+ * method validator
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QValidator *
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, cursorWordForward){
-		/* l public*/
 
-		/* int mark,  */
+ZEND_METHOD(QLineEdit, validator)
+{
+  ///
+#ifdef PHP_QT_QValidator        // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'validator' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->cursorWordForward((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast < QValidator * >(selfpointer->validator());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLineEdit::validator(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  event
- *    flags:    
+/*!
+ * method isRedoAvailable
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, event){
-		/* o public*/
 
-		/* qt_QEvent* ,  */
+ZEND_METHOD(QLineEdit, isRedoAvailable)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isRedoAvailable' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isRedoAvailable());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::isRedoAvailable(...) ");
+}
 
+/*!
+ * method deselect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QEvent")) {
-				RETURN_BOOL(obj->event((QEvent*) obj_z_0));
-			}
-			}
-		}
-	}
+ZEND_METHOD(QLineEdit, deselect)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'deselect' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->deselect());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::deselect(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  validator
- *    flags:    c
+/*!
+ * method cursorPositionAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &poss0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, validator){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			const QValidator ** return_object = new const QValidator *;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (const QValidator *) obj->validator();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, cursorPositionAt)
+{
+  ///const QPoint &poss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'cursorPositionAt' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &poss0,
+        QLineEdit *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+        }
+        QPoint *cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->cursorPositionAt((const QPoint &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::cursorPositionAt(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  end
- *    flags:    
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, end){
-		/* l public*/
 
-		/* int mark,  */
+/*!
+ * method selectedText
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+ZEND_METHOD(QLineEdit, selectedText)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'selectedText' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-			obj->end((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->selectedText());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLineEdit::selectedText(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  isRedoAvailable
- *    flags:    c
+/*!
+ * method setSelection
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * @param	 int  ints1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, isRedoAvailable){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isRedoAvailable());
-	}
+
+ZEND_METHOD(QLineEdit, setSelection)
+{
+  ///int ints0, int  ints1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setSelection' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0, int  ints1,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setSelection((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::setSelection(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cursorPositionAt
- *    flags:    
+/*!
+ * method mouseDoubleClickEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, cursorPositionAt){
-		/* l public*/
 
-		/* const QPoint& pos,  */
+/*!
+ * method selectionChanged
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+/*!
+ * method isUndoAvailable
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
+ZEND_METHOD(QLineEdit, isUndoAvailable)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isUndoAvailable' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-			RETURN_LONG(obj->cursorPositionAt((const QPoint&) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isUndoAvailable());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::isUndoAvailable(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  deselect
- *    flags:    
+/*!
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, deselect){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj->deselect();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setSelection
- *    flags:    
+/*!
+ * method setInputMask
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &inputMasks0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, setSelection){
-		/* ll public*/
 
-		/* int , int ,  */
+ZEND_METHOD(QLineEdit, setInputMask)
+{
+  ///const QString &inputMasks0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setInputMask' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &inputMasks0,
+        QLineEdit *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			obj->setSelection((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+        RETURN_VOID(selfpointer->setInputMask((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::setInputMask(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  selectedText
- *    flags:    c
+/*!
+ * method hasFrame
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, selectedText){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj->selectedText();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, hasFrame)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hasFrame' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->hasFrame());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::hasFrame(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  isUndoAvailable
- *    flags:    c
+/*!
+ * method mousePressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, isUndoAvailable){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isUndoAvailable());
-	}
+
+/*!
+ * method dragEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+ZEND_METHOD(QLineEdit, dragEnabled)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'dragEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->dragEnabled());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::dragEnabled(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  hasFrame
- *    flags:    c
+/*!
+ * method cut
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, hasFrame){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->hasFrame());
-	}
+
+ZEND_METHOD(QLineEdit, cut)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'cut' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->cut());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::cut(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setInputMask
- *    flags:    
+/*!
+ * method setText
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, setInputMask){
-		/* o public*/
 
-		/* const QString& inputMask,  */
+ZEND_METHOD(QLineEdit, setText)
+{
+  ///const QString &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setText' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QLineEdit *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QString")) {
-				obj->setInputMask((const QString&) *obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_VOID(selfpointer->setText((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::setText(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  dragEnabled
- *    flags:    c
+/*!
+ * method alignment
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Alignment
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, dragEnabled){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->dragEnabled());
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cut
- *    flags:    l
- */
-ZEND_METHOD(QLineEdit, cut){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj->cut();
-			RETURN_NULL();
-	}
+ZEND_METHOD(QLineEdit, alignment)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'alignment' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->alignment());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::alignment(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setText
- *    flags:    l
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, setText){
-		/* o public_slots*/
 
-		/* const QString& ,  */
+ZEND_METHOD(QLineEdit, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QString")) {
-				obj->setText((const QString&) *obj_z_0);
-			    RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_STRING){
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
 
-			    QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+      *return_object = static_cast < QSize > (selfpointer->sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-				obj->setText(Z_STRVAL_P(z_0));
-			    RETURN_NULL();
-			}
-			
-
-		}
-
-	}
+  php_error(E_ERROR, "could not parse argument in QLineEdit::sizeHint(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  alignment
- *    flags:    c
+/*!
+ * method dragMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDragMoveEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, alignment){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_LONG(obj->alignment());
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method setCursorPosition
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QSize* return_object = new QSize;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->sizeHint();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, setCursorPosition)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setCursorPosition' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setCursorPosition((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::setCursorPosition(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setCursorPosition
- *    flags:    
+/*!
+ * method createStandardContextMenu
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMenu *
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, setCursorPosition){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLineEdit, createStandardContextMenu)
+{
+  ///
+#ifdef PHP_QT_QMenu             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'createStandardContextMenu' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setCursorPosition((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QMenu * >(selfpointer->createStandardContextMenu());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLineEdit::createStandardContextMenu(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  createStandardContextMenu
- *    flags:    
+/*!
+ * method backspace
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, createStandardContextMenu){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QMenu ** return_object = new QMenu *;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QMenu *) obj->createStandardContextMenu();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, backspace)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'backspace' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->backspace());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::backspace(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  backspace
- *    flags:    
+/*!
+ * method keyPressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, backspace){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj->backspace();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  selectAll
- *    flags:    l
+/*!
+ * method selectAll
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, selectAll){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj->selectAll();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLineEdit, selectAll)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'selectAll' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->selectAll());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::selectAll(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  maxLength
- *    flags:    c
+/*!
+ * method focusInEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, maxLength){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_LONG(obj->maxLength());
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  isModified
- *    flags:    c
+/*!
+ * method editingFinished
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QLineEdit, isModified){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isModified());
-	}
+
+/*!
+ * method textEdited
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
+
+/*!
+ * method maxLength
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QLineEdit, maxLength)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'maxLength' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->maxLength());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::maxLength(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLineEdit, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QLineEdit, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QLineEdit::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLineEdit::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QLineEdit::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QLineEdit::trUtf8(...) ");
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  isReadOnly
- *    flags:    c
+/*!
+ * method isModified
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, isReadOnly){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isReadOnly());
-	}
+
+ZEND_METHOD(QLineEdit, isModified)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isModified' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isModified());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::isModified(...) ");
 }
 
+/*!
+ * method isReadOnly
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QLineEdit);
+ZEND_METHOD(QLineEdit, isReadOnly)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isReadOnly' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isReadOnly());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QLineEdit::isReadOnly(...) ");
+}

Modified: trunk/qt/classes/qmouseevent.cpp
===================================================================
--- trunk/qt/classes/qmouseevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qmouseevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,145 +19,359 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QMouseEvent.cpp - QMouseEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QMouseEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  x
- *    flags:    c
+#include <QMouseEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QMouseEvent_php_qt:public QMouseEvent
+{
+
+public:
+  QMouseEvent_php_qt(zval * zend_ptr, Type types0, const QPoint & poss1, Qt::MouseButton buttons2, Qt::MouseButtons buttonss3,
+                     Qt::KeyboardModifiers modifierss4);
+    QMouseEvent_php_qt(zval * zend_ptr, Type types0, const QPoint & poss1, const QPoint & globalPoss2, Qt::MouseButton buttons3, Qt::MouseButtons buttonss4,
+                       Qt::KeyboardModifiers modifierss5);
+
+
+  zval *zend_ptr;
+};
+QMouseEvent_php_qt::QMouseEvent_php_qt(zval * zend_ptr, Type types0, const QPoint & poss1, Qt::MouseButton buttons2, Qt::MouseButtons buttonss3,
+                                       Qt::KeyboardModifiers modifierss4):
+QMouseEvent(types0, poss1, buttons2, buttonss3, modifierss4)
+{
+  this->zend_ptr = zend_ptr;
+}
+QMouseEvent_php_qt::QMouseEvent_php_qt(zval * zend_ptr, Type types0, const QPoint & poss1, const QPoint & globalPoss2, Qt::MouseButton buttons3,
+                                       Qt::MouseButtons buttonss4, Qt::KeyboardModifiers modifierss5):
+QMouseEvent(types0, poss1, globalPoss2, buttons3, buttonss4, modifierss5)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method y
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, x){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->x());
-	}
+
+ZEND_METHOD(QMouseEvent, y)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'y' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QMouseEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->y());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QMouseEvent::y(...) ");
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  globalX
- *    flags:    c
+/*!
+ * method QMouseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	const QPoint &poss1s1
+ * @param	Qt::MouseButton buttons2s2
+ * @param	Qt::MouseButtons buttonss3s3
+ * @param	Qt::KeyboardModifiers modifierss4s4
+ * 
+ * overloaded args:
+ * @param	Type types0
+ * @param	const QPoint &poss1
+ * @param	const QPoint &globalPoss2
+ * @param	Qt::MouseButton buttons3
+ * @param	Qt::MouseButtons buttonss4
+ * @param	Qt::KeyboardModifiers modifierss5
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QMouseEvent, globalX){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->globalX());
-	}
+
+ZEND_METHOD(QMouseEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+
+// notice: unknown argument Type types0, skipped
+  php_error(E_ERROR, "could not parse argument in QMouseEvent::QMouseEvent(...) ");
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  globalPos
- *    flags:    c
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, globalPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-				const QPoint & return_object = (const QPoint &) obj->globalPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QMouseEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QMouseEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QMouseEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QMouseEvent::pos(...) ");
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  y
- *    flags:    c
+/*!
+ * method globalX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, y){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->y());
-	}
+
+ZEND_METHOD(QMouseEvent, globalX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalX' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QMouseEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->globalX());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QMouseEvent::globalX(...) ");
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  globalY
- *    flags:    c
+/*!
+ * method globalPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, globalY){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->globalY());
-	}
+
+ZEND_METHOD(QMouseEvent, globalPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalPos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QMouseEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->globalPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QMouseEvent::globalPos(...) ");
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method buttons
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::MouseButtons
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-				const QPoint & return_object = (const QPoint &) obj->pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QMouseEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QMouseEvent, buttons)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'buttons' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QMouseEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->buttons());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QMouseEvent::buttons(...) ");
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  button
- *    flags:    c
+/*!
+ * method x
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, button){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-				Qt::MouseButton return_object = (Qt::MouseButton) obj->button();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QMouseEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QMouseEvent, x)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'x' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QMouseEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->x());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QMouseEvent::x(...) ");
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  buttons
- *    flags:    c
+/*!
+ * method globalY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, buttons){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-				Qt::MouseButtons return_object = (Qt::MouseButtons) obj->buttons();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QMouseEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QMouseEvent, globalY)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalY' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QMouseEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->globalY());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QMouseEvent::globalY(...) ");
 }
 
+/*!
+ * method button
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::MouseButton
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QMouseEvent);
+ZEND_METHOD(QMouseEvent, button)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'button' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QMouseEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->button());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QMouseEvent::button(...) ");
+}

Modified: trunk/qt/classes/qmoveevent.cpp
===================================================================
--- trunk/qt/classes/qmoveevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qmoveevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,55 +19,162 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QMoveEvent.cpp - QMoveEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QMoveEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QMoveEvent */
-/*
- *    function  oldPos
- *    flags:    c
+#include <QMoveEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QMoveEvent_php_qt:public QMoveEvent
+{
+
+public:
+  QMoveEvent_php_qt(zval * zend_ptr, const QPoint & poss0, const QPoint & oldPoss1);
+
+
+  zval *zend_ptr;
+};
+QMoveEvent_php_qt::QMoveEvent_php_qt(zval * zend_ptr, const QPoint & poss0, const QPoint & oldPoss1):
+QMoveEvent(poss0, oldPoss1)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &
+ * @flags	c
  */
-ZEND_METHOD(QMoveEvent, oldPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QMoveEvent *obj = (QMoveEvent*) PHP_QT_FETCH();
-				const QPoint & return_object = (const QPoint &) obj->oldPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QMoveEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QMoveEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QMoveEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QMoveEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QMoveEvent::pos(...) ");
 }
 
-/*********************************
- *    class     QMoveEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method QMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &poss0s0
+ * @param	const QPoint &oldPoss1s1
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QMoveEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QMoveEvent *obj = (QMoveEvent*) PHP_QT_FETCH();
-				const QPoint & return_object = (const QPoint &) obj->pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QMoveEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QMoveEvent, __construct)
+{
+  ///const QPoint &poss0s0,const QPoint &oldPoss1s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &poss0s0,const QPoint &oldPoss1s1,
+        QPoint *cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QPoint *cpp_arg_1 = static_cast < QPoint * >(php_qt_fetch(arg_1));
+        QMoveEvent_php_qt *selfpointer = new QMoveEvent_php_qt(getThis(), (const QPoint &)*cpp_arg_0, (const QPoint &)*cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QMoveEvent::QMoveEvent(...) ");
 }
 
+/*!
+ * method oldPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QMoveEvent);
+ZEND_METHOD(QMoveEvent, oldPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'oldPos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QMoveEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QMoveEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->oldPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QMoveEvent::oldPos(...) ");
+}

Modified: trunk/qt/classes/qobject.cpp
===================================================================
--- trunk/qt/classes/qobject.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qobject.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,1110 +19,2080 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QObject.cpp - QObject PHP implementation.
- * begin           : Wed Jan 11 20:29:53 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QObject>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QObject */
-/*
- *    function  removeEventFilter
- *    flags:    
- */
-ZEND_METHOD(QObject, removeEventFilter){
+#include <QObject>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QObject_php_qt:public QObject
+{
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+public:
+  QObject_php_qt(zval * zend_ptr, QObject * parent = 0);
 
-		/* QObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"o", &z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
 
-			QString tmp_o_0(var_o_0->metaObject()->className());
-			
-			if(tmp_o_0 == "QObject*") {
-				obj->removeEventFilter((QObject*) var_o_0);
-			RETURN_NULL();
-			}
-		}
-	}
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+
+QObject_php_qt::QObject_php_qt(zval * zend_ptr, QObject * parent):QObject(parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QObject",&staticMetaObject));
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  connectNotify
- *    flags:    v
+PHP_QT_MOC(QObject);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * overloaded args:
+ * @param	const char *
+ * @param	 const char *
+ * 
+ * overloaded args:
+ * @param	const char *sourceText
+ * @param	 const char * = 0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QObject, connectNotify){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+ZEND_METHOD(QObject, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QObject *
+        selfpointer;
 
-		/* const char* signal,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s", &var_s_0, len_s_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			
-			obj->connectNotify( (const char*) var_s_0);
-			RETURN_NULL();
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-/*********************************
- *    class     QObject */
-/*
- *    function  tr
- *    flags:    s
- */
-ZEND_METHOD(QObject, tr){
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QObject::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QObject *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* ss */
-		char* var_ss_0;   // default: 
-		int len_ss_0;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-		char* var_ss_1;   // default: 0
-		int len_ss_1;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QObject::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-		/* const char* , const char* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"ss|", &var_ss_0, len_ss_0, &var_ss_1, len_ss_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
 
-									
-			QString return_object = (QString) obj->tr( (const char*) var_ss_0 , (const char*) var_ss_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-		}
-	}
-}
+  ///const char *, const char *
+#ifdef PHP_QT_QString           // return type
 
-/*********************************
- *    class     QObject */
-/*
- *    function  disconnect
- *    flags:    
- */
-ZEND_METHOD(QObject, disconnect){
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try const char *, const char *,
+      QObject *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* os */
-		zval* z_var_os_0;   // default: 
-		char* var_os_1;   // default: 0
-		int len_os_1;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-		/* const QObject* receiver, const char* member,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"os|", &z_var_os_0, &var_os_1, len_os_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_os_0 = (QObject*) php_qt_fetch(z_var_os_0);
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QObject::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			QString tmp_os_0(var_os_0->metaObject()->className());
-			
-			if(tmp_os_0 == "const QObject*") {
-				RETURN_BOOL(obj->disconnect((const QObject*) var_os_0, (const char*) var_os_1));
-			}
-		}
-	}
 
-	if (ZEND_NUM_ARGS() == 3){
-		/* sos */
-		char* var_sos_0;   // default: 0
-		int len_sos_0;
+  ///const char *sourceText, const char * = 0
+#ifdef PHP_QT_QString           // return type
 
-		zval* z_var_sos_1;   // default: 0
-		char* var_sos_2;   // default: 0
-		int len_sos_2;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *sourceText,
+      QObject *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-		/* const char* signal, const QObject* receiver, const char* member,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s|o|s|", &var_sos_0, len_sos_0, &z_var_sos_1, &var_sos_2, len_sos_2) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_sos_1 = (QObject*) php_qt_fetch(z_var_sos_1);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-			QString tmp_sos_0(var_sos_1->metaObject()->className());
-			
-			if(tmp_sos_0 == "const QObject*") {
-				RETURN_BOOL(obj->disconnect((const char*) var_sos_0, (const QObject*) var_sos_1, (const char*) var_sos_2));
-			}
-		}
-	}
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QObject::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try const char *sourceText, const char * = 0,
+      QObject *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 4){
-		/* osos */
-		zval* z_var_osos_0;   // default: 
-		char* var_osos_1;   // default: 
-		int len_osos_1;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-		zval* z_var_osos_2;   // default: 
-		char* var_osos_3;   // default: 
-		int len_osos_3;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QObject::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-		/* const QObject* sender, const char* signal, const QObject* receiver, const char* member,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"osos", &z_var_osos_0, &var_osos_1, len_osos_1, &z_var_osos_2, &var_osos_3, len_osos_3) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_osos_0 = (QObject*) php_qt_fetch(z_var_osos_0);
-			QObject* var_osos_2 = (QObject*) php_qt_fetch(z_var_osos_2);
-
-			QString tmp_osos_0(var_osos_0->metaObject()->className());
-			QString tmp_osos_1(var_osos_2->metaObject()->className());
-			
-			if(tmp_osos_0 == "const QObject*" && tmp_osos_1 == "const QObject*") {
-				RETURN_BOOL(obj->disconnect((const QObject*) var_osos_0, (const char*) var_osos_1, (const QObject*) var_osos_2, (const char*) var_osos_3));
-			}
-		}
-	}
+  php_error(E_ERROR, "could not parse argument in QObject::tr(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  children
- *    flags:    c
+/*!
+ * method children
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QObjectList &
+ * @flags	c
  */
-ZEND_METHOD(QObject, children){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			const QObjectList & return_object = (const QObjectList &) obj->children();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QObject, children)
+{
+  ///
+#ifdef PHP_QT_QObjectList       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'children' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &const_cast < QObjectList & >(selfpointer->children());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QObject::children(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  qt_invoke
- *    flags:    v
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QObject, qt_invoke){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* lo */
-		long var_lo_0;    // default: 
-		zval* z_var_lo_1;   // default: 
+/*!
+ * method installEventFilter
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-		/* int , QUObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"lo", &var_lo_0, &z_var_lo_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_lo_1 = (QObject*) php_qt_fetch(z_var_lo_1);
+ZEND_METHOD(QObject, installEventFilter)
+{
+  ///QObject *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'installEventFilter' is not static");
+          RETURN_NULL();
+        }
+        /// try QObject *s0,
+        QObject *
+          selfpointer;
 
-			QString tmp_lo_0(var_lo_1->metaObject()->className());
-			
-			if(tmp_lo_0 == "QUObject*") {
-				RETURN_BOOL(obj->qt_invoke((int) var_lo_0, (QUObject*) var_lo_1));
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->installEventFilter((QObject *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::installEventFilter(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  deleteLater
- *    flags:    l
+/*!
+ * method destroyed
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject * = 0s0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QObject, deleteLater){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			obj->deleteLater();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  installEventFilter
- *    flags:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QObject, installEventFilter){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+/*!
+ * method setProperty
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *names0
+ * @param	 const QVariant  &values1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
 
-		/* QObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"o", &z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+ZEND_METHOD(QObject, setProperty)
+{
+  ///const char *names0, const QVariant  &values1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QVariant
+      if (inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setProperty' is not static");
+          RETURN_NULL();
+        }
+        /// try const char *names0, const QVariant  &values1,
+        QObject *
+          selfpointer;
 
-			QString tmp_o_0(var_o_0->metaObject()->className());
-			
-			if(tmp_o_0 == "QObject*") {
-				obj->installEventFilter((QObject*) var_o_0);
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QVariant *
+          cpp_arg_1 = static_cast < QVariant * >(php_qt_fetch(arg_1));
+
+        RETURN_BOOL(selfpointer->setProperty((const char *)&Z_STRVAL_P(arg_0)[0], (const QVariant &)*cpp_arg_1));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::setProperty(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *names0
+ * 
+ * @access	public
+ * @return	QVariant
+ * @flags	c
  */
-ZEND_METHOD(QObject, qt_cast){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+ZEND_METHOD(QObject, property)
+{
+  ///const char *names0
+#ifdef PHP_QT_QVariant          // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'property' is not static");
+        RETURN_NULL();
+      }
+      /// try const char *names0,
+      QObject *
+        selfpointer;
 
-		/* const char* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s", &var_s_0, len_s_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			
-			obj->qt_cast( (const char*) var_s_0);
-			RETURN_NULL();
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QVariant *
+        return_object = new QVariant;
+
+      *return_object = static_cast < QVariant > (selfpointer->property((const char *)&Z_STRVAL_P(arg_0)[0]));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QObject::property(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  setProperty
- *    flags:    
+/*!
+ * method dumpObjectInfo
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, setProperty){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* so */
-		char* var_so_0;   // default: 
-		int len_so_0;
+ZEND_METHOD(QObject, dumpObjectInfo)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'dumpObjectInfo' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
 
-		zval* z_var_so_1;   // default: 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->dumpObjectInfo());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::dumpObjectInfo(...) ");
+}
 
-		/* const char* name, const QVariant& value,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"so", &var_so_0, len_so_0, &z_var_so_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_so_1 = (QObject*) php_qt_fetch(z_var_so_1);
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-			QString tmp_so_0(var_so_1->metaObject()->className());
-			
-			if(tmp_so_0 == "const QVariant&") {
-				RETURN_BOOL(obj->setProperty((const char*) var_so_0, (const QVariant&) var_so_1));
-			}
-		}
-	}
-}
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-/*********************************
- *    class     QObject */
-/*
- *    function  disconnectNotify
- *    flags:    v
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QObject, disconnectNotify){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+/*!
+ * method timerEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTimerEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
 
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
+ */
 
-		/* const char* signal,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s", &var_s_0, len_s_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+ZEND_METHOD(QObject, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-			
-			obj->disconnectNotify( (const char*) var_s_0);
-			RETURN_NULL();
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QObject::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QObject::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  property
- *    flags:    c
+/*!
+ * method userData
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uint ids0
+ * 
+ * @access	public
+ * @return	QObjectUserData*
+ * @flags	c
  */
-ZEND_METHOD(QObject, property){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+ZEND_METHOD(QObject, userData)
+{
+  ///uint ids0
+#ifdef PHP_QT_QObjectUserData   // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'userData' is not static");
+        RETURN_NULL();
+      }
+      /// try uint ids0,
+      QObject *
+        selfpointer;
 
-		/* const char* name,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s", &var_s_0, len_s_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			
-			QVariant return_object = (QVariant) obj->property( (const char*) var_s_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/*********************************
- *    class     QObject */
-/*
- *    function  dumpObjectInfo
- *    flags:    
- */
-ZEND_METHOD(QObject, dumpObjectInfo){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			obj->dumpObjectInfo();
-			RETURN_NULL();
-	}
+      le.ptr = static_cast < QObjectUserData * >(selfpointer->userData((uint) Z_LVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QObject::userData(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  registerUserData
- *    flags:    s
+/*!
+ * method setUserData
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uint ids0
+ * @param	 QObjectUserData * datas1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, registerUserData){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			RETURN_LONG(obj->registerUserData());
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  metaObject
- *    flags:    cv
- */
-ZEND_METHOD(QObject, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QMetaObject * return_object = (QMetaObject *) obj->metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			const QMetaObject * return_object = (const QMetaObject *) obj->metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QObject, setUserData)
+{
+  ///uint ids0, QObjectUserData * datas1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QObjectUserData
+      if (inherits(Z_OBJCE_P(arg_1), 48)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setUserData' is not static");
+          RETURN_NULL();
+        }
+        /// try uint ids0, QObjectUserData * datas1,
+        QObject *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QObjectUserData *
+          cpp_arg_1 = static_cast < QObjectUserData * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->setUserData((uint) Z_LVAL_P(arg_0), (QObjectUserData *) cpp_arg_1));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::setUserData(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  parent
- *    flags:    c
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QObject, parent){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject * return_object = (QObject *) obj->parent();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  receivers
- *    flags:    c
+/*!
+ * method setParent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, receivers){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+ZEND_METHOD(QObject, setParent)
+{
+  ///QObject *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setParent' is not static");
+          RETURN_NULL();
+        }
+        /// try QObject *s0,
+        QObject *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
 
-		/* const char* signal,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s", &var_s_0, len_s_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer->setParent((QObject *) cpp_arg_0));
+      }
+#endif
 
-			
-			RETURN_LONG(obj->receivers( (const char*) var_s_0));
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::setParent(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method killTimer
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ids0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, qt_emit){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* lo */
-		long var_lo_0;    // default: 
-		zval* z_var_lo_1;   // default: 
+ZEND_METHOD(QObject, killTimer)
+{
+  ///int ids0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'killTimer' is not static");
+        RETURN_NULL();
+      }
+      /// try int ids0,
+      QObject *
+        selfpointer;
 
-		/* int , QUObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"lo", &var_lo_0, &z_var_lo_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_lo_1 = (QObject*) php_qt_fetch(z_var_lo_1);
-
-			QString tmp_lo_0(var_lo_1->metaObject()->className());
-			
-			if(tmp_lo_0 == "QUObject*") {
-				RETURN_BOOL(obj->qt_emit((int) var_lo_0, (QUObject*) var_lo_1));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->killTimer((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::killTimer(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  event
- *    flags:    v
+/*!
+ * method childEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChildEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QObject, event){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+/*!
+ * method moveToThread
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QThread *threads0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-		/* QEvent* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"o", &z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+ZEND_METHOD(QObject, moveToThread)
+{
+  ///QThread *threads0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QThread
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'moveToThread' is not static");
+          RETURN_NULL();
+        }
+        /// try QThread *threads0,
+        QObject *
+          selfpointer;
 
-			QString tmp_o_0(var_o_0->metaObject()->className());
-			
-			if(tmp_o_0 == "QEvent*") {
-				RETURN_BOOL(obj->event((QEvent*) var_o_0));
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QThread *
+          cpp_arg_0 = static_cast < QThread * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->moveToThread((QThread *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::moveToThread(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method dumpObjectTree
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, className){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			const char * return_object = (const char *) obj->className();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QObject, dumpObjectTree)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'dumpObjectTree' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->dumpObjectTree());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::dumpObjectTree(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  thread
- *    flags:    c
+/*!
+ * method eventFilter
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * @param	 QEvent *s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QObject, thread){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QThread * return_object = (QThread *) obj->thread();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  isWidgetType
- *    flags:    c
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QObject, isWidgetType){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isWidgetType());
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  sender
- *    flags:    c
+/*!
+ * method removeEventFilter
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, sender){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject * return_object = (QObject *) obj->sender();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QObject, removeEventFilter)
+{
+  ///QObject *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'removeEventFilter' is not static");
+          RETURN_NULL();
+        }
+        /// try QObject *s0,
+        QObject *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->removeEventFilter((QObject *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::removeEventFilter(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  signalsBlocked
- *    flags:    c
+/*!
+ * method connectNotify
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *signals0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QObject, signalsBlocked){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->signalsBlocked());
-	}
+
+/*!
+ * method disconnect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *signal = 0s0
+ * @param	 const QObject *receiver = 0s1
+ * @param	 const char *member = 0s2
+ * 
+ * overloaded args:
+ * @param	const QObject *receiver
+ * @param	 const char *member = 0
+ * 
+ * overloaded args:
+ * @param	const QObject *sender
+ * @param	 const char *signal
+ * @param	 const QObject *receiver
+ * @param	 const char *member
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
+
+ZEND_METHOD(QObject, disconnect)
+{
+  ///const char *signal = 0s0, const QObject *receiver = 0s1, const char *member = 0s2
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'disconnect' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->disconnect());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'disconnect' is not static");
+        RETURN_NULL();
+      }
+      /// try const char *signal = 0s0,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->disconnect((const char *)&Z_STRVAL_P(arg_0)[0]));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'disconnect' is not static");
+        RETURN_NULL();
+      }
+      /// try const char *signal = 0s0, const QObject *receiver = 0s1,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      QObject *
+        cpp_arg_1 = static_cast < QObject * >(php_qt_fetch(arg_1));
+
+      RETURN_BOOL(selfpointer->disconnect((const char *)&Z_STRVAL_P(arg_0)[0], (const QObject *)cpp_arg_1));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'disconnect' is not static");
+        RETURN_NULL();
+      }
+      /// try const char *signal = 0s0, const QObject *receiver = 0s1, const char *member = 0s2,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      QObject *
+        cpp_arg_1 = static_cast < QObject * >(php_qt_fetch(arg_1));
+
+      RETURN_BOOL(selfpointer->disconnect((const char *)&Z_STRVAL_P(arg_0)[0], (const QObject *)cpp_arg_1, (const char *)&Z_STRVAL_P(arg_2)[0]));
+    }
+  }
+  ///const QObject *receiver, const char *member = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'disconnect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QObject *receiver,
+        QObject *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->disconnect((const QObject *)cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_STRING) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'disconnect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QObject *receiver, const char *member = 0,
+        QObject *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->disconnect((const QObject *)cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0]));
+      }
+#endif
+
+    }
+  }
+  ///const QObject *sender, const char *signal, const QObject *receiver, const char *member
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_STRING && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_STRING) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46) && inherits(Z_OBJCE_P(arg_2), 46)) {
+        /// try const QObject *sender, const char *signal, const QObject *receiver, const char *member,
+        QObject *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+        QObject *
+          cpp_arg_2 = static_cast < QObject * >(php_qt_fetch(arg_2));
+
+        if (getThis() == NULL) {
+          RETURN_BOOL(QObject::
+                      disconnect((const QObject *)cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0], (const QObject *)cpp_arg_2,
+                                 (const char *)&Z_STRVAL_P(arg_3)[0]));
+        } else {
+          RETURN_BOOL(selfpointer->
+                      disconnect((const QObject *)cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0], (const QObject *)cpp_arg_2,
+                                 (const char *)&Z_STRVAL_P(arg_3)[0]));
+      }}
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::disconnect(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method deleteLater
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QObject, staticMetaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QMetaObject* return_object = (QMetaObject*) obj->staticMetaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QObject, deleteLater)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'deleteLater' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->deleteLater());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::deleteLater(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  setUserData
- *    flags:    
+/*!
+ * method disconnectNotify
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *signals0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QObject, setUserData){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* lo */
-		long var_lo_0;    // default: 
-		zval* z_var_lo_1;   // default: 
+/*!
+ * method registerUserData
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uint
+ * @flags	s
+ */
 
-		/* uint id, QObjectUserData* data,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"lo", &var_lo_0, &z_var_lo_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_lo_1 = (QObject*) php_qt_fetch(z_var_lo_1);
+ZEND_METHOD(QObject, registerUserData)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QObject *
+        selfpointer;
 
-			QString tmp_lo_0(var_lo_1->metaObject()->className());
-			
-			if(tmp_lo_0 == "QObjectUserData*") {
-				obj->setUserData((uint) var_lo_0, (QObjectUserData*) var_lo_1);
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QObject::registerUserData());
+      } else {
+        RETURN_LONG(selfpointer->registerUserData());
+      }
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::registerUserData(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  userData
- *    flags:    c
+/*!
+ * method parent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject *
+ * @flags	c
  */
-ZEND_METHOD(QObject, userData){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* l */
-		long var_l_0;    // default: 
+ZEND_METHOD(QObject, parent)
+{
+  ///
+#ifdef PHP_QT_QObject           // return type
 
-		/* uint id,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"l", &var_l_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'parent' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
 
-			
-			QObjectUserData* return_object = (QObjectUserData*) obj->userData((uint) var_l_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast < QObject * >(selfpointer->parent());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QObject::parent(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method receivers
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char * signals0
+ * 
+ * @access	protected
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QObject, qObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* return_object = (QObject*) obj->qObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  setObjectName
- *    flags:    
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QObject, setObjectName){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+/*!
+ * method thread
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QThread *
+ * @flags	c
+ */
 
-		/* const QString& name,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"o", &z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+ZEND_METHOD(QObject, thread)
+{
+  ///
+#ifdef PHP_QT_QThread           // return type
 
-			QString tmp_o_0(var_o_0->metaObject()->className());
-			
-			if(tmp_o_0 == "const QString&") {
-				obj->setObjectName((const QString&) var_o_0);
-			RETURN_NULL();
-			}
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'thread' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast < QThread * >(selfpointer->thread());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QObject::thread(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  killTimer
- *    flags:    
+/*!
+ * method isWidgetType
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QObject, killTimer){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* l */
-		long var_l_0;    // default: 
+ZEND_METHOD(QObject, isWidgetType)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isWidgetType' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
 
-		/* int id,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"l", &var_l_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-
-			
-			obj->killTimer((int) var_l_0);
-			RETURN_NULL();
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isWidgetType());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::isWidgetType(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  setParent
- *    flags:    
+/*!
+ * method sender
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	QObject *
+ * @flags	c
  */
-ZEND_METHOD(QObject, setParent){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+/*!
+ * method signalsBlocked
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-		/* QObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"o", &z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+ZEND_METHOD(QObject, signalsBlocked)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'signalsBlocked' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
 
-			QString tmp_o_0(var_o_0->metaObject()->className());
-			
-			if(tmp_o_0 == "QObject*") {
-				obj->setParent((QObject*) var_o_0);
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->signalsBlocked());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::signalsBlocked(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  moveToThread
- *    flags:    
+/*!
+ * method setObjectName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &names0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, moveToThread){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+ZEND_METHOD(QObject, setObjectName)
+{
+  ///const QString &names0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-		/* QThread* thread,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"o", &z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setObjectName' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &names0,
+        QObject *
+          selfpointer;
 
-			QString tmp_o_0(var_o_0->metaObject()->className());
-			
-			if(tmp_o_0 == "QThread*") {
-				obj->moveToThread((QThread*) var_o_0);
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setObjectName((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::setObjectName(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  connect
- *    flags:    c
+/*!
+ * method connect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QObject *senders0
+ * @param	 const char *signals1
+ * @param	 const char *members2
+ * @param	 Qt::ConnectionType type = Qt::AutoConnection s3
+ * 
+ * overloaded args:
+ * @param	const QObject *sender
+ * @param	 const char *signal
+ * @param	 const QObject *receiver
+ * @param	 const char *member
+ * @param	 Qt::ConnectionType = Qt::AutoConnection 
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QObject, connect){
 
-	if (ZEND_NUM_ARGS() == 4){
-		/* ossl */
-		zval* z_var_ossl_0;   // default: 
-		char* var_ossl_1;   // default: 
-		int len_ossl_1;
+ZEND_METHOD(QObject, connect)
+{
+  ///const QObject *senders0, const char *signals1, const char *members2, Qt::ConnectionType type = Qt::AutoConnection s3
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_STRING && Z_TYPE_P(arg_2) == IS_STRING) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'connect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QObject *senders0, const char *signals1, const char *members2,
+        QObject *
+          selfpointer;
 
-		char* var_ossl_2;   // default: 
-		int len_ossl_2;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
 
-		long var_ossl_3;    // default: Qt::AutoConnection
+        RETURN_BOOL(selfpointer->connect((const QObject *)cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0], (const char *)&Z_STRVAL_P(arg_2)[0]));
+      }
+#endif
 
-		/* const QObject* sender, const char* signal, const char* member, int type,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"ossl|", &z_var_ossl_0, &var_ossl_1, len_ossl_1, &var_ossl_2, len_ossl_2, &var_ossl_3) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_ossl_0 = (QObject*) php_qt_fetch(z_var_ossl_0);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_STRING && Z_TYPE_P(arg_2) == IS_STRING && Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'connect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QObject *senders0, const char *signals1, const char *members2, Qt::ConnectionType type = Qt::AutoConnection s3,
+        QObject *
+          selfpointer;
 
-			QString tmp_ossl_0(var_ossl_0->metaObject()->className());
-			
-			if(tmp_ossl_0 == "const QObject*") {
-				RETURN_BOOL(obj->connect((const QObject*) var_ossl_0, (const char*) var_ossl_1, (const char*) var_ossl_2, (Qt::ConnectionType) var_ossl_3));
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 5){
-		/* ososl */
-		zval* z_var_ososl_0;   // default: 
-		char* var_ososl_1;   // default: 
-		int len_ososl_1;
+        RETURN_BOOL(selfpointer->
+                    connect((const QObject *)cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0], (const char *)&Z_STRVAL_P(arg_2)[0],
+                            (Qt::ConnectionType) Z_LVAL_P(arg_3)));
+      }
+#endif
 
-		zval* z_var_ososl_2;   // default: 
-		char* var_ososl_3;   // default: 
-		int len_ososl_3;
+    }
+  }
+  ///const QObject *sender, const char *signal, const QObject *receiver, const char *member, Qt::ConnectionType = Qt::AutoConnection 
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_STRING && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_STRING) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46) && inherits(Z_OBJCE_P(arg_2), 46)) {
+        /// try const QObject *sender, const char *signal, const QObject *receiver, const char *member,
+        QObject *
+          selfpointer;
 
-		long var_ososl_4;    // default: Qt::AutoConnection
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+        QObject *
+          cpp_arg_2 = static_cast < QObject * >(php_qt_fetch(arg_2));
 
-		/* const QObject* sender, const char* signal, const QObject* receiver, const char* member, int ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"ososl|", &z_var_ososl_0, &var_ososl_1, len_ososl_1, &z_var_ososl_2, &var_ososl_3, len_ososl_3, &var_ososl_4) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_ososl_0 = (QObject*) php_qt_fetch(z_var_ososl_0);
-			QObject* var_ososl_2 = (QObject*) php_qt_fetch(z_var_ososl_2);
+        if (getThis() == NULL) {
+          RETURN_BOOL(QObject::
+                      connect((const QObject *)cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0], (const QObject *)cpp_arg_2,
+                              (const char *)&Z_STRVAL_P(arg_3)[0]));
+        } else {
+          RETURN_BOOL(selfpointer->
+                      connect((const QObject *)cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0], (const QObject *)cpp_arg_2,
+                              (const char *)&Z_STRVAL_P(arg_3)[0]));
+      }}
+#endif
 
-			QString tmp_ososl_0(var_ososl_0->metaObject()->className());
-			QString tmp_ososl_1(var_ososl_2->metaObject()->className());
-			
-			if(tmp_ososl_0 == "const QObject*" && tmp_ososl_1 == "const QObject*") {
-				RETURN_BOOL(obj->connect((const QObject*) var_ososl_0, (const char*) var_ososl_1, (const QObject*) var_ososl_2, (const char*) var_ososl_3, (Qt::ConnectionType) var_ososl_4));
-			}
-		}
-	}
-}
+#endif
 
-/*********************************
- *    class     QObject */
-/*
- *    function  blockSignals
- *    flags:    
- */
-ZEND_METHOD(QObject, blockSignals){
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_STRING && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_STRING &&
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46) && inherits(Z_OBJCE_P(arg_2), 46)) {
+        /// try const QObject *sender, const char *signal, const QObject *receiver, const char *member, Qt::ConnectionType = Qt::AutoConnection ,
+        QObject *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* b */
-		bool var_b_0;   // _default: 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+        QObject *
+          cpp_arg_2 = static_cast < QObject * >(php_qt_fetch(arg_2));
 
-		/* bool b,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"b", &var_b_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+        if (getThis() == NULL) {
+          RETURN_BOOL(QObject::
+                      connect((const QObject *)cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0], (const QObject *)cpp_arg_2, (const char *)&Z_STRVAL_P(arg_3)[0],
+                              (Qt::ConnectionType) Z_LVAL_P(arg_4)));
+        } else {
+          RETURN_BOOL(selfpointer->
+                      connect((const QObject *)cpp_arg_0, (const char *)&Z_STRVAL_P(arg_1)[0], (const QObject *)cpp_arg_2, (const char *)&Z_STRVAL_P(arg_3)[0],
+                              (Qt::ConnectionType) Z_LVAL_P(arg_4)));
+      }}
+#endif
 
-			
-			RETURN_BOOL(obj->blockSignals((bool) var_b_0));
-		}
-	}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::connect(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  objectName
- *    flags:    c
+/*!
+ * method blockSignals
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bs0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QObject, objectName){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QString return_object = (QString) obj->objectName();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QObject, blockSignals)
+{
+  ///bool bs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'blockSignals' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bs0,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->blockSignals((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::blockSignals(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  QObject
- *    flags:    t
+/*!
+ * method objectName
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QObject, __construct){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 0
+ZEND_METHOD(QObject, objectName)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-		/* QObject* parent,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"o|", &z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'objectName' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
 
-			QString tmp_o_0(var_o_0->metaObject()->className());
-			
-			if(tmp_o_0 == "QObject*") {
-				QObject *QObject_ptr = new QObject((QObject*) var_o_0);
-			PHP_QT_REGISTER(QObject_ptr);
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* oo */
-		zval* z_var_oo_0;   // default: 
-		zval* z_var_oo_1;   // default: 0
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-		/* QObjectPrivate& dd, QObject* parent,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"oo|", &z_var_oo_0, &z_var_oo_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_oo_0 = (QObject*) php_qt_fetch(z_var_oo_0);
-			QObject* var_oo_1 = (QObject*) php_qt_fetch(z_var_oo_1);
+      *return_object = static_cast < QString > (selfpointer->objectName());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			QString tmp_oo_0(var_oo_0->metaObject()->className());
-			QString tmp_oo_1(var_oo_1->metaObject()->className());
-			
-			if(tmp_oo_0 == "QObjectPrivate&" && tmp_oo_1 == "QObject*") {
-				QObject *QObject_ptr = new QObject((QObjectPrivate&) var_oo_0, (QObject*) var_oo_1);
-			PHP_QT_REGISTER(QObject_ptr);
-			RETURN_NULL();
-			}
-		}
-	}
+  php_error(E_ERROR, "could not parse argument in QObject::objectName(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  dumpObjectTree
- *    flags:    
+/*!
+ * method customEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QObject, dumpObjectTree){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			obj->dumpObjectTree();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  startTimer
- *    flags:    
+/*!
+ * method QObject
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *parent=0s0
+ * 
+ * overloaded args:
+ * @param	QObjectPrivate &dd
+ * @param	 QObject *parent = 0
+ * 
+ * overloaded args:
+ * @param	const QObject &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QObject, startTimer){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* l */
-		long var_l_0;    // default: 
+ZEND_METHOD(QObject, __construct)
+{
+  ///QObject *parent=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QObject_php_qt *
+        selfpointer = new QObject_php_qt(getThis());
 
-		/* int interval,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"l", &var_l_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QObject *parent=0s0,
+      QObject *
+        cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+      QObject_php_qt *
+        selfpointer = new QObject_php_qt(getThis(), (QObject *) cpp_arg_0);
 
-			
-			RETURN_LONG(obj->startTimer((int) var_l_0));
-		}
-	}
-}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QObjectPrivate &dd, QObject *parent = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObjectPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QObjectPrivate &dd,
+        QObjectPrivate *
+          cpp_arg_0 = static_cast < QObjectPrivate * >(php_qt_fetch(arg_0));
+        QObject_php_qt *
+          selfpointer = new QObject_php_qt(getThis(), (QObjectPrivate &) * cpp_arg_0);
 
-/*********************************
- *    class     QObject */
-/*
- *    function  inherits
- *    flags:    c
- */
-ZEND_METHOD(QObject, inherits){
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QObjectPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QObjectPrivate &dd, QObject *parent = 0,
+        QObjectPrivate *
+          cpp_arg_0 = static_cast < QObjectPrivate * >(php_qt_fetch(arg_0));
+        QObject *
+          cpp_arg_1 = static_cast < QObject * >(php_qt_fetch(arg_1));
+        QObject_php_qt *
+          selfpointer = new QObject_php_qt(getThis(), (QObjectPrivate &) * cpp_arg_0, (QObject *) cpp_arg_1);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-		/* const char* classname,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s", &var_s_0, len_s_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+    }
+  }
+  ///const QObject &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+/// method is private, skip
+        php_error(E_ERROR, "QObject::__construct(...) cannot be called with 'const QObject &,'.");
+      }
+#endif
 
-			
-			RETURN_BOOL(obj->inherits( (const char*) var_s_0));
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::QObject(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  eventFilter
- *    flags:    v
+/*!
+ * method startTimer
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int intervals0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	
  */
-ZEND_METHOD(QObject, eventFilter){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* oo */
-		zval* z_var_oo_0;   // default: 
-		zval* z_var_oo_1;   // default: 
+ZEND_METHOD(QObject, startTimer)
+{
+  ///int intervals0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'startTimer' is not static");
+        RETURN_NULL();
+      }
+      /// try int intervals0,
+      QObject *
+        selfpointer;
 
-		/* QObject* , QEvent* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"oo", &z_var_oo_0, &z_var_oo_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_oo_0 = (QObject*) php_qt_fetch(z_var_oo_0);
-			QObject* var_oo_1 = (QObject*) php_qt_fetch(z_var_oo_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->startTimer((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::startTimer(...) ");
+}
 
-			QString tmp_oo_0(var_oo_0->metaObject()->className());
-			QString tmp_oo_1(var_oo_1->metaObject()->className());
-			
-			if(tmp_oo_0 == "QObject*" && tmp_oo_1 == "QEvent*") {
-				RETURN_BOOL(obj->eventFilter((QObject*) var_oo_0, (QEvent*) var_oo_1));
-			}
-		}
-	}
+/*!
+ * method inherits
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *classnames0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+ZEND_METHOD(QObject, inherits)
+{
+  ///const char *classnames0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'inherits' is not static");
+        RETURN_NULL();
+      }
+      /// try const char *classnames0,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->inherits((const char *)&Z_STRVAL_P(arg_0)[0]));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QObject::inherits(...) ");
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * overloaded args:
+ * @param	const char *
+ * @param	 const char *
+ * 
+ * overloaded args:
+ * @param	const char *sourceText
+ * @param	 const char * = 0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QObject, trUtf8){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* ss */
-		char* var_ss_0;   // default: 
-		int len_ss_0;
+ZEND_METHOD(QObject, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-		char* var_ss_1;   // default: 0
-		int len_ss_1;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QObject *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-		/* const char* , const char* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"ss|", &var_ss_0, len_ss_0, &var_ss_1, len_ss_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-									
-			QString return_object = (QString) obj->trUtf8( (const char*) var_ss_0 , (const char*) var_ss_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-		}
-	}
-}
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QObject::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QObject *
+        selfpointer;
 
-/*********************************
- *    class     QObject */
-/*
- *    function  qt_property
- *    flags:    v
- */
-ZEND_METHOD(QObject, qt_property){
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-	if (ZEND_NUM_ARGS() == 3){
-		/* llo */
-		long var_llo_0;    // default: 
-		long var_llo_1;    // default: 
-		zval* z_var_llo_2;   // default: 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-		/* int , int , QVariant* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"llo", &var_llo_0, &var_llo_1, &z_var_llo_2) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_llo_2 = (QObject*) php_qt_fetch(z_var_llo_2);
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QObject::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			QString tmp_llo_0(var_llo_2->metaObject()->className());
-			
-			if(tmp_llo_0 == "QVariant*") {
-				RETURN_BOOL(obj->qt_property((int) var_llo_0, (int) var_llo_1, (QVariant*) var_llo_2));
-			}
-		}
-	}
-}
 
+  ///const char *, const char *
+#ifdef PHP_QT_QString           // return type
 
-PHP_QT_DESTRUCT(QObject);
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try const char *, const char *,
+      QObject *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QObject::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const char *sourceText, const char * = 0
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *sourceText,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QObject::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try const char *sourceText, const char * = 0,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QObject * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QObject::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QObject::trUtf8(...) ");
+}

Modified: trunk/qt/classes/qobjectdata.cpp
===================================================================
--- trunk/qt/classes/qobjectdata.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qobjectdata.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,16 +19,15 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QObjectData.cpp - QObjectData PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QObjectData>
 #include "../php_qt.h"
 
 
-PHP_QT_DESTRUCT(QObjectData);
-
+#include <QObjectData>
+/// DEBUG:destructor skipped.

Modified: trunk/qt/classes/qobjectuserdata.cpp
===================================================================
--- trunk/qt/classes/qobjectuserdata.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qobjectuserdata.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,16 +19,15 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QObjectUserData.cpp - QObjectUserData PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QObjectUserData>
 #include "../php_qt.h"
 
 
-PHP_QT_DESTRUCT(QObjectUserData);
-
+#include <QObjectUserData>
+/// DEBUG:destructor skipped.

Modified: trunk/qt/classes/qpaintdevice.cpp
===================================================================
--- trunk/qt/classes/qpaintdevice.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qpaintdevice.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QPaintDevice.cpp - QPaintDevice PHP implementation.
- * begin           : Tue Apr 11 10:33:13 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -31,262 +30,316 @@
 
 
 #include <QPaintDevice>
-
-
-/*		public enumPaintDeviceMetric:long {
-			PdmWidth = 1,
-			PaintDeviceMetric = 1,
-			PaintDeviceMetric = 2,
-			PaintDeviceMetric = 3,
-			PaintDeviceMetric = 4,
-			PaintDeviceMetric = 5,
-			PaintDeviceMetric = 6,
-			PaintDeviceMetric = 7,
-			PaintDeviceMetric = 8,
-			PaintDeviceMetric = 9
-		}
-*/
+/// DEBUG:destructor skipped.
 /*!
- *    @class     QPaintDevice
- *    @function  width
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method logicalDpiY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, width)
+
+ZEND_METHOD(QPaintDevice, logicalDpiY)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->width());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QPaintDevice::logicalDpiY(...) cannot be called with ''.");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QPaintDevice::logicalDpiY(...) ");
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  physicalDpiX
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method heightMM
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, physicalDpiX)
+
+ZEND_METHOD(QPaintDevice, heightMM)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->physicalDpiX());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QPaintDevice::heightMM(...) cannot be called with ''.");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QPaintDevice::heightMM(...) ");
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  logicalDpiY
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method numColors
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, logicalDpiY)
+
+ZEND_METHOD(QPaintDevice, numColors)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->logicalDpiY());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QPaintDevice::numColors(...) cannot be called with ''.");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QPaintDevice::numColors(...) ");
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  heightMM
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method logicalDpiX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, heightMM)
+
+ZEND_METHOD(QPaintDevice, logicalDpiX)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->heightMM());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QPaintDevice::logicalDpiX(...) cannot be called with ''.");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QPaintDevice::logicalDpiX(...) ");
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  paintingActive
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method width
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, paintingActive)
+
+ZEND_METHOD(QPaintDevice, width)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->paintingActive());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QPaintDevice::width(...) cannot be called with ''.");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QPaintDevice::width(...) ");
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  numColors
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method height
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, numColors)
+
+ZEND_METHOD(QPaintDevice, height)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->numColors());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QPaintDevice::height(...) cannot be called with ''.");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QPaintDevice::height(...) ");
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  logicalDpiX
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method QPaintDevice
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPaintDevice &
+ * 
+ * @access	protected
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QPaintDevice, logicalDpiX)
+
+/*!
+ * method devType
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cv
+ */
+
+/*!
+ * method widthMM
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QPaintDevice, widthMM)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->logicalDpiX());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QPaintDevice::widthMM(...) cannot be called with ''.");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QPaintDevice::widthMM(...) ");
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  depth
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method depth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QPaintDevice, depth)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->depth());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QPaintDevice::depth(...) cannot be called with ''.");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QPaintDevice::depth(...) ");
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  height
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method physicalDpiY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, height)
+
+ZEND_METHOD(QPaintDevice, physicalDpiY)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->height());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QPaintDevice::physicalDpiY(...) cannot be called with ''.");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QPaintDevice::physicalDpiY(...) ");
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  physicalDpiY
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method physicalDpiX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, physicalDpiY)
+
+ZEND_METHOD(QPaintDevice, physicalDpiX)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->physicalDpiY());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QPaintDevice::physicalDpiX(...) cannot be called with ''.");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QPaintDevice::physicalDpiX(...) ");
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  widthMM
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method paintEngine
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPaintEngine *
+ * @flags	cpv
  */
-ZEND_METHOD(QPaintDevice, widthMM)
+
+/*!
+ * method metric
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	PaintDeviceMetric metrics0
+ * 
+ * @access	protected
+ * @return	int
+ * @flags	cv
+ */
+
+/*!
+ * method paintingActive
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+ZEND_METHOD(QPaintDevice, paintingActive)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->widthMM());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QPaintDevice::paintingActive(...) cannot be called with ''.");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QPaintDevice::paintingActive(...) ");
 }
-
-
-PHP_QT_DESTRUCT(QPaintDevice);

Modified: trunk/qt/classes/qpainter.cpp
===================================================================
--- trunk/qt/classes/qpainter.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qpainter.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,2888 +19,7259 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QPainter.cpp - QPainter PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QPainter>
 #include "../php_qt.h"
 
+
+#include <QPainter>
 #include <QPainterPath>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QPainter_php_qt:public QPainter
+{
 
+public:
+  QPainter_php_qt(zval * zend_ptr);
+  QPainter_php_qt(zval * zend_ptr, QPaintDevice * s0);
 
-/*		public enumRenderHint:long {
-			Antialiasing = 0x01,
-			TextAntialiasing = 0x02,
-			SmoothPixmapTransform = 0x04,
-		}
-*/
 
-/*		public enumCompositionMode:long {
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-		}
-*/
-/*********************************
- *    class     QPainter */
-/*
- *    function  eraseRect
- *    flags:    
+  zval *zend_ptr;
+};
+
+QPainter_php_qt::QPainter_php_qt(zval * zend_ptr):QPainter()
+{
+  this->zend_ptr = zend_ptr;
+}
+
+QPainter_php_qt::QPainter_php_qt(zval * zend_ptr, QPaintDevice * s0):QPainter(s0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method eraseRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &s0
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * 
+ * overloaded args:
+ * @param	const QRect &
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, eraseRect){
-		/* o public*/
 
-		/* const QRectF& ,  */
+ZEND_METHOD(QPainter, eraseRect)
+{
+  ///const QRectF &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'eraseRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &s0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->eraseRect((const QRectF &)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF") {
-				obj->eraseRect((const QRectF&) obj_z_0);
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QRect") {
-				obj->eraseRect((const QRect&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llll public*/
+    }
+  }
+  ///int x, int y, int w, int h
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'eraseRect' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h,
+      QPainter *
+        selfpointer;
 
-		/* int x, int y, int w, int h,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->eraseRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  ///const QRect &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'eraseRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->eraseRect((const QRect &)*cpp_arg_0));
+      }
+#endif
 
-			obj->eraseRect((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::eraseRect(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setClipPath
- *    flags:    
+/*!
+ * method setClipPath
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPainterPath &paths0
+ * @param	 Qt::ClipOperation op = Qt::ReplaceClips1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setClipPath){
-		/* ll public*/
 
-		/* const QPainterPath& path, int op,  */
+ZEND_METHOD(QPainter, setClipPath)
+{
+  ///const QPainterPath &paths0, Qt::ClipOperation op = Qt::ReplaceClips1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPainterPath
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setClipPath' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPainterPath &paths0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPainterPath *
+          cpp_arg_0 = static_cast < QPainterPath * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setClipPath((const QPainterPath &)*cpp_arg_0));
+      }
+#endif
 
-			obj->setClipPath((const QPainterPath&) Z_LVAL_P(z_0) ,(Qt::ClipOperation) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPainterPath
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setClipPath' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPainterPath &paths0, Qt::ClipOperation op = Qt::ReplaceClips1,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPainterPath *
+          cpp_arg_0 = static_cast < QPainterPath * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setClipPath((const QPainterPath &)*cpp_arg_0, (Qt::ClipOperation) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setClipPath(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  matrixEnabled
- *    flags:    c
+/*!
+ * method matrixEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QPainter, matrixEnabled){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->matrixEnabled());
-	}
+
+ZEND_METHOD(QPainter, matrixEnabled)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'matrixEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->matrixEnabled());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::matrixEnabled(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  shear
- *    flags:    
+/*!
+ * method shear
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	qreal shs0
+ * @param	 qreal svs1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, shear){
-		/* ll public*/
 
-		/* double sh, double sv,  */
+ZEND_METHOD(QPainter, shear)
+{
+// notice: unknown argument qreal shs0, skipped
+  php_error(E_ERROR, "could not parse argument in QPainter::shear(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+/*!
+ * method save
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QPainter, save)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'save' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
-			obj->shear((qreal) Z_LVAL_P(z_0) ,(qreal) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->save());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::save(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  save
- *    flags:    
+/*!
+ * method resetMatrix
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, save){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			obj->save();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  resetMatrix
- *    flags:    
- */
-ZEND_METHOD(QPainter, resetMatrix){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			obj->resetMatrix();
-			RETURN_NULL();
-	}
+ZEND_METHOD(QPainter, resetMatrix)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'resetMatrix' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->resetMatrix());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::resetMatrix(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  initFrom
- *    flags:    
+/*!
+ * method initFrom
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QWidget *widgets0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, initFrom){
-		/* o public*/
 
-		/* const QWidget* widget,  */
+ZEND_METHOD(QPainter, initFrom)
+{
+  ///const QWidget *widgets0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'initFrom' is not static");
+          RETURN_NULL();
+        }
+        /// try const QWidget *widgets0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->initFrom((const QWidget *)cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0->inherits("QWidget")) {
-				obj->initFrom((const QWidget*) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::initFrom(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  fontInfo
- *    flags:    c
+/*!
+ * method fontInfo
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QFontInfo
+ * @flags	c
  */
-ZEND_METHOD(QPainter, fontInfo){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QFontInfo return_object = (QFontInfo) obj->fontInfo();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setLayoutDirection
- *    flags:    
- */
-ZEND_METHOD(QPainter, setLayoutDirection){
-		/* l public*/
+ZEND_METHOD(QPainter, fontInfo)
+{
+  ///
+#ifdef PHP_QT_QFontInfo         // return type
 
-		/* int direction,  */
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'fontInfo' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QFontInfo *
+        return_object = new QFontInfo;
 
-			obj->setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      *return_object = static_cast < QFontInfo > (selfpointer->fontInfo());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::fontInfo(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setBrushOrigin
- *    flags:    
+/*!
+ * method setLayoutDirection
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::LayoutDirection directions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setBrushOrigin){
-		/* l public*/
 
-		/* const QPoint& ,  */
+ZEND_METHOD(QPainter, setLayoutDirection)
+{
+  ///Qt::LayoutDirection directions0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setLayoutDirection' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::LayoutDirection directions0,
+      QPainter *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setLayoutDirection(...) ");
+}
 
+/*!
+ * method setBrushOrigin
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int xs0
+ * @param	 int ys1
+ * 
+ * overloaded args:
+ * @param	const QPoint &
+ * 
+ * overloaded args:
+ * @param	const QPointF &
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj->setBrushOrigin((const QPoint&) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-		/* ll public*/
+ZEND_METHOD(QPainter, setBrushOrigin)
+{
+  ///int xs0, int ys1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setBrushOrigin' is not static");
+        RETURN_NULL();
+      }
+      /// try int xs0, int ys1,
+      QPainter *
+        selfpointer;
 
-		/* int x, int y,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setBrushOrigin((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  ///const QPoint &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setBrushOrigin' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setBrushOrigin((const QPoint &)*cpp_arg_0));
+      }
+#endif
 
-			obj->setBrushOrigin((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+    }
+  }
+  ///const QPointF &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setBrushOrigin' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF &,
+        QPainter *
+          selfpointer;
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  pen
- *    flags:    c
- */
-ZEND_METHOD(QPainter, pen){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				const QPen & return_object = (const QPen &) obj->pen();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setBrushOrigin((const QPointF &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setBrushOrigin(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawRects
- *    flags:    
+/*!
+ * method pen
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPen &
+ * @flags	c
  */
-ZEND_METHOD(QPainter, drawRects){
-		/* ol public*/
 
-		/* const QRectF* rects, int rectCount,  */
+ZEND_METHOD(QPainter, pen)
+{
+  ///
+#ifdef PHP_QT_QPen              // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pen' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF") {
-				obj->drawRects((const QRectF*) obj_z_0, (int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &const_cast < QPen & >(selfpointer->pen());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::pen(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPath
- *    flags:    
+/*!
+ * method drawRects
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF *rectss0
+ * @param	 int rectCounts1
+ * 
+ * overloaded args:
+ * @param	const QVector<QRectF> &rectangles
+ * 
+ * overloaded args:
+ * @param	const QRect *rects
+ * @param	 int rectCount
+ * 
+ * overloaded args:
+ * @param	const QVector<QRect> &rectangles
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPath){
-		/* l public*/
 
-		/* const QPainterPath& path,  */
+ZEND_METHOD(QPainter, drawRects)
+{
+  ///const QRectF *rectss0, int rectCounts1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawRects' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF *rectss0, int rectCounts1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawRects((const QRectF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			obj->drawPath((const QPainterPath&) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+    }
+  }
+  ///const QVector<QRectF> &rectangles
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVector
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawRects' is not static");
+          RETURN_NULL();
+        }
+        /// try const QVector<QRectF> &rectangles,
+        QPainter *
+          selfpointer;
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  fillPath
- *    flags:    
- */
-ZEND_METHOD(QPainter, fillPath){
-		/* lo public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QVector < QRectF > *cpp_arg_0 = static_cast < QVector < QRectF > *>(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer->drawRects((const QVector < QRectF > &)*cpp_arg_0));
+      }
+#endif
 
-		/* const QPainterPath& path, const QBrush& brush,  */
+    }
+  }
+  ///const QRect *rects, int rectCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawRects' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect *rects, int rectCount,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawRects((const QRect *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			if(obj_z_1->inherits("QBrush")) {
-				obj->fillPath((const QPainterPath&) Z_LVAL_P(z_0), (const QBrush&) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  ///const QVector<QRect> &rectangles
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVector
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawRects' is not static");
+          RETURN_NULL();
+        }
+        /// try const QVector<QRect> &rectangles,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QVector < QRect > *cpp_arg_0 = static_cast < QVector < QRect > *>(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer->drawRects((const QVector < QRect > &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawRects(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  rotate
- *    flags:    
+/*!
+ * method drawPath
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPainterPath &paths0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, rotate){
-		/* l public*/
 
-		/* double a,  */
+ZEND_METHOD(QPainter, drawPath)
+{
+  ///const QPainterPath &paths0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPainterPath
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPath' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPainterPath &paths0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPainterPath *
+          cpp_arg_0 = static_cast < QPainterPath * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawPath((const QPainterPath &)*cpp_arg_0));
+      }
+#endif
 
-			obj->rotate((qreal) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawPath(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPie
- *    flags:    
+/*!
+ * method fillPath
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPainterPath &paths0
+ * @param	 const QBrush &brushs1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPie){
-		/* oll public*/
 
-		/* const QRectF& rect, int a, int alen,  */
+ZEND_METHOD(QPainter, fillPath)
+{
+  ///const QPainterPath &paths0, const QBrush &brushs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPainterPath
+#ifdef PHP_QT_QBrush
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'fillPath' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPainterPath &paths0, const QBrush &brushs1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPainterPath *
+          cpp_arg_0 = static_cast < QPainterPath * >(php_qt_fetch(arg_0));
+        QBrush *
+          cpp_arg_1 = static_cast < QBrush * >(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer->fillPath((const QPainterPath &)*cpp_arg_0, (const QBrush &)*cpp_arg_1));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF") {
-				obj->drawPie((const QRectF&) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QRect") {
-				obj->drawPie((const QRect&) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllll public*/
+#endif
 
-		/* int x, int y, int w, int h, int a, int alen,  */
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::fillPath(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 6){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzzz", &z_0, &z_1, &z_2, &z_3, &z_4, &z_5) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG && Z_TYPE_P(z_5) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+/*!
+ * method rotate
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	qreal as0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-
-			obj->drawPie((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3) ,(int) Z_LVAL_P(z_4) ,(int) Z_LVAL_P(z_5));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QPainter, rotate)
+{
+// notice: unknown argument qreal as0, skipped
+  php_error(E_ERROR, "could not parse argument in QPainter::rotate(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  translate
- *    flags:    
+/*!
+ * method drawPie
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &rects0
+ * @param	 int as1
+ * @param	 int alens2
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 int a
+ * @param	 int alen
+ * 
+ * overloaded args:
+ * @param	const QRect &
+ * @param	 int a
+ * @param	 int alen
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, translate){
-		/* l public*/
 
-		/* const QPointF& offset,  */
+ZEND_METHOD(QPainter, drawPie)
+{
+  ///const QRectF &rects0, int as1, int alens2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPie' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rects0, int as1, int alens2,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawPie((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-			obj->translate((const QPointF&) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-		/* ll public*/
+    }
+  }
+  ///int x, int y, int w, int h, int a, int alen
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
+        && Z_TYPE_P(arg_5) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'drawPie' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h, int a, int alen,
+      QPainter *
+        selfpointer;
 
-		/* double dx, double dy,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->
+                  drawPie((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4), (int)Z_LVAL_P(arg_5)));
+    }
+  }
+  ///const QRect &, int a, int alen
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPie' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &, int a, int alen,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawPie((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-			obj->translate((qreal) Z_LVAL_P(z_0) ,(qreal) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawPie(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setCompositionMode
- *    flags:    
+/*!
+ * method translate
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF &offsets0
+ * 
+ * overloaded args:
+ * @param	const QPoint &offset
+ * 
+ * overloaded args:
+ * @param	qreal dx
+ * @param	 qreal dy
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setCompositionMode){
-		/* l public*/
 
-		/* QPainter::CompositionMode mode,  */
+ZEND_METHOD(QPainter, translate)
+{
+  ///const QPointF &offsets0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'translate' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF &offsets0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->translate((const QPointF &)*cpp_arg_0));
+      }
+#endif
 
-			obj->setCompositionMode((QPainter::CompositionMode) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  ///const QPoint &offset
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'translate' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &offset,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->translate((const QPoint &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument qreal dx, skipped
+  php_error(E_ERROR, "could not parse argument in QPainter::translate(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setWindow
- *    flags:    
+/*!
+ * method setCompositionMode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	CompositionMode modes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setWindow){
-		/* o public*/
 
-		/* const QRect& window,  */
+ZEND_METHOD(QPainter, setCompositionMode)
+{
+// notice: unknown argument CompositionMode modes0, skipped
+  php_error(E_ERROR, "could not parse argument in QPainter::setCompositionMode(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method setWindow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &windows0
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QPainter, setWindow)
+{
+  ///const QRect &windows0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setWindow' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &windows0,
+        QPainter *
+          selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QRect") {
-				obj->setWindow((const QRect&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llll public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
-		/* int x, int y, int w, int h,  */
+        RETURN_VOID(selfpointer->setWindow((const QRect &)*cpp_arg_0));
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+    }
+  }
+  ///int x, int y, int w, int h
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setWindow' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h,
+      QPainter *
+        selfpointer;
 
-
-			obj->setWindow((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setWindow((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setWindow(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  fontMetrics
- *    flags:    c
+/*!
+ * method fontMetrics
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QFontMetrics
+ * @flags	c
  */
-ZEND_METHOD(QPainter, fontMetrics){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QFontMetrics return_object = (QFontMetrics) obj->fontMetrics();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, fontMetrics)
+{
+  ///
+#ifdef PHP_QT_QFontMetrics      // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'fontMetrics' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QFontMetrics *
+        return_object = new QFontMetrics;
+
+      *return_object = static_cast < QFontMetrics > (selfpointer->fontMetrics());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::fontMetrics(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPixmap
- *    flags:    
+/*!
+ * method drawPixmap
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &targetRects0
+ * @param	 const QPixmap &pixmaps1
+ * @param	 const QRectF &sourceRects2
+ * 
+ * overloaded args:
+ * @param	const QRect &targetRect
+ * @param	 const QPixmap &pixmap
+ * @param	 const QRect &sourceRect
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 const QPixmap &pm
+ * @param	 int sx
+ * @param	 int sy
+ * @param	 int sw
+ * @param	 int sh
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 const QPixmap &pm
+ * @param	 int sx
+ * @param	 int sy
+ * @param	 int sw
+ * @param	 int sh
+ * 
+ * overloaded args:
+ * @param	const QPointF &p
+ * @param	 const QPixmap &pm
+ * @param	 const QRectF &sr
+ * 
+ * overloaded args:
+ * @param	const QPoint &p
+ * @param	 const QPixmap &pm
+ * @param	 const QRect &sr
+ * 
+ * overloaded args:
+ * @param	const QPointF &p
+ * @param	 const QPixmap &pm
+ * 
+ * overloaded args:
+ * @param	const QPoint &p
+ * @param	 const QPixmap &pm
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 const QPixmap &pm
+ * 
+ * overloaded args:
+ * @param	const QRect &r
+ * @param	 const QPixmap &pm
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 const QPixmap &pm
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPixmap){
-		/* oo public*/
 
-		/* const QRect& r, const QPixmap& pm,  */
-		/* lo public*/
+ZEND_METHOD(QPainter, drawPixmap)
+{
+  ///const QRectF &targetRects0, const QPixmap &pixmaps1, const QRectF &sourceRects2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QPixmap
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &targetRects0, const QPixmap &pixmaps1, const QRectF &sourceRects2,
+        QPainter *
+          selfpointer;
 
-		/* const QPointF& p, const QPixmap& pm,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
+        QRectF *
+          cpp_arg_2 = static_cast < QRectF * >(php_qt_fetch(arg_2));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        RETURN_VOID(selfpointer->drawPixmap((const QRectF &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1, (const QRectF &)*cpp_arg_2));
+      }
+#endif
 
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRect" && obj_z_1->inherits("QPixmap")) {
-				obj->drawPixmap((const QRect&) obj_z_0, (const QPixmap&) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+#endif
 
+    }
+  }
+  ///const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QPixmap
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect,
+        QPainter *
+          selfpointer;
 
-			if(obj_z_1->inherits("QPixmap")) {
-				obj->drawPixmap((const QPointF&) Z_LVAL_P(z_0), (const QPixmap&) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* loo public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
+        QRect *
+          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));
 
-		/* const QPointF& p, const QPixmap& pm, const QRectF& sr,  */
-		/* ooo public*/
+        RETURN_VOID(selfpointer->drawPixmap((const QRect &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1, (const QRect &)*cpp_arg_2));
+      }
+#endif
 
-		/* const QRectF& targetRect, const QPixmap& pixmap, const QRectF& sourceRect,  */
-		/* llo public*/
+#endif
 
-		/* int x, int y, const QPixmap& pm,  */
+#endif
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+    }
+  }
+  ///int x, int y, int w, int h, const QPixmap &pm, int sx, int sy, int sw, int sh
+  if (ZEND_NUM_ARGS() == 9) {
+    PHP_QT_FETCH_9_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_OBJECT && Z_TYPE_P(arg_5) == IS_LONG && Z_TYPE_P(arg_6) == IS_LONG && Z_TYPE_P(arg_7) == IS_LONG && Z_TYPE_P(arg_8) == IS_LONG) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_4), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, const QPixmap &pm, int sx, int sy, int sw, int sh,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_4 = static_cast < QPixmap * >(php_qt_fetch(arg_4));
 
-			if(obj_z_1->inherits("QPixmap") && Z_OBJCE_P(z_2)->name == "QRectF") {
-				obj->drawPixmap((const QPointF&) Z_LVAL_P(z_0), (const QPixmap&) obj_z_1, (const QRectF&) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        RETURN_VOID(selfpointer->
+                    drawPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &)*cpp_arg_4,
+                               (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6), (int)Z_LVAL_P(arg_7), (int)Z_LVAL_P(arg_8)));
+      }
+#endif
 
+    }
+  }
+  ///int x, int y, const QPixmap &pm, int sx, int sy, int sw, int sh
+  if (ZEND_NUM_ARGS() == 7) {
+    PHP_QT_FETCH_7_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG && Z_TYPE_P(arg_5) == IS_LONG && Z_TYPE_P(arg_6) == IS_LONG) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QPixmap &pm, int sx, int sy, int sw, int sh,
+        QPainter *
+          selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF" && obj_z_1->inherits("QPixmap") && Z_OBJCE_P(z_2)->name == "QRectF") {
-				obj->drawPixmap((const QRectF&) obj_z_0, (const QPixmap&) obj_z_1, (const QRectF&) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_2 = static_cast < QPixmap * >(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer->
+                    drawPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QPixmap &)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                               (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6)));
+      }
+#endif
 
-			if(obj_z_2->inherits("QPixmap")) {
-				obj->drawPixmap((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QPixmap&) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllo public*/
+    }
+  }
+  ///const QPointF &p, const QPixmap &pm, const QRectF &sr
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QPixmap
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF &p, const QPixmap &pm, const QRectF &sr,
+        QPainter *
+          selfpointer;
 
-		/* int x, int y, int w, int h, const QPixmap& pm,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
+        QRectF *
+          cpp_arg_2 = static_cast < QRectF * >(php_qt_fetch(arg_2));
 
-	if (ZEND_NUM_ARGS() == 5){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzz", &z_0, &z_1, &z_2, &z_3, &z_4) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_4 = (QObject*) php_qt_fetch(z_4);
+        RETURN_VOID(selfpointer->drawPixmap((const QPointF &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1, (const QRectF &)*cpp_arg_2));
+      }
+#endif
 
+#endif
 
-			if(obj_z_4->inherits("QPixmap")) {
-				obj->drawPixmap((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (const QPixmap&) obj_z_4);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llollll public*/
+#endif
 
-		/* int x, int y, const QPixmap& pm, int sx, int sy, int sw, int sh,  */
+    }
+  }
+  ///const QPoint &p, const QPixmap &pm, const QRect &sr
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPixmap
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &p, const QPixmap &pm, const QRect &sr,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 7){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		zval *z_6; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzzzz", &z_0, &z_1, &z_2, &z_3, &z_4, &z_5, &z_6) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG && Z_TYPE_P(z_5) == IS_LONG && Z_TYPE_P(z_6) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
+        QRect *
+          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer->drawPixmap((const QPoint &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1, (const QRect &)*cpp_arg_2));
+      }
+#endif
 
-			if(obj_z_2->inherits("QPixmap")) {
-				obj->drawPixmap((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QPixmap&) obj_z_2, (int) Z_LVAL_P(z_3), (int) Z_LVAL_P(z_4), (int) Z_LVAL_P(z_5), (int) Z_LVAL_P(z_6));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllollll public*/
+#endif
 
-		/* int x, int y, int w, int h, const QPixmap& pm, int sx, int sy, int sw, int sh,  */
+#endif
 
-	if (ZEND_NUM_ARGS() == 9){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		zval *z_6; // define ZVAL
-		zval *z_7; // define ZVAL
-		zval *z_8; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzzzzzz", &z_0, &z_1, &z_2, &z_3, &z_4, &z_5, &z_6, &z_7, &z_8) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_OBJECT && Z_TYPE_P(z_5) == IS_LONG && Z_TYPE_P(z_6) == IS_LONG && Z_TYPE_P(z_7) == IS_LONG && Z_TYPE_P(z_8) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_4 = (QObject*) php_qt_fetch(z_4);
+    }
+  }
+  ///const QPointF &p, const QPixmap &pm
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF &p, const QPixmap &pm,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
 
-			if(obj_z_4->inherits("QPixmap")) {
-				obj->drawPixmap((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (const QPixmap&) obj_z_4, (int) Z_LVAL_P(z_5), (int) Z_LVAL_P(z_6), (int) Z_LVAL_P(z_7), (int) Z_LVAL_P(z_8));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_VOID(selfpointer->drawPixmap((const QPointF &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QPoint &p, const QPixmap &pm
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &p, const QPixmap &pm,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->drawPixmap((const QPoint &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///int x, int y, const QPixmap &pm
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QPixmap &pm,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_2 = static_cast < QPixmap * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->drawPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QPixmap &)*cpp_arg_2));
+      }
+#endif
+
+    }
+  }
+  ///const QRect &r, const QPixmap &pm
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &r, const QPixmap &pm,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->drawPixmap((const QRect &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///int x, int y, int w, int h, const QPixmap &pm
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_OBJECT) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_4), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, const QPixmap &pm,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_4 = static_cast < QPixmap * >(php_qt_fetch(arg_4));
+
+        RETURN_VOID(selfpointer->
+                    drawPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &)*cpp_arg_4));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawPixmap(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPolyline
- *    flags:    
+/*!
+ * method drawPolyline
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF *pointss0
+ * @param	 int pointCounts1
+ * 
+ * overloaded args:
+ * @param	const QPolygonF &polyline
+ * 
+ * overloaded args:
+ * @param	const QPoint *points
+ * @param	 int pointCount
+ * 
+ * overloaded args:
+ * @param	const QPolygon &polygon
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPolyline){
-		/* o public*/
 
-		/* const QPolygonF& polyline,  */
+ZEND_METHOD(QPainter, drawPolyline)
+{
+  ///const QPointF *pointss0, int pointCounts1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPolyline' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF *pointss0, int pointCounts1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawPolyline((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QPolygonF") {
-				obj->drawPolyline((const QPolygonF&) obj_z_0);
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QPolygon") {
-				obj->drawPolyline((const QPolygon&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ll public*/
+    }
+  }
+  ///const QPolygonF &polyline
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygonF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPolyline' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPolygonF &polyline,
+        QPainter *
+          selfpointer;
 
-		/* const QPointF* points, int pointCount,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPolygonF *
+          cpp_arg_0 = static_cast < QPolygonF * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer->drawPolyline((const QPolygonF &)*cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///const QPoint *points, int pointCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPolyline' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint *points, int pointCount,
+        QPainter *
+          selfpointer;
 
-			obj->drawPolyline((const QPointF*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawPolyline((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QPolygon &polygon
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPolyline' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPolygon &polygon,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPolygon *
+          cpp_arg_0 = static_cast < QPolygon * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawPolyline((const QPolygon &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawPolyline(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  deviceMatrix
- *    flags:    c
+/*!
+ * method deviceMatrix
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QMatrix &
+ * @flags	c
  */
-ZEND_METHOD(QPainter, deviceMatrix){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				const QMatrix & return_object = (const QMatrix &) obj->deviceMatrix();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, deviceMatrix)
+{
+  ///
+#ifdef PHP_QT_QMatrix           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'deviceMatrix' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &const_cast < QMatrix & >(selfpointer->deviceMatrix());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::deviceMatrix(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawLine
- *    flags:    
+/*!
+ * method drawLine
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QLineF &lines0
+ * 
+ * overloaded args:
+ * @param	const QLine &line
+ * 
+ * overloaded args:
+ * @param	int x1
+ * @param	 int y1
+ * @param	 int x2
+ * @param	 int y2
+ * 
+ * overloaded args:
+ * @param	const QPoint &p1
+ * @param	 const QPoint &p2
+ * 
+ * overloaded args:
+ * @param	const QPointF &p1
+ * @param	 const QPointF &p2
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawLine){
-		/* o public*/
 
-		/* const QLineF& line,  */
+ZEND_METHOD(QPainter, drawLine)
+{
+  ///const QLineF &lines0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLineF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawLine' is not static");
+          RETURN_NULL();
+        }
+        /// try const QLineF &lines0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QLineF *
+          cpp_arg_0 = static_cast < QLineF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawLine((const QLineF &)*cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0->inherits("QLineF")) {
-				obj->drawLine((const QLineF&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ll public*/
+    }
+  }
+  ///const QLine &line
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLine
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawLine' is not static");
+          RETURN_NULL();
+        }
+        /// try const QLine &line,
+        QPainter *
+          selfpointer;
 
-		/* const QPoint& p1, const QPoint& p2,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QLine *
+          cpp_arg_0 = static_cast < QLine * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer->drawLine((const QLine &)*cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///int x1, int y1, int x2, int y2
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'drawLine' is not static");
+        RETURN_NULL();
+      }
+      /// try int x1, int y1, int x2, int y2,
+      QPainter *
+        selfpointer;
 
-			obj->drawLine((const QPoint&) Z_LVAL_P(z_0) ,(const QPoint&) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
-		/* llll public*/
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->drawLine((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  ///const QPoint &p1, const QPoint &p2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawLine' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &p1, const QPoint &p2,
+        QPainter *
+          selfpointer;
 
-		/* int x1, int y1, int x2, int y2,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QPoint *
+          cpp_arg_1 = static_cast < QPoint * >(php_qt_fetch(arg_1));
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer->drawLine((const QPoint &)*cpp_arg_0, (const QPoint &)*cpp_arg_1));
+      }
+#endif
 
+#endif
 
-			obj->drawLine((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  ///const QPointF &p1, const QPointF &p2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawLine' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF &p1, const QPointF &p2,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
+        QPointF *
+          cpp_arg_1 = static_cast < QPointF * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->drawLine((const QPointF &)*cpp_arg_0, (const QPointF &)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawLine(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  fillRect
- *    flags:    
+/*!
+ * method fillRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &s0
+ * @param	 const QBrush &s1
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 const QBrush &
+ * 
+ * overloaded args:
+ * @param	const QRect &
+ * @param	 const QBrush &
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, fillRect){
-		/* oo public*/
 
-		/* const QRectF& , const QBrush& ,  */
+ZEND_METHOD(QPainter, fillRect)
+{
+  ///const QRectF &s0, const QBrush &s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QBrush
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'fillRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &s0, const QBrush &s1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QBrush *
+          cpp_arg_1 = static_cast < QBrush * >(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer->fillRect((const QRectF &)*cpp_arg_0, (const QBrush &)*cpp_arg_1));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF" && obj_z_1->inherits("QBrush")) {
-				obj->fillRect((const QRectF&) obj_z_0, (const QBrush&) obj_z_1);
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QRect" && obj_z_1->inherits("QBrush")) {
-				obj->fillRect((const QRect&) obj_z_0, (const QBrush&) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllo public*/
+#endif
 
-		/* int x, int y, int w, int h, const QBrush& ,  */
+    }
+  }
+  ///int x, int y, int w, int h, const QBrush &
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_OBJECT) {
+#ifdef PHP_QT_QBrush
+      if (inherits(Z_OBJCE_P(arg_4), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'fillRect' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, const QBrush &,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 5){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzz", &z_0, &z_1, &z_2, &z_3, &z_4) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_4 = (QObject*) php_qt_fetch(z_4);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QBrush *
+          cpp_arg_4 = static_cast < QBrush * >(php_qt_fetch(arg_4));
 
+        RETURN_VOID(selfpointer->fillRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QBrush &)*cpp_arg_4));
+      }
+#endif
 
-			if(obj_z_4->inherits("QBrush")) {
-				obj->fillRect((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (const QBrush&) obj_z_4);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  ///const QRect &, const QBrush &
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QBrush
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'fillRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &, const QBrush &,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+        QBrush *
+          cpp_arg_1 = static_cast < QBrush * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->fillRect((const QRect &)*cpp_arg_0, (const QBrush &)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::fillRect(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  boundingRect
- *    flags:    
+/*!
+ * method boundingRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &rects0
+ * @param	 int flagss1
+ * @param	 const QString &texts2
+ * 
+ * overloaded args:
+ * @param	const QRect &rect
+ * @param	 int flags
+ * @param	 const QString &text
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 int flags
+ * @param	 const QString &text
+ * 
+ * overloaded args:
+ * @param	const QRectF &rect
+ * @param	 const QString &text
+ * @param	 const QTextOption &o = QTextOption()
+ * 
+ * @access	public
+ * @return	QRectF
+ * @flags	
  */
-ZEND_METHOD(QPainter, boundingRect){
-		/* ooo public*/
 
-		/* const QRectF& rect, const QString& text, const QTextOption& o,  */
-		/* olo public*/
+ZEND_METHOD(QPainter, boundingRect)
+{
+  ///const QRectF &rects0, int flagss1, const QString &texts2
+#ifdef PHP_QT_QRectF            // return type
 
-		/* const QRectF& rect, int flags, const QString& text,  */
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'boundingRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rects0, int flagss1, const QString &texts2,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
+        zend_class_entry *
+          ce;
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF" && Z_OBJCE_P(z_1)->name == "QString" && obj_z_2->inherits("QTextOption")) {
-				obj->boundingRect((const QRectF&) obj_z_0, (const QString&) obj_z_1, (const QTextOption&) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QRectF *
+          return_object = new QRectF;
 
+        *return_object = static_cast < QRectF > (selfpointer->boundingRect((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF" && Z_OBJCE_P(z_2)->name == "QString") {
-/*					QRect return_object = (QRect) obj->boundingRect((const QRectF&) obj_z_0, (int) Z_LVAL_P(z_1), (const QString&) obj_z_2);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-*/				return;                                             
-			}
-			if(Z_OBJCE_P(z_0)->name == "QRect" && Z_OBJCE_P(z_2)->name == "QString") {
-					QRect return_object = (QRect) obj->boundingRect((const QRect&) obj_z_0, (int) Z_LVAL_P(z_1), (const QString&) obj_z_2);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* lllllo public*/
+#endif
 
-		/* int x, int y, int w, int h, int flags, const QString& text,  */
+    }
+  }
+#endif // return type
 
-	if (ZEND_NUM_ARGS() == 6){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzzz", &z_0, &z_1, &z_2, &z_3, &z_4, &z_5) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG && Z_TYPE_P(z_5) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_5 = (QObject*) php_qt_fetch(z_5);
 
+  ///const QRect &rect, int flags, const QString &text
+#ifdef PHP_QT_QRect             // return type
 
-			if(Z_OBJCE_P(z_5)->name == "QString") {
-					QRect return_object = (QRect) obj->boundingRect((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (int) Z_LVAL_P(z_4), (const QString&) obj_z_5);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'boundingRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &rect, int flags, const QString &text,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
+        zend_class_entry *
+          ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QRect *
+          return_object = new QRect;
+
+        *return_object = static_cast < QRect > (selfpointer->boundingRect((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///int x, int y, int w, int h, int flags, const QString &text
+#ifdef PHP_QT_QRect             // return type
+
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    arg_5 = invokeToQString(arg_5);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
+        && Z_TYPE_P(arg_5) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_5), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'boundingRect' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, int flags, const QString &text,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_5 = static_cast < QString * >(php_qt_fetch(arg_5));
+        zend_class_entry *
+          ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QRect *
+          return_object = new QRect;
+
+        *return_object =
+          static_cast < QRect >
+          (selfpointer->
+           boundingRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                        (const QString &)*cpp_arg_5));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QRectF &rect, const QString &text, const QTextOption &o = QTextOption()
+#ifdef PHP_QT_QRectF            // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'boundingRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rect, const QString &text,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        zend_class_entry *
+          ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QRectF *
+          return_object = new QRectF;
+
+        *return_object = static_cast < QRectF > (selfpointer->boundingRect((const QRectF &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_1 = invokeToQString(arg_1);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'boundingRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rect, const QString &text, const QTextOption &o = QTextOption(),
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        QTextOption *
+          cpp_arg_2 = static_cast < QTextOption * >(php_qt_fetch(arg_2));
+        zend_class_entry *
+          ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QRectF *
+          return_object = new QRectF;
+
+        *return_object =
+          static_cast < QRectF > (selfpointer->boundingRect((const QRectF &)*cpp_arg_0, (const QString &)*cpp_arg_1, (const QTextOption &)*cpp_arg_2));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::boundingRect(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setClipRect
- *    flags:    
+/*!
+ * method setClipRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &s0
+ * @param	 Qt::ClipOperation op = Qt::ReplaceClips1
+ * 
+ * overloaded args:
+ * @param	const QRect &
+ * @param	 Qt::ClipOperation op = Qt::ReplaceClip
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 Qt::ClipOperation op = Qt::ReplaceClip
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setClipRect){
-		/* ol public*/
 
-		/* const QRectF& , int op,  */
+ZEND_METHOD(QPainter, setClipRect)
+{
+  ///const QRectF &s0, Qt::ClipOperation op = Qt::ReplaceClips1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setClipRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &s0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setClipRect((const QRectF &)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF") {
-				obj->setClipRect((const QRectF&) obj_z_0, (Qt::ClipOperation) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* lllll public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setClipRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &s0, Qt::ClipOperation op = Qt::ReplaceClips1,
+        QPainter *
+          selfpointer;
 
-		/* int x, int y, int w, int h, int op,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 5){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzz", &z_0, &z_1, &z_2, &z_3, &z_4) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer->setClipRect((const QRectF &)*cpp_arg_0, (Qt::ClipOperation) Z_LVAL_P(arg_1)));
+      }
+#endif
 
+    }
+  }
+  ///const QRect &, Qt::ClipOperation op = Qt::ReplaceClip
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setClipRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &,
+        QPainter *
+          selfpointer;
 
-			obj->setClipRect((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3) ,(Qt::ClipOperation) Z_LVAL_P(z_4));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setClipRect((const QRect &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setClipRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &, Qt::ClipOperation op = Qt::ReplaceClip,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setClipRect((const QRect &)*cpp_arg_0, (Qt::ClipOperation) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///int x, int y, int w, int h, Qt::ClipOperation op = Qt::ReplaceClip
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setClipRect' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setClipRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setClipRect' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h, Qt::ClipOperation op = Qt::ReplaceClip,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->
+                  setClipRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (Qt::ClipOperation) Z_LVAL_P(arg_4)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setClipRect(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawImage
- *    flags:    
+/*!
+ * method drawImage
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &targetRects0
+ * @param	 const QImage &images1
+ * @param	 const QRectF &sourceRects2
+ * @param	 Qt::ImageConversionFlags flags = Qt::AutoColors3
+ * 
+ * overloaded args:
+ * @param	const QRect &targetRect
+ * @param	 const QImage &image
+ * @param	 const QRect &sourceRect
+ * @param	 Qt::ImageConversionFlags flags = Qt::AutoColor
+ * 
+ * overloaded args:
+ * @param	const QPointF &p
+ * @param	 const QImage &image
+ * @param	 const QRectF &sr
+ * @param	 Qt::ImageConversionFlags flags = Qt::AutoColor
+ * 
+ * overloaded args:
+ * @param	const QPoint &p
+ * @param	 const QImage &image
+ * @param	 const QRect &sr
+ * @param	 Qt::ImageConversionFlags flags = Qt::AutoColor
+ * 
+ * overloaded args:
+ * @param	const QRectF &r
+ * @param	 const QImage &image
+ * 
+ * overloaded args:
+ * @param	const QRect &r
+ * @param	 const QImage &image
+ * 
+ * overloaded args:
+ * @param	const QPointF &p
+ * @param	 const QImage &image
+ * 
+ * overloaded args:
+ * @param	const QPoint &p
+ * @param	 const QImage &image
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 const QImage &image
+ * @param	 int sx = 0
+ * @param	 int sy = 0
+ * @param	 int sw = -1
+ * @param	 int sh = -1
+ * @param	 Qt::ImageConversionFlags flags = Qt::AutoColor
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawImage){
-NOT_YET_IMPLEMENTED
-		/* oo public*/
 
-		/* const QRectF& r, const QImage& image,  */
-		/* lo public*/
+ZEND_METHOD(QPainter, drawImage)
+{
+  ///const QRectF &targetRects0, const QImage &images1, const QRectF &sourceRects2, Qt::ImageConversionFlags flags = Qt::AutoColors3
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &targetRects0, const QImage &images1, const QRectF &sourceRects2,
+        QPainter *
+          selfpointer;
 
-		/* const QPointF& p, const QImage& image,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
+        QRectF *
+          cpp_arg_2 = static_cast < QRectF * >(php_qt_fetch(arg_2));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        RETURN_VOID(selfpointer->drawImage((const QRectF &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRectF &)*cpp_arg_2));
+      }
+#endif
 
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF" && obj_z_1->inherits("QImage")) {
-				obj->drawImage((const QRectF&) obj_z_0, (const QImage&) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+#endif
 
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &targetRects0, const QImage &images1, const QRectF &sourceRects2, Qt::ImageConversionFlags flags = Qt::AutoColors3,
+        QPainter *
+          selfpointer;
 
-			if(obj_z_1->inherits("QImage")) {
-				obj->drawImage((const QPointF&) Z_LVAL_P(z_0), (const QImage&) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* looo public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
+        QRectF *
+          cpp_arg_2 = static_cast < QRectF * >(php_qt_fetch(arg_2));
 
-		/* const QPointF& p, const QImage& image, const QRectF& sr, Qt::ImageConversionFlags flags,  */
-		/* oooo public*/
+        RETURN_VOID(selfpointer->
+                    drawImage((const QRectF &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRectF &)*cpp_arg_2, (Qt::ImageConversionFlags) Z_LVAL_P(arg_3)));
+      }
+#endif
 
-		/* const QRectF& targetRect, const QImage& image, const QRectF& sourceRect, Qt::ImageConversionFlags flags,  */
+#endif
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
-			QObject* obj_z_3 = (QObject*) php_qt_fetch(z_3);
+#endif
 
+    }
+  }
+  ///const QRect &targetRect, const QImage &image, const QRect &sourceRect, Qt::ImageConversionFlags flags = Qt::AutoColor
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &targetRect, const QImage &image, const QRect &sourceRect,
+        QPainter *
+          selfpointer;
 
-			if(obj_z_1->inherits("QImage") && Z_OBJCE_P(z_2)->name == "QRectF" && obj_z_3->inherits("Qt::ImageConversionFlags")) {
-//				obj->drawImage((const QPointF&) Z_LVAL_P(z_0), (const QImage&) obj_z_1, (const QRectF&) obj_z_2, (Qt::ImageConversionFlags) obj_z_3);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
-			QObject* obj_z_3 = (QObject*) php_qt_fetch(z_3);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
+        QRect *
+          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer->drawImage((const QRect &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRect &)*cpp_arg_2));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF" && obj_z_1->inherits("QImage") && Z_OBJCE_P(z_2)->name == "QRectF" && obj_z_3->inherits("Qt::ImageConversionFlags")) {
-//				obj->drawImage((const QRectF&) obj_z_0, (const QImage&) obj_z_1, (const QRectF&) obj_z_2, (Qt::ImageConversionFlags) obj_z_3);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llollllo public*/
+#endif
 
-		/* int x, int y, const QImage& image, int sx, int sy, int sw, int sh, Qt::ImageConversionFlags flags,  */
+#endif
 
-	if (ZEND_NUM_ARGS() == 8){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		zval *z_6; // define ZVAL
-		zval *z_7; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzzzzz", &z_0, &z_1, &z_2, &z_3, &z_4, &z_5, &z_6, &z_7) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG && Z_TYPE_P(z_5) == IS_LONG && Z_TYPE_P(z_6) == IS_LONG && Z_TYPE_P(z_7) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
-			QObject* obj_z_7 = (QObject*) php_qt_fetch(z_7);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &targetRect, const QImage &image, const QRect &sourceRect, Qt::ImageConversionFlags flags = Qt::AutoColor,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
+        QRect *
+          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));
 
-			if(obj_z_2->inherits("QImage") && obj_z_7->inherits("Qt::ImageConversionFlags")) {
-//				obj->drawImage((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QImage&) obj_z_2, (int) Z_LVAL_P(z_3), (int) Z_LVAL_P(z_4), (int) Z_LVAL_P(z_5), (int) Z_LVAL_P(z_6), (Qt::ImageConversionFlags) obj_z_7);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_VOID(selfpointer->
+                    drawImage((const QRect &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRect &)*cpp_arg_2, (Qt::ImageConversionFlags) Z_LVAL_P(arg_3)));
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+  ///const QPointF &p, const QImage &image, const QRectF &sr, Qt::ImageConversionFlags flags = Qt::AutoColor
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF &p, const QImage &image, const QRectF &sr,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
+        QRectF *
+          cpp_arg_2 = static_cast < QRectF * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->drawImage((const QPointF &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRectF &)*cpp_arg_2));
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF &p, const QImage &image, const QRectF &sr, Qt::ImageConversionFlags flags = Qt::AutoColor,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
+        QRectF *
+          cpp_arg_2 = static_cast < QRectF * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->
+                    drawImage((const QPointF &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRectF &)*cpp_arg_2, (Qt::ImageConversionFlags) Z_LVAL_P(arg_3)));
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+  ///const QPoint &p, const QImage &image, const QRect &sr, Qt::ImageConversionFlags flags = Qt::AutoColor
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &p, const QImage &image, const QRect &sr,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
+        QRect *
+          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->drawImage((const QPoint &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRect &)*cpp_arg_2));
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &p, const QImage &image, const QRect &sr, Qt::ImageConversionFlags flags = Qt::AutoColor,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
+        QRect *
+          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->
+                    drawImage((const QPoint &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRect &)*cpp_arg_2, (Qt::ImageConversionFlags) Z_LVAL_P(arg_3)));
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+  ///const QRectF &r, const QImage &image
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &r, const QImage &image,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->drawImage((const QRectF &)*cpp_arg_0, (const QImage &)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QRect &r, const QImage &image
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &r, const QImage &image,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->drawImage((const QRect &)*cpp_arg_0, (const QImage &)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QPointF &p, const QImage &image
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF &p, const QImage &image,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->drawImage((const QPointF &)*cpp_arg_0, (const QImage &)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QPoint &p, const QImage &image
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &p, const QImage &image,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->drawImage((const QPoint &)*cpp_arg_0, (const QImage &)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///int x, int y, const QImage &image, int sx = 0, int sy = 0, int sw = -1, int sh = -1, Qt::ImageConversionFlags flags = Qt::AutoColor
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QImage &image,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QImage *
+          cpp_arg_2 = static_cast < QImage * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &)*cpp_arg_2));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QImage &image, int sx = 0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QImage *
+          cpp_arg_2 = static_cast < QImage * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &)*cpp_arg_2, (int)Z_LVAL_P(arg_3)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QImage &image, int sx = 0, int sy = 0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QImage *
+          cpp_arg_2 = static_cast < QImage * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG && Z_TYPE_P(arg_5) == IS_LONG) {
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QImage &image, int sx = 0, int sy = 0, int sw = -1,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QImage *
+          cpp_arg_2 = static_cast < QImage * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->
+                    drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                              (int)Z_LVAL_P(arg_5)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 7) {
+    PHP_QT_FETCH_7_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG && Z_TYPE_P(arg_5) == IS_LONG && Z_TYPE_P(arg_6) == IS_LONG) {
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QImage &image, int sx = 0, int sy = 0, int sw = -1, int sh = -1,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QImage *
+          cpp_arg_2 = static_cast < QImage * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->
+                    drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                              (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 8) {
+    PHP_QT_FETCH_8_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG && Z_TYPE_P(arg_5) == IS_LONG && Z_TYPE_P(arg_6) == IS_LONG && Z_TYPE_P(arg_7) == IS_LONG) {
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawImage' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QImage &image, int sx = 0, int sy = 0, int sw = -1, int sh = -1, Qt::ImageConversionFlags flags = Qt::AutoColor,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QImage *
+          cpp_arg_2 = static_cast < QImage * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->
+                    drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                              (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6), (Qt::ImageConversionFlags) Z_LVAL_P(arg_7)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawImage(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawTiledPixmap
- *    flags:    
+/*!
+ * method drawTiledPixmap
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &rects0
+ * @param	 const QPixmap &pms1
+ * @param	 const QPointF &offset = QPointF()s2
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 const QPixmap &
+ * @param	 int sx=0
+ * @param	 int sy=0
+ * 
+ * overloaded args:
+ * @param	const QRect &
+ * @param	 const QPixmap &
+ * @param	 const QPoint & = QPoint()
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawTiledPixmap){
-		/* ool public*/
 
-		/* const QRectF& rect, const QPixmap& pm, const QPointF& offset,  */
+ZEND_METHOD(QPainter, drawTiledPixmap)
+{
+  ///const QRectF &rects0, const QPixmap &pms1, const QPointF &offset = QPointF()s2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rects0, const QPixmap &pms1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer->drawTiledPixmap((const QRectF &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF" && obj_z_1->inherits("QPixmap")) {
-				obj->drawTiledPixmap((const QRectF&) obj_z_0, (const QPixmap&) obj_z_1, (const QPointF&) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QRect" && obj_z_1->inherits("QPixmap")) {
-				obj->drawTiledPixmap((const QRect&) obj_z_0, (const QPixmap&) obj_z_1, (const QPoint&) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* lllloll public*/
+#endif
 
-		/* int x, int y, int w, int h, const QPixmap& , int sx, int sy,  */
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rects0, const QPixmap &pms1, const QPointF &offset = QPointF()s2,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 7){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		zval *z_6; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzzzz", &z_0, &z_1, &z_2, &z_3, &z_4, &z_5, &z_6) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_OBJECT && Z_TYPE_P(z_5) == IS_LONG && Z_TYPE_P(z_6) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_4 = (QObject*) php_qt_fetch(z_4);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
+        QPointF *
+          cpp_arg_2 = static_cast < QPointF * >(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer->drawTiledPixmap((const QRectF &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1, (const QPointF &)*cpp_arg_2));
+      }
+#endif
 
-			if(obj_z_4->inherits("QPixmap")) {
-				obj->drawTiledPixmap((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (const QPixmap&) obj_z_4, (int) Z_LVAL_P(z_5), (int) Z_LVAL_P(z_6));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+#endif
+
+    }
+  }
+  ///int x, int y, int w, int h, const QPixmap &, int sx=0, int sy=0
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_OBJECT) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_4), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, const QPixmap &,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_4 = static_cast < QPixmap * >(php_qt_fetch(arg_4));
+
+        RETURN_VOID(selfpointer->
+                    drawTiledPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &)*cpp_arg_4));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_OBJECT && Z_TYPE_P(arg_5) == IS_LONG) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_4), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, const QPixmap &, int sx=0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_4 = static_cast < QPixmap * >(php_qt_fetch(arg_4));
+
+        RETURN_VOID(selfpointer->
+                    drawTiledPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &)*cpp_arg_4,
+                                    (int)Z_LVAL_P(arg_5)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 7) {
+    PHP_QT_FETCH_7_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_OBJECT && Z_TYPE_P(arg_5) == IS_LONG && Z_TYPE_P(arg_6) == IS_LONG) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_4), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, const QPixmap &, int sx=0, int sy=0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_4 = static_cast < QPixmap * >(php_qt_fetch(arg_4));
+
+        RETURN_VOID(selfpointer->
+                    drawTiledPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &)*cpp_arg_4,
+                                    (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6)));
+      }
+#endif
+
+    }
+  }
+  ///const QRect &, const QPixmap &, const QPoint & = QPoint()
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &, const QPixmap &,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->drawTiledPixmap((const QRect &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &, const QPixmap &, const QPoint & = QPoint(),
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
+        QPoint *
+          cpp_arg_2 = static_cast < QPoint * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->drawTiledPixmap((const QRect &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1, (const QPoint &)*cpp_arg_2));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawTiledPixmap(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  layoutDirection
- *    flags:    c
+/*!
+ * method layoutDirection
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::LayoutDirection
+ * @flags	c
  */
-ZEND_METHOD(QPainter, layoutDirection){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_LONG(obj->layoutDirection());
-	}
+
+ZEND_METHOD(QPainter, layoutDirection)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'layoutDirection' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->layoutDirection());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::layoutDirection(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  background
- *    flags:    c
+/*!
+ * method background
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QBrush &
+ * @flags	c
  */
-ZEND_METHOD(QPainter, background){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				const QBrush & return_object = (const QBrush &) obj->background();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, background)
+{
+  ///
+#ifdef PHP_QT_QBrush            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'background' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &const_cast < QBrush & >(selfpointer->background());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::background(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPolygon
- *    flags:    
+/*!
+ * method drawPolygon
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF *pointss0
+ * @param	 int pointCounts1
+ * @param	 Qt::FillRule fillRule = Qt::OddEvenFills2
+ * 
+ * overloaded args:
+ * @param	const QPolygonF &polygon
+ * @param	 Qt::FillRule fillRule = Qt::OddEvenFill
+ * 
+ * overloaded args:
+ * @param	const QPoint *points
+ * @param	 int pointCount
+ * @param	 Qt::FillRule fillRule = Qt::OddEvenFill
+ * 
+ * overloaded args:
+ * @param	const QPolygon &polygon
+ * @param	 Qt::FillRule fillRule = Qt::OddEvenFill
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPolygon){
-		/* ol public*/
 
-		/* const QPolygonF& polygon, int fillRule,  */
+ZEND_METHOD(QPainter, drawPolygon)
+{
+  ///const QPointF *pointss0, int pointCounts1, Qt::FillRule fillRule = Qt::OddEvenFills2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPolygon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF *pointss0, int pointCounts1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawPolygon((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QPolygonF") {
-				obj->drawPolygon((const QPolygonF&) obj_z_0, (Qt::FillRule) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QPolygon") {
-				obj->drawPolygon((const QPolygon&) obj_z_0, (Qt::FillRule) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* lll public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPolygon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF *pointss0, int pointCounts1, Qt::FillRule fillRule = Qt::OddEvenFills2,
+        QPainter *
+          selfpointer;
 
-		/* const QPointF* points, int pointCount, int fillRule,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer->drawPolygon((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::FillRule) Z_LVAL_P(arg_2)));
+      }
+#endif
 
+    }
+  }
+  ///const QPolygonF &polygon, Qt::FillRule fillRule = Qt::OddEvenFill
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygonF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPolygon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPolygonF &polygon,
+        QPainter *
+          selfpointer;
 
-			obj->drawPolygon((const QPointF*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(Qt::FillRule) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPolygonF *
+          cpp_arg_0 = static_cast < QPolygonF * >(php_qt_fetch(arg_0));
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  device
- *    flags:    c
- */
-ZEND_METHOD(QPainter, device){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QPaintDevice * return_object = (QPaintDevice *) obj->device();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+        RETURN_VOID(selfpointer->drawPolygon((const QPolygonF &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPolygonF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPolygon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPolygonF &polygon, Qt::FillRule fillRule = Qt::OddEvenFill,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPolygonF *
+          cpp_arg_0 = static_cast < QPolygonF * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawPolygon((const QPolygonF &)*cpp_arg_0, (Qt::FillRule) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QPoint *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPolygon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint *points, int pointCount,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawPolygon((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPolygon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawPolygon((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::FillRule) Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  ///const QPolygon &polygon, Qt::FillRule fillRule = Qt::OddEvenFill
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPolygon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPolygon &polygon,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPolygon *
+          cpp_arg_0 = static_cast < QPolygon * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawPolygon((const QPolygon &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPolygon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPolygon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPolygon &polygon, Qt::FillRule fillRule = Qt::OddEvenFill,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPolygon *
+          cpp_arg_0 = static_cast < QPolygon * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawPolygon((const QPolygon &)*cpp_arg_0, (Qt::FillRule) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawPolygon(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setClipRegion
- *    flags:    
+/*!
+ * method setClipRegion
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRegion &s0
+ * @param	 Qt::ClipOperation op = Qt::ReplaceClips1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setClipRegion){
-		/* ol public*/
 
-		/* const QRegion& , int op,  */
+ZEND_METHOD(QPainter, setClipRegion)
+{
+  ///const QRegion &s0, Qt::ClipOperation op = Qt::ReplaceClips1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegion
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setClipRegion' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegion &s0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRegion *
+          cpp_arg_0 = static_cast < QRegion * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setClipRegion((const QRegion &)*cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0->inherits("QRegion")) {
-				obj->setClipRegion((const QRegion&) obj_z_0, (Qt::ClipOperation) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRegion
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setClipRegion' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegion &s0, Qt::ClipOperation op = Qt::ReplaceClips1,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRegion *
+          cpp_arg_0 = static_cast < QRegion * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setClipRegion((const QRegion &)*cpp_arg_0, (Qt::ClipOperation) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setClipRegion(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  restoreRedirected
- *    flags:    s
+/*!
+ * method device
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPaintDevice *
+ * @flags	c
  */
-ZEND_METHOD(QPainter, restoreRedirected){
-		/* l public*/
 
-		/* const QPaintDevice* device,  */
+ZEND_METHOD(QPainter, device)
+{
+  ///
+#ifdef PHP_QT_QPaintDevice      // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'device' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj->restoreRedirected((const QPaintDevice*) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast < QPaintDevice * >(selfpointer->device());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::device(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setMatrixEnabled
- *    flags:    
+/*!
+ * method restoreRedirected
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPaintDevice *devices0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QPainter, setMatrixEnabled){
-		/* l public*/
 
-		/* int enabled,  */
+ZEND_METHOD(QPainter, restoreRedirected)
+{
+  ///const QPaintDevice *devices0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPaintDevice
+      if (inherits(Z_OBJCE_P(arg_0), 49)) {
+        /// try const QPaintDevice *devices0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPaintDevice *
+          cpp_arg_0 = static_cast < QPaintDevice * >(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QPainter::restoreRedirected((const QPaintDevice *)cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer->restoreRedirected((const QPaintDevice *)cpp_arg_0));
+      }}
+#endif
 
-			obj->setMatrixEnabled((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::restoreRedirected(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPoints
- *    flags:    
+/*!
+ * method setMatrixEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enableds0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPoints){
-		/* o public*/
 
-		/* const QPolygonF& points,  */
+ZEND_METHOD(QPainter, setMatrixEnabled)
+{
+  ///bool enableds0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMatrixEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try bool enableds0,
+      QPainter *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMatrixEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setMatrixEnabled(...) ");
+}
 
+/*!
+ * method drawPoints
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF *pointss0
+ * @param	 int pointCounts1
+ * 
+ * overloaded args:
+ * @param	const QPolygonF &points
+ * 
+ * overloaded args:
+ * @param	const QPoint *points
+ * @param	 int pointCount
+ * 
+ * overloaded args:
+ * @param	const QPolygon &points
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			if(Z_OBJCE_P(z_0)->name == "QPolygonF") {
-				obj->drawPoints((const QPolygonF&) obj_z_0);
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QPolygon") {
-				obj->drawPoints((const QPolygon&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ll public*/
+ZEND_METHOD(QPainter, drawPoints)
+{
+  ///const QPointF *pointss0, int pointCounts1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPoints' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF *pointss0, int pointCounts1,
+        QPainter *
+          selfpointer;
 
-		/* const QPointF* points, int pointCount,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer->drawPoints((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
+    }
+  }
+  ///const QPolygonF &points
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygonF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPoints' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPolygonF &points,
+        QPainter *
+          selfpointer;
 
-			obj->drawPoints((const QPointF*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPolygonF *
+          cpp_arg_0 = static_cast < QPolygonF * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawPoints((const QPolygonF &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///const QPoint *points, int pointCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPoints' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint *points, int pointCount,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawPoints((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QPolygon &points
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPoints' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPolygon &points,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPolygon *
+          cpp_arg_0 = static_cast < QPolygon * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawPoints((const QPolygon &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawPoints(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawRoundRect
- *    flags:    
+/*!
+ * method drawRoundRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &rs0
+ * @param	 int xround = 25s1
+ * @param	 int yround = 25s2
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 int = 25
+ * @param	 int = 25
+ * 
+ * overloaded args:
+ * @param	const QRect &r
+ * @param	 int xround = 25
+ * @param	 int yround = 25
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawRoundRect){
-		/* oll public*/
 
-		/* const QRectF& r, int xround, int yround,  */
+ZEND_METHOD(QPainter, drawRoundRect)
+{
+  ///const QRectF &rs0, int xround = 25s1, int yround = 25s2
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawRoundRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rs0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawRoundRect((const QRectF &)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF") {
-				obj->drawRoundRect((const QRectF&) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QRect") {
-				obj->drawRoundRect((const QRect&) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllll public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawRoundRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rs0, int xround = 25s1,
+        QPainter *
+          selfpointer;
 
-		/* int x, int y, int w, int h, int , int ,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 6){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzzz", &z_0, &z_1, &z_2, &z_3, &z_4, &z_5) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG && Z_TYPE_P(z_5) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer->drawRoundRect((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawRoundRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rs0, int xround = 25s1, int yround = 25s2,
+        QPainter *
+          selfpointer;
 
-			obj->drawRoundRect((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3) ,(int) Z_LVAL_P(z_4) ,(int) Z_LVAL_P(z_5));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawRoundRect((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  ///int x, int y, int w, int h, int = 25, int = 25
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'drawRoundRect' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->drawRoundRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'drawRoundRect' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h, int = 25,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->drawRoundRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
+        && Z_TYPE_P(arg_5) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'drawRoundRect' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h, int = 25, int = 25,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->
+                  drawRoundRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                                (int)Z_LVAL_P(arg_5)));
+    }
+  }
+  ///const QRect &r, int xround = 25, int yround = 25
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawRoundRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &r,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawRoundRect((const QRect &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawRoundRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &r, int xround = 25,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawRoundRect((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawRoundRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &r, int xround = 25, int yround = 25,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawRoundRect((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawRoundRect(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawConvexPolygon
- *    flags:    
+/*!
+ * method drawConvexPolygon
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF *pointss0
+ * @param	 int pointCounts1
+ * 
+ * overloaded args:
+ * @param	const QPolygonF &polygon
+ * 
+ * overloaded args:
+ * @param	const QPoint *points
+ * @param	 int pointCount
+ * 
+ * overloaded args:
+ * @param	const QPolygon &polygon
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawConvexPolygon){
-		/* o public*/
 
-		/* const QPolygonF& polygon,  */
+ZEND_METHOD(QPainter, drawConvexPolygon)
+{
+  ///const QPointF *pointss0, int pointCounts1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawConvexPolygon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF *pointss0, int pointCounts1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawConvexPolygon((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QPolygonF") {
-				obj->drawConvexPolygon((const QPolygonF&) obj_z_0);
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QPolygon") {
-				obj->drawConvexPolygon((const QPolygon&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ll public*/
+    }
+  }
+  ///const QPolygonF &polygon
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygonF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawConvexPolygon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPolygonF &polygon,
+        QPainter *
+          selfpointer;
 
-		/* const QPointF* points, int pointCount,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPolygonF *
+          cpp_arg_0 = static_cast < QPolygonF * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer->drawConvexPolygon((const QPolygonF &)*cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///const QPoint *points, int pointCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawConvexPolygon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint *points, int pointCount,
+        QPainter *
+          selfpointer;
 
-			obj->drawConvexPolygon((const QPointF*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawConvexPolygon((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QPolygon &polygon
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawConvexPolygon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPolygon &polygon,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPolygon *
+          cpp_arg_0 = static_cast < QPolygon * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawConvexPolygon((const QPolygon &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawConvexPolygon(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setMatrix
- *    flags:    
+/*!
+ * method drawPicture
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF &ps0
+ * @param	 const QPicture &pictures1
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 const QPicture &picture
+ * 
+ * overloaded args:
+ * @param	const QPoint &p
+ * @param	 const QPicture &picture
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setMatrix){
-		/* ol public*/
 
-		/* const QMatrix& matrix, int combine,  */
+ZEND_METHOD(QPainter, drawPicture)
+{
+  ///const QPointF &ps0, const QPicture &pictures1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QPicture
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPicture' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF &ps0, const QPicture &pictures1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
+        QPicture *
+          cpp_arg_1 = static_cast < QPicture * >(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer->drawPicture((const QPointF &)*cpp_arg_0, (const QPicture &)*cpp_arg_1));
+      }
+#endif
 
-			if(obj_z_0->inherits("QMatrix")) {
-				obj->setMatrix((const QMatrix&) obj_z_0, (bool) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+#endif
+
+    }
+  }
+  ///int x, int y, const QPicture &picture
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPicture
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPicture' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QPicture &picture,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPicture *
+          cpp_arg_2 = static_cast < QPicture * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->drawPicture((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QPicture &)*cpp_arg_2));
+      }
+#endif
+
+    }
+  }
+  ///const QPoint &p, const QPicture &picture
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPicture
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPicture' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &p, const QPicture &picture,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QPicture *
+          cpp_arg_1 = static_cast < QPicture * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->drawPicture((const QPoint &)*cpp_arg_0, (const QPicture &)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawPicture(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPicture
- *    flags:    
+/*!
+ * method setMatrix
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QMatrix &matrixs0
+ * @param	 bool combine = falses1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPicture){
-		/* lo public*/
 
-		/* const QPointF& p, const QPicture& picture,  */
+ZEND_METHOD(QPainter, setMatrix)
+{
+  ///const QMatrix &matrixs0, bool combine = falses1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QMatrix
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setMatrix' is not static");
+          RETURN_NULL();
+        }
+        /// try const QMatrix &matrixs0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QMatrix *
+          cpp_arg_0 = static_cast < QMatrix * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setMatrix((const QMatrix &)*cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_1->inherits("QPicture")) {
-				obj->drawPicture((const QPointF&) Z_LVAL_P(z_0), (const QPicture&) obj_z_1);
-			RETURN_NULL();
-			}
-			if(obj_z_1->inherits("QPicture")) {
-				obj->drawPicture((const QPoint&) Z_LVAL_P(z_0), (const QPicture&) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llo public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_BOOL) {
+#ifdef PHP_QT_QMatrix
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setMatrix' is not static");
+          RETURN_NULL();
+        }
+        /// try const QMatrix &matrixs0, bool combine = falses1,
+        QPainter *
+          selfpointer;
 
-		/* int x, int y, const QPicture& picture,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QMatrix *
+          cpp_arg_0 = static_cast < QMatrix * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        RETURN_VOID(selfpointer->setMatrix((const QMatrix &)*cpp_arg_0, (bool) Z_LVAL_P(arg_1)));
+      }
+#endif
 
-
-			if(obj_z_2->inherits("QPicture")) {
-				obj->drawPicture((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QPicture&) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setMatrix(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  restore
- *    flags:    
+/*!
+ * method restore
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, restore){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			obj->restore();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QPainter, restore)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'restore' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->restore());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::restore(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  font
- *    flags:    c
+/*!
+ * method matrix
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QMatrix &
+ * @flags	c
  */
-ZEND_METHOD(QPainter, font){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				const QFont & return_object = (const QFont &) obj->font();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, matrix)
+{
+  ///
+#ifdef PHP_QT_QMatrix           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'matrix' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &const_cast < QMatrix & >(selfpointer->matrix());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::matrix(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  matrix
- *    flags:    c
+/*!
+ * method font
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QFont &
+ * @flags	c
  */
-ZEND_METHOD(QPainter, matrix){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				const QMatrix & return_object = (const QMatrix &) obj->matrix();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, font)
+{
+  ///
+#ifdef PHP_QT_QFont             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'font' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &const_cast < QFont & >(selfpointer->font());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::font(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  viewport
- *    flags:    c
+/*!
+ * method viewport
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-ZEND_METHOD(QPainter, viewport){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QRect return_object = (QRect) obj->viewport();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, viewport)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'viewport' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast < QRect > (selfpointer->viewport());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::viewport(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  viewTransformEnabled
- *    flags:    c
+/*!
+ * method viewTransformEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QPainter, viewTransformEnabled){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->viewTransformEnabled());
-	}
+
+ZEND_METHOD(QPainter, viewTransformEnabled)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'viewTransformEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->viewTransformEnabled());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::viewTransformEnabled(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawText
- *    flags:    
+/*!
+ * method drawText
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF &ps0
+ * @param	 const QString &ss1
+ * 
+ * overloaded args:
+ * @param	const QPoint &p
+ * @param	 const QString &s
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 const QString &s
+ * 
+ * overloaded args:
+ * @param	const QRectF &r
+ * @param	 int flags
+ * @param	 const QString &text
+ * @param	 QRectF *br=0
+ * 
+ * overloaded args:
+ * @param	const QRect &r
+ * @param	 int flags
+ * @param	 const QString &text
+ * @param	 QRect *br=0
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 int flags
+ * @param	 const QString &text
+ * @param	 QRect *br=0
+ * 
+ * overloaded args:
+ * @param	const QRectF &r
+ * @param	 const QString &text
+ * @param	 const QTextOption &o = QTextOption()
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawText){
-		/* lo public*/
 
-		/* const QPointF& p, const QString& s,  */
+ZEND_METHOD(QPainter, drawText)
+{
+  ///const QPointF &ps0, const QString &ss1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawText' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF &ps0, const QString &ss1,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
 
-			if(Z_OBJCE_P(z_1)->name == "QString") {
-				obj->drawText((const QPointF&) Z_LVAL_P(z_0), (const QString&) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ooo public*/
+        RETURN_VOID(selfpointer->drawText((const QPointF &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+      }
+#endif
 
-		/* const QRectF& r, const QString& text, const QTextOption& o,  */
-		/* llo public*/
+#endif
 
-		/* int x, int y, const QString& s,  */
+    }
+  }
+  ///const QPoint &p, const QString &s
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawText' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &p, const QString &s,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF" && Z_OBJCE_P(z_1)->name == "QString" && obj_z_2->inherits("QTextOption")) {
-				obj->drawText((const QRectF&) obj_z_0, (const QString&) obj_z_1, (const QTextOption&) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        RETURN_VOID(selfpointer->drawText((const QPoint &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+      }
+#endif
 
+#endif
 
-			if(Z_OBJCE_P(z_2)->name == "QString") {
-				obj->drawText((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QString&) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* oloo public*/
+    }
+  }
+  ///int x, int y, const QString &s
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
 
-		/* const QRectF& r, int flags, const QString& text, QRectF* br,  */
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawText' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QString &s,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
-			QObject* obj_z_3 = (QObject*) php_qt_fetch(z_3);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer->drawText((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF" && Z_OBJCE_P(z_2)->name == "QString" && Z_OBJCE_P(z_3)->name == "QRectF") {
-				obj->drawText((const QRectF&) obj_z_0, (int) Z_LVAL_P(z_1), (const QString&) obj_z_2, (QRectF*) obj_z_3);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllloo public*/
+    }
+  }
+  ///const QRectF &r, int flags, const QString &text, QRectF *br=0
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
 
-		/* int x, int y, int w, int h, int flags, const QString& text, qt_QRect* br,  */
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawText' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &r, int flags, const QString &text,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 7){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		zval *z_6; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzzzz", &z_0, &z_1, &z_2, &z_3, &z_4, &z_5, &z_6) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG && Z_TYPE_P(z_5) == IS_OBJECT && Z_TYPE_P(z_6) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_5 = (QObject*) php_qt_fetch(z_5);
-			QObject* obj_z_6 = (QObject*) php_qt_fetch(z_6);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer->drawText((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_5)->name == "QString" && Z_OBJCE_P(z_6)->name == "QRect") {
-				obj->drawText((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (int) Z_LVAL_P(z_4), (const QString&) obj_z_5, (QRect*) obj_z_6);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    arg_2 = invokeToQString(arg_2);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawText' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &r, int flags, const QString &text, QRectF *br=0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
+        QRectF *
+          cpp_arg_3 = static_cast < QRectF * >(php_qt_fetch(arg_3));
+
+        RETURN_VOID(selfpointer->drawText((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2, (QRectF *) cpp_arg_3));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QRect &r, int flags, const QString &text, QRect *br=0
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawText' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &r, int flags, const QString &text,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->drawText((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    arg_2 = invokeToQString(arg_2);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawText' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &r, int flags, const QString &text, QRect *br=0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
+        QRect *
+          cpp_arg_3 = static_cast < QRect * >(php_qt_fetch(arg_3));
+
+        RETURN_VOID(selfpointer->drawText((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2, (QRect *) cpp_arg_3));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///int x, int y, int w, int h, int flags, const QString &text, QRect *br=0
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    arg_5 = invokeToQString(arg_5);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
+        && Z_TYPE_P(arg_5) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_5), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawText' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, int flags, const QString &text,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_5 = static_cast < QString * >(php_qt_fetch(arg_5));
+
+        RETURN_VOID(selfpointer->
+                    drawText((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                             (const QString &)*cpp_arg_5));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 7) {
+    PHP_QT_FETCH_7_ARGS();
+    arg_5 = invokeToQString(arg_5);
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
+        && Z_TYPE_P(arg_5) == IS_OBJECT && Z_TYPE_P(arg_6) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_5), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawText' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, int flags, const QString &text, QRect *br=0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_5 = static_cast < QString * >(php_qt_fetch(arg_5));
+        QRect *
+          cpp_arg_6 = static_cast < QRect * >(php_qt_fetch(arg_6));
+
+        RETURN_VOID(selfpointer->
+                    drawText((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                             (const QString &)*cpp_arg_5, (QRect *) cpp_arg_6));
+      }
+#endif
+
+    }
+  }
+  ///const QRectF &r, const QString &text, const QTextOption &o = QTextOption()
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawText' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &r, const QString &text,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer->drawText((const QRectF &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_1 = invokeToQString(arg_1);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawText' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &r, const QString &text, const QTextOption &o = QTextOption(),
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        QTextOption *
+          cpp_arg_2 = static_cast < QTextOption * >(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer->drawText((const QRectF &)*cpp_arg_0, (const QString &)*cpp_arg_1, (const QTextOption &)*cpp_arg_2));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawText(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawChord
- *    flags:    
+/*!
+ * method drawChord
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &rects0
+ * @param	 int as1
+ * @param	 int alens2
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 int a
+ * @param	 int alen
+ * 
+ * overloaded args:
+ * @param	const QRect &
+ * @param	 int a
+ * @param	 int alen
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawChord){
-		/* oll public*/
 
-		/* const QRectF& rect, int a, int alen,  */
+ZEND_METHOD(QPainter, drawChord)
+{
+  ///const QRectF &rects0, int as1, int alens2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawChord' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rects0, int as1, int alens2,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawChord((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF") {
-				obj->drawChord((const QRectF&) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QRect") {
-				obj->drawChord((const QRect&) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllll public*/
+    }
+  }
+  ///int x, int y, int w, int h, int a, int alen
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
+        && Z_TYPE_P(arg_5) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'drawChord' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h, int a, int alen,
+      QPainter *
+        selfpointer;
 
-		/* int x, int y, int w, int h, int a, int alen,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->
+                  drawChord((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                            (int)Z_LVAL_P(arg_5)));
+    }
+  }
+  ///const QRect &, int a, int alen
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawChord' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &, int a, int alen,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 6){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzzz", &z_0, &z_1, &z_2, &z_3, &z_4, &z_5) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG && Z_TYPE_P(z_5) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawChord((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-			obj->drawChord((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3) ,(int) Z_LVAL_P(z_4) ,(int) Z_LVAL_P(z_5));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawChord(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  clipRegion
- *    flags:    c
+/*!
+ * method clipRegion
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRegion
+ * @flags	c
  */
-ZEND_METHOD(QPainter, clipRegion){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QRegion return_object = (QRegion) obj->clipRegion();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, clipRegion)
+{
+  ///
+#ifdef PHP_QT_QRegion           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'clipRegion' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRegion *
+        return_object = new QRegion;
+
+      *return_object = static_cast < QRegion > (selfpointer->clipRegion());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::clipRegion(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  end
- *    flags:    
+/*!
+ * method brushOrigin
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
-ZEND_METHOD(QPainter, end){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->end());
-	}
+
+ZEND_METHOD(QPainter, brushOrigin)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'brushOrigin' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QPoint *
+        return_object = new QPoint;
+
+      *return_object = static_cast < QPoint > (selfpointer->brushOrigin());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::brushOrigin(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  brushOrigin
- *    flags:    c
+/*!
+ * method end
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QPainter, brushOrigin){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QPoint return_object = (QPoint) obj->brushOrigin();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, end)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'end' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->end());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::end(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setViewTransformEnabled
- *    flags:    
+/*!
+ * method setViewTransformEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enables0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setViewTransformEnabled){
-		/* l public*/
 
-		/* int enable,  */
+ZEND_METHOD(QPainter, setViewTransformEnabled)
+{
+  ///bool enables0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setViewTransformEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try bool enables0,
+      QPainter *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setViewTransformEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setViewTransformEnabled(...) ");
+}
 
+/*!
+ * method scale
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	qreal sxs0
+ * @param	 qreal sys1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj->setViewTransformEnabled((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QPainter, scale)
+{
+// notice: unknown argument qreal sxs0, skipped
+  php_error(E_ERROR, "could not parse argument in QPainter::scale(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  scale
- *    flags:    
+/*!
+ * method setPen
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QColor &colors0
+ * 
+ * overloaded args:
+ * @param	const QPen &pen
+ * 
+ * overloaded args:
+ * @param	Qt::PenStyle style
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, scale){
-		/* ll public*/
 
-		/* double sx, double sy,  */
+ZEND_METHOD(QPainter, setPen)
+{
+  ///const QColor &colors0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QColor
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setPen' is not static");
+          RETURN_NULL();
+        }
+        /// try const QColor &colors0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QColor *
+          cpp_arg_0 = static_cast < QColor * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setPen((const QColor &)*cpp_arg_0));
+      }
+#endif
 
-			obj->scale((qreal) Z_LVAL_P(z_0) ,(qreal) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  ///const QPen &pen
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPen
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setPen' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPen &pen,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPen *
+          cpp_arg_0 = static_cast < QPen * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setPen((const QPen &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///Qt::PenStyle style
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setPen' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::PenStyle style,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setPen((Qt::PenStyle) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setPen(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setPen
- *    flags:    
+/*!
+ * method window
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-ZEND_METHOD(QPainter, setPen){
-		/* l public*/
 
-		/* int style,  */
-		/* o public*/
+ZEND_METHOD(QPainter, window)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
 
-		/* const QColor& color,  */
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'window' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
 
-			obj->setPen((Qt::PenStyle) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      *return_object = static_cast < QRect > (selfpointer->window());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
+  php_error(E_ERROR, "could not parse argument in QPainter::window(...) ");
+}
 
-			if(obj_z_0->inherits("QColor")) {
-				obj->setPen((const QColor&) obj_z_0);
-			RETURN_NULL();
-			}
-			if(obj_z_0->inherits("QPen")) {
-				obj->setPen((const QPen&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+/*!
+ * method setBackgroundMode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::BGMode modes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QPainter, setBackgroundMode)
+{
+  ///Qt::BGMode modes0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setBackgroundMode' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::BGMode modes0,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setBackgroundMode((Qt::BGMode) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setBackgroundMode(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setBackgroundMode
- *    flags:    
+/*!
+ * method paintEngine
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPaintEngine *
+ * @flags	c
  */
-ZEND_METHOD(QPainter, setBackgroundMode){
-		/* l public*/
 
-		/* int mode,  */
+ZEND_METHOD(QPainter, paintEngine)
+{
+  ///
+#ifdef PHP_QT_QPaintEngine      // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'paintEngine' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj->setBackgroundMode((Qt::BGMode) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast < QPaintEngine * >(selfpointer->paintEngine());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::paintEngine(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  window
- *    flags:    c
+/*!
+ * method setRenderHint
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	RenderHint hints0
+ * @param	 bool on = trues1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, window){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QRect return_object = (QRect) obj->window();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  paintEngine
- *    flags:    c
- */
-ZEND_METHOD(QPainter, paintEngine){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QPaintEngine * return_object = (QPaintEngine *) obj->paintEngine();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QPainter, setRenderHint)
+{
+// notice: unknown argument RenderHint hints0, skipped
+  php_error(E_ERROR, "could not parse argument in QPainter::setRenderHint(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setRenderHint
- *    flags:    
+/*!
+ * method strokePath
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPainterPath &paths0
+ * @param	 const QPen &pens1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setRenderHint){
-		/* ll public*/
 
-		/* QPainter::RenderHint hint, int on,  */
+ZEND_METHOD(QPainter, strokePath)
+{
+  ///const QPainterPath &paths0, const QPen &pens1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPainterPath
+#ifdef PHP_QT_QPen
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'strokePath' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPainterPath &paths0, const QPen &pens1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPainterPath *
+          cpp_arg_0 = static_cast < QPainterPath * >(php_qt_fetch(arg_0));
+        QPen *
+          cpp_arg_1 = static_cast < QPen * >(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer->strokePath((const QPainterPath &)*cpp_arg_0, (const QPen &)*cpp_arg_1));
+      }
+#endif
 
-			obj->setRenderHint((QPainter::RenderHint) Z_LVAL_P(z_0) ,(bool) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+#endif
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  brush
- *    flags:    c
- */
-ZEND_METHOD(QPainter, brush){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				const QBrush & return_object = (const QBrush &) obj->brush();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::strokePath(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  strokePath
- *    flags:    
+/*!
+ * method brush
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QBrush &
+ * @flags	c
  */
-ZEND_METHOD(QPainter, strokePath){
-		/* lo public*/
 
-		/* const QPainterPath& path, const QPen& pen,  */
+ZEND_METHOD(QPainter, brush)
+{
+  ///
+#ifdef PHP_QT_QBrush            // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'brush' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			if(obj_z_1->inherits("QPen")) {
-				obj->strokePath((const QPainterPath&) Z_LVAL_P(z_0), (const QPen&) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &const_cast < QBrush & >(selfpointer->brush());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::brush(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setBrush
- *    flags:    
+/*!
+ * method setBrush
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QBrush &brushs0
+ * 
+ * overloaded args:
+ * @param	Qt::BrushStyle style
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setBrush){
-		/* l public*/
 
-		/* int style,  */
-		/* o public*/
+ZEND_METHOD(QPainter, setBrush)
+{
+  ///const QBrush &brushs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QBrush
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setBrush' is not static");
+          RETURN_NULL();
+        }
+        /// try const QBrush &brushs0,
+        QPainter *
+          selfpointer;
 
-		/* const QBrush& brush,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QBrush *
+          cpp_arg_0 = static_cast < QBrush * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer->setBrush((const QBrush &)*cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///Qt::BrushStyle style
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setBrush' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::BrushStyle style,
+      QPainter *
+        selfpointer;
 
-			obj->setBrush((Qt::BrushStyle) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-
-
-			if(obj_z_0->inherits("QBrush")) {
-				obj->setBrush((const QBrush&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setBrush((Qt::BrushStyle) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setBrush(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPoint
- *    flags:    
+/*!
+ * method drawPoint
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF &pts0
+ * 
+ * overloaded args:
+ * @param	const QPoint &p
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPoint){
-		/* l public*/
 
-		/* const QPointF& pt,  */
+ZEND_METHOD(QPainter, drawPoint)
+{
+  ///const QPointF &pts0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPoint' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF &pts0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawPoint((const QPointF &)*cpp_arg_0));
+      }
+#endif
 
-			obj->drawPoint((const QPointF&) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-		/* ll public*/
+    }
+  }
+  ///const QPoint &p
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawPoint' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &p,
+        QPainter *
+          selfpointer;
 
-		/* int x, int y,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer->drawPoint((const QPoint &)*cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///int x, int y
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'drawPoint' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y,
+      QPainter *
+        selfpointer;
 
-			obj->drawPoint((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->drawPoint((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawPoint(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  QPainter
- *    flags:    
+/*!
+ * method QPainter
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintDevice *s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QPainter, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *QPainter_ptr = new QPainter();
-				PHP_QT_REGISTER(QPainter_ptr);
-				RETURN_NULL();
-	}
-		/* l public*/
 
-		/* qt_QPaintDevice* ,  */
+ZEND_METHOD(QPainter, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter_php_qt *
+        selfpointer = new QPainter_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QPaintDevice *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPaintDevice
+      if (inherits(Z_OBJCE_P(arg_0), 49)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QPaintDevice *s0,
+        QPaintDevice *
+          cpp_arg_0 = static_cast < QPaintDevice * >(php_qt_fetch(arg_0));
+        QPainter_php_qt *
+          selfpointer = new QPainter_php_qt(getThis(), (QPaintDevice *) cpp_arg_0);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-			QPainter *QPainter_ptr = new QPainter((QPaintDevice*) Z_LVAL_P(z_0));
-				PHP_QT_REGISTER(QPainter_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::QPainter(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setRedirected
- *    flags:    s
+/*!
+ * method setRedirected
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPaintDevice *devices0
+ * @param	 QPaintDevice *replacements1
+ * @param	 const QPoint & offset = QPoint()s2
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QPainter, setRedirected){
-		/* lll public*/
 
-		/* const QPaintDevice* device, qt_QPaintDevice* replacement, const QPoint& offset,  */
+ZEND_METHOD(QPainter, setRedirected)
+{
+  ///const QPaintDevice *devices0, QPaintDevice *replacements1, const QPoint & offset = QPoint()s2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPaintDevice
+#ifdef PHP_QT_QPaintDevice
+      if (inherits(Z_OBJCE_P(arg_0), 49) && inherits(Z_OBJCE_P(arg_1), 49)) {
+        /// try const QPaintDevice *devices0, QPaintDevice *replacements1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPaintDevice *
+          cpp_arg_0 = static_cast < QPaintDevice * >(php_qt_fetch(arg_0));
+        QPaintDevice *
+          cpp_arg_1 = static_cast < QPaintDevice * >(php_qt_fetch(arg_1));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QPainter::setRedirected((const QPaintDevice *)cpp_arg_0, (QPaintDevice *) cpp_arg_1));
+        } else {
+          RETURN_VOID(selfpointer->setRedirected((const QPaintDevice *)cpp_arg_0, (QPaintDevice *) cpp_arg_1));
+      }}
+#endif
 
-			obj->setRedirected((const QPaintDevice*) Z_LVAL_P(z_0) ,(QPaintDevice*) Z_LVAL_P(z_1) ,(const QPoint&) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-		}
-	}
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPaintDevice
+#ifdef PHP_QT_QPaintDevice
+      if (inherits(Z_OBJCE_P(arg_0), 49) && inherits(Z_OBJCE_P(arg_1), 49)) {
+        /// try const QPaintDevice *devices0, QPaintDevice *replacements1, const QPoint & offset = QPoint()s2,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPaintDevice *
+          cpp_arg_0 = static_cast < QPaintDevice * >(php_qt_fetch(arg_0));
+        QPaintDevice *
+          cpp_arg_1 = static_cast < QPaintDevice * >(php_qt_fetch(arg_1));
+        QPoint *
+          cpp_arg_2 = static_cast < QPoint * >(php_qt_fetch(arg_2));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QPainter::setRedirected((const QPaintDevice *)cpp_arg_0, (QPaintDevice *) cpp_arg_1, (const QPoint &)*cpp_arg_2));
+        } else {
+          RETURN_VOID(selfpointer->setRedirected((const QPaintDevice *)cpp_arg_0, (QPaintDevice *) cpp_arg_1, (const QPoint &)*cpp_arg_2));
+      }}
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setRedirected(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  compositionMode
- *    flags:    c
+/*!
+ * method compositionMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	CompositionMode
+ * @flags	c
  */
-ZEND_METHOD(QPainter, compositionMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QPainter::CompositionMode return_object = (QPainter::CompositionMode) obj->compositionMode();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, compositionMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type CompositionMode");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::compositionMode(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setFont
- *    flags:    
+/*!
+ * method setFont
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &fs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setFont){
-		/* o public*/
 
-		/* const QFont& f,  */
+ZEND_METHOD(QPainter, setFont)
+{
+  ///const QFont &fs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setFont' is not static");
+          RETURN_NULL();
+        }
+        /// try const QFont &fs0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QFont *
+          cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setFont((const QFont &)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QFont") {
-				obj->setFont((const QFont&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setFont(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  begin
- *    flags:    
+/*!
+ * method begin
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintDevice *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QPainter, begin){
-		/* l public*/
 
-		/* qt_QPaintDevice* ,  */
+ZEND_METHOD(QPainter, begin)
+{
+  ///QPaintDevice *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPaintDevice
+      if (inherits(Z_OBJCE_P(arg_0), 49)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'begin' is not static");
+          RETURN_NULL();
+        }
+        /// try QPaintDevice *s0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPaintDevice *
+          cpp_arg_0 = static_cast < QPaintDevice * >(php_qt_fetch(arg_0));
 
+        RETURN_BOOL(selfpointer->begin((QPaintDevice *) cpp_arg_0));
+      }
+#endif
 
-			RETURN_BOOL(obj->begin((QPaintDevice*) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::begin(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setViewport
- *    flags:    
+/*!
+ * method setViewport
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &viewports0
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setViewport){
-		/* o public*/
 
-		/* const QRect& viewport,  */
+ZEND_METHOD(QPainter, setViewport)
+{
+  ///const QRect &viewports0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setViewport' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &viewports0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setViewport((const QRect &)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRect") {
-				obj->setViewport((const QRect&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llll public*/
+    }
+  }
+  ///int x, int y, int w, int h
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setViewport' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h,
+      QPainter *
+        selfpointer;
 
-		/* int x, int y, int w, int h,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setViewport((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setViewport(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+/*!
+ * method drawEllipse
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &rs0
+ * 
+ * overloaded args:
+ * @param	const QRect &r
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QPainter, drawEllipse)
+{
+  ///const QRectF &rs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawEllipse' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rs0,
+        QPainter *
+          selfpointer;
 
-			obj->setViewport((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawEllipse((const QRectF &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///const QRect &r
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawEllipse' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &r,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawEllipse((const QRect &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///int x, int y, int w, int h
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'drawEllipse' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->drawEllipse((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawEllipse(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawEllipse
- *    flags:    
+/*!
+ * method drawArc
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &rects0
+ * @param	 int as1
+ * @param	 int alens2
+ * 
+ * overloaded args:
+ * @param	const QRect &
+ * @param	 int a
+ * @param	 int alen
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 int a
+ * @param	 int alen
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawEllipse){
-		/* o public*/
 
-		/* const QRectF& r,  */
+ZEND_METHOD(QPainter, drawArc)
+{
+  ///const QRectF &rects0, int as1, int alens2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawArc' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rects0, int as1, int alens2,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawArc((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF") {
-				obj->drawEllipse((const QRectF&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llll public*/
+    }
+  }
+  ///const QRect &, int a, int alen
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawArc' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &, int a, int alen,
+        QPainter *
+          selfpointer;
 
-		/* int x, int y, int w, int h,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer->drawArc((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
+    }
+  }
+  ///int x, int y, int w, int h, int a, int alen
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
+        && Z_TYPE_P(arg_5) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'drawArc' is not static");
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h, int a, int alen,
+      QPainter *
+        selfpointer;
 
-			obj->drawEllipse((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->
+                  drawArc((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4), (int)Z_LVAL_P(arg_5)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawArc(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawArc
- *    flags:    
+/*!
+ * method drawRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &rects0
+ * 
+ * overloaded args:
+ * @param	int x1
+ * @param	 int y1
+ * @param	 int w
+ * @param	 int h
+ * 
+ * overloaded args:
+ * @param	const QRect &rect
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawArc){
-		/* oll public*/
 
-		/* const QRectF& rect, int a, int alen,  */
+ZEND_METHOD(QPainter, drawRect)
+{
+  ///const QRectF &rects0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRectF &rects0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawRect((const QRectF &)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF") {
-				obj->drawArc((const QRectF&) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QRect") {
-				obj->drawArc((const QRect&) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllll public*/
+    }
+  }
+  ///int x1, int y1, int w, int h
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'drawRect' is not static");
+        RETURN_NULL();
+      }
+      /// try int x1, int y1, int w, int h,
+      QPainter *
+        selfpointer;
 
-		/* int x, int y, int w, int h, int a, int alen,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->drawRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  ///const QRect &rect
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawRect' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &rect,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 6){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzzz", &z_0, &z_1, &z_2, &z_3, &z_4, &z_5) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_LONG && Z_TYPE_P(z_5) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawRect((const QRect &)*cpp_arg_0));
+      }
+#endif
 
-			obj->drawArc((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3) ,(int) Z_LVAL_P(z_4) ,(int) Z_LVAL_P(z_5));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawRect(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setBackground
- *    flags:    
+/*!
+ * method setBackground
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QBrush &bgs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setBackground){
-		/* o public*/
 
-		/* const QBrush& bg,  */
+ZEND_METHOD(QPainter, setBackground)
+{
+  ///const QBrush &bgs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QBrush
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setBackground' is not static");
+          RETURN_NULL();
+        }
+        /// try const QBrush &bgs0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QBrush *
+          cpp_arg_0 = static_cast < QBrush * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->setBackground((const QBrush &)*cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0->inherits("QBrush")) {
-				obj->setBackground((const QBrush&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setBackground(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  isActive
- *    flags:    c
+/*!
+ * method isActive
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QPainter, isActive){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isActive());
-	}
+
+ZEND_METHOD(QPainter, isActive)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isActive' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isActive());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::isActive(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawRect
- *    flags:    
+/*!
+ * method drawLines
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QLineF *liness0
+ * @param	 int lineCounts1
+ * 
+ * overloaded args:
+ * @param	const QVector<QLineF> &lines
+ * 
+ * overloaded args:
+ * @param	const QPointF *pointPairs
+ * @param	 int lineCount
+ * 
+ * overloaded args:
+ * @param	const QVector<QPointF> &pointPairs
+ * 
+ * overloaded args:
+ * @param	const QLine *lines
+ * @param	 int lineCount
+ * 
+ * overloaded args:
+ * @param	const QVector<QLine> &lines
+ * 
+ * overloaded args:
+ * @param	const QPoint *pointPairs
+ * @param	 int lineCount
+ * 
+ * overloaded args:
+ * @param	const QVector<QPoint> &pointPairs
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawRect){
-		/* o public*/
 
-		/* const QRectF& rect,  */
+ZEND_METHOD(QPainter, drawLines)
+{
+  ///const QLineF *liness0, int lineCounts1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLineF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawLines' is not static");
+          RETURN_NULL();
+        }
+        /// try const QLineF *liness0, int lineCounts1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QLineF *
+          cpp_arg_0 = static_cast < QLineF * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawLines((const QLineF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRectF") {
-				obj->drawRect((const QRectF&) obj_z_0);
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QRect") {
-				obj->drawRect((const QRect&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llll public*/
+    }
+  }
+  ///const QVector<QLineF> &lines
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVector
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawLines' is not static");
+          RETURN_NULL();
+        }
+        /// try const QVector<QLineF> &lines,
+        QPainter *
+          selfpointer;
 
-		/* int x1, int y1, int w, int h,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QVector < QLineF > *cpp_arg_0 = static_cast < QVector < QLineF > *>(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer->drawLines((const QVector < QLineF > &)*cpp_arg_0));
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+    }
+  }
+  ///const QPointF *pointPairs, int lineCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawLines' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF *pointPairs, int lineCount,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
 
-			obj->drawRect((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+        RETURN_VOID(selfpointer->drawLines((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawLines
- *    flags:    
- */
-ZEND_METHOD(QPainter, drawLines){
-		/* ol public*/
+    }
+  }
+  ///const QVector<QPointF> &pointPairs
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVector
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawLines' is not static");
+          RETURN_NULL();
+        }
+        /// try const QVector<QPointF> &pointPairs,
+        QPainter *
+          selfpointer;
 
-		/* const QLineF* lines, int lineCount,  */
-		/* ll public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QVector < QPointF > *cpp_arg_0 = static_cast < QVector < QPointF > *>(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer->drawLines((const QVector < QPointF > &)*cpp_arg_0));
+      }
+#endif
 
-		/* const QPointF* pointPairs, int lineCount,  */
+    }
+  }
+  ///const QLine *lines, int lineCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLine
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawLines' is not static");
+          RETURN_NULL();
+        }
+        /// try const QLine *lines, int lineCount,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QLine *
+          cpp_arg_0 = static_cast < QLine * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->drawLines((const QLine *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			if(obj_z_0->inherits("QLineF")) {
-				obj->drawLines((const QLineF*) obj_z_0, (int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			if(obj_z_0->inherits("QLine")) {
-				obj->drawLines((const QLine*) obj_z_0, (int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+    }
+  }
+  ///const QVector<QLine> &lines
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVector
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawLines' is not static");
+          RETURN_NULL();
+        }
+        /// try const QVector<QLine> &lines,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QVector < QLine > *cpp_arg_0 = static_cast < QVector < QLine > *>(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer->drawLines((const QVector < QLine > &)*cpp_arg_0));
+      }
+#endif
 
-			obj->drawLines((const QPointF*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  ///const QPoint *pointPairs, int lineCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawLines' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint *pointPairs, int lineCount,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->drawLines((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QVector<QPoint> &pointPairs
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVector
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawLines' is not static");
+          RETURN_NULL();
+        }
+        /// try const QVector<QPoint> &pointPairs,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QVector < QPoint > *cpp_arg_0 = static_cast < QVector < QPoint > *>(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer->drawLines((const QVector < QPoint > &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawLines(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  renderHints
- *    flags:    c
+/*!
+ * method renderHints
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	RenderHints
+ * @flags	c
  */
-ZEND_METHOD(QPainter, renderHints){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			obj->renderHints();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  backgroundMode
- *    flags:    c
- */
-ZEND_METHOD(QPainter, backgroundMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_LONG(obj->backgroundMode());
-	}
+ZEND_METHOD(QPainter, renderHints)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type RenderHints");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::renderHints(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  redirected
- *    flags:    s
+/*!
+ * method backgroundMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::BGMode
+ * @flags	c
  */
-ZEND_METHOD(QPainter, redirected){
-		/* ll public*/
 
-		/* const QPaintDevice* device, qt_QPoint* offset,  */
+ZEND_METHOD(QPainter, backgroundMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'backgroundMode' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->backgroundMode());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::backgroundMode(...) ");
+}
 
+/*!
+ * method redirected
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPaintDevice *devices0
+ * @param	 QPoint *offset = 0s1
+ * 
+ * @access	public
+ * @return	QPaintDevice *
+ * @flags	s
+ */
 
-				QPaintDevice * return_object = (QPaintDevice *) obj->redirected((const QPaintDevice*) Z_LVAL_P(z_0) ,(QPoint*) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+ZEND_METHOD(QPainter, redirected)
+{
+// notice: abstract class QPaintDevice cannot be instanciated, skipped
+  php_error(E_ERROR, "could not parse argument in QPainter::redirected(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  hasClipping
- *    flags:    c
+/*!
+ * method hasClipping
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QPainter, hasClipping){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->hasClipping());
-	}
+
+ZEND_METHOD(QPainter, hasClipping)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hasClipping' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->hasClipping());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::hasClipping(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawTextItem
- *    flags:    
+/*!
+ * method drawTextItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF &ps0
+ * @param	 const QTextItem &tis1
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 const QTextItem &ti
+ * 
+ * overloaded args:
+ * @param	const QPoint &p
+ * @param	 const QTextItem &ti
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawTextItem){
-		/* lo public*/
 
-		/* const QPointF& p, const QTextItem& ti,  */
+ZEND_METHOD(QPainter, drawTextItem)
+{
+  ///const QPointF &ps0, const QTextItem &tis1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QTextItem
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawTextItem' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPointF &ps0, const QTextItem &tis1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
+        QTextItem *
+          cpp_arg_1 = static_cast < QTextItem * >(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer->drawTextItem((const QPointF &)*cpp_arg_0, (const QTextItem &)*cpp_arg_1));
+      }
+#endif
 
-			if(obj_z_1->inherits("QTextItem")) {
-				obj->drawTextItem((const QPointF&) Z_LVAL_P(z_0), (const QTextItem&) obj_z_1);
-			RETURN_NULL();
-			}
-			if(obj_z_1->inherits("QTextItem")) {
-				obj->drawTextItem((const QPoint&) Z_LVAL_P(z_0), (const QTextItem&) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llo public*/
+#endif
 
-		/* int x, int y, const QTextItem& ti,  */
+    }
+  }
+  ///int x, int y, const QTextItem &ti
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QTextItem
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawTextItem' is not static");
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QTextItem &ti,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QTextItem *
+          cpp_arg_2 = static_cast < QTextItem * >(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer->drawTextItem((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QTextItem &)*cpp_arg_2));
+      }
+#endif
 
-			if(obj_z_2->inherits("QTextItem")) {
-				obj->drawTextItem((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QTextItem&) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-}
+    }
+  }
+  ///const QPoint &p, const QTextItem &ti
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QTextItem
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'drawTextItem' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &p, const QTextItem &ti,
+        QPainter *
+          selfpointer;
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setClipping
- *    flags:    
- */
-ZEND_METHOD(QPainter, setClipping){
-		/* l public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QTextItem *
+          cpp_arg_1 = static_cast < QTextItem * >(php_qt_fetch(arg_1));
 
-		/* int enable,  */
+        RETURN_VOID(selfpointer->drawTextItem((const QPoint &)*cpp_arg_0, (const QTextItem &)*cpp_arg_1));
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+#endif
 
-
-			obj->setClipping((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::drawTextItem(...) ");
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  clipPath
- *    flags:    c
+/*!
+ * method setClipping
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enables0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, clipPath){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			obj->clipPath();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QPainter, setClipping)
+{
+  ///bool enables0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setClipping' is not static");
+        RETURN_NULL();
+      }
+      /// try bool enables0,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setClipping((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPainter::setClipping(...) ");
 }
 
+/*!
+ * method clipPath
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPainterPath
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QPainter);
+ZEND_METHOD(QPainter, clipPath)
+{
+  ///
+#ifdef PHP_QT_QPainterPath      // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'clipPath' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QPainterPath *
+        return_object = new QPainterPath;
+
+      *return_object = static_cast < QPainterPath > (selfpointer->clipPath());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPainter::clipPath(...) ");
+}

Modified: trunk/qt/classes/qpaintevent.cpp
===================================================================
--- trunk/qt/classes/qpaintevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qpaintevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,55 +19,187 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QPaintEvent.cpp - QPaintEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QPaintEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QPaintEvent */
-/*
- *    function  rect
- *    flags:    c
+#include <QPaintEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QPaintEvent_php_qt:public QPaintEvent
+{
+
+public:
+  QPaintEvent_php_qt(zval * zend_ptr, const QRegion & paintRegions0);
+    QPaintEvent_php_qt(zval * zend_ptr, const QRect & paintRects0);
+
+
+  zval *zend_ptr;
+};
+QPaintEvent_php_qt::QPaintEvent_php_qt(zval * zend_ptr, const QRegion & paintRegions0):
+QPaintEvent(paintRegions0)
+{
+  this->zend_ptr = zend_ptr;
+}
+QPaintEvent_php_qt::QPaintEvent_php_qt(zval * zend_ptr, const QRect & paintRects0):
+QPaintEvent(paintRects0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method region
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QRegion &
+ * @flags	c
  */
-ZEND_METHOD(QPaintEvent, rect){
-	if (ZEND_NUM_ARGS() == 0){
-			QPaintEvent *obj = (QPaintEvent*) PHP_QT_FETCH();
-				const QRect & return_object = (const QRect &) obj->rect();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPaintEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPaintEvent, region)
+{
+  ///
+#ifdef PHP_QT_QRegion           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'region' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPaintEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPaintEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QRegion & >(selfpointer->region());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPaintEvent::region(...) ");
 }
 
-/*********************************
- *    class     QPaintEvent */
-/*
- *    function  region
- *    flags:    c
+/*!
+ * method QPaintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRegion & paintRegions0s0
+ * 
+ * overloaded args:
+ * @param	const QRect &paintRects0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QPaintEvent, region){
-	if (ZEND_NUM_ARGS() == 0){
-			QPaintEvent *obj = (QPaintEvent*) PHP_QT_FETCH();
-				const QRegion & return_object = (const QRegion &) obj->region();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPaintEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPaintEvent, __construct)
+{
+  ///const QRegion & paintRegions0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegion
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegion & paintRegions0s0,
+        QRegion *cpp_arg_0 = static_cast < QRegion * >(php_qt_fetch(arg_0));
+        QPaintEvent_php_qt *selfpointer = new QPaintEvent_php_qt(getThis(), (const QRegion &)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QRect &paintRects0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &paintRects0,
+        QRect *cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+        QPaintEvent_php_qt *selfpointer = new QPaintEvent_php_qt(getThis(), (const QRect &)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPaintEvent::QPaintEvent(...) ");
 }
 
+/*!
+ * method rect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QRect &
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QPaintEvent);
+ZEND_METHOD(QPaintEvent, rect)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'rect' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPaintEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPaintEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QRect & >(selfpointer->rect());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPaintEvent::rect(...) ");
+}

Modified: trunk/qt/classes/qpushbutton.cpp
===================================================================
--- trunk/qt/classes/qpushbutton.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qpushbutton.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,439 +19,918 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QPushButton.cpp - QPushButton PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QPushButton>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  tr
- *    flags:    s
- */
-ZEND_METHOD(QPushButton, tr){
-		/* ss public*/
+#include <QPushButton>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QPushButton_php_qt:public QPushButton
+{
 
-		/* const char* , const char* ,  */
+public:
+  QPushButton_php_qt(zval * zend_ptr, QWidget * parent = 0);
+  QPushButton_php_qt(zval * zend_ptr, const QString & texts0, QWidget * parent = 0);
+    QPushButton_php_qt(zval * zend_ptr, const QIcon & icons0, const QString & texts1, QWidget * parent = 0);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
 
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
-				QString return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPushButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+QPushButton_php_qt::QPushButton_php_qt(zval * zend_ptr, QWidget * parent):QPushButton(parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QPushButton",&staticMetaObject));
 }
-
-/*********************************
- *    class     QPushButton */
-/*
- *    function  showMenu
- *    flags:    l
- */
-ZEND_METHOD(QPushButton, showMenu){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-			obj->showMenu();
-			RETURN_NULL();
-	}
+QPushButton_php_qt::QPushButton_php_qt(zval * zend_ptr, const QString & texts0, QWidget * parent):
+QPushButton(texts0, parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QPushButton",&staticMetaObject));
 }
+QPushButton_php_qt::QPushButton_php_qt(zval * zend_ptr, const QIcon & icons0, const QString & texts1, QWidget * parent):
+QPushButton(icons0, texts1, parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QPushButton",&staticMetaObject));
+}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  setFlat
- *    flags:    
+PHP_QT_MOC(QPushButton);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QPushButton, setFlat){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QPushButton, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QPushButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setFlat((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  qt_invoke
- *    flags:    v
- */
-ZEND_METHOD(QPushButton, qt_invoke){
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QPushButton::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QPushButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QPushButton::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPushButton::tr(...) ");
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QPushButton, staticMetaObject){
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QPushButton, qObject){
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  isDefault
- *    flags:    c
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QPushButton, isDefault){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isDefault());
-	}
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  setAutoDefault
- *    flags:    
+/*!
+ * method QPushButton
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parent=0s0
+ * 
+ * overloaded args:
+ * @param	const QString &texts0
+ * @param	 QWidget  *parent=0
+ * 
+ * overloaded args:
+ * @param	const QIcon & icons0
+ * @param	const QString &texts1
+ * @param	 QWidget *parent=0
+ * 
+ * overloaded args:
+ * @param	const QPushButton &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QPushButton, setAutoDefault){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QPushButton, __construct)
+{
+  ///QWidget *parent=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton_php_qt *selfpointer = new QPushButton_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget *parent=0s0,
+      QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QPushButton_php_qt *selfpointer = new QPushButton_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QString &texts0, QWidget  *parent=0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-			obj->setAutoDefault((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &texts0,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QPushButton_php_qt *selfpointer = new QPushButton_php_qt(getThis(), (const QString &)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &texts0, QWidget  *parent=0,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QWidget *cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+        QPushButton_php_qt *selfpointer = new QPushButton_php_qt(getThis(), (const QString &)*cpp_arg_0, (QWidget *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QIcon & icons0,const QString &texts1, QWidget *parent=0
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QIcon
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QIcon & icons0,const QString &texts1,
+        QIcon *cpp_arg_0 = static_cast < QIcon * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        QPushButton_php_qt *selfpointer = new QPushButton_php_qt(getThis(), (const QIcon &)*cpp_arg_0, (const QString &)*cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_1 = invokeToQString(arg_1);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QIcon
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QIcon & icons0,const QString &texts1, QWidget *parent=0,
+        QIcon *cpp_arg_0 = static_cast < QIcon * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        QWidget *cpp_arg_2 = static_cast < QWidget * >(php_qt_fetch(arg_2));
+        QPushButton_php_qt *selfpointer = new QPushButton_php_qt(getThis(), (const QIcon &)*cpp_arg_0, (const QString &)*cpp_arg_1, (QWidget *) cpp_arg_2);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QPushButton &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPushButton
+      if (inherits(Z_OBJCE_P(arg_0), 52)) {
+/// method is private, skip
+        php_error(E_ERROR, "QPushButton::__construct(...) cannot be called with 'const QPushButton &,'.");
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPushButton::QPushButton(...) ");
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QPushButton, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj->sizeHint();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPushButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QPushButton, qt_cast){
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  metaObject
- *    flags:    cv
+/*!
+ * method autoDefault
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QPushButton, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-				QMetaObject * return_object = (QMetaObject *) obj->metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPushButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPushButton, autoDefault)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'autoDefault' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->autoDefault());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPushButton::autoDefault(...) ");
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  menu
- *    flags:    c
+/*!
+ * method setMenu
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMenu * menus0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPushButton, menu){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-				QMenu* return_object = (QMenu*) obj->menu();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPushButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPushButton, setMenu)
+{
+  ///QMenu * menus0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QMenu
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setMenu' is not static");
+          RETURN_NULL();
+        }
+        /// try QMenu * menus0,
+        QPushButton *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+        }
+        QMenu *cpp_arg_0 = static_cast < QMenu * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setMenu((QMenu *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPushButton::setMenu(...) ");
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  setDefault
- *    flags:    
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QPushButton, setDefault){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QPushButton, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QPushButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->setDefault((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QPushButton::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPushButton::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QPushButton, qt_emit){
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  QPushButton
- *    flags:    t
+/*!
+ * method isDefault
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QPushButton, __construct){
-		/* o public*/
 
-		/* qt_QWidget* parent,  */
+ZEND_METHOD(QPushButton, isDefault)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isDefault' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isDefault());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPushButton::isDefault(...) ");
+}
 
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-			if(obj_z_0->inherits("QWidget")) {
-				QPushButton *QPushButton_ptr = new QPushButton((QWidget*) obj_z_0);
-				PHP_QT_REGISTER(QPushButton_ptr);
-				RETURN_NULL();
-			}
-			} else if(Z_TYPE_P(z_0) == IS_STRING) { 
-				QPushButton *QPushButton_ptr = new QPushButton((const char*) Z_STRVAL_P(z_0));
-				PHP_QT_REGISTER(QPushButton_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
-		/* oo public*/
+/*!
+ * method setFlat
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-		/* const QString& text, qt_QWidget* parent,  */
+ZEND_METHOD(QPushButton, setFlat)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setFlat' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QPushButton *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setFlat((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPushButton::setFlat(...) ");
+}
 
-			if(!(strcmp(Z_OBJCE_P(z_0)->name,"QString")) && obj_z_1->inherits("QWidget")) {
-				QPushButton *QPushButton_ptr = new QPushButton((const QString&) obj_z_0, (QWidget*) obj_z_1);
-				PHP_QT_REGISTER(QPushButton_ptr);
-				RETURN_NULL();
-			} 
-			} else if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_OBJECT){
+/*!
+ * method focusOutEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-			  QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+/*!
+ * method setDefault
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			if(obj_z_1->inherits("QWidget")) {
-				QPushButton *QPushButton_ptr = new QPushButton((const char*) Z_STRVAL_P(z_0), (QWidget*) obj_z_1);
-				PHP_QT_REGISTER(QPushButton_ptr);
-				RETURN_NULL();
-			} 
-			}
-		}
-	}
-		/* ooo public*/
+ZEND_METHOD(QPushButton, setDefault)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setDefault' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QPushButton *selfpointer;
 
-		/* const QIcon& icon, const QString& text, qt_QWidget* parent,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setDefault((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPushButton::setDefault(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
+/*!
+ * method showMenu
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
 
-			if(obj_z_0->inherits("QIcon") && Z_OBJCE_P(z_1)->name == "QString" && obj_z_2->inherits("QWidget")) {
-				QPushButton *QPushButton_ptr = new QPushButton((const QIcon&) obj_z_0, (const QString&) obj_z_1, (QWidget*) obj_z_2);
-				PHP_QT_REGISTER(QPushButton_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QPushButton, showMenu)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'showMenu' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->showMenu());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPushButton::showMenu(...) ");
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method setAutoDefault
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPushButton, className){
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  autoDefault
- *    flags:    c
- */
-ZEND_METHOD(QPushButton, autoDefault){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->autoDefault());
-	}
+ZEND_METHOD(QPushButton, setAutoDefault)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setAutoDefault' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QPushButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setAutoDefault((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPushButton::setAutoDefault(...) ");
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QPushButton, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QPushButton, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPushButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPushButton::sizeHint(...) ");
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  isFlat
- *    flags:    c
+/*!
+ * method keyPressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPushButton, isFlat){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isFlat());
-	}
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method menu
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMenu*
+ * @flags	c
  */
-ZEND_METHOD(QPushButton, qt_property){
+
+ZEND_METHOD(QPushButton, menu)
+{
+  ///
+#ifdef PHP_QT_QMenu             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'menu' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QMenu * >(selfpointer->menu());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPushButton::menu(...) ");
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  setMenu
- *    flags:    
+/*!
+ * method focusInEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPushButton, setMenu){
-		/* o public*/
 
-		/* QMenu* menu,  */
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QPushButton, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QPushButton *selfpointer;
 
-			if(obj_z_0->inherits("QMenu")) {
-				obj->setMenu((QMenu*) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QPushButton::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QPushButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QPushButton::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QPushButton::trUtf8(...) ");
 }
 
+/*!
+ * method isFlat
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QPushButton);
+ZEND_METHOD(QPushButton, isFlat)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isFlat' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QPushButton * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isFlat());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QPushButton::isFlat(...) ");
+}

Modified: trunk/qt/classes/qresizeevent.cpp
===================================================================
--- trunk/qt/classes/qresizeevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qresizeevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,55 +19,162 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QResizeEvent.cpp - QResizeEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QResizeEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QResizeEvent */
-/*
- *    function  oldSize
- *    flags:    c
+#include <QResizeEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QResizeEvent_php_qt:public QResizeEvent
+{
+
+public:
+  QResizeEvent_php_qt(zval * zend_ptr, const QSize & sizes0, const QSize & oldSizes1);
+
+
+  zval *zend_ptr;
+};
+QResizeEvent_php_qt::QResizeEvent_php_qt(zval * zend_ptr, const QSize & sizes0, const QSize & oldSizes1):
+QResizeEvent(sizes0, oldSizes1)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QResizeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &sizes0s0
+ * @param	const QSize &oldSizes1s1
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QResizeEvent, oldSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QResizeEvent *obj = (QResizeEvent*) PHP_QT_FETCH();
-				const QSize & return_object = (const QSize &) obj->oldSize();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QResizeEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QResizeEvent, __construct)
+{
+  ///const QSize &sizes0s0,const QSize &oldSizes1s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QSize &sizes0s0,const QSize &oldSizes1s1,
+        QSize *cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));
+        QSize *cpp_arg_1 = static_cast < QSize * >(php_qt_fetch(arg_1));
+        QResizeEvent_php_qt *selfpointer = new QResizeEvent_php_qt(getThis(), (const QSize &)*cpp_arg_0, (const QSize &)*cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QResizeEvent::QResizeEvent(...) ");
 }
 
-/*********************************
- *    class     QResizeEvent */
-/*
- *    function  size
- *    flags:    c
+/*!
+ * method size
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QSize &
+ * @flags	c
  */
-ZEND_METHOD(QResizeEvent, size){
-	if (ZEND_NUM_ARGS() == 0){
-			QResizeEvent *obj = (QResizeEvent*) PHP_QT_FETCH();
-				const QSize & return_object = (const QSize &) obj->size();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QResizeEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QResizeEvent, size)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'size' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QResizeEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QResizeEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QSize & >(selfpointer->size());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QResizeEvent::size(...) ");
 }
 
+/*!
+ * method oldSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QSize &
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QResizeEvent);
+ZEND_METHOD(QResizeEvent, oldSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'oldSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QResizeEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QResizeEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QSize & >(selfpointer->oldSize());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QResizeEvent::oldSize(...) ");
+}

Modified: trunk/qt/classes/qshortcutevent.cpp
===================================================================
--- trunk/qt/classes/qshortcutevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qshortcutevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,62 +19,201 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QShortcutEvent.cpp - QShortcutEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QShortcutEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QShortcutEvent */
-/*
- *    function  shortcutId
- *    flags:    
+#include <QShortcutEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QShortcutEvent_php_qt:public QShortcutEvent
+{
+
+public:
+  QShortcutEvent_php_qt(zval * zend_ptr, const QKeySequence & keys0, int ids1, bool ambiguous = false);
+
+
+  zval *zend_ptr;
+};
+QShortcutEvent_php_qt::QShortcutEvent_php_qt(zval * zend_ptr, const QKeySequence & keys0, int ids1, bool ambiguous):
+QShortcutEvent(keys0, ids1, ambiguous)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method key
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QKeySequence &
+ * @flags	
  */
-ZEND_METHOD(QShortcutEvent, shortcutId){
-	if (ZEND_NUM_ARGS() == 0){
-			QShortcutEvent *obj = (QShortcutEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->shortcutId());
-	}
+
+ZEND_METHOD(QShortcutEvent, key)
+{
+  ///
+#ifdef PHP_QT_QKeySequence      // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'key' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QShortcutEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QShortcutEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QKeySequence & >(selfpointer->key());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QShortcutEvent::key(...) ");
 }
 
-/*********************************
- *    class     QShortcutEvent */
-/*
- *    function  isAmbiguous
- *    flags:    
+/*!
+ * method shortcutId
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	
  */
-ZEND_METHOD(QShortcutEvent, isAmbiguous){
-	if (ZEND_NUM_ARGS() == 0){
-			QShortcutEvent *obj = (QShortcutEvent*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isAmbiguous());
-	}
+
+ZEND_METHOD(QShortcutEvent, shortcutId)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'shortcutId' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QShortcutEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QShortcutEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->shortcutId());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QShortcutEvent::shortcutId(...) ");
 }
 
-/*********************************
- *    class     QShortcutEvent */
-/*
- *    function  key
- *    flags:    
+/*!
+ * method isAmbiguous
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QShortcutEvent, key){
-	if (ZEND_NUM_ARGS() == 0){
-			QShortcutEvent *obj = (QShortcutEvent*) PHP_QT_FETCH();
-				const QKeySequence & return_object = (const QKeySequence &) obj->key();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QShortcutEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QShortcutEvent, isAmbiguous)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isAmbiguous' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QShortcutEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QShortcutEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isAmbiguous());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QShortcutEvent::isAmbiguous(...) ");
 }
 
+/*!
+ * method QShortcutEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QKeySequence &keys0s0
+ * @param	int ids1s1
+ * @param	 bool ambiguous = falses2
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QShortcutEvent);
+ZEND_METHOD(QShortcutEvent, __construct)
+{
+  ///const QKeySequence &keys0s0,int ids1s1, bool ambiguous = falses2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QKeySequence
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QKeySequence &keys0s0,int ids1s1,
+        QKeySequence *cpp_arg_0 = static_cast < QKeySequence * >(php_qt_fetch(arg_0));
+        QShortcutEvent_php_qt *selfpointer = new QShortcutEvent_php_qt(getThis(), (const QKeySequence &)*cpp_arg_0, (int)Z_LVAL_P(arg_1));
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_BOOL) {
+#ifdef PHP_QT_QKeySequence
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QKeySequence &keys0s0,int ids1s1, bool ambiguous = falses2,
+        QKeySequence *cpp_arg_0 = static_cast < QKeySequence * >(php_qt_fetch(arg_0));
+        QShortcutEvent_php_qt *selfpointer =
+          new QShortcutEvent_php_qt(getThis(), (const QKeySequence &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (bool) Z_LVAL_P(arg_2));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QShortcutEvent::QShortcutEvent(...) ");
+}

Modified: trunk/qt/classes/qshowevent.cpp
===================================================================
--- trunk/qt/classes/qshowevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qshowevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,62 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QShowEvent.cpp - QShowEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QShowEvent>
 #include "../php_qt.h"
 
 
+#include <QShowEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QShowEvent_php_qt:public QShowEvent
+{
 
-PHP_QT_DESTRUCT(QShowEvent);
+public:
+  QShowEvent_php_qt(zval * zend_ptr);
 
+
+  zval *zend_ptr;
+};
+
+QShowEvent_php_qt::QShowEvent_php_qt(zval * zend_ptr):QShowEvent()
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QShowEvent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QShowEvent, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QShowEvent_php_qt *
+        selfpointer = new QShowEvent_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QShowEvent::QShowEvent(...) ");
+}

Modified: trunk/qt/classes/qslider.cpp
===================================================================
--- trunk/qt/classes/qslider.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qslider.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,391 +19,750 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QSlider.cpp - QSlider PHP implementation.
- * begin           : Thu Feb 23 10:18:44 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
+
 #include "../php_qt.h"
 
 
 #include <QSlider>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QSlider_php_qt:public QSlider
+{
 
+public:
+  QSlider_php_qt(zval * zend_ptr, QWidget * parent = 0);
+  QSlider_php_qt(zval * zend_ptr, Qt::Orientation orientations0, QWidget * parent = 0);
 
-/*		public enumTickPosition:long {
-			NoTicks = 0,
-			TicksAbove = 1,
-			TicksLeft = TicksAbove,
-			TicksBelow = 2,
-			TicksRight = TicksBelow,
-			TicksBothSides = 3
-		}
-*/
-/*********************************
- *    class     QSlider */
-/*
- *    function  tr
- *    flags:    s
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+
+QSlider_php_qt::QSlider_php_qt(zval * zend_ptr, QWidget * parent):QSlider(parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QSlider",&staticMetaObject));
+}
+
+QSlider_php_qt::QSlider_php_qt(zval * zend_ptr, Qt::Orientation orientations0, QWidget * parent):QSlider(orientations0, parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QSlider",&staticMetaObject));
+}
+
+PHP_QT_MOC(QSlider);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QSlider, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QSlider, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QSlider *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSlider * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QSlider::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  qt_invoke
- *    flags:    v
- */
-ZEND_METHOD(QSlider, qt_invoke){
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QSlider::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSlider * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QSlider::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QSlider::tr(...) ");
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method mouseMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *evs0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSlider, staticMetaObject){
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QSlider, qObject){
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  QSlider
- *    flags:    t
+/*!
+ * method QSlider
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parent = 0s0
+ * 
+ * overloaded args:
+ * @param	Qt::Orientation orientations0
+ * @param	 QWidget *parent = 0
+ * 
+ * overloaded args:
+ * @param	const QSlider &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QSlider, __construct){
-		/* o public*/
 
-		/* qt_QWidget* parent,  */
+ZEND_METHOD(QSlider, __construct)
+{
+  ///QWidget *parent = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QSlider_php_qt *
+        selfpointer = new QSlider_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget *parent = 0s0,
+      QWidget *
+        cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QSlider_php_qt *
+        selfpointer = new QSlider_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///Qt::Orientation orientations0, QWidget *parent = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::Orientation orientations0,
+      QSlider_php_qt *
+        selfpointer = new QSlider_php_qt(getThis(), (Qt::Orientation) Z_LVAL_P(arg_0));
 
-			if(obj_z_0->inherits("QWidget")) {
-				QSlider *QSlider_ptr = new QSlider((QWidget*) obj_z_0);
-				PHP_QT_REGISTER(QSlider_ptr);
-				RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
-		/* lo public*/
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::Orientation orientations0, QWidget *parent = 0,
+      QWidget *
+        cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+      QSlider_php_qt *
+        selfpointer = new QSlider_php_qt(getThis(), (Qt::Orientation) Z_LVAL_P(arg_0), (QWidget *) cpp_arg_1);
 
-		/* int orientation, qt_QWidget* parent,  */
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QSlider &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSlider
+      if (inherits(Z_OBJCE_P(arg_0), 56)) {
+/// method is private, skip
+        php_error(E_ERROR, "QSlider::__construct(...) cannot be called with 'const QSlider &,'.");
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-
-
-			if(obj_z_1->inherits("QWidget")) {
-				QSlider *QSlider_ptr = new QSlider((Qt::Orientation) Z_LVAL_P(z_0), (QWidget*) obj_z_1);
-				PHP_QT_REGISTER(QSlider_ptr);
-				RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QSlider::QSlider(...) ");
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  minimumSizeHint
- *    flags:    c
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QSlider, minimumSizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
-			QSize* return_object = new QSize;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->minimumSizeHint();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QSlider, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
-			QSize* return_object = new QSize;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QSize) obj->sizeHint();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method setTickInterval
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int tis0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSlider, qt_cast){
+
+ZEND_METHOD(QSlider, setTickInterval)
+{
+  ///int tis0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setTickInterval' is not static");
+        RETURN_NULL();
+      }
+      /// try int tis0,
+      QSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setTickInterval((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QSlider::setTickInterval(...) ");
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  metaObject
- *    flags:    cv
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QSlider, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
-			QMetaObject ** return_object = new QMetaObject *;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QMetaObject *) obj->metaObject();
-			} else {
-				php_error(E_ERROR,"Object not found");
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  tickInterval
- *    flags:    c
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QSlider, tickInterval){
-	if (ZEND_NUM_ARGS() == 0){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj->tickInterval());
-	}
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  setTickInterval
- *    flags:    
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QSlider, setTickInterval){
-		/* l public*/
 
-		/* int ti,  */
+ZEND_METHOD(QSlider, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QSlider *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSlider * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj->setTickInterval((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QSlider::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QSlider::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  tickPosition
- *    flags:    c
+/*!
+ * method mouseReleaseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *evs0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSlider, tickPosition){
-	if (ZEND_NUM_ARGS() == 0){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
-			obj->tickPosition();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QSlider, qt_emit){
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  event
- *    flags:    
+/*!
+ * method minimumSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QSlider, event){
-		/* o public*/
 
-		/* qt_QEvent* event,  */
+ZEND_METHOD(QSlider, minimumSizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumSizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QSlider *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSlider * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			if(!strcmp(Z_OBJCE_P(z_0)->name,"QEvent")) {
-				RETURN_BOOL(obj->event((QEvent*) obj_z_0));
-			}
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->minimumSizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QSlider::minimumSizeHint(...) ");
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QSlider, className){
+
+/*!
+ * method tickInterval
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QSlider, tickInterval)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'tickInterval' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSlider * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->tickInterval());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QSlider::tickInterval(...) ");
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  setTickPosition
- *    flags:    
+/*!
+ * method tickPosition
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	TickPosition
+ * @flags	c
  */
-ZEND_METHOD(QSlider, setTickPosition){
-		/* l public*/
 
-		/* int position,  */
+ZEND_METHOD(QSlider, tickPosition)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type TickPosition");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QSlider::tickPosition(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *events0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
 
+ZEND_METHOD(QSlider, event)
+{
+  ///QEvent *events0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 21)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'event' is not static");
+          RETURN_NULL();
+        }
+        /// try QEvent *events0,
+        QSlider *
+          selfpointer;
 
-			obj->setTickPosition((QSlider::TickPosition) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QSlider * >(PHP_QT_FETCH());
+        }
+        QEvent *
+          cpp_arg_0 = static_cast < QEvent * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->event((QEvent *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QSlider::event(...) ");
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *evs0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSlider, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+/*!
+ * method mousePressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *evs0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
+ */
 
+ZEND_METHOD(QSlider, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QSlider::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSlider * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QSlider::sizeHint(...) ");
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method setTickPosition
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	TickPosition positions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSlider, qt_property){
+
+ZEND_METHOD(QSlider, setTickPosition)
+{
+// notice: unknown argument TickPosition positions0, skipped
+  php_error(E_ERROR, "could not parse argument in QSlider::setTickPosition(...) ");
 }
 
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
 
-PHP_QT_DESTRUCT(QSlider);
+ZEND_METHOD(QSlider, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSlider * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QSlider::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSlider * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QSlider::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QSlider::trUtf8(...) ");
+}

Modified: trunk/qt/classes/qspaceritem.cpp
===================================================================
--- trunk/qt/classes/qspaceritem.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qspaceritem.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,236 +19,501 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QSpacerItem.cpp - QSpacerItem PHP implementation.
- * begin           : Wed Jan 11 20:29:53 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QSpacerItem>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  changeSize
- *    flags:    
- */
-ZEND_METHOD(QSpacerItem, changeSize){
+#include <QSpacerItem>
+#include <QMetaMethod>
+class QSpacerItem_php_qt:public QSpacerItem
+{
 
-	if (ZEND_NUM_ARGS() == 4){
-		/* lloo */
-		long var_lloo_0;    // default: 
-		long var_lloo_1;    // default: 
-		zval* z_var_lloo_2;   // default: QSizePolicy::Minimum
-		zval* z_var_lloo_3;   // default: QSizePolicy::Minimum
+public:
+  QSpacerItem_php_qt(zval * zend_ptr, int ws0, int hs1, QSizePolicy::Policy hData = QSizePolicy::Minimum, QSizePolicy::Policy vData = QSizePolicy::Minimum);
 
-		/* int w, int h, QSizePolicy::Policy hData, QSizePolicy::Policy vData,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"llo|o|", &var_lloo_0, &var_lloo_1, &z_var_lloo_2, &z_var_lloo_3) == SUCCESS) {
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QObject* var_lloo_2 = (QObject*) php_qt_fetch(z_var_lloo_2);
-			QObject* var_lloo_3 = (QObject*) php_qt_fetch(z_var_lloo_3);
 
-			QString tmp_lloo_0(var_lloo_2->metaObject()->className());
-			QString tmp_lloo_1(var_lloo_3->metaObject()->className());
-			
-			if(tmp_lloo_0 == "QSizePolicy::Policy" && tmp_lloo_1 == "QSizePolicy::Policy") {
-//				obj->changeSize((int) var_lloo_0, (int) var_lloo_1, (QSizePolicy::Policy) var_lloo_2, (QSizePolicy::Policy) var_lloo_3);
-			RETURN_NULL();
-			}
-		}
-	}
+  zval *zend_ptr;
+};
+QSpacerItem_php_qt::QSpacerItem_php_qt(zval * zend_ptr, int ws0, int hs1, QSizePolicy::Policy hData, QSizePolicy::Policy vData):
+QSpacerItem(ws0, hs1, hData, vData)
+{
+  this->zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  isEmpty
- *    flags:    c
+/*!
+ * method spacerItem
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSpacerItem *
+ * @flags	
  */
-ZEND_METHOD(QSpacerItem, isEmpty){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isEmpty());
-	}
+
+ZEND_METHOD(QSpacerItem, spacerItem)
+{
+  ///
+#ifdef PHP_QT_QSpacerItem       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'spacerItem' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSpacerItem * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QSpacerItem * >(selfpointer->spacerItem());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QSpacerItem::spacerItem(...) ");
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  setGeometry
- *    flags:    
+/*!
+ * method changeSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ws0
+ * @param	 int hs1
+ * @param	 QSizePolicy::Policy hData = QSizePolicy::Minimums2
+ * @param	 QSizePolicy::Policy vData = QSizePolicy::Minimums3
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSpacerItem, setGeometry){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+ZEND_METHOD(QSpacerItem, changeSize)
+{
+  ///int ws0, int hs1, QSizePolicy::Policy hData = QSizePolicy::Minimums2, QSizePolicy::Policy vData = QSizePolicy::Minimums3
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'changeSize' is not static");
+        RETURN_NULL();
+      }
+      /// try int ws0, int hs1,
+      QSpacerItem *selfpointer;
 
-		/* const QRect& ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"o", &z_var_o_0) == SUCCESS) {
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSpacerItem * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->changeSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'changeSize' is not static");
+        RETURN_NULL();
+      }
+      /// try int ws0, int hs1, QSizePolicy::Policy hData = QSizePolicy::Minimums2,
+      QSpacerItem *selfpointer;
 
-			QString tmp_o_0(var_o_0->metaObject()->className());
-			
-			if(tmp_o_0 == "const QRect&") {
-				obj->setGeometry((const QRect&) var_o_0);
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSpacerItem * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->changeSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (QSizePolicy::Policy) Z_LVAL_P(arg_2)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'changeSize' is not static");
+        RETURN_NULL();
+      }
+      /// try int ws0, int hs1, QSizePolicy::Policy hData = QSizePolicy::Minimums2, QSizePolicy::Policy vData = QSizePolicy::Minimums3,
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSpacerItem * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->
+                  changeSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (QSizePolicy::Policy) Z_LVAL_P(arg_2), (QSizePolicy::Policy) Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QSpacerItem::changeSize(...) ");
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  spacerItem
- *    flags:    
+/*!
+ * method QSpacerItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ws0s0
+ * @param	int hs1s1
+ * @param	 QSizePolicy::Policy hData = QSizePolicy::Minimums2
+ * @param	 QSizePolicy::Policy vData = QSizePolicy::Minimums3
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QSpacerItem, spacerItem){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QSpacerItem * return_object = (QSpacerItem *) obj->spacerItem();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSpacerItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QSpacerItem, __construct)
+{
+  ///int ws0s0,int hs1s1, QSizePolicy::Policy hData = QSizePolicy::Minimums2, QSizePolicy::Policy vData = QSizePolicy::Minimums3
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try int ws0s0,int hs1s1,
+      QSpacerItem_php_qt *selfpointer = new QSpacerItem_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try int ws0s0,int hs1s1, QSizePolicy::Policy hData = QSizePolicy::Minimums2,
+      QSpacerItem_php_qt *selfpointer = new QSpacerItem_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (QSizePolicy::Policy) Z_LVAL_P(arg_2));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try int ws0s0,int hs1s1, QSizePolicy::Policy hData = QSizePolicy::Minimums2, QSizePolicy::Policy vData = QSizePolicy::Minimums3,
+      QSpacerItem_php_qt *selfpointer =
+        new QSpacerItem_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (QSizePolicy::Policy) Z_LVAL_P(arg_2),
+                               (QSizePolicy::Policy) Z_LVAL_P(arg_3));
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QSpacerItem::QSpacerItem(...) ");
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  minimumSize
- *    flags:    c
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	c
  */
-ZEND_METHOD(QSpacerItem, minimumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QSize return_object = (QSize) obj->minimumSize();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSpacerItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QSpacerItem, expandingDirections)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'expandingDirections' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSpacerItem * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->expandingDirections());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QSpacerItem::expandingDirections(...) ");
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method isEmpty
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QSpacerItem, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QSize return_object = (QSize) obj->sizeHint();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSpacerItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QSpacerItem, isEmpty)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isEmpty' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSpacerItem * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isEmpty());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QSpacerItem::isEmpty(...) ");
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  maximumSize
- *    flags:    c
+/*!
+ * method geometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-ZEND_METHOD(QSpacerItem, maximumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QSize return_object = (QSize) obj->maximumSize();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSpacerItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QSpacerItem, geometry)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'geometry' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSpacerItem * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QRect *return_object = new QRect;
+
+      *return_object = static_cast < QRect > (selfpointer->geometry());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QSpacerItem::geometry(...) ");
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  geometry
- *    flags:    c
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSpacerItem, geometry){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QRect return_object = (QRect) obj->geometry();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSpacerItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QSpacerItem, setGeometry)
+{
+  ///const QRect &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setGeometry' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &s0,
+        QSpacerItem *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QSpacerItem * >(PHP_QT_FETCH());
+        }
+        QRect *cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setGeometry((const QRect &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QSpacerItem::setGeometry(...) ");
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  expandingDirections
- *    flags:    c
+/*!
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QSpacerItem, expandingDirections){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			Qt::Orientations return_object = (Qt::Orientations) obj->expandingDirections();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSpacerItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QSpacerItem, minimumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSpacerItem * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->minimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QSpacerItem::minimumSize(...) ");
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  QSpacerItem
- *    flags:    
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QSpacerItem, __construct){
 
-	if (ZEND_NUM_ARGS() == 4){
-		/* lloo */
-		long var_lloo_0;    // default: 
-		long var_lloo_1;    // default: 
-		zval* z_var_lloo_2;   // default: QSizePolicy::Minimum
-		zval* z_var_lloo_3;   // default: QSizePolicy::Minimum
+ZEND_METHOD(QSpacerItem, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-		/* int w, int h, QSizePolicy::Policy hData, QSizePolicy::Policy vData,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"llo|o|", &var_lloo_0, &var_lloo_1, &z_var_lloo_2, &z_var_lloo_3) == SUCCESS) {
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QObject* var_lloo_2 = (QObject*) php_qt_fetch(z_var_lloo_2);
-			QObject* var_lloo_3 = (QObject*) php_qt_fetch(z_var_lloo_3);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
 
-			QString tmp_lloo_0(var_lloo_2->metaObject()->className());
-			QString tmp_lloo_1(var_lloo_3->metaObject()->className());
-			
-			if(tmp_lloo_0 == "QSizePolicy::Policy" && tmp_lloo_1 == "QSizePolicy::Policy") {
-//				QSpacerItem *QSpacerItem_ptr = new QSpacerItem((int) var_lloo_0, (int) var_lloo_1, (QSizePolicy::Policy) var_lloo_2, (QSizePolicy::Policy) var_lloo_3);
-//			PHP_QT_REGISTER(QSpacerItem_ptr);
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSpacerItem * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QSpacerItem::sizeHint(...) ");
 }
 
+/*!
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QSpacerItem);
+ZEND_METHOD(QSpacerItem, maximumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'maximumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QSpacerItem * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->maximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QSpacerItem::maximumSize(...) ");
+}

Modified: trunk/qt/classes/qstatustipevent.cpp
===================================================================
--- trunk/qt/classes/qstatustipevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qstatustipevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,36 +19,117 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QStatusTipEvent.cpp - QStatusTipEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QStatusTipEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QStatusTipEvent */
-/*
- *    function  tip
- *    flags:    c
+#include <QStatusTipEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QStatusTipEvent_php_qt:public QStatusTipEvent
+{
+
+public:
+  QStatusTipEvent_php_qt(zval * zend_ptr, const QString & tips0);
+
+
+  zval *zend_ptr;
+};
+QStatusTipEvent_php_qt::QStatusTipEvent_php_qt(zval * zend_ptr, const QString & tips0):
+QStatusTipEvent(tips0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method tip
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QStatusTipEvent, tip){
-	if (ZEND_NUM_ARGS() == 0){
-			QStatusTipEvent *obj = (QStatusTipEvent*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->tip();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QStatusTipEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QStatusTipEvent, tip)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'tip' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QStatusTipEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QStatusTipEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->tip());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QStatusTipEvent::tip(...) ");
 }
 
+/*!
+ * method QStatusTipEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &tips0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QStatusTipEvent);
+ZEND_METHOD(QStatusTipEvent, __construct)
+{
+  ///const QString &tips0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &tips0s0,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QStatusTipEvent_php_qt *selfpointer = new QStatusTipEvent_php_qt(getThis(), (const QString &)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QStatusTipEvent::QStatusTipEvent(...) ");
+}

Modified: trunk/qt/classes/qstring.cpp
===================================================================
--- trunk/qt/classes/qstring.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qstring.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,2844 +19,8301 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QString.cpp - QString PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QString>
 #include "../php_qt.h"
 
 
-ZEND_METHOD(QString,__toString){
+#include <QString>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QString_php_qt:public QString
+{
 
-  QString *QString_ptr = (QString *) PHP_QT_FETCH();
+public:
+  QString_php_qt(zval * zend_ptr);
+  QString_php_qt(zval * zend_ptr, const QChar * unicodes0, int sizes1);
+    QString_php_qt(zval * zend_ptr, QChar cs0);
+    QString_php_qt(zval * zend_ptr, int sizes0, QChar cs1);
+    QString_php_qt(zval * zend_ptr, const QLatin1String & latin1s0);
+    QString_php_qt(zval * zend_ptr, const QString & s0);
+    QString_php_qt(zval * zend_ptr, const char *chs0);
+    QString_php_qt(zval * zend_ptr, const QByteArray & as0);
+    QString_php_qt(zval * zend_ptr, const Null & s0);
 
-  int l = QString_ptr->size();
-  char* c = (char*) (QString_ptr->toAscii()).constData();
-  RETURN_STRING(c,l);
-}
 
+  zval *zend_ptr;
+};
 
-/*		public enumSectionFlag:long {
-			SectionDefault = 0x00,
-			SectionSkipEmpty = 0x01,
-			SectionIncludeLeadingSep = 0x02,
-			SectionIncludeTrailingSep = 0x04,
-			SectionCaseInsensitiveSeps = 0x08
-		}
-*/
+QString_php_qt::QString_php_qt(zval * zend_ptr):QString()
+{
+  this->zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, const QChar * unicodes0, int sizes1):
+QString(unicodes0, sizes1)
+{
+  this->zend_ptr = zend_ptr;
+}
 
-/*		public enumSplitBehavior:long {
-			SplitBehavior = 0,
-			SplitBehavior = 1
-		}
-*/
+QString_php_qt::QString_php_qt(zval * zend_ptr, QChar cs0):QString(cs0)
+{
+  this->zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, int sizes0, QChar cs1):
+QString(sizes0, cs1)
+{
+  this->zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, const QLatin1String & latin1s0):
+QString(latin1s0)
+{
+  this->zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, const QString & s0):
+QString(s0)
+{
+  this->zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, const char *chs0):
+QString(chs0)
+{
+  this->zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, const QByteArray & as0):
+QString(as0)
+{
+  this->zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, const Null & s0):
+QString(s0)
+{
+  this->zend_ptr = zend_ptr;
+}
 
-/*		public enumNormalizationForm:long {
-			NormalizationForm = 0,
-			NormalizationForm = 1,
-			NormalizationForm = 2,
-			NormalizationForm = 3
-		}
-*/
-/*********************************
- *    class     QString */
-/*
- *    function  compare
- *    flags:    c
+/*!
+ * method compare
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * overloaded args:
+ * @param	const QString &s1
+ * @param	 const QString &s2
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QString, compare){
-		/* o public*/
 
-		/* const QString& s,  */
+ZEND_METHOD(QString, compare)
+{
+  ///const QString &ss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'compare' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &ss0,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				RETURN_LONG(obj->compare((const QString&) obj_z_0));
-			}
-			}
-		}
-	}
-		/* oo public*/
+        RETURN_LONG(selfpointer->compare((const QString &)*cpp_arg_0));
+      }
+#endif
 
-		/* const QString& s1, const QString& s2,  */
+    }
+  }
+  ///const QString &s1, const QString &s2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        /// try const QString &s1, const QString &s2,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && Z_OBJCE_P(z_1)->name == "QString") {
-				RETURN_LONG(obj->compare((const QString&) obj_z_0, (const QString&) obj_z_1));
-			}
-			}
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_LONG(QString::compare((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        } else {
+          RETURN_LONG(selfpointer->compare((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+      }}
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::compare(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  utf16
- *    flags:    c
+/*!
+ * method utf16
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const ushort *
+ * @flags	c
  */
-ZEND_METHOD(QString, utf16){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				const ushort * return_object = (const ushort *) obj->utf16();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, utf16)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'utf16' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->utf16());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::utf16(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  constData
- *    flags:    c
+/*!
+ * method constData
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QChar *
+ * @flags	c
  */
-ZEND_METHOD(QString, constData){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				const QChar * return_object = (const QChar *) obj->constData();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, constData)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'constData' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast < QChar * >(selfpointer->constData());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::constData(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  insert
- *    flags:    
+/*!
+ * method insert
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * @param	 QChar cs1
+ * 
+ * overloaded args:
+ * @param	int i
+ * @param	 const QChar *uc
+ * @param	 int len
+ * 
+ * overloaded args:
+ * @param	int i
+ * @param	 const QString &s
+ * 
+ * overloaded args:
+ * @param	int i
+ * @param	 const QLatin1String &s
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
  */
-ZEND_METHOD(QString, insert){
-		/* ll public*/
 
-		/* int i, char c,  */
-		/* lo public*/
+ZEND_METHOD(QString, insert)
+{
+  ///int is0, QChar cs1
+#ifdef PHP_QT_QString           // return type
 
-		/* int i, const QString& s,  */
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_1), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'insert' is not static");
+          RETURN_NULL();
+        }
+        /// try int is0, QChar cs1,
+        QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
 
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
 
-				QString & return_object = (QString &) obj->insert((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        le.ptr = &static_cast < QString & >(selfpointer->insert((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
+    }
+  }
+#endif // return type
 
-			if(Z_OBJCE_P(z_1)->name == "QString") {
-					QString & return_object = (QString &) obj->insert((int) Z_LVAL_P(z_0), (const QString&) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* lol public*/
 
-		/* int i, const QChar* uc, int len,  */
+  ///int i, const QChar *uc, int len
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_1), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'insert' is not static");
+          RETURN_NULL();
+        }
+        /// try int i, const QChar *uc, int len,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_1)->name == "char") {
-					QString & return_object = (QString &) obj->insert((int) Z_LVAL_P(z_0), (const QChar*) obj_z_1, (int) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->insert((int)Z_LVAL_P(arg_0), (const QChar *)cpp_arg_1, (int)Z_LVAL_P(arg_2)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///int i, const QString &s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'insert' is not static");
+          RETURN_NULL();
+        }
+        /// try int i, const QString &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->insert((int)Z_LVAL_P(arg_0), (const QString &)*cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///int i, const QLatin1String &s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_1), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'insert' is not static");
+          RETURN_NULL();
+        }
+        /// try int i, const QLatin1String &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_1 = static_cast < QLatin1String * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->insert((int)Z_LVAL_P(arg_0), (const QLatin1String &)*cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::insert(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  clear
- *    flags:    
+/*!
+ * method clear
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, clear){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			obj->clear();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QString, clear)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'clear' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->clear());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::clear(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  setUtf16
- *    flags:    
+/*!
+ * method setUtf16
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const ushort *utf16s0
+ * @param	 int sizes1
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
  */
-ZEND_METHOD(QString, setUtf16){
-		/* ol public*/
 
-		/* const ushort* utf16, int size,  */
+ZEND_METHOD(QString, setUtf16)
+{
+  ///const ushort *utf16s0, int sizes1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setUtf16' is not static");
+        RETURN_NULL();
+      }
+      /// try const ushort *utf16s0, int sizes1,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString & return_object = (QString &) obj->setUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setUtf16((const ushort *)&Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::setUtf16(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  prepend
- *    flags:    
+/*!
+ * method prepend
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &s
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &s
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
  */
-ZEND_METHOD(QString, prepend){
-		/* l public*/
 
-		/* char c,  */
-		/* s public*/
+ZEND_METHOD(QString, prepend)
+{
+  ///QChar cs0
+#ifdef PHP_QT_QString           // return type
 
-		/* const char* s,  */
-		/* o public*/
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'prepend' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
-		/* const QString& s,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
 
+        le.ptr = &static_cast < QString & >(selfpointer->prepend((QChar) * cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-				QString & return_object = (QString &) obj->prepend((char) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_STRING){
-			QString *obj = (QString*) PHP_QT_FETCH();
+    }
+  }
+#endif // return type
 
 
-				QString & return_object = (QString &) obj->prepend( (const char*) Z_STRVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  ///const QString &s
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QString & return_object = (QString &) obj->prepend((const QString&) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_0)->name == "QByteArray") {
-					QString & return_object = (QString &) obj->prepend((const QByteArray&) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'prepend' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->prepend((const QString &)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QLatin1String &s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'prepend' is not static");
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->prepend((const QLatin1String &)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const char *s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'prepend' is not static");
+        RETURN_NULL();
+      }
+      /// try const char *s,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->prepend((const char *)&Z_STRVAL_P(arg_0)[0]));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const QByteArray &s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QByteArray
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'prepend' is not static");
+          RETURN_NULL();
+        }
+        /// try const QByteArray &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QByteArray *cpp_arg_0 = static_cast < QByteArray * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->prepend((const QByteArray &)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::prepend(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  trimmed
- *    flags:    c
+/*!
+ * method grow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	private
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QString, trimmed){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->trimmed();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, grow)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+/// method is private, skip
+      php_error(E_ERROR, "QString::grow(...) cannot be called with 'int ints0,'.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::grow(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  chop
- *    flags:    
+/*!
+ * method trimmed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, chop){
-		/* l public*/
 
-		/* int n,  */
+ZEND_METHOD(QString, trimmed)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'trimmed' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->chop((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->trimmed());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::trimmed(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  leftJustified
- *    flags:    c
+/*!
+ * method chop
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ns0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, leftJustified){
-		/* lll public*/
 
-		/* int width, char fill, int trunc,  */
+ZEND_METHOD(QString, chop)
+{
+  ///int ns0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'chop' is not static");
+        RETURN_NULL();
+      }
+      /// try int ns0,
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->chop((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::chop(...) ");
+}
 
+/*!
+ * method leftJustified
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int widths0
+ * @param	 QChar fill = QLatin1Char(' ')s1
+ * @param	 bool trunc = falses2
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-				QString return_object = (QString) obj->leftJustified((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(bool) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+ZEND_METHOD(QString, leftJustified)
+{
+  ///int widths0, QChar fill = QLatin1Char(' ')s1, bool trunc = falses2
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'leftJustified' is not static");
+        RETURN_NULL();
+      }
+      /// try int widths0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->leftJustified((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'leftJustified' is not static");
+        RETURN_NULL();
+      }
+      /// try int widths0, QChar fill = QLatin1Char(' ')s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->leftJustified((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'leftJustified' is not static");
+        RETURN_NULL();
+      }
+      /// try int widths0, QChar fill = QLatin1Char(' ')s1, bool trunc = falses2,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->leftJustified((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1, (bool) Z_LVAL_P(arg_2)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::leftJustified(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  squeeze
- *    flags:    
+/*!
+ * method squeeze
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, squeeze){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			obj->squeeze();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QString, squeeze)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'squeeze' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->squeeze());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::squeeze(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  count
- *    flags:    c
+/*!
+ * method count
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar c
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QString, count){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_LONG(obj->count());
-	}
-		/* o public*/
 
-		/* const QRegExp& ,  */
+ZEND_METHOD(QString, count)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'count' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->count());
+    }
+  }
+  ///QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'count' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar c,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)->name == "QRegExp") {
-				RETURN_LONG(obj->count((const QRegExp&) obj_z_0));
-			}
-			}
-		}
-	}
-		/* ol public*/
+        RETURN_LONG(selfpointer->count((QChar) * cpp_arg_0));
+      }
+#endif
 
-		/* const QString& s, int cs,  */
-		/* ll public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'count' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
 
-		/* char c, int cs,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        RETURN_LONG(selfpointer->count((QChar) * cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
 
+    }
+  }
+  ///const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				RETURN_LONG(obj->count((const QString&) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1)));
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'count' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			RETURN_LONG(obj->count((char) Z_LVAL_P(z_0) ,(Qt::CaseSensitivity) Z_LVAL_P(z_1)));
-			}
-		}
-	}
-}
+        RETURN_LONG(selfpointer->count((const QString &)*cpp_arg_0));
+      }
+#endif
 
-/*********************************
- *    class     QString */
-/*
- *    function  fromAscii
- *    flags:    s
- */
-ZEND_METHOD(QString, fromAscii){
-		/* sl public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'count' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
 
-		/* const char* , int size,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        RETURN_LONG(selfpointer->count((const QString &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
 
+    }
+  }
+  ///const QRegExp &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'count' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegExp &,
+        QString *selfpointer;
 
-				QString return_object = (QString) obj->fromAscii( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->count((const QRegExp &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::count(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toLongLong
- *    flags:    c
+/*!
+ * method fromAscii
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *s0
+ * @param	 int size = -1s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, toLongLong){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, fromAscii)
+{
+  ///const char *s0, int size = -1s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->toLongLong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::fromAscii((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->fromAscii((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try const char *s0, int size = -1s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::fromAscii((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->fromAscii((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::fromAscii(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toUpper
- *    flags:    c
+/*!
+ * method toLongLong
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	qlonglong
+ * @flags	c
  */
-ZEND_METHOD(QString, toUpper){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->toUpper();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, toLongLong)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type qlonglong");
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      php_error(E_ERROR, "unsupported return type qlonglong");
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
+      php_error(E_ERROR, "unsupported return type qlonglong");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::toLongLong(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  QString
- *    flags:    
+/*!
+ * method toUpper
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *QString_ptr = new QString();
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-	}
-		/* l public*/
 
-		/* char c,  */
-		/* s public*/
+ZEND_METHOD(QString, toUpper)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-		/* const char* ch,  */
-		/* o public*/
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toUpper' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-		/* const QLatin1String& latin1,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
+      *return_object = static_cast < QString > (selfpointer->toUpper());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			QString *QString_ptr = new QString((char) Z_LVAL_P(z_0));
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_STRING){
+  php_error(E_ERROR, "could not parse argument in QString::toUpper(...) ");
+}
 
+/*!
+ * method QString
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QChar *unicodes0
+ * @param	int sizes1
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	int sizes0
+ * @param	QChar cs1
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &latin1s0
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * overloaded args:
+ * @param	const char *chs0
+ * 
+ * overloaded args:
+ * @param	const QByteArray &as0
+ * 
+ * overloaded args:
+ * @param	const Null &s0
+ * 
+ * overloaded args:
+ * @param	const char *ch
+ * 
+ * overloaded args:
+ * @param	const QByteArray &a
+ * 
+ * overloaded args:
+ * @param	Data *dd
+ * @param	 int
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-			QString *QString_ptr = new QString( (const char*) Z_STRVAL_P(z_0));
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QString, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString_php_qt *selfpointer = new QString_php_qt(getThis());
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QChar *unicodes0,int sizes1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QChar *unicodes0,int sizes1,
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const QChar *)cpp_arg_0, (int)Z_LVAL_P(arg_1));
 
-			if(obj_z_0->inherits("QLatin1String")) {
-				QString *QString_ptr = new QString((const QLatin1String&) obj_z_0);
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				QString *QString_ptr = new QString((const QString&) obj_z_0);
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)->name == "QByteArray") {
-				QString *QString_ptr = new QString((const QByteArray&) obj_z_0);
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			if(obj_z_0->inherits("Null")) {
-				QString *QString_ptr = new QString((const Null&) obj_z_0);
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ol public*/
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-		/* const QChar* unicode, int size,  */
-		/* ll public*/
+    }
+  }
+  ///QChar cs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (QChar) * cpp_arg_0);
 
-		/* int size, char c,  */
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    }
+  }
+  ///int sizes0,QChar cs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_1), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try int sizes0,QChar cs1,
+        QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
+        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "char") {
-				QString *QString_ptr = new QString((const QChar*) obj_z_0, (int) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+    }
+  }
+  ///const QLatin1String &latin1s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &latin1s0,
+        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));
+        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const QLatin1String &)*cpp_arg_0);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-			QString *QString_ptr = new QString((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
-}
+    }
+  }
+  ///const QString &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-/*********************************
- *    class     QString */
-/*
- *    function  normalized
- *    flags:    c
- */
-ZEND_METHOD(QString, normalized){
-		/* o public*/
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const QString &)*cpp_arg_0);
 
-		/* QString::NormalizationForm mode,  */
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+    }
+  }
+  ///const char *chs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try const char *chs0,
+      QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const char *)&Z_STRVAL_P(arg_0)[0]);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QByteArray &as0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QByteArray
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QByteArray &as0,
+        QByteArray *cpp_arg_0 = static_cast < QByteArray * >(php_qt_fetch(arg_0));
+        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const QByteArray &)*cpp_arg_0);
 
-				QString return_object = (QString) obj->normalized((QString::NormalizationForm) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
-		/* ol public*/
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-		/* QString::NormalizationForm mode, int version,  */
+    }
+  }
+// notice: unknown argument const Null &s0, skipped
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  ///const char *ch
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+/// method is private, skip
+      php_error(E_ERROR, "QString::__construct(...) cannot be called with 'const char *ch,'.");
+    }
+  }
+  ///const QByteArray &a
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QByteArray
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// method is private, skip
+        php_error(E_ERROR, "QString::__construct(...) cannot be called with 'const QByteArray &a,'.");
+      }
+#endif
 
+    }
+  }
+// notice: unknown argument Data *dd, skipped
+  php_error(E_ERROR, "could not parse argument in QString::QString(...) ");
+}
 
-				QString return_object = (QString) obj->normalized((QString::NormalizationForm) Z_LVAL_P(z_0) ,(QChar::UnicodeVersion) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+/*!
+ * method normalized
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	NormalizationForm modes0
+ * 
+ * overloaded args:
+ * @param	NormalizationForm mode
+ * @param	 QChar::UnicodeVersion version
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
+
+ZEND_METHOD(QString, normalized)
+{
+// notice: unknown argument NormalizationForm modes0, skipped
+
+// notice: unknown argument NormalizationForm mode, skipped
+  php_error(E_ERROR, "could not parse argument in QString::normalized(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  fromUtf16
- *    flags:    s
+/*!
+ * method fromUtf16
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const ushort *s0
+ * @param	 int size = -1s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, fromUtf16){
-		/* ol public*/
 
-		/* const ushort* , int size,  */
+ZEND_METHOD(QString, fromUtf16)
+{
+  ///const ushort *s0, int size = -1s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try const ushort *s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj->fromUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::fromUtf16((const ushort *)&Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->fromUtf16((const ushort *)&Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try const ushort *s0, int size = -1s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::fromUtf16((const ushort *)&Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->fromUtf16((const ushort *)&Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::fromUtf16(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  isRightToLeft
- *    flags:    c
+/*!
+ * method isRightToLeft
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, isRightToLeft){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isRightToLeft());
-	}
+
+ZEND_METHOD(QString, isRightToLeft)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isRightToLeft' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isRightToLeft());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::isRightToLeft(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  setNum
- *    flags:    
+/*!
+ * method setNum
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	short shorts0
+ * @param	 int base=10s1
+ * 
+ * overloaded args:
+ * @param	ushort
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	int
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	uint
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	long
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	ulong
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	qlonglong
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	qulonglong
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	float
+ * @param	 char f='g'
+ * @param	 int prec=6
+ * 
+ * overloaded args:
+ * @param	double
+ * @param	 char f='g'
+ * @param	 int prec=6
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
  */
-ZEND_METHOD(QString, setNum){
-		/* ol public*/
 
-		/* short , int base,  */
+ZEND_METHOD(QString, setNum)
+{
+  ///short shorts0, int base=10s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try short shorts0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString & return_object = (QString &) obj->setNum((short) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
-		/* oll public*/
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
 
-		/* float , char f, int prec,  */
-		/* lll public*/
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((short)Z_LVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try short shorts0, int base=10s1,
+      QString *selfpointer;
 
-		/* double , char f, int prec,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
 
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((short)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-				QString & return_object = (QString &) obj->setNum((float) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
 
+  ///ushort, int base=10
+#ifdef PHP_QT_QString           // return type
 
-				QString & return_object = (QString &) obj->setNum((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try ushort,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((ushort) Z_LVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try ushort, int base=10,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((ushort) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///int, int base=10
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try int,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((int)Z_LVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try int, int base=10,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///uint, int base=10
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try uint,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((uint) Z_LVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try uint, int base=10,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+// notice: unknown argument long, skipped
+
+// notice: unknown argument ulong, skipped
+
+// notice: unknown argument qlonglong, skipped
+
+// notice: unknown argument qulonglong, skipped
+
+  ///float, char f='g', int prec=6
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try float,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((float)Z_DVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try float, char f='g',
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((float)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0]));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_STRING && Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try float, char f='g', int prec=6,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((float)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0], (int)Z_LVAL_P(arg_2)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///double, char f='g', int prec=6
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try double,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((double)Z_DVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try double, char f='g',
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0]));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_STRING && Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setNum' is not static");
+        RETURN_NULL();
+      }
+      /// try double, char f='g', int prec=6,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->setNum((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0], (int)Z_LVAL_P(arg_2)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::setNum(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  endsWith
- *    flags:    c
+/*!
+ * method operator[]
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * 
+ * overloaded args:
+ * @param	int i
+ * 
+ * overloaded args:
+ * @param	uint i
+ * 
+ * overloaded args:
+ * @param	uint i
+ * 
+ * @access	public
+ * @return	const QChar
+ * @flags	c
  */
-ZEND_METHOD(QString, endsWith){
-		/* ol public*/
 
-		/* const QString& s, int cs,  */
+/*!
+ * method endsWith
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives1
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &s
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QChar &c
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QString, endsWith)
+{
+  ///const QString &ss0, Qt::CaseSensitivity cs = Qt::CaseSensitives1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'endsWith' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &ss0,
+        QString *selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				RETURN_BOOL(obj->endsWith((const QString&) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1)));
-			}
-			if(Z_OBJCE_P(z_0)->name == "char") {
-				RETURN_BOOL(obj->endsWith((const QChar&) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1)));
-			}
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->endsWith((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'endsWith' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &ss0, Qt::CaseSensitivity cs = Qt::CaseSensitives1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->endsWith((const QString &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'endsWith' is not static");
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->endsWith((const QLatin1String &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'endsWith' is not static");
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->endsWith((const QLatin1String &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'endsWith' is not static");
+          RETURN_NULL();
+        }
+        /// try const QChar &c,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->endsWith((const QChar &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'endsWith' is not static");
+          RETURN_NULL();
+        }
+        /// try const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->endsWith((const QChar &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::endsWith(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  number
- *    flags:    s
+/*!
+ * method number
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * @param	 int base=10s1
+ * 
+ * overloaded args:
+ * @param	uint
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	long
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	ulong
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	qlonglong
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	qulonglong
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	double
+ * @param	 char f='g'
+ * @param	 int prec=6
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, number){
-		/* ol public*/
 
-		/* unsigned long , int base,  */
-		/* ll public*/
+ZEND_METHOD(QString, number)
+{
+  ///int ints0, int base=10s1
+#ifdef PHP_QT_QString           // return type
 
-		/* int , int base,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ints0,
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-				QString return_object = (QString) obj->number((ulong) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::number((int)Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->number((int)Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try int ints0, int base=10s1,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj->number((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
-		/* lll public*/
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-		/* double , char f, int prec,  */
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::number((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->number((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
 
+  ///uint, int base=10
+#ifdef PHP_QT_QString           // return type
 
-				QString return_object = (QString) obj->number((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try uint,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::number((uint) Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->number((uint) Z_LVAL_P(arg_0)));
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try uint, int base=10,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::number((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->number((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+// notice: unknown argument long, skipped
+
+// notice: unknown argument ulong, skipped
+
+// notice: unknown argument qlonglong, skipped
+
+// notice: unknown argument qulonglong, skipped
+
+  ///double, char f='g', int prec=6
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      /// try double,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::number((double)Z_DVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->number((double)Z_DVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try double, char f='g',
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::number((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->number((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_STRING && Z_TYPE_P(arg_2) == IS_LONG) {
+      /// try double, char f='g', int prec=6,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::number((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0], (int)Z_LVAL_P(arg_2)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->number((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0], (int)Z_LVAL_P(arg_2)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::number(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  localeAwareCompare
- *    flags:    c
+/*!
+ * method localeAwareCompare
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString & ss0
+ * 
+ * overloaded args:
+ * @param	const QString& s1
+ * @param	 const QString& s2
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QString, localeAwareCompare){
-		/* o public*/
 
-		/* const QString& s,  */
+ZEND_METHOD(QString, localeAwareCompare)
+{
+  ///const QString & ss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'localeAwareCompare' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString & ss0,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				RETURN_LONG(obj->localeAwareCompare((const QString&) obj_z_0));
-			}
-			}
-		}
-	}
-		/* oo public*/
+        RETURN_LONG(selfpointer->localeAwareCompare((const QString &)*cpp_arg_0));
+      }
+#endif
 
-		/* const QString& s1, const QString& s2,  */
+    }
+  }
+  ///const QString& s1, const QString& s2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        /// try const QString& s1, const QString& s2,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && Z_OBJCE_P(z_1)->name == "QString") {
-				RETURN_LONG(obj->localeAwareCompare((const QString&) obj_z_0, (const QString&) obj_z_1));
-			}
-			}
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_LONG(QString::localeAwareCompare((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        } else {
+          RETURN_LONG(selfpointer->localeAwareCompare((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+      }}
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::localeAwareCompare(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  section
- *    flags:    c
+/*!
+ * method section
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar seps0
+ * @param	 int starts1
+ * @param	 int end = -1s2
+ * @param	 SectionFlags flags = SectionDefaults3
+ * 
+ * overloaded args:
+ * @param	const QString &in_sep
+ * @param	 int start
+ * @param	 int end = -1
+ * @param	 SectionFlags flags = SectionDefault
+ * 
+ * overloaded args:
+ * @param	const QRegExp &reg
+ * @param	 int start
+ * @param	 int end = -1
+ * @param	 SectionFlags flags = SectionDefault
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, section){
-		/* lllo public*/
 
-		/* char sep, int start, int end, QString::SectionFlags flags,  */
-		/* ollo public*/
+ZEND_METHOD(QString, section)
+{
+  ///QChar seps0, int starts1, int end = -1s2, SectionFlags flags = SectionDefaults3
+#ifdef PHP_QT_QString           // return type
 
-		/* const QString& in_sep, int start, int end, QString::SectionFlags flags,  */
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'section' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar seps0, int starts1,
+        QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
 
-				QString return_object = (QString) obj->section((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(QString::SectionFlags) Z_LVAL_P(z_3));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        *return_object = static_cast < QString > (selfpointer->section((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'section' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar seps0, int starts1, int end = -1s2,
+        QString *selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QString return_object = (QString) obj->section((const QString&) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (QString::SectionFlags) Z_LVAL_P(z_3));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_0)->name == "QRegExp") {
-					QString return_object = (QString) obj->section((const QRegExp&) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (QString::SectionFlags) Z_LVAL_P(z_3));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->section((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument  SectionFlags flags = SectionDefaults3, skipped
+#endif // return type
+
+
+  ///const QString &in_sep, int start, int end = -1, SectionFlags flags = SectionDefault
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'section' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &in_sep, int start,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->section((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'section' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &in_sep, int start, int end = -1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->section((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument  SectionFlags flags = SectionDefault, skipped
+#endif // return type
+
+
+  ///const QRegExp &reg, int start, int end = -1, SectionFlags flags = SectionDefault
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'section' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegExp &reg, int start,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->section((const QRegExp &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'section' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegExp &reg, int start, int end = -1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->section((const QRegExp &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument  SectionFlags flags = SectionDefault, skipped
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::section(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  isSimpleText
- *    flags:    c
+/*!
+ * method operator<
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &s
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &s
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, isSimpleText){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isSimpleText());
-	}
+
+/*!
+ * method isSimpleText
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+ZEND_METHOD(QString, isSimpleText)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isSimpleText' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isSimpleText());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::isSimpleText(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  size
- *    flags:    c
+/*!
+ * method operator==
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &s
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &s
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, size){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_LONG(obj->size());
-	}
+
+/*!
+ * method size
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QString, size)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'size' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->size());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::size(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  simplified
- *    flags:    c
+/*!
+ * method updateProperties
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	private
+ * @return	void
+ * @flags	c
  */
-ZEND_METHOD(QString, simplified){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->simplified();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, updateProperties)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QString::updateProperties(...) cannot be called with ''.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::updateProperties(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toUInt
- *    flags:    c
+/*!
+ * method simplified
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, toUInt){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, simplified)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'simplified' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_LONG(obj->toUInt((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->simplified());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::simplified(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toUShort
- *    flags:    c
+/*!
+ * method toUInt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	uint
+ * @flags	c
  */
-ZEND_METHOD(QString, toUShort){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, toUInt)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toUInt' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toUInt());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toUInt' is not static");
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toUInt((bool *) & Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toUInt' is not static");
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0, int base=10s1,
+      QString *selfpointer;
 
-			RETURN_LONG(obj->toUShort((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toUInt((bool *) & Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::toUInt(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  truncate
- *    flags:    
+/*!
+ * method toUShort
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	ushort
+ * @flags	c
  */
-ZEND_METHOD(QString, truncate){
-		/* l public*/
 
-		/* int pos,  */
+ZEND_METHOD(QString, toUShort)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toUShort' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toUShort());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toUShort' is not static");
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toUShort((bool *) & Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toUShort' is not static");
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0, int base=10s1,
+      QString *selfpointer;
 
-			obj->truncate((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toUShort((bool *) & Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::toUShort(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toAscii
- *    flags:    c
+/*!
+ * method truncate
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int poss0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, toAscii){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj->toAscii(), 1);
-	}
-}
 
-/*********************************
- *    class     QString */
-/*
- *    function  length
- *    flags:    c
- */
-ZEND_METHOD(QString, length){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_LONG(obj->length());
-	}
+ZEND_METHOD(QString, truncate)
+{
+  ///int poss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'truncate' is not static");
+        RETURN_NULL();
+      }
+      /// try int poss0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->truncate((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::truncate(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  right
- *    flags:    c
+/*!
+ * method toAscii
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QByteArray
+ * @flags	c
  */
-ZEND_METHOD(QString, right){
-		/* l public*/
 
-		/* int len,  */
+ZEND_METHOD(QString, toAscii)
+{
+  ///
+#ifdef PHP_QT_QByteArray        // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toAscii' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj->right((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QByteArray *return_object = new QByteArray;
+
+      *return_object = static_cast < QByteArray > (selfpointer->toAscii());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::toAscii(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  push_front
- *    flags:    
+/*!
+ * method right
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int lens0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, push_front){
-		/* l public*/
 
-		/* char c,  */
-		/* o public*/
+ZEND_METHOD(QString, right)
+{
+  ///int lens0
+#ifdef PHP_QT_QString           // return type
 
-		/* const QString& s,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'right' is not static");
+        RETURN_NULL();
+      }
+      /// try int lens0,
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-			obj->push_front((char) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      *return_object = static_cast < QString > (selfpointer->right((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
+  php_error(E_ERROR, "could not parse argument in QString::right(...) ");
+}
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				obj->push_front((const QString&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+/*!
+ * method length
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QString, length)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'length' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->length());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::length(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toUtf8
- *    flags:    c
+/*!
+ * method expand
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * 
+ * @access	private
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, toUtf8){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj->toUtf8(), 1);
-	}
+
+ZEND_METHOD(QString, expand)
+{
+  ///int is0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+/// method is private, skip
+      php_error(E_ERROR, "QString::expand(...) cannot be called with 'int is0,'.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::expand(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toULongLong
- *    flags:    c
+/*!
+ * method push_front
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, toULongLong){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, push_front)
+{
+  ///QChar cs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'push_front' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->push_front((QChar) * cpp_arg_0));
+      }
+#endif
 
-			obj->toULongLong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  ///const QString &s
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'push_front' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->push_front((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::push_front(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  indexOf
- *    flags:    c
+/*!
+ * method toUtf8
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QByteArray
+ * @flags	c
  */
-ZEND_METHOD(QString, indexOf){
-		/* ol public*/
 
-		/* const QRegExp& , int from,  */
+ZEND_METHOD(QString, toUtf8)
+{
+  ///
+#ifdef PHP_QT_QByteArray        // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toUtf8' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)->name == "QRegExp") {
-				RETURN_LONG(obj->indexOf((const QRegExp&) obj_z_0, (int) Z_LVAL_P(z_1)));
-			}
-			}
-		}
-	}
-		/* oll public*/
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QByteArray *return_object = new QByteArray;
 
-		/* const QString& s, int from, int cs,  */
-		/* lll public*/
+      *return_object = static_cast < QByteArray > (selfpointer->toUtf8());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-		/* char c, int from, int cs,  */
+  php_error(E_ERROR, "could not parse argument in QString::toUtf8(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method toULongLong
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	qulonglong
+ * @flags	c
+ */
 
+ZEND_METHOD(QString, toULongLong)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type qulonglong");
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      php_error(E_ERROR, "unsupported return type qulonglong");
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
+      php_error(E_ERROR, "unsupported return type qulonglong");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::toULongLong(...) ");
+}
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				RETURN_LONG(obj->indexOf((const QString&) obj_z_0, (int) Z_LVAL_P(z_1), (Qt::CaseSensitivity) Z_LVAL_P(z_2)));
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+/*!
+ * method indexOf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * @param	 int from = 0s1
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives2
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * @param	 int from = 0
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &
+ * @param	 int from = 0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QString, indexOf)
+{
+  ///QChar cs0, int from = 0s1, Qt::CaseSensitivity cs = Qt::CaseSensitives2
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'indexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
-			RETURN_LONG(obj->indexOf((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(Qt::CaseSensitivity) Z_LVAL_P(z_2)));
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->indexOf((QChar) * cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'indexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0, int from = 0s1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->indexOf((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'indexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0, int from = 0s1, Qt::CaseSensitivity cs = Qt::CaseSensitives2,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->indexOf((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  ///const QString &s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'indexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->indexOf((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'indexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s, int from = 0,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->indexOf((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'indexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->indexOf((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  ///const QRegExp &, int from = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'indexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegExp &,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->indexOf((const QRegExp &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'indexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegExp &, int from = 0,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->indexOf((const QRegExp &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::indexOf(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  fromRawData
- *    flags:    s
+/*!
+ * method fromRawData
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QChar *s0
+ * @param	 int sizes1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, fromRawData){
-		/* ol public*/
 
-		/* const QChar* , int size,  */
+ZEND_METHOD(QString, fromRawData)
+{
+  ///const QChar *s0, int sizes1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        /// try const QChar *s0, int sizes1,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)->name == "char") {
-					QString return_object = (QString) obj->fromRawData((const QChar*) obj_z_0, (int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast < QString > (QString::fromRawData((const QChar *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        } else {
+          *return_object = static_cast < QString > (selfpointer->fromRawData((const QChar *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::fromRawData(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  constEnd
- *    flags:    c
+/*!
+ * method constEnd
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const_iterator
+ * @flags	c
  */
-ZEND_METHOD(QString, constEnd){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			obj->constEnd();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QString, constEnd)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type const_iterator");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::constEnd(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  left
- *    flags:    c
+/*!
+ * method left
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int lens0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, left){
-		/* l public*/
 
-		/* int len,  */
+ZEND_METHOD(QString, left)
+{
+  ///int lens0
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'left' is not static");
+        RETURN_NULL();
+      }
+      /// try int lens0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj->left((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->left((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::left(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  fromLocal8Bit
- *    flags:    s
+/*!
+ * method fromLocal8Bit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *s0
+ * @param	 int size = -1s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, fromLocal8Bit){
-		/* sl public*/
 
-		/* const char* , int size,  */
+ZEND_METHOD(QString, fromLocal8Bit)
+{
+  ///const char *s0, int size = -1s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj->fromLocal8Bit( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::fromLocal8Bit((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->fromLocal8Bit((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try const char *s0, int size = -1s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::fromLocal8Bit((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->fromLocal8Bit((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::fromLocal8Bit(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  startsWith
- *    flags:    c
+/*!
+ * method remove
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * @param	 int lens1
+ * 
+ * overloaded args:
+ * @param	QChar c
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &rx
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
  */
-ZEND_METHOD(QString, startsWith){
-		/* ol public*/
 
-		/* const QString& s, int cs,  */
+ZEND_METHOD(QString, remove)
+{
+  ///int is0, int lens1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'remove' is not static");
+        RETURN_NULL();
+      }
+      /// try int is0, int lens1,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				RETURN_BOOL(obj->startsWith((const QString&) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1)));
-			}
-			if(Z_OBJCE_P(z_0)->name == "char") {
-				RETURN_BOOL(obj->startsWith((const QChar&) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1)));
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->remove((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'remove' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar c,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->remove((QChar) * cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'remove' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->remove((QChar) * cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'remove' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->remove((const QString &)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'remove' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->remove((const QString &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QRegExp &rx
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'remove' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegExp &rx,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->remove((const QRegExp &)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::remove(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  remove
- *    flags:    
+/*!
+ * method startsWith
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives1
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &s
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QChar &c
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, remove){
-		/* o public*/
 
-		/* const QRegExp& rx,  */
+ZEND_METHOD(QString, startsWith)
+{
+  ///const QString &ss0, Qt::CaseSensitivity cs = Qt::CaseSensitives1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'startsWith' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &ss0,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)->name == "QRegExp") {
-					QString & return_object = (QString &) obj->remove((const QRegExp&) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* ol public*/
+        RETURN_BOOL(selfpointer->startsWith((const QString &)*cpp_arg_0));
+      }
+#endif
 
-		/* const QString& s, int cs,  */
-		/* ll public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'startsWith' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &ss0, Qt::CaseSensitivity cs = Qt::CaseSensitives1,
+        QString *selfpointer;
 
-		/* int i, int len,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        RETURN_BOOL(selfpointer->startsWith((const QString &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
 
+    }
+  }
+  ///const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'startsWith' is not static");
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &s,
+        QString *selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QString & return_object = (QString &) obj->remove((const QString&) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));
 
+        RETURN_BOOL(selfpointer->startsWith((const QLatin1String &)*cpp_arg_0));
+      }
+#endif
 
-				QString & return_object = (QString &) obj->remove((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'startsWith' is not static");
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->startsWith((const QLatin1String &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'startsWith' is not static");
+          RETURN_NULL();
+        }
+        /// try const QChar &c,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->startsWith((const QChar &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'startsWith' is not static");
+          RETURN_NULL();
+        }
+        /// try const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer->startsWith((const QChar &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::startsWith(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  isEmpty
- *    flags:    c
+/*!
+ * method operator!=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &s
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &s
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, isEmpty){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isEmpty());
-	}
-}
 
-/*********************************
- *    class     QString */
-/*
- *    function  arg
- *    flags:    c
+/*!
+ * method arg
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	qlonglong as0
+ * @param	 int fieldwidth=0s1
+ * @param	 int base=10s2
+ * @param	 const QChar &fillChar = QLatin1Char(' ')s3
+ * 
+ * overloaded args:
+ * @param	qulonglong a
+ * @param	 int fieldwidth=0
+ * @param	 int base=10
+ * @param	 const QChar &fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	long a
+ * @param	 int fieldwidth=0
+ * @param	 int base=10
+ * @param	 const QChar &fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	ulong a
+ * @param	 int fieldwidth=0
+ * @param	 int base=10
+ * @param	 const QChar &fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	int a
+ * @param	 int fieldWidth = 0
+ * @param	 int base = 10
+ * @param	 const QChar &fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	uint a
+ * @param	 int fieldWidth = 0
+ * @param	 int base = 10
+ * @param	 const QChar &fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	short a
+ * @param	 int fieldWidth = 0
+ * @param	 int base = 10
+ * @param	 const QChar &fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	ushort a
+ * @param	 int fieldWidth = 0
+ * @param	 int base = 10
+ * @param	 const QChar &fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	double a
+ * @param	 int fieldWidth = 0
+ * @param	 char fmt = 'g'
+ * @param	 int prec = -1
+ * @param	 const QChar &fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	char a
+ * @param	 int fieldWidth = 0
+ * @param	 const QChar &fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	QChar a
+ * @param	 int fieldWidth = 0
+ * @param	 const QChar &fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	const QString &a
+ * @param	 int fieldWidth = 0
+ * @param	 const QChar &fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	const QString &a1
+ * @param	 const QString &a2
+ * 
+ * overloaded args:
+ * @param	const QString &a1
+ * @param	 const QString &a2
+ * @param	 const QString &a3
+ * 
+ * overloaded args:
+ * @param	const QString &a1
+ * @param	 const QString &a2
+ * @param	 const QString &a3
+ * @param	 const QString &a4
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, arg){
-		/* oo public*/
 
-		/* const QString& a1, const QString& a2,  */
+ZEND_METHOD(QString, arg)
+{
+// notice: unknown argument qlonglong as0, skipped
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+// notice: unknown argument qulonglong a, skipped
 
+// notice: unknown argument long a, skipped
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && Z_OBJCE_P(z_1)->name == "QString") {
-					QString return_object = (QString) obj->arg((const QString&) obj_z_0, (const QString&) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* ooo public*/
+// notice: unknown argument ulong a, skipped
 
-		/* const QString& a1, const QString& a2, const QString& a3,  */
-		/* olo public*/
+  ///int a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
 
-		/* const QString& a, int fieldWidth, const QChar& fillChar,  */
-		/* llo public*/
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try int a,
+      QString *selfpointer;
 
-		/* char a, int fieldWidth, const QChar& fillChar,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
+      *return_object = static_cast < QString > (selfpointer->arg((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try int a, int fieldWidth = 0,
+      QString *selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && Z_OBJCE_P(z_1)->name == "QString" && Z_OBJCE_P(z_2)->name == "QString") {
-					QString return_object = (QString) obj->arg((const QString&) obj_z_0, (const QString&) obj_z_1, (const QString&) obj_z_2);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && Z_OBJCE_P(z_2)->name == "char") {
-					QString return_object = (QString) obj->arg((const QString&) obj_z_0, (int) Z_LVAL_P(z_1), (const QChar&) obj_z_2);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+      *return_object = static_cast < QString > (selfpointer->arg((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try int a, int fieldWidth = 0, int base = 10,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_2)->name == "char") {
-					QString return_object = (QString) obj->arg((char) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QChar&) obj_z_2);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* lllo public*/
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-		/* int a, int fieldWidth, int base, const QChar& fillChar,  */
-		/* ollo public*/
+      *return_object = static_cast < QString > (selfpointer->arg((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try int a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' '),
+      QString *selfpointer;
 
-		/* qlonglong a, int fieldwidth, int base, const QChar& fillChar,  */
-		/* oooo public*/
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_3 = static_cast < QChar * >(php_qt_fetch(arg_3));
+      zend_class_entry *ce;
 
-		/* const QString& a1, const QString& a2, const QString& a3, const QString& a4,  */
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_3 = (QObject*) php_qt_fetch(z_3);
+      *return_object = static_cast < QString > (selfpointer->arg((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (const QChar &)*cpp_arg_3));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
 
-			if(Z_OBJCE_P(z_3)->name == "char") {
-					QString return_object = (QString) obj->arg((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_3 = (QObject*) php_qt_fetch(z_3);
+  ///uint a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try uint a,
+      QString *selfpointer;
 
-			if(Z_OBJCE_P(z_3)->name == "char") {
-					QString return_object = (QString) obj->arg((qlonglong) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_3)->name == "char") {
-					QString return_object = (QString) obj->arg((qulonglong) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_3)->name == "char") {
-					QString return_object = (QString) obj->arg((long) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_3)->name == "char") {
-					QString return_object = (QString) obj->arg((ulong) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_3)->name == "char") {
-					QString return_object = (QString) obj->arg((short) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_3)->name == "char") {
-					QString return_object = (QString) obj->arg((ushort) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
-			QObject* obj_z_3 = (QObject*) php_qt_fetch(z_3);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && Z_OBJCE_P(z_1)->name == "QString" && Z_OBJCE_P(z_2)->name == "QString" && Z_OBJCE_P(z_3)->name == "QString") {
-					QString return_object = (QString) obj->arg((const QString&) obj_z_0, (const QString&) obj_z_1, (const QString&) obj_z_2, (const QString&) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* llllo public*/
+      *return_object = static_cast < QString > (selfpointer->arg((uint) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try uint a, int fieldWidth = 0,
+      QString *selfpointer;
 
-		/* double a, int fieldWidth, char fmt, int prec, const QChar& fillChar,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 5){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzz", &z_0, &z_1, &z_2, &z_3, &z_4) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_4 = (QObject*) php_qt_fetch(z_4);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
+      *return_object = static_cast < QString > (selfpointer->arg((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try uint a, int fieldWidth = 0, int base = 10,
+      QString *selfpointer;
 
-			if(Z_OBJCE_P(z_4)->name == "char") {
-					QString return_object = (QString) obj->arg((double) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (char) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (const QChar&) obj_z_4);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-/*********************************
- *    class     QString */
-/*
- *    function  vsprintf
- *    flags:    
- */
-ZEND_METHOD(QString, vsprintf){
-		/* so public*/
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-		/* const char* format, va_list ap,  */
+      *return_object = static_cast < QString > (selfpointer->arg((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try uint a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' '),
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_3 = static_cast < QChar * >(php_qt_fetch(arg_3));
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-			if(obj_z_1->inherits("va_list")) {
-					QString & return_object = (QString &) obj->vsprintf((const char*) Z_LVAL_P(z_0), (va_list) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+      *return_object =
+        static_cast < QString > (selfpointer->arg((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (const QChar &)*cpp_arg_3));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///short a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try short a,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->arg((short)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try short a, int fieldWidth = 0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->arg((short)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try short a, int fieldWidth = 0, int base = 10,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->arg((short)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try short a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' '),
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_3 = static_cast < QChar * >(php_qt_fetch(arg_3));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object =
+        static_cast < QString > (selfpointer->arg((short)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (const QChar &)*cpp_arg_3));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///ushort a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try ushort a,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->arg((ushort) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try ushort a, int fieldWidth = 0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->arg((ushort) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try ushort a, int fieldWidth = 0, int base = 10,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->arg((ushort) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try ushort a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' '),
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_3 = static_cast < QChar * >(php_qt_fetch(arg_3));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object =
+        static_cast < QString > (selfpointer->arg((ushort) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (const QChar &)*cpp_arg_3));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///double a, int fieldWidth = 0, char fmt = 'g', int prec = -1, const QChar &fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try double a,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->arg((double)Z_DVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try double a, int fieldWidth = 0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->arg((double)Z_DVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try double a, int fieldWidth = 0, char fmt = 'g',
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->arg((double)Z_DVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (char)Z_STRVAL_P(arg_2)[0]));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_STRING && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try double a, int fieldWidth = 0, char fmt = 'g', int prec = -1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object =
+        static_cast < QString > (selfpointer->arg((double)Z_DVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (char)Z_STRVAL_P(arg_2)[0], (int)Z_LVAL_P(arg_3)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_STRING && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try double a, int fieldWidth = 0, char fmt = 'g', int prec = -1, const QChar &fillChar = QLatin1Char(' '),
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_4 = static_cast < QChar * >(php_qt_fetch(arg_4));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object =
+        static_cast < QString >
+        (selfpointer->arg((double)Z_DVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (char)Z_STRVAL_P(arg_2)[0], (int)Z_LVAL_P(arg_3), (const QChar &)*cpp_arg_4));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///char a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try char a,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->arg((char)Z_STRVAL_P(arg_0)[0]));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try char a, int fieldWidth = 0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->arg((char)Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arg' is not static");
+        RETURN_NULL();
+      }
+      /// try char a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' '),
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_2 = static_cast < QChar * >(php_qt_fetch(arg_2));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->arg((char)Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1), (const QChar &)*cpp_arg_2));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///QChar a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'arg' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar a,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->arg((QChar) * cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'arg' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar a, int fieldWidth = 0,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->arg((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'arg' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' '),
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        QChar *cpp_arg_2 = static_cast < QChar * >(php_qt_fetch(arg_2));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->arg((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QChar &)*cpp_arg_2));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'arg' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &a,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->arg((const QString &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'arg' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &a, int fieldWidth = 0,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->arg((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'arg' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' '),
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QChar *cpp_arg_2 = static_cast < QChar * >(php_qt_fetch(arg_2));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->arg((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QChar &)*cpp_arg_2));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &a1, const QString &a2
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'arg' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &a1, const QString &a2,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->arg((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &a1, const QString &a2, const QString &a3
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59) && inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'arg' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &a1, const QString &a2, const QString &a3,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        QString *cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->arg((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1, (const QString &)*cpp_arg_2));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &a1, const QString &a2, const QString &a3, const QString &a4
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    arg_3 = invokeToQString(arg_3);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59) && inherits(Z_OBJCE_P(arg_2), 59) && inherits(Z_OBJCE_P(arg_3), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'arg' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &a1, const QString &a2, const QString &a3, const QString &a4,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        QString *cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
+        QString *cpp_arg_3 = static_cast < QString * >(php_qt_fetch(arg_3));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object =
+          static_cast < QString >
+          (selfpointer->arg((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1, (const QString &)*cpp_arg_2, (const QString &)*cpp_arg_3));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::arg(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toFloat
- *    flags:    c
+/*!
+ * method isEmpty
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, toFloat){
-		/* l public*/
 
-		/* int* ok,  */
+ZEND_METHOD(QString, isEmpty)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isEmpty' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isEmpty());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::isEmpty(...) ");
+}
 
+/*!
+ * method vsprintf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *formats0
+ * @param	 va_list aps1
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
+ */
 
-			RETURN_FLOAT(obj->toFloat((bool*) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+ZEND_METHOD(QString, vsprintf)
+{
+// notice: unknown argument  va_list aps1, skipped
+  php_error(E_ERROR, "could not parse argument in QString::vsprintf(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  isDetached
- *    flags:    c
+/*!
+ * method toFloat
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * 
+ * @access	public
+ * @return	float
+ * @flags	c
  */
-ZEND_METHOD(QString, isDetached){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isDetached());
-	}
+
+ZEND_METHOD(QString, toFloat)
+{
+  ///bool *ok=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toFloat' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_DOUBLE(selfpointer->toFloat());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toFloat' is not static");
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_DOUBLE(selfpointer->toFloat((bool *) & Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::toFloat(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  reserve
- *    flags:    
+/*!
+ * method operator>
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &s
+ * 
+ * overloaded args:
+ * @param	const char *s2
+ * 
+ * overloaded args:
+ * @param	const QByteArray &s
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, reserve){
-		/* l public*/
 
-		/* int size,  */
+/*!
+ * method isDetached
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+ZEND_METHOD(QString, isDetached)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isDetached' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-
-			obj->reserve((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isDetached());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::isDetached(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toULong
- *    flags:    c
+/*!
+ * method toULong
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	ulong
+ * @flags	c
  */
-ZEND_METHOD(QString, toULong){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, toULong)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type ulong");
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      php_error(E_ERROR, "unsupported return type ulong");
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
+      php_error(E_ERROR, "unsupported return type ulong");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::toULong(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+/*!
+ * method reserve
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int sizes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QString, reserve)
+{
+  ///int sizes0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'reserve' is not static");
+        RETURN_NULL();
+      }
+      /// try int sizes0,
+      QString *selfpointer;
 
-			RETURN_ULONG(obj->toULong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->reserve((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::reserve(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toShort
- *    flags:    c
+/*!
+ * method toShort
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	short
+ * @flags	c
  */
-ZEND_METHOD(QString, toShort){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, toShort)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toShort' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toShort());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toShort' is not static");
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toShort((bool *) & Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toShort' is not static");
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0, int base=10s1,
+      QString *selfpointer;
 
-			RETURN_SHORT(obj->toShort((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toShort((bool *) & Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::toShort(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  split
- *    flags:    c
+/*!
+ * method split
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &seps0
+ * @param	 SplitBehavior behavior = KeepEmptyPartss1
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives2
+ * 
+ * overloaded args:
+ * @param	const QChar &sep
+ * @param	 SplitBehavior behavior = KeepEmptyParts
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &sep
+ * @param	 SplitBehavior behavior = KeepEmptyParts
+ * 
+ * @access	public
+ * @return	QStringList
+ * @flags	c
  */
-ZEND_METHOD(QString, split){
-		/* oo public*/
 
-		/* const QRegExp& sep, QString::SplitBehavior behavior,  */
+ZEND_METHOD(QString, split)
+{
+  ///const QString &seps0, SplitBehavior behavior = KeepEmptyPartss1, Qt::CaseSensitivity cs = Qt::CaseSensitives2
+#ifdef PHP_QT_QStringList       // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'split' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &seps0,
+        QString *selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QRegExp") {
-					QStringList return_object = (QStringList) obj->split((const QRegExp&) obj_z_0, (QString::SplitBehavior) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* ool public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-		/* const QString& sep, QString::SplitBehavior behavior, int cs,  */
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QStringList *return_object = new QStringList;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        *return_object = static_cast < QStringList > (selfpointer->split((const QString &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
+    }
+  }
+// notice: unknown argument  SplitBehavior behavior = KeepEmptyPartss1, skipped
+#endif // return type
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QStringList return_object = (QStringList) obj->split((const QString&) obj_z_0, (QString::SplitBehavior) Z_LVAL_P(z_1), (Qt::CaseSensitivity) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+
+  ///const QChar &sep, SplitBehavior behavior = KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QStringList       // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'split' is not static");
+          RETURN_NULL();
+        }
+        /// try const QChar &sep,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QStringList *return_object = new QStringList;
+
+        *return_object = static_cast < QStringList > (selfpointer->split((const QChar &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument  SplitBehavior behavior = KeepEmptyParts, skipped
+#endif // return type
+
+
+  ///const QRegExp &sep, SplitBehavior behavior = KeepEmptyParts
+#ifdef PHP_QT_QStringList       // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'split' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegExp &sep,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QStringList *return_object = new QStringList;
+
+        *return_object = static_cast < QStringList > (selfpointer->split((const QRegExp &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument  SplitBehavior behavior = KeepEmptyParts, skipped
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::split(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  setUnicode
- *    flags:    
+/*!
+ * method setUnicode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QChar *unicodes0
+ * @param	 int sizes1
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
  */
-ZEND_METHOD(QString, setUnicode){
-		/* ol public*/
 
-		/* const QChar* unicode, int size,  */
+ZEND_METHOD(QString, setUnicode)
+{
+  ///const QChar *unicodes0, int sizes1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setUnicode' is not static");
+          RETURN_NULL();
+        }
+        /// try const QChar *unicodes0, int sizes1,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)->name == "char") {
-					QString & return_object = (QString &) obj->setUnicode((const QChar*) obj_z_0, (int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->setUnicode((const QChar *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::setUnicode(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  fromLatin1
- *    flags:    s
+/*!
+ * method fromLatin1
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *s0
+ * @param	 int size = -1s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, fromLatin1){
-		/* sl public*/
 
-		/* const char* , int size,  */
+ZEND_METHOD(QString, fromLatin1)
+{
+  ///const char *s0, int size = -1s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj->fromLatin1( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::fromLatin1((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->fromLatin1((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try const char *s0, int size = -1s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::fromLatin1((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->fromLatin1((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::fromLatin1(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  data
- *    flags:    
+/*!
+ * method toLatin1
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QByteArray
+ * @flags	c
  */
-ZEND_METHOD(QString, data){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				QChar * return_object = (QChar *) obj->data();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, toLatin1)
+{
+  ///
+#ifdef PHP_QT_QByteArray        // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toLatin1' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QByteArray *return_object = new QByteArray;
+
+      *return_object = static_cast < QByteArray > (selfpointer->toLatin1());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::toLatin1(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toLatin1
- *    flags:    c
+/*!
+ * method data
+ * 
+ * @param: -
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar *
+ * @flags	
  */
-ZEND_METHOD(QString, toLatin1){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj->toLatin1(), 1);
-	}
+
+ZEND_METHOD(QString, data)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'data' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast < QChar * >(selfpointer->data());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'data' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast < QChar * >(selfpointer->data());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::data(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  end
- *    flags:    
+/*!
+ * method end
+ * 
+ * @param: -
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	iterator
+ * @flags	
  */
-ZEND_METHOD(QString, end){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_INTPTR(obj->end());
-	}
+
+ZEND_METHOD(QString, end)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type iterator");
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type const_iterator");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::end(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  contains
- *    flags:    c
+/*!
+ * method contains
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives1
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &rx
+ * 
+ * @access	public
+ * @return	QBool
+ * @flags	c
  */
-ZEND_METHOD(QString, contains){
-		/* o public*/
 
-		/* const QRegExp& rx,  */
+ZEND_METHOD(QString, contains)
+{
+  ///QChar cs0, Qt::CaseSensitivity cs = Qt::CaseSensitives1
+#ifdef PHP_QT_QBool             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'contains' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)->name == "QRegExp") {
-				obj->contains((const QRegExp&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ol public*/
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QBool *return_object = new QBool;
 
-		/* const QString& s, int cs,  */
-		/* ll public*/
+        *return_object = static_cast < QBool > (selfpointer->contains((QChar) * cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-		/* char c, int cs,  */
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'contains' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0, Qt::CaseSensitivity cs = Qt::CaseSensitives1,
+        QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QBool *return_object = new QBool;
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				obj->contains((const QString&) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        *return_object = static_cast < QBool > (selfpointer->contains((QChar) * cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
+    }
+  }
+#endif // return type
 
-			obj->contains((char) Z_LVAL_P(z_0) ,(Qt::CaseSensitivity) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
-}
 
-/*********************************
- *    class     QString */
-/*
- *    function  resize
- *    flags:    
- */
-ZEND_METHOD(QString, resize){
-		/* l public*/
+  ///const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QBool             // return type
 
-		/* int size,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'contains' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			obj->resize((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QBool *return_object = new QBool;
+
+        *return_object = static_cast < QBool > (selfpointer->contains((const QString &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'contains' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QBool *return_object = new QBool;
+
+        *return_object = static_cast < QBool > (selfpointer->contains((const QString &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QRegExp &rx
+#ifdef PHP_QT_QBool             // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'contains' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegExp &rx,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QBool *return_object = new QBool;
+
+        *return_object = static_cast < QBool > (selfpointer->contains((const QRegExp &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::contains(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  replace
- *    flags:    
+/*!
+ * method replace
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * @param	 int lens1
+ * @param	 QChar afters2
+ * 
+ * overloaded args:
+ * @param	int i
+ * @param	 int len
+ * @param	 const QChar *s
+ * @param	 int slen
+ * 
+ * overloaded args:
+ * @param	int i
+ * @param	 int len
+ * @param	 const QString &after
+ * 
+ * overloaded args:
+ * @param	QChar before
+ * @param	 QChar after
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	QChar c
+ * @param	 const QString &after
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QString &before
+ * @param	 const QString &after
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &rx
+ * @param	 const QString &after
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
  */
-ZEND_METHOD(QString, replace){
-		/* oo public*/
 
-		/* const QRegExp& rx, const QString& after,  */
+ZEND_METHOD(QString, replace)
+{
+  ///int is0, int lens1, QChar afters2
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_2), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'replace' is not static");
+          RETURN_NULL();
+        }
+        /// try int is0, int lens1, QChar afters2,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_2 = static_cast < QChar * >(php_qt_fetch(arg_2));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)->name == "QRegExp" && Z_OBJCE_P(z_1)->name == "QString") {
-					QString & return_object = (QString &) obj->replace((const QRegExp&) obj_z_0, (const QString&) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* ool public*/
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
 
-		/* const QString& before, const QString& after, int cs,  */
-		/* lol public*/
+        le.ptr = &static_cast < QString & >(selfpointer->replace((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (QChar) * cpp_arg_2));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-		/* char c, const QString& after, int cs,  */
-		/* lll public*/
+    }
+  }
+#endif // return type
 
-		/* int i, int len, char after,  */
-		/* llo public*/
 
-		/* int i, int len, const QString& after,  */
+  ///int i, int len, const QChar *s, int slen
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_2), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'replace' is not static");
+          RETURN_NULL();
+        }
+        /// try int i, int len, const QChar *s, int slen,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_2 = static_cast < QChar * >(php_qt_fetch(arg_2));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && Z_OBJCE_P(z_1)->name == "QString") {
-					QString & return_object = (QString &) obj->replace((const QString&) obj_z_0, (const QString&) obj_z_1, (Qt::CaseSensitivity) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
 
+        le.ptr = &static_cast < QString & >(selfpointer->replace((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QChar *)cpp_arg_2, (int)Z_LVAL_P(arg_3)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-			if(Z_OBJCE_P(z_1)->name == "QString") {
-					QString & return_object = (QString &) obj->replace((char) Z_LVAL_P(z_0), (const QString&) obj_z_1, (Qt::CaseSensitivity) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+    }
+  }
+#endif // return type
 
 
-				QString & return_object = (QString &) obj->replace((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(char) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+  ///int i, int len, const QString &after
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
 
-			if(Z_OBJCE_P(z_2)->name == "QString") {
-					QString & return_object = (QString &) obj->replace((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QString&) obj_z_2);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* llol public*/
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'replace' is not static");
+          RETURN_NULL();
+        }
+        /// try int i, int len, const QString &after,
+        QString *selfpointer;
 
-		/* int i, int len, const QChar* s, int slen,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
+        zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
 
+        le.ptr = &static_cast < QString & >(selfpointer->replace((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-			if(Z_OBJCE_P(z_2)->name == "char") {
-					QString & return_object = (QString &) obj->replace((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QChar*) obj_z_2, (int) Z_LVAL_P(z_3));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+    }
+  }
+#endif // return type
+
+
+  ///QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6) && inherits(Z_OBJCE_P(arg_1), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'replace' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar before, QChar after,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->replace((QChar) * cpp_arg_0, (QChar) * cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QChar
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6) && inherits(Z_OBJCE_P(arg_1), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'replace' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->replace((QChar) * cpp_arg_0, (QChar) * cpp_arg_1, (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///QChar c, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 6) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'replace' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar c, const QString &after,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->replace((QChar) * cpp_arg_0, (const QString &)*cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_1 = invokeToQString(arg_1);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QChar
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 6) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'replace' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar c, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->replace((QChar) * cpp_arg_0, (const QString &)*cpp_arg_1, (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'replace' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &before, const QString &after,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->replace((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_1 = invokeToQString(arg_1);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'replace' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr =
+          &static_cast < QString & >(selfpointer->replace((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1, (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QRegExp &rx, const QString &after
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'replace' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegExp &rx, const QString &after,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->replace((const QRegExp &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::replace(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  fromUtf8
- *    flags:    s
+/*!
+ * method operator+=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	QChar::SpecialCharacter c
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &s
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &s
+ * 
+ * overloaded args:
+ * @param	char c
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &s
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
  */
-ZEND_METHOD(QString, fromUtf8){
-		/* sl public*/
 
-		/* const char* , int size,  */
+/*!
+ * method resize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int sizes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+ZEND_METHOD(QString, resize)
+{
+  ///int sizes0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'resize' is not static");
+        RETURN_NULL();
+      }
+      /// try int sizes0,
+      QString *selfpointer;
 
-
-				QString return_object = (QString) obj->fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->resize((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::resize(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toLong
- *    flags:    c
+/*!
+ * method fromUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *s0
+ * @param	 int size = -1s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, toLong){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, fromUtf8)
+{
+  ///const char *s0, int size = -1s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_LONG(obj->toLong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::fromUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->fromUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try const char *s0, int size = -1s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QString::fromUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->fromUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::fromUtf8(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  detach
- *    flags:    
+/*!
+ * method toLong
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	long
+ * @flags	c
  */
-ZEND_METHOD(QString, detach){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			obj->detach();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QString, toLong)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type long");
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      php_error(E_ERROR, "unsupported return type long");
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
+      php_error(E_ERROR, "unsupported return type long");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::toLong(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  append
- *    flags:    
+/*!
+ * method realloc
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int alloc
+ * 
+ * @access	private
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, append){
-		/* l public*/
 
-		/* char c,  */
-		/* s public*/
+ZEND_METHOD(QString, realloc)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "QString::realloc(...) cannot be called with ''.");
+    }
+  }
+  ///int alloc
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+/// method is private, skip
+      php_error(E_ERROR, "QString::realloc(...) cannot be called with 'int alloc,'.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::realloc(...) ");
+}
 
-		/* const char* s,  */
-		/* o public*/
+/*!
+ * method detach
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-		/* const QString& s,  */
+ZEND_METHOD(QString, detach)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'detach' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->detach());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::detach(...) ");
+}
 
+/*!
+ * method append
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &s
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &s
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
+ */
 
-				QString & return_object = (QString &) obj->append((char) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_STRING){
-			QString *obj = (QString*) PHP_QT_FETCH();
+ZEND_METHOD(QString, append)
+{
+  ///QChar cs0
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'append' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
-				QString & return_object = (QString &) obj->append( (const char*) Z_STRVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QString & return_object = (QString &) obj->append((const QString&) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_0)->name == "QByteArray") {
-					QString & return_object = (QString &) obj->append((const QByteArray&) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+        le.ptr = &static_cast < QString & >(selfpointer->append((QChar) * cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'append' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->append((const QString &)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QLatin1String &s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'append' is not static");
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->append((const QLatin1String &)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const char *s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'append' is not static");
+        RETURN_NULL();
+      }
+      /// try const char *s,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &static_cast < QString & >(selfpointer->append((const char *)&Z_STRVAL_P(arg_0)[0]));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const QByteArray &s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QByteArray
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'append' is not static");
+          RETURN_NULL();
+        }
+        /// try const QByteArray &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QByteArray *cpp_arg_0 = static_cast < QByteArray * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->append((const QByteArray &)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::append(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  mid
- *    flags:    c
+/*!
+ * method operator<=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &s
+ * 
+ * overloaded args:
+ * @param	const char *s2
+ * 
+ * overloaded args:
+ * @param	const QByteArray &s
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, mid){
-		/* ll public*/
 
-		/* int i, int len,  */
+/*!
+ * method multiArg
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int numArgss0
+ * @param	 const QString **argss1
+ * 
+ * @access	private
+ * @return	QString
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+ZEND_METHOD(QString, multiArg)
+{
+  ///int numArgss0, const QString **argss1
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
 
-				QString return_object = (QString) obj->mid((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_1), 59)) {
+/// method is private, skip
+        php_error(E_ERROR, "QString::multiArg(...) cannot be called with 'int numArgss0, const QString **argss1,'.");
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::multiArg(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toDouble
- *    flags:    c
+/*!
+ * method toDouble
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * 
+ * @access	public
+ * @return	double
+ * @flags	c
  */
-ZEND_METHOD(QString, toDouble){
-		/* l public*/
 
-		/* int* ok,  */
+ZEND_METHOD(QString, toDouble)
+{
+  ///bool *ok=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toDouble' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_DOUBLE(selfpointer->toDouble());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toDouble' is not static");
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_DOUBLE(selfpointer->toDouble((bool *) & Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::toDouble(...) ");
+}
 
-			RETURN_DOUBLE(obj->toDouble((bool*) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+/*!
+ * method mid
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * @param	 int len = -1s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
+
+ZEND_METHOD(QString, mid)
+{
+  ///int is0, int len = -1s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'mid' is not static");
+        RETURN_NULL();
+      }
+      /// try int is0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->mid((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'mid' is not static");
+        RETURN_NULL();
+      }
+      /// try int is0, int len = -1s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->mid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::mid(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  fill
- *    flags:    
+/*!
+ * method fill
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * @param	 int size = -1s1
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
  */
-ZEND_METHOD(QString, fill){
-		/* ll public*/
 
-		/* char c, int size,  */
+ZEND_METHOD(QString, fill)
+{
+  ///QChar cs0, int size = -1s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'fill' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-				QString & return_object = (QString &) obj->fill((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->fill((QChar) * cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'fill' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0, int size = -1s1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &static_cast < QString & >(selfpointer->fill((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::fill(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  rightJustified
- *    flags:    c
+/*!
+ * method free
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Data *s0
+ * 
+ * @access	private
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QString, rightJustified){
-		/* lll public*/
 
-		/* int width, char fill, int trunc,  */
+ZEND_METHOD(QString, free)
+{
+// notice: unknown argument Data *s0, skipped
+  php_error(E_ERROR, "could not parse argument in QString::free(...) ");
+}
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+/*!
+ * method toLower
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
+ZEND_METHOD(QString, toLower)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-				QString return_object = (QString) obj->rightJustified((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(bool) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toLower' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->toLower());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::toLower(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toLower
- *    flags:    c
+/*!
+ * method rightJustified
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int widths0
+ * @param	 QChar fill = QLatin1Char(' ')s1
+ * @param	 bool trunc = falses2
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, toLower){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->toLower();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, rightJustified)
+{
+  ///int widths0, QChar fill = QLatin1Char(' ')s1, bool trunc = falses2
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'rightJustified' is not static");
+        RETURN_NULL();
+      }
+      /// try int widths0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->rightJustified((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'rightJustified' is not static");
+        RETURN_NULL();
+      }
+      /// try int widths0, QChar fill = QLatin1Char(' ')s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->rightJustified((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'rightJustified' is not static");
+        RETURN_NULL();
+      }
+      /// try int widths0, QChar fill = QLatin1Char(' ')s1, bool trunc = falses2,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->rightJustified((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1, (bool) Z_LVAL_P(arg_2)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::rightJustified(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  lastIndexOf
- *    flags:    c
+/*!
+ * method lastIndexOf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * @param	 int from = -1s1
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives2
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * @param	 int from = -1
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &
+ * @param	 int from = -1
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QString, lastIndexOf){
-		/* ol public*/
 
-		/* const QRegExp& , int from,  */
+ZEND_METHOD(QString, lastIndexOf)
+{
+  ///QChar cs0, int from = -1s1, Qt::CaseSensitivity cs = Qt::CaseSensitives2
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'lastIndexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
 
+        RETURN_LONG(selfpointer->lastIndexOf((QChar) * cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QRegExp") {
-				RETURN_LONG(obj->lastIndexOf((const QRegExp&) obj_z_0, (int) Z_LVAL_P(z_1)));
-			}
-			}
-		}
-	}
-		/* oll public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'lastIndexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0, int from = -1s1,
+        QString *selfpointer;
 
-		/* const QString& s, int from, int cs,  */
-		/* lll public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
 
-		/* char c, int from, int cs,  */
+        RETURN_LONG(selfpointer->lastIndexOf((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'lastIndexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0, int from = -1s1, Qt::CaseSensitivity cs = Qt::CaseSensitives2,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				RETURN_LONG(obj->lastIndexOf((const QString&) obj_z_0, (int) Z_LVAL_P(z_1), (Qt::CaseSensitivity) Z_LVAL_P(z_2)));
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        RETURN_LONG(selfpointer->lastIndexOf((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+      }
+#endif
 
+    }
+  }
+  ///const QString &s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-			RETURN_LONG(obj->lastIndexOf((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(Qt::CaseSensitivity) Z_LVAL_P(z_2)));
-			}
-		}
-	}
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'lastIndexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->lastIndexOf((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'lastIndexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s, int from = -1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->lastIndexOf((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'lastIndexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->lastIndexOf((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  ///const QRegExp &, int from = -1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'lastIndexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegExp &,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->lastIndexOf((const QRegExp &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'lastIndexOf' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegExp &, int from = -1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->lastIndexOf((const QRegExp &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::lastIndexOf(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  unicode
- *    flags:    c
+/*!
+ * method unicode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QChar *
+ * @flags	c
  */
-ZEND_METHOD(QString, unicode){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				const QChar * return_object = (const QChar *) obj->unicode();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, unicode)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'unicode' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast < QChar * >(selfpointer->unicode());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::unicode(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  at
- *    flags:    c
+/*!
+ * method at
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * 
+ * @access	public
+ * @return	const QChar
+ * @flags	c
  */
-ZEND_METHOD(QString, at){
-		/* l public*/
 
-		/* int i,  */
+ZEND_METHOD(QString, at)
+{
+  ///int is0
+#ifdef PHP_QT_QChar             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'at' is not static");
+        RETURN_NULL();
+      }
+      /// try int is0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj->at((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QChar *return_object = new QChar;
+
+      *return_object = const_cast < QChar > (selfpointer->at((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::at(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  begin
- *    flags:    
+/*!
+ * method begin
+ * 
+ * @param: -
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	iterator
+ * @flags	
  */
-ZEND_METHOD(QString, begin){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_INTPTR(obj->begin());
-	}
+
+ZEND_METHOD(QString, begin)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type iterator");
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type const_iterator");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::begin(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  push_back
- *    flags:    
+/*!
+ * method sprintf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *formats0
+ * @param	 ...  ...s1
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
  */
-ZEND_METHOD(QString, push_back){
-		/* l public*/
 
-		/* char c,  */
-		/* o public*/
+ZEND_METHOD(QString, sprintf)
+{
+// notice: unknown argument  ...  ...s1, skipped
+  php_error(E_ERROR, "could not parse argument in QString::sprintf(...) ");
+}
 
-		/* const QString& s,  */
+/*!
+ * method push_back
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+ZEND_METHOD(QString, push_back)
+{
+  ///QChar cs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'push_back' is not static");
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
 
-			obj->push_back((char) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        RETURN_VOID(selfpointer->push_back((QChar) * cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///const QString &s
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-				obj->push_back((const QString&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'push_back' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->push_back((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::push_back(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  capacity
- *    flags:    c
+/*!
+ * method capacity
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QString, capacity){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_LONG(obj->capacity());
-	}
+
+ZEND_METHOD(QString, capacity)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'capacity' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->capacity());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::capacity(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  constBegin
- *    flags:    c
+/*!
+ * method constBegin
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const_iterator
+ * @flags	c
  */
-ZEND_METHOD(QString, constBegin){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			obj->constBegin();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QString, constBegin)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type const_iterator");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::constBegin(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toLocal8Bit
- *    flags:    c
+/*!
+ * method toInt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QString, toLocal8Bit){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj->toLocal8Bit(), 1);
-	}
+
+ZEND_METHOD(QString, toInt)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toInt' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toInt());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toInt' is not static");
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toInt((bool *) & Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toInt' is not static");
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0, int base=10s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toInt((bool *) & Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::toInt(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toInt
- *    flags:    c
+/*!
+ * method toLocal8Bit
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QByteArray
+ * @flags	c
  */
-ZEND_METHOD(QString, toInt){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, toLocal8Bit)
+{
+  ///
+#ifdef PHP_QT_QByteArray        // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toLocal8Bit' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_LONG(obj->toInt((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QByteArray *return_object = new QByteArray;
+
+      *return_object = static_cast < QByteArray > (selfpointer->toLocal8Bit());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QString::toLocal8Bit(...) ");
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  isNull
- *    flags:    c
+/*!
+ * method isNull
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, isNull){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isNull());
-	}
+
+ZEND_METHOD(QString, isNull)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isNull' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isNull());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QString::isNull(...) ");
 }
 
+/*!
+ * method operator=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	const QString &
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &
+ * 
+ * overloaded args:
+ * @param	const char *ch
+ * 
+ * overloaded args:
+ * @param	const QByteArray &a
+ * 
+ * overloaded args:
+ * @param	char c
+ * 
+ * overloaded args:
+ * @param	const Null &
+ * 
+ * overloaded args:
+ * @param	const char *ch
+ * 
+ * overloaded args:
+ * @param	const QByteArray &a
+ * 
+ * @access	public
+ * @return	QString &
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QString);
-
+/*!
+ * method operator>=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &s
+ * 
+ * overloaded args:
+ * @param	const char *s2
+ * 
+ * overloaded args:
+ * @param	const QByteArray &s
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */

Modified: trunk/qt/classes/qt.cpp
===================================================================
--- trunk/qt/classes/qt.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qt.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,1167 +19,206 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Qt.cpp - Qt PHP implementation.
- * begin           : Wed Jan 11 20:29:53 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <Qt>
 #include "../php_qt.h"
 
 
-
-/*		public enumGlobalColor:long {
-			GlobalColor = 0,
-			GlobalColor = 1,
-			GlobalColor = 2,
-			GlobalColor = 3,
-			GlobalColor = 4,
-			GlobalColor = 5,
-			GlobalColor = 6,
-			GlobalColor = 7,
-			GlobalColor = 8,
-			GlobalColor = 9,
-			GlobalColor = 10,
-			GlobalColor = 11,
-			GlobalColor = 12,
-			GlobalColor = 13,
-			GlobalColor = 14,
-			GlobalColor = 15,
-			GlobalColor = 16,
-			GlobalColor = 17,
-			GlobalColor = 18,
-			GlobalColor = 19
-		}
-*/
-
-/*		public enumKeyboardModifier:long {
-			NoModifier = 0x00000000,
-			ShiftModifier = 0x02000000,
-			ControlModifier = 0x04000000,
-			AltModifier = 0x08000000,
-			MetaModifier = 0x10000000,
-			KeypadModifier = 0x20000000,
-			KeyboardModifierMask = 0xfe000000
-		}
-*/
-
-/*		public enumModifier:long {
-			META = Qt.MetaModifier,
-			SHIFT = Qt.ShiftModifier,
-			CTRL = Qt.ControlModifier,
-			ALT = Qt.AltModifier,
-			MODIFIER_MASK = KeyboardModifierMask,
-			UNICODE_ACCEL = 0x00000000
-		}
-*/
-
-/*		public enumMouseButton:long {
-			NoButton = 0x00000000,
-			LeftButton = 0x00000001,
-			RightButton = 0x00000002,
-			MidButton = 0x00000004,
-			XButton1 = 0x00000008,
-			XButton2 = 0x00000010,
-			MouseButtonMask = 0x000000ff
-		}
-*/
-
-/*		public enumOrientation:long {
-			Horizontal = 0x1,
-			Vertical = 0x2
-		}
-*/
-
-/*		public enumFocusPolicy:long {
-			NoFocus = 0,
-			TabFocus = 0x1,
-			ClickFocus = 0x2,
-			StrongFocus = TabFocus|ClickFocus|0x8,
-			WheelFocus = StrongFocus|0x4
-		}
-*/
-
-/*		public enumSortOrder:long {
-			SortOrder = 0,
-			SortOrder = 1
-		}
-*/
-
-/*		public enumAlignmentFlag:long {
-			AlignLeft = 0x0001,
-			AlignLeading = AlignLeft,
-			AlignRight = 0x0002,
-			AlignTrailing = AlignRight,
-			AlignHCenter = 0x0004,
-			AlignJustify = 0x0008,
-			AlignAbsolute = 0x0010,
-			AlignHorizontal_Mask = AlignLeft|AlignRight|AlignHCenter|AlignJustify|AlignAbsolute,
-			AlignTop = 0x0020,
-			AlignBottom = 0x0040,
-			AlignVCenter = 0x0080,
-			AlignVertical_Mask = AlignTop|AlignBottom|AlignVCenter,
-			AlignCenter = AlignVCenter|AlignHCenter
-		}
-*/
-
-/*		public enumTextFlag:long {
-			TextSingleLine = 0x0100,
-			TextDontClip = 0x0200,
-			TextExpandTabs = 0x0400,
-			TextShowMnemonic = 0x0800,
-			TextWordWrap = 0x1000,
-			TextWrapAnywhere = 0x2000,
-			TextDontPrint = 0x4000,
-			TextIncludeTrailingSpaces = 0x08000000,
-			TextHideMnemonic = 0x8000
-		}
-*/
-
-/*		public enumTextElideMode:long {
-			TextElideMode = 0,
-			TextElideMode = 1,
-			TextElideMode = 2
-		}
-*/
-
-/*		public enumWindowType:long {
-			Widget = 0x00000000,
-			Window = 0x00000001,
-			Dialog = 0x00000002|Window,
-			Sheet = 0x00000004|Window,
-			Drawer = 0x00000006|Window,
-			Popup = 0x00000008|Window,
-			Tool = 0x0000000a|Window,
-			ToolTip = 0x0000000c|Window,
-			SplashScreen = 0x0000000e|Window,
-			Desktop = 0x00000010|Window,
-			SubWindow = 0x00000012,
-			WindowType_Mask = 0x000000ff,
-			MSWindowsFixedSizeDialogHint = 0x00000100,
-			MSWindowsOwnDC = 0x00000200,
-			X11BypassWindowManagerHint = 0x00000400,
-			FramelessWindowHint = 0x00000800,
-			WindowTitleHint = 0x00001000,
-			WindowSystemMenuHint = 0x00002000,
-			WindowMinimizeButtonHint = 0x00004000,
-			WindowMaximizeButtonHint = 0x00008000,
-			WindowMinMaxButtonsHint = WindowMinimizeButtonHint|WindowMaximizeButtonHint,
-			WindowContextHelpButtonHint = 0x00010000,
-			WindowShadeButtonHint = 0x00020000,
-			WindowStaysOnTopHint = 0x00040000
-		}
-*/
-
-/*		public enumWindowState:long {
-			WindowNoState = 0x00000000,
-			WindowMinimized = 0x00000001,
-			WindowMaximized = 0x00000002,
-			WindowFullScreen = 0x00000004,
-			WindowActive = 0x00000008
-		}
-*/
-
-/*		public enumWidgetAttribute:long {
-			WA_Disabled = 0,
-			WA_UnderMouse = 1,
-			WA_MouseTracking = 2,
-			WA_ContentsPropagated = 3,
-			WA_OpaquePaintEvent = 4,
-			WA_NoBackground = WA_OpaquePaintEvent,
-			WA_StaticContents = 5,
-			WA_LaidOut = 7,
-			WA_PaintOnScreen = 8,
-			WA_NoSystemBackground = 9,
-			WA_UpdatesDisabled = 10,
-			WA_Mapped = 11,
-			WA_MacNoClickThrough = 12,
-			WA_PaintOutsidePaintEvent = 13,
-			WA_InputMethodEnabled = 14,
-			WA_WState_Visible = 15,
-			WA_WState_Hidden = 16,
-			WA_ForceDisabled = 32,
-			WA_KeyCompression = 33,
-			WA_PendingMoveEvent = 34,
-			WA_PendingResizeEvent = 35,
-			WA_SetPalette = 36,
-			WA_SetFont = 37,
-			WA_SetCursor = 38,
-			WA_NoChildEventsFromChildren = 39,
-			WA_WindowModified = 41,
-			WA_Resized = 42,
-			WA_Moved = 43,
-			WA_PendingUpdate = 44,
-			WA_InvalidSize = 45,
-			WA_MacMetalStyle = 46,
-			WA_CustomWhatsThis = 47,
-			WA_LayoutOnEntireRect = 48,
-			WA_OutsideWSRange = 49,
-			WA_GrabbedShortcut = 50,
-			WA_TransparentForMouseEvents = 51,
-			WA_PaintUnclipped = 52,
-			WA_SetWindowIcon = 53,
-			WA_NoMouseReplay = 54,
-			WA_DeleteOnClose = 55,
-			WA_RightToLeft = 56,
-			WA_SetLayoutDirection = 57,
-			WA_NoChildEventsForParent = 58,
-			WA_ForceUpdatesDisabled = 59,
-			WA_WState_Created = 60,
-			WA_WState_CompressKeys = 61,
-			WA_WState_InPaintEvent = 62,
-			WA_WState_Reparented = 63,
-			WA_WState_ConfigPending = 64,
-			WA_WState_Polished = 66,
-			WA_WState_DND = 67,
-			WA_WState_OwnSizePolicy = 68,
-			WA_WState_ExplicitShowHide = 69,
-			WA_ShowModal = 70,
-			WA_MouseNoMask = 71,
-			WA_GroupLeader = 72,
-			WA_NoMousePropagation = 73,
-			WA_Hover = 74,
-			WA_InputMethodTransparent = 75,
-			WA_QuitOnClose = 76,
-			WA_KeyboardFocusChange = 77,
-			WA_AcceptDrops = 78,
-			WA_DropSiteRegistered = 79,
-			WA_ForceAcceptDrops = WA_DropSiteRegistered,
-			WA_WindowPropagation = 80,
-			WA_NoX11EventCompression = 81,
-			WA_TintedBackground = 82,
-			WidgetAttribute = 67
-		}
-*/
-
-/*		public enumImageConversionFlag:long {
-			ColorMode_Mask = 0x00000003,
-			AutoColor = 0x00000000,
-			ColorOnly = 0x00000003,
-			MonoOnly = 0x00000002,
-			AlphaDither_Mask = 0x0000000c,
-			ThresholdAlphaDither = 0x00000000,
-			OrderedAlphaDither = 0x00000004,
-			DiffuseAlphaDither = 0x00000008,
-			NoAlpha = 0x0000000c,
-			Dither_Mask = 0x00000030,
-			DiffuseDither = 0x00000000,
-			OrderedDither = 0x00000010,
-			ThresholdDither = 0x00000020,
-			DitherMode_Mask = 0x000000c0,
-			AutoDither = 0x00000000,
-			PreferDither = 0x00000040,
-			AvoidDither = 0x00000080
-		}
-*/
-
-/*		public enumBGMode:long {
-			BGMode = 0,
-			BGMode = 1
-		}
-*/
-
-/*		public enumKey:long {
-			Key_Escape = 0x01000000,
-			Key_Tab = 0x01000001,
-			Key_Backtab = 0x01000002,
-			Key_Backspace = 0x01000003,
-			Key_Return = 0x01000004,
-			Key_Enter = 0x01000005,
-			Key_Insert = 0x01000006,
-			Key_Delete = 0x01000007,
-			Key_Pause = 0x01000008,
-			Key_Print = 0x01000009,
-			Key_SysReq = 0x0100000a,
-			Key_Clear = 0x0100000b,
-			Key_Home = 0x01000010,
-			Key_End = 0x01000011,
-			Key_Left = 0x01000012,
-			Key_Up = 0x01000013,
-			Key_Right = 0x01000014,
-			Key_Down = 0x01000015,
-			Key_PageUp = 0x01000016,
-			Key_PageDown = 0x01000017,
-			Key_Shift = 0x01000020,
-			Key_Control = 0x01000021,
-			Key_Meta = 0x01000022,
-			Key_Alt = 0x01000023,
-			Key_CapsLock = 0x01000024,
-			Key_NumLock = 0x01000025,
-			Key_ScrollLock = 0x01000026,
-			Key_F1 = 0x01000030,
-			Key_F2 = 0x01000031,
-			Key_F3 = 0x01000032,
-			Key_F4 = 0x01000033,
-			Key_F5 = 0x01000034,
-			Key_F6 = 0x01000035,
-			Key_F7 = 0x01000036,
-			Key_F8 = 0x01000037,
-			Key_F9 = 0x01000038,
-			Key_F10 = 0x01000039,
-			Key_F11 = 0x0100003a,
-			Key_F12 = 0x0100003b,
-			Key_F13 = 0x0100003c,
-			Key_F14 = 0x0100003d,
-			Key_F15 = 0x0100003e,
-			Key_F16 = 0x0100003f,
-			Key_F17 = 0x01000040,
-			Key_F18 = 0x01000041,
-			Key_F19 = 0x01000042,
-			Key_F20 = 0x01000043,
-			Key_F21 = 0x01000044,
-			Key_F22 = 0x01000045,
-			Key_F23 = 0x01000046,
-			Key_F24 = 0x01000047,
-			Key_F25 = 0x01000048,
-			Key_F26 = 0x01000049,
-			Key_F27 = 0x0100004a,
-			Key_F28 = 0x0100004b,
-			Key_F29 = 0x0100004c,
-			Key_F30 = 0x0100004d,
-			Key_F31 = 0x0100004e,
-			Key_F32 = 0x0100004f,
-			Key_F33 = 0x01000050,
-			Key_F34 = 0x01000051,
-			Key_F35 = 0x01000052,
-			Key_Super_L = 0x01000053,
-			Key_Super_R = 0x01000054,
-			Key_Menu = 0x01000055,
-			Key_Hyper_L = 0x01000056,
-			Key_Hyper_R = 0x01000057,
-			Key_Help = 0x01000058,
-			Key_Direction_L = 0x01000059,
-			Key_Direction_R = 0x01000060,
-			Key_Space = 0x20,
-			Key_Any = Key_Space,
-			Key_Exclam = 0x21,
-			Key_QuoteDbl = 0x22,
-			Key_NumberSign = 0x23,
-			Key_Dollar = 0x24,
-			Key_Percent = 0x25,
-			Key_Ampersand = 0x26,
-			Key_Apostrophe = 0x27,
-			Key_ParenLeft = 0x28,
-			Key_ParenRight = 0x29,
-			Key_Asterisk = 0x2a,
-			Key_Plus = 0x2b,
-			Key_Comma = 0x2c,
-			Key_Minus = 0x2d,
-			Key_Period = 0x2e,
-			Key_Slash = 0x2f,
-			Key_0 = 0x30,
-			Key_1 = 0x31,
-			Key_2 = 0x32,
-			Key_3 = 0x33,
-			Key_4 = 0x34,
-			Key_5 = 0x35,
-			Key_6 = 0x36,
-			Key_7 = 0x37,
-			Key_8 = 0x38,
-			Key_9 = 0x39,
-			Key_Colon = 0x3a,
-			Key_Semicolon = 0x3b,
-			Key_Less = 0x3c,
-			Key_Equal = 0x3d,
-			Key_Greater = 0x3e,
-			Key_Question = 0x3f,
-			Key_At = 0x40,
-			Key_A = 0x41,
-			Key_B = 0x42,
-			Key_C = 0x43,
-			Key_D = 0x44,
-			Key_E = 0x45,
-			Key_F = 0x46,
-			Key_G = 0x47,
-			Key_H = 0x48,
-			Key_I = 0x49,
-			Key_J = 0x4a,
-			Key_K = 0x4b,
-			Key_L = 0x4c,
-			Key_M = 0x4d,
-			Key_N = 0x4e,
-			Key_O = 0x4f,
-			Key_P = 0x50,
-			Key_Q = 0x51,
-			Key_R = 0x52,
-			Key_S = 0x53,
-			Key_T = 0x54,
-			Key_U = 0x55,
-			Key_V = 0x56,
-			Key_W = 0x57,
-			Key_X = 0x58,
-			Key_Y = 0x59,
-			Key_Z = 0x5a,
-			Key_BracketLeft = 0x5b,
-			Key_Backslash = 0x5c,
-			Key_BracketRight = 0x5d,
-			Key_AsciiCircum = 0x5e,
-			Key_Underscore = 0x5f,
-			Key_QuoteLeft = 0x60,
-			Key_BraceLeft = 0x7b,
-			Key_Bar = 0x7c,
-			Key_BraceRight = 0x7d,
-			Key_AsciiTilde = 0x7e,
-			Key_nobreakspace = 0x0a0,
-			Key_exclamdown = 0x0a1,
-			Key_cent = 0x0a2,
-			Key_sterling = 0x0a3,
-			Key_currency = 0x0a4,
-			Key_yen = 0x0a5,
-			Key_brokenbar = 0x0a6,
-			Key_section = 0x0a7,
-			Key_diaeresis = 0x0a8,
-			Key_copyright = 0x0a9,
-			Key_ordfeminine = 0x0aa,
-			Key_guillemotleft = 0x0ab,
-			Key_notsign = 0x0ac,
-			Key_hyphen = 0x0ad,
-			Key_registered = 0x0ae,
-			Key_macron = 0x0af,
-			Key_degree = 0x0b0,
-			Key_plusminus = 0x0b1,
-			Key_twosuperior = 0x0b2,
-			Key_threesuperior = 0x0b3,
-			Key_acute = 0x0b4,
-			Key_mu = 0x0b5,
-			Key_paragraph = 0x0b6,
-			Key_periodcentered = 0x0b7,
-			Key_cedilla = 0x0b8,
-			Key_onesuperior = 0x0b9,
-			Key_masculine = 0x0ba,
-			Key_guillemotright = 0x0bb,
-			Key_onequarter = 0x0bc,
-			Key_onehalf = 0x0bd,
-			Key_threequarters = 0x0be,
-			Key_questiondown = 0x0bf,
-			Key_Agrave = 0x0c0,
-			Key_Aacute = 0x0c1,
-			Key_Acircumflex = 0x0c2,
-			Key_Atilde = 0x0c3,
-			Key_Adiaeresis = 0x0c4,
-			Key_Aring = 0x0c5,
-			Key_AE = 0x0c6,
-			Key_Ccedilla = 0x0c7,
-			Key_Egrave = 0x0c8,
-			Key_Eacute = 0x0c9,
-			Key_Ecircumflex = 0x0ca,
-			Key_Ediaeresis = 0x0cb,
-			Key_Igrave = 0x0cc,
-			Key_Iacute = 0x0cd,
-			Key_Icircumflex = 0x0ce,
-			Key_Idiaeresis = 0x0cf,
-			Key_ETH = 0x0d0,
-			Key_Ntilde = 0x0d1,
-			Key_Ograve = 0x0d2,
-			Key_Oacute = 0x0d3,
-			Key_Ocircumflex = 0x0d4,
-			Key_Otilde = 0x0d5,
-			Key_Odiaeresis = 0x0d6,
-			Key_multiply = 0x0d7,
-			Key_Ooblique = 0x0d8,
-			Key_Ugrave = 0x0d9,
-			Key_Uacute = 0x0da,
-			Key_Ucircumflex = 0x0db,
-			Key_Udiaeresis = 0x0dc,
-			Key_Yacute = 0x0dd,
-			Key_THORN = 0x0de,
-			Key_ssharp = 0x0df,
-			Key_division = 0x0f7,
-			Key_ydiaeresis = 0x0ff,
-			Key_AltGr = 0x01001103,
-			Key_Multi_key = 0x01001120,
-			Key_Codeinput = 0x01001137,
-			Key_SingleCandidate = 0x0100113c,
-			Key_MultipleCandidate = 0x0100113d,
-			Key_PreviousCandidate = 0x0100113e,
-			Key_Mode_switch = 0x0100117e,
-			Key_Kanji = 0x01001121,
-			Key_Muhenkan = 0x01001122,
-			Key_Henkan = 0x01001123,
-			Key_Romaji = 0x01001124,
-			Key_Hiragana = 0x01001125,
-			Key_Katakana = 0x01001126,
-			Key_Hiragana_Katakana = 0x01001127,
-			Key_Zenkaku = 0x01001128,
-			Key_Hankaku = 0x01001129,
-			Key_Zenkaku_Hankaku = 0x0100112a,
-			Key_Touroku = 0x0100112b,
-			Key_Massyo = 0x0100112c,
-			Key_Kana_Lock = 0x0100112d,
-			Key_Kana_Shift = 0x0100112e,
-			Key_Eisu_Shift = 0x0100112f,
-			Key_Eisu_toggle = 0x01001130,
-			Key_Hangul = 0x01001131,
-			Key_Hangul_Start = 0x01001132,
-			Key_Hangul_End = 0x01001133,
-			Key_Hangul_Hanja = 0x01001134,
-			Key_Hangul_Jamo = 0x01001135,
-			Key_Hangul_Romaja = 0x01001136,
-			Key_Hangul_Jeonja = 0x01001138,
-			Key_Hangul_Banja = 0x01001139,
-			Key_Hangul_PreHanja = 0x0100113a,
-			Key_Hangul_PostHanja = 0x0100113b,
-			Key_Hangul_Special = 0x0100113f,
-			Key_Dead_Grave = 0x01001250,
-			Key_Dead_Acute = 0x01001251,
-			Key_Dead_Circumflex = 0x01001252,
-			Key_Dead_Tilde = 0x01001253,
-			Key_Dead_Macron = 0x01001254,
-			Key_Dead_Breve = 0x01001255,
-			Key_Dead_Abovedot = 0x01001256,
-			Key_Dead_Diaeresis = 0x01001257,
-			Key_Dead_Abovering = 0x01001258,
-			Key_Dead_Doubleacute = 0x01001259,
-			Key_Dead_Caron = 0x0100125a,
-			Key_Dead_Cedilla = 0x0100125b,
-			Key_Dead_Ogonek = 0x0100125c,
-			Key_Dead_Iota = 0x0100125d,
-			Key_Dead_Voiced_Sound = 0x0100125e,
-			Key_Dead_Semivoiced_Sound = 0x0100125f,
-			Key_Dead_Belowdot = 0x01001260,
-			Key_Dead_Hook = 0x01001261,
-			Key_Dead_Horn = 0x01001262,
-			Key_Back = 0x01000061,
-			Key_Forward = 0x01000062,
-			Key_Stop = 0x01000063,
-			Key_Refresh = 0x01000064,
-			Key_VolumeDown = 0x01000070,
-			Key_VolumeMute = 0x01000071,
-			Key_VolumeUp = 0x01000072,
-			Key_BassBoost = 0x01000073,
-			Key_BassUp = 0x01000074,
-			Key_BassDown = 0x01000075,
-			Key_TrebleUp = 0x01000076,
-			Key_TrebleDown = 0x01000077,
-			Key_MediaPlay = 0x01000080,
-			Key_MediaStop = 0x01000081,
-			Key_MediaPrevious = 0x01000082,
-			Key_MediaNext = 0x01000083,
-			Key_MediaRecord = 0x01000084,
-			Key_HomePage = 0x01000090,
-			Key_Favorites = 0x01000091,
-			Key_Search = 0x01000092,
-			Key_Standby = 0x01000093,
-			Key_OpenUrl = 0x01000094,
-			Key_LaunchMail = 0x010000a0,
-			Key_LaunchMedia = 0x010000a1,
-			Key_Launch0 = 0x010000a2,
-			Key_Launch1 = 0x010000a3,
-			Key_Launch2 = 0x010000a4,
-			Key_Launch3 = 0x010000a5,
-			Key_Launch4 = 0x010000a6,
-			Key_Launch5 = 0x010000a7,
-			Key_Launch6 = 0x010000a8,
-			Key_Launch7 = 0x010000a9,
-			Key_Launch8 = 0x010000aa,
-			Key_Launch9 = 0x010000ab,
-			Key_LaunchA = 0x010000ac,
-			Key_LaunchB = 0x010000ad,
-			Key_LaunchC = 0x010000ae,
-			Key_LaunchD = 0x010000af,
-			Key_LaunchE = 0x010000b0,
-			Key_LaunchF = 0x010000b1,
-			Key_MediaLast = 0x0100ffff,
-			Key_Select = 0x01010000,
-			Key_Yes = 0x01010001,
-			Key_No = 0x01010002,
-			Key_Context1 = 0x01100000,
-			Key_Context2 = 0x01100001,
-			Key_Context3 = 0x01100002,
-			Key_Context4 = 0x01100003,
-			Key_Call = 0x01100004,
-			Key_Hangup = 0x01100005,
-			Key_Flip = 0x01100006,
-			Key_unknown = 0x01ffffff
-		}
-*/
-
-/*		public enumArrowType:long {
-			ArrowType = 0,
-			ArrowType = 1,
-			ArrowType = 2,
-			ArrowType = 3,
-			ArrowType = 4
-		}
-*/
-
-/*		public enumPenStyle:long {
-			PenStyle = 0,
-			PenStyle = 1,
-			PenStyle = 2,
-			PenStyle = 3,
-			PenStyle = 4,
-			PenStyle = 5,
-			PenStyle = 6,
-			MPenStyle = 0x0f
-		}
-*/
-
-/*		public enumPenCapStyle:long {
-			FlatCap = 0x00,
-			SquareCap = 0x10,
-			RoundCap = 0x20,
-			MPenCapStyle = 0x30
-		}
-*/
-
-/*		public enumPenJoinStyle:long {
-			MiterJoin = 0x00,
-			BevelJoin = 0x40,
-			RoundJoin = 0x80,
-			MPenJoinStyle = 0xc0
-		}
-*/
-
-/*		public enumBrushStyle:long {
-			BrushStyle = 0,
-			BrushStyle = 1,
-			BrushStyle = 2,
-			BrushStyle = 3,
-			BrushStyle = 4,
-			BrushStyle = 5,
-			BrushStyle = 6,
-			BrushStyle = 7,
-			BrushStyle = 8,
-			BrushStyle = 9,
-			BrushStyle = 10,
-			BrushStyle = 11,
-			BrushStyle = 12,
-			BrushStyle = 13,
-			BrushStyle = 14,
-			BrushStyle = 15,
-			BrushStyle = 16,
-			BrushStyle = 17,
-			TexturePattern = 24
-		}
-*/
-
-/*		public enumUIEffect:long {
-			UIEffect = 0,
-			UIEffect = 1,
-			UIEffect = 2,
-			UIEffect = 3,
-			UIEffect = 4,
-			UIEffect = 5,
-			UIEffect = 6
-		}
-*/
-
-/*		public enumCursorShape:long {
-			CursorShape = 0,
-			CursorShape = 1,
-			CursorShape = 2,
-			CursorShape = 3,
-			CursorShape = 4,
-			CursorShape = 5,
-			CursorShape = 6,
-			CursorShape = 7,
-			CursorShape = 8,
-			CursorShape = 9,
-			CursorShape = 10,
-			CursorShape = 11,
-			CursorShape = 12,
-			CursorShape = 13,
-			CursorShape = 14,
-			CursorShape = 15,
-			CursorShape = 16,
-			LastCursor = BusyCursor,
-			BitmapCursor = 24
-		}
-*/
-
-/*		public enumTextFormat:long {
-			TextFormat = 0,
-			TextFormat = 1,
-			TextFormat = 2,
-			TextFormat = 3
-		}
-*/
-
-/*		public enumAspectRatioMode:long {
-			AspectRatioMode = 0,
-			AspectRatioMode = 1,
-			AspectRatioMode = 2
-		}
-*/
-
-/*		public enumAnchorAttribute:long {
-			AnchorAttribute = 0,
-			AnchorAttribute = 1
-		}
-*/
-
-/*		public enumDockWidgetArea:long {
-			LeftDockWidgetArea = 0x1,
-			RightDockWidgetArea = 0x2,
-			TopDockWidgetArea = 0x4,
-			BottomDockWidgetArea = 0x8,
-			DockWidgetArea_Mask = 0xf,
-			AllDockWidgetAreas = DockWidgetArea_Mask
-		}
-*/
-
-/*		public enum:long {
-			NDockWidgetAreas = 4
-		}
-*/
-
-/*		public enumToolBarArea:long {
-			LeftToolBarArea = 0x1,
-			RightToolBarArea = 0x2,
-			TopToolBarArea = 0x4,
-			BottomToolBarArea = 0x8,
-			ToolBarArea_Mask = 0xf,
-			AllToolBarAreas = ToolBarArea_Mask
-		}
-*/
-
-/*		public enum:long {
-			NToolBarAreas = 4
-		}
-*/
-
-/*		public enumDateFormat:long {
-			DateFormat = 0,
-			DateFormat = 1,
-			DateFormat = 2
-		}
-*/
-
-/*		public enumTimeSpec:long {
-			TimeSpec = 0,
-			TimeSpec = 1
-		}
-*/
-
-/*		public enumDayOfWeek:long {
-			Monday = 1,
-			Tuesday = 2,
-			Wednesday = 3,
-			Thursday = 4,
-			Friday = 5,
-			Saturday = 6,
-			Sunday = 7
-		}
-*/
-
-/*		public enumScrollBarPolicy:long {
-			ScrollBarPolicy = 0,
-			ScrollBarPolicy = 1,
-			ScrollBarPolicy = 2
-		}
-*/
-
-/*		public enumCaseSensitivity:long {
-			CaseSensitivity = 0,
-			CaseSensitivity = 1
-		}
-*/
-
-/*		public enumCorner:long {
-			TopLeftCorner = 0x00000,
-			TopRightCorner = 0x00001,
-			BottomLeftCorner = 0x00002,
-			BottomRightCorner = 0x00003
-		}
-*/
-
-/*		public enumConnectionType:long {
-			ConnectionType = 0,
-			ConnectionType = 1,
-			ConnectionType = 2,
-			ConnectionType = 3
-		}
-*/
-
-/*		public enumShortcutContext:long {
-			ShortcutContext = 0,
-			ShortcutContext = 1,
-			ShortcutContext = 2
-		}
-*/
-
-/*		public enumFillRule:long {
-			FillRule = 0,
-			FillRule = 1
-		}
-*/
-
-/*		public enumClipOperation:long {
-			ClipOperation = 0,
-			ClipOperation = 1,
-			ClipOperation = 2,
-			ClipOperation = 3
-		}
-*/
-
-/*		public enumTransformationMode:long {
-			TransformationMode = 0,
-			TransformationMode = 1
-		}
-*/
-
-/*		public enumFocusReason:long {
-			FocusReason = 0,
-			FocusReason = 1,
-			FocusReason = 2,
-			FocusReason = 3,
-			FocusReason = 4,
-			FocusReason = 5,
-			FocusReason = 6,
-			FocusReason = 7,
-			FocusReason = 8
-		}
-*/
-
-/*		public enumContextMenuPolicy:long {
-			ContextMenuPolicy = 0,
-			ContextMenuPolicy = 1,
-			ContextMenuPolicy = 2,
-			ContextMenuPolicy = 3
-		}
-*/
-
-/*		public enumInputMethodQuery:long {
-			InputMethodQuery = 0,
-			InputMethodQuery = 1,
-			InputMethodQuery = 2,
-			InputMethodQuery = 3,
-			InputMethodQuery = 4
-		}
-*/
-
-/*		public enumToolButtonStyle:long {
-			ToolButtonStyle = 0,
-			ToolButtonStyle = 1,
-			ToolButtonStyle = 2,
-			ToolButtonStyle = 3
-		}
-*/
-
-/*		public enumLayoutDirection:long {
-			LayoutDirection = 0,
-			LayoutDirection = 1
-		}
-*/
-
-/*		public enumDropAction:long {
-			CopyAction = 0x1,
-			MoveAction = 0x2,
-			LinkAction = 0x4,
-			ActionMask = 0xff,
-			TargetMoveAction = 0x8002,
-			IgnoreAction = 0x0
-		}
-*/
-
-/*		public enumCheckState:long {
-			CheckState = 0,
-			CheckState = 1,
-			CheckState = 2
-		}
-*/
-
-/*		public enumItemDataRole:long {
-			DisplayRole = 0,
-			DecorationRole = 1,
-			EditRole = 2,
-			ToolTipRole = 3,
-			StatusTipRole = 4,
-			WhatsThisRole = 5,
-			FontRole = 6,
-			TextAlignmentRole = 7,
-			BackgroundColorRole = 8,
-			TextColorRole = 9,
-			CheckStateRole = 10,
-			AccessibleTextRole = 11,
-			AccessibleDescriptionRole = 12,
-			SizeHintRole = 13,
-			UserRole = 32
-		}
-*/
-
-/*		public enumItemFlag:long {
-			ItemIsSelectable = 1,
-			ItemIsEditable = 2,
-			ItemIsDragEnabled = 4,
-			ItemIsDropEnabled = 8,
-			ItemIsUserCheckable = 16,
-			ItemIsEnabled = 32,
-			ItemIsTristate = 64
-		}
-*/
-
-/*		public enumMatchFlag:long {
-			MatchExactly = 0,
-			MatchContains = 1,
-			MatchStartsWith = 2,
-			MatchEndsWith = 3,
-			MatchRegExp = 4,
-			MatchWildcard = 5,
-			MatchCaseSensitive = 16,
-			MatchWrap = 32,
-			MatchRecursive = 64
-		}
-*/
-
-/*		public enumWindowModality:long {
-			WindowModality = 0,
-			WindowModality = 1,
-			WindowModality = 2
-		}
-*/
-/*********************************
- *    class     Qt */
-/*
- *    function  metaObject
- *    flags:    cv
+#include <Qt>
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(Qt, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			QMetaObject * return_object = (QMetaObject *) obj->metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, Qt_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     Qt */
-/*
- *    function  tr
- *    flags:    s
- */
-ZEND_METHOD(Qt, tr){
+ZEND_METHOD(Qt, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* ss */
-		char* var_ss_0;   // default: 
-		int len_ss_0;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+/// method is private, skip
+      php_error(E_ERROR, "Qt::tr(...) cannot be called with ' const char *s0,'.");
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+/// method is private, skip
+      php_error(E_ERROR, "Qt::tr(...) cannot be called with ' const char *s0, const char * = 0 s1,'.");
+    }
+  }
+#endif // return type
 
-		char* var_ss_1;   // default: 0
-		int len_ss_1;
-
-
-		/* const char* , const char* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"ss|", &var_ss_0, len_ss_0, &var_ss_1, len_ss_1) == SUCCESS) {
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-
-			
-			QString return_object = (QString) obj->tr( (const char*) var_ss_0 , (const char*) var_ss_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, Qt_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-		}
-	}
+  php_error(E_ERROR, "could not parse argument in Qt::tr(...) ");
 }
 
-/*********************************
- *    class     Qt */
-/*
- *    function  qt_invoke
- *    flags:    v
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(Qt, qt_invoke){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* lo */
-		long var_lo_0;    // default: 
-		zval* z_var_lo_1;   // default: 
-
-		/* int , QUObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"lo", &var_lo_0, &z_var_lo_1) == SUCCESS) {
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			QObject* var_lo_1 = (QObject*) php_qt_fetch(z_var_lo_1);
-
-			QString tmp_lo_0(var_lo_1->metaObject()->className());
-			
-			if(tmp_lo_0 == "QUObject*") {
-				RETURN_BOOL(obj->qt_invoke((int) var_lo_0, (QUObject*) var_lo_1));
-			}
-		}
-	}
-}
-
-/*********************************
- *    class     Qt */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(Qt, staticMetaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			QMetaObject* return_object = (QMetaObject*) obj->staticMetaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, Qt_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     Qt */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(Qt, qt_emit){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* lo */
-		long var_lo_0;    // default: 
-		zval* z_var_lo_1;   // default: 
-
-		/* int , QUObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"lo", &var_lo_0, &z_var_lo_1) == SUCCESS) {
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			QObject* var_lo_1 = (QObject*) php_qt_fetch(z_var_lo_1);
-
-			QString tmp_lo_0(var_lo_1->metaObject()->className());
-			
-			if(tmp_lo_0 == "QUObject*") {
-				RETURN_BOOL(obj->qt_emit((int) var_lo_0, (QUObject*) var_lo_1));
-			}
-		}
-	}
-}
-
-/*********************************
- *    class     Qt */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(Qt, className){
-	if (ZEND_NUM_ARGS() == 0){
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			const char * return_object = (const char *) obj->className();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, Qt_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     Qt */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(Qt, qObject){
-	if (ZEND_NUM_ARGS() == 0){
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			QObject* return_object = (QObject*) obj->qObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, Qt_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     Qt */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(Qt, trUtf8){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* ss */
-		char* var_ss_0;   // default: 
-		int len_ss_0;
+ZEND_METHOD(Qt, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-		char* var_ss_1;   // default: 0
-		int len_ss_1;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+/// method is private, skip
+      php_error(E_ERROR, "Qt::trUtf8(...) cannot be called with ' const char *s0,'.");
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+/// method is private, skip
+      php_error(E_ERROR, "Qt::trUtf8(...) cannot be called with ' const char *s0, const char * = 0 s1,'.");
+    }
+  }
+#endif // return type
 
-
-		/* const char* , const char* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"ss|", &var_ss_0, len_ss_0, &var_ss_1, len_ss_1) == SUCCESS) {
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-
-			
-			QString return_object = (QString) obj->trUtf8( (const char*) var_ss_0 , (const char*) var_ss_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, Qt_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-		}
-	}
+  php_error(E_ERROR, "could not parse argument in Qt::trUtf8(...) ");
 }
 
-/*********************************
- *    class     Qt */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(Qt, qt_property){
 
-	if (ZEND_NUM_ARGS() == 3){
-		/* llo */
-		long var_llo_0;    // default: 
-		long var_llo_1;    // default: 
-		zval* z_var_llo_2;   // default: 
-
-		/* int , int , QVariant* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"llo", &var_llo_0, &var_llo_1, &z_var_llo_2) == SUCCESS) {
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			QObject* var_llo_2 = (QObject*) php_qt_fetch(z_var_llo_2);
-
-			QString tmp_llo_0(var_llo_2->metaObject()->className());
-			
-			if(tmp_llo_0 == "QVariant*") {
-				RETURN_BOOL(obj->qt_property((int) var_llo_0, (int) var_llo_1, (QVariant*) var_llo_2));
-			}
-		}
-	}
-}
-
-/*********************************
- *    class     Qt */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(Qt, qt_cast){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+ZEND_METHOD(Qt, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, "Qt::staticMetaObject(...) cannot be called with ''.");
+    }
+  }
+#endif // return type
 
-		/* const char* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s", &var_s_0, len_s_0) == SUCCESS) {
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-
-			
-			obj->qt_cast( (const char*) var_s_0);
-			RETURN_NULL();
-		}
-	}
+  php_error(E_ERROR, "could not parse argument in Qt::staticMetaObject(...) ");
 }
 
-
-PHP_QT_DESTRUCT(Qt);
-
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */

Modified: trunk/qt/classes/qtabletevent.cpp
===================================================================
--- trunk/qt/classes/qtabletevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qtabletevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,290 +19,614 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QTabletEvent.cpp - QTabletEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QTabletEvent>
 #include "../php_qt.h"
 
 
+#include <QTabletEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QTabletEvent_php_qt:public QTabletEvent
+{
 
-/*		public enumTabletDevice:long {
-			TabletDevice = 0,
-			TabletDevice = 0,
-			TabletDevice = 0,
-			TabletDevice = 0,
-			TabletDevice = 0,
-			TabletDevice = 0,
-		}
-*/
+public:
+  QTabletEvent_php_qt(zval * zend_ptr, Type ts0, const QPoint & poss1, const QPoint & globalPoss2, const QPointF & hiResGlobalPoss3, int devices4,
+                      int pointerTypes5, qreal pressures6, int xTilts7, int yTilts8, qreal tangentialPressures9, qreal rotations10, int zs11,
+                      Qt::KeyboardModifiers keyStates12, qint64 uniqueIDs13);
 
-/*		public enumPointerType:long {
-			PointerType = 0,
-			PointerType = 0,
-			PointerType = 0,
-			PointerType = 0,
-		}
-*/
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  hiResGlobalX
- *    flags:    c
+
+  zval *zend_ptr;
+};
+QTabletEvent_php_qt::QTabletEvent_php_qt(zval * zend_ptr, Type ts0, const QPoint & poss1, const QPoint & globalPoss2, const QPointF & hiResGlobalPoss3,
+                                         int devices4, int pointerTypes5, qreal pressures6, int xTilts7, int yTilts8, qreal tangentialPressures9,
+                                         qreal rotations10, int zs11, Qt::KeyboardModifiers keyStates12, qint64 uniqueIDs13):
+QTabletEvent(ts0, poss1, globalPoss2, hiResGlobalPoss3, devices4, pointerTypes5, pressures6, xTilts7, yTilts8, tangentialPressures9, rotations10, zs11,
+             keyStates12, uniqueIDs13)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method pressure
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, hiResGlobalX){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj->hiResGlobalX());
-	}
+
+ZEND_METHOD(QTabletEvent, pressure)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type qreal");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::pressure(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  pressure
- *    flags:    c
+/*!
+ * method hiResGlobalPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPointF &
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, pressure){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj->pressure());
-	}
+
+ZEND_METHOD(QTabletEvent, hiResGlobalPos)
+{
+  ///
+#ifdef PHP_QT_QPointF           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hiResGlobalPos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTabletEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPointF & >(selfpointer->hiResGlobalPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::hiResGlobalPos(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  hiResGlobalPos
- *    flags:    c
+/*!
+ * method y
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, hiResGlobalPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-				const QPointF & return_object = (const QPointF &) obj->hiResGlobalPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTabletEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QTabletEvent, y)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'y' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTabletEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->y());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::y(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  tangentialPressure
- *    flags:    c
+/*!
+ * method xTilt
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, tangentialPressure){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj->tangentialPressure());
-	}
+
+ZEND_METHOD(QTabletEvent, xTilt)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'xTilt' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTabletEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->xTilt());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::xTilt(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  x
- *    flags:    c
+/*!
+ * method rotation
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, x){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->x());
-	}
+
+ZEND_METHOD(QTabletEvent, rotation)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type qreal");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::rotation(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  globalX
- *    flags:    c
+/*!
+ * method pointerType
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	PointerType
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, globalX){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->globalX());
-	}
+
+ZEND_METHOD(QTabletEvent, pointerType)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type PointerType");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::pointerType(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  globalPos
- *    flags:    c
+/*!
+ * method yTilt
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, globalPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-				const QPoint & return_object = (const QPoint &) obj->globalPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTabletEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QTabletEvent, yTilt)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'yTilt' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTabletEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->yTilt());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::yTilt(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  y
- *    flags:    c
+/*!
+ * method z
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, y){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->y());
-	}
+
+ZEND_METHOD(QTabletEvent, z)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'z' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTabletEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->z());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::z(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  uniqueId
- *    flags:    c
+/*!
+ * method hiResGlobalX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, uniqueId){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			obj->uniqueId();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QTabletEvent, hiResGlobalX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type qreal");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::hiResGlobalX(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  hiResGlobalY
- *    flags:    c
+/*!
+ * method hiResGlobalY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, hiResGlobalY){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj->hiResGlobalY());
-	}
+
+ZEND_METHOD(QTabletEvent, hiResGlobalY)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type qreal");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::hiResGlobalY(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-				const QPoint & return_object = (const QPoint &) obj->pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTabletEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QTabletEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTabletEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::pos(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  xTilt
- *    flags:    c
+/*!
+ * method device
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	TabletDevice
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, xTilt){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->xTilt());
-	}
+
+ZEND_METHOD(QTabletEvent, device)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type TabletDevice");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::device(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  rotation
- *    flags:    c
+/*!
+ * method tangentialPressure
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, rotation){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj->rotation());
-	}
+
+ZEND_METHOD(QTabletEvent, tangentialPressure)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type qreal");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::tangentialPressure(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  pointerType
- *    flags:    c
+/*!
+ * method globalX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, pointerType){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			obj->pointerType();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QTabletEvent, globalX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalX' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTabletEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->globalX());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::globalX(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  yTilt
- *    flags:    c
+/*!
+ * method globalPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, yTilt){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->yTilt());
-	}
+
+ZEND_METHOD(QTabletEvent, globalPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalPos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTabletEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->globalPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::globalPos(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  device
- *    flags:    c
+/*!
+ * method x
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, device){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			obj->device();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QTabletEvent, x)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'x' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTabletEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->x());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::x(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  globalY
- *    flags:    c
+/*!
+ * method uniqueId
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qint64
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, globalY){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->globalY());
-	}
+
+ZEND_METHOD(QTabletEvent, uniqueId)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type qint64");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::uniqueId(...) ");
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  z
- *    flags:    c
+/*!
+ * method QTabletEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type ts0s0
+ * @param	const QPoint &poss1s1
+ * @param	const QPoint &globalPoss2s2
+ * @param	const QPointF &hiResGlobalPoss3s3
+ * @param	int devices4s4
+ * @param	int pointerTypes5s5
+ * @param	qreal pressures6s6
+ * @param	int xTilts7s7
+ * @param	int yTilts8s8
+ * @param	qreal tangentialPressures9s9
+ * @param	qreal rotations10s10
+ * @param	int zs11s11
+ * @param	Qt::KeyboardModifiers keyStates12s12
+ * @param	qint64 uniqueIDs13s13
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QTabletEvent, z){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->z());
-	}
+
+ZEND_METHOD(QTabletEvent, __construct)
+{
+// notice: unknown argument Type ts0s0, skipped
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::QTabletEvent(...) ");
 }
 
+/*!
+ * method globalY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QTabletEvent);
+ZEND_METHOD(QTabletEvent, globalY)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalY' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTabletEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->globalY());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTabletEvent::globalY(...) ");
+}

Modified: trunk/qt/classes/qtime.cpp
===================================================================
--- trunk/qt/classes/qtime.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qtime.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,447 +19,1055 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QTime.cpp - QTime PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QTime>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QTime */
-/*
- *    function  hour
- *    flags:    c
+#include <QTime>
+#include <QMetaMethod>
+class QTime_php_qt:public QTime
+{
+
+public:
+  QTime_php_qt(zval * zend_ptr);
+  QTime_php_qt(zval * zend_ptr, int hs0, int ms1, int s = 0, int ms = 0);
+
+
+  zval *zend_ptr;
+};
+
+QTime_php_qt::QTime_php_qt(zval * zend_ptr):QTime()
+{
+  this->zend_ptr = zend_ptr;
+}
+QTime_php_qt::QTime_php_qt(zval * zend_ptr, int hs0, int ms1, int s, int ms):
+QTime(hs0, ms1, s, ms)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method hour
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTime, hour){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj->hour());
-	}
+
+ZEND_METHOD(QTime, hour)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hour' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->hour());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::hour(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  isValid
- *    flags:    c
+/*!
+ * method isValid
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int h
+ * @param	 int m
+ * @param	 int s
+ * @param	 int ms = 0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QTime, isValid){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isValid());
-	}
-		/* llll public*/
 
-		/* int h, int m, int s, int ms,  */
+ZEND_METHOD(QTime, isValid)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isValid' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isValid());
+    }
+  }
+  ///int h, int m, int s, int ms = 0
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      /// try int h, int m, int s,
+      QTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QTime::isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      } else {
+        RETURN_BOOL(selfpointer->isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+    }}
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      /// try int h, int m, int s, int ms = 0,
+      QTime *selfpointer;
 
-			RETURN_BOOL(obj->isValid((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QTime::isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+      } else {
+        RETURN_BOOL(selfpointer->isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }}
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::isValid(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  elapsed
- *    flags:    c
+/*!
+ * method elapsed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTime, elapsed){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj->elapsed());
-	}
+
+ZEND_METHOD(QTime, elapsed)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'elapsed' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->elapsed());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::elapsed(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  toString
- *    flags:    c
+/*!
+ * method fromString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &ss0
+ * @param	 Qt::DateFormat f = Qt::TextDates1
+ * 
+ * overloaded args:
+ * @param	const QString &s
+ * @param	 const QString &format
+ * 
+ * @access	public
+ * @return	QTime
+ * @flags	s
  */
-ZEND_METHOD(QTime, toString){
-		/* l public*/
 
-		/* int f,  */
-		/* o public*/
+ZEND_METHOD(QTime, fromString)
+{
+  ///const QString &ss0, Qt::DateFormat f = Qt::TextDates1
+#ifdef PHP_QT_QTime             // return type
 
-		/* const QString& format,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &ss0,
+        QTime *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-				QString return_object = (QString) obj->toString((Qt::DateFormat) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QTime *return_object = new QTime;
 
+        if (getThis() == NULL) {
+          *return_object = static_cast < QTime > (QTime::fromString((const QString &)*cpp_arg_0));
+        } else {
+          *return_object = static_cast < QTime > (selfpointer->fromString((const QString &)*cpp_arg_0));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QString return_object = (QString) obj->toString((const QString&) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &ss0, Qt::DateFormat f = Qt::TextDates1,
+        QTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QTime *return_object = new QTime;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast < QTime > (QTime::fromString((const QString &)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
+        } else {
+          *return_object = static_cast < QTime > (selfpointer->fromString((const QString &)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &s, const QString &format
+#ifdef PHP_QT_QTime             // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
+        /// try const QString &s, const QString &format,
+        QTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QTime *return_object = new QTime;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast < QTime > (QTime::fromString((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        } else {
+          *return_object = static_cast < QTime > (selfpointer->fromString((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QTime::fromString(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  msec
- *    flags:    c
+/*!
+ * method second
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTime, msec){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj->msec());
-	}
+
+ZEND_METHOD(QTime, second)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'second' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->second());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::second(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  secsTo
- *    flags:    c
+/*!
+ * method setHMS
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int hs0
+ * @param	 int ms1
+ * @param	 int ss2
+ * @param	 int ms = 0s3
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QTime, secsTo){
-		/* o public*/
 
-		/* const QTime& ,  */
+ZEND_METHOD(QTime, setHMS)
+{
+  ///int hs0, int ms1, int ss2, int ms = 0s3
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setHMS' is not static");
+        RETURN_NULL();
+      }
+      /// try int hs0, int ms1, int ss2,
+      QTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->setHMS((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setHMS' is not static");
+        RETURN_NULL();
+      }
+      /// try int hs0, int ms1, int ss2, int ms = 0s3,
+      QTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->setHMS((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::setHMS(...) ");
+}
 
-			if(Z_OBJCE_P(z_0)->name == "QTime") {
-				RETURN_LONG(obj->secsTo((const QTime&) obj_z_0));
-			}
-			}
-		}
-	}
+/*!
+ * method minute
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QTime, minute)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minute' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->minute());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::minute(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  restart
- *    flags:    
+/*!
+ * method start
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QTime, restart){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj->restart());
-	}
+
+ZEND_METHOD(QTime, start)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'start' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->start());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::start(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  fromString
- *    flags:    s
+/*!
+ * method operator<
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QTime, fromString){
-		/* ol public*/
 
-		/* const QString& s, int f,  */
-		/* oo public*/
+/*!
+ * method operator==
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-		/* const QString& s, const QString& format,  */
+/*!
+ * method addSecs
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int secss0
+ * 
+ * @access	public
+ * @return	QTime
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QTime, addSecs)
+{
+  ///int secss0
+#ifdef PHP_QT_QTime             // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addSecs' is not static");
+        RETURN_NULL();
+      }
+      /// try int secss0,
+      QTime *selfpointer;
 
-			if(Z_OBJCE_P(z_0)->name == "QString") {
-					QTime return_object = (QTime) obj->fromString((const QString&) obj_z_0, (Qt::DateFormat) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QTime *return_object = new QTime;
 
-			if(Z_OBJCE_P(z_0)->name == "QString" && Z_OBJCE_P(z_1)->name == "QString") {
-					QTime return_object = (QTime) obj->fromString((const QString&) obj_z_0, (const QString&) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+      *return_object = static_cast < QTime > (selfpointer->addSecs((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QTime::addSecs(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  second
- *    flags:    c
+/*!
+ * method currentTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QTime
+ * @flags	s
  */
-ZEND_METHOD(QTime, second){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj->second());
-	}
+
+ZEND_METHOD(QTime, currentTime)
+{
+  ///
+#ifdef PHP_QT_QTime             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QTime *return_object = new QTime;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QTime > (QTime::currentTime());
+      } else {
+        *return_object = static_cast < QTime > (selfpointer->currentTime());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QTime::currentTime(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  QTime
- *    flags:    
+/*!
+ * method operator!=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QTime, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *QTime_ptr = new QTime();
-				PHP_QT_REGISTER(QTime_ptr);
-				RETURN_NULL();
-	}
-		/* llll public*/
 
-		/* int h, int m, int s, int ms,  */
+/*!
+ * method operator>
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
+/*!
+ * method msec
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QTime, msec)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'msec' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
 
-			QTime *QTime_ptr = new QTime((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-				PHP_QT_REGISTER(QTime_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->msec());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::msec(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  addSecs
- *    flags:    c
+/*!
+ * method secsTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTime, addSecs){
-		/* l public*/
 
-		/* int secs,  */
+ZEND_METHOD(QTime, secsTo)
+{
+  ///const QTime &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QTime
+      if (inherits(Z_OBJCE_P(arg_0), 63)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'secsTo' is not static");
+          RETURN_NULL();
+        }
+        /// try const QTime &s0,
+        QTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+        }
+        QTime *cpp_arg_0 = static_cast < QTime * >(php_qt_fetch(arg_0));
 
+        RETURN_LONG(selfpointer->secsTo((const QTime &)*cpp_arg_0));
+      }
+#endif
 
-				QTime return_object = (QTime) obj->addSecs((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::secsTo(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  addMSecs
- *    flags:    c
+/*!
+ * method addMSecs
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int mss0
+ * 
+ * @access	public
+ * @return	QTime
+ * @flags	c
  */
-ZEND_METHOD(QTime, addMSecs){
-		/* l public*/
 
-		/* int ms,  */
+ZEND_METHOD(QTime, addMSecs)
+{
+  ///int mss0
+#ifdef PHP_QT_QTime             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'addMSecs' is not static");
+        RETURN_NULL();
+      }
+      /// try int mss0,
+      QTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QTime return_object = (QTime) obj->addMSecs((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QTime *return_object = new QTime;
+
+      *return_object = static_cast < QTime > (selfpointer->addMSecs((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QTime::addMSecs(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  currentTime
- *    flags:    s
+/*!
+ * method msecsTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTime, currentTime){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-				QTime return_object = (QTime) obj->currentTime();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QTime, msecsTo)
+{
+  ///const QTime &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QTime
+      if (inherits(Z_OBJCE_P(arg_0), 63)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'msecsTo' is not static");
+          RETURN_NULL();
+        }
+        /// try const QTime &s0,
+        QTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+        }
+        QTime *cpp_arg_0 = static_cast < QTime * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->msecsTo((const QTime &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::msecsTo(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  minute
- *    flags:    c
+/*!
+ * method operator<=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QTime, minute){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj->minute());
-	}
-}
 
-/*********************************
- *    class     QTime */
-/*
- *    function  setHMS
- *    flags:    
+/*!
+ * method toString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::DateFormat f = Qt::TextDates0
+ * 
+ * overloaded args:
+ * @param	const QString &format
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QTime, setHMS){
-		/* llll public*/
 
-		/* int h, int m, int s, int ms,  */
+ZEND_METHOD(QTime, toString)
+{
+  ///Qt::DateFormat f = Qt::TextDates0
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toString' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_BOOL(obj->setHMS((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->toString());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toString' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::DateFormat f = Qt::TextDates0,
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->toString((Qt::DateFormat) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const QString &format
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'toString' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &format,
+        QTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast < QString > (selfpointer->toString((const QString &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QTime::toString(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  isNull
- *    flags:    c
+/*!
+ * method restart
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	
  */
-ZEND_METHOD(QTime, isNull){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isNull());
-	}
+
+ZEND_METHOD(QTime, restart)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'restart' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->restart());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::restart(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  msecsTo
- *    flags:    c
+/*!
+ * method QTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int hs0
+ * @param	int ms1
+ * @param	 int s = 0
+ * @param	 int ms = 0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QTime, msecsTo){
-		/* o public*/
 
-		/* const QTime& ,  */
+ZEND_METHOD(QTime, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTime_php_qt *selfpointer = new QTime_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///int hs0,int ms1, int s = 0, int ms = 0
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try int hs0,int ms1,
+      QTime_php_qt *selfpointer = new QTime_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1));
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try int hs0,int ms1, int s = 0,
+      QTime_php_qt *selfpointer = new QTime_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2));
 
-			if(Z_OBJCE_P(z_0)->name == "QTime") {
-				RETURN_LONG(obj->msecsTo((const QTime&) obj_z_0));
-			}
-			}
-		}
-	}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try int hs0,int ms1, int s = 0, int ms = 0,
+      QTime_php_qt *selfpointer = new QTime_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::QTime(...) ");
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  start
- *    flags:    
+/*!
+ * method isNull
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QTime, start){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			obj->start();
-			RETURN_NULL();
-	}
-}
 
+ZEND_METHOD(QTime, isNull)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isNull' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
 
-PHP_QT_DESTRUCT(QTime);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isNull());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTime::isNull(...) ");
+}
 
+/*!
+ * method operator>=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */

Modified: trunk/qt/classes/qtimer.cpp
===================================================================
--- trunk/qt/classes/qtimer.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qtimer.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,365 +19,816 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QTimer.cpp - QTimer PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QTimer>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  tr
- *    flags:    s
- */
-ZEND_METHOD(QTimer, tr){
-		/* ss public*/
+#include <QTimer>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QTimer_php_qt:public QTimer
+{
 
-		/* const char* , const char* ,  */
+public:
+  QTimer_php_qt(zval * zend_ptr, QObject * parent = 0);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
 
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
-				QString return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTimer_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+QTimer_php_qt::QTimer_php_qt(zval * zend_ptr, QObject * parent):QTimer(parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QTimer",&staticMetaObject));
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  qt_invoke
- *    flags:    v
+PHP_QT_MOC(QTimer);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QTimer, qt_invoke){
+
+ZEND_METHOD(QTimer, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QTimer::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QTimer::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QTimer::tr(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QTimer, staticMetaObject){
-}
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  setInterval
- *    flags:    
+/*!
+ * method timeout
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QTimer, setInterval){
-		/* l public*/
 
-		/* int msec,  */
+/*!
+ * method singleShot
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int msecs0
+ * @param	 QObject *receivers1
+ * @param	 const char *members2
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
+ZEND_METHOD(QTimer, singleShot)
+{
+  ///int msecs0, QObject *receivers1, const char *members2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_STRING) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_1), 46)) {
+        /// try int msecs0, QObject *receivers1, const char *members2,
+        QTimer *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_1 = static_cast < QObject * >(php_qt_fetch(arg_1));
 
-			obj->setInterval((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_VOID(QTimer::singleShot((int)Z_LVAL_P(arg_0), (QObject *) cpp_arg_1, (const char *)&Z_STRVAL_P(arg_2)[0]));
+        } else {
+          RETURN_VOID(selfpointer->singleShot((int)Z_LVAL_P(arg_0), (QObject *) cpp_arg_1, (const char *)&Z_STRVAL_P(arg_2)[0]));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimer::singleShot(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QTimer, qObject){
-}
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  timerId
- *    flags:    c
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QTimer, timerId){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			RETURN_LONG(obj->timerId());
-	}
-}
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  singleShot
- *    flags:    s
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QTimer, singleShot){
-		/* los public*/
 
-		/* int msec, qt_QObject* receiver, const char* member,  */
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_STRING){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+/*!
+ * method start
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int msecs0
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
 
+ZEND_METHOD(QTimer, start)
+{
+  ///int msecs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'start' is not static");
+        RETURN_NULL();
+      }
+      /// try int msecs0,
+      QTimer *
+        selfpointer;
 
-			if(obj_z_1->inherits("QObject")) {
-				obj->singleShot((int) Z_LVAL_P(z_0), (QObject*) obj_z_1, (const char*) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->start((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'start' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->start());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimer::start(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method timerEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTimerEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QTimer, qt_cast){
-}
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  metaObject
- *    flags:    cv
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QTimer, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-				QMetaObject * return_object = (QMetaObject *) obj->metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTimer_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QTimer, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QTimer::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QTimer::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  stop
- *    flags:    l
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QTimer, stop){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			obj->stop();
-			RETURN_NULL();
-	}
+
+/*!
+ * method timerId
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QTimer, timerId)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'timerId' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->timerId());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimer::timerId(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  isActive
- *    flags:    c
+/*!
+ * method killTimer
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	private
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QTimer, isActive){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isActive());
-	}
+
+ZEND_METHOD(QTimer, killTimer)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+/// method is private, skip
+      php_error(E_ERROR, "QTimer::killTimer(...) cannot be called with 'int ints0,'.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimer::killTimer(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  QTimer
- *    flags:    t
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QTimer, __construct){
-		/* o public*/
 
-		/* qt_QObject* parent,  */
+/*!
+ * method isSingleShot
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QTimer, isSingleShot)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isSingleShot' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer *
+        selfpointer;
 
-
-			if(obj_z_0->inherits("QObject")) {
-				QTimer *QTimer_ptr = new QTimer((QObject*) obj_z_0);
-				PHP_QT_REGISTER(QTimer_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isSingleShot());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimer::isSingleShot(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method interval
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTimer, qt_emit){
+
+ZEND_METHOD(QTimer, interval)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'interval' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->interval());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimer::interval(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  interval
- *    flags:    c
+/*!
+ * method setInterval
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int msecs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QTimer, interval){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			RETURN_LONG(obj->interval());
-	}
+
+ZEND_METHOD(QTimer, setInterval)
+{
+  ///int msecs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setInterval' is not static");
+        RETURN_NULL();
+      }
+      /// try int msecs0,
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setInterval((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimer::setInterval(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  setSingleShot
- *    flags:    
+/*!
+ * method stop
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QTimer, setSingleShot){
-		/* l public*/
 
-		/* int singleShot,  */
+ZEND_METHOD(QTimer, stop)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'stop' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->stop());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimer::stop(...) ");
+}
 
+/*!
+ * method isActive
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-			obj->setSingleShot((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+ZEND_METHOD(QTimer, isActive)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isActive' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer *
+        selfpointer;
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  className
- *    flags:    cv
- */
-ZEND_METHOD(QTimer, className){
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isActive());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimer::isActive(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method QTimer
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *parent = 0s0
+ * 
+ * overloaded args:
+ * @param	const QTimer &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QTimer, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QTimer, __construct)
+{
+  ///QObject *parent = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer_php_qt *
+        selfpointer = new QTimer_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QObject *parent = 0s0,
+      QObject *
+        cpp_arg_0 = static_cast < QObject * >(php_qt_fetch(arg_0));
+      QTimer_php_qt *
+        selfpointer = new QTimer_php_qt(getThis(), (QObject *) cpp_arg_0);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QTimer &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QTimer
+      if (inherits(Z_OBJCE_P(arg_0), 64)) {
+/// method is private, skip
+        php_error(E_ERROR, "QTimer::__construct(...) cannot be called with 'const QTimer &,'.");
+      }
+#endif
 
-				QString return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTimer_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimer::QTimer(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method setSingleShot
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool singleShots0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QTimer, qt_property){
+
+ZEND_METHOD(QTimer, setSingleShot)
+{
+  ///bool singleShots0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setSingleShot' is not static");
+        RETURN_NULL();
+      }
+      /// try bool singleShots0,
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setSingleShot((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimer::setSingleShot(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  isSingleShot
- *    flags:    c
+/*!
+ * method startTimer
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	private
+ * @return	int
+ * @flags	
  */
-ZEND_METHOD(QTimer, isSingleShot){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isSingleShot());
-	}
+
+ZEND_METHOD(QTimer, startTimer)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+/// method is private, skip
+      php_error(E_ERROR, "QTimer::startTimer(...) cannot be called with 'int ints0,'.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimer::startTimer(...) ");
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  start
- *    flags:    l
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QTimer, start){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			obj->start();
-			RETURN_NULL();
-	}
-		/* l public_slots*/
 
-		/* int msec,  */
+ZEND_METHOD(QTimer, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QTimer *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj->start((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QTimer::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QTimer *
+        selfpointer;
 
-PHP_QT_DESTRUCT(QTimer);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimer * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QTimer::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QTimer::trUtf8(...) ");
+}

Modified: trunk/qt/classes/qtimerevent.cpp
===================================================================
--- trunk/qt/classes/qtimerevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qtimerevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QTimerEvent.cpp - QTimerEvent PHP implementation.
- * begin           : Tue Apr 11 10:33:13 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -31,28 +30,85 @@
 
 
 #include <QTimerEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QTimerEvent_php_qt:public QTimerEvent
+{
 
+public:
+  QTimerEvent_php_qt(zval * zend_ptr, int timerIds0);
+
+
+  zval *zend_ptr;
+};
+QTimerEvent_php_qt::QTimerEvent_php_qt(zval * zend_ptr, int timerIds0):
+QTimerEvent(timerIds0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
 /*!
- *    @class     QTimerEvent
- *    @function  timerId
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method timerId
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QTimerEvent, timerId)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'timerId' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QTimerEvent *selfpointer;
 
-    if (getThis() != NULL) {
-      QTimerEvent *obj = (QTimerEvent *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->timerId());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QTimerEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->timerId());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QTimerEvent::timerId(...) ");
 }
 
+/*!
+ * method QTimerEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int timerIds0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QTimerEvent);
+ZEND_METHOD(QTimerEvent, __construct)
+{
+  ///int timerIds0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try int timerIds0s0,
+      QTimerEvent_php_qt *selfpointer = new QTimerEvent_php_qt(getThis(), (int)Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QTimerEvent::QTimerEvent(...) ");
+}

Modified: trunk/qt/classes/qtoolbarchangeevent.cpp
===================================================================
--- trunk/qt/classes/qtoolbarchangeevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qtoolbarchangeevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,30 +19,98 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QToolBarChangeEvent.cpp - QToolBarChangeEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QToolBarChangeEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QToolBarChangeEvent */
-/*
- *    function  toggle
- *    flags:    c
+#include <QToolBarChangeEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QToolBarChangeEvent_php_qt:public QToolBarChangeEvent
+{
+
+public:
+  QToolBarChangeEvent_php_qt(zval * zend_ptr, bool ts0);
+
+
+  zval *zend_ptr;
+};
+
+QToolBarChangeEvent_php_qt::QToolBarChangeEvent_php_qt(zval * zend_ptr, bool ts0):QToolBarChangeEvent(ts0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method toggle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QToolBarChangeEvent, toggle){
-	if (ZEND_NUM_ARGS() == 0){
-			QToolBarChangeEvent *obj = (QToolBarChangeEvent*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->toggle());
-	}
+
+ZEND_METHOD(QToolBarChangeEvent, toggle)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toggle' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QToolBarChangeEvent *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolBarChangeEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->toggle());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QToolBarChangeEvent::toggle(...) ");
 }
 
+/*!
+ * method QToolBarChangeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool ts0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QToolBarChangeEvent);
+ZEND_METHOD(QToolBarChangeEvent, __construct)
+{
+  ///bool ts0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try bool ts0s0,
+      QToolBarChangeEvent_php_qt *
+        selfpointer = new QToolBarChangeEvent_php_qt(getThis(), (bool) Z_LVAL_P(arg_0));
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QToolBarChangeEvent::QToolBarChangeEvent(...) ");
+}

Modified: trunk/qt/classes/qtoolbutton.cpp
===================================================================
--- trunk/qt/classes/qtoolbutton.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qtoolbutton.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QToolButton.cpp - QToolButton PHP implementation.
- * begin           : Thu May 11 21:32:50 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -31,719 +30,1147 @@
 
 
 #include <QToolButton>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QToolButton_php_qt:public QToolButton
+{
 
+public:
+  QToolButton_php_qt(zval * zend_ptr, QWidget * parent = 0);
 
-/*		public enumToolButtonPopupMode:long {
-			ToolButtonPopupMode = 0,
-			ToolButtonPopupMode = 1,
-			ToolButtonPopupMode = 2
-		}
-*/
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+
+QToolButton_php_qt::QToolButton_php_qt(zval * zend_ptr, QWidget * parent):QToolButton(parent)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QToolButton",&staticMetaObject));
+}
+
+PHP_QT_MOC(QToolButton);
+
 /*!
- *    @class     QToolButton
- *    @function  tr
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
+
 ZEND_METHOD(QToolButton, tr)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QToolButton *
+        selfpointer;
 
-        QString *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast < QString > (obj->tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QToolButton::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));   /// memory allocation
-          *return_object = static_cast < QString > (QToolButton::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        object_init_ex(return_value, QToolButton_ce_ptr);
-        zend_rsrc_list_entry le;
-
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QToolButton::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
       } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING) {
-        QString *return_object;
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QToolButton *
+        selfpointer;
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          QToolButton *obj = static_cast<QToolButton *>(PHP_QT_FETCH());
-          *return_object = static_cast < QString > (obj->tr((const char *)Z_STRVAL_P(z_0)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QToolButton::tr((const char *)Z_STRVAL_P(z_0))));   /// memory allocation
-          *return_object = static_cast < QString > (QToolButton::tr((const char *)Z_STRVAL_P(z_0)));
-        } zend_class_entry *ce;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        object_init_ex(return_value, QToolButton_ce_ptr);
-        zend_rsrc_list_entry le;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QToolButton::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
       } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QToolButton::tr(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  defaultAction
- *
- *    @flags    c
- *    @access    public
- *    @return    QAction *
- *    @param    
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QToolButton, defaultAction)
-{
-  if (ZEND_NUM_ARGS() == 0) {
-    QAction **return_object;
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+/*!
+ * method actionEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QActionEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-/// return: pointer
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
+ */
 
-/// return value is object: QAction *
-      *return_object = static_cast < QAction * >(obj->defaultAction());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
-    }
-    zend_class_entry *ce;
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-    object_init_ex(return_value, QToolButton_ce_ptr);
-    zend_rsrc_list_entry le;
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
-}
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
 /*!
- *    @class     QToolButton
- *    @function  showMenu
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method enterEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, showMenu)
+
+/*!
+ * method setToolButtonStyle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::ToolButtonStyle styles0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QToolButton, setToolButtonStyle)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+  ///Qt::ToolButtonStyle styles0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setToolButtonStyle' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::ToolButtonStyle styles0,
+      QToolButton *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
-
-      obj->showMenu();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setToolButtonStyle((Qt::ToolButtonStyle) Z_LVAL_P(arg_0)));
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QToolButton::setToolButtonStyle(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  autoRaise
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method setMenu
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMenu * menus0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, autoRaise)
+
+ZEND_METHOD(QToolButton, setMenu)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+  ///QMenu * menus0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QMenu
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setMenu' is not static");
+          RETURN_NULL();
+        }
+        /// try QMenu * menus0,
+        QToolButton *
+          selfpointer;
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+        }
+        QMenu *
+          cpp_arg_0 = static_cast < QMenu * >(php_qt_fetch(arg_0));
 
-      RETURN_BOOL(obj->autoRaise());
-    }                           /// 5 END getThis(), simple types
+        RETURN_VOID(selfpointer->setMenu((QMenu *) cpp_arg_0));
+      }
+#endif
+
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QToolButton::setMenu(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  staticMetaObject
- *
- *    @flags    s
- *    @access    public
- *    @return    QMetaObject*
- *    @param    
+ * method timerEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTimerEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, staticMetaObject)
-{
-}
 
 /*!
- *    @class     QToolButton
- *    @function  arrowType
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::ArrowType
- *    @param    
+ * method defaultAction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QAction *
+ * @flags	c
  */
-ZEND_METHOD(QToolButton, arrowType)
+
+ZEND_METHOD(QToolButton, defaultAction)
 {
+  ///
+#ifdef PHP_QT_QAction           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::ArrowType * return_object;
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'defaultAction' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-      RETURN_LONG(obj->arrowType());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast < QAction * >(selfpointer->defaultAction());
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QToolButton::defaultAction(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  setDefaultAction
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QAction *
+ * method autoRaise
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QToolButton, setDefaultAction)
+
+ZEND_METHOD(QToolButton, autoRaise)
 {
-///qt_QAction*
-/*! o public*/
-/*! qt_QAction* ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'autoRaise' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
-
-        if (obj_z_0->inherits("QAction")) {
-          void *return_object;
-
-          if (getThis() != NULL) {
-            obj->setDefaultAction((QAction *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->autoRaise());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QToolButton::autoRaise(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  popupMode
- *
- *    @flags    c
- *    @access    public
- *    @return    ToolButtonPopupMode
- *    @param    
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QToolButton, popupMode)
+
+ZEND_METHOD(QToolButton, staticMetaObject)
 {
-/*  if (ZEND_NUM_ARGS() == 0) {
-    ToolButtonPopupMode *return_object;
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QToolButton *
+        selfpointer;
 
-      obj->popupMode();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
-  }*/
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QToolButton::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QToolButton::staticMetaObject(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  qObject
- *
- *    @flags    
- *    @access    public
- *    @return    QObject*
- *    @param    
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QToolButton, qObject)
-{
-}
 
 /*!
- *    @class     QToolButton
- *    @function  minimumSizeHint
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method minimumSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QToolButton, minimumSizeHint)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumSizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->minimumSizeHint());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->minimumSizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QToolButton_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QToolButton::minimumSizeHint(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  sizeHint
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method triggered
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QAction *s0
+ * 
+ * @access	public
+ * @return	Q_SIGNALS: void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, sizeHint)
+
+ZEND_METHOD(QToolButton, triggered)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+  ///QAction *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'triggered' is not static");
+          RETURN_NULL();
+        }
+        /// try QAction *s0,
+        QToolButton *
+          selfpointer;
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+        }
+        QAction *
+          cpp_arg_0 = static_cast < QAction * >(php_qt_fetch(arg_0));
 
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->sizeHint());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+        RETURN_VOID(selfpointer->triggered((QAction *) cpp_arg_0));
+      }
+#endif
+
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QToolButton_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, "could not parse argument in QToolButton::triggered(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  QToolButton
- *
- *    @flags    t
- *    @access    public
- *    @return    
- *    @param    QWidget * parent=0
+ * method toolButtonStyle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::ToolButtonStyle
+ * @flags	c
  */
-ZEND_METHOD(QToolButton, __construct)
+
+ZEND_METHOD(QToolButton, toolButtonStyle)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* parent,  */
-
+  ///
   if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toolButtonStyle' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-    QToolButton *QToolButton_ptr = new QToolButton();
-    PHP_QT_REGISTER(QToolButton_ptr);
-    RETURN_NULL();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->toolButtonStyle());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QToolButton::toolButtonStyle(...) ");
+}
 
-  }                             /// END ZEND_NUM_ARGS
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
+/*!
+ * method setAutoRaise
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enables0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QToolButton, setAutoRaise)
+{
+  ///bool enables0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setAutoRaise' is not static");
+        RETURN_NULL();
+      }
+      /// try bool enables0,
+      QToolButton *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setAutoRaise((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QToolButton::setAutoRaise(...) ");
+}
 
-        if (obj_z_0->inherits("QWidget")) {
-          QToolButton *QToolButton_ptr = new QToolButton((QWidget *) obj_z_0);
+/*!
+ * method arrowType
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::ArrowType
+ * @flags	c
+ */
 
-          PHP_QT_REGISTER(QToolButton_ptr);
-          RETURN_NULL();
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+ZEND_METHOD(QToolButton, arrowType)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'arrowType' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->arrowType());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QToolButton::arrowType(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  menu
- *
- *    @flags    c
- *    @access    public
- *    @return    QMenu*
- *    @param    
+ * method setDefaultAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QAction *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, menu)
+
+ZEND_METHOD(QToolButton, setDefaultAction)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QMenu **return_object;
+  ///QAction *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setDefaultAction' is not static");
+          RETURN_NULL();
+        }
+        /// try QAction *s0,
+        QToolButton *
+          selfpointer;
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+        }
+        QAction *
+          cpp_arg_0 = static_cast < QAction * >(php_qt_fetch(arg_0));
 
-/// return: pointer
+        RETURN_VOID(selfpointer->setDefaultAction((QAction *) cpp_arg_0));
+      }
+#endif
 
-/// return value is object: QMenu*
-      *return_object = static_cast < QMenu * >(obj->menu());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QToolButton_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, "could not parse argument in QToolButton::setDefaultAction(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  nextCheckState
- *
- *    @flags    
- *    @access    protected
- *    @return    void
- *    @param    
+ * method leaveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method nextCheckState is protected, skipped.
 
 /*!
- *    @class     QToolButton
- *    @function  triggered
- *
- *    @flags    
- *    @access    public
- *    @return    Q_SIGNALS: void
- *    @param    QAction *
+ * method nextCheckState
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, triggered)
-{
-///qt_QAction*
-/*! o public*/
-/*! qt_QAction* ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *es0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
+ */
 
-        if (obj_z_0->inherits("QAction")) {
-          void *return_object;
+/*!
+ * method setPopupMode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	ToolButtonPopupMode modes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-          if (getThis() != NULL) {
-//            obj->triggered((QAction *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+ZEND_METHOD(QToolButton, setPopupMode)
+{
+// notice: unknown argument ToolButtonPopupMode modes0, skipped
+  php_error(E_ERROR, "could not parse argument in QToolButton::setPopupMode(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  event
- *
- *    @flags    
- *    @access    protected
- *    @return    bool
- *    @param    QEvent *e
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method event is protected, skipped.
 
 /*!
- *    @class     QToolButton
- *    @function  toolButtonStyle
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::ToolButtonStyle
- *    @param    
+ * method setArrowType
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::ArrowType types0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, toolButtonStyle)
+
+ZEND_METHOD(QToolButton, setArrowType)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    Qt::ToolButtonStyle * return_object;
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+  ///Qt::ArrowType types0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setArrowType' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::ArrowType types0,
+      QToolButton *
+        selfpointer;
 
-      obj->toolButtonStyle();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setArrowType((Qt::ArrowType) Z_LVAL_P(arg_0)));
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QToolButton::setArrowType(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  setPopupMode
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    ToolButtonPopupMode mode
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, setPopupMode)
-{
-///ToolButtonPopupMode
-/*! o public*/
-/*! ToolButtonPopupMode mode,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+/*!
+ * method showMenu
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-        if (obj_z_0->inherits("ToolButtonPopupMode")) {
-          void *return_object;
+ZEND_METHOD(QToolButton, showMenu)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'showMenu' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-          if (getThis() != NULL) {
-//            obj->setPopupMode((ToolButtonPopupMode) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->showMenu());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QToolButton::showMenu(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  setToolButtonStyle
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::ToolButtonStyle style
+ * method mousePressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, setToolButtonStyle)
-{
-///Qt::ToolButtonStyle
-/*! o public*/
-/*! Qt::ToolButtonStyle style,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+/*!
+ * method popupMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	ToolButtonPopupMode
+ * @flags	c
+ */
 
-        if (obj_z_0->inherits("Qt::ToolButtonStyle")) {
-          void *return_object;
-
-          if (getThis() != NULL) {
-  //          obj->setToolButtonStyle((Qt::ToolButtonStyle) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+ZEND_METHOD(QToolButton, popupMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type ToolButtonPopupMode");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QToolButton::popupMode(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  trUtf8
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QToolButton, trUtf8)
+
+ZEND_METHOD(QToolButton, sizeHint)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-        QString *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast < QString > (obj->trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QToolButton::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));       /// memory allocation
-          *return_object = static_cast < QString > (QToolButton::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
 
-        object_init_ex(return_value, QToolButton_ce_ptr);
-        zend_rsrc_list_entry le;
+      *return_object = static_cast < QSize > (selfpointer->sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+  php_error(E_ERROR, "could not parse argument in QToolButton::sizeHint(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  setMenu
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QMenu* menu
+ * method QToolButton
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * parent=0s0
+ * 
+ * overloaded args:
+ * @param	QToolButtonPrivate &
+ * @param	 QWidget* parent
+ * 
+ * overloaded args:
+ * @param	const QToolButton &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QToolButton, setMenu)
+
+ZEND_METHOD(QToolButton, __construct)
 {
-///QMenu*
-/*! o public*/
-/*! QMenu* menu,  */
+  ///QWidget * parent=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton_php_qt *
+        selfpointer = new QToolButton_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget * parent=0s0,
+      QWidget *
+        cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QToolButton_php_qt *
+        selfpointer = new QToolButton_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QToolButtonPrivate &, QWidget* parent
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QToolButtonPrivate
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 71)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QToolButtonPrivate &, QWidget* parent,
+        QToolButtonPrivate *
+          cpp_arg_0 = static_cast < QToolButtonPrivate * >(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+        QToolButton_php_qt *
+          selfpointer = new QToolButton_php_qt(getThis(), (QToolButtonPrivate &) * cpp_arg_0, (QWidget *) cpp_arg_1);
 
-        if (obj_z_0->inherits("QMenu")) {
-          void *return_object;
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setMenu((QMenu *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+#endif
+
+    }
+  }
+  ///const QToolButton &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QToolButton
+      if (inherits(Z_OBJCE_P(arg_0), 67)) {
+/// method is private, skip
+        php_error(E_ERROR, "QToolButton::__construct(...) cannot be called with 'const QToolButton &,'.");
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QToolButton::QToolButton(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  setAutoRaise
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool enable
+ * method menu
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMenu*
+ * @flags	c
  */
-ZEND_METHOD(QToolButton, setAutoRaise)
+
+ZEND_METHOD(QToolButton, menu)
 {
-/*! l public*/
-/*! int enable,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QMenu             // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'menu' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-        void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-          obj->setAutoRaise((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast < QMenu * >(selfpointer->menu());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QToolButton::menu(...) ");
 }
 
 /*!
- *    @class     QToolButton
- *    @function  setArrowType
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::ArrowType type
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QToolButton, setArrowType)
+
+ZEND_METHOD(QToolButton, trUtf8)
 {
-/*! l public*/
-/*! int type,  */
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QToolButton *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        void *return_object;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        if (getThis() != NULL) {
-          obj->setArrowType((Qt::ArrowType) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QToolButton::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
       } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QToolButton *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QToolButton * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-PHP_QT_DESTRUCT(QToolButton);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QToolButton::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QToolButton::trUtf8(...) ");
+}

Modified: trunk/qt/classes/qvboxlayout.cpp
===================================================================
--- trunk/qt/classes/qvboxlayout.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qvboxlayout.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,143 +19,412 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QVBoxLayout.cpp - QVBoxLayout PHP implementation.
- * begin           : Thu Feb 23 16:39:38 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
+
 #include "../php_qt.h"
 
 
 #include <QVBoxLayout>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QVBoxLayout_php_qt:public QVBoxLayout
+{
 
-/*********************************
- *    class     QVBoxLayout
- *    function  tr
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
- */
-ZEND_METHOD(QVBoxLayout, tr){
-		/* ss public*/
+public:
+  QVBoxLayout_php_qt(zval * zend_ptr);
+  QVBoxLayout_php_qt(zval * zend_ptr, QWidget * parents0);
 
-		/* const char* , const char* ,  */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QVBoxLayout *obj = (QVBoxLayout*) PHP_QT_FETCH();
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
+QVBoxLayout_php_qt::QVBoxLayout_php_qt(zval * zend_ptr):QVBoxLayout()
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QVBoxLayout",&staticMetaObject));
+}
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QVBoxLayout::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QVBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+QVBoxLayout_php_qt::QVBoxLayout_php_qt(zval * zend_ptr, QWidget * parents0):QVBoxLayout(parents0)
+{
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QVBoxLayout",&staticMetaObject));
 }
 
-/*********************************
- *    class     QVBoxLayout
- *    function  staticMetaObject
- *    flags:    s
- *    access:    public
- *    return:    QMetaObject*
- *    params:    
+PHP_QT_MOC(QVBoxLayout);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QVBoxLayout, staticMetaObject){
+
+ZEND_METHOD(QVBoxLayout, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QVBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QVBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QVBoxLayout::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QVBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QVBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QVBoxLayout::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QVBoxLayout::tr(...) ");
 }
 
-/*********************************
- *    class     QVBoxLayout
- *    function  qObject
- *    flags:    
- *    access:    public
- *    return:    QObject*
- *    params:    
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QVBoxLayout, qObject){
-}
 
-/*********************************
- *    class     QVBoxLayout
- *    function  trUtf8
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QVBoxLayout, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING){
-			QVBoxLayout *obj = (QVBoxLayout*) PHP_QT_FETCH();
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj->trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QVBoxLayout::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QVBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,"argument not allowed"); }
-		}
-	}
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
+ */
+
+ZEND_METHOD(QVBoxLayout, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QVBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QVBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QVBoxLayout::staticMetaObject());
+      } else {
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QVBoxLayout::staticMetaObject(...) ");
 }
 
-/*********************************
- *    class     QVBoxLayout
- *    function  QVBoxLayout
- *    flags:    
- *    access:    public
- *    return:    
- *    params:    
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QVBoxLayout, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QVBoxLayout *QVBoxLayout_ptr = new QVBoxLayout();
-				PHP_QT_REGISTER(QVBoxLayout_ptr);
-				RETURN_NULL();
-	}
-/// handmade
-    if (ZEND_NUM_ARGS() == 1){
-    	zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-            QWidget *qw = static_cast<QWidget*>(php_qt_fetch(z_0));
-			QVBoxLayout *QVBoxLayout_ptr = new QVBoxLayout(qw);
-			PHP_QT_REGISTER(QVBoxLayout_ptr);
-			RETURN_NULL();
+
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
+
+/*!
+ * method QVBoxLayout
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parents0
+ * 
+ * overloaded args:
+ * @param	const QVBoxLayout &
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QVBoxLayout, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QVBoxLayout_php_qt *
+        selfpointer = new QVBoxLayout_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QWidget *parents0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
         }
-	}
+        /// try QWidget *parents0,
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+        QVBoxLayout_php_qt *
+          selfpointer = new QVBoxLayout_php_qt(getThis(), (QWidget *) cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QVBoxLayout &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVBoxLayout
+      if (inherits(Z_OBJCE_P(arg_0), 68)) {
+/// method is private, skip
+        php_error(E_ERROR, "QVBoxLayout::__construct(...) cannot be called with 'const QVBoxLayout &,'.");
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QVBoxLayout::QVBoxLayout(...) ");
 }
 
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
 
-PHP_QT_DESTRUCT(QVBoxLayout);
+ZEND_METHOD(QVBoxLayout, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QVBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QVBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QVBoxLayout::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QVBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QVBoxLayout * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QVBoxLayout::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QVBoxLayout::trUtf8(...) ");
+}

Modified: trunk/qt/classes/qwhatsthisclickedevent.cpp
===================================================================
--- trunk/qt/classes/qwhatsthisclickedevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qwhatsthisclickedevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,36 +19,117 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QWhatsThisClickedEvent.cpp - QWhatsThisClickedEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QWhatsThisClickedEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QWhatsThisClickedEvent */
-/*
- *    function  href
- *    flags:    c
+#include <QWhatsThisClickedEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QWhatsThisClickedEvent_php_qt:public QWhatsThisClickedEvent
+{
+
+public:
+  QWhatsThisClickedEvent_php_qt(zval * zend_ptr, const QString & hrefs0);
+
+
+  zval *zend_ptr;
+};
+QWhatsThisClickedEvent_php_qt::QWhatsThisClickedEvent_php_qt(zval * zend_ptr, const QString & hrefs0):
+QWhatsThisClickedEvent(hrefs0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QWhatsThisClickedEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &hrefs0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QWhatsThisClickedEvent, href){
-	if (ZEND_NUM_ARGS() == 0){
-			QWhatsThisClickedEvent *obj = (QWhatsThisClickedEvent*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->href();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWhatsThisClickedEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWhatsThisClickedEvent, __construct)
+{
+  ///const QString &hrefs0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &hrefs0s0,
+        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
+        QWhatsThisClickedEvent_php_qt *selfpointer = new QWhatsThisClickedEvent_php_qt(getThis(), (const QString &)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWhatsThisClickedEvent::QWhatsThisClickedEvent(...) ");
 }
 
+/*!
+ * method href
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QWhatsThisClickedEvent);
+ZEND_METHOD(QWhatsThisClickedEvent, href)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'href' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWhatsThisClickedEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWhatsThisClickedEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->href());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWhatsThisClickedEvent::href(...) ");
+}

Modified: trunk/qt/classes/qwheelevent.cpp
===================================================================
--- trunk/qt/classes/qwheelevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qwheelevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,152 +19,486 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QWheelEvent.cpp - QWheelEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QWheelEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  orientation
- *    flags:    c
+#include <QWheelEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QWheelEvent_php_qt:public QWheelEvent
+{
+
+public:
+  QWheelEvent_php_qt(zval * zend_ptr, const QPoint & poss0, int deltas1, Qt::MouseButtons buttonss2, Qt::KeyboardModifiers modifierss3, Qt::Orientation orient =
+                     Qt::Vertical);
+    QWheelEvent_php_qt(zval * zend_ptr, const QPoint & poss0, const QPoint & globalPoss1, int deltas2, Qt::MouseButtons buttonss3,
+                       Qt::KeyboardModifiers modifierss4, Qt::Orientation orient = Qt::Vertical);
+
+
+  zval *zend_ptr;
+};
+QWheelEvent_php_qt::QWheelEvent_php_qt(zval * zend_ptr, const QPoint & poss0, int deltas1, Qt::MouseButtons buttonss2, Qt::KeyboardModifiers modifierss3,
+                                       Qt::Orientation orient):
+QWheelEvent(poss0, deltas1, buttonss2, modifierss3, orient)
+{
+  this->zend_ptr = zend_ptr;
+}
+QWheelEvent_php_qt::QWheelEvent_php_qt(zval * zend_ptr, const QPoint & poss0, const QPoint & globalPoss1, int deltas2, Qt::MouseButtons buttonss3,
+                                       Qt::KeyboardModifiers modifierss4, Qt::Orientation orient):
+QWheelEvent(poss0, globalPoss1, deltas2, buttonss3, modifierss4, orient)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method y
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, orientation){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->orientation());
-	}
+
+ZEND_METHOD(QWheelEvent, y)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'y' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWheelEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->y());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWheelEvent::y(...) ");
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  x
- *    flags:    c
+/*!
+ * method delta
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, x){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->x());
-	}
+
+ZEND_METHOD(QWheelEvent, delta)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'delta' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWheelEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->delta());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWheelEvent::delta(...) ");
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  globalX
- *    flags:    c
+/*!
+ * method QWheelEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &poss0s0
+ * @param	int deltas1s1
+ * @param	Qt::MouseButtons buttonss2s2
+ * @param	Qt::KeyboardModifiers modifierss3s3
+ * @param	 Qt::Orientation orient = Qt::Verticals4
+ * 
+ * overloaded args:
+ * @param	const QPoint &poss0
+ * @param	const QPoint& globalPoss1
+ * @param	int deltas2
+ * @param	Qt::MouseButtons buttonss3
+ * @param	Qt::KeyboardModifiers modifierss4
+ * @param	 Qt::Orientation orient = Qt::Vertical
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QWheelEvent, globalX){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->globalX());
-	}
+
+ZEND_METHOD(QWheelEvent, __construct)
+{
+  ///const QPoint &poss0s0,int deltas1s1,Qt::MouseButtons buttonss2s2,Qt::KeyboardModifiers modifierss3s3, Qt::Orientation orient = Qt::Verticals4
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &poss0s0,int deltas1s1,Qt::MouseButtons buttonss2s2,Qt::KeyboardModifiers modifierss3s3,
+        QPoint *cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QWheelEvent_php_qt *selfpointer =
+          new QWheelEvent_php_qt(getThis(), (const QPoint &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::MouseButtons) Z_LVAL_P(arg_2),
+                                 (Qt::KeyboardModifiers) Z_LVAL_P(arg_3));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &poss0s0,int deltas1s1,Qt::MouseButtons buttonss2s2,Qt::KeyboardModifiers modifierss3s3, Qt::Orientation orient = Qt::Verticals4,
+        QPoint *cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QWheelEvent_php_qt *selfpointer =
+          new QWheelEvent_php_qt(getThis(), (const QPoint &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::MouseButtons) Z_LVAL_P(arg_2),
+                                 (Qt::KeyboardModifiers) Z_LVAL_P(arg_3), (Qt::Orientation) Z_LVAL_P(arg_4));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QPoint &poss0,const QPoint& globalPoss1,int deltas2,Qt::MouseButtons buttonss3,Qt::KeyboardModifiers modifierss4, Qt::Orientation orient = Qt::Vertical
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &poss0,const QPoint& globalPoss1,int deltas2,Qt::MouseButtons buttonss3,Qt::KeyboardModifiers modifierss4,
+        QPoint *cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QPoint *cpp_arg_1 = static_cast < QPoint * >(php_qt_fetch(arg_1));
+        QWheelEvent_php_qt *selfpointer =
+          new QWheelEvent_php_qt(getThis(), (const QPoint &)*cpp_arg_0, (const QPoint &)*cpp_arg_1, (int)Z_LVAL_P(arg_2), (Qt::MouseButtons) Z_LVAL_P(arg_3),
+                                 (Qt::KeyboardModifiers) Z_LVAL_P(arg_4));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
+        Z_TYPE_P(arg_4) == IS_LONG && Z_TYPE_P(arg_5) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &poss0,const QPoint& globalPoss1,int deltas2,Qt::MouseButtons buttonss3,Qt::KeyboardModifiers modifierss4, Qt::Orientation orient = Qt::Vertical,
+        QPoint *cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        QPoint *cpp_arg_1 = static_cast < QPoint * >(php_qt_fetch(arg_1));
+        QWheelEvent_php_qt *selfpointer =
+          new QWheelEvent_php_qt(getThis(), (const QPoint &)*cpp_arg_0, (const QPoint &)*cpp_arg_1, (int)Z_LVAL_P(arg_2), (Qt::MouseButtons) Z_LVAL_P(arg_3),
+                                 (Qt::KeyboardModifiers) Z_LVAL_P(arg_4), (Qt::Orientation) Z_LVAL_P(arg_5));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWheelEvent::QWheelEvent(...) ");
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  globalPos
- *    flags:    c
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, globalPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-				const QPoint & return_object = (const QPoint &) obj->globalPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWheelEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWheelEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWheelEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWheelEvent::pos(...) ");
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  y
- *    flags:    c
+/*!
+ * method globalX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, y){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->y());
-	}
+
+ZEND_METHOD(QWheelEvent, globalX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalX' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWheelEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->globalX());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWheelEvent::globalX(...) ");
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  delta
- *    flags:    c
+/*!
+ * method globalPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, delta){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->delta());
-	}
+
+ZEND_METHOD(QWheelEvent, globalPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalPos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWheelEvent * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &const_cast < QPoint & >(selfpointer->globalPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWheelEvent::globalPos(...) ");
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  globalY
- *    flags:    c
+/*!
+ * method buttons
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::MouseButtons
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, globalY){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj->globalY());
-	}
+
+ZEND_METHOD(QWheelEvent, buttons)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'buttons' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWheelEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->buttons());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWheelEvent::buttons(...) ");
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method orientation
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientation
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-				const QPoint & return_object = (const QPoint &) obj->pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWheelEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWheelEvent, orientation)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'orientation' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWheelEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->orientation());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWheelEvent::orientation(...) ");
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  buttons
- *    flags:    c
+/*!
+ * method x
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, buttons){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-				Qt::MouseButtons return_object = (Qt::MouseButtons) obj->buttons();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWheelEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWheelEvent, x)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'x' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWheelEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->x());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWheelEvent::x(...) ");
 }
 
+/*!
+ * method globalY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QWheelEvent);
+ZEND_METHOD(QWheelEvent, globalY)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'globalY' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWheelEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->globalY());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWheelEvent::globalY(...) ");
+}

Modified: trunk/qt/classes/qwidget.cpp
===================================================================
--- trunk/qt/classes/qwidget.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qwidget.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QWidget.cpp - QWidget PHP implementation.
- * begin           : Tue Apr 11 10:33:13 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -29,5858 +28,9192 @@
 
 #include "../php_qt.h"
 
+
 #include <QWidget>
 #include <QIcon>
+/// DEBUG:destructor skipped.
 #include <QMetaMethod>
-
-class QWidget_moc : public QWidget
+class QWidget_php_qt:public QWidget
 {
-    public:
-        QWidget_moc(zval* zend_ptr);
 
-        zval* zend_ptr;
-        QMetaObject* dynamicMetaObject;
+public:
+  QWidget_php_qt(zval * zend_ptr, QWidget * parent = 0, Qt::WFlags f = 0);
 
-        const QMetaObject* metaObject() const;
-        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
-        
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
 };
 
-const QMetaObject *QWidget_moc::metaObject() const
+QWidget_php_qt::QWidget_php_qt(zval * zend_ptr, QWidget * parent, Qt::WFlags f):QWidget(parent, f)
 {
-    return php_qt_getMocData(this->zend_ptr,"QWidget",&staticMetaObject);;
+  this->zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QWidget",&staticMetaObject));
 }
 
-QWidget_moc::QWidget_moc(zval* zend_ptr)
-{
-    this->zend_ptr = zend_ptr;
-    dynamicMetaObject = new QMetaObject;
-    dynamicMetaObject = php_qt_getMocData(this->zend_ptr,"QWidget",&staticMetaObject);
-//    cout << dynamicMetaObject->indexOfSignal("valueChanged(int)")<<"\n";
-}
+PHP_QT_MOC(QWidget);
 
-int QWidget_moc::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+/*!
+ * method nextInFocusChain
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
+ */
+
+ZEND_METHOD(QWidget, nextInFocusChain)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
 
-    QMetaObject* d = (QMetaObject*) this->metaObject();
-    char* method_name = new char[strlen((d->method(_id)).signature())];
-    strcpy(method_name,(char*) (d->method(_id)).signature());
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'nextInFocusChain' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    // breaks the string at the first bracket
-    int i;
-    for(i = 0; i < strlen(method_name); i++){
-        if(method_name[i] == 40){
-            method_name[i] = 0;
-            break;
-        }
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast < QWidget * >(selfpointer->nextInFocusChain());
+      php_qt_register(return_value, le);
+      return;
     }
+  }
+#endif // return type
 
-    // is a Slot
-    if(d->method(_id).methodType() == QMetaMethod::Slot){
-        int j = 0;
-        zval** args[1];
-        QList<QByteArray> qargs = d->method(_id).parameterTypes();
-        for(i = 0; i < qargs.count(); i++){
+  php_error(E_ERROR, "could not parse argument in QWidget::nextInFocusChain(...) ");
+}
 
-            zval *arg;
-            MAKE_STD_ZVAL(arg);
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
 
-            // invoke to zend types
-            if(!strncmp("int",(const char*) qargs[i],3)){
-                ZVAL_LONG(arg, *reinterpret_cast< int*>(_a[i+1]));
-            } else if(!strncmp("char*",(const char*) qargs[i],5)){
-                ZVAL_STRING(arg, *reinterpret_cast< char**>(_a[i+1]), 1);
-            } else if(!strncmp("bool",(const char*) qargs[i],4)){
-                ZVAL_BOOL(arg, *reinterpret_cast< bool*>(_a[i+1]));
-            } else if(!strncmp("double",(const char*) qargs[i],4)){
-                ZVAL_DOUBLE(arg, *reinterpret_cast< double*>(_a[i+1]));
-            } else {
-                    // must be an object
-                    zend_class_entry *ce;
-                    object_init_ex(arg, QWidget_ce_ptr);
-                    zend_rsrc_list_entry le;
-                    le.ptr = *reinterpret_cast< QObject**>(_a[1]);
-                    php_qt_register(arg, le);
-                    
-            }
+ZEND_METHOD(QWidget, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-            args[j++] = &arg;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QWidget *
+        selfpointer;
 
-        }
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        php_qt_callmethod(this->zend_ptr, method_name, j, args);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-    // is a signal
-    } else {
-        void *_b[] = { 0, _a[1] };
-        QMetaObject::activate(this, d, 0, _b);
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QWidget::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QWidget *
+        selfpointer;
 
-    delete d;
-    delete method_name;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-    return _id;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QWidget::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::tr(...) ");
 }
 
-
 /*!
- *    @class     QWidget
- *    @function  nextInFocusChain
- *
- *    @flags     c
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method focusPolicy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::FocusPolicy
+ * @flags	c
  */
-ZEND_METHOD(QWidget, nextInFocusChain)
+
+ZEND_METHOD(QWidget, focusPolicy)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'focusPolicy' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-/// return: pointer
-
-/// return value is object: QWidget *
-      *return_object = static_cast < QWidget * >(obj->nextInFocusChain());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->focusPolicy());
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::focusPolicy(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  tr
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method mouseMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QWidget, tr)
+
+/*!
+ * method insertActions
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QAction *befores0
+ * @param	 QList<QAction*> actionss1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QWidget, insertActions)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
+  ///QAction *befores0, QList<QAction*> actionss1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+#ifdef PHP_QT_QList
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'insertActions' is not static");
+          RETURN_NULL();
+        }
+        /// try QAction *befores0, QList<QAction*> actionss1,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        QString *return_object;
-
         if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast < QString > (obj->tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QWidget::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));       /// memory allocation
-          *return_object = static_cast < QString > (QWidget::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QAction *
+          cpp_arg_0 = static_cast < QAction * >(php_qt_fetch(arg_0));
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+        QList < QAction > *cpp_arg_1 = static_cast < QList < QAction > *>(php_qt_fetch(arg_1));
+        RETURN_VOID(selfpointer->insertActions((QAction *) cpp_arg_0, (QList < QAction > *)cpp_arg_1));
+      }
+#endif
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
+#endif
 
-/*!
- *    @class     QWidget
- *    @function  focusPolicy
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::FocusPolicy
- *    @param    
- */
-ZEND_METHOD(QWidget, focusPolicy)
-{
-  if (ZEND_NUM_ARGS() == 0) {
-    Qt::FocusPolicy * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->focusPolicy());
-    }                           /// 5 END getThis(), simple types
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::insertActions(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowOpacity
- *
- *    @flags    c
- *    @access    public
- *    @return    qreal
- *    @param    
+ * method windowOpacity
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowOpacity)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    qreal *return_object;
-
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_DOUBLE(obj->windowOpacity());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type qreal");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::windowOpacity(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  y
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method y
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, y)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'y' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->y());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->y());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::y(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  clearFocus
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method clearFocus
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, clearFocus)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'clearFocus' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->clearFocus();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->clearFocus());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::clearFocus(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  fontInfo
- *
- *    @flags    c
- *    @access    public
- *    @return    QFontInfo
- *    @param    
+ * method fontInfo
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QFontInfo
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, fontInfo)
 {
+  ///
+#ifdef PHP_QT_QFontInfo         // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QFontInfo *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'fontInfo' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QFontInfo
-      *return_object = static_cast < QFontInfo > (obj->fontInfo());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QFontInfo *
+        return_object = new QFontInfo;
+
+      *return_object = static_cast < QFontInfo > (selfpointer->fontInfo());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::fontInfo(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isHidden
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isHidden
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isHidden)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isHidden' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isHidden());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isHidden());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isHidden(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMaximumWidth
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int maxw
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
+
+/*!
+ * method styleChange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QStyle &s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method setMaximumWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int maxws0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setMaximumWidth)
 {
-/*! l public*/
-/*! int maxw,  */
+  ///int maxws0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMaximumWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int maxws0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setMaximumWidth((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMaximumWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setMaximumWidth(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  contentsRect
- *
- *    @flags    c
- *    @access    public
- *    @return    QRect
- *    @param    
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
+
+/*!
+ * method contentsRect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, contentsRect)
 {
+  ///
+#ifdef PHP_QT_QRect             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRect *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'contentsRect' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRect
-      *return_object = static_cast < QRect > (obj->contentsRect());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast < QRect > (selfpointer->contentsRect());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::contentsRect(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setContextMenuPolicy
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::ContextMenuPolicy policy
+ * method setContextMenuPolicy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::ContextMenuPolicy policys0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setContextMenuPolicy)
 {
-/*! l public*/
-/*! int policy,  */
+  ///Qt::ContextMenuPolicy policys0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setContextMenuPolicy' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::ContextMenuPolicy policys0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setContextMenuPolicy((Qt::ContextMenuPolicy) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setContextMenuPolicy((Qt::ContextMenuPolicy) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setContextMenuPolicy(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  focusProxy
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method focusProxy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, focusProxy)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'focusProxy' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast < QWidget * >(obj->focusProxy());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      le.ptr = static_cast < QWidget * >(selfpointer->focusProxy());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::focusProxy(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  statusTip
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method statusTip
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, statusTip)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'statusTip' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast < QString > (obj->statusTip());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->statusTip());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::statusTip(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  visibleRegion
- *
- *    @flags    c
- *    @access    public
- *    @return    QRegion
- *    @param    
+ * method visibleRegion
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRegion
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, visibleRegion)
 {
+  ///
+#ifdef PHP_QT_QRegion           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRegion *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'visibleRegion' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRegion
-      *return_object = static_cast < QRegion > (obj->visibleRegion());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRegion *
+        return_object = new QRegion;
+
+      *return_object = static_cast < QRegion > (selfpointer->visibleRegion());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::visibleRegion(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isVisibleTo
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    QWidget*
+ * method isVisibleTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isVisibleTo)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* ,  */
+  ///QWidget *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'isVisibleTo' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QWidget")) {
-          bool *return_object;
+        RETURN_BOOL(selfpointer->isVisibleTo((QWidget *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            RETURN_BOOL(obj->isVisibleTo((QWidget *) obj_z_0));
-          }                     /// 5 END getThis(), simple types
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::isVisibleTo(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  releaseMouse
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method releaseMouse
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, releaseMouse)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'releaseMouse' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->releaseMouse();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->releaseMouse());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::releaseMouse(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setTabOrder
- *
- *    @flags    s
- *    @access    public
- *    @return    void
- *    @param    QWidget *, QWidget *
+ * method setTabOrder
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * @param	 QWidget *s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
+
 ZEND_METHOD(QWidget, setTabOrder)
 {
-///QWidget*
-///QWidget*
-/*! oo public*/
-/*! QWidget* , QWidget* ,  */
+  ///QWidget *s0, QWidget *s1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71) && inherits(Z_OBJCE_P(arg_1), 71)) {
+        /// try QWidget *s0, QWidget *s1,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
-        QObject *obj_z_1 = (QObject *) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
 
-        if (obj_z_0->inherits("QWidget") && obj_z_1->inherits("QWidget")) {
-          void *return_object;
+        if (getThis() == NULL) {
+          RETURN_VOID(QWidget::setTabOrder((QWidget *) cpp_arg_0, (QWidget *) cpp_arg_1));
+        } else {
+          RETURN_VOID(selfpointer->setTabOrder((QWidget *) cpp_arg_0, (QWidget *) cpp_arg_1));
+        }
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setTabOrder((QWidget *) obj_z_0, (QWidget *) obj_z_1);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setTabOrder(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setFocusProxy
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QWidget *
+ * method setFocusProxy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setFocusProxy)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* ,  */
+  ///QWidget *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setFocusProxy' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QWidget")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setFocusProxy((QWidget *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setFocusProxy((QWidget *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setFocusProxy(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  topLevelWidget
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
+
+/*!
+ * method topLevelWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, topLevelWidget)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'topLevelWidget' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast < QWidget * >(obj->topLevelWidget());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      le.ptr = static_cast < QWidget * >(selfpointer->topLevelWidget());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::topLevelWidget(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  mapToParent
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    const QPoint &
+ * method mapToParent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &s0
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, mapToParent)
 {
-/*! l public*/
-/*! const QPoint& ,  */
+  ///const QPoint &s0
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'mapToParent' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        QPoint *return_object;
-
         if (getThis() != NULL) {
-/// return value is object: QPoint
-          *return_object = static_cast < QPoint > (obj->mapToParent((const QPoint &)Z_LVAL_P(z_0)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, "Object not found");
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
         }
-        zend_class_entry *ce;
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        zend_class_entry *
+          ce;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QPoint *
+          return_object = new QPoint;
 
-        le.ptr = return_object;
+        *return_object = static_cast < QPoint > (selfpointer->mapToParent((const QPoint &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
         php_qt_register(return_value, le);
         return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::mapToParent(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  overrideWindowFlags
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::WindowFlags type
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
+
+/*!
+ * method overrideWindowFlags
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WindowFlags types0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, overrideWindowFlags)
 {
-/*! l public*/
-/*! int type,  */
+  ///Qt::WindowFlags types0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'overrideWindowFlags' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::WindowFlags types0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->overrideWindowFlags((Qt::WindowFlags) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->overrideWindowFlags((Qt::WindowFlags) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::overrideWindowFlags(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  hide
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method hide
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, hide)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hide' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->hide();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->hide());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::hide(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  mapTo
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    QWidget *, const QPoint &
+ * method mapTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * @param	 const QPoint  &s1
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, mapTo)
 {
-///QWidget*
-/*! ol public*/
-/*! QWidget* , const QPoint& ,  */
+  ///QWidget *s0, const QPoint  &s1
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 71) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'mapTo' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *s0, const QPoint  &s1,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+        QPoint *
+          cpp_arg_1 = static_cast < QPoint * >(php_qt_fetch(arg_1));
+        zend_class_entry *
+          ce;
 
-        if (obj_z_0->inherits("QWidget")) {
-          QPoint *return_object;
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QPoint *
+          return_object = new QPoint;
 
-          if (getThis() != NULL) {
-/// return value is object: QPoint
-            *return_object = static_cast < QPoint > (obj->mapTo((QWidget *) obj_z_0, (const QPoint &)Z_LVAL_P(z_1)));
-          } else {              /// END getThis(), static
-            php_error(E_ERROR, "Object not found");
-          }
-          zend_class_entry *ce;
+        *return_object = static_cast < QPoint > (selfpointer->mapTo((QWidget *) cpp_arg_0, (const QPoint &)*cpp_arg_1));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-          object_init_ex(return_value, QWidget_ce_ptr);
-          zend_rsrc_list_entry le;
+#endif
 
-          le.ptr = return_object;
-          php_qt_register(return_value, le);
-          return;
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::mapTo(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  childrenRect
- *
- *    @flags    c
- *    @access    public
- *    @return    QRect
- *    @param    
+ * method childrenRect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, childrenRect)
 {
+  ///
+#ifdef PHP_QT_QRect             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRect *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'childrenRect' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRect
-      *return_object = static_cast < QRect > (obj->childrenRect());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast < QRect > (selfpointer->childrenRect());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::childrenRect(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setStyle
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QStyle *
+ * method setStyle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QStyle *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setStyle)
 {
-///qt_QStyle*
-/*! o public*/
-/*! qt_QStyle* ,  */
+  ///QStyle *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QStyle
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setStyle' is not static");
+          RETURN_NULL();
+        }
+        /// try QStyle *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QStyle *
+          cpp_arg_0 = static_cast < QStyle * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QStyle")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setStyle((QStyle *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setStyle((QStyle *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setStyle(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isRightToLeft
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isRightToLeft
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isRightToLeft)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isRightToLeft' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isRightToLeft());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isRightToLeft());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isRightToLeft(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowModified
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    bool
+ * method setWindowModified
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, setWindowModified)
 {
-/*! l public_slots*/
-/*! int ,  */
+  ///bool bools0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setWindowModified' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setWindowModified((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setWindowModified((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setWindowModified(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setBackgroundRole
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QPalette::ColorRole
+ * method setBackgroundRole
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPalette::ColorRole QPalette::ColorRoles0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setBackgroundRole)
 {
-/*! l public*/
-/*! int ,  */
+  ///QPalette::ColorRole QPalette::ColorRoles0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setBackgroundRole' is not static");
+        RETURN_NULL();
+      }
+      /// try QPalette::ColorRole QPalette::ColorRoles0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setBackgroundRole((QPalette::ColorRole) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setBackgroundRole((QPalette::ColorRole) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setBackgroundRole(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setFixedSize
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QSize &
+ * method setFixedSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &s0
+ * 
+ * overloaded args:
+ * @param	int w
+ * @param	 int h
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setFixedSize)
 {
-///const QSize&
-/*! o public*/
-/*! const QSize& ,  */
+  ///const QSize &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setFixedSize' is not static");
+          RETURN_NULL();
+        }
+        /// try const QSize &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QSize *
+          cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QSize")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setFixedSize((const QSize &)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setFixedSize((const QSize &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  ///int w, int h
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setFixedSize' is not static");
+        RETURN_NULL();
+      }
+      /// try int w, int h,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setFixedSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setFixedSize(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  focusPreviousChild
- *
- *    @flags    
- *    @access    protected
- *    @return    bool
- *    @param    
+ * method focusPreviousChild
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-// method focusPreviousChild is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  inputContext
- *
- *    @flags    
- *    @access    public
- *    @return    QInputContext *
- *    @param    
+ * method dragLeaveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDragLeaveEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method inputContext
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QInputContext *
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, inputContext)
 {
+  ///
+#ifdef PHP_QT_QInputContext     // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QInputContext **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'inputContext' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QInputContext *
-      *return_object = static_cast < QInputContext * >(obj->inputContext());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      le.ptr = static_cast < QInputContext * >(selfpointer->inputContext());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::inputContext(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  palette
- *
- *    @flags    c
- *    @access    public
- *    @return    const QPalette &
- *    @param    
+ * method palette
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPalette &
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, palette)
 {
+  ///
+#ifdef PHP_QT_QPalette          // return type
+
   if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'palette' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &const_cast < QPalette & >(selfpointer->palette());
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::palette(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setFixedHeight
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int h
+ * method setFixedHeight
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int hs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setFixedHeight)
 {
-/*! l public*/
-/*! int h,  */
+  ///int hs0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setFixedHeight' is not static");
+        RETURN_NULL();
+      }
+      /// try int hs0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setFixedHeight((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setFixedHeight((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setFixedHeight(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  repaint
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int x, int y, int w, int h
+ * method repaint
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int xs0
+ * @param	 int ys1
+ * @param	 int ws2
+ * @param	 int hs3
+ * 
+ * overloaded args:
+ * @param	const QRect &
+ * 
+ * overloaded args:
+ * @param	const QRegion &
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, repaint)
 {
-/*! llll public*/
-/*! int x, int y, int w, int h,  */
+  ///int xs0, int ys1, int ws2, int hs3
   if (ZEND_NUM_ARGS() == 4) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'repaint' is not static");
+        RETURN_NULL();
+      }
+      /// try int xs0, int ys1, int ws2, int hs3,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->repaint((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  ///const QRect &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'repaint' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &,
+        QWidget *
+          selfpointer;
 
-        void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->repaint((const QRect &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///const QRegion &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegion
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'repaint' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegion &,
+        QWidget *
+          selfpointer;
+
         if (getThis() != NULL) {
-          obj->repaint((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1), (int)Z_LVAL_P(z_2), (int)Z_LVAL_P(z_3));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QRegion *
+          cpp_arg_0 = static_cast < QRegion * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->repaint((const QRegion &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'repaint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->repaint());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::repaint(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  cursor
- *
- *    @flags    c
- *    @access    public
- *    @return    QCursor
- *    @param    
+ * method cursor
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QCursor
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, cursor)
 {
+  ///
+#ifdef PHP_QT_QCursor           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QCursor *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'cursor' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QCursor
-      *return_object = static_cast < QCursor > (obj->cursor());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QCursor *
+        return_object = new QCursor;
+
+      *return_object = static_cast < QCursor > (selfpointer->cursor());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::cursor(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowIconText
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &
+ * method setWindowIconText
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWindowIconText)
 {
-///const QString&
-/*! o public*/
-/*! const QString& ,  */
+  ///const QString &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setWindowIconText' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)->name, "QString")) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj->setWindowIconText((const QString &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->setWindowIconText((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setWindowIconText(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  fontMetrics
- *
- *    @flags    c
- *    @access    public
- *    @return    QFontMetrics
- *    @param    
+ * method fontMetrics
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QFontMetrics
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, fontMetrics)
 {
+  ///
+#ifdef PHP_QT_QFontMetrics      // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QFontMetrics *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'fontMetrics' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QFontMetrics
-      *return_object = static_cast < QFontMetrics > (obj->fontMetrics());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QFontMetrics *
+        return_object = new QFontMetrics;
+
+      *return_object = static_cast < QFontMetrics > (selfpointer->fontMetrics());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::fontMetrics(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  grabShortcut
- *
- *    @flags    
- *    @access    public
- *    @return    int
- *    @param    const QKeySequence &key, Qt::ShortcutContext context = Qt::WindowShortcut
+ * method grabShortcut
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QKeySequence &keys0
+ * @param	 Qt::ShortcutContext context = Qt::WindowShortcuts1
+ * 
+ * @access	public
+ * @return	int
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, grabShortcut)
 {
-///const QKeySequence&
-/*! ol public*/
-/*! const QKeySequence& key, int context,  */
+  ///const QKeySequence &keys0, Qt::ShortcutContext context = Qt::WindowShortcuts1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QKeySequence
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'grabShortcut' is not static");
+          RETURN_NULL();
+        }
+        /// try const QKeySequence &keys0,
+        QWidget *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QKeySequence *
+          cpp_arg_0 = static_cast < QKeySequence * >(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer->grabShortcut((const QKeySequence &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QKeySequence
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'grabShortcut' is not static");
+          RETURN_NULL();
+        }
+        /// try const QKeySequence &keys0, Qt::ShortcutContext context = Qt::WindowShortcuts1,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QKeySequence *
+          cpp_arg_0 = static_cast < QKeySequence * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QKeySequence")) {
-          int *return_object;
+        RETURN_LONG(selfpointer->grabShortcut((const QKeySequence &)*cpp_arg_0, (Qt::ShortcutContext) Z_LVAL_P(arg_1)));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            RETURN_LONG(obj->grabShortcut((const QKeySequence &)*obj_z_0, (Qt::ShortcutContext) Z_LVAL_P(z_1)));
-          }                     /// 5 END getThis(), simple types
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::grabShortcut(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  releaseKeyboard
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method releaseKeyboard
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, releaseKeyboard)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'releaseKeyboard' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->releaseKeyboard();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->releaseKeyboard());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::releaseKeyboard(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setAccessibleDescription
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &description
+ * method setAccessibleDescription
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &descriptions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setAccessibleDescription)
 {
-///const QString&
-/*! o public*/
-/*! const QString& description,  */
+  ///const QString &descriptions0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setAccessibleDescription' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &descriptions0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)->name, "QString")) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj->setAccessibleDescription((const QString &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->setAccessibleDescription((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setAccessibleDescription(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  qObject
- *
- *    @flags    
- *    @access    public
- *    @return    QObject*
- *    @param    
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QWidget, qObject)
-{
-}
 
 /*!
- *    @class     QWidget
- *    @function  maximumWidth
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method maximumWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, maximumWidth)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'maximumWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->maximumWidth());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->maximumWidth());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::maximumWidth(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowOpacity
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    qreal level
+ * method setWindowOpacity
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	qreal levels0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWindowOpacity)
 {
-/*! l public*/
-/*! double level,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
-
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setWindowOpacity((qreal) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+// notice: unknown argument qreal levels0, skipped
+  php_error(E_ERROR, "could not parse argument in QWidget::setWindowOpacity(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isTopLevel
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isTopLevel
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isTopLevel)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isTopLevel' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isTopLevel());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isTopLevel());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isTopLevel(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  mask
- *
- *    @flags    c
- *    @access    public
- *    @return    QRegion
- *    @param    
+ * method mask
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRegion
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, mask)
 {
+  ///
+#ifdef PHP_QT_QRegion           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRegion *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'mask' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRegion
-      *return_object = static_cast < QRegion > (obj->mask());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRegion *
+        return_object = new QRegion;
+
+      *return_object = static_cast < QRegion > (selfpointer->mask());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::mask(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isActiveWindow
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method fontChange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method isActiveWindow
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, isActiveWindow)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isActiveWindow' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isActiveWindow());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isActiveWindow());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isActiveWindow(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isEnabledTo
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    QWidget*
+ * method isEnabledTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isEnabledTo)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* ,  */
+  ///QWidget *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'isEnabledTo' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QWidget")) {
-          bool *return_object;
+        RETURN_BOOL(selfpointer->isEnabledTo((QWidget *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            RETURN_BOOL(obj->isEnabledTo((QWidget *) obj_z_0));
-          }                     /// 5 END getThis(), simple types
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::isEnabledTo(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  layoutDirection
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::LayoutDirection
- *    @param    
+ * method layoutDirection
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::LayoutDirection
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, layoutDirection)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::LayoutDirection * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'layoutDirection' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      RETURN_LONG(obj->layoutDirection());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->layoutDirection());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::layoutDirection(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isAncestorOf
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    const QWidget *child
+ * method isAncestorOf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QWidget *childs0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isAncestorOf)
 {
-///const QWidget*
-/*! o public*/
-/*! const QWidget* child,  */
+  ///const QWidget *childs0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'isAncestorOf' is not static");
+          RETURN_NULL();
+        }
+        /// try const QWidget *childs0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QWidget")) {
-          bool *return_object;
+        RETURN_BOOL(selfpointer->isAncestorOf((const QWidget *)cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            RETURN_BOOL(obj->isAncestorOf((const QWidget *)obj_z_0));
-          }                     /// 5 END getThis(), simple types
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::isAncestorOf(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowIcon
- *
- *    @flags    c
- *    @access    public
- *    @return    QIcon
- *    @param    
+ * method windowIcon
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QIcon
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowIcon)
 {
+  ///
+#ifdef PHP_QT_QIcon             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QIcon *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'windowIcon' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-      obj->windowIcon();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QIcon *
+        return_object = new QIcon;
+
+      *return_object = static_cast < QIcon > (selfpointer->windowIcon());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::windowIcon(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  updatesEnabled
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method updatesEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, updatesEnabled)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'updatesEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->updatesEnabled());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->updatesEnabled());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::updatesEnabled(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isMinimized
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isMinimized
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isMinimized)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isMinimized' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isMinimized());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isMinimized());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isMinimized(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  height
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method height
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, height)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'height' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->height());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->height());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::height(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  normalGeometry
- *
- *    @flags    c
- *    @access    public
- *    @return    QRect
- *    @param    
+ * method normalGeometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, normalGeometry)
 {
+  ///
+#ifdef PHP_QT_QRect             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRect *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'normalGeometry' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRect
-      *return_object = static_cast < QRect > (obj->normalGeometry());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast < QRect > (selfpointer->normalGeometry());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::normalGeometry(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMask
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QBitmap &
+ * method setMask
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QBitmap &s0
+ * 
+ * overloaded args:
+ * @param	const QRegion &
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setMask)
 {
-///const QBitmap&
-/*! o public*/
-/*! const QBitmap& ,  */
+  ///const QBitmap &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QBitmap
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setMask' is not static");
+          RETURN_NULL();
+        }
+        /// try const QBitmap &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QBitmap *
+          cpp_arg_0 = static_cast < QBitmap * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QBitmap")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setMask((const QBitmap &)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setMask((const QBitmap &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
+    }
+  }
+  ///const QRegion &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegion
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setMask' is not static");
+          RETURN_NULL();
         }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        /// try const QRegion &,
+        QWidget *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QRegion *
+          cpp_arg_0 = static_cast < QRegion * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setMask((const QRegion &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setMask(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setForegroundRole
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QPalette::ColorRole
+ * method setForegroundRole
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPalette::ColorRole QPalette::ColorRoles0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setForegroundRole)
 {
-/*! l public*/
-/*! int ,  */
+  ///QPalette::ColorRole QPalette::ColorRoles0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setForegroundRole' is not static");
+        RETURN_NULL();
+      }
+      /// try QPalette::ColorRole QPalette::ColorRoles0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setForegroundRole((QPalette::ColorRole) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setForegroundRole((QPalette::ColorRole) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setForegroundRole(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  update
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int x, int y, int w, int h
+ * method update
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int xs0
+ * @param	 int ys1
+ * @param	 int ws2
+ * @param	 int hs3
+ * 
+ * overloaded args:
+ * @param	const QRect&
+ * 
+ * overloaded args:
+ * @param	const QRegion&
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, update)
 {
-/*! llll public*/
-/*! int x, int y, int w, int h,  */
+  ///int xs0, int ys1, int ws2, int hs3
   if (ZEND_NUM_ARGS() == 4) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'update' is not static");
+        RETURN_NULL();
+      }
+      /// try int xs0, int ys1, int ws2, int hs3,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->update((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  ///const QRect&
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'update' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect&,
+        QWidget *
+          selfpointer;
 
-        void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer->update((const QRect &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///const QRegion&
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegion
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'update' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRegion&,
+        QWidget *
+          selfpointer;
+
         if (getThis() != NULL) {
-          obj->update((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1), (int)Z_LVAL_P(z_2), (int)Z_LVAL_P(z_3));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QRegion *
+          cpp_arg_0 = static_cast < QRegion * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->update((const QRegion &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'update' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->update());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::update(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  adjustSize
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method adjustSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, adjustSize)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'adjustSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->adjustSize();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->adjustSize());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::adjustSize(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  toolTip
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method toolTip
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, toolTip)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'toolTip' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast < QString > (obj->toolTip());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->toolTip());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::toolTip(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setCursor
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QCursor &
+ * method wheelEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWheelEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method setCursor
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QCursor &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setCursor)
 {
-///const QCursor&
-/*! o public*/
-/*! const QCursor& ,  */
+  ///const QCursor &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QCursor
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setCursor' is not static");
+          RETURN_NULL();
+        }
+        /// try const QCursor &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QCursor *
+          cpp_arg_0 = static_cast < QCursor * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QCursor")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setCursor((const QCursor &)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setCursor((const QCursor &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setCursor(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMinimumWidth
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int minw
+ * method setMinimumWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int minws0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setMinimumWidth)
 {
-/*! l public*/
-/*! int minw,  */
+  ///int minws0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMinimumWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int minws0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setMinimumWidth((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMinimumWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setMinimumWidth(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isEnabledToTLW
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isEnabledToTLW
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isEnabledToTLW)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isEnabledToTLW' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isEnabledToTLW());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isEnabledToTLW());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isEnabledToTLW(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowRole
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &
+ * method setWindowRole
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWindowRole)
 {
-///const QString&
-/*! o public*/
-/*! const QString& ,  */
+  ///const QString &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setWindowRole' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)->name, "QString")) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj->setWindowRole((const QString &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->setWindowRole((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setWindowRole(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setPalette
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QPalette &
+ * method setPalette
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPalette &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setPalette)
 {
-///const QPalette&
-/*! o public*/
-/*! const QPalette& ,  */
+  ///const QPalette &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPalette
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setPalette' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPalette &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QPalette *
+          cpp_arg_0 = static_cast < QPalette * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QPalette")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setPalette((const QPalette &)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setPalette((const QPalette &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setPalette(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  acceptDrops
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method closeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QCloseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method resizeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QResizeEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method acceptDrops
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, acceptDrops)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'acceptDrops' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->acceptDrops());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->acceptDrops());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::acceptDrops(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  focusNextChild
- *
- *    @flags    
- *    @access    protected
- *    @return    bool
- *    @param    
+ * method focusNextChild
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-// method focusNextChild is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  setShortcutEnabled
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int id, bool enable = true
+ * method setShortcutEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ids0
+ * @param	 bool enable = trues1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setShortcutEnabled)
 {
-/*! ll public*/
-/*! int id, int enable,  */
+  ///int ids0, bool enable = trues1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setShortcutEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try int ids0,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setShortcutEnabled((int)Z_LVAL_P(arg_0)));
+    }
+  }
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setShortcutEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try int ids0, bool enable = trues1,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setShortcutEnabled((int)Z_LVAL_P(z_0), (bool) Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setShortcutEnabled((int)Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setShortcutEnabled(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  geometry
- *
- *    @flags    c
- *    @access    public
- *    @return    const QRect &
- *    @param    
+ * method geometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QRect &
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, geometry)
 {
+  ///
+#ifdef PHP_QT_QRect             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'geometry' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &const_cast < QRect & >(selfpointer->geometry());
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::geometry(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setShown
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    bool shown
+ * method focusNextPrevChild
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool nexts0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	v
  */
+
+/*!
+ * method windowActivationChange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method setShown
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool showns0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
+
 ZEND_METHOD(QWidget, setShown)
 {
-/*! l public_slots*/
-/*! int shown,  */
+  ///bool showns0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setShown' is not static");
+        RETURN_NULL();
+      }
+      /// try bool showns0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setShown((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setShown((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setShown(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  accessibleDescription
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method accessibleDescription
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, accessibleDescription)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'accessibleDescription' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast < QString > (obj->accessibleDescription());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->accessibleDescription());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::accessibleDescription(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMaximumSize
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QSize &
+ * method setMaximumSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &s0
+ * 
+ * overloaded args:
+ * @param	int maxw
+ * @param	 int maxh
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setMaximumSize)
 {
-///const QSize&
-/*! o public*/
-/*! const QSize& ,  */
+  ///const QSize &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setMaximumSize' is not static");
+          RETURN_NULL();
+        }
+        /// try const QSize &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QSize *
+          cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QSize")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setMaximumSize((const QSize &)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setMaximumSize((const QSize &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  ///int maxw, int maxh
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMaximumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try int maxw, int maxh,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMaximumSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setMaximumSize(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setContentsMargins
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int left, int top, int right, int bottom
+ * method setContentsMargins
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int lefts0
+ * @param	 int tops1
+ * @param	 int rights2
+ * @param	 int bottoms3
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setContentsMargins)
 {
-/*! llll public*/
-/*! int left, int top, int right, int bottom,  */
+  ///int lefts0, int tops1, int rights2, int bottoms3
   if (ZEND_NUM_ARGS() == 4) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setContentsMargins' is not static");
+        RETURN_NULL();
+      }
+      /// try int lefts0, int tops1, int rights2, int bottoms3,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setContentsMargins((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1), (int)Z_LVAL_P(z_2), (int)Z_LVAL_P(z_3));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setContentsMargins((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setContentsMargins(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  backgroundRole
- *
- *    @flags    c
- *    @access    public
- *    @return    QPalette::ColorRole
- *    @param    
+ * method backgroundRole
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPalette::ColorRole
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, backgroundRole)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    QPalette::ColorRole * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'backgroundRole' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      RETURN_LONG(obj->backgroundRole());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->backgroundRole());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::backgroundRole(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  mapFromParent
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    const QPoint &
+ * method mapFromParent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &s0
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, mapFromParent)
 {
-/*! l public*/
-/*! const QPoint& ,  */
+  ///const QPoint &s0
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'mapFromParent' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        QPoint *return_object;
-
         if (getThis() != NULL) {
-/// return value is object: QPoint
-          *return_object = static_cast < QPoint > (obj->mapFromParent((const QPoint &)Z_LVAL_P(z_0)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, "Object not found");
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
         }
-        zend_class_entry *ce;
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        zend_class_entry *
+          ce;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QPoint *
+          return_object = new QPoint;
 
-        le.ptr = return_object;
+        *return_object = static_cast < QPoint > (selfpointer->mapFromParent((const QPoint &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
         php_qt_register(return_value, le);
         return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::mapFromParent(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  updateGeometry
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method updateGeometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, updateGeometry)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'updateGeometry' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->updateGeometry();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->updateGeometry());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::updateGeometry(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setAttribute
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::WidgetAttribute, bool on = true
+ * method setAttribute
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WidgetAttribute Qt::WidgetAttributes0
+ * @param	 bool on = trues1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setAttribute)
 {
-/*! ll public*/
-/*! int , int on,  */
+  ///Qt::WidgetAttribute Qt::WidgetAttributes0, bool on = trues1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setAttribute' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::WidgetAttribute Qt::WidgetAttributes0,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setAttribute((Qt::WidgetAttribute) Z_LVAL_P(arg_0)));
+    }
+  }
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setAttribute' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::WidgetAttribute Qt::WidgetAttributes0, bool on = trues1,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setAttribute((Qt::WidgetAttribute) Z_LVAL_P(z_0), (bool) Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setAttribute((Qt::WidgetAttribute) Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setAttribute(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowType
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::WindowType
- *    @param    
+ * method windowType
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::WindowType
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowType)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::WindowType * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'windowType' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      obj->windowType();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->windowType());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::windowType(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  focusWidget
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method mouseDoubleClickEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method focusWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, focusWidget)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'focusWidget' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast < QWidget * >(obj->focusWidget());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      le.ptr = static_cast < QWidget * >(selfpointer->focusWidget());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::focusWidget(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  ensurePolished
- *
- *    @flags    c
- *    @access    public
- *    @return    void
- *    @param    
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method ensurePolished
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, ensurePolished)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'ensurePolished' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->ensurePolished();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->ensurePolished());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::ensurePolished(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  foregroundRole
- *
- *    @flags    c
- *    @access    public
- *    @return    QPalette::ColorRole
- *    @param    
+ * method foregroundRole
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPalette::ColorRole
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, foregroundRole)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    QPalette::ColorRole * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'foregroundRole' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      RETURN_LONG(obj->foregroundRole());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->foregroundRole());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::foregroundRole(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setEnabled
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    bool
+ * method setEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, setEnabled)
 {
-/*! l public_slots*/
-/*! int ,  */
+  ///bool bools0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setEnabled((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setEnabled(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowIconText
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method windowIconText
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowIconText)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'windowIconText' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast < QString > (obj->windowIconText());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->windowIconText());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::windowIconText(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  updateMicroFocus
- *
- *    @flags    
- *    @access    protected
- *    @return    void
- *    @param    
+ * method updateMicroFocus
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method updateMicroFocus is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  metric
- *
- *    @flags    c
- *    @access    protected
- *    @return    int
- *    @param    PaintDeviceMetric
+ * method metric
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	PaintDeviceMetric PaintDeviceMetrics0
+ * 
+ * @access	protected
+ * @return	int
+ * @flags	c
  */
-// method metric is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  winId
- *
- *    @flags    c
- *    @access    public
- *    @return    WId
- *    @param    
+ * method paletteChange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPalette &s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method winId
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	WId
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, winId)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    WId *return_object;
-
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->winId());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, "unsupported return type WId");
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::winId(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  close
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    bool
- *    @param    
+ * method close
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	bool
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, close)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'close' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->close());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->close());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::close(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  childAt
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget *
- *    @param    int x, int y
+ * method childAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int xs0
+ * @param	 int ys1
+ * 
+ * overloaded args:
+ * @param	const QPoint &p
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, childAt)
 {
-/*! ll public*/
-/*! int x, int y,  */
+  ///int xs0, int ys1
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'childAt' is not static");
+        RETURN_NULL();
+      }
+      /// try int xs0, int ys1,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        QWidget **return_object;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-        if (getThis() != NULL) {
-/// return: pointer
+      le.ptr = static_cast < QWidget * >(selfpointer->childAt((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-/// return value is object: QWidget *
-          *return_object = static_cast < QWidget * >(obj->childAt((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, "Object not found");
+
+  ///const QPoint &p
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'childAt' is not static");
+          RETURN_NULL();
         }
-        zend_class_entry *ce;
+        /// try const QPoint &p,
+        QWidget *
+          selfpointer;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        zend_class_entry *
+          ce;
 
-        le.ptr = return_object[0];
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+
+        le.ptr = static_cast < QWidget * >(selfpointer->childAt((const QPoint &)*cpp_arg_0));
         php_qt_register(return_value, le);
         return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::childAt(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setFixedWidth
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int w
+ * method setFixedWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ws0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setFixedWidth)
 {
-/*! l public*/
-/*! int w,  */
+  ///int ws0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setFixedWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int ws0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setFixedWidth((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setFixedWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setFixedWidth(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowRole
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method windowRole
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowRole)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'windowRole' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast < QString > (obj->windowRole());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->windowRole());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::windowRole(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setFont
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QFont &
+ * method setFont
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setFont)
 {
-///const QFont&
-/*! o public*/
-/*! const QFont& ,  */
+  ///const QFont &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setFont' is not static");
+          RETURN_NULL();
+        }
+        /// try const QFont &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QFont *
+          cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));
 
-        if (!strcmp(Z_OBJCE_P(z_0)->name, "QFont")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setFont((const QFont &)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setFont((const QFont &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setFont(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  hasMouseTracking
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method hasMouseTracking
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, hasMouseTracking)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hasMouseTracking' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->hasMouseTracking());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->hasMouseTracking());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::hasMouseTracking(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  childrenRegion
- *
- *    @flags    c
- *    @access    public
- *    @return    QRegion
- *    @param    
+ * method childrenRegion
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRegion
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, childrenRegion)
 {
+  ///
+#ifdef PHP_QT_QRegion           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRegion *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'childrenRegion' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRegion
-      *return_object = static_cast < QRegion > (obj->childrenRegion());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRegion *
+        return_object = new QRegion;
+
+      *return_object = static_cast < QRegion > (selfpointer->childrenRegion());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::childrenRegion(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  QWidget
- *
- *    @flags    t
- *    @access    public
- *    @return    
- *    @param    QWidget* parent = 0, Qt::WFlags f = 0
+ * method QWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * parent = 0s0
+ * @param	 Qt::WFlags f = 0s1
+ * 
+ * overloaded args:
+ * @param	QWidgetPrivate &d
+ * @param	 QWidget* parent
+ * @param	 Qt::WFlags f
+ * 
+ * overloaded args:
+ * @param	const QWidget &
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
+
 ZEND_METHOD(QWidget, __construct)
 {
-///QWidget*
+  ///QWidget * parent = 0s0, Qt::WFlags f = 0s1
   if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget_php_qt *
+        selfpointer = new QWidget_php_qt(getThis());
 
-          QWidget_moc *QWidget_ptr = new QWidget_moc(this_ptr);
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget * parent = 0s0,
+      QWidget *
+        cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QWidget_php_qt *
+        selfpointer = new QWidget_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-          PHP_QT_REGISTER(QWidget_ptr);
-          RETURN_NULL();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try QWidget * parent = 0s0, Qt::WFlags f = 0s1,
+      QWidget *
+        cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+      QWidget_php_qt *
+        selfpointer = new QWidget_php_qt(getThis(), (QWidget *) cpp_arg_0, (Qt::WFlags) Z_LVAL_P(arg_1));
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
     }
+  }
+  ///QWidgetPrivate &d, QWidget* parent, Qt::WFlags f
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QWidgetPrivate
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 71)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidgetPrivate &d, QWidget* parent, Qt::WFlags f,
+        QWidgetPrivate *
+          cpp_arg_0 = static_cast < QWidgetPrivate * >(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
+        QWidget_php_qt *
+          selfpointer = new QWidget_php_qt(getThis(), (QWidgetPrivate &) * cpp_arg_0, (QWidget *) cpp_arg_1, (Qt::WFlags) Z_LVAL_P(arg_2));
 
-/*! ol public*/
-/*! QWidget* parent, int f,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG) {
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+#endif
 
-        if (obj_z_0->inherits("QWidget")) {
-          QWidget *QWidget_ptr = new QWidget((QWidget *) obj_z_0, (Qt::WFlags) Z_LVAL_P(z_1));
+    }
+  }
+  ///const QWidget &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+/// method is private, skip
+        php_error(E_ERROR, "QWidget::__construct(...) cannot be called with 'const QWidget &,'.");
+      }
+#endif
 
-          PHP_QT_REGISTER(QWidget_ptr);
-          RETURN_NULL();
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::QWidget(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setInputContext
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QInputContext *
+ * method setInputContext
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QInputContext *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setInputContext)
 {
-///QInputContext*
-/*! o public*/
-/*! QInputContext* ,  */
+  ///QInputContext *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QInputContext
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setInputContext' is not static");
+          RETURN_NULL();
+        }
+        /// try QInputContext *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QInputContext *
+          cpp_arg_0 = static_cast < QInputContext * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QInputContext")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setInputContext((QInputContext *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setInputContext((QInputContext *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setInputContext(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  unsetLayoutDirection
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method unsetLayoutDirection
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, unsetLayoutDirection)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'unsetLayoutDirection' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->unsetLayoutDirection();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->unsetLayoutDirection());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::unsetLayoutDirection(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  sizeIncrement
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method sizeIncrement
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, sizeIncrement)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeIncrement' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->sizeIncrement());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->sizeIncrement());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::sizeIncrement(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  mouseGrabber
- *
- *    @flags    s
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method focusInEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method setVisible
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool visibles0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	vl
+ */
+
+/*!
+ * method mouseGrabber
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
+ */
+
 ZEND_METHOD(QWidget, mouseGrabber)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast < QWidget * >(obj->mouseGrabber());
-/// check whether method call is static.
-    } else {
-      return_object = (QWidget **) malloc(sizeof (QWidget::mouseGrabber()));    /// memory allocation
-      *return_object = static_cast < QWidget * >(QWidget::mouseGrabber());
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QWidget * >(QWidget::mouseGrabber());
+      } else {
+        le.ptr = static_cast < QWidget * >(selfpointer->mouseGrabber());
+      }
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
+  php_error(E_ERROR, "could not parse argument in QWidget::mouseGrabber(...) ");
+}
 
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
+/*!
+ * method addActions
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QList<QAction *> actionss0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QWidget, addActions)
+{
+  ///QList<QAction *> actionss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QList
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addActions' is not static");
+          RETURN_NULL();
+        }
+        /// try QList<QAction *> actionss0,
+        QWidget *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QList < QAction * cpp_arg_0 = static_cast < QList < QAction * >(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer->addActions((QList < QAction *) cpp_arg_0));
+      }
+#endif
+
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::addActions(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  trUtf8
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
+
 ZEND_METHOD(QWidget, trUtf8)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_STRING) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QWidget *
+        selfpointer;
 
-        QString *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast < QString > (obj->trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QWidget::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));   /// memory allocation
-          *return_object = static_cast < QString > (QWidget::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QWidget::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QWidget *
+        selfpointer;
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast < QString > (QWidget::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
       } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::trUtf8(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  resetInputContext
- *
- *    @flags    
- *    @access    protected
- *    @return    void
- *    @param    
+ * method resetInputContext
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method resetInputContext is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  isFullScreen
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isFullScreen
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isFullScreen)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isFullScreen' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isFullScreen());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isFullScreen());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isFullScreen(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  mapToGlobal
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    const QPoint &
+ * method mapToGlobal
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &s0
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, mapToGlobal)
 {
-/*! l public*/
-/*! const QPoint& ,  */
+  ///const QPoint &s0
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'mapToGlobal' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        QPoint *return_object;
-
         if (getThis() != NULL) {
-/// return value is object: QPoint
-          *return_object = static_cast < QPoint > (obj->mapToGlobal((const QPoint &)Z_LVAL_P(z_0)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, "Object not found");
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
         }
-        zend_class_entry *ce;
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        zend_class_entry *
+          ce;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QPoint *
+          return_object = new QPoint;
 
-        le.ptr = return_object;
+        *return_object = static_cast < QPoint > (selfpointer->mapToGlobal((const QPoint &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
         php_qt_register(return_value, le);
         return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::mapToGlobal(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  move
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int x, int y
+ * method move
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int xs0
+ * @param	 int ys1
+ * 
+ * overloaded args:
+ * @param	const QPoint &
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, move)
 {
-/*! ll public*/
-/*! int x, int y,  */
+  ///int xs0, int ys1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'move' is not static");
+        RETURN_NULL();
+      }
+      /// try int xs0, int ys1,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->move((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  ///const QPoint &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'move' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &,
+        QWidget *
+          selfpointer;
 
-        void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
 
-        if (getThis() != NULL) {
-          obj->move((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->move((const QPoint &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::move(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  mapFromGlobal
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    const QPoint &
+ * method mapFromGlobal
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &s0
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, mapFromGlobal)
 {
-/*! l public*/
-/*! const QPoint& ,  */
+  ///const QPoint &s0
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'mapFromGlobal' is not static");
+          RETURN_NULL();
+        }
+        /// try const QPoint &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        QPoint *return_object;
-
         if (getThis() != NULL) {
-/// return value is object: QPoint
-          *return_object = static_cast < QPoint > (obj->mapFromGlobal((const QPoint &)Z_LVAL_P(z_0)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, "Object not found");
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
         }
-        zend_class_entry *ce;
+        QPoint *
+          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
+        zend_class_entry *
+          ce;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QPoint *
+          return_object = new QPoint;
 
-        le.ptr = return_object;
+        *return_object = static_cast < QPoint > (selfpointer->mapFromGlobal((const QPoint &)*cpp_arg_0));
+        le.ptr = (void *)return_object;
         php_qt_register(return_value, le);
         return;
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::mapFromGlobal(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setUpdatesEnabled
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool enable
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
+
+/*!
+ * method setUpdatesEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enables0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setUpdatesEnabled)
 {
-/*! l public*/
-/*! int enable,  */
+  ///bool enables0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setUpdatesEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try bool enables0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setUpdatesEnabled((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setUpdatesEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setUpdatesEnabled(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setSizeIncrement
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QSize &
+ * method setSizeIncrement
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &s0
+ * 
+ * overloaded args:
+ * @param	int w
+ * @param	 int h
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setSizeIncrement)
 {
-///const QSize&
-/*! o public*/
-/*! const QSize& ,  */
+  ///const QSize &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setSizeIncrement' is not static");
+          RETURN_NULL();
+        }
+        /// try const QSize &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QSize *
+          cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QSize")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setSizeIncrement((const QSize &)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setSizeIncrement((const QSize &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  ///int w, int h
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setSizeIncrement' is not static");
+        RETURN_NULL();
+      }
+      /// try int w, int h,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setSizeIncrement((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setSizeIncrement(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  grabMouse
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method grabMouse
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QCursor &
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, grabMouse)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'grabMouse' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->grabMouse());
+    }
+  }
+  ///const QCursor &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QCursor
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'grabMouse' is not static");
+          RETURN_NULL();
+        }
+        /// try const QCursor &,
+        QWidget *
+          selfpointer;
 
-      obj->grabMouse();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QCursor *
+          cpp_arg_0 = static_cast < QCursor * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->grabMouse((const QCursor &)*cpp_arg_0));
+      }
+#endif
+
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::grabMouse(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  layout
- *
- *    @flags    c
- *    @access    public
- *    @return    QLayout *
- *    @param    
+ * method layout
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QLayout *
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, layout)
 {
+  ///
+#ifdef PHP_QT_QLayout           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QLayout **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'layout' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QLayout *
-      *return_object = static_cast < QLayout * >(obj->layout());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      le.ptr = static_cast < QLayout * >(selfpointer->layout());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::layout(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  mapFrom
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    QWidget *, const QPoint &
+ * method actionEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QActionEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method mapFrom
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * @param	 const QPoint  &s1
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, mapFrom)
 {
-///QWidget*
-/*! ol public*/
-/*! QWidget* , const QPoint& ,  */
+  ///QWidget *s0, const QPoint  &s1
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 71) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'mapFrom' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *s0, const QPoint  &s1,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+        QPoint *
+          cpp_arg_1 = static_cast < QPoint * >(php_qt_fetch(arg_1));
+        zend_class_entry *
+          ce;
 
-        if (obj_z_0->inherits("QWidget")) {
-          QPoint *return_object;
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QPoint *
+          return_object = new QPoint;
 
-          if (getThis() != NULL) {
-/// return value is object: QPoint
-            *return_object = static_cast < QPoint > (obj->mapFrom((QWidget *) obj_z_0, (const QPoint &)Z_LVAL_P(z_1)));
-          } else {              /// END getThis(), static
-            php_error(E_ERROR, "Object not found");
-          }
-          zend_class_entry *ce;
+        *return_object = static_cast < QPoint > (selfpointer->mapFrom((QWidget *) cpp_arg_0, (const QPoint &)*cpp_arg_1));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-          object_init_ex(return_value, QWidget_ce_ptr);
-          zend_rsrc_list_entry le;
+#endif
 
-          le.ptr = return_object;
-          php_qt_register(return_value, le);
-          return;
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::mapFrom(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowFlags
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::WindowFlags
- *    @param    
+ * method windowFlags
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::WindowFlags
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowFlags)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::WindowFlags * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'windowFlags' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      RETURN_LONG(obj->windowFlags());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->windowFlags());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::windowFlags(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isModal
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isModal
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isModal)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isModal' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isModal());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isModal());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isModal(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  unsetCursor
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method unsetCursor
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, unsetCursor)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'unsetCursor' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->unsetCursor();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->unsetCursor());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::unsetCursor(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setLayoutDirection
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::LayoutDirection direction
+ * method setLayoutDirection
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::LayoutDirection directions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setLayoutDirection)
 {
-/*! l public*/
-/*! int direction,  */
+  ///Qt::LayoutDirection directions0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setLayoutDirection' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::LayoutDirection directions0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setLayoutDirection(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  maximumHeight
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method tabletEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTabletEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method maximumHeight
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, maximumHeight)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'maximumHeight' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->maximumHeight());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->maximumHeight());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::maximumHeight(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  frameGeometry
- *
- *    @flags    c
- *    @access    public
- *    @return    QRect
- *    @param    
+ * method frameGeometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, frameGeometry)
 {
+  ///
+#ifdef PHP_QT_QRect             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRect *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'frameGeometry' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRect
-      *return_object = static_cast < QRect > (obj->frameGeometry());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast < QRect > (selfpointer->frameGeometry());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::frameGeometry(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  handle
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::HANDLE
- *    @param    
+ * method enterEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method customContextMenuRequested
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &poss0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
+
+/*!
+ * method handle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::HANDLE
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, handle)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::HANDLE * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'handle' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      obj->handle();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->handle());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::handle(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  lower
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method lower
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, lower)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'lower' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->lower();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->lower());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::lower(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowTitle
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &
+ * method setWindowTitle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWindowTitle)
 {
-///const QString&
-/*! o public*/
-/*! const QString& ,  */
+  ///const QString &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setWindowTitle' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)->name, "QString")) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj->setWindowTitle((const QString &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->setWindowTitle((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setWindowTitle(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowState
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::WindowStates state
+ * method setWindowState
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WindowStates states0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWindowState)
 {
-/*! l public*/
-/*! int state,  */
+  ///Qt::WindowStates states0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setWindowState' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::WindowStates states0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setWindowState((Qt::WindowStates) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setWindowState((Qt::WindowStates) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setWindowState(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  scroll
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int dx, int dy
+ * method scroll
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int dxs0
+ * @param	 int dys1
+ * 
+ * overloaded args:
+ * @param	int dx
+ * @param	 int dy
+ * @param	 const QRect&
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, scroll)
 {
-/*! ll public*/
-/*! int dx, int dy,  */
+  ///int dxs0, int dys1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'scroll' is not static");
+        RETURN_NULL();
+      }
+      /// try int dxs0, int dys1,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->scroll((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  ///int dx, int dy, const QRect&
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'scroll' is not static");
+          RETURN_NULL();
+        }
+        /// try int dx, int dy, const QRect&,
+        QWidget *
+          selfpointer;
 
-        void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));
 
-        if (getThis() != NULL) {
-          obj->scroll((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->scroll((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QRect &)*cpp_arg_2));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::scroll(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  sizePolicy
- *
- *    @flags    c
- *    @access    public
- *    @return    QSizePolicy
- *    @param    
+ * method sizePolicy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSizePolicy
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, sizePolicy)
 {
+  ///
+#ifdef PHP_QT_QSizePolicy       // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSizePolicy *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizePolicy' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSizePolicy
-      *return_object = static_cast < QSizePolicy > (obj->sizePolicy());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSizePolicy *
+        return_object = new QSizePolicy;
+
+      *return_object = static_cast < QSizePolicy > (selfpointer->sizePolicy());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
+  php_error(E_ERROR, "could not parse argument in QWidget::sizePolicy(...) ");
+}
 
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
+/*!
+ * method width
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QWidget, width)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'width' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->width());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::width(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  width
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method actions
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QList<QAction*>
+ * @flags	c
  */
-ZEND_METHOD(QWidget, width)
+
+ZEND_METHOD(QWidget, actions)
 {
+  ///
+#ifdef PHP_QT_QList             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'actions' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-      RETURN_LONG(obj->width());
-    }                           /// 5 END getThis(), simple types
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast < QList < QAction > *>(selfpointer->actions());
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::actions(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setHidden
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    bool hidden
+ * method setHidden
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool hiddens0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, setHidden)
 {
-/*! l public_slots*/
-/*! int hidden,  */
+  ///bool hiddens0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setHidden' is not static");
+        RETURN_NULL();
+      }
+      /// try bool hiddens0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setHidden((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setHidden((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setHidden(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  find
- *
- *    @flags    s
- *    @access    public
- *    @return    QWidget *
- *    @param    WId
+ * method find
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	WId WIds0
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
+
 ZEND_METHOD(QWidget, find)
 {
-/*! l public*/
-/*! unsigned int ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+// notice: unknown argument WId WIds0, skipped
+  php_error(E_ERROR, "could not parse argument in QWidget::find(...) ");
+}
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
+ */
 
-        QWidget **return_object;
+ZEND_METHOD(QWidget, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-        if (getThis() != NULL) {
-/// return: pointer
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QWidget *
+        selfpointer;
 
-/// return value is object: QWidget *
-          *return_object = static_cast < QWidget * >(obj->find((WId) Z_LVAL_P(z_0)));
-/// check whether method call is static.
-        } else {
-          return_object = (QWidget **) malloc(sizeof (QWidget::find((WId) Z_LVAL_P(z_0))));     /// memory allocation
-          *return_object = static_cast < QWidget * >(QWidget::find((WId) Z_LVAL_P(z_0)));
-        }
-        zend_class_entry *ce;
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-        le.ptr = return_object[0];
-        php_qt_register(return_value, le);
-        return;
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QMetaObject * >(QWidget::staticMetaObject());
       } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::staticMetaObject(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  staticMetaObject
- *
- *    @flags    s
- *    @access    public
- *    @return    QMetaObject*
- *    @param    
+ * method mouseReleaseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QWidget, staticMetaObject)
-{
-}
 
 /*!
- *    @class     QWidget
- *    @function  size
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method size
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, size)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'size' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->size());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->size());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::size(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  activateWindow
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method activateWindow
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, activateWindow)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'activateWindow' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->activateWindow();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->activateWindow());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::activateWindow(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setToolTip
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &
+ * method hideEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QHideEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method setToolTip
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setToolTip)
 {
-///const QString&
-/*! o public*/
-/*! const QString& ,  */
+  ///const QString &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setToolTip' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)->name, "QString")) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj->setToolTip((const QString &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->setToolTip((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setToolTip(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setParent
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QWidget *parent
+ * method inputMethodQuery
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::InputMethodQuery Qt::InputMethodQuerys0
+ * 
+ * @access	public
+ * @return	QVariant
+ * @flags	cv
  */
+
+/*!
+ * method setParent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parents0
+ * 
+ * overloaded args:
+ * @param	QWidget *parent
+ * @param	 Qt::WFlags f
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setParent)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* parent,  */
+  ///QWidget *parents0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setParent' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *parents0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QWidget")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setParent((QWidget *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setParent((QWidget *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
+    }
+  }
+  ///QWidget *parent, Qt::WFlags f
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setParent' is not static");
+          RETURN_NULL();
         }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        /// try QWidget *parent, Qt::WFlags f,
+        QWidget *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setParent((QWidget *) cpp_arg_0, (Qt::WFlags) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setParent(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isWindowModified
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isWindowModified
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isWindowModified)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isWindowModified' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isWindowModified());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isWindowModified());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isWindowModified(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  testAttribute
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    Qt::WidgetAttribute
+ * method testAttribute
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WidgetAttribute Qt::WidgetAttributes0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, testAttribute)
 {
-/*! l public*/
-/*! int ,  */
+  ///Qt::WidgetAttribute Qt::WidgetAttributes0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'testAttribute' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::WidgetAttribute Qt::WidgetAttributes0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->testAttribute((Qt::WidgetAttribute) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::testAttribute(...) ");
+}
 
-        bool *return_object;
+/*!
+ * method minimumSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cv
+ */
 
-        if (getThis() != NULL) {
-          RETURN_BOOL(obj->testAttribute((Qt::WidgetAttribute) Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
+/*!
+ * method heightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cv
+ */
 
 /*!
- *    @class     QWidget
- *    @function  pos
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, pos)
 {
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QPoint *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'pos' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QPoint
-      *return_object = static_cast < QPoint > (obj->pos());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QPoint *
+        return_object = new QPoint;
+
+      *return_object = static_cast < QPoint > (selfpointer->pos());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::pos(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isWindow
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isWindow
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isWindow)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isWindow' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isWindow());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isWindow());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isWindow(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  create
- *
- *    @flags    
- *    @access    protected
- *    @return    void
- *    @param    WId = 0, bool initializeWindow = true, bool destroyOldWindow = true
+ * method create
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	WId = 0s0
+ * @param	 bool initializeWindow = trues1
+ * @param	 bool destroyOldWindow = trues2
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method create is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  setFocusPolicy
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::FocusPolicy policy
+ * method setFocusPolicy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::FocusPolicy policys0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setFocusPolicy)
 {
-/*! l public*/
-/*! int policy,  */
+  ///Qt::FocusPolicy policys0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setFocusPolicy' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::FocusPolicy policys0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setFocusPolicy((Qt::FocusPolicy) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setFocusPolicy((Qt::FocusPolicy) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setFocusPolicy(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  getContentsMargins
- *
- *    @flags    c
- *    @access    public
- *    @return    void
- *    @param    int *left, int *top, int *right, int *bottom
+ * method getContentsMargins
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int *lefts0
+ * @param	 int *tops1
+ * @param	 int *rights2
+ * @param	 int *bottoms3
+ * 
+ * @access	public
+ * @return	void
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, getContentsMargins)
 {
-/*! llll public*/
-/*! int* left, int* top, int* right, int* bottom,  */
+  ///int *lefts0, int *tops1, int *rights2, int *bottoms3
   if (ZEND_NUM_ARGS() == 4) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'getContentsMargins' is not static");
+        RETURN_NULL();
+      }
+      /// try int *lefts0, int *tops1, int *rights2, int *bottoms3,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->getContentsMargins((int *)Z_LVAL_P(z_0), (int *)Z_LVAL_P(z_1), (int *)Z_LVAL_P(z_2), (int *)Z_LVAL_P(z_3));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->getContentsMargins((int *)&Z_LVAL_P(arg_0), (int *)&Z_LVAL_P(arg_1), (int *)&Z_LVAL_P(arg_2), (int *)&Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::getContentsMargins(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowTitle
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method dropEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDropEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method windowTitle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, windowTitle)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'windowTitle' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast < QString > (obj->windowTitle());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->windowTitle());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::windowTitle(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  style
- *
- *    @flags    c
- *    @access    public
- *    @return    QStyle *
- *    @param    
+ * method keyReleaseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method style
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QStyle *
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, style)
 {
+  ///
+#ifdef PHP_QT_QStyle            // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QStyle **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'style' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QStyle *
-      *return_object = static_cast < QStyle * >(obj->style());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      le.ptr = static_cast < QStyle * >(selfpointer->style());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::style(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowState
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::WindowStates
- *    @param    
+ * method windowState
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::WindowStates
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowState)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::WindowStates * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'windowState' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      RETURN_LONG(obj->windowState());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->windowState());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::windowState(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  frameSize
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method frameSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, frameSize)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'frameSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->frameSize());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->frameSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::frameSize(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setAccessibleName
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &name
+ * method setAccessibleName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &names0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setAccessibleName)
 {
-///const QString&
-/*! o public*/
-/*! const QString& name,  */
+  ///const QString &names0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setAccessibleName' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &names0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)->name, "QString")) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj->setAccessibleName((const QString &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->setAccessibleName((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setAccessibleName(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setAcceptDrops
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool on
+ * method setAcceptDrops
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool ons0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setAcceptDrops)
 {
-/*! l public*/
-/*! int on,  */
+  ///bool ons0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setAcceptDrops' is not static");
+        RETURN_NULL();
+      }
+      /// try bool ons0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setAcceptDrops((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setAcceptDrops(...) ");
+}
 
-        void *return_object;
+/*!
+ * method setSizePolicy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QSizePolicy QSizePolicys0
+ * 
+ * overloaded args:
+ * @param	QSizePolicy::Policy horizontal
+ * @param	 QSizePolicy::Policy vertical
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QWidget, setSizePolicy)
+{
+  ///QSizePolicy QSizePolicys0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSizePolicy
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setSizePolicy' is not static");
+          RETURN_NULL();
+        }
+        /// try QSizePolicy QSizePolicys0,
+        QWidget *
+          selfpointer;
+
         if (getThis() != NULL) {
-          obj->setAcceptDrops((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QSizePolicy *
+          cpp_arg_0 = static_cast < QSizePolicy * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setSizePolicy((QSizePolicy) * cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setSizePolicy' is not static");
+        RETURN_NULL();
+      }
+      /// try QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setSizePolicy((QSizePolicy::Policy) Z_LVAL_P(arg_0), (QSizePolicy::Policy) Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setSizePolicy(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  removeAction
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QAction *action
+ * method languageChange
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method removeAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QAction *actions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, removeAction)
 {
-///qt_QAction*
-/*! o public*/
-/*! qt_QAction* action,  */
+  ///QAction *actions0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'removeAction' is not static");
+          RETURN_NULL();
+        }
+        /// try QAction *actions0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QAction *
+          cpp_arg_0 = static_cast < QAction * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QAction")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->removeAction((QAction *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->removeAction((QAction *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::removeAction(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  hasFocus
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method hasFocus
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, hasFocus)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hasFocus' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->hasFocus());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->hasFocus());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::hasFocus(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  showFullScreen
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method contextMenuEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QContextMenuEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method showFullScreen
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
+
 ZEND_METHOD(QWidget, showFullScreen)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'showFullScreen' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->showFullScreen();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->showFullScreen());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::showFullScreen(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMouseTracking
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool enable
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
+
+/*!
+ * method setMouseTracking
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enables0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setMouseTracking)
 {
-/*! l public*/
-/*! int enable,  */
+  ///bool enables0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMouseTracking' is not static");
+        RETURN_NULL();
+      }
+      /// try bool enables0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setMouseTracking((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMouseTracking((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setMouseTracking(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  clearMask
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method clearMask
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, clearMask)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'clearMask' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->clearMask();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->clearMask());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::clearMask(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  showMaximized
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method moveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMoveEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method inputMethodEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QInputMethodEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method showMaximized
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
+
 ZEND_METHOD(QWidget, showMaximized)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'showMaximized' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->showMaximized();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->showMaximized());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::showMaximized(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  devType
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method devType
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, devType)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'devType' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->devType());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->devType());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::devType(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  font
- *
- *    @flags    c
- *    @access    public
- *    @return    const QFont &
- *    @param    
+ * method font
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QFont &
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, font)
 {
+  ///
+#ifdef PHP_QT_QFont             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'font' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &const_cast < QFont & >(selfpointer->font());
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidget::font(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  stackUnder
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QWidget*
+ * method stackUnder
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, stackUnder)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* ,  */
+  ///QWidget *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'stackUnder' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QWidget")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->stackUnder((QWidget *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->stackUnder((QWidget *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::stackUnder(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMinimumSize
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QSize &
+ * method setMinimumSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &s0
+ * 
+ * overloaded args:
+ * @param	int minw
+ * @param	 int minh
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setMinimumSize)
 {
-///const QSize&
-/*! o public*/
-/*! const QSize& ,  */
+  ///const QSize &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setMinimumSize' is not static");
+          RETURN_NULL();
+        }
+        /// try const QSize &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QSize *
+          cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QSize")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setMinimumSize((const QSize &)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setMinimumSize((const QSize &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  ///int minw, int minh
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMinimumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try int minw, int minh,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMinimumSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setMinimumSize(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setDisabled
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    bool
+ * method setDisabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, setDisabled)
 {
-/*! l public_slots*/
-/*! int ,  */
+  ///bool bools0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setDisabled' is not static");
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setDisabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setDisabled(...) ");
+}
 
-        void *return_object;
+/*!
+ * method leaveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
 
-        if (getThis() != NULL) {
-          obj->setDisabled((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
+/*!
+ * method dragEnterEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDragEnterEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
 
 /*!
- *    @class     QWidget
- *    @function  show
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method enabledChange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method show
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
+
 ZEND_METHOD(QWidget, show)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'show' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->show();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->show());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::show(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  underMouse
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method underMouse
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, underMouse)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'underMouse' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->underMouse());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->underMouse());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::underMouse(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowIcon
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QIcon &icon
+ * method setWindowIcon
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QIcon &icons0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWindowIcon)
 {
-///const QIcon&
-/*! o public*/
-/*! const QIcon& icon,  */
+  ///const QIcon &icons0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QIcon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setWindowIcon' is not static");
+          RETURN_NULL();
+        }
+        /// try const QIcon &icons0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QIcon *
+          cpp_arg_0 = static_cast < QIcon * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QIcon")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setWindowIcon((const QIcon &)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setWindowIcon((const QIcon &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setWindowIcon(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  grabKeyboard
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method focusOutEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method grabKeyboard
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, grabKeyboard)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'grabKeyboard' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->grabKeyboard();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->grabKeyboard());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::grabKeyboard(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  raise
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method raise
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, raise)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'raise' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->raise();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->raise());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::raise(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  event
- *
- *    @flags    
- *    @access    protected
- *    @return    bool
- *    @param    QEvent *
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-// method event is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  setWhatsThis
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &
+ * method setWhatsThis
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWhatsThis)
 {
-///const QString&
-/*! o public*/
-/*! const QString& ,  */
+  ///const QString &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setWhatsThis' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)->name, "QString")) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj->setWhatsThis((const QString &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->setWhatsThis((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setWhatsThis(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setGeometry
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int x, int y, int w, int h
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int xs0
+ * @param	 int ys1
+ * @param	 int ws2
+ * @param	 int hs3
+ * 
+ * overloaded args:
+ * @param	const QRect &
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setGeometry)
 {
-/*! llll public*/
-/*! int x, int y, int w, int h,  */
+  ///int xs0, int ys1, int ws2, int hs3
   if (ZEND_NUM_ARGS() == 4) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
+    PHP_QT_FETCH_4_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setGeometry' is not static");
+        RETURN_NULL();
+      }
+      /// try int xs0, int ys1, int ws2, int hs3,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setGeometry((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  ///const QRect &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setGeometry' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &,
+        QWidget *
+          selfpointer;
 
-        void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
 
-        if (getThis() != NULL) {
-          obj->setGeometry((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1), (int)Z_LVAL_P(z_2), (int)Z_LVAL_P(z_3));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->setGeometry((const QRect &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setGeometry(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  contextMenuPolicy
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::ContextMenuPolicy
- *    @param    
+ * method contextMenuPolicy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::ContextMenuPolicy
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, contextMenuPolicy)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::ContextMenuPolicy * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'contextMenuPolicy' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      RETURN_LONG(obj->contextMenuPolicy());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->contextMenuPolicy());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::contextMenuPolicy(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  resize
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int w, int h
+ * method resize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ws0
+ * @param	 int hs1
+ * 
+ * overloaded args:
+ * @param	const QSize &
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, resize)
 {
-/*! ll public*/
-/*! int w, int h,  */
+  ///int ws0, int hs1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'resize' is not static");
+        RETURN_NULL();
+      }
+      /// try int ws0, int hs1,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->resize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  ///const QSize &
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'resize' is not static");
+          RETURN_NULL();
+        }
+        /// try const QSize &,
+        QWidget *
+          selfpointer;
 
-        void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QSize *
+          cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));
 
-        if (getThis() != NULL) {
-          obj->resize((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->resize((const QSize &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::resize(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isLeftToRight
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isLeftToRight
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isLeftToRight)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isLeftToRight' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isLeftToRight());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isLeftToRight());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isLeftToRight(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowFlags
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::WindowFlags type
+ * method showEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QShowEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method setWindowFlags
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WindowFlags types0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setWindowFlags)
 {
-/*! l public*/
-/*! int type,  */
+  ///Qt::WindowFlags types0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setWindowFlags' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::WindowFlags types0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setWindowFlags((Qt::WindowFlags) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setWindowFlags((Qt::WindowFlags) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setWindowFlags(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  baseSize
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method baseSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, baseSize)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'baseSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->baseSize());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->baseSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::baseSize(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setLayout
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QLayout *
+ * method setLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayout *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setLayout)
 {
-///qt_QLayout*
-/*! o public*/
-/*! qt_QLayout* ,  */
+  ///QLayout *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setLayout' is not static");
+          RETURN_NULL();
+        }
+        /// try QLayout *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast < QLayout * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QLayout")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setLayout((QLayout *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setLayout((QLayout *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-    else {
-        php_error(E_ERROR, "arg parse error.");
     }
-  }                             /// END ZEND_NUM_ARGS
-  else {
-    php_error(E_ERROR, "wrong arg count.");
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::setLayout(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMaximumHeight
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int maxh
+ * method setMaximumHeight
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int maxhs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setMaximumHeight)
 {
-/*! l public*/
-/*! int maxh,  */
+  ///int maxhs0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMaximumHeight' is not static");
+        RETURN_NULL();
+      }
+      /// try int maxhs0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setMaximumHeight((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMaximumHeight((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setMaximumHeight(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  showNormal
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method showNormal
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, showNormal)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'showNormal' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->showNormal();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->showNormal());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::showNormal(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  insertAction
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QAction *before, QAction *action
+ * method insertAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QAction *befores0
+ * @param	 QAction *actions1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, insertAction)
 {
-///qt_QAction*
-///qt_QAction*
-/*! oo public*/
-/*! qt_QAction* before, qt_QAction* action,  */
+  ///QAction *befores0, QAction *actions1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'insertAction' is not static");
+          RETURN_NULL();
+        }
+        /// try QAction *befores0, QAction *actions1,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &z_0, &z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
-        QObject *obj_z_1 = (QObject *) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QAction *
+          cpp_arg_0 = static_cast < QAction * >(php_qt_fetch(arg_0));
+        QAction *
+          cpp_arg_1 = static_cast < QAction * >(php_qt_fetch(arg_1));
 
-        if (obj_z_0->inherits("QAction") && obj_z_1->inherits("QAction")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->insertAction((QAction *) cpp_arg_0, (QAction *) cpp_arg_1));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->insertAction((QAction *) obj_z_0, (QAction *) obj_z_1);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::insertAction(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  window
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method window
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, window)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'window' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast < QWidget * >(obj->window());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      le.ptr = static_cast < QWidget * >(selfpointer->window());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::window(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  paintEngine
- *
- *    @flags    c
- *    @access    public
- *    @return    QPaintEngine *
- *    @param    
+ * method paintEngine
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPaintEngine *
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, paintEngine)
 {
+  ///
+#ifdef PHP_QT_QPaintEngine      // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QPaintEngine **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'paintEngine' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QPaintEngine *
-      *return_object = static_cast < QPaintEngine * >(obj->paintEngine());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      le.ptr = static_cast < QPaintEngine * >(selfpointer->paintEngine());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::paintEngine(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  minimumHeight
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method minimumHeight
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, minimumHeight)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumHeight' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->minimumHeight());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->minimumHeight());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::minimumHeight(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  x
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method x
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, x)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'x' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->x());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->x());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::x(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  releaseShortcut
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int id
+ * method releaseShortcut
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ids0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, releaseShortcut)
 {
-/*! l public*/
-/*! int id,  */
+  ///int ids0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'releaseShortcut' is not static");
+        RETURN_NULL();
+      }
+      /// try int ids0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->releaseShortcut((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->releaseShortcut((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::releaseShortcut(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setStatusTip
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &
+ * method setStatusTip
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setStatusTip)
 {
-///const QString&
-/*! o public*/
-/*! const QString& ,  */
+  ///const QString &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setStatusTip' is not static");
+          RETURN_NULL();
+        }
+        /// try const QString &s0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)->name, "QString")) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj->setStatusTip((const QString &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer->setStatusTip((const QString &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setStatusTip(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setBaseSize
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QSize &
+ * method mousePressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method setBaseSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &s0
+ * 
+ * overloaded args:
+ * @param	int basew
+ * @param	 int baseh
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setBaseSize)
 {
-///const QSize&
-/*! o public*/
-/*! const QSize& ,  */
+  ///const QSize &s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setBaseSize' is not static");
+          RETURN_NULL();
+        }
+        /// try const QSize &s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QSize *
+          cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QSize")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->setBaseSize((const QSize &)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->setBaseSize((const QSize &)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  ///int basew, int baseh
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setBaseSize' is not static");
+        RETURN_NULL();
+      }
+      /// try int basew, int baseh,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setBaseSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setBaseSize(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  rect
- *
- *    @flags    c
- *    @access    public
- *    @return    QRect
- *    @param    
+ * method rect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, rect)
 {
+  ///
+#ifdef PHP_QT_QRect             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRect *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'rect' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRect
-      *return_object = static_cast < QRect > (obj->rect());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast < QRect > (selfpointer->rect());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::rect(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  addAction
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QAction *action
+ * method addAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QAction *actions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, addAction)
 {
-///qt_QAction*
-/*! o public*/
-/*! qt_QAction* action,  */
+  ///QAction *actions0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'addAction' is not static");
+          RETURN_NULL();
+        }
+        /// try QAction *actions0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+        }
+        QAction *
+          cpp_arg_0 = static_cast < QAction * >(php_qt_fetch(arg_0));
 
-        if (obj_z_0->inherits("QAction")) {
-          void *return_object;
+        RETURN_VOID(selfpointer->addAction((QAction *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj->addAction((QAction *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::addAction(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  minimumSize
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, minimumSize)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->minimumSize());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->minimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::minimumSize(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setFocus
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::FocusReason reason
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cv
  */
+
+/*!
+ * method setFocus
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::FocusReason reasons0
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setFocus)
 {
-/*! l public*/
-/*! int reason,  */
+  ///Qt::FocusReason reasons0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setFocus' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::FocusReason reasons0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setFocus((Qt::FocusReason) Z_LVAL_P(arg_0)));
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setFocus' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->setFocus((Qt::FocusReason) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setFocus());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setFocus(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  destroy
- *
- *    @flags    
- *    @access    protected
- *    @return    void
- *    @param    bool destroyWindow = true, bool destroySubWindows = true
+ * method destroy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool destroyWindow = trues0
+ * @param	 bool destroySubWindows = trues1
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method destroy is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  isVisible
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method dragMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDragMoveEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method isVisible
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, isVisible)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isVisible' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isVisible());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isVisible());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isVisible(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  accessibleName
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method accessibleName
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, accessibleName)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'accessibleName' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast < QString > (obj->accessibleName());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->accessibleName());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::accessibleName(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  minimumWidth
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method keyPressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method minimumWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, minimumWidth)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj->minimumWidth());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->minimumWidth());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::minimumWidth(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isEnabled
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isEnabled)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isEnabled' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isEnabled());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isEnabled());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isEnabled(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  keyboardGrabber
- *
- *    @flags    s
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method keyboardGrabber
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
+
 ZEND_METHOD(QWidget, keyboardGrabber)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast < QWidget * >(obj->keyboardGrabber());
-/// check whether method call is static.
-    } else {
-      return_object = (QWidget **) malloc(sizeof (QWidget::keyboardGrabber())); /// memory allocation
-      *return_object = static_cast < QWidget * >(QWidget::keyboardGrabber());
+      if (getThis() == NULL) {
+        le.ptr = static_cast < QWidget * >(QWidget::keyboardGrabber());
+      } else {
+        le.ptr = static_cast < QWidget * >(selfpointer->keyboardGrabber());
+      }
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::keyboardGrabber(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  overrideWindowState
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::WindowStates state
+ * method overrideWindowState
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WindowStates states0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, overrideWindowState)
 {
-/*! l public*/
-/*! int state,  */
+  ///Qt::WindowStates states0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'overrideWindowState' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::WindowStates states0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj->overrideWindowState((Qt::WindowStates) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->overrideWindowState((Qt::WindowStates) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::overrideWindowState(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMinimumHeight
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int minh
+ * method setMinimumHeight
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int minhs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setMinimumHeight)
 {
-/*! l public*/
-/*! int minh,  */
+  ///int minhs0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'setMinimumHeight' is not static");
+        RETURN_NULL();
+      }
+      /// try int minhs0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->setMinimumHeight((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::setMinimumHeight(...) ");
+}
 
-        void *return_object;
+/*!
+ * method testAttribute_helper
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WidgetAttribute Qt::WidgetAttributes0
+ * 
+ * @access	private
+ * @return	bool
+ * @flags	c
+ */
 
-        if (getThis() != NULL) {
-          obj->setMinimumHeight((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, "argument not allowed");
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+ZEND_METHOD(QWidget, testAttribute_helper)
+{
+  ///Qt::WidgetAttribute Qt::WidgetAttributes0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+/// method is private, skip
+      php_error(E_ERROR, "QWidget::testAttribute_helper(...) cannot be called with 'Qt::WidgetAttribute Qt::WidgetAttributes0,'.");
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidget::testAttribute_helper(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  isMaximized
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isMaximized
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isMaximized)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isMaximized' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj->isMaximized());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isMaximized());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::isMaximized(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  parentWidget
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method parentWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, parentWidget)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'parentWidget' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast < QWidget * >(obj->parentWidget());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      le.ptr = static_cast < QWidget * >(selfpointer->parentWidget());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::parentWidget(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  whatsThis
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method whatsThis
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, whatsThis)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'whatsThis' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast < QString > (obj->whatsThis());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast < QString > (selfpointer->whatsThis());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::whatsThis(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  maximumSize
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, maximumSize)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'maximumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast < QSize > (obj->maximumSize());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, "Object not found");
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->maximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, "could not parse argument in QWidget::maximumSize(...) ");
 }
 
 /*!
- *    @class     QWidget
- *    @function  showMinimized
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method showMinimized
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, showMinimized)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'showMinimized' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj->showMinimized();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer->showMinimized());
+    }
   }
+  php_error(E_ERROR, "could not parse argument in QWidget::showMinimized(...) ");
 }
-
-
-PHP_QT_DESTRUCT(QWidget);

Modified: trunk/qt/classes/qwidgetdata.cpp
===================================================================
--- trunk/qt/classes/qwidgetdata.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qwidgetdata.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,14 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QWidgetData.cpp - QWidgetData PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QWidgetData>
 #include "../php_qt.h"
 
 
-
-PHP_QT_DESTRUCT(QWidgetData);
-
+#include <QWidgetData>

Modified: trunk/qt/classes/qwidgetitem.cpp
===================================================================
--- trunk/qt/classes/qwidgetitem.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qwidgetitem.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,237 +19,463 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QWidgetItem.cpp - QWidgetItem PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QWidgetItem>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  hasHeightForWidth
- *    flags:    c
+#include <QWidgetItem>
+#include <QMetaMethod>
+class QWidgetItem_php_qt:public QWidgetItem
+{
+
+public:
+  QWidgetItem_php_qt(zval * zend_ptr, QWidget * ws0);
+
+
+  zval *zend_ptr;
+};
+
+QWidgetItem_php_qt::QWidgetItem_php_qt(zval * zend_ptr, QWidget * ws0):QWidgetItem(ws0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method hasHeightForWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, hasHeightForWidth){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->hasHeightForWidth());
-	}
+
+ZEND_METHOD(QWidgetItem, hasHeightForWidth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'hasHeightForWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidgetItem * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->hasHeightForWidth());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidgetItem::hasHeightForWidth(...) ");
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  isEmpty
- *    flags:    c
+/*!
+ * method widget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	v
  */
-ZEND_METHOD(QWidgetItem, isEmpty){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isEmpty());
-	}
+
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	c
+ */
+
+ZEND_METHOD(QWidgetItem, expandingDirections)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'expandingDirections' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidgetItem * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->expandingDirections());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidgetItem::expandingDirections(...) ");
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  setGeometry
- *    flags:    
+/*!
+ * method QWidgetItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QWidgetItem, setGeometry){
-		/* o public*/
 
-		/* const QRect& ,  */
+ZEND_METHOD(QWidgetItem, __construct)
+{
+  ///QWidget *ws0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method '__construct' is not static");
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0s0,
+        QWidget *
+          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
+        QWidgetItem_php_qt *
+          selfpointer = new QWidgetItem_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-
-			if(Z_OBJCE_P(z_0)->name == "QRect") {
-				obj->setGeometry((const QRect&) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidgetItem::QWidgetItem(...) ");
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  QWidgetItem
- *    flags:    t
+/*!
+ * method geometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, __construct){
-		/* o public*/
 
-		/* qt_QWidget* w,  */
+ZEND_METHOD(QWidgetItem, geometry)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'geometry' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidgetItem * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			if(obj_z_0->inherits("QWidget")) {
-				QWidgetItem *QWidgetItem_ptr = new QWidgetItem((QWidget*) obj_z_0);
-				PHP_QT_REGISTER(QWidgetItem_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast < QRect > (selfpointer->geometry());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidgetItem::geometry(...) ");
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  minimumSize
- *    flags:    c
+/*!
+ * method heightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, minimumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj->minimumSize();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWidgetItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWidgetItem, heightForWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'heightForWidth' is not static");
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QWidgetItem *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidgetItem * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->heightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidgetItem::heightForWidth(...) ");
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method isEmpty
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj->sizeHint();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWidgetItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWidgetItem, isEmpty)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'isEmpty' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidgetItem * >(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer->isEmpty());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidgetItem::isEmpty(...) ");
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  maximumSize
- *    flags:    c
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QWidgetItem, maximumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj->maximumSize();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWidgetItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWidgetItem, setGeometry)
+{
+  ///const QRect &s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, "method 'setGeometry' is not static");
+          RETURN_NULL();
+        }
+        /// try const QRect &s0,
+        QWidgetItem *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast < QWidgetItem * >(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer->setGeometry((const QRect &)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWidgetItem::setGeometry(...) ");
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  heightForWidth
- *    flags:    c
+/*!
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, heightForWidth){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QWidgetItem, minimumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'minimumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidgetItem * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			RETURN_LONG(obj->heightForWidth((int) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->minimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidgetItem::minimumSize(...) ");
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  widget
- *    flags:    v
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, widget){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-				QWidget * return_object = (QWidget *) obj->widget();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWidgetItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  expandingDirections
- *    flags:    c
- */
-ZEND_METHOD(QWidgetItem, expandingDirections){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-				Qt::Orientations return_object = (Qt::Orientations) obj->expandingDirections();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWidgetItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QWidgetItem, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'sizeHint' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidgetItem * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidgetItem::sizeHint(...) ");
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  geometry
- *    flags:    c
+/*!
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, geometry){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-				QRect return_object = (QRect) obj->geometry();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWidgetItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
+ZEND_METHOD(QWidgetItem, maximumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-PHP_QT_DESTRUCT(QWidgetItem);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'maximumSize' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWidgetItem * >(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast < QSize > (selfpointer->maximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, "could not parse argument in QWidgetItem::maximumSize(...) ");
+}

Modified: trunk/qt/classes/qwindowstatechangeevent.cpp
===================================================================
--- trunk/qt/classes/qwindowstatechangeevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qwindowstatechangeevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke <tm at ippfp.org>,
- * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,36 +19,98 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QWindowStateChangeEvent.cpp - QWindowStateChangeEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include <iostream>
 using namespace std;
 
-#include <QWindowStateChangeEvent>
 #include "../php_qt.h"
 
 
-/*********************************
- *    class     QWindowStateChangeEvent */
-/*
- *    function  oldState
- *    flags:    c
+#include <QWindowStateChangeEvent>
+/// DEBUG:destructor skipped.
+#include <QMetaMethod>
+class QWindowStateChangeEvent_php_qt:public QWindowStateChangeEvent
+{
+
+public:
+  QWindowStateChangeEvent_php_qt(zval * zend_ptr, Qt::WindowStates aOldStates0);
+
+
+  zval *zend_ptr;
+};
+
+QWindowStateChangeEvent_php_qt::QWindowStateChangeEvent_php_qt(zval * zend_ptr, Qt::WindowStates aOldStates0):QWindowStateChangeEvent(aOldStates0)
+{
+  this->zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QWindowStateChangeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WindowStates aOldStates0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QWindowStateChangeEvent, oldState){
-	if (ZEND_NUM_ARGS() == 0){
-			QWindowStateChangeEvent *obj = (QWindowStateChangeEvent*) PHP_QT_FETCH();
-				Qt::WindowStates return_object = (Qt::WindowStates) obj->oldState();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWindowStateChangeEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWindowStateChangeEvent, __construct)
+{
+  ///Qt::WindowStates aOldStates0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method '__construct' is not static");
+        RETURN_NULL();
+      }
+      /// try Qt::WindowStates aOldStates0s0,
+      QWindowStateChangeEvent_php_qt *
+        selfpointer = new QWindowStateChangeEvent_php_qt(getThis(), (Qt::WindowStates) Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWindowStateChangeEvent::QWindowStateChangeEvent(...) ");
 }
 
+/*!
+ * method oldState
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::WindowStates
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QWindowStateChangeEvent);
+ZEND_METHOD(QWindowStateChangeEvent, oldState)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, "method 'oldState' is not static");
+        RETURN_NULL();
+      }
+      /// try 
+      QWindowStateChangeEvent *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast < QWindowStateChangeEvent * >(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer->oldState());
+    }
+  }
+  php_error(E_ERROR, "could not parse argument in QWindowStateChangeEvent::oldState(...) ");
+}



From tm243 at berlios.de  Tue Jun  6 23:03:31 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Tue, 6 Jun 2006 23:03:31 +0200
Subject: [Php-qt-svn] r256 - trunk/qt/classes
Message-ID: <200606062103.k56L3V3C000135@sheep.berlios.de>

Author: tm243
Date: 2006-06-06 23:03:31 +0200 (Tue, 06 Jun 2006)
New Revision: 256

Modified:
   trunk/qt/classes/qdialog.cpp
   trunk/qt/classes/qlayout.cpp
Log:
manually postprocessed.

Modified: trunk/qt/classes/qdialog.cpp
===================================================================
--- trunk/qt/classes/qdialog.cpp	2006-06-06 20:52:31 UTC (rev 255)
+++ trunk/qt/classes/qdialog.cpp	2006-06-06 21:03:31 UTC (rev 256)
@@ -738,7 +738,7 @@
       if (getThis() != NULL) {
         selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
       }
-      RETURN_VOID(selfpointer->accepted());
+//      RETURN_VOID(selfpointer->accepted());
     }
   }
   php_error(E_ERROR, "could not parse argument in QDialog::accepted(...) ");
@@ -932,7 +932,7 @@
       if (getThis() != NULL) {
         selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
       }
-      RETURN_VOID(selfpointer->rejected());
+//      RETURN_VOID(selfpointer->rejected());
     }
   }
   php_error(E_ERROR, "could not parse argument in QDialog::rejected(...) ");
@@ -973,7 +973,7 @@
         QEvent *
           cpp_arg_0 = static_cast < QEvent * >(php_qt_fetch(arg_0));
 
-        RETURN_BOOL(selfpointer->event((QEvent *) cpp_arg_0));
+//        RETURN_BOOL(selfpointer->event((QEvent *) cpp_arg_0));
       }
 #endif
 
@@ -1025,7 +1025,7 @@
       if (getThis() != NULL) {
         selfpointer = static_cast < QDialog * >(PHP_QT_FETCH());
       }
-      RETURN_VOID(selfpointer->finished((int)Z_LVAL_P(arg_0)));
+//      RETURN_VOID(selfpointer->finished((int)Z_LVAL_P(arg_0)));
     }
   }
   php_error(E_ERROR, "could not parse argument in QDialog::finished(...) ");

Modified: trunk/qt/classes/qlayout.cpp
===================================================================
--- trunk/qt/classes/qlayout.cpp	2006-06-06 20:52:31 UTC (rev 255)
+++ trunk/qt/classes/qlayout.cpp	2006-06-06 21:03:31 UTC (rev 256)
@@ -19,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLayout.cpp - QLayout PHP implementation.
- * begin           : Tue Jun  6 22:42:56 2006
+ * begin           : Tue Jun  6 22:56:02 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -115,6 +115,10 @@
   virtual QLayoutItem *itemAt(int indexs0) const;       // pure 
 
   virtual QLayoutItem *takeAt(int indexs0);     // pure 
+
+  virtual void setGeometry(const QRect & s0);   // pure 
+  virtual QSize sizeHint() const;       // pure 
+
 protected:
   void protected_setGeometry(const QRect & s0); // pure 
 };
@@ -134,6 +138,20 @@
 // virtual, pure 
 
 void
+QLayout_php_qt::setGeometry(const QRect & s0)
+{
+}
+
+// virtual, pure 
+
+QSize
+QLayout_php_qt::sizeHint() const
+{
+}
+
+// virtual, pure 
+
+void
 QLayout_php_qt::addItem(QLayoutItem * s0)
 {
 }



From tm243 at berlios.de  Thu Jun  8 15:24:08 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Thu, 8 Jun 2006 15:24:08 +0200
Subject: [Php-qt-svn] r257 - trunk
Message-ID: <200606081324.k58DO8x2024668@sheep.berlios.de>

Author: tm243
Date: 2006-06-08 15:24:07 +0200 (Thu, 08 Jun 2006)
New Revision: 257

Modified:
   trunk/ChangeLog
   trunk/TODO
Log:
next steps to do and things that were done

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2006-06-06 21:03:31 UTC (rev 256)
+++ trunk/ChangeLog	2006-06-08 13:24:07 UTC (rev 257)
@@ -1,3 +1,14 @@
+2006-06-08  Thomas Moenicke <tm at ippfp.org>  (v.0.0.3) "Lilly"
+
+		* tutorial 7 and an example application
+		* automatically conversion of PHP strings into QStrings in method calls
+		* function 'qobject_cast' implemented
+		* handling of all allowed arguments in methods, with fast lookup table for inheritance
+		* Signals-Slots and custom Signals-Slots implemented
+		* better error handling for debugging
+		* #ifdef statements to exclude unimplemented classes to compile safely
+		* kalyptus extension rewritten
+
 2006-01-23  Thomas Moenicke  <tm at ippfp.org> (v.0.0.2) "Fridolin"
 
         * a lot of new classes added

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-06-06 21:03:31 UTC (rev 256)
+++ trunk/TODO	2006-06-08 13:24:07 UTC (rev 257)
@@ -1,5 +1,9 @@
 
-- handling of optional method arguments
-- custom SLOTS/SIGNALS
-- virtual methods
-- float
+
+- virtual and protected methods (already prepared)
+- storing meta objects in hashtable (already prepared)
+- returning of right php objects if returntype is reference
+- support for pecl operators
+- support for Q_SIGNAL/Q_SLOT macros
+- classes for tutorial 8-14 and QSvgWidget, QSvgRenderer
+



From tm243 at berlios.de  Thu Jun  8 15:31:35 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Thu, 8 Jun 2006 15:31:35 +0200
Subject: [Php-qt-svn] r258 - in trunk: . examples examples/calculator tutorials
Message-ID: <200606081331.k58DVZTa025561@sheep.berlios.de>

Author: tm243
Date: 2006-06-08 15:31:34 +0200 (Thu, 08 Jun 2006)
New Revision: 258

Added:
   trunk/examples/
   trunk/examples/calculator/
Removed:
   trunk/tutorials/calculator/
Modified:
   trunk/examples/calculator/calculator.php
Log:
calculator moved to 'examples'

Copied: trunk/examples/calculator (from rev 256, trunk/tutorials/calculator)

Modified: trunk/examples/calculator/calculator.php
===================================================================
--- trunk/tutorials/calculator/calculator.php	2006-06-06 21:03:31 UTC (rev 256)
+++ trunk/examples/calculator/calculator.php	2006-06-08 13:31:34 UTC (rev 258)
@@ -68,11 +68,11 @@
             $this->pendingAdditiveOperator = new QString();
             $this->pendingMultiplicativeOperator = new QString();
 
-            $this->display = new QLineEdit("Thor");
+            $this->display = new QLineEdit("0");
             $this->display->setReadOnly(true);
             $this->display->setAlignment(QT_ALIGNMENT_ALIGNRIGHT);
             $this->display->setMaxLength(15);
-//            $this->display->installEventFilter($this);
+            $this->display->installEventFilter($this);
 
             for ($i = 0; $i < $this->NumDigitButtons; ++$i) {
                     $this->digitButtons[$i] = $this->createButton($i."", SLOT("digitClicked()"));



From tm243 at berlios.de  Thu Jun  8 16:41:20 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Thu, 8 Jun 2006 16:41:20 +0200
Subject: [Php-qt-svn] r259 - trunk
Message-ID: <200606081441.k58EfKUm001887@sheep.berlios.de>

Author: tm243
Date: 2006-06-08 16:41:20 +0200 (Thu, 08 Jun 2006)
New Revision: 259

Modified:
   trunk/ChangeLog
Log:
typo

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2006-06-08 13:31:34 UTC (rev 258)
+++ trunk/ChangeLog	2006-06-08 14:41:20 UTC (rev 259)
@@ -1,4 +1,4 @@
-2006-06-08  Thomas Moenicke <tm at ippfp.org>  (v.0.0.3) "Lilly"
+2006-06-08  Thomas Moenicke <tm at ippfp.org>  (v.0.0.3) "Lilli"
 
 		* tutorial 7 and an example application
 		* automatically conversion of PHP strings into QStrings in method calls



From tm243 at berlios.de  Fri Jun  9 08:44:48 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Fri, 9 Jun 2006 08:44:48 +0200
Subject: [Php-qt-svn] r260 - in trunk: . qt
Message-ID: <200606090644.k596im3K024031@sheep.berlios.de>

Author: tm243
Date: 2006-06-09 08:44:45 +0200 (Fri, 09 Jun 2006)
New Revision: 260

Modified:
   trunk/config.m4
   trunk/qt/php_qt.cpp
Log:
64bit libpath added, version number corrected.

Modified: trunk/config.m4
===================================================================
--- trunk/config.m4	2006-06-08 14:41:20 UTC (rev 259)
+++ trunk/config.m4	2006-06-09 06:44:45 UTC (rev 260)
@@ -44,7 +44,7 @@
 
   SEARCH_OBJ="/Qt/qobject.h"
 
-  SEARCH_PATH="/usr/local /usr /usr/lib/qt4"
+  SEARCH_PATH="/usr/local /usr /usr/lib/qt4 /usr/lib64/qt4"
   SEARCH_FOR="/include/qt4 /include"
   SEARCH_FOR_OTHER="/include/Qt/qobject.h"
 

Modified: trunk/qt/php_qt.cpp
===================================================================
--- trunk/qt/php_qt.cpp	2006-06-08 14:41:20 UTC (rev 259)
+++ trunk/qt/php_qt.cpp	2006-06-09 06:44:45 UTC (rev 260)
@@ -101,7 +101,7 @@
 	PHP_RSHUTDOWN(php_qt),	/* Replace with NULL if there's nothing to do at request end */
 	PHP_MINFO(php_qt),
 #if ZEND_MODULE_API_NO >= 20010901
-	"0.1", /* Replace with version number for your extension */
+	"0.0.3", /* Replace with version number for your extension */
 #endif
 	STANDARD_MODULE_PROPERTIES
 };



From tm243 at berlios.de  Tue Jun 13 10:27:38 2006
From: tm243 at berlios.de (tm243 at BerliOS)
Date: Tue, 13 Jun 2006 10:27:38 +0200
Subject: [Php-qt-svn] r261 - trunk
Message-ID: <200606130827.k5D8RcP9027611@sheep.berlios.de>

Author: tm243
Date: 2006-06-13 10:27:35 +0200 (Tue, 13 Jun 2006)
New Revision: 261

Modified:
   trunk/config.m4
Log:
unallowed spaces removed.

Modified: trunk/config.m4
===================================================================
--- trunk/config.m4	2006-06-09 06:44:45 UTC (rev 260)
+++ trunk/config.m4	2006-06-13 08:27:35 UTC (rev 261)
@@ -111,7 +111,7 @@
 	qt/classes/qcontextmenuevent.cpp \
 	qt/classes/qdate.cpp \
 	qt/classes/qdatetime.cpp \
-	qt/classes/qdialog.cpp \ 
+	qt/classes/qdialog.cpp \
 	qt/classes/qdragenterevent.cpp \
 	qt/classes/qdragleaveevent.cpp \
 	qt/classes/qdragmoveevent.cpp \
@@ -149,7 +149,7 @@
 	qt/classes/qtimer.cpp \
 	qt/classes/qtimerevent.cpp \
 	qt/classes/qtoolbarchangeevent.cpp \
-	qt/classes/qtoolbutton.cpp \ 
+	qt/classes/qtoolbutton.cpp \
 	qt/classes/qwhatsthisclickedevent.cpp \
 	qt/classes/qwheelevent.cpp \
 	qt/classes/qwidgetdata.cpp \



