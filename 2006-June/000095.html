<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Php-qt-svn] r251 - trunk/tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/php-qt-svn/2006-June/index.html" >
   <LINK REL="made" HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r251%20-%20trunk/tools&In-Reply-To=%3C200606062034.k56KYIlW028173%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000094.html">
   <LINK REL="Next"  HREF="000096.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Php-qt-svn] r251 - trunk/tools</H1>
    <B>tm243 at BerliOS</B> 
    <A HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r251%20-%20trunk/tools&In-Reply-To=%3C200606062034.k56KYIlW028173%40sheep.berlios.de%3E"
       TITLE="[Php-qt-svn] r251 - trunk/tools">tm243 at berlios.de
       </A><BR>
    <I>Tue Jun  6 22:34:18 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000094.html">[Php-qt-svn] r250 - trunk/qt
</A></li>
        <LI>Next message: <A HREF="000096.html">[Php-qt-svn] r252 - trunk/qt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#95">[ date ]</a>
              <a href="thread.html#95">[ thread ]</a>
              <a href="subject.html#95">[ subject ]</a>
              <a href="author.html#95">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tm243
Date: 2006-06-06 22:34:16 +0200 (Tue, 06 Jun 2006)
New Revision: 251

Modified:
   trunk/tools/kalyptusCxxToPHP.pm
Log:
much more work on parser: generates well-compiling cpp code with support for moc, type checking etc.

Modified: trunk/tools/kalyptusCxxToPHP.pm
===================================================================
--- trunk/tools/kalyptusCxxToPHP.pm	2006-06-06 20:27:57 UTC (rev 250)
+++ trunk/tools/kalyptusCxxToPHP.pm	2006-06-06 20:34:16 UTC (rev 251)
@@ -13,14 +13,11 @@
 # *                                                                         *
 #***************************************************************************/
 
-# sub cplusplusToZEND               $cplusplusType
-# sub cplusplusToZENDType           $cplusplusType
-# sub cplusplusToPInvoke            $cplusplusType
-# sub cplusplusToMacro              $class, $cnode
-
 # sub writeDoc                      $lib, $rootnode, $outputdir, $opt
 # sub writeClassDoc                 $node
 
+# support for return types, access (can switch from public to private)
+
 package kalyptusCxxToPHP;
 
 use File::Path;
@@ -40,12 +37,22 @@
     @clist
     $host $who $now $gentext %functionId $docTop
 	$lib $rootnode $outputdir $opt $debug $typeprefix $eventHandlerCount
-	$pastaccess $pastname $pastreturn $pastparams $nullctor $ctorCount @properties @functions @constructors
+	$pastaccess $pastname $pastreturn $pastparams $nullctor $ctorCount
 
+    $onlyPrivateConstructor
+    $classId
+
+    @properties
+    @functions
+    @constructors
+
     %methods
-    @protected;
-    @virtual;
-    @addIncludes;
+    %classes
+    @protected
+    @virtual
+    @addIncludes
+    @enums
+    @pure
 
     $classname;
     *CLASS
@@ -59,6 +66,7 @@
     *AG_CONFIGM4
     *AG_QT_MINIT
     *AG_PHP_QT_CPP
+    *INHERITANCE
 
     *QTCTYPES
     *KDETYPES
@@ -95,11 +103,18 @@
 	my ( $lib, $rootnode, $outputdir_, $opt ) = @_;
 
     $outputdir = $outputdir_;
+    $global_rootnode = $rootnode;
+    $onlyPrivateConstructor = 1;
+    $classId = 1;
+    %classes = ();
 
 #    kdocAstUtil::dumpAst($rootnode);
+    report(&quot;reimplementation of protected and virtual methods temporarily disabled&quot;);
 
     openAllFiles();
 
+    generateInheritanceList();
+
 	# Document all compound nodes
 	Iter::LocalCompounds( $rootnode, sub { writeClassDoc( shift ); } );
 
@@ -114,49 +129,82 @@
 	my( $class ) = @_;
     $classname = $class-&gt;{astNodeName};
 
+    @addIncludes = ();
+    @virtual = ();
+    @protected = ();
+    @pure = ();
+    %methods = ();
+
     openClassFile($class);
 
     checkIncludes($class);
     writeAllFiles($class);
 
+    prepareMethods($class);
     DerivedClass($class);
 
     handleAllMethods($class);
     Inheritance($class);
 
-
-
     closeClassFile();
 
 }
 
-# all methods of this class
-
-sub handleAllMethods
+sub prepareMethods
 {
     my ($class) = @_;
 
     %methods = ();
+    @enums = ();
 
 	Iter::MembersByType ($class,sub{},
 		sub
         {
             my ($class, $kid ) = @_;
+            if ($kid-&gt;{NodeType} eq &quot;enum&quot; )
+            {
+                push @enums, $kid;
+            }
+
             if ($kid-&gt;{NodeType} eq &quot;property&quot; )
             {
                 push @properties, $kid;
             }
             if($kid-&gt;{NodeType} eq &quot;method&quot;)
             {
+                # to handle overloaded methods
                 mergeMethods($kid);
             }
         },sub {}
 	);
 
+    foreach my $key (%methods){
+
+        $method = %methods-&gt;{$key};
+
+        if($method-&gt;{Flags} =~ /p/) {
+            push(@pure, $method);
+        } elsif($method-&gt;{Access} eq &quot;protected&quot; || $method-&gt;{Flags} =~ /v/){
+            if($method-&gt;{astNodeName} eq $classname){
+                report(&quot;protected constructor&quot;, 3);
+                next;
+            }
+            push @protected, $method;
+        } else {
+            report($method-&gt;{astNodeName}.&quot; skipped in prepareMethods()&quot;, 3) if ($method-&gt;{astNodeName} ne &quot;&quot; &amp;&amp; $method-&gt;{astNodeName} =~ /v/);
+        }
+    }
+}
+
+# all methods of this class
+
+sub handleAllMethods
+{
     foreach my $key (keys %methods)
     {
         $method = %methods-&gt;{$key};
 
+        $method = prepareArgs($method);
         writeMethodDoc($method);
         handleMethod($method);
 
@@ -171,7 +219,7 @@
 {
     my ( $method ) = @_;
 
-    my $methodname = $method-&gt;{astNodeName};
+    my $methodname = $method-&gt;{astNodeName};    # for better reading
 
     if(IshouldSkip($method)){
         return;
@@ -180,7 +228,6 @@
     $methodname = &quot;__construct&quot; if($methodname eq $classname);
 
     print CLASS &quot;ZEND_METHOD(&quot;.$classname.&quot;,&quot;.$methodname.&quot;){&quot;;
-    print CLASS &quot;PHP_QT_FETCH_ARGS();&quot;;
 
     my $first = &quot;true&quot;;
     # get _all_ arg
@@ -196,15 +243,15 @@
 
         my $zend_args_query;        # parameter for the type check statement
         my $ce_ptr_query;           # parameter for the class check statement
-        my $count_args=0;
+        my $count_args = 0;
         my @stack = ();             # argument stack, regular parameters
         my @stack_optional = ();    # argument stack, optional parameters
+        my $specialQString;         # converts php strings into QStrings
 
         my @ifdef_stack = ();       # object safety
 
         # check whether agument is optional or regular
         foreach my $cpp_arg ( @cargs ) {
-
             if($cpp_arg =~ /=/){
                 push(@stack_optional,$cpp_arg);
             } else {
@@ -226,39 +273,58 @@
                 next ARGLIST;
             }
 
-            $zend_args_query .= &quot; &amp;&amp; Z_TYPE_P(args[&quot;.$count_args.&quot;]) == IS_&quot;.$zend_arg;
+            # skip abstract class
+            if(isAbstract(unwrapClassType($overloadedmethod-&gt;{ReturnType}))){
+                print CLASS &quot;\n// notice: abstract class &quot;.unwrapClassType($overloadedmethod-&gt;{ReturnType}).&quot; cannot be instanciated, skipped\n&quot;;
+                next ARGLIST;
+            }
+
+            $zend_args_query .= &quot; &amp;&amp; Z_TYPE_P(arg_&quot;.$count_args.&quot;) == IS_&quot;.$zend_arg;
             if($zend_arg eq &quot;OBJECT&quot;){
-                if($count_args &gt; 1){
-                    $ce_ptr_query .= &quot;&amp;&amp; &quot;;
+                my $classId = %classes-&gt;{ unwrapClassType($cpp_arg) };
+                if($classId == 0){
+                    $classId = &quot;0&quot;;
                 }
-                $ce_ptr_query .= &quot;Z_OBJCE_P(args[&quot;.$count_args.&quot;]) == &quot;.unwrapClassType($cpp_arg).&quot;_ce_ptr&quot;;
-                push(@ifdef_stack,unwrapClassType($cpp_arg));
+                $ce_ptr_query .= &quot;inherits(Z_OBJCE_P(arg_&quot;.$count_args.&quot;), &quot;.$classId.&quot;)&quot;;
+                push(@ifdef_stack,unwrapClassType(removeGeneric($cpp_arg)));
+                $ce_ptr_query .= &quot;&amp;&amp;&quot;;
             }
+            if($cpp_arg =~ /QString/){
+                $specialQString = &quot;arg_&quot;.$count_args.&quot; = invokeToQString(arg_&quot;.$count_args.&quot;);\n&quot;;
+            }
             $count_args++;
         }
 
+        # remove last '&amp;&amp;'
+        chop($ce_ptr_query);
+        chop($ce_ptr_query);
+
         # type check
         print CLASS &quot;\n\t///&quot;.$overloadedmethod-&gt;{Params}.&quot;\n&quot;;
 
         # ifdef
-        print CLASS &quot;#ifdef PHP_QT_&quot;.unwrapClassType($method-&gt;{ReturnType}).&quot; // return type\n\n&quot;
-            if cplusplusToZVAL($method-&gt;{ReturnType}) eq &quot;OBJECT&quot;;
+        print CLASS &quot;#ifdef PHP_QT_&quot;.unwrapClassType(removeGeneric($overloadedmethod-&gt;{ReturnType})).&quot; // return type\n\n&quot;
+            if cplusplusToZVAL($overloadedmethod-&gt;{ReturnType}) eq &quot;OBJECT&quot;;
 
-        print CLASS &quot;if(ZEND_NUM_ARGS() == &quot;.$count_args.$zend_args_query.&quot;){&quot;;
+        print CLASS &quot;if(ZEND_NUM_ARGS() == &quot;.$count_args.&quot;){&quot;;
+        print CLASS &quot;PHP_QT_FETCH_&quot;.$count_args.&quot;_ARGS();&quot;;
 
+        print CLASS $specialQString.&quot;\n&quot;;
+        print CLASS &quot;if(1 &quot;.$zend_args_query.&quot;){&quot;;
+
         # class check if object
         if($ce_ptr_query ne &quot;&quot;){
             print CLASS &quot;&quot;.expandIfdefs(@ifdef_stack);  # ifdef PHP_QT_QString
             print CLASS &quot; if(&quot;.$ce_ptr_query.&quot;){&quot;;
-            handleArguments($params,$method-&gt;{ReturnType},$method-&gt;{Flags}, $methodname); # argument handling
+            handleArguments($params,$overloadedmethod-&gt;{ReturnType},$overloadedmethod-&gt;{Flags}, $methodname, $overloadedmethod); # argument handling
             print CLASS &quot;}\n&quot;;
             print CLASS &quot;&quot;.expandEndifs(@ifdef_stack);  # endif
 
         # simple types
         } else {
-            handleArguments($params,$method-&gt;{ReturnType},$method-&gt;{Flags}, $methodname); # argument handling
+            handleArguments($params,$overloadedmethod-&gt;{ReturnType},$overloadedmethod-&gt;{Flags}, $methodname, $overloadedmethod); # argument handling
         }
-        print CLASS &quot;}&quot;;
+        print CLASS &quot;}}&quot;; # end if ZEND_NUM_ARGS
 
         #
         # for all optional parameters
@@ -271,35 +337,48 @@
             # intercept unknown types
             if($zend_arg eq &quot;unknown&quot;){
                 print CLASS &quot;\n// notice: unknown argument &quot;.$cpp_arg.&quot;, skipped\n&quot;;
+                # ifdef
+                print CLASS &quot;#endif // return type\n\n&quot; if cplusplusToZVAL($overloadedmethod-&gt;{ReturnType}) eq &quot;OBJECT&quot;;
+
                 next ARGLIST;
             }
 
-            $zend_args_query .= &quot; &amp;&amp; Z_TYPE_P(args[&quot;.$count_args++.&quot;]) == IS_&quot;.$zend_arg;
+            $zend_args_query .= &quot; &amp;&amp; Z_TYPE_P(arg_&quot;.$count_args++.&quot;) == IS_&quot;.$zend_arg;
 
             # type check
-            print CLASS &quot;if(ZEND_NUM_ARGS() == &quot;.$count_args.$zend_args_query.&quot;){&quot;;
+            print CLASS &quot;if(ZEND_NUM_ARGS() == &quot;.$count_args.&quot;){&quot;;
+            print CLASS &quot;PHP_QT_FETCH_&quot;.$count_args.&quot;_ARGS();&quot;;
 
+            # regular arg
+            print CLASS $specialQString;
+
+            # optional arg
+            if($cpp_arg =~ /QString/){
+                print CLASS &quot;arg_&quot;.$count_args.&quot; = invokeToQString(arg_&quot;.$count_args.&quot;);\n&quot;;
+            }
+            print CLASS &quot;if(1 &quot;.$zend_args_query.&quot;){&quot;;
+
             # if object
             if($ce_ptr_query ne &quot;&quot;){
                 print CLASS &quot;&quot;.expandIfdefs(@ifdef_stack);  # ifdef PHP_QT_QString
                 print CLASS &quot; if(&quot;.$ce_ptr_query.&quot;){&quot;;  # ask object types
-                handleArguments($params,$method-&gt;{ReturnType},$method-&gt;{Flags}, $methodname); # argument handling
+                handleArguments($params,$overloadedmethod-&gt;{ReturnType},$overloadedmethod-&gt;{Flags}, $methodname, , $overloadedmethod); # argument handling
                 print CLASS &quot;}\n&quot;;
                 print CLASS &quot;&quot;.expandEndifs(@ifdef_stack);  # endif
             # if simple type
             } else {
                 # argument handling
-                handleArguments($params,$method-&gt;{ReturnType},$method-&gt;{Flags}, $methodname);
+                handleArguments($params,$overloadedmethod-&gt;{ReturnType},$overloadedmethod-&gt;{Flags}, $methodname, , $overloadedmethod);
             }
-            print CLASS &quot;}&quot;; # end type check
+            print CLASS &quot;}}&quot;; # end type check
 
         } # stack_optional
 
         # ifdef
-        print CLASS &quot;#endif // return type\n\n&quot; if cplusplusToZVAL($method-&gt;{ReturnType}) eq &quot;OBJECT&quot;;
+        print CLASS &quot;#endif // return type\n\n&quot; if cplusplusToZVAL($overloadedmethod-&gt;{ReturnType}) eq &quot;OBJECT&quot;;
     }
 
-    print CLASS &quot;php_error(E_ERROR,\&quot;could not parse argument\&quot;);&quot;;
+    print CLASS &quot;php_error(E_ERROR,\&quot;could not parse argument in &quot;.$classname.&quot;::&quot;.$method-&gt;{astNodeName}.&quot;(...) \&quot;);&quot;;
     print CLASS &quot;}\n&quot;;
 
 }
@@ -310,22 +389,39 @@
 
 sub handleArguments
 {
-    my ( $params, $return, $flags, $methodname ) = @_;
+    my ( $params, $return, $flags, $methodname, $overloadedmethod ) = @_;
 
     my $returnType = cplusplusToZVAL($return);      # example: BOOL, LONG, DOUBLE, STRING, OBJECT
     my $is_constructor = ($method-&gt;{astNodeName} eq $classname);
 
+#    print CLASS &quot;#ifdef MONITOR\n cout &lt;&lt; \&quot;(&quot;.$classname.&quot;)\&quot; &lt;&lt; getThis() &lt;&lt; \&quot;::&quot;.$methodname.&quot;(&quot;.$params.&quot;)\\n\&quot;;\n#endif\n&quot;;
+#    print CLASS &quot;#ifdef MONITOR\n php_error(E_NOTICE, \&quot;&quot;.$classname.&quot;::&quot;.$methodname.&quot;(&quot;.$params.&quot;) accepted.\\n\&quot;);\n#endif\n&quot;;
+
     if($returnType eq &quot;unknown&quot;){
         print CLASS &quot;php_error(E_ERROR,\&quot;unsupported return type &quot;.$return.&quot;\&quot;);&quot;;
         return;
     }
 
+    if($overloadedmethod-&gt;{Access} eq &quot;protected&quot;){
+        print CLASS &quot;\n/// overloaded method is protected, skipped.\n&quot;;
+        report(&quot;overloaded protected method &quot;.$methodname, 3);
+        return if ($methodname ne &quot;__construct&quot;);
+    }
+
+    # QCharRef *selfpointer = new QCharRef(...);
+    if($onlyPrivateConstructor || $overloadedmethod-&gt;{Access} eq &quot;private&quot;){
+        report($classname.&quot; has only private constructors&quot;, 4);
+        print CLASS &quot;\n/// method is private, skip\n&quot;;
+        print CLASS &quot;php_error(E_ERROR,\&quot;&quot;.$classname.&quot;::&quot;.$methodname.&quot;(...) cannot be called with '&quot;.$params.&quot;'.\&quot;);&quot;;
+        return;
+    }
+
+
     if($flags =~ /s/){  # static
     } else {
         print CLASS &quot;if(getThis() == NULL){php_error(E_ERROR,\&quot;method '&quot;.$methodname.&quot;' is not static\&quot;); RETURN_NULL();}&quot;;
     }
 
-
     my $preparation;    # invoke zend to cpp, prepare return object if necessary
     my $cpp_call_params;    # the args passed to Qt method
     my $count_args = 0;
@@ -347,6 +443,15 @@
             return; # return arg handling
         }
 
+        # Dummy
+        if($argType eq &quot;ARRAY&quot;){
+            $cpp_call_params .= &quot;new char*[1],&quot;;
+            next;
+        }
+
+        # the Z_STRVAL_P macro delivers char*, but we simply need the first and only char
+        my $charSpecial = &quot;[0]&quot; if isChar($arg);
+
         # for all arg types, e.g. bool*
         $classType = unwrapClassType($arg);
 
@@ -370,11 +475,11 @@
 
         if($argType eq &quot;OBJECT&quot;){
             # example: QString *cpp_arg_0 = static_cast&lt;QString*&gt;(php_qt_fetch(args[0]);
-            $preparation .= $classType.&quot; *cpp_arg_&quot;.$count_args.&quot; = static_cast&lt;&quot;.$classType.&quot;*&gt;(php_qt_fetch(args[&quot;.$count_args.&quot;]));\n&quot;;
+            $preparation .= $classType.&quot; *cpp_arg_&quot;.$count_args.&quot; = static_cast&lt;&quot;.$classType.&quot;*&gt;(php_qt_fetch(arg_&quot;.$count_args.&quot;));\n&quot;;
             $cpp_call_params .= $prefix.&quot;cpp_arg_&quot;.$count_args.&quot; &quot;;
         } else {
             # example: Z_LVAL_P(arg_0), Z_STRVAL(arg_0)
-            $cpp_call_params .= $prefix_ZVAL.&quot;Z_&quot;.invokeTypeToZ_XVAL($argType).&quot;VAL_P(args[&quot;.$count_args.&quot;]) &quot;;
+            $cpp_call_params .= $prefix_ZVAL.&quot;Z_&quot;.invokeTypeToZ_XVAL($argType).&quot;VAL_P(arg_&quot;.$count_args.&quot;)&quot;.$charSpecial.&quot; &quot;;
         }
 
         $cpp_call_params .= &quot;,&quot;;
@@ -387,35 +492,74 @@
 
     # return handling
     my $returnClassName = unwrapClassType($return); # example: QString (from QString &amp;c)
-    my $prefix, $postfix, $infix;
+    my $prefix, my $postfix, my $infix, my $le_ptr;
+    my $yrr, my $rxrr, my $pxrr;
 
+    # yrr,rxrr,pxrr defined for prefix
+    my $leftAssignment;
+    if($returnType eq &quot;OBJECT&quot;){
+        print CLASS &quot;zend_class_entry *ce;&quot;;
+        print CLASS &quot;object_init_ex(return_value, QString_ce_ptr);&quot;;
+        print CLASS &quot;zend_rsrc_list_entry le;&quot;;
+        $yrr = &quot;&quot;;
+    } else {
+        $yrr = $returnClassName;
+        $rxrr = &quot;&amp;&quot;;
+        $pxrr = &quot;*&quot;;
+    }
+
+    # static_cast&lt;...&gt; or const_cast&lt;...&gt;
+    my $castWay = &quot;static&quot;;
+    if($return =~ /const/){
+        $castWay = &quot;const&quot;;
+    }
+
+    my $returnCast;
+    $returnCast = &quot;(char*)&quot; if isChar($return);
+    $returnCast = &quot;(char*)&quot; if ($returnType eq &quot;STRING&quot;);
+
     if(checkRPN($return) eq &quot;reference&quot;){       # tested
-        $prefix = $returnClassName.&quot;&amp;&quot;;
+        $prefix = $yrr.$rxrr;
+        # const_cast&lt;...&gt; =&gt; &amp;const_cast&lt;...&gt;
+        $castWay = &quot;&amp;&quot;.$castWay;
         $infix = &quot;&amp;&quot;;
+        $le_ptr = &quot;&amp;&quot;;
     } elsif (checkRPN($return) eq &quot;pointer&quot;){
-        $prefix = $returnClassName.&quot;* &quot;;
+        $prefix = $yrr.$pxrr;
+        $infix = &quot;*&quot;;    # for static_cast, return_object
+        $le_ptr = &quot;&quot;;
     } elsif (checkRPN($return) eq &quot;normal&quot;){    # tested with non-objects
-        # allocate memory on the heap
-        if($returnType eq &quot;OBJECT&quot;){
+        $infix = &quot;&quot;;
+        $prefix = &quot;*&quot;;
+        $le_ptr = &quot;&quot;;
+    }
+
+    # allocate memory on the heap if object
+    # QString *return_object = new QString;
+    # leftAssignment:
+    # *return_object = static_cast&lt;.....
+    if($returnType eq &quot;OBJECT&quot;){
+        if (checkRPN($return) eq &quot;normal&quot;){
             print CLASS $returnClassName.&quot; *return_object = new &quot;.$returnClassName.&quot;;\n&quot;;
+            $leftAssignment = $prefix.&quot; return_object&quot;;
+        } else {
+            $leftAssignment = &quot;le.ptr&quot;; #le.ptr
         }
-        $prefix = &quot;*&quot;;
     }
 
     if($returnType eq &quot;OBJECT&quot;){
         if($flags =~ /s/){  # static
-            print CLASS &quot;if(getThis() == NULL){&quot;.$prefix.&quot; return_object = static_cast&lt;&quot;                .$returnClassName.$infix.&quot;&gt;(&quot;.$classname.&quot;::&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;));} else {&quot;
-            .$prefix.&quot; return_object = static_cast&lt;&quot;               .$returnClassName.$infix.&quot;&gt;(selfpointer-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;));}&quot;;
-        } else {
-            print CLASS $prefix.&quot; return_object = static_cast&lt;&quot;
+            print CLASS &quot;if(getThis() == NULL){&quot;.$leftAssignment.&quot; = &quot;.$castWay.&quot;_cast&lt;&quot;                .$returnClassName.$infix.&quot;&gt;(&quot;.$classname.&quot;::&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;));} else {&quot;
+            .$leftAssignment.&quot; = &quot;.$castWay.&quot;_cast&lt;&quot;               .$returnClassName.$infix.&quot;&gt;(selfpointer-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;));}&quot;;
+        } else { #non-static
+            print CLASS $leftAssignment.&quot; = &quot;.$castWay.&quot;_cast&lt;&quot;
                 .$returnClassName.$infix.&quot;&gt;(selfpointer-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;));&quot;;
         }
-        print CLASS &quot;zend_class_entry *ce;&quot;;
-        print CLASS &quot;object_init_ex(return_value, QString_ce_ptr);&quot;;
-        print CLASS &quot;zend_rsrc_list_entry le;&quot;;
-        print CLASS &quot;le.ptr = (void*) &quot;.$infix.&quot;return_object;&quot;;
+        # normal
+        print CLASS &quot;le.ptr = (void*) &quot;.$le_ptr.&quot;return_object;&quot; if (checkRPN($return) eq &quot;normal&quot;);
         print CLASS &quot;php_qt_register(return_value,le);&quot;;
         print CLASS &quot;return;&quot;;
+
     } else {
         my $for_string;
         if($returnType eq &quot;STRING&quot;){    # RETURN_STRING macro needs 2 params
@@ -423,15 +567,30 @@
         }
         if($is_constructor){   # constructor
             my $comma = &quot;,&quot; if($cpp_call_params);
+
+            # constructor:
+            # QString_php_qt *selfpointer = new QString_php_qt(...);
+            # there are two ways: allocate memory on heap or with emalloc
+
+            # cpp-way
             print CLASS $classname.&quot;_php_qt *selfpointer = new &quot;.$classname.&quot;_php_qt(getThis()&quot;.$comma.$cpp_call_params.&quot;);&quot;;
-            print CLASS &quot;PHP_QT_REGISTER(selfpointer);&quot;;
+
+            # experiment, do not use
+#            print CLASS $classname.&quot;_php_qt *selfpointer = static_cast&lt;&quot;.$classname.&quot;_php_qt*&gt;(new &quot;.$classname.&quot;(&quot;.$cpp_call_params.&quot;));&quot;;
+#            print CLASS &quot;selfpointer-&gt;zend_ptr = getThis();&quot;;
+
+            # zend-way with emalloc()
+#            print CLASS $classname.&quot;_php_qt *selfpointer = static_cast&lt;&quot;.$classname.&quot;_php_qt*&gt;(emalloc(sizeof(&quot;.$classname.&quot;_php_qt)));&quot;;
+#            print CLASS &quot;new (selfpointer) &quot;.$classname.&quot;_php_qt(getThis()&quot;.$comma.$cpp_call_params.&quot;);&quot;;
+
+            print CLASS &quot;PHP_QT_REGISTER(selfpointer);RETURN_NULL();&quot;;
         } else {
             if($flags =~ /s/){  # static
                 print CLASS &quot;if(getThis() == NULL){RETURN_&quot;.$returnType.&quot;(&quot;.$classname.&quot;::&quot;
                     .$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;)&quot;.$for_string.&quot;);} else {RETURN_&quot;
                     .$returnType.&quot;(selfpointer-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;)&quot;.$for_string.&quot;);}&quot;;
             } else {
-                print CLASS &quot;RETURN_&quot;.$returnType.&quot;(selfpointer-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;)&quot;.$for_string.&quot;);&quot;;
+                print CLASS &quot;RETURN_&quot;.$returnType.&quot;(&quot;.$returnCast.&quot;selfpointer-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;)&quot;.$for_string.&quot;);&quot;;
             }
         }
     }
@@ -443,10 +602,21 @@
 {
 	my ( $method )  = @_;
 
+    # skip destructor
+    if($method-&gt;{ReturnType} =~ /~/){
+        return;
+    }
+
     # looking for existing list
     foreach my $key ( %methods ) {
         if ( $key-&gt;{astNodeName} eq $method-&gt;{astNodeName} ) {
-            #add to existing list
+
+            # report
+#             if($key-&gt;{ReturnType} ne $method-&gt;{ReturnType}){
+#                 report($classname .&quot;, &quot;. $method-&gt;{astNodeName} .&quot;: &lt;&quot;. $key-&gt;{ReturnType} .&quot;&gt; &lt;&quot;. $method-&gt;{ReturnType}.&quot;&gt;\n&quot;);
+#             }
+
+            # add to existing list
             push(@{$methods{ $method-&gt;{astNodeName} }-&gt;{&quot;argList&quot;}},$method);
 	        return;
  		}
@@ -511,6 +681,11 @@
 	mkpath( $outputdir ) unless -f $outputdir;
     mkpath( $outputdir.&quot;/classes/&quot; ) unless -f $outputdir.&quot;/classes/&quot;;
 
+    # INHERITANCE
+    my $file_inheritance = &quot;$outputdir/inheritance.cpp&quot;;
+    open( INHERITANCE, &quot;&gt;$file_inheritance&quot; ) || die &quot;Couldn't create $file_inheritance\n&quot;;
+    $file_inheritance =~ s/\.h/.h/;
+
     # AG_ZEND_CLASS_ENTRY
     my $file_ag_zend_class_entry = &quot;$outputdir/ag_zend_class_entry.inc&quot;;
     open( AG_ZEND_CLASS_ENTRY, &quot;&gt;$file_ag_zend_class_entry&quot; ) || die &quot;Couldn't create $file_ag_zend_class_entry\n&quot;;
@@ -641,6 +816,7 @@
     close AG_CONFIGM4;
     close AG_QT_MINIT;
     close AG_PHP_QT_CPP;
+    close INHERITANCE;
 }
 
 sub openClassFile
@@ -720,61 +896,205 @@
 {
     my ($class) = @_;
 
-    $constructor = findConstructor($class);
+    # handle enums
+    my $public_enum_declaration;
+    my $protected_enum_declaration;
+    foreach $enum (@enums){
+        # deactivated
+        $public_enum_declaration .= declareEnums($enum,&quot;public&quot;);
+        $protected_enum_declaration .= declareEnums($enum,&quot;protected&quot;);
+    }
 
-    my $prepared_params;
-    my @paramList = kdocUtil::splitUnnested(&quot;,&quot;, $constructor-&gt;{Params});
-    foreach my $param (@paramList){
+    # handle constructors
+    @constructors = findConstructor($class);
 
-        @ch = split(/=/, $param);
+    # nothing to do
+    return if($onlyPrivateConstructor);
 
-        $prepared_params .= &quot;,&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">. at ch</A>[0];
+    my $constructors_declaration, my $constructors_implementation;
+
+
+    foreach my $constructor (@constructors){
+
+        my $prepared_params, my $comma, my $call_params;
+        $call_params = prepareParamsForCall($constructor);
+
+        my @paramList = kdocUtil::splitUnnested(&quot;,&quot;, $constructor-&gt;{Params});
+        if(@paramList &gt; 0){
+            foreach my $param (@paramList){
+                @ch = split(/=/, $param);
+                $prepared_params .= &quot;,&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">. at ch</A>[0];
+            }
+            $comma = &quot;,&quot; if ($prepared_params);
+        }
+
+        $constructors_declaration .= $classname.&quot;_php_qt(zval* zend_ptr&quot;.$comma.$constructor-&gt;{Params}.&quot;);&quot;;
+        $constructors_implementation .= $classname.&quot;_php_qt::&quot;.$classname.&quot;_php_qt(zval* zend_ptr&quot;.$prepared_params.&quot;) : &quot;.$classname.&quot;(&quot;.$call_params.&quot;)
+        {
+            this-&gt;zend_ptr = zend_ptr;&quot;;
+
+        if(hasMetaObject()){
+            $constructors_implementation .= &quot;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,\&quot;&quot;.$classname.&quot;\&quot;,&amp;staticMetaObject));&quot;;
+        }
+        $constructors_implementation .= &quot;\n}\n&quot;;
     }
 
-    $comma = &quot;,&quot; if ($prepared_params);
+    my $protected_declaration, my $protected_implementation;
+    my $virtual_declaration, my $virtual_implementation;
 
-    my $protected_declaration, $protected_implementation;
-    if(@protected){
-        $protected_declaration = &quot;\nprotected:\n&quot;;
+    # handle pure methods
+    if(@pure){
+        foreach my $method (@pure){
+
+            if(IshouldSkipForReimplementation($method)){
+                next;
+            }
+
+            # add const to declaration and implementation
+            # someMethod() const
+            my $constant;
+            if($method-&gt;{Flags} =~ /c/){
+                $constant = &quot;const\n&quot;;
+            }
+
+            writeMethodDoc($method);
+
+            if($method-&gt;{ReturnType} eq &quot;void&quot;){
+                $return = &quot;&quot;;
+            } else {
+                $return = &quot;return &quot;;
+            }
+
+            checkAddIncludes($method);
+
+            $call_params = prepareParamsForCall($method);
+
+            # virtual protected methods will be implemented
+            if($method-&gt;{Flags} =~ /v/){
+                $virtual_declaration .= &quot;\n&quot;.checkConst($method-&gt;{Flags}).&quot; &quot;.checkFlags($method-&gt;{Flags}).&quot; &quot;.$method-&gt;{ReturnType}.&quot; &quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$method-&gt;{Params}.&quot;)&quot;.$constant.&quot;; // pure \n&quot;;
+
+                $virtual_implementation .= &quot;\n// virtual, pure \n\n &quot;.$method-&gt;{ReturnType}.&quot; &quot;.$classname.&quot;_php_qt::&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.prepareParamsForArg($method).&quot;)&quot;.$constant.&quot;{}&quot;;
+
+            # protected methods with proxy methods
+            } else {
+
+                # SliderAction =&gt; QbstractSlider_php_qt::SliderAction
+                my $returnIType;
+                if(isEnum($method-&gt;{ReturnType})){
+                    $returnIType = $classname.&quot;::&quot;.$method-&gt;{ReturnType};
+                } else {
+                    $returnIType = $method-&gt;{ReturnType};
+                }
+
+                #   void protected_adjustPosition(QWidget * QWidget * s0);
+                $protected_declaration .= &quot;\n&quot;.checkConst($method-&gt;{Flags}).&quot; &quot;.checkFlags($method-&gt;{Flags}).&quot; &quot;.$returnIType.&quot; protected_&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.prepareParamsForDeclaration($method).&quot;)&quot;.$constant.&quot;; // pure \n&quot;;
+
+                $protected_implementation .= &quot;\n &quot;.$returnIType.&quot; &quot;.$classname.&quot;_php_qt::protected_&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.prepareParamsForArg($method).&quot;)&quot;.$constant.&quot;{&quot;.$return.&quot;this-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$call_params.&quot;);}&quot;;
+            }
+
+        }
+    } # end pure
+
+    # handle protected methods
+    # temp. disabled
+    if(@protected &amp;&amp; 0){
+
+        $protected_declaration;
+        my $return, my $call_params;
+
         foreach my $method (@protected){
-            if($method-&gt;{astNodeName} eq &quot;metaObject&quot; || $method-&gt;{astNodeName} eq &quot;className&quot;){
+
+            if(IshouldSkipForReimplementation($method)){
                 next;
             }
+
+            # add const to declaration and implementation
+            # someMethod() const
+            my $constant;
+            if($method-&gt;{Flags} =~ /c/){
+                $constant = &quot;const\n&quot;;
+            }
+
+            writeMethodDoc($method);
+
+            if($method-&gt;{ReturnType} eq &quot;void&quot;){
+                $return = &quot;&quot;;
+            } else {
+                $return = &quot;return &quot;;
+            }
+            # skip special methods
+            if($method-&gt;{astNodeName} eq &quot;metaObject&quot;
+            || $method-&gt;{astNodeName} eq &quot;className&quot;){
+                next;
+            }
             checkAddIncludes($method);
-            $protected_declaration .= &quot;\n&quot;.checkConst($method-&gt;{Flags}).&quot; &quot;.checkFlags($method-&gt;{Flags}).&quot; &quot;.$method-&gt;{ReturnType}.&quot; &quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$method-&gt;{Params}.&quot;);&quot;;
-            $protected_implementation .= &quot;\n &quot;.$method-&gt;{ReturnType}.&quot; &quot;.$classname.&quot;_php_qt::&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$method-&gt;{Params}.&quot;){}&quot;;
+
+            $call_params = prepareParamsForCall($method);
+
+            # virtual protected methods will be implemented
+            if($method-&gt;{Flags} =~ /v/){
+                $virtual_declaration .= &quot;\n&quot;.checkConst($method-&gt;{Flags}).&quot; &quot;.checkFlags($method-&gt;{Flags}).&quot; &quot;.$method-&gt;{ReturnType}.&quot; &quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$method-&gt;{Params}.&quot;)&quot;.$constant.&quot;;&quot;;
+
+                $virtual_implementation .= &quot;\n// virtual \n\n &quot;.$method-&gt;{ReturnType}.&quot; &quot;.$classname.&quot;_php_qt::&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.prepareParamsForArg($method).&quot;)&quot;.$constant.&quot;{}&quot;;
+
+            # protected methods with proxy methods
+            } else {
+
+                # SliderAction =&gt; QbstractSlider_php_qt::SliderAction
+                my $returnIType;
+                if(isEnum($method-&gt;{ReturnType})){
+                    $returnIType = $classname.&quot;::&quot;.$method-&gt;{ReturnType};
+                } else {
+                    $returnIType = $method-&gt;{ReturnType};
+                }
+
+                #   void protected_adjustPosition(QWidget * QWidget * s0);
+                $protected_declaration .= &quot;\n&quot;.checkConst($method-&gt;{Flags}).&quot; &quot;.checkFlags($method-&gt;{Flags}).&quot; &quot;.$returnIType.&quot; protected_&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.prepareParamsForDeclaration($method).&quot;)&quot;.$constant.&quot;;&quot;;
+
+                $protected_implementation .= &quot;\n &quot;.$returnIType.&quot; &quot;.$classname.&quot;_php_qt::protected_&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.prepareParamsForArg($method).&quot;)&quot;.$constant.&quot;{&quot;.$return.&quot;this-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$call_params.&quot;);}&quot;;
+            }
         }
+
     }
 
     my $includes;
     foreach $include (@addIncludes){
-        print CLASS &quot;#include &lt;&quot;.$include.&quot;&gt;\n&quot;;
+        $include =~ s/\*|\&amp;//;
+        print CLASS &quot;#include &lt;&quot;.$include.&quot;&gt;\n&quot; if $include ne &quot;&quot;;
     }
 
+    # handle moc implementation
+    my $moc_declaration, my $moc_implementation;
+    if(hasMetaObject()){
+        $moc_declaration = &quot;
+        const QMetaObject* metaObject() const;
+        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);&quot;;
+        $moc_implementation = &quot;\nPHP_QT_MOC(&quot;.$classname.&quot;);\n&quot;;
+    }
+
     print CLASS &quot;#include &lt;QMetaMethod&gt;
     class &quot;.$classname.&quot;_php_qt : public &quot;.$classname.&quot;{
 
     public:
-        &quot;.$classname.&quot;_php_qt(zval* zend_ptr&quot;.$comma.$constructor-&gt;{Params}.&quot;);
+        &quot;.$constructors_declaration.&quot;
+        &quot;.$public_enum_declaration.&quot;
 
-        zval* zend_ptr;
-        QMetaObject* dynamicMetaObject;
+        zval* zend_ptr;&quot;;
+    print CLASS $moc_declaration;
+    print CLASS $virtual_declaration;
+    print CLASS &quot;protected:&quot; if $protected_declaration;
+    print CLASS $protected_enum_declaration;
+    print CLASS $protected_declaration;
+    print CLASS &quot;};&quot;;
 
-        const QMetaObject* metaObject() const;
-        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
-    &quot;.$protected_declaration.&quot;
-    };
-    &quot;.$classname.&quot;_php_qt::&quot;.$classname.&quot;_php_qt(zval* zend_ptr&quot;.$prepared_params.&quot;)
-    {
-        this-&gt;zend_ptr = zend_ptr;
-        dynamicMetaObject = new QMetaObject;
-        dynamicMetaObject = php_qt_getMocData(this-&gt;zend_ptr,\&quot;&quot;.$classname.&quot;\&quot;,&amp;staticMetaObject);
-    }&quot;;
-
+    print CLASS $constructors_implementation;
+    print CLASS $virtual_implementation;
     print CLASS $protected_implementation;
+    print CLASS $moc_implementation;
 
-    print CLASS &quot;\nPHP_QT_MOC(&quot;.$classname.&quot;);
-&quot;;
+    print CLASS &quot;\n&quot;;
+
 # TODO:
 # virtual and private classes
 
@@ -859,12 +1179,17 @@
 		return &quot;LONG&quot;;
 	} elsif ( $cplusplusType =~ /\s*\bint\s*\&amp;*/) {
 		return &quot;LONG&quot;;
-	} elsif ( $cplusplusType =~ /\s*int\s*\&amp;*/) {
+	} elsif ( $cplusplusType =~ /\s*\buint\s*\&amp;*/) {
 		return &quot;LONG&quot;;
+#	} elsif ( $cplusplusType =~ /\s*int\s*\&amp;*/) {
+#		return &quot;LONG&quot;;
 	} elsif ( $cplusplusType =~ /\s*short\s*\&amp;*/) {
 		return &quot;LONG&quot;;
 	} elsif ( $cplusplusType =~ /\s*char\s*\*\*/ ) {
-		return &quot;STRING&quot;;
+        # should e array
+		return &quot;ARRAY&quot;;
+	} elsif ( $cplusplusType =~ /\s*uchar\s*\**/ ) {
+		return &quot;unknown&quot;;
 	} elsif ( $cplusplusType =~ /\s*char\s*\**/ ) {
 		return &quot;STRING&quot;;
 	} elsif ( $cplusplusType =~ /\s*unsigned int\s*\**/ ) {
@@ -1011,27 +1336,48 @@
         return 1;
     }
 #    if($method-&gt;{Flags} =~ /n|v|t/){    # skip slots
-    if($method-&gt;{Flags} =~ /n/){    # skip slots
+    if($method-&gt;{Flags} =~ /n|v/){    # skip slots
         return 1;
     }
 
     if($method-&gt;{Access} eq &quot;protected&quot;){
-        push @protected, $method;
         return 1;
     }
 
-    if($method-&gt;{Flags} =~ /v/){    # skip slots
+    if($method-&gt;{astNodeName} eq &quot;className&quot;
+        || $method-&gt;{astNodeName} eq &quot;qObject&quot;
+        || $method-&gt;{astNodeName} =~ /operator/
+        || $method-&gt;{astNodeName} =~ /qt_/
+    ){
         return 1;
     }
 
+}
+
+sub IshouldSkipForReimplementation
+{
+    my ($method) = @_;
+
+    if($method-&gt;{astNodeName} =~ /qt_/)
+    {   # skip qt_cast, ...
+        return 1;
+    }
+
+    if($method-&gt;{Flags} =~ /n/){    # skip slots
+        return 1;
+    }
+
     if($method-&gt;{astNodeName} eq &quot;className&quot;
-        || $method-&gt;{astNodeName} eq &quot;qObject&quot;)
-    {
+        || $method-&gt;{astNodeName} eq &quot;qObject&quot;
+        || $method-&gt;{astNodeName} =~ /operator/
+        || $method-&gt;{astNodeName} =~ /qt_/
+    ){
         return 1;
     }
 
 }
 
+
 #
 #   finds the constructor
 #
@@ -1039,8 +1385,11 @@
 {
     my ($class) = @_;
 
-    my @return;
+    my @return, my $safetyConstructor;
 
+    $onlyPrivateConstructor = 1;
+    $main::doPrivate = 1;
+
     Iter::MembersByType ($class,sub{},
 	sub
     {
@@ -1049,17 +1398,32 @@
         {
             # there are some additional protected constructors, skip
             if($kid-&gt;{Access} ne &quot;protected&quot;){
+                if($kid-&gt;{Access} eq &quot;private&quot;){
+                    next;
+                }
                 if($kid-&gt;{astNodeName} eq $classname){
-                    push @return, $kid;
+                    if($kid-&gt;{ReturnType} =~ /~/){
+                        debug(&quot;destructor skipped&quot;);
+                    } else {
+                        $onlyPrivateConstructor = 0;
+                        push @return, $kid;
+                    }
                 }
             }
+            if($kid-&gt;{Access} ne &quot;protected&quot; &amp;&amp; $kid-&gt;{astNodeName} eq $classname){
+                $safetyConstructor = $kid;
+            }
         }
     },sub {}
 	);
 
-    # first is the constructor, second is destructor
-    return @return[0];
+    if (@return == 0){
+        report(&quot;none or only protected constructors detected, we declared an empty destructor &quot;.$safetyConstructor-&gt;{Params}, 3);
+        push @return, $safetyConstructor;
+    }
 
+    return @return;
+
 }
 
 sub checkAddIncludes
@@ -1069,6 +1433,11 @@
     my @cargs = kdocUtil::splitUnnested(&quot;,&quot;, $method-&gt;{Params});
 
     foreach my $arg (@cargs){
+
+        if($arg =~ /::/){
+            return;
+        }
+
         my @arg_ = split(/ /,$arg);
         foreach my $m (@addIncludes){
             # skip 'const'
@@ -1076,20 +1445,446 @@
                 if($m eq @arg_[1]){
                     return;
                 }
+            # skip enums
             } else {
                 if($m eq @arg_[0]){
                     return;
                 }
             }
         }
-        if(@arg_[0] eq &quot;const&quot;){
-            push @addIncludes, @arg_[1];
+
+        if(@arg_[0] =~ /Q/ || @arg_[1] =~ /Q/){
+            if(@arg_[0] eq &quot;const&quot;){
+                push @addIncludes, @arg_[1];
+            } else {
+                push @addIncludes, @arg_[0];
+            }
+        }
+    }
+
+}
+
+#
+#   for reimplementing of protected methods
+#   QFocusEvent * e =&gt; e
+#   int repeatTime = 50 s
+#
+#   warn: $method-&gt;{Params} will be modified!
+
+sub prepareParamsForCall
+{
+    my ($method) = @_;
+
+    # for typos:
+    # QWidget* =&gt; QWidget *, see
+    $method-&gt;{Params} =~ s/\*/ \*/;
+    $method-&gt;{Params} =~ s/\&amp;/ \&amp;/;
+    $method-&gt;{Params} =~ s/  / /;
+
+    my @cargs = kdocUtil::splitUnnested(&quot;,&quot;, $method-&gt;{Params});
+    my $param, my $params_replacement, my $safetyCount=0;
+
+    foreach my $arg (@cargs){
+
+        my $type_tmp = $arg;  # needed for @arg_ == 1
+
+        # safety
+        # QAbstractSlider::timerEvent(QTimerEvent*)
+        my $arg_s;
+        if($arg =~ /=/){
         } else {
-            push @addIncludes, @arg_[0];
+            $/ = &quot; &quot;;
+            chomp($arg);
+
+            # ' Type' =&gt; 'Type'
+            $arg =~ s/^ //;
+            my $c = ($arg =~ tr/ //);
+
+            if($c == 0){
+                # to prevent 'PaintDeviceMetrics0',
+                # should be 'PaintDeviceMetric s0' (see QWidget)
+                $arg = &quot;&quot;;
+                $arg .= &quot;s&quot;.$safetyCount;# if $arg =~ /^:/;
+            } else {
+                $arg .= &quot;s&quot;.$safetyCount;# if $arg =~ /^:/;
+            }
+            $arg .= &quot;s&quot;.$safetyCount if $arg =~ /^:/;
+            $arg_s = &quot;s&quot;.$safetyCount++;    # for @arg_ == 1, to prevent 'bool bools0'
         }
 
+        my @arg_ = split(/ /,$arg);
+        if(@arg_[0] eq &quot;&quot;){
+            shift(@arg_);
+        }
+        if(@arg_ == 1){
+            $params_replacement .= $type_tmp.&quot; &quot;.$arg_s.&quot;,&quot;;
+        } else {
+            $params_replacement .= $arg.&quot;,&quot;;
+        }
+
+        #   int repeatTime = 50 s =&gt; repeatTime
+        if($arg =~ /=/){
+
+            # remove special signs
+            $arg_c = $arg;              # work with a copy
+            $arg_c =~ s/=/ /;           # remove '='
+            $arg_c =~ s/\*|\&amp;|const//;  # remove special signs
+            $arg_c =~ s/  / /;          # remove double spaces
+
+            my @arg_c = split(/ /,$arg_c);
+            my @arg_stack;
+            foreach my $a (@arg_c){
+                next if($a eq &quot;&quot; | $a eq &quot;const&quot;);
+                push (@arg_stack, $a);
+            }
+            if(@arg_stack == 2){
+                $param .= &quot;s&quot;.$safetyCount.&quot;,&quot;;
+            } else {
+                pop (@arg_stack);
+                $param .= pop (@arg_stack).&quot;,&quot;;
+            }
+        #   QFocusEvent * e =&gt; e
+        } else {
+            my $arg__ = pop(@arg_);
+            $arg__ =~ s/\*|&amp;//;
+            $param .= $arg__.&quot;,&quot;;
+
+        }
     }
 
+    chop($param);
+    chop($params_replacement);
+    $param =~ s/\*|\&amp;//;
+
+    $method-&gt;{Params} = $params_replacement;
+    return $param;
+
 }
 
+#
+#   prepare for implementation of protected methods
+#
+
+sub prepareParamsForArg
+{
+    my ($method) = @_;
+
+    my @cargs = kdocUtil::splitUnnested(&quot;,&quot;, $method-&gt;{Params});
+    my $arg_return;
+
+    foreach $param (@cargs){
+        my $arg_chunk;
+        if($param =~ /=/){
+            my @arg = split(/=/,$param);
+            $arg_chunk = shift(@arg);
+
+            # WId =&gt; 'WId s0'
+            my $c = ($arg_chunk =~ tr/ //);
+            if($c == 1){
+                report(&quot;Warning: parameter 's0' hardcoded, maybe dangerous!&quot;);
+                $arg_chunk .= &quot;s0&quot;;
+            }
+
+        } else {
+            $arg_chunk = $param;
+        }
+
+        # SliderAction =&gt; QAbstractSlider::SliderAction
+        @arg_ = split(/ /,$arg_chunk);
+        if(isEnum(@arg_[0])){
+            $arg_chunk = $classname.&quot;::&quot;.$arg_chunk;
+        }
+
+        $arg_return .= $arg_chunk;
+
+        $arg_return .= &quot;,&quot;;
+    }
+
+    chop($arg_return);
+
+    return $arg_return;
+
+}
+
+#
+#   prepare for implementation of protected methods
+#
+
+sub prepareParamsForDeclaration
+{
+    my ($method) = @_;
+
+    my @cargs = kdocUtil::splitUnnested(&quot;,&quot;, $method-&gt;{Params});
+    my $arg_return;
+
+    foreach $param (@cargs){
+        my $arg_chunk;
+
+        $arg_chunk = $param;
+
+        # SliderAction =&gt; QAbstractSlider::SliderAction
+        @arg_ = split(/ /,$arg_chunk);
+        if(isEnum(@arg_[0])){
+            $arg_chunk = $classname.&quot;::&quot;.$arg_chunk;
+        }
+
+        $arg_return .= $arg_chunk;
+
+        $arg_return .= &quot;,&quot;;
+    }
+
+    chop($arg_return);
+
+    return $arg_return;
+
+}
+
+
+#
+#   for _all_ methods in class
+#   QEvent* =&gt; QEvent* s0
+
+sub prepareArgs
+{
+    my ($method) = @_;
+
+    # for typos:
+    # QWidget* =&gt; QWidget *
+    $method-&gt;{Params} =~ s/\*/ \*/;
+    $method-&gt;{Params} =~ s/\&amp;/ \&amp;/;
+    $method-&gt;{Params} =~ s/  / /;
+
+    my @cargs = kdocUtil::splitUnnested(&quot;,&quot;, $method-&gt;{Params});
+    my $params_replacement, my $safetyCount;
+
+    foreach $arg (@cargs){
+        my $type_tmp = $arg;  # needed for @arg_ == 1
+
+        # safety
+        # QAbstractSlider::timerEvent(QTimerEvent*)
+        $arg .= &quot;s&quot;.$safetyCount++;
+
+        my @arg_ = split(/ /,$arg);
+        if(@arg_[0] eq &quot;&quot;){
+            shift(@arg_);
+        }
+
+        if(@arg_ == 1){
+            $params_replacement .= $type_tmp.&quot; &quot;.$arg.&quot;,&quot;;
+        } else {
+            $params_replacement .= $arg.&quot;,&quot;;
+        }
+
+    }
+
+    chop($params_replacement);
+
+    $method-&gt;{Params} = $params_replacement;
+
+    return $method;
+
+}
+
+sub declareEnums
+{
+	my( $enum, $specifier ) = @_;
+
+	$enum-&gt;{Access} =~ /([^_]*)(.*)?\s*/;
+
+	if( $enum-&gt;{NodeType} eq &quot;/* enum&quot; &amp;&amp; $enum-&gt;{Access} eq $specifier) {
+
+        my $enum_declaration = &quot;enum &quot;.$enum-&gt;{astNodeName}.&quot; {&quot;;   # return value
+
+		my @enums = split(&quot;,&quot;, $enum-&gt;{Params});
+		my $enumCount = 0;
+
+		if($enum-&gt;{astNodeName} ne &quot; &quot;) {
+
+			foreach my $enum_ ( @enums ) {
+				$enum_ =~ s/\s//g;
+				$enum_ =~ s/::/./g;
+				if($#enums == $enumCount){
+
+					if ( $enum_ =~ /(.*)=(.*)/ ) {
+						$enum_declaration .= &quot;\n\t\t\t$1 = $2&quot;;
+					} else {
+						$enum_declaration .= &quot;\n\t\t\t&quot;.$enum_.&quot; = $enumCount&quot;;
+					}
+
+				} else {
+
+					if ( $enum_ =~ /(.*)=(.*)/ ) {
+						$enum_declaration .= &quot;\n\t\t\t$1 = $2,&quot;;
+					} else {
+						$enum_declaration .= &quot;\n\t\t\t&quot;.$enum_.&quot; = $enumCount,&quot;;
+					}
+
+				}
+#                my @constant = split(/=/,$enum_);
+# what to skip?
+                    if(!(
+                            $classname =~ /QContextMenuEvent/
+                        ||  $classname =~ /QInputMethodEvent/
+                        ||  $classname =~ /QPainter/
+                        ||  $classname =~ /QTabletEvent/
+                    )){
+                        print AG_QT_MINIT &quot;\t  REGISTER_LONG_CONSTANT(\&quot;&quot;,uc($classname),&quot;_&quot;,uc($enum-&gt;{astNodeName}),&quot;_&quot;,uc($constant[0]),&quot;\&quot;, &quot;,$classname,&quot;::&quot;,$constant[0],&quot;, CONST_CS | CONST_PERSISTENT);\n&quot;;
+                        $enumCount++;
+                    }
+			}
+
+			$enum_declaration .= &quot;\n\t\t};*/\n&quot;;
+
+            return $enum_declaration;
+		}
+	}
+
+}
+
+#   remove generic syntax
+#   QList&lt;Attribute&gt; =&gt; QList
+sub removeGeneric
+{
+    my($myarg) = @_;
+    $myarg =~ s/&lt;.*&gt;//;
+    return $myarg;
+}
+
+sub generateInheritanceList
+{
+
+    print INHERITANCE &quot;\n\n#include \&quot;php_qt.h\&quot;\nbool inherits(zend_class_entry* ace, uint objectId, int recursion){&quot;;
+
+    # generate list of Id's
+    my $classId;
+	Iter::LocalCompounds( $global_rootnode, sub {
+        $class = shift;
+        $classes{ $class-&gt;{astNodeName} } = ++$classId;
+    });
+
+    $classId = 0;   # reset
+
+    # write code
+	Iter::LocalCompounds( $global_rootnode, sub {
+
+        $class = shift;
+        $classId++;
+
+        # ask for all ancestors
+        @c = superclass_list($class);
+
+        print INHERITANCE &quot;\n\n/// &quot;.$class-&gt;{astNodeName}.&quot;, ID: &quot;.$classId.&quot; \n&quot;;
+        print INHERITANCE &quot;if(ace == &quot;.$class-&gt;{astNodeName}.&quot;_ce_ptr){ switch(objectId){&quot;;
+        print INHERITANCE &quot;case &quot;.$classId.&quot;: //&quot;.$class-&gt;{astNodeName}.&quot;\nreturn true;&quot;;
+
+        # walk through relevant ancestors
+        foreach my $a (@c){
+            next if $a-&gt;{astNodeName} eq &quot;&quot;;
+            print INHERITANCE &quot;case &quot;.%classes-&gt;{ $a-&gt;{astNodeName} }.&quot;: //&quot;.$a-&gt;{astNodeName}.&quot;\nreturn true;&quot;
+        }
+
+        print INHERITANCE &quot;default: return false;&quot;;
+        print INHERITANCE &quot;}}&quot;;
+
+    } );
+
+    print INHERITANCE &quot;\n// final: \nif(recursion == 10) {return false;} inherits(ace-&gt;parent, objectId, recursion++);}\n&quot;;
+
+}
+
+# helper function
+sub superclass_list($)
+{
+    my $classNode = shift;
+    my @super;
+    Iter::Ancestors( $classNode, $global_rootnode, undef, undef, sub {
+                        push @super, @_[0];
+                        push @super, superclass_list( @_[0] );
+                     }, undef );
+    return @super;
+}
+
+#
+#   returns 1 if enum
+#
+sub isEnum
+{
+    my ($name) = @_;
+
+    foreach $enum (@enums){
+        if($name eq $enum-&gt;{astNodeName}){
+            return 1;
+        }
+    }
+    return 0;
+}
+
+# returns 1 if moc is needed
+
+sub hasMetaObject
+{
+    foreach my $key (keys %methods)
+    {
+        $method = %methods-&gt;{$key};
+        if($method-&gt;{astNodeName} eq &quot;metaObject&quot;){
+            return 1;
+        }
+    }
+    return 0;
+}
+
+#
+# returns 1 if class is abstract
+# abstract classes cannot be instanciated
+
+sub isAbstract
+{
+    my ($className) = @_;
+
+    if($className eq &quot;&quot;) {return 0;}
+
+    my $iter_class = kdocAstUtil::findRef( $global_rootnode, $className, sub{});
+
+    if($iter_class-&gt;{Pure} == 1){
+        return 1;
+    } else {
+        return 0;
+    }
+
+}
+
+sub isChar
+{
+
+    my ($arg) = @_;
+
+    my @arg_ = split(/ /,$arg);
+
+    foreach $chunk (@arg_){
+        return 1 if($chunk eq &quot;char&quot;);
+    }
+
+    return 0;
+
+}
+
+sub debug
+{
+    my ($string) = @_;
+
+    print CLASS &quot;/// DEBUG:&quot;.$string.&quot;.\n&quot;;
+
+}
+
+# 3     important hints
+# 4     informations for later
+
+sub report
+{
+    my ($string, $level) = @_;
+
+    print &quot;REPORT &quot;.$classname.&quot;: &quot;.$string.&quot;.\n&quot; if $level &lt; 5;
+
+}
+
 1;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000094.html">[Php-qt-svn] r250 - trunk/qt
</A></li>
	<LI>Next message: <A HREF="000096.html">[Php-qt-svn] r252 - trunk/qt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#95">[ date ]</a>
              <a href="thread.html#95">[ thread ]</a>
              <a href="subject.html#95">[ subject ]</a>
              <a href="author.html#95">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/php-qt-svn">More information about the Php-qt-svn
mailing list</a><br>
</body></html>
