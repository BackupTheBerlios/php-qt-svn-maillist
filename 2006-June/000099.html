<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Php-qt-svn] r254 - in trunk/qt: . classes
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/php-qt-svn/2006-June/index.html" >
   <LINK REL="made" HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r254%20-%20in%20trunk/qt%3A%20.%20classes&In-Reply-To=%3C200606062046.k56KkJjU030684%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000097.html">
   <LINK REL="Next"  HREF="000098.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Php-qt-svn] r254 - in trunk/qt: . classes</H1>
    <B>tm243 at BerliOS</B> 
    <A HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r254%20-%20in%20trunk/qt%3A%20.%20classes&In-Reply-To=%3C200606062046.k56KkJjU030684%40sheep.berlios.de%3E"
       TITLE="[Php-qt-svn] r254 - in trunk/qt: . classes">tm243 at berlios.de
       </A><BR>
    <I>Tue Jun  6 22:46:19 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000097.html">[Php-qt-svn] r253 - trunk/qt/text_related
</A></li>
        <LI>Next message: <A HREF="000098.html">[Php-qt-svn] r255 - in trunk: tests tutorials/calculator tutorials/t1 tutorials/t2 tutorials/t3 tutorials/t4 tutorials/t5 tutorials/t6 tutorials/t7
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#99">[ date ]</a>
              <a href="thread.html#99">[ thread ]</a>
              <a href="subject.html#99">[ subject ]</a>
              <a href="author.html#99">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tm243
Date: 2006-06-06 22:44:55 +0200 (Tue, 06 Jun 2006)
New Revision: 254

Modified:
   trunk/qt/ag_extern_zend_class_entry.inc
   trunk/qt/ag_php_qt_cpp.inc
   trunk/qt/ag_zend_class_entry.inc
   trunk/qt/ag_zend_php_qt.inc
   trunk/qt/classes/qabstractbutton.cpp
   trunk/qt/classes/qabstractslider.cpp
   trunk/qt/classes/qactionevent.cpp
   trunk/qt/classes/qapplication.cpp
   trunk/qt/classes/qboxlayout.cpp
   trunk/qt/classes/qchar.cpp
   trunk/qt/classes/qcharref.cpp
   trunk/qt/classes/qchildevent.cpp
   trunk/qt/classes/qclipboardevent.cpp
   trunk/qt/classes/qcloseevent.cpp
   trunk/qt/classes/qcontextmenuevent.cpp
   trunk/qt/classes/qcoreapplication.cpp
   trunk/qt/classes/qdate.cpp
   trunk/qt/classes/qdatetime.cpp
   trunk/qt/classes/qdialog.cpp
   trunk/qt/classes/qdragenterevent.cpp
   trunk/qt/classes/qdragleaveevent.cpp
   trunk/qt/classes/qdragmoveevent.cpp
   trunk/qt/classes/qdragresponseevent.cpp
   trunk/qt/classes/qdropevent.cpp
   trunk/qt/classes/qfileopenevent.cpp
   trunk/qt/classes/qfocusevent.cpp
   trunk/qt/classes/qfont.cpp
   trunk/qt/classes/qframe.cpp
   trunk/qt/classes/qgridlayout.cpp
   trunk/qt/classes/qhboxlayout.cpp
   trunk/qt/classes/qhelpevent.cpp
   trunk/qt/classes/qhideevent.cpp
   trunk/qt/classes/qhoverevent.cpp
   trunk/qt/classes/qicondragevent.cpp
   trunk/qt/classes/qinputevent.cpp
   trunk/qt/classes/qinputmethodevent.cpp
   trunk/qt/classes/qinputmethodevent__attribute.cpp
   trunk/qt/classes/qinternal.cpp
   trunk/qt/classes/qkeyevent.cpp
   trunk/qt/classes/qlabel.cpp
   trunk/qt/classes/qlatin1char.cpp
   trunk/qt/classes/qlatin1string.cpp
   trunk/qt/classes/qlayout.cpp
   trunk/qt/classes/qlayoutitem.cpp
   trunk/qt/classes/qlcdnumber.cpp
   trunk/qt/classes/qlineedit.cpp
   trunk/qt/classes/qmouseevent.cpp
   trunk/qt/classes/qmoveevent.cpp
   trunk/qt/classes/qobject.cpp
   trunk/qt/classes/qobjectdata.cpp
   trunk/qt/classes/qobjectuserdata.cpp
   trunk/qt/classes/qpaintdevice.cpp
   trunk/qt/classes/qpainter.cpp
   trunk/qt/classes/qpaintevent.cpp
   trunk/qt/classes/qpushbutton.cpp
   trunk/qt/classes/qresizeevent.cpp
   trunk/qt/classes/qshortcutevent.cpp
   trunk/qt/classes/qshowevent.cpp
   trunk/qt/classes/qslider.cpp
   trunk/qt/classes/qspaceritem.cpp
   trunk/qt/classes/qstatustipevent.cpp
   trunk/qt/classes/qstring.cpp
   trunk/qt/classes/qt.cpp
   trunk/qt/classes/qtabletevent.cpp
   trunk/qt/classes/qtime.cpp
   trunk/qt/classes/qtimer.cpp
   trunk/qt/classes/qtimerevent.cpp
   trunk/qt/classes/qtoolbarchangeevent.cpp
   trunk/qt/classes/qtoolbutton.cpp
   trunk/qt/classes/qvboxlayout.cpp
   trunk/qt/classes/qwhatsthisclickedevent.cpp
   trunk/qt/classes/qwheelevent.cpp
   trunk/qt/classes/qwidget.cpp
   trunk/qt/classes/qwidgetdata.cpp
   trunk/qt/classes/qwidgetitem.cpp
   trunk/qt/classes/qwindowstatechangeevent.cpp
Log:
classes reimplemented with improved kalyptus script.

Modified: trunk/qt/ag_extern_zend_class_entry.inc
===================================================================
--- trunk/qt/ag_extern_zend_class_entry.inc	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/ag_extern_zend_class_entry.inc	2006-06-06 20:44:55 UTC (rev 254)
@@ -64,6 +64,10 @@
 void 	_register_QInputEvent();
 extern zend_class_entry *QInputMethodEvent_ce_ptr;
 void 	_register_QInputMethodEvent();
+extern zend_class_entry *Attribute_ce_ptr;
+void 	_register_Attribute();
+extern zend_class_entry *QInternal_ce_ptr;
+void 	_register_QInternal();
 extern zend_class_entry *QKeyEvent_ce_ptr;
 void 	_register_QKeyEvent();
 extern zend_class_entry *QLCDNumber_ce_ptr;
@@ -84,6 +88,8 @@
 void 	_register_QMouseEvent();
 extern zend_class_entry *QMoveEvent_ce_ptr;
 void 	_register_QMoveEvent();
+extern zend_class_entry *QObject_ce_ptr;
+void 	_register_QObject();
 extern zend_class_entry *QObjectData_ce_ptr;
 void 	_register_QObjectData();
 extern zend_class_entry *QObjectUserData_ce_ptr;
@@ -110,6 +116,10 @@
 void 	_register_QStatusTipEvent();
 extern zend_class_entry *QString_ce_ptr;
 void 	_register_QString();
+extern zend_class_entry *Data_ce_ptr;
+void 	_register_Data();
+extern zend_class_entry *Null_ce_ptr;
+void 	_register_Null();
 extern zend_class_entry *QTabletEvent_ce_ptr;
 void 	_register_QTabletEvent();
 extern zend_class_entry *QTime_ce_ptr;
@@ -136,3 +146,5 @@
 void 	_register_QWidgetItem();
 extern zend_class_entry *QWindowStateChangeEvent_ce_ptr;
 void 	_register_QWindowStateChangeEvent();
+extern zend_class_entry *Qt_ce_ptr;
+void 	_register_Qt();

Modified: trunk/qt/ag_php_qt_cpp.inc
===================================================================
--- trunk/qt/ag_php_qt_cpp.inc	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/ag_php_qt_cpp.inc	2006-06-06 20:44:55 UTC (rev 254)
@@ -16,7 +16,6 @@
 	ZEND_ME(QAbstractButton,animateClick,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractButton,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QAbstractButton,autoRepeat,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QAbstractButton,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractButton,group,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractButton,setText,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractButton,text,NULL,ZEND_ACC_PUBLIC)
@@ -58,7 +57,6 @@
 	ZEND_ME(QAbstractSlider,orientation,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractSlider,setValue,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractSlider,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QAbstractSlider,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractSlider,invertedControls,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractSlider,setSingleStep,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QAbstractSlider,isSliderDown,NULL,ZEND_ACC_PUBLIC)
@@ -119,7 +117,6 @@
 	ZEND_ME(QCoreApplication,translate,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QCoreApplication,applicationDirPath,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QCoreApplication,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QCoreApplication,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QCoreApplication,argc,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QCoreApplication,quit,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QCoreApplication, __construct,NULL,ZEND_ACC_PUBLIC)
@@ -167,7 +164,6 @@
 	ZEND_ME(QApplication,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QApplication,colorSpec,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QApplication,quitOnLastWindowClosed,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QApplication,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QApplication,wheelScrollLines,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QApplication,mouseButtons,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QApplication,topLevelWidgets,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
@@ -239,7 +235,6 @@
 	ZEND_ME(QBoxLayout,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QBoxLayout,itemAt,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QBoxLayout,direction,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QBoxLayout,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QBoxLayout,minimumSize,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QBoxLayout,sizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QBoxLayout,heightForWidth,NULL,ZEND_ACC_PUBLIC)
@@ -508,7 +503,6 @@
 	ZEND_ME(QDialog,orientation,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QDialog, __construct,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QDialog,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QDialog,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QDialog,sizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QDialog,minimumSizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QDialog,extension,NULL,ZEND_ACC_PUBLIC)
@@ -736,7 +730,6 @@
 	ZEND_ME(QFrame, __construct,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QFrame,midLineWidth,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QFrame,frameShadow,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QFrame,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QFrame,frameShape,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QFrame,setFrameShape,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QFrame,sizeHint,NULL,ZEND_ACC_PUBLIC)
@@ -779,7 +772,6 @@
 	ZEND_ME(QGridLayout,takeAt,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QGridLayout,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QGridLayout,itemAt,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QGridLayout,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QGridLayout,minimumSize,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QGridLayout,sizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QGridLayout,setColumnMinimumWidth,NULL,ZEND_ACC_PUBLIC)
@@ -811,7 +803,6 @@
 static zend_function_entry QHBoxLayout_methods[] = {
 	ZEND_ME(QHBoxLayout,tr,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QHBoxLayout,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QHBoxLayout,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QHBoxLayout, __construct,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QHBoxLayout,trUtf8,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 
@@ -946,7 +937,6 @@
 	ZEND_ME(QLCDNumber,display,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLCDNumber,setSegmentStyle,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLCDNumber,setHexMode,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QLCDNumber,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLCDNumber,setSmallDecimalPoint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLCDNumber,sizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLCDNumber,value,NULL,ZEND_ACC_PUBLIC)
@@ -990,7 +980,6 @@
 	ZEND_ME(QLabel,wordWrap,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLabel,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QLabel,setTextFormat,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QLabel,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLabel,setText,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLabel,text,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLabel,alignment,NULL,ZEND_ACC_PUBLIC)
@@ -1064,7 +1053,6 @@
 	ZEND_ME(QLayout,addWidget,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLayout,removeItem,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLayout,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QLayout,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLayout,totalMinimumSize,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLayout,minimumSize,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLayout,setSpacing,NULL,ZEND_ACC_PUBLIC)
@@ -1124,7 +1112,6 @@
 	ZEND_ME(QLineEdit,setAlignment,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLineEdit, __construct,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLineEdit,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QLineEdit,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLineEdit,inputMethodQuery,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLineEdit,text,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QLineEdit,minimumSizeHint,NULL,ZEND_ACC_PUBLIC)
@@ -1374,7 +1361,6 @@
 	ZEND_ME(QPushButton,showMenu,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QPushButton,setFlat,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QPushButton,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QPushButton,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QPushButton,isDefault,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QPushButton,setAutoDefault,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QPushButton,sizeHint,NULL,ZEND_ACC_PUBLIC)
@@ -1444,7 +1430,6 @@
 static zend_function_entry QSlider_methods[] = {
 	ZEND_ME(QSlider,tr,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QSlider,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QSlider,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QSlider, __construct,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QSlider,minimumSizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QSlider,sizeHint,NULL,ZEND_ACC_PUBLIC)
@@ -1660,7 +1645,6 @@
 	ZEND_ME(QTimer,tr,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QTimer,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QTimer,setInterval,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QTimer,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QTimer,timerId,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QTimer,singleShot,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QTimer,stop,NULL,ZEND_ACC_PUBLIC)
@@ -1720,7 +1704,6 @@
 	ZEND_ME(QToolButton,arrowType,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QToolButton,setDefaultAction,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QToolButton,popupMode,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QToolButton,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QToolButton,minimumSizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QToolButton,sizeHint,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QToolButton, __construct,NULL,ZEND_ACC_PUBLIC)
@@ -1748,7 +1731,6 @@
 static zend_function_entry QVBoxLayout_methods[] = {
 	ZEND_ME(QVBoxLayout,tr,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QVBoxLayout,staticMetaObject,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
-	ZEND_ME(QVBoxLayout,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QVBoxLayout,trUtf8,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
 	ZEND_ME(QVBoxLayout, __construct,NULL,ZEND_ACC_PUBLIC)
 
@@ -1839,7 +1821,6 @@
 	ZEND_ME(QWidget,grabShortcut,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QWidget,releaseKeyboard,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QWidget,setAccessibleDescription,NULL,ZEND_ACC_PUBLIC)
-	ZEND_ME(QWidget,qObject,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QWidget,maximumWidth,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QWidget,setWindowOpacity,NULL,ZEND_ACC_PUBLIC)
 	ZEND_ME(QWidget,isTopLevel,NULL,ZEND_ACC_PUBLIC)

Modified: trunk/qt/ag_zend_class_entry.inc
===================================================================
--- trunk/qt/ag_zend_class_entry.inc	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/ag_zend_class_entry.inc	2006-06-06 20:44:55 UTC (rev 254)
@@ -31,6 +31,8 @@
 zend_class_entry *QIconDragEvent_ce_ptr;
 zend_class_entry *QInputEvent_ce_ptr;
 zend_class_entry *QInputMethodEvent_ce_ptr;
+zend_class_entry *Attribute_ce_ptr;
+zend_class_entry *QInternal_ce_ptr;
 zend_class_entry *QKeyEvent_ce_ptr;
 zend_class_entry *QLCDNumber_ce_ptr;
 zend_class_entry *QLabel_ce_ptr;
@@ -41,6 +43,7 @@
 zend_class_entry *QLineEdit_ce_ptr;
 zend_class_entry *QMouseEvent_ce_ptr;
 zend_class_entry *QMoveEvent_ce_ptr;
+zend_class_entry *QObject_ce_ptr;
 zend_class_entry *QObjectData_ce_ptr;
 zend_class_entry *QObjectUserData_ce_ptr;
 zend_class_entry *QPaintDevice_ce_ptr;
@@ -54,6 +57,8 @@
 zend_class_entry *QSpacerItem_ce_ptr;
 zend_class_entry *QStatusTipEvent_ce_ptr;
 zend_class_entry *QString_ce_ptr;
+zend_class_entry *Data_ce_ptr;
+zend_class_entry *Null_ce_ptr;
 zend_class_entry *QTabletEvent_ce_ptr;
 zend_class_entry *QTime_ce_ptr;
 zend_class_entry *QTimer_ce_ptr;
@@ -67,3 +72,4 @@
 zend_class_entry *QWidgetData_ce_ptr;
 zend_class_entry *QWidgetItem_ce_ptr;
 zend_class_entry *QWindowStateChangeEvent_ce_ptr;
+zend_class_entry *Qt_ce_ptr;

Modified: trunk/qt/ag_zend_php_qt.inc
===================================================================
--- trunk/qt/ag_zend_php_qt.inc	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/ag_zend_php_qt.inc	2006-06-06 20:44:55 UTC (rev 254)
@@ -16,7 +16,6 @@
 ZEND_METHOD(QAbstractButton, animateClick);
 ZEND_METHOD(QAbstractButton, staticMetaObject);
 ZEND_METHOD(QAbstractButton, autoRepeat);
-ZEND_METHOD(QAbstractButton, qObject);
 ZEND_METHOD(QAbstractButton, group);
 ZEND_METHOD(QAbstractButton, setText);
 ZEND_METHOD(QAbstractButton, text);
@@ -45,7 +44,6 @@
 ZEND_METHOD(QAbstractSlider, orientation);
 ZEND_METHOD(QAbstractSlider, setValue);
 ZEND_METHOD(QAbstractSlider, staticMetaObject);
-ZEND_METHOD(QAbstractSlider, qObject);
 ZEND_METHOD(QAbstractSlider, invertedControls);
 ZEND_METHOD(QAbstractSlider, setSingleStep);
 ZEND_METHOD(QAbstractSlider, isSliderDown);
@@ -81,7 +79,6 @@
 ZEND_METHOD(QApplication, staticMetaObject);
 ZEND_METHOD(QApplication, colorSpec);
 ZEND_METHOD(QApplication, quitOnLastWindowClosed);
-ZEND_METHOD(QApplication, qObject);
 ZEND_METHOD(QApplication, wheelScrollLines);
 ZEND_METHOD(QApplication, mouseButtons);
 ZEND_METHOD(QApplication, topLevelWidgets);
@@ -140,7 +137,6 @@
 ZEND_METHOD(QBoxLayout, staticMetaObject);
 ZEND_METHOD(QBoxLayout, itemAt);
 ZEND_METHOD(QBoxLayout, direction);
-ZEND_METHOD(QBoxLayout, qObject);
 ZEND_METHOD(QBoxLayout, minimumSize);
 ZEND_METHOD(QBoxLayout, sizeHint);
 ZEND_METHOD(QBoxLayout, heightForWidth);
@@ -253,7 +249,6 @@
 ZEND_METHOD(QCoreApplication, translate);
 ZEND_METHOD(QCoreApplication, applicationDirPath);
 ZEND_METHOD(QCoreApplication, staticMetaObject);
-ZEND_METHOD(QCoreApplication, qObject);
 ZEND_METHOD(QCoreApplication, argc);
 ZEND_METHOD(QCoreApplication, quit);
 ZEND_METHOD(QCoreApplication, __construct);
@@ -328,7 +323,6 @@
 ZEND_METHOD(QDialog, orientation);
 ZEND_METHOD(QDialog, __construct);
 ZEND_METHOD(QDialog, staticMetaObject);
-ZEND_METHOD(QDialog, qObject);
 ZEND_METHOD(QDialog, sizeHint);
 ZEND_METHOD(QDialog, minimumSizeHint);
 ZEND_METHOD(QDialog, extension);
@@ -427,7 +421,6 @@
 ZEND_METHOD(QFrame, __construct);
 ZEND_METHOD(QFrame, midLineWidth);
 ZEND_METHOD(QFrame, frameShadow);
-ZEND_METHOD(QFrame, qObject);
 ZEND_METHOD(QFrame, frameShape);
 ZEND_METHOD(QFrame, setFrameShape);
 ZEND_METHOD(QFrame, sizeHint);
@@ -457,7 +450,6 @@
 ZEND_METHOD(QGridLayout, takeAt);
 ZEND_METHOD(QGridLayout, staticMetaObject);
 ZEND_METHOD(QGridLayout, itemAt);
-ZEND_METHOD(QGridLayout, qObject);
 ZEND_METHOD(QGridLayout, minimumSize);
 ZEND_METHOD(QGridLayout, sizeHint);
 ZEND_METHOD(QGridLayout, setColumnMinimumWidth);
@@ -476,7 +468,6 @@
 ZEND_METHOD(QGridLayout, rowStretch);
 ZEND_METHOD(QHBoxLayout, tr);
 ZEND_METHOD(QHBoxLayout, staticMetaObject);
-ZEND_METHOD(QHBoxLayout, qObject);
 ZEND_METHOD(QHBoxLayout, __construct);
 ZEND_METHOD(QHBoxLayout, trUtf8);
 ZEND_METHOD(QHelpEvent, y);
@@ -507,7 +498,6 @@
 ZEND_METHOD(QLCDNumber, display);
 ZEND_METHOD(QLCDNumber, setSegmentStyle);
 ZEND_METHOD(QLCDNumber, setHexMode);
-ZEND_METHOD(QLCDNumber, qObject);
 ZEND_METHOD(QLCDNumber, setSmallDecimalPoint);
 ZEND_METHOD(QLCDNumber, sizeHint);
 ZEND_METHOD(QLCDNumber, value);
@@ -538,7 +528,6 @@
 ZEND_METHOD(QLabel, wordWrap);
 ZEND_METHOD(QLabel, staticMetaObject);
 ZEND_METHOD(QLabel, setTextFormat);
-ZEND_METHOD(QLabel, qObject);
 ZEND_METHOD(QLabel, setText);
 ZEND_METHOD(QLabel, text);
 ZEND_METHOD(QLabel, alignment);
@@ -575,7 +564,6 @@
 ZEND_METHOD(QLayout, addWidget);
 ZEND_METHOD(QLayout, removeItem);
 ZEND_METHOD(QLayout, staticMetaObject);
-ZEND_METHOD(QLayout, qObject);
 ZEND_METHOD(QLayout, totalMinimumSize);
 ZEND_METHOD(QLayout, minimumSize);
 ZEND_METHOD(QLayout, setSpacing);
@@ -609,7 +597,6 @@
 ZEND_METHOD(QLineEdit, setAlignment);
 ZEND_METHOD(QLineEdit, __construct);
 ZEND_METHOD(QLineEdit, staticMetaObject);
-ZEND_METHOD(QLineEdit, qObject);
 ZEND_METHOD(QLineEdit, inputMethodQuery);
 ZEND_METHOD(QLineEdit, text);
 ZEND_METHOD(QLineEdit, minimumSizeHint);
@@ -759,7 +746,6 @@
 ZEND_METHOD(QPushButton, showMenu);
 ZEND_METHOD(QPushButton, setFlat);
 ZEND_METHOD(QPushButton, staticMetaObject);
-ZEND_METHOD(QPushButton, qObject);
 ZEND_METHOD(QPushButton, isDefault);
 ZEND_METHOD(QPushButton, setAutoDefault);
 ZEND_METHOD(QPushButton, sizeHint);
@@ -777,7 +763,6 @@
 ZEND_METHOD(QShortcutEvent, key);
 ZEND_METHOD(QSlider, tr);
 ZEND_METHOD(QSlider, staticMetaObject);
-ZEND_METHOD(QSlider, qObject);
 ZEND_METHOD(QSlider, __construct);
 ZEND_METHOD(QSlider, minimumSizeHint);
 ZEND_METHOD(QSlider, sizeHint);
@@ -917,7 +902,6 @@
 ZEND_METHOD(QTimer, tr);
 ZEND_METHOD(QTimer, staticMetaObject);
 ZEND_METHOD(QTimer, setInterval);
-ZEND_METHOD(QTimer, qObject);
 ZEND_METHOD(QTimer, timerId);
 ZEND_METHOD(QTimer, singleShot);
 ZEND_METHOD(QTimer, stop);
@@ -938,7 +922,6 @@
 ZEND_METHOD(QToolButton, arrowType);
 ZEND_METHOD(QToolButton, setDefaultAction);
 ZEND_METHOD(QToolButton, popupMode);
-ZEND_METHOD(QToolButton, qObject);
 ZEND_METHOD(QToolButton, minimumSizeHint);
 ZEND_METHOD(QToolButton, sizeHint);
 ZEND_METHOD(QToolButton, __construct);
@@ -953,7 +936,6 @@
 ZEND_METHOD(QToolButton, setArrowType);
 ZEND_METHOD(QVBoxLayout, tr);
 ZEND_METHOD(QVBoxLayout, staticMetaObject);
-ZEND_METHOD(QVBoxLayout, qObject);
 ZEND_METHOD(QVBoxLayout, trUtf8);
 ZEND_METHOD(QVBoxLayout, __construct);
 ZEND_METHOD(QWhatsThisClickedEvent, href);
@@ -1005,7 +987,6 @@
 ZEND_METHOD(QWidget, grabShortcut);
 ZEND_METHOD(QWidget, releaseKeyboard);
 ZEND_METHOD(QWidget, setAccessibleDescription);
-ZEND_METHOD(QWidget, qObject);
 ZEND_METHOD(QWidget, maximumWidth);
 ZEND_METHOD(QWidget, setWindowOpacity);
 ZEND_METHOD(QWidget, isTopLevel);

Modified: trunk/qt/classes/qabstractbutton.cpp
===================================================================
--- trunk/qt/classes/qabstractbutton.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qabstractbutton.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,605 +19,1511 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QAbstractButton.cpp - QAbstractButton PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QAbstractButton&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  tr
- *    flags:    s
+#include &lt;QAbstractButton&gt;
+/// DEBUG:destructor skipped.
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *e
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	pv
  */
-ZEND_METHOD(QAbstractButton, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+#include &lt;QPaintEvent&gt;
+#include &lt;QMetaMethod&gt;
+class QAbstractButton_php_qt:public QAbstractButton
+{
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+public:
+  QAbstractButton_php_qt(zval * zend_ptr, QWidget * parent = 0);
 
 
-				QString return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+  virtual void paintEvent(QPaintEvent * es0);   // pure 
+};
+
+QAbstractButton_php_qt::QAbstractButton_php_qt(zval * zend_ptr, QWidget * parent):QAbstractButton(parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QAbstractButton&quot;,&amp;staticMetaObject));
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setAutoRepeat
- *    flags:    
+// virtual, pure 
+
+void
+QAbstractButton_php_qt::paintEvent(QPaintEvent * es0)
+{
+}
+
+PHP_QT_MOC(QAbstractButton);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QAbstractButton, setAutoRepeat){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractButton, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QAbstractButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setAutoRepeat((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QAbstractButton::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QAbstractButton::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  isDown
- *    flags:    c
+/*!
+ * method mouseMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, isDown){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isDown());
-	}
+
+/*!
+ * method setAutoRepeat
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QAbstractButton, setAutoRepeat)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setAutoRepeat' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setAutoRepeat((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::setAutoRepeat(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  qt_invoke
- *    flags:    v
+/*!
+ * method isDown
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractButton, qt_invoke){
+
+ZEND_METHOD(QAbstractButton, isDown)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isDown' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isDown());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::isDown(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setAutoExclusive
- *    flags:    
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QAbstractButton, setAutoExclusive){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method setAutoExclusive
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+ZEND_METHOD(QAbstractButton, setAutoExclusive)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setAutoExclusive' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractButton *selfpointer;
 
-
-			obj-&gt;setAutoExclusive((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setAutoExclusive((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::setAutoExclusive(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setIconSize
- *    flags:    l
+/*!
+ * method setIconSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &amp;sizes0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QAbstractButton, setIconSize){
-		/* o public_slots*/
 
-		/* const QSize&amp; size,  */
+ZEND_METHOD(QAbstractButton, setIconSize)
+{
+  ///const QSize &amp;sizes0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setIconSize' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QSize &amp;sizes0,
+        QAbstractButton *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+        }
+        QSize *cpp_arg_0 = static_cast &lt; QSize * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setIconSize((const QSize &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QSize&quot;)) {
-				obj-&gt;setIconSize((const QSize&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::setIconSize(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QAbstractButton, qt_cast){
-}
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  metaObject
- *    flags:    cv
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QAbstractButton, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-				QMetaObject * return_object = (QMetaObject *) obj-&gt;metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setIcon
- *    flags:    
+/*!
+ * method toggled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool checkeds0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QAbstractButton, setIcon){
-		/* o public*/
 
-		/* const QIcon&amp; icon,  */
+/*!
+ * method setIcon
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QIcon &amp;icons0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QAbstractButton, setIcon)
+{
+  ///const QIcon &amp;icons0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QIcon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setIcon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QIcon &amp;icons0,
+        QAbstractButton *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+        }
+        QIcon *cpp_arg_0 = static_cast &lt; QIcon * &gt;(php_qt_fetch(arg_0));
 
-			if(obj_z_0-&gt;inherits(&quot;QIcon&quot;)) {
-				obj-&gt;setIcon((const QIcon&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_VOID(selfpointer-&gt;setIcon((const QIcon &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::setIcon(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method focusOutEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, qt_emit){
+
+/*!
+ * method nextCheckState
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method released
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
+
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *es0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
+ */
+
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
+
+/*!
+ * method autoExclusive
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+ZEND_METHOD(QAbstractButton, autoExclusive)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'autoExclusive' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;autoExclusive());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::autoExclusive(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  autoExclusive
- *    flags:    c
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QAbstractButton, autoExclusive){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;autoExclusive());
-	}
+
+/*!
+ * method toggle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
+
+ZEND_METHOD(QAbstractButton, toggle)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toggle' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;toggle());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::toggle(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method setCheckable
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, className){
+
+ZEND_METHOD(QAbstractButton, setCheckable)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setCheckable' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setCheckable((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::setCheckable(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  toggle
- *    flags:    l
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *es0s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	pv
  */
-ZEND_METHOD(QAbstractButton, toggle){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			obj-&gt;toggle();
-			RETURN_NULL();
-	}
+
+/*!
+ * method setDown
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QAbstractButton, setDown)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setDown' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setDown((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::setDown(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setCheckable
- *    flags:    
+/*!
+ * method shortcut
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QKeySequence
+ * @flags	c
  */
-ZEND_METHOD(QAbstractButton, setCheckable){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractButton, shortcut)
+{
+  ///
+#ifdef PHP_QT_QKeySequence      // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'shortcut' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setCheckable((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QKeySequence *return_object = new QKeySequence;
+
+      *return_object = static_cast &lt; QKeySequence &gt; (selfpointer-&gt;shortcut());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::shortcut(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setDown
- *    flags:    
+/*!
+ * method icon
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QIcon
+ * @flags	c
  */
-ZEND_METHOD(QAbstractButton, setDown){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractButton, icon)
+{
+  ///
+#ifdef PHP_QT_QIcon             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'icon' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setDown((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QIcon *return_object = new QIcon;
+
+      *return_object = static_cast &lt; QIcon &gt; (selfpointer-&gt;icon());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::icon(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  shortcut
- *    flags:    c
+/*!
+ * method setChecked
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QAbstractButton, shortcut){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-				QKeySequence return_object = (QKeySequence) obj-&gt;shortcut();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QAbstractButton, setChecked)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setChecked' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setChecked((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::setChecked(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  icon
- *    flags:    c
+/*!
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, icon){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			obj-&gt;icon();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setChecked
- *    flags:    l
+/*!
+ * method timerEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTimerEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, setChecked){
-		/* l public_slots*/
 
-		/* int ,  */
+/*!
+ * method setShortcut
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QKeySequence &amp;keys0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+ZEND_METHOD(QAbstractButton, setShortcut)
+{
+  ///const QKeySequence &amp;keys0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QKeySequence
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setShortcut' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QKeySequence &amp;keys0,
+        QAbstractButton *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+        }
+        QKeySequence *cpp_arg_0 = static_cast &lt; QKeySequence * &gt;(php_qt_fetch(arg_0));
 
-			obj-&gt;setChecked((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        RETURN_VOID(selfpointer-&gt;setShortcut((const QKeySequence &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::setShortcut(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setShortcut
- *    flags:    
+/*!
+ * method animateClick
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int msec = 100s0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QAbstractButton, setShortcut){
-		/* o public*/
 
-		/* const QKeySequence&amp; key,  */
+ZEND_METHOD(QAbstractButton, animateClick)
+{
+  ///int msec = 100s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'animateClick' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;animateClick());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'animateClick' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int msec = 100s0,
+      QAbstractButton *selfpointer;
 
-
-			if(obj_z_0-&gt;inherits(&quot;QKeySequence&quot;)) {
-				obj-&gt;setShortcut((const QKeySequence&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;animateClick((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::animateClick(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  animateClick
- *    flags:    l
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QAbstractButton, animateClick){
-		/* l public_slots*/
 
-		/* int msec,  */
+ZEND_METHOD(QAbstractButton, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QAbstractButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;animateClick((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QAbstractButton::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method mouseReleaseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, staticMetaObject){
-}
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  autoRepeat
- *    flags:    c
+/*!
+ * method autoRepeat
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractButton, autoRepeat){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;autoRepeat());
-	}
+
+ZEND_METHOD(QAbstractButton, autoRepeat)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'autoRepeat' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;autoRepeat());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::autoRepeat(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method mousePressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, qObject){
-}
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  group
- *    flags:    c
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, group){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-				QButtonGroup * return_object = (QButtonGroup *) obj-&gt;group();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method group
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QButtonGroup *
+ * @flags	c
+ */
+
+ZEND_METHOD(QAbstractButton, group)
+{
+  ///
+#ifdef PHP_QT_QButtonGroup      // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'group' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QButtonGroup * &gt;(selfpointer-&gt;group());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::group(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  setText
- *    flags:    
+/*!
+ * method setText
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;texts0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractButton, setText){
-		/* o public*/
 
-		/* const QString&amp; text,  */
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
+ZEND_METHOD(QAbstractButton, setText)
+{
+  ///const QString &amp;texts0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-			    QAbstractButton *obj = static_cast&lt;QAbstractButton*&gt;(PHP_QT_FETCH());
-			    QObject* obj_z_0 = static_cast&lt;QObject*&gt;(php_qt_fetch(z_0));
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;texts0,
+        QAbstractButton *selfpointer;
 
-		        obj-&gt;setText((const QString&amp;) *obj_z_0);
-			    RETURN_NULL();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			}
-		}
-	}
+        RETURN_VOID(selfpointer-&gt;setText((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::setText(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  text
- *    flags:    c
+/*!
+ * method hitButton
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;poss0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	cv
  */
-ZEND_METHOD(QAbstractButton, text){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-            QString *return_object = new QString;
-				*return_object = (QString) obj-&gt;text();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method text
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
+
+ZEND_METHOD(QAbstractButton, text)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'text' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;text());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::text(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  isChecked
- *    flags:    c
+/*!
+ * method isChecked
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractButton, isChecked){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isChecked());
-	}
+
+ZEND_METHOD(QAbstractButton, isChecked)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isChecked' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isChecked());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::isChecked(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  iconSize
- *    flags:    c
+/*!
+ * method clicked
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool checked = falses0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QAbstractButton, iconSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj-&gt;iconSize();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method keyPressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
+
+/*!
+ * method keyReleaseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
+
+/*!
+ * method focusInEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
+
+/*!
+ * method iconSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
+ */
+
+ZEND_METHOD(QAbstractButton, iconSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'iconSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;iconSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::iconSize(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  isCheckable
- *    flags:    c
+/*!
+ * method pressed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QAbstractButton, isCheckable){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isCheckable());
-	}
+
+/*!
+ * method QAbstractButton
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * parent=0s0
+ * 
+ * overloaded args:
+ * @param	QAbstractButtonPrivate &amp;dd
+ * @param	 QWidget* parent = 0
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
+ */
+
+ZEND_METHOD(QAbstractButton, __construct)
+{
+  ///QWidget * parent=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton_php_qt *selfpointer = new QAbstractButton_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget * parent=0s0,
+      QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QAbstractButton_php_qt *selfpointer = new QAbstractButton_php_qt(getThis(), (QWidget *) cpp_arg_0);
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QAbstractButtonPrivate &amp;dd, QWidget* parent = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAbstractButtonPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QAbstractButtonPrivate &amp;dd,
+        QAbstractButtonPrivate *cpp_arg_0 = static_cast &lt; QAbstractButtonPrivate * &gt;(php_qt_fetch(arg_0));
+        QAbstractButton_php_qt *selfpointer = new QAbstractButton_php_qt(getThis(), (QAbstractButtonPrivate &amp;) * cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QAbstractButtonPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QAbstractButtonPrivate &amp;dd, QWidget* parent = 0,
+        QAbstractButtonPrivate *cpp_arg_0 = static_cast &lt; QAbstractButtonPrivate * &gt;(php_qt_fetch(arg_0));
+        QWidget *cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+        QAbstractButton_php_qt *selfpointer = new QAbstractButton_php_qt(getThis(), (QAbstractButtonPrivate &amp;) * cpp_arg_0, (QWidget *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::QAbstractButton(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  click
- *    flags:    l
+/*!
+ * method isCheckable
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractButton, click){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
-			obj-&gt;click();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QAbstractButton, isCheckable)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isCheckable' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isCheckable());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::isCheckable(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method click
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QAbstractButton, qt_property){
+
+ZEND_METHOD(QAbstractButton, click)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'click' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;click());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::click(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractButton */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QAbstractButton, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QAbstractButton, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QAbstractButton *obj = (QAbstractButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QAbstractButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QAbstractButton::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QAbstractButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QAbstractButton::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractButton::trUtf8(...) &quot;);
 }
 
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-PHP_QT_DESTRUCT(QAbstractButton);
-
+/*!
+ * method checkStateSet
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */

Modified: trunk/qt/classes/qabstractslider.cpp
===================================================================
--- trunk/qt/classes/qabstractslider.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qabstractslider.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,705 +19,1443 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QAbstractSlider.cpp - QAbstractSlider PHP implementation.
- * begin           : Thu Feb 23 16:30:02 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
+
 #include &quot;../php_qt.h&quot;
 
 
 #include &lt;QAbstractSlider&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QAbstractSlider_php_qt:public QAbstractSlider
+{
 
+public:
+  QAbstractSlider_php_qt(zval * zend_ptr, QWidget * parent = 0);
 
-/*		public enumSliderAction:long {
-			SliderAction = 0,
-			SliderAction = 1,
-			SliderAction = 2,
-			SliderAction = 3,
-			SliderAction = 4,
-			SliderAction = 5,
-			SliderAction = 6,
-			SliderAction = 7
-		}
-*/
 
-/*		protected enumSliderChange:long {
-			SliderChange = 0,
-			SliderChange = 1,
-			SliderChange = 2,
-			SliderChange = 3
-		}
-*/
-/*********************************
- *    class     QAbstractSlider
- *    function  tr
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+
+QAbstractSlider_php_qt::QAbstractSlider_php_qt(zval * zend_ptr, QWidget * parent):QAbstractSlider(parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QAbstractSlider&quot;,&amp;staticMetaObject));
+}
+
+PHP_QT_MOC(QAbstractSlider);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QAbstractSlider, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QAbstractSlider, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QAbstractSlider *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QAbstractSlider::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QAbstractSlider::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QAbstractSlider::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setMaximum
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method wheelEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWheelEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, setMaximum){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method rangeChanged
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int mins0
+ * @param	 int maxs1
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+/*!
+ * method setMaximum
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QAbstractSlider, setMaximum)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMaximum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QAbstractSlider *
+        selfpointer;
 
-			obj-&gt;setMaximum((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMaximum((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::setMaximum(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setInvertedAppearance
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    bool
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QAbstractSlider, setInvertedAppearance){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method sliderMoved
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int positions0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+/*!
+ * method setInvertedAppearance
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QAbstractSlider, setInvertedAppearance)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setInvertedAppearance' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractSlider *
+        selfpointer;
 
-			obj-&gt;setInvertedAppearance((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setInvertedAppearance((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::setInvertedAppearance(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  value
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method sliderChange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	SliderChange changes0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QAbstractSlider, value){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;value());
-	}
-}
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setSliderDown
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    bool
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QAbstractSlider, setSliderDown){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+/*!
+ * method value
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QAbstractSlider, value)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'value' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
-			obj-&gt;setSliderDown((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;value());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::value(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  triggerAction
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    SliderAction action
+/*!
+ * method setSliderDown
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, triggerAction){
-		/* l public*/
 
-		/* int action,  */
+ZEND_METHOD(QAbstractSlider, setSliderDown)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setSliderDown' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractSlider *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setSliderDown((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::setSliderDown(...) &quot;);
+}
 
+/*!
+ * method triggerAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	SliderAction actions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj-&gt;triggerAction((QAbstractSlider::SliderAction) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+ZEND_METHOD(QAbstractSlider, triggerAction)
+{
+// notice: unknown argument SliderAction actions0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::triggerAction(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setRange
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int min, int max
+/*!
+ * method valueChanged
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int values0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QAbstractSlider, setRange){
-		/* ll public*/
 
-		/* int min, int max,  */
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+/*!
+ * method singleStep
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QAbstractSlider, singleStep)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'singleStep' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
-			obj-&gt;setRange((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;singleStep());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::singleStep(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  singleStep
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method setRange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int mins0
+ * @param	 int maxs1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, singleStep){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;singleStep());
-	}
+
+ZEND_METHOD(QAbstractSlider, setRange)
+{
+  ///int mins0, int maxs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setRange' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int mins0, int maxs1,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setRange((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::setRange(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  repeatAction
- *    flags:    c
- *    access:    protected
- *    return:    SliderAction
- *    params:    
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-// method repeatAction is protected, skipped.
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setTracking
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    bool enable
+/*!
+ * method repeatAction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	SliderAction
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, setTracking){
-		/* l public*/
 
-		/* int enable,  */
+/*!
+ * method setTracking
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enables0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+ZEND_METHOD(QAbstractSlider, setTracking)
+{
+  ///bool enables0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setTracking' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool enables0,
+      QAbstractSlider *
+        selfpointer;
 
-
-			obj-&gt;setTracking((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setTracking((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::setTracking(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  QAbstractSlider
- *    flags:    t
- *    access:    public
- *    return:    
- *    params:    QWidget *parent=0
+/*!
+ * method QAbstractSlider
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parent=0s0
+ * 
+ * overloaded args:
+ * @param	QAbstractSliderPrivate &amp;dd
+ * @param	 QWidget *parent=0
+ * 
+ * overloaded args:
+ * @param	const QAbstractSlider &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QAbstractSlider, __construct){
-//qt_QWidget*
-		/* o public*/
 
-		/* qt_QWidget* parent,  */
+ZEND_METHOD(QAbstractSlider, __construct)
+{
+  ///QWidget *parent=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider_php_qt *
+        selfpointer = new QAbstractSlider_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget *parent=0s0,
+      QWidget *
+        cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QAbstractSlider_php_qt *
+        selfpointer = new QAbstractSlider_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QAbstractSliderPrivate &amp;dd, QWidget *parent=0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAbstractSliderPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QAbstractSliderPrivate &amp;dd,
+        QAbstractSliderPrivate *
+          cpp_arg_0 = static_cast &lt; QAbstractSliderPrivate * &gt;(php_qt_fetch(arg_0));
+        QAbstractSlider_php_qt *
+          selfpointer = new QAbstractSlider_php_qt(getThis(), (QAbstractSliderPrivate &amp;) * cpp_arg_0);
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				QAbstractSlider *QAbstractSlider_ptr = new QAbstractSlider((QWidget*) obj_z_0);
-				PHP_QT_REGISTER(QAbstractSlider_ptr);
-				RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QAbstractSliderPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QAbstractSliderPrivate &amp;dd, QWidget *parent=0,
+        QAbstractSliderPrivate *
+          cpp_arg_0 = static_cast &lt; QAbstractSliderPrivate * &gt;(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+        QAbstractSlider_php_qt *
+          selfpointer = new QAbstractSlider_php_qt(getThis(), (QAbstractSliderPrivate &amp;) * cpp_arg_0, (QWidget *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QAbstractSlider &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAbstractSlider
+      if (inherits(Z_OBJCE_P(arg_0), 2)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QAbstractSlider::__construct(...) cannot be called with 'const QAbstractSlider &amp;,'.&quot;);
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::QAbstractSlider(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  sliderPosition
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method sliderPosition
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, sliderPosition){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;sliderPosition());
-	}
+
+ZEND_METHOD(QAbstractSlider, sliderPosition)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sliderPosition' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;sliderPosition());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::sliderPosition(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setMinimum
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method invertedAppearance
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, setMinimum){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractSlider, invertedAppearance)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'invertedAppearance' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;invertedAppearance());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::invertedAppearance(...) &quot;);
+}
 
+/*!
+ * method setSliderPosition
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj-&gt;setMinimum((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+ZEND_METHOD(QAbstractSlider, setSliderPosition)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setSliderPosition' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setSliderPosition((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::setSliderPosition(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  minimum
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method setPageStep
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, minimum){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;minimum());
-	}
+
+ZEND_METHOD(QAbstractSlider, setPageStep)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setPageStep' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setPageStep((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::setPageStep(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setPageStep
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method minimum
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, setPageStep){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractSlider, minimum)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;minimum());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::minimum(...) &quot;);
+}
 
+/*!
+ * method setMinimum
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj-&gt;setPageStep((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+ZEND_METHOD(QAbstractSlider, setMinimum)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMinimum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMinimum((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::setMinimum(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setSliderPosition
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, setSliderPosition){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method maximum
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+ZEND_METHOD(QAbstractSlider, maximum)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'maximum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
-
-			obj-&gt;setSliderPosition((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;maximum());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::maximum(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  invertedAppearance
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
+/*!
+ * method timerEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTimerEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, invertedAppearance){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;invertedAppearance());
-	}
-}
 
-/*********************************
- *    class     QAbstractSlider
- *    function  maximum
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method setValue
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QAbstractSlider, maximum){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;maximum());
-	}
+
+ZEND_METHOD(QAbstractSlider, setValue)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setValue' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setValue((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::setValue(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  orientation
- *    flags:    c
- *    access:    public
- *    return:    Qt::Orientation
- *    params:    
+/*!
+ * method orientation
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientation
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, orientation){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;orientation());
-	}
+
+ZEND_METHOD(QAbstractSlider, orientation)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'orientation' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;orientation());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::orientation(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setValue
- *    flags:    l
- *    access:    public_slots
- *    return:    void
- *    params:    int
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QAbstractSlider, setValue){
-		/* l public_slots*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractSlider, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj-&gt;setValue((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QAbstractSlider::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  staticMetaObject
- *    flags:    s
- *    access:    public
- *    return:    QMetaObject*
- *    params:    
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, staticMetaObject){
-}
 
-/*********************************
- *    class     QAbstractSlider
- *    function  qObject
- *    flags:    
- *    access:    public
- *    return:    QObject*
- *    params:    
+/*!
+ * method setRepeatAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	SliderAction actions0
+ * @param	 int thresholdTime = 500s1
+ * @param	 int repeatTime = 50s2
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, qObject){
-}
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setRepeatAction
- *    flags:    
- *    access:    protected
- *    return:    void
- *    params:    SliderAction action, int thresholdTime = 500, int repeatTime = 50
+/*!
+ * method invertedControls
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-// method setRepeatAction is protected, skipped.
 
-/*********************************
- *    class     QAbstractSlider
- *    function  invertedControls
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
- */
-ZEND_METHOD(QAbstractSlider, invertedControls){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;invertedControls());
-	}
+ZEND_METHOD(QAbstractSlider, invertedControls)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'invertedControls' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;invertedControls());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::invertedControls(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setSingleStep
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method isSliderDown
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, setSingleStep){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractSlider, isSliderDown)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isSliderDown' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isSliderDown());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::isSliderDown(...) &quot;);
+}
 
+/*!
+ * method setSingleStep
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj-&gt;setSingleStep((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+ZEND_METHOD(QAbstractSlider, setSingleStep)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setSingleStep' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setSingleStep((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::setSingleStep(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  isSliderDown
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
+/*!
+ * method keyPressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *evs0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QAbstractSlider, isSliderDown){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isSliderDown());
-	}
-}
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setOrientation
- *    flags:    l
- *    access:    public_slots
- *    return:    void
- *    params:    Qt::Orientation
+/*!
+ * method setOrientation
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Orientation Qt::Orientations0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QAbstractSlider, setOrientation){
-		/* l public_slots*/
 
-		/* int ,  */
+ZEND_METHOD(QAbstractSlider, setOrientation)
+{
+  ///Qt::Orientation Qt::Orientations0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setOrientation' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::Orientation Qt::Orientations0,
+      QAbstractSlider *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setOrientation((Qt::Orientation) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::setOrientation(...) &quot;);
+}
 
+/*!
+ * method pageStep
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-			obj-&gt;setOrientation((Qt::Orientation) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+ZEND_METHOD(QAbstractSlider, pageStep)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pageStep' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;pageStep());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::pageStep(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  pageStep
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method sliderPressed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QAbstractSlider, pageStep){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;pageStep());
-	}
-}
 
-/*********************************
- *    class     QAbstractSlider
- *    function  hasTracking
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
+/*!
+ * method hasTracking
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QAbstractSlider, hasTracking){
-	if (ZEND_NUM_ARGS() == 0){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;hasTracking());
-	}
+
+ZEND_METHOD(QAbstractSlider, hasTracking)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hasTracking' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;hasTracking());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::hasTracking(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  setInvertedControls
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    bool
+/*!
+ * method sliderReleased
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QAbstractSlider, setInvertedControls){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method setInvertedControls
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+ZEND_METHOD(QAbstractSlider, setInvertedControls)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setInvertedControls' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QAbstractSlider *
+        selfpointer;
 
-
-			obj-&gt;setInvertedControls((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setInvertedControls((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::setInvertedControls(...) &quot;);
 }
 
-/*********************************
- *    class     QAbstractSlider
- *    function  trUtf8
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QAbstractSlider, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QAbstractSlider, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QAbstractSlider *obj = (QAbstractSlider*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QAbstractSlider *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QAbstractSlider::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QAbstractSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QAbstractSlider::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QAbstractSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QAbstractSlider * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QAbstractSlider::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QAbstractSlider::trUtf8(...) &quot;);
 }
 
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-PHP_QT_DESTRUCT(QAbstractSlider);
-
+/*!
+ * method actionTriggered
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int actions0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */

Modified: trunk/qt/classes/qactionevent.cpp
===================================================================
--- trunk/qt/classes/qactionevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qactionevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,55 +19,180 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QActionEvent.cpp - QActionEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QActionEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QActionEvent */
-/*
- *    function  action
- *    flags:    c
+#include &lt;QActionEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QActionEvent_php_qt:public QActionEvent
+{
+
+public:
+  QActionEvent_php_qt(zval * zend_ptr, int types0, QAction * actions1, QAction * before = 0);
+
+
+  zval *zend_ptr;
+};
+QActionEvent_php_qt::QActionEvent_php_qt(zval * zend_ptr, int types0, QAction * actions1, QAction * before):
+QActionEvent(types0, actions1, before)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QActionEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int types0s0
+ * @param	QAction *actions1s1
+ * @param	 QAction *before = 0s2
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QActionEvent, action){
-	if (ZEND_NUM_ARGS() == 0){
-			QActionEvent *obj = (QActionEvent*) PHP_QT_FETCH();
-				QAction * return_object = (QAction *) obj-&gt;action();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QActionEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QActionEvent, __construct)
+{
+  ///int types0s0,QAction *actions1s1, QAction *before = 0s2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int types0s0,QAction *actions1s1,
+        QAction *cpp_arg_1 = static_cast &lt; QAction * &gt;(php_qt_fetch(arg_1));
+        QActionEvent_php_qt *selfpointer = new QActionEvent_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (QAction *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int types0s0,QAction *actions1s1, QAction *before = 0s2,
+        QAction *cpp_arg_1 = static_cast &lt; QAction * &gt;(php_qt_fetch(arg_1));
+        QAction *cpp_arg_2 = static_cast &lt; QAction * &gt;(php_qt_fetch(arg_2));
+        QActionEvent_php_qt *selfpointer = new QActionEvent_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (QAction *) cpp_arg_1, (QAction *) cpp_arg_2);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QActionEvent::QActionEvent(...) &quot;);
 }
 
-/*********************************
- *    class     QActionEvent */
-/*
- *    function  before
- *    flags:    c
+/*!
+ * method before
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QAction *
+ * @flags	c
  */
-ZEND_METHOD(QActionEvent, before){
-	if (ZEND_NUM_ARGS() == 0){
-			QActionEvent *obj = (QActionEvent*) PHP_QT_FETCH();
-				QAction * return_object = (QAction *) obj-&gt;before();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QActionEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QActionEvent, before)
+{
+  ///
+#ifdef PHP_QT_QAction           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'before' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QActionEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QActionEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QAction * &gt;(selfpointer-&gt;before());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QActionEvent::before(...) &quot;);
 }
 
+/*!
+ * method action
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QAction *
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QActionEvent);
+ZEND_METHOD(QActionEvent, action)
+{
+  ///
+#ifdef PHP_QT_QAction           // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'action' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QActionEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QActionEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QAction * &gt;(selfpointer-&gt;action());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QActionEvent::action(...) &quot;);
+}

Modified: trunk/qt/classes/qapplication.cpp
===================================================================
--- trunk/qt/classes/qapplication.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qapplication.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,12 +19,13 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QApplication.cpp - QApplication PHP implementation.
- * begin           : Thu Feb 23 12:34:50 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
+
 #include &quot;../php_qt.h&quot;
 
 
@@ -33,1496 +33,3181 @@
 #include &lt;QPalette&gt;
 #include &lt;QFontMetrics&gt;
 #include &lt;QIcon&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QApplication_php_qt:public QApplication
+{
 
-int argc__;
-char *argv__[1];
+public:
+  QApplication_php_qt(zval * zend_ptr, int &amp;argcs0, char **argvs1);
+    QApplication_php_qt(zval * zend_ptr, int &amp;argcs0, char **argvs1, bool GUIenableds2);
+    QApplication_php_qt(zval * zend_ptr, int &amp;argcs0, char **argvs1, Type s2);
 
 
-/*		public enumType:long {
-			Type = 0,
-			Type = 1,
-			Type = 2
-		}
-*/
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+QApplication_php_qt::QApplication_php_qt(zval * zend_ptr, int &amp;argcs0, char **argvs1):
+QApplication(argcs0, argvs1)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QApplication&quot;,&amp;staticMetaObject));
+}
+QApplication_php_qt::QApplication_php_qt(zval * zend_ptr, int &amp;argcs0, char **argvs1, bool GUIenableds2):
+QApplication(argcs0, argvs1, GUIenableds2)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QApplication&quot;,&amp;staticMetaObject));
+}
+QApplication_php_qt::QApplication_php_qt(zval * zend_ptr, int &amp;argcs0, char **argvs1, Type s2):
+QApplication(argcs0, argvs1, s2)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QApplication&quot;,&amp;staticMetaObject));
+}
 
-/*		public enumColorSpec:long {
-			NormalColor = 0,
-			CustomColor = 1,
-			ManyColor = 2
-		}
-*/
-/*********************************
- *    class     QApplication
- *    function  sessionKey
- *    flags:    c
+PHP_QT_MOC(QApplication);
+
+/*!
+ * method sessionKey
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QApplication, sessionKey){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;sessionKey();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, sessionKey)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sessionKey' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;sessionKey());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::sessionKey(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  tr
- *    flags:    s
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QApplication, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QApplication, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QApplication::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QApplication::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QApplication::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  clipboard
- *    flags:    s
+/*!
+ * method clipboard
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QClipboard *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, clipboard){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QClipboard ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QClipboard *) obj-&gt;clipboard();
-			} else {
-				*return_object = (QClipboard *) QApplication::clipboard();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, clipboard)
+{
+  ///
+#ifdef PHP_QT_QClipboard        // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QClipboard * &gt;(QApplication::clipboard());
+      } else {
+        le.ptr = static_cast &lt; QClipboard * &gt;(selfpointer-&gt;clipboard());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::clipboard(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  startDragTime
- *    flags:    s
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QApplication, startDragTime){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;startDragTime());
-	}
-}
 
-/*********************************
- *    class     QApplication
- *    function  sessionId
- *    flags:    c
+/*!
+ * method commitData
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QSessionManager &amp; sms0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QApplication, sessionId){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;sessionId();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QApplication
- *    function  isSessionRestored
- *    flags:    c
+/*!
+ * method startDragTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, isSessionRestored){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isSessionRestored());
-	}
+
+ZEND_METHOD(QApplication, startDragTime)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::startDragTime());
+      } else {
+        RETURN_LONG(selfpointer-&gt;startDragTime());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::startDragTime(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setColorSpec
- *    flags:    s
+/*!
+ * method sessionId
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QApplication, setColorSpec){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QApplication, sessionId)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sessionId' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setColorSpec((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;sessionId());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::sessionId(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setStartDragDistance
- *    flags:    s
+/*!
+ * method isSessionRestored
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QApplication, setStartDragDistance){
-		/* l public*/
 
-		/* int l,  */
+ZEND_METHOD(QApplication, isSessionRestored)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isSessionRestored' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isSessionRestored());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::isSessionRestored(...) &quot;);
+}
 
+/*!
+ * method setColorSpec
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-			obj-&gt;setStartDragDistance((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+ZEND_METHOD(QApplication, setColorSpec)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ints0,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setColorSpec((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;setColorSpec((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setColorSpec(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setLayoutDirection
- *    flags:    s
+/*!
+ * method setStartDragDistance
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ls0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setLayoutDirection){
-		/* l public*/
 
-		/* int direction,  */
+ZEND_METHOD(QApplication, setStartDragDistance)
+{
+  ///int ls0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ls0,
+      QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setStartDragDistance((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;setStartDragDistance((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setStartDragDistance(...) &quot;);
+}
 
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
+ */
 
-			obj-&gt;setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+/*!
+ * method setLayoutDirection
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::LayoutDirection directions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
+
+ZEND_METHOD(QApplication, setLayoutDirection)
+{
+  ///Qt::LayoutDirection directions0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try Qt::LayoutDirection directions0,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(arg_0)));
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setLayoutDirection(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  keyboardInputInterval
- *    flags:    s
+/*!
+ * method keyboardInputInterval
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, keyboardInputInterval){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;keyboardInputInterval());
-	}
-}
 
-/*********************************
- *    class     QApplication
- *    function  allWidgets
- *    flags:    s
- */
-ZEND_METHOD(QApplication, allWidgets){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QWidgetList* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidgetList) obj-&gt;allWidgets();
-			} else {
-				*return_object = (QWidgetList) QApplication::allWidgets();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QApplication, keyboardInputInterval)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::keyboardInputInterval());
+      } else {
+        RETURN_LONG(selfpointer-&gt;keyboardInputInterval());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::keyboardInputInterval(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setCursorFlashTime
- *    flags:    s
+/*!
+ * method allWidgets
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidgetList
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setCursorFlashTime){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QApplication, allWidgets)
+{
+  ///
+#ifdef PHP_QT_QWidgetList       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setCursorFlashTime((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QWidgetList *return_object = new QWidgetList;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QWidgetList &gt; (QApplication::allWidgets());
+      } else {
+        *return_object = static_cast &lt; QWidgetList &gt; (selfpointer-&gt;allWidgets());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::allWidgets(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setWheelScrollLines
- *    flags:    s
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QApplication, setWheelScrollLines){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method setCursorFlashTime
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+ZEND_METHOD(QApplication, setCursorFlashTime)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ints0,
+      QApplication *selfpointer;
 
-
-			obj-&gt;setWheelScrollLines((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setCursorFlashTime((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;setCursorFlashTime((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setCursorFlashTime(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setEffectEnabled
- *    flags:    s
+/*!
+ * method setWheelScrollLines
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setEffectEnabled){
-		/* ll public*/
 
-		/* int , int enable,  */
+ZEND_METHOD(QApplication, setWheelScrollLines)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ints0,
+      QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-
-
-			obj-&gt;setEffectEnabled((Qt::UIEffect) Z_LVAL_P(z_0) ,(bool) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setWheelScrollLines((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;setWheelScrollLines((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setWheelScrollLines(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setStyle
- *    flags:    s
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QApplication, setStyle){
-//qt_QStyle*
-		/* o public*/
 
-		/* qt_QStyle* ,  */
+/*!
+ * method setEffectEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::UIEffect Qt::UIEffects0
+ * @param	 bool enable = trues1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QApplication, setEffectEnabled)
+{
+  ///Qt::UIEffect Qt::UIEffects0, bool enable = trues1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try Qt::UIEffect Qt::UIEffects0,
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setEffectEnabled((Qt::UIEffect) Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;setEffectEnabled((Qt::UIEffect) Z_LVAL_P(arg_0)));
+      }
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_BOOL) {
+      /// try Qt::UIEffect Qt::UIEffects0, bool enable = trues1,
+      QApplication *selfpointer;
 
-			if(obj_z_0-&gt;inherits(&quot;QStyle&quot;)) {
-				obj-&gt;setStyle((QStyle*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setEffectEnabled((Qt::UIEffect) Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;setEffectEnabled((Qt::UIEffect) Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setEffectEnabled(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  isRightToLeft
- *    flags:    s
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QApplication, isRightToLeft){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isRightToLeft());
-	}
-}
 
-/*********************************
- *    class     QApplication
- *    function  setDesktopSettingsAware
- *    flags:    s
+/*!
+ * method setStyle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QStyle *s0
+ * 
+ * overloaded args:
+ * @param	const QString&amp;
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setDesktopSettingsAware){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QApplication, setStyle)
+{
+  ///QStyle *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QStyle
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try QStyle *s0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QStyle *cpp_arg_0 = static_cast &lt; QStyle * &gt;(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setStyle((QStyle *) cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setStyle((QStyle *) cpp_arg_0));
+        }
+      }
+#endif
 
-			obj-&gt;setDesktopSettingsAware((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  ///const QString&amp;
+#ifdef PHP_QT_QStyle            // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString&amp;,
+        QApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        if (getThis() == NULL) {
+          le.ptr = static_cast &lt; QStyle * &gt;(QApplication::setStyle((const QString &amp;)*cpp_arg_0));
+        } else {
+          le.ptr = static_cast &lt; QStyle * &gt;(selfpointer-&gt;setStyle((const QString &amp;)*cpp_arg_0));
+        } php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setStyle(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  inputContext
- *    flags:    c
+/*!
+ * method isRightToLeft
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QApplication, inputContext){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QInputContext ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QInputContext *) obj-&gt;inputContext();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, isRightToLeft)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QApplication::isRightToLeft());
+      } else {
+        RETURN_BOOL(selfpointer-&gt;isRightToLeft());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::isRightToLeft(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  palette
- *    flags:    s
+/*!
+ * method setDesktopSettingsAware
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, palette){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QPalette* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QPalette) obj-&gt;palette();
-			} else {
-				*return_object = (QPalette) QApplication::palette();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, setDesktopSettingsAware)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      /// try bool bools0,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setDesktopSettingsAware((bool) Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;setDesktopSettingsAware((bool) Z_LVAL_P(arg_0)));
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setDesktopSettingsAware(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  desktopSettingsAware
- *    flags:    s
+/*!
+ * method palette
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QWidget *
+ * 
+ * overloaded args:
+ * @param	const char *className
+ * 
+ * @access	public
+ * @return	QPalette
+ * @flags	s
  */
-ZEND_METHOD(QApplication, desktopSettingsAware){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;desktopSettingsAware());
-	}
+
+ZEND_METHOD(QApplication, palette)
+{
+  ///
+#ifdef PHP_QT_QPalette          // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QPalette *return_object = new QPalette;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QPalette &gt; (QApplication::palette());
+      } else {
+        *return_object = static_cast &lt; QPalette &gt; (selfpointer-&gt;palette());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const QWidget *
+#ifdef PHP_QT_QPalette          // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        /// try const QWidget *,
+        QApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QPalette *return_object = new QPalette;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QPalette &gt; (QApplication::palette((const QWidget *)cpp_arg_0));
+        } else {
+          *return_object = static_cast &lt; QPalette &gt; (selfpointer-&gt;palette((const QWidget *)cpp_arg_0));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const char *className
+#ifdef PHP_QT_QPalette          // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *className,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QPalette *return_object = new QPalette;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QPalette &gt; (QApplication::palette((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QPalette &gt; (selfpointer-&gt;palette((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::palette(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  fontMetrics
- *    flags:    s
+/*!
+ * method inputContext
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QInputContext *
+ * @flags	c
  */
-ZEND_METHOD(QApplication, fontMetrics){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QFontMetrics* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QFontMetrics) obj-&gt;fontMetrics();
-			} else {
-				*return_object = (QFontMetrics) QApplication::fontMetrics();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, inputContext)
+{
+  ///
+#ifdef PHP_QT_QInputContext     // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'inputContext' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QInputContext * &gt;(selfpointer-&gt;inputContext());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::inputContext(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  desktop
- *    flags:    s
+/*!
+ * method desktopSettingsAware
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QApplication, desktop){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QDesktopWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QDesktopWidget *) obj-&gt;desktop();
-			} else {
-				*return_object = (QDesktopWidget *) QApplication::desktop();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, desktopSettingsAware)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QApplication::desktopSettingsAware());
+      } else {
+        RETURN_BOOL(selfpointer-&gt;desktopSettingsAware());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::desktopSettingsAware(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method fontMetrics
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QFontMetrics
+ * @flags	s
  */
-ZEND_METHOD(QApplication, staticMetaObject){
+
+ZEND_METHOD(QApplication, fontMetrics)
+{
+  ///
+#ifdef PHP_QT_QFontMetrics      // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QFontMetrics *return_object = new QFontMetrics;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QFontMetrics &gt; (QApplication::fontMetrics());
+      } else {
+        *return_object = static_cast &lt; QFontMetrics &gt; (selfpointer-&gt;fontMetrics());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::fontMetrics(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  colorSpec
- *    flags:    s
+/*!
+ * method desktop
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QDesktopWidget *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, colorSpec){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;colorSpec());
-	}
+
+ZEND_METHOD(QApplication, desktop)
+{
+  ///
+#ifdef PHP_QT_QDesktopWidget    // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QDesktopWidget * &gt;(QApplication::desktop());
+      } else {
+        le.ptr = static_cast &lt; QDesktopWidget * &gt;(selfpointer-&gt;desktop());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::desktop(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  quitOnLastWindowClosed
- *    flags:    s
+/*!
+ * method colorSpec
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, quitOnLastWindowClosed){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;quitOnLastWindowClosed());
-	}
+
+ZEND_METHOD(QApplication, colorSpec)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::colorSpec());
+      } else {
+        RETURN_LONG(selfpointer-&gt;colorSpec());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::colorSpec(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  qObject
- *    flags:    
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QApplication, qObject){
+
+ZEND_METHOD(QApplication, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QApplication::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  wheelScrollLines
- *    flags:    s
+/*!
+ * method quitOnLastWindowClosed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QApplication, wheelScrollLines){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;wheelScrollLines());
-	}
+
+ZEND_METHOD(QApplication, quitOnLastWindowClosed)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QApplication::quitOnLastWindowClosed());
+      } else {
+        RETURN_BOOL(selfpointer-&gt;quitOnLastWindowClosed());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::quitOnLastWindowClosed(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  mouseButtons
- *    flags:    s
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QApplication, mouseButtons){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj-&gt;mouseButtons();
-			RETURN_NULL();
-	}
+
+/*!
+ * method wheelScrollLines
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
+ */
+
+ZEND_METHOD(QApplication, wheelScrollLines)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::wheelScrollLines());
+      } else {
+        RETURN_LONG(selfpointer-&gt;wheelScrollLines());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::wheelScrollLines(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  topLevelWidgets
- *    flags:    s
+/*!
+ * method mouseButtons
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::MouseButtons
+ * @flags	s
  */
-ZEND_METHOD(QApplication, topLevelWidgets){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QWidgetList* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidgetList) obj-&gt;topLevelWidgets();
-			} else {
-				*return_object = (QWidgetList) QApplication::topLevelWidgets();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, mouseButtons)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::mouseButtons());
+      } else {
+        RETURN_LONG(selfpointer-&gt;mouseButtons());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::mouseButtons(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  QApplication
- *    flags:    
+/*!
+ * method topLevelWidgets
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidgetList
+ * @flags	s
  */
-ZEND_METHOD(QApplication, __construct){
-		/* ll public*/
 
-		/* int argc, char* * argv,  */
+ZEND_METHOD(QApplication, topLevelWidgets)
+{
+  ///
+#ifdef PHP_QT_QWidgetList       // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
 
-//			QApplication *QApplication_ptr = new QApplication((int&amp;) Z_LVAL_P(z_0) ,(char* *) Z_LVAL_P(z_1));
-				QApplication *QApplication_ptr = new QApplication(argc__, argv__);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				PHP_QT_REGISTER(QApplication_ptr);
-				RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QWidgetList *return_object = new QWidgetList;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QWidgetList &gt; (QApplication::topLevelWidgets());
+      } else {
+        *return_object = static_cast &lt; QWidgetList &gt; (selfpointer-&gt;topLevelWidgets());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::topLevelWidgets(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  aboutQt
- *    flags:    sl
+/*!
+ * method QApplication
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int &amp;argcs0s0
+ * @param	char   **argvs1s1
+ * 
+ * overloaded args:
+ * @param	int &amp;argcs0
+ * @param	char  **argvs1
+ * @param	bool GUIenableds2
+ * 
+ * overloaded args:
+ * @param	int &amp;argcs0
+ * @param	char  **argvs1
+ * @param	 Type s2
+ * 
+ * overloaded args:
+ * @param	const QApplication &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QApplication, aboutQt){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj-&gt;aboutQt();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, __construct)
+{
+  ///int &amp;argcs0s0,char   **argvs1s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_ARRAY) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int &amp;argcs0s0,char   **argvs1s1,
+      QApplication_php_qt *selfpointer = new QApplication_php_qt(getThis(), (int &amp;)Z_LVAL_P(arg_0), new char *[1]);
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///int &amp;argcs0,char  **argvs1,bool GUIenableds2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_ARRAY &amp;&amp; Z_TYPE_P(arg_2) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int &amp;argcs0,char  **argvs1,bool GUIenableds2,
+      QApplication_php_qt *selfpointer = new QApplication_php_qt(getThis(), (int &amp;)Z_LVAL_P(arg_0), new char *[1], (bool) Z_LVAL_P(arg_1));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+// notice: unknown argument  Type s2, skipped
+
+  ///const QApplication &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QApplication
+      if (inherits(Z_OBJCE_P(arg_0), 4)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QApplication::__construct(...) cannot be called with 'const QApplication &amp;,'.&quot;);
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::QApplication(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  layoutDirection
- *    flags:    s
+/*!
+ * method aboutQt
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	sl
  */
-ZEND_METHOD(QApplication, layoutDirection){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;layoutDirection());
-	}
+
+ZEND_METHOD(QApplication, aboutQt)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::aboutQt());
+      } else {
+        RETURN_VOID(selfpointer-&gt;aboutQt());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::aboutQt(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  windowIcon
- *    flags:    s
+/*!
+ * method layoutDirection
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::LayoutDirection
+ * @flags	s
  */
-ZEND_METHOD(QApplication, windowIcon){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj-&gt;windowIcon();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, layoutDirection)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::layoutDirection());
+      } else {
+        RETURN_LONG(selfpointer-&gt;layoutDirection());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::layoutDirection(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  style
- *    flags:    s
+/*!
+ * method windowIcon
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QIcon
+ * @flags	s
  */
-ZEND_METHOD(QApplication, style){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QStyle ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QStyle *) obj-&gt;style();
-			} else {
-				*return_object = (QStyle *) QApplication::style();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, windowIcon)
+{
+  ///
+#ifdef PHP_QT_QIcon             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QIcon *return_object = new QIcon;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QIcon &gt; (QApplication::windowIcon());
+      } else {
+        *return_object = static_cast &lt; QIcon &gt; (selfpointer-&gt;windowIcon());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::windowIcon(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  activeModalWidget
- *    flags:    s
+/*!
+ * method style
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QStyle *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, activeModalWidget){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj-&gt;activeModalWidget();
-			} else {
-				*return_object = (QWidget *) QApplication::activeModalWidget();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, style)
+{
+  ///
+#ifdef PHP_QT_QStyle            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QStyle * &gt;(QApplication::style());
+      } else {
+        le.ptr = static_cast &lt; QStyle * &gt;(selfpointer-&gt;style());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::style(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setKeyboardInputInterval
- *    flags:    s
+/*!
+ * method activeModalWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setKeyboardInputInterval){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QApplication, activeModalWidget)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setKeyboardInputInterval((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QWidget * &gt;(QApplication::activeModalWidget());
+      } else {
+        le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;activeModalWidget());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::activeModalWidget(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  restoreOverrideCursor
- *    flags:    s
+/*!
+ * method setKeyboardInputInterval
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, restoreOverrideCursor){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj-&gt;restoreOverrideCursor();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, setKeyboardInputInterval)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ints0,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setKeyboardInputInterval((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;setKeyboardInputInterval((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setKeyboardInputInterval(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setDoubleClickInterval
- *    flags:    s
+/*!
+ * method restoreOverrideCursor
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setDoubleClickInterval){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QApplication, restoreOverrideCursor)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::restoreOverrideCursor());
+      } else {
+        RETURN_VOID(selfpointer-&gt;restoreOverrideCursor());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::restoreOverrideCursor(...) &quot;);
+}
 
+/*!
+ * method lastWindowClosed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
 
-			obj-&gt;setDoubleClickInterval((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
-}
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-/*********************************
- *    class     QApplication
- *    function  activeWindow
- *    flags:    s
+/*!
+ * method setDoubleClickInterval
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, activeWindow){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj-&gt;activeWindow();
-			} else {
-				*return_object = (QWidget *) QApplication::activeWindow();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, setDoubleClickInterval)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ints0,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setDoubleClickInterval((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;setDoubleClickInterval((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setDoubleClickInterval(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setActiveWindow
- *    flags:    s
+/*!
+ * method activeWindow
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setActiveWindow){
-//qt_QWidget*
-		/* o public*/
 
-		/* qt_QWidget* act,  */
+ZEND_METHOD(QApplication, activeWindow)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				obj-&gt;setActiveWindow((QWidget*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QWidget * &gt;(QApplication::activeWindow());
+      } else {
+        le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;activeWindow());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::activeWindow(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  widgetAt
- *    flags:    s
+/*!
+ * method setActiveWindow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * acts0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, widgetAt){
-		/* l public*/
 
-		/* const QPoint&amp; p,  */
+ZEND_METHOD(QApplication, setActiveWindow)
+{
+  ///QWidget * acts0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        /// try QWidget * acts0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setActiveWindow((QWidget *) cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setActiveWindow((QWidget *) cpp_arg_0));
+        }
+      }
+#endif
 
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj-&gt;widgetAt((const QPoint&amp;) Z_LVAL_P(z_0));
-			} else {
-				*return_object = (QWidget *) QApplication::widgetAt((const QPoint&amp;) Z_LVAL_P(z_0));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setActiveWindow(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  isEffectEnabled
- *    flags:    s
+/*!
+ * method widgetAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;ps0
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, isEffectEnabled){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QApplication, widgetAt)
+{
+  ///const QPoint &amp;ps0
+#ifdef PHP_QT_QWidget           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QPoint &amp;ps0,
+        QApplication *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			RETURN_BOOL(obj-&gt;isEffectEnabled((Qt::UIEffect) Z_LVAL_P(z_0)));
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        if (getThis() == NULL) {
+          le.ptr = static_cast &lt; QWidget * &gt;(QApplication::widgetAt((const QPoint &amp;)*cpp_arg_0));
+        } else {
+          le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;widgetAt((const QPoint &amp;)*cpp_arg_0));
+        } php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///int x, int y
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try int x, int y,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QWidget * &gt;(QApplication::widgetAt((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } else {
+        le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;widgetAt((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::widgetAt(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setPalette
- *    flags:    s
+/*!
+ * method isEffectEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::UIEffect Qt::UIEffects0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setPalette){
-//const QPalette&amp;
-		/* os public*/
 
-		/* const QPalette&amp; , const char* className,  */
+ZEND_METHOD(QApplication, isEffectEnabled)
+{
+  ///Qt::UIEffect Qt::UIEffects0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try Qt::UIEffect Qt::UIEffects0,
+      QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QApplication::isEffectEnabled((Qt::UIEffect) Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_BOOL(selfpointer-&gt;isEffectEnabled((Qt::UIEffect) Z_LVAL_P(arg_0)));
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::isEffectEnabled(...) &quot;);
+}
 
+/*!
+ * method setPalette
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPalette &amp;s0
+ * @param	 const char * className = 0s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-			if(obj_z_0-&gt;inherits(&quot;QPalette&quot;)) {
-				obj-&gt;setPalette((const QPalette&amp;) *obj_z_0, (const char*) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+ZEND_METHOD(QApplication, setPalette)
+{
+  ///const QPalette &amp;s0, const char * className = 0s1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPalette
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QPalette &amp;s0,
+        QApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QPalette *cpp_arg_0 = static_cast &lt; QPalette * &gt;(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setPalette((const QPalette &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setPalette((const QPalette &amp;)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+#ifdef PHP_QT_QPalette
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QPalette &amp;s0, const char * className = 0s1,
+        QApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QPalette *cpp_arg_0 = static_cast &lt; QPalette * &gt;(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setPalette((const QPalette &amp;)*cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setPalette((const QPalette &amp;)*cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setPalette(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  doubleClickInterval
- *    flags:    s
+/*!
+ * method doubleClickInterval
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, doubleClickInterval){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;doubleClickInterval());
-	}
+
+ZEND_METHOD(QApplication, doubleClickInterval)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::doubleClickInterval());
+      } else {
+        RETURN_LONG(selfpointer-&gt;doubleClickInterval());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::doubleClickInterval(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  font
- *    flags:    s
+/*!
+ * method font
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QWidget * = 0s0
+ * 
+ * @access	public
+ * @return	QFont
+ * @flags	s
  */
-ZEND_METHOD(QApplication, font){
-//const QWidget*
-		/* o public*/
 
-		/* const QWidget* ,  */
+ZEND_METHOD(QApplication, font)
+{
+  ///const QWidget * = 0s0
+#ifdef PHP_QT_QFont             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				QFont* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QFont) obj-&gt;font((const QWidget*) obj_z_0);
-			} else {
-				*return_object = (QFont) QApplication::font((const QWidget*) obj_z_0);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QFont *return_object = new QFont;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QFont &gt; (QApplication::font());
+      } else {
+        *return_object = static_cast &lt; QFont &gt; (selfpointer-&gt;font());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      /// try const QWidget * = 0s0,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QFont *return_object = new QFont;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QFont &gt; (QApplication::font((const QWidget *)cpp_arg_0));
+      } else {
+        *return_object = static_cast &lt; QFont &gt; (selfpointer-&gt;font((const QWidget *)cpp_arg_0));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::font(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  globalStrut
- *    flags:    s
+/*!
+ * method globalStrut
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	s
  */
-ZEND_METHOD(QApplication, globalStrut){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;globalStrut();
-			} else {
-				*return_object = (QSize) QApplication::globalStrut();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, globalStrut)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QSize &gt; (QApplication::globalStrut());
+      } else {
+        *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;globalStrut());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::globalStrut(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setGlobalStrut
- *    flags:    s
+/*!
+ * method setGlobalStrut
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setGlobalStrut){
-//const QSize&amp;
-		/* o public*/
 
-		/* const QSize&amp; ,  */
+ZEND_METHOD(QApplication, setGlobalStrut)
+{
+  ///const QSize &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QSize &amp;s0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QSize *cpp_arg_0 = static_cast &lt; QSize * &gt;(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setGlobalStrut((const QSize &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setGlobalStrut((const QSize &amp;)*cpp_arg_0));
+      }}
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QSize&quot;)) {
-				obj-&gt;setGlobalStrut((const QSize&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setGlobalStrut(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  exec
- *    flags:    s
+/*!
+ * method exec
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, exec){
-	if (ZEND_NUM_ARGS() == 0){
-//			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(QApplication::exec());
-	}
+
+ZEND_METHOD(QApplication, exec)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::exec());
+      } else {
+        RETURN_LONG(selfpointer-&gt;exec());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::exec(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  changeOverrideCursor
- *    flags:    s
+/*!
+ * method changeOverrideCursor
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QCursor &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, changeOverrideCursor){
-//const QCursor&amp;
-		/* o public*/
 
-		/* const QCursor&amp; ,  */
+ZEND_METHOD(QApplication, changeOverrideCursor)
+{
+  ///const QCursor &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QCursor
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QCursor &amp;s0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QCursor *cpp_arg_0 = static_cast &lt; QCursor * &gt;(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::changeOverrideCursor((const QCursor &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;changeOverrideCursor((const QCursor &amp;)*cpp_arg_0));
+      }}
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QCursor&quot;)) {
-				obj-&gt;changeOverrideCursor((const QCursor&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::changeOverrideCursor(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setWindowIcon
- *    flags:    s
+/*!
+ * method setWindowIcon
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QIcon &amp;icons0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setWindowIcon){
-//const QIcon&amp;
-		/* o public*/
 
-		/* const QIcon&amp; icon,  */
+ZEND_METHOD(QApplication, setWindowIcon)
+{
+  ///const QIcon &amp;icons0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QIcon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QIcon &amp;icons0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QIcon *cpp_arg_0 = static_cast &lt; QIcon * &gt;(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setWindowIcon((const QIcon &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setWindowIcon((const QIcon &amp;)*cpp_arg_0));
+      }}
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QIcon&quot;)) {
-				obj-&gt;setWindowIcon((const QIcon&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setWindowIcon(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  keyboardModifiers
- *    flags:    s
+/*!
+ * method keyboardModifiers
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::KeyboardModifiers
+ * @flags	s
  */
-ZEND_METHOD(QApplication, keyboardModifiers){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj-&gt;keyboardModifiers();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, keyboardModifiers)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::keyboardModifiers());
+      } else {
+        RETURN_LONG(selfpointer-&gt;keyboardModifiers());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::keyboardModifiers(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  event
- *    flags:    
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QApplication, event){
-		/* o protected*/
-}
 
-/*********************************
- *    class     QApplication
- *    function  beep
- *    flags:    s
+/*!
+ * method beep
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, beep){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj-&gt;beep();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, beep)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::beep());
+      } else {
+        RETURN_VOID(selfpointer-&gt;beep());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::beep(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  overrideCursor
- *    flags:    s
+/*!
+ * method overrideCursor
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QCursor *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, overrideCursor){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QCursor ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QCursor *) obj-&gt;overrideCursor();
-			} else {
-				*return_object = (QCursor *) QApplication::overrideCursor();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, overrideCursor)
+{
+  ///
+#ifdef PHP_QT_QCursor           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QCursor * &gt;(QApplication::overrideCursor());
+      } else {
+        le.ptr = static_cast &lt; QCursor * &gt;(selfpointer-&gt;overrideCursor());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::overrideCursor(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  isLeftToRight
- *    flags:    s
+/*!
+ * method isLeftToRight
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QApplication, isLeftToRight){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isLeftToRight());
-	}
+
+ZEND_METHOD(QApplication, isLeftToRight)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QApplication::isLeftToRight());
+      } else {
+        RETURN_BOOL(selfpointer-&gt;isLeftToRight());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::isLeftToRight(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  syncX
- *    flags:    s
+/*!
+ * method syncX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, syncX){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj-&gt;syncX();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, syncX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::syncX());
+      } else {
+        RETURN_VOID(selfpointer-&gt;syncX());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::syncX(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  type
- *    flags:    s
+/*!
+ * method type
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Type
+ * @flags	s
  */
-ZEND_METHOD(QApplication, type){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;type());
-	}
+
+ZEND_METHOD(QApplication, type)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type Type&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::type(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setOverrideCursor
- *    flags:    s
+/*!
+ * method setOverrideCursor
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QCursor &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setOverrideCursor){
-//const QCursor&amp;
-		/* o public*/
 
-		/* const QCursor&amp; ,  */
+ZEND_METHOD(QApplication, setOverrideCursor)
+{
+  ///const QCursor &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QCursor
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QCursor &amp;s0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QCursor *cpp_arg_0 = static_cast &lt; QCursor * &gt;(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setOverrideCursor((const QCursor &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setOverrideCursor((const QCursor &amp;)*cpp_arg_0));
+      }}
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QCursor&quot;)) {
-				obj-&gt;setOverrideCursor((const QCursor&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setOverrideCursor(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  focusWidget
- *    flags:    s
+/*!
+ * method focusWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, focusWidget){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj-&gt;focusWidget();
-			} else {
-				*return_object = (QWidget *) QApplication::focusWidget();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QApplication, focusWidget)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QWidget * &gt;(QApplication::focusWidget());
+      } else {
+        le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;focusWidget());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::focusWidget(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  topLevelAt
- *    flags:    s
+/*!
+ * method topLevelAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;ps0
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
-ZEND_METHOD(QApplication, topLevelAt){
-		/* l public*/
 
-		/* const QPoint&amp; p,  */
+ZEND_METHOD(QApplication, topLevelAt)
+{
+  ///const QPoint &amp;ps0
+#ifdef PHP_QT_QWidget           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QPoint &amp;ps0,
+        QApplication *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj-&gt;topLevelAt((const QPoint&amp;) Z_LVAL_P(z_0));
-			} else {
-				*return_object = (QWidget *) QApplication::topLevelAt((const QPoint&amp;) Z_LVAL_P(z_0));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        if (getThis() == NULL) {
+          le.ptr = static_cast &lt; QWidget * &gt;(QApplication::topLevelAt((const QPoint &amp;)*cpp_arg_0));
+        } else {
+          le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;topLevelAt((const QPoint &amp;)*cpp_arg_0));
+        } php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///int x, int y
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try int x, int y,
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QWidget * &gt;(QApplication::topLevelAt((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } else {
+        le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;topLevelAt((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::topLevelAt(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  cursorFlashTime
- *    flags:    s
+/*!
+ * method cursorFlashTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, cursorFlashTime){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;cursorFlashTime());
-	}
+
+ZEND_METHOD(QApplication, cursorFlashTime)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::cursorFlashTime());
+      } else {
+        RETURN_LONG(selfpointer-&gt;cursorFlashTime());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::cursorFlashTime(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  startDragDistance
- *    flags:    s
+/*!
+ * method startDragDistance
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QApplication, startDragDistance){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;startDragDistance());
-	}
+
+ZEND_METHOD(QApplication, startDragDistance)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QApplication::startDragDistance());
+      } else {
+        RETURN_LONG(selfpointer-&gt;startDragDistance());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::startDragDistance(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  closeAllWindows
- *    flags:    sl
+/*!
+ * method closeAllWindows
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	sl
  */
-ZEND_METHOD(QApplication, closeAllWindows){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			obj-&gt;closeAllWindows();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QApplication, closeAllWindows)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::closeAllWindows());
+      } else {
+        RETURN_VOID(selfpointer-&gt;closeAllWindows());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::closeAllWindows(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setFont
- *    flags:    s
+/*!
+ * method setFont
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &amp;s0
+ * @param	 const char * className = 0s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setFont){
-//const QFont&amp;
-		/* os public*/
 
-		/* const QFont&amp; , const char* className,  */
+ZEND_METHOD(QApplication, setFont)
+{
+  ///const QFont &amp;s0, const char * className = 0s1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        /// try const QFont &amp;s0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QFont *cpp_arg_0 = static_cast &lt; QFont * &gt;(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setFont((const QFont &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setFont((const QFont &amp;)*cpp_arg_0));
+      }}
+#endif
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QFont&quot;)) {
-				obj-&gt;setFont((const QFont&amp;) *obj_z_0, (const char*) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        /// try const QFont &amp;s0, const char * className = 0s1,
+        QApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QFont *cpp_arg_0 = static_cast &lt; QFont * &gt;(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QApplication::setFont((const QFont &amp;)*cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setFont((const QFont &amp;)*cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setFont(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  notify
- *    flags:    
+/*!
+ * method notify
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * @param	 QEvent *s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QApplication, notify){
-//qt_QObject*
-//qt_QEvent*
-		/* oo public*/
 
-		/* qt_QObject* , qt_QEvent* ,  */
+ZEND_METHOD(QApplication, notify)
+{
+  ///QObject *s0, QEvent *s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 46) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 21)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'notify' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QObject *s0, QEvent *s1,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QObject *cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+        QEvent *cpp_arg_1 = static_cast &lt; QEvent * &gt;(php_qt_fetch(arg_1));
 
+        RETURN_BOOL(selfpointer-&gt;notify((QObject *) cpp_arg_0, (QEvent *) cpp_arg_1));
+      }
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QObject&quot;) &amp;&amp; !strcmp(Z_OBJCE_P(z_1)-&gt;name,&quot;QEvent&quot;)) {
-				RETURN_BOOL(obj-&gt;notify((QObject*) obj_z_0, (QEvent*) obj_z_1));
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::notify(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setStartDragTime
- *    flags:    s
+/*!
+ * method setStartDragTime
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int mss0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QApplication, setStartDragTime){
-		/* l public*/
 
-		/* int ms,  */
+ZEND_METHOD(QApplication, setStartDragTime)
+{
+  ///int mss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int mss0,
+      QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setStartDragTime((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;setStartDragTime((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setStartDragTime(...) &quot;);
+}
 
+/*!
+ * method activePopupWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
+ */
 
-			obj-&gt;setStartDragTime((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
-}
+ZEND_METHOD(QApplication, activePopupWidget)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
 
-/*********************************
- *    class     QApplication
- *    function  activePopupWidget
- *    flags:    s
- */
-ZEND_METHOD(QApplication, activePopupWidget){
-	if (ZEND_NUM_ARGS() == 0){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj-&gt;activePopupWidget();
-			} else {
-				*return_object = (QWidget *) QApplication::activePopupWidget();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QWidget * &gt;(QApplication::activePopupWidget());
+      } else {
+        le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;activePopupWidget());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::activePopupWidget(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setInputContext
- *    flags:    
+/*!
+ * method setInputContext
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QInputContext *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QApplication, setInputContext){
-//QInputContext*
-		/* o public*/
 
-		/* QInputContext* ,  */
+ZEND_METHOD(QApplication, setInputContext)
+{
+  ///QInputContext *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QInputContext
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setInputContext' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QInputContext *s0,
+        QApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+        }
+        QInputContext *cpp_arg_0 = static_cast &lt; QInputContext * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setInputContext((QInputContext *) cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QInputContext&quot;)) {
-				obj-&gt;setInputContext((QInputContext*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setInputContext(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  setQuitOnLastWindowClosed
- *    flags:    s
+/*!
+ * method compressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * @param	 QObject *receivers1
+ * @param	 QPostEventList *s2
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QApplication, setQuitOnLastWindowClosed){
-		/* l public*/
 
-		/* int quit,  */
+/*!
+ * method setQuitOnLastWindowClosed
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool quits0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+ZEND_METHOD(QApplication, setQuitOnLastWindowClosed)
+{
+  ///bool quits0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      /// try bool quits0,
+      QApplication *selfpointer;
 
-
-			obj-&gt;setQuitOnLastWindowClosed((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QApplication::setQuitOnLastWindowClosed((bool) Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;setQuitOnLastWindowClosed((bool) Z_LVAL_P(arg_0)));
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::setQuitOnLastWindowClosed(...) &quot;);
 }
 
-/*********************************
- *    class     QApplication
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QApplication, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QApplication, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QApplication *obj = (QApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QApplication::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QApplication::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QApplication *selfpointer;
 
-PHP_QT_DESTRUCT(QApplication);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QApplication::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QApplication::trUtf8(...) &quot;);
+}
+
+/*!
+ * method saveState
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QSessionManager &amp; sms0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	v
+ */

Modified: trunk/qt/classes/qboxlayout.cpp
===================================================================
--- trunk/qt/classes/qboxlayout.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qboxlayout.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,859 +19,1533 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QBoxLayout.cpp - QBoxLayout PHP implementation.
- * begin           : Thu Feb 23 16:39:38 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
+
 #include &quot;../php_qt.h&quot;
 
 
 #include &lt;QBoxLayout&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QBoxLayout_php_qt:public QBoxLayout
+{
 
+public:
+  QBoxLayout_php_qt(zval * zend_ptr, Direction s0, QWidget * parent = 0);
 
-/*		public enumDirection:long {
-			Direction = 0,
-			Direction = 1,
-			Direction = 2,
-			Direction = 3,
-			Down = TopToBottom,
-			Up = BottomToTop
-		}
-*/
-/*********************************
- *    class     QBoxLayout
- *    function  tr
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+
+QBoxLayout_php_qt::QBoxLayout_php_qt(zval * zend_ptr, Direction s0, QWidget * parent):QBoxLayout(s0, parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QBoxLayout&quot;,&amp;staticMetaObject));
+}
+
+PHP_QT_MOC(QBoxLayout);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QBoxLayout, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QBoxLayout, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QBoxLayout *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QBoxLayout::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-/*********************************
- *    class     QBoxLayout
- *    function  addLayout
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QLayout *layout, int stretch = 0
- */
-ZEND_METHOD(QBoxLayout, addLayout){
-//qt_QLayout*
-		/* ol public*/
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QBoxLayout::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QBoxLayout *
+        selfpointer;
 
-		/* qt_QLayout* layout, int stretch,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QBoxLayout::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			if(obj_z_0-&gt;inherits(&quot;QLayout&quot;)) {
-				obj-&gt;addLayout((QLayout*) obj_z_0, (int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  setStretchFactor
- *    flags:    
- *    access:    public
- *    return:    bool
- *    params:    QWidget *w, int stretch
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QBoxLayout, setStretchFactor){
-//qt_QWidget*
-		/* ol public*/
 
-		/* qt_QWidget* w, int stretch,  */
+/*!
+ * method setDirection
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Direction Directions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-
-
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				RETURN_BOOL(obj-&gt;setStretchFactor((QWidget*) obj_z_0, (int) Z_LVAL_P(z_1)));
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+ZEND_METHOD(QBoxLayout, setDirection)
+{
+// notice: unknown argument Direction Directions0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::setDirection(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  setDirection
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    Direction
+/*!
+ * method addItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, setDirection){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QBoxLayout, addItem)
+{
+  ///QLayoutItem *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addItem' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayoutItem *s0,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayoutItem *
+          cpp_arg_0 = static_cast &lt; QLayoutItem * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;addItem((QLayoutItem *) cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;setDirection((QBoxLayout::Direction) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::addItem(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  addItem
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QLayoutItem *
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QBoxLayout, addItem){
-//qt_QLayoutItem*
-		/* o public*/
 
-		/* qt_QLayoutItem* ,  */
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method count
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QBoxLayout, count)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'count' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
 
-			if(obj_z_0-&gt;inherits(&quot;QLayoutItem&quot;)) {
-				obj-&gt;addItem((QLayoutItem*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;count());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::count(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  insertSpacing
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int index, int size
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QBoxLayout, insertSpacing){
-		/* ll public*/
 
-		/* int index, int size,  */
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
+ */
 
+ZEND_METHOD(QBoxLayout, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-			obj-&gt;insertSpacing((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QBoxLayout::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  count
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method itemAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	c
  */
-ZEND_METHOD(QBoxLayout, count){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;count());
-	}
+
+ZEND_METHOD(QBoxLayout, itemAt)
+{
+// notice: abstract class QLayoutItem cannot be instanciated, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::itemAt(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  invalidate
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    
+/*!
+ * method direction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Direction
+ * @flags	c
  */
-ZEND_METHOD(QBoxLayout, invalidate){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			obj-&gt;invalidate();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QBoxLayout, direction)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type Direction&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::direction(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  setGeometry
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    const QRect&amp;
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, setGeometry){
-//const QRect&amp;
-		/* o public*/
 
-		/* const QRect&amp; ,  */
+/*!
+ * method heightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QBoxLayout, heightForWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'heightForWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QBoxLayout *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;heightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::heightForWidth(...) &quot;);
+}
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QRect&quot;)) {
-				obj-&gt;setGeometry((const QRect&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+/*!
+ * method addSpacing
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int sizes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QBoxLayout, addSpacing)
+{
+  ///int sizes0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addSpacing' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int sizes0,
+      QBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;addSpacing((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::addSpacing(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  addWidget
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QWidget *, int stretch = 0, Qt::Alignment alignment = 0
+/*!
+ * method hasHeightForWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QBoxLayout, addWidget){
-//qt_QWidget*
-		/* oll public*/
 
-		/* qt_QWidget* , int stretch, int alignment,  */
+ZEND_METHOD(QBoxLayout, hasHeightForWidth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hasHeightForWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;hasHeightForWidth());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::hasHeightForWidth(...) &quot;);
+}
 
+/*!
+ * method addStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int stretch = 0s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				obj-&gt;addWidget((QWidget*) obj_z_0, (int) Z_LVAL_P(z_1), (Qt::Alignment) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
-    if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
+ZEND_METHOD(QBoxLayout, addStretch)
+{
+  ///int stretch = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addStretch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
 
-			    QBoxLayout *obj = static_cast&lt;QBoxLayout*&gt;(PHP_QT_FETCH());
-			    QWidget* obj_z_0 = static_cast&lt;QWidget*&gt;(php_qt_fetch(z_0));
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;addStretch());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addStretch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int stretch = 0s0,
+      QBoxLayout *
+        selfpointer;
 
-//			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				obj-&gt;addWidget(obj_z_0);
-			    RETURN_NULL();
-//			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;addStretch((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::addStretch(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  addStrut
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method insertLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0
+ * @param	 QLayout *layouts1
+ * @param	 int stretch = 0s2
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, addStrut){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QBoxLayout, insertLayout)
+{
+  ///int indexs0, QLayout *layouts1, int stretch = 0s2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_1), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'insertLayout' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int indexs0, QLayout *layouts1,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_1 = static_cast &lt; QLayout * &gt;(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer-&gt;insertLayout((int)Z_LVAL_P(arg_0), (QLayout *) cpp_arg_1));
+      }
+#endif
 
-			obj-&gt;addStrut((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_1), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'insertLayout' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int indexs0, QLayout *layouts1, int stretch = 0s2,
+        QBoxLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_1 = static_cast &lt; QLayout * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;insertLayout((int)Z_LVAL_P(arg_0), (QLayout *) cpp_arg_1, (int)Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::insertLayout(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  takeAt
- *    flags:    
- *    access:    public
- *    return:    QLayoutItem *
- *    params:    int
+/*!
+ * method minimumHeightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QBoxLayout, takeAt){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QBoxLayout, minimumHeightForWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumHeightForWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QBoxLayout *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;minimumHeightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::minimumHeightForWidth(...) &quot;);
+}
 
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-			QLayoutItem ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QLayoutItem *) obj-&gt;takeAt((int) Z_LVAL_P(z_0));
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	c
+ */
+
+ZEND_METHOD(QBoxLayout, expandingDirections)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'expandingDirections' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;expandingDirections());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::expandingDirections(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  staticMetaObject
- *    flags:    s
- *    access:    public
- *    return:    QMetaObject*
- *    params:    
+/*!
+ * method addLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayout *layouts0
+ * @param	 int stretch = 0s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, staticMetaObject){
+
+ZEND_METHOD(QBoxLayout, addLayout)
+{
+  ///QLayout *layouts0, int stretch = 0s1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addLayout' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayout *layouts0,
+        QBoxLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast &lt; QLayout * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;addLayout((QLayout *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addLayout' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayout *layouts0, int stretch = 0s1,
+        QBoxLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast &lt; QLayout * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;addLayout((QLayout *) cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::addLayout(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  itemAt
- *    flags:    c
- *    access:    public
- *    return:    QLayoutItem *
- *    params:    int
+/*!
+ * method setStretchFactor
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * @param	 int stretchs1
+ * 
+ * overloaded args:
+ * @param	QLayout *l
+ * @param	 int stretch
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, itemAt){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QBoxLayout, setStretchFactor)
+{
+  ///QWidget *ws0, int stretchs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setStretchFactor' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0, int stretchs1,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_BOOL(selfpointer-&gt;setStretchFactor((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			QLayoutItem ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QLayoutItem *) obj-&gt;itemAt((int) Z_LVAL_P(z_0));
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  ///QLayout *l, int stretch
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setStretchFactor' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayout *l, int stretch,
+        QBoxLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast &lt; QLayout * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;setStretchFactor((QLayout *) cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::setStretchFactor(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  direction
- *    flags:    c
- *    access:    public
- *    return:    Direction
- *    params:    
+/*!
+ * method insertSpacing
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0
+ * @param	 int sizes1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, direction){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;direction());
-	}
-}
 
-/*********************************
- *    class     QBoxLayout
- *    function  qObject
- *    flags:    
- *    access:    public
- *    return:    QObject*
- *    params:    
- */
-ZEND_METHOD(QBoxLayout, qObject){
+ZEND_METHOD(QBoxLayout, insertSpacing)
+{
+  ///int indexs0, int sizes1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'insertSpacing' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int indexs0, int sizes1,
+      QBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;insertSpacing((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::insertSpacing(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  minimumSize
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method invalidate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, minimumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;minimumSize();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QBoxLayout
- *    function  sizeHint
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
- */
-ZEND_METHOD(QBoxLayout, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;sizeHint();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QBoxLayout, invalidate)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'invalidate' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;invalidate());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::invalidate(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  heightForWidth
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    int
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, heightForWidth){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QBoxLayout, setGeometry)
+{
+  ///const QRect &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setGeometry' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;s0,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setGeometry((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
 
-			RETURN_LONG(obj-&gt;heightForWidth((int) Z_LVAL_P(z_0)));
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::setGeometry(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  addSpacing
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int size
+/*!
+ * method takeAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, addSpacing){
-		/* l public*/
 
-		/* int size,  */
+ZEND_METHOD(QBoxLayout, takeAt)
+{
+// notice: abstract class QLayoutItem cannot be instanciated, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::takeAt(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+/*!
+ * method addStrut
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QBoxLayout, addStrut)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addStrut' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QBoxLayout *
+        selfpointer;
 
-			obj-&gt;addSpacing((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;addStrut((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::addStrut(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  addStretch
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int stretch = 0
+/*!
+ * method addWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * @param	 int stretch = 0s1
+ * @param	 Qt::Alignment alignment = 0s2
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, addStretch){
-		/* l public*/
 
-		/* int stretch,  */
+ZEND_METHOD(QBoxLayout, addWidget)
+{
+  ///QWidget *s0, int stretch = 0s1, Qt::Alignment alignment = 0s2
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *s0,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;addWidget((QWidget *) cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;addStretch((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
-}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *s0, int stretch = 0s1,
+        QBoxLayout *
+          selfpointer;
 
-/*********************************
- *    class     QBoxLayout
- *    function  hasHeightForWidth
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
- */
-ZEND_METHOD(QBoxLayout, hasHeightForWidth){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;hasHeightForWidth());
-	}
-}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
-/*********************************
- *    class     QBoxLayout
- *    function  QBoxLayout
- *    flags:    t
- *    access:    public
- *    return:    
- *    params:    Direction, QWidget *parent = 0
- */
-ZEND_METHOD(QBoxLayout, __construct){
-//qt_QWidget*
-		/* lo public*/
+        RETURN_VOID(selfpointer-&gt;addWidget((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-		/* int , qt_QWidget* parent,  */
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *s0, int stretch = 0s1, Qt::Alignment alignment = 0s2,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;addWidget((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::Alignment) Z_LVAL_P(arg_2)));
+      }
+#endif
 
-			if(obj_z_1-&gt;inherits(&quot;QWidget&quot;)) {
-				QBoxLayout *QBoxLayout_ptr = new QBoxLayout((QBoxLayout::Direction) Z_LVAL_P(z_0), (QWidget*) obj_z_1);
-				PHP_QT_REGISTER(QBoxLayout_ptr);
-				RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::addWidget(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  insertStretch
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int index, int stretch = 0
+/*!
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QBoxLayout, insertStretch){
-		/* ll public*/
 
-		/* int index, int stretch,  */
+ZEND_METHOD(QBoxLayout, minimumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj-&gt;insertStretch((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;minimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::minimumSize(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  insertWidget
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int index, QWidget *widget, int stretch = 0, Qt::Alignment alignment = 0
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QBoxLayout, insertWidget){
-//qt_QWidget*
-		/* loll public*/
 
-		/* int index, qt_QWidget* widget, int stretch, int alignment,  */
+ZEND_METHOD(QBoxLayout, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			if(obj_z_1-&gt;inherits(&quot;QWidget&quot;)) {
-				obj-&gt;insertWidget((int) Z_LVAL_P(z_0), (QWidget*) obj_z_1, (int) Z_LVAL_P(z_2), (Qt::Alignment) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::sizeHint(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  insertLayout
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int index, QLayout *layout, int stretch = 0
+/*!
+ * method insertWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0
+ * @param	 QWidget *widgets1
+ * @param	 int stretch = 0s2
+ * @param	 Qt::Alignment alignment = 0s3
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, insertLayout){
-//qt_QLayout*
-		/* lol public*/
 
-		/* int index, qt_QLayout* layout, int stretch,  */
+ZEND_METHOD(QBoxLayout, insertWidget)
+{
+  ///int indexs0, QWidget *widgets1, int stretch = 0s2, Qt::Alignment alignment = 0s3
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_1), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'insertWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int indexs0, QWidget *widgets1,
+        QBoxLayout *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer-&gt;insertWidget((int)Z_LVAL_P(arg_0), (QWidget *) cpp_arg_1));
+      }
+#endif
 
-			if(obj_z_1-&gt;inherits(&quot;QLayout&quot;)) {
-				obj-&gt;insertLayout((int) Z_LVAL_P(z_0), (QLayout*) obj_z_1, (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_1), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'insertWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int indexs0, QWidget *widgets1, int stretch = 0s2,
+        QBoxLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;insertWidget((int)Z_LVAL_P(arg_0), (QWidget *) cpp_arg_1, (int)Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_1), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'insertWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int indexs0, QWidget *widgets1, int stretch = 0s2, Qt::Alignment alignment = 0s3,
+        QBoxLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;insertWidget((int)Z_LVAL_P(arg_0), (QWidget *) cpp_arg_1, (int)Z_LVAL_P(arg_2), (Qt::Alignment) Z_LVAL_P(arg_3)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::insertWidget(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  trUtf8
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+/*!
+ * method insertStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0
+ * @param	 int stretch = 0s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QBoxLayout, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QBoxLayout, insertStretch)
+{
+  ///int indexs0, int stretch = 0s1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'insertStretch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int indexs0,
+      QBoxLayout *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;insertStretch((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'insertStretch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int indexs0, int stretch = 0s1,
+      QBoxLayout *
+        selfpointer;
 
-
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QBoxLayout::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;insertStretch((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::insertStretch(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  maximumSize
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method QBoxLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Direction s0s0
+ * @param	 QWidget *parent = 0s1
+ * 
+ * overloaded args:
+ * @param	const QBoxLayout &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QBoxLayout, maximumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;maximumSize();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QBoxLayout, __construct)
+{
+// notice: unknown argument Direction s0s0, skipped
+
+  ///const QBoxLayout &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QBoxLayout
+      if (inherits(Z_OBJCE_P(arg_0), 5)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QBoxLayout::__construct(...) cannot be called with 'const QBoxLayout &amp;,'.&quot;);
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::QBoxLayout(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  minimumHeightForWidth
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    int
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QBoxLayout, minimumHeightForWidth){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QBoxLayout, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QBoxLayout *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			RETURN_LONG(obj-&gt;minimumHeightForWidth((int) Z_LVAL_P(z_0)));
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QBoxLayout::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QBoxLayout::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::trUtf8(...) &quot;);
 }
 
-/*********************************
- *    class     QBoxLayout
- *    function  insertItem
- *    flags:    
- *    access:    protected
- *    return:    void
- *    params:    int index, QLayoutItem *
+/*!
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-// method insertItem is protected, skipped.
 
-/*********************************
- *    class     QBoxLayout
- *    function  expandingDirections
- *    flags:    c
- *    access:    public
- *    return:    Qt::Orientations
- *    params:    
- */
-ZEND_METHOD(QBoxLayout, expandingDirections){
-	if (ZEND_NUM_ARGS() == 0){
-			QBoxLayout *obj = (QBoxLayout*) PHP_QT_FETCH();
-			obj-&gt;expandingDirections();
-			RETURN_NULL();
-	}
-}
+ZEND_METHOD(QBoxLayout, maximumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'maximumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QBoxLayout *
+        selfpointer;
 
-PHP_QT_DESTRUCT(QBoxLayout);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;maximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QBoxLayout::maximumSize(...) &quot;);
+}
+
+/*!
+ * method insertItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0
+ * @param	 QLayoutItem *s1
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */

Modified: trunk/qt/classes/qchar.cpp
===================================================================
--- trunk/qt/classes/qchar.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qchar.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,746 +19,1399 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QChar.cpp - QChar PHP implementation.
- * begin           : Sun Jan 22 20:52:15 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QChar&gt;
 #include &quot;../php_qt.h&quot;
 
 
+#include &lt;QChar&gt;
+#include &lt;QMetaMethod&gt;
+class QChar_php_qt:public QChar
+{
 
-/*		public enumSpecialCharacter:long {
-			Null = 0x0000,
-			Nbsp = 0x00a0,
-			ReplacementCharacter = 0xfffd,
-			ObjectReplacementCharacter = 0xfffc,
-			ByteOrderMark = 0xfeff,
-			ByteOrderSwapped = 0xfffe,
-			ParagraphSeparator = 0x2029,
-			LineSeparator = 0x2028
-		}
-*/
+public:
+  QChar_php_qt(zval * zend_ptr);
+  QChar_php_qt(zval * zend_ptr, char cs0);
+    QChar_php_qt(zval * zend_ptr, uchar cs0);
+    QChar_php_qt(zval * zend_ptr, QLatin1Char chs0);
+    QChar_php_qt(zval * zend_ptr, uchar cs0, uchar rs1);
+    QChar_php_qt(zval * zend_ptr, ushort rcs0);
+    QChar_php_qt(zval * zend_ptr, short rcs0);
+    QChar_php_qt(zval * zend_ptr, uint rcs0);
+    QChar_php_qt(zval * zend_ptr, int rcs0);
+    QChar_php_qt(zval * zend_ptr, SpecialCharacter scs0);
 
-/*		public enumCategory:long {
-			Category = 0,
-			Category = 1,
-			Category = 2,
-			Category = 3,
-			Category = 4,
-			Category = 5,
-			Category = 6,
-			Category = 7,
-			Category = 8,
-			Category = 9,
-			Category = 10,
-			Category = 11,
-			Category = 12,
-			Category = 13,
-			Category = 14,
-			Category = 15,
-			Category = 16,
-			Category = 17,
-			Category = 18,
-			Category = 19,
-			Category = 20,
-			Category = 21,
-			Category = 22,
-			Category = 23,
-			Category = 24,
-			Category = 25,
-			Category = 26,
-			Category = 27,
-			Category = 28,
-			Category = 29,
-			Category = 30,
-			Punctuation_Dask = Punctuation_Dash
-		}
-*/
 
-/*		public enumDirection:long {
-			Direction = 0,
-			Direction = 1,
-			Direction = 2,
-			Direction = 3,
-			Direction = 4,
-			Direction = 5,
-			Direction = 6,
-			Direction = 7,
-			Direction = 8,
-			Direction = 9,
-			Direction = 10,
-			Direction = 11,
-			Direction = 12,
-			Direction = 13,
-			Direction = 14,
-			Direction = 15,
-			Direction = 16,
-			Direction = 17,
-			Direction = 18
-		}
-*/
+  zval *zend_ptr;
+};
 
-/*		public enumDecomposition:long {
-			Decomposition = 0,
-			Decomposition = 1,
-			Decomposition = 2,
-			Decomposition = 3,
-			Decomposition = 4,
-			Decomposition = 5,
-			Decomposition = 6,
-			Decomposition = 7,
-			Decomposition = 8,
-			Decomposition = 9,
-			Decomposition = 10,
-			Decomposition = 11,
-			Decomposition = 12,
-			Decomposition = 13,
-			Decomposition = 14,
-			Decomposition = 15,
-			Decomposition = 16,
-			Decomposition = 17
-		}
-*/
+QChar_php_qt::QChar_php_qt(zval * zend_ptr):QChar()
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, char cs0):
+QChar(cs0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
 
-/*		public enumJoining:long {
-			Joining = 0,
-			Joining = 1,
-			Joining = 2,
-			Joining = 3
-		}
-*/
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, uchar cs0):QChar(cs0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
 
-/*		public enumCombiningClass:long {
-			Combining_BelowLeftAttached = 200,
-			Combining_BelowAttached = 202,
-			Combining_BelowRightAttached = 204,
-			Combining_LeftAttached = 208,
-			Combining_RightAttached = 210,
-			Combining_AboveLeftAttached = 212,
-			Combining_AboveAttached = 214,
-			Combining_AboveRightAttached = 216,
-			Combining_BelowLeft = 218,
-			Combining_Below = 220,
-			Combining_BelowRight = 222,
-			Combining_Left = 224,
-			Combining_Right = 226,
-			Combining_AboveLeft = 228,
-			Combining_Above = 230,
-			Combining_AboveRight = 232,
-			Combining_DoubleBelow = 233,
-			Combining_DoubleAbove = 234,
-			Combining_IotaSubscript = 240
-		}
-*/
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, QLatin1Char chs0):QChar(chs0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
 
-/*		public enumUnicodeVersion:long {
-			UnicodeVersion = 0,
-			UnicodeVersion = 1,
-			UnicodeVersion = 2,
-			UnicodeVersion = 3,
-			UnicodeVersion = 4,
-			UnicodeVersion = 5,
-			UnicodeVersion = 6,
-			UnicodeVersion = 7
-		}
-*/
-/*********************************
- *    class     QChar */
-/*
- *    function  combiningClass
- *    flags:    c
- */
-ZEND_METHOD(QChar, combiningClass){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj-&gt;combiningClass(), 1);
-	}
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, uchar cs0, uchar rs1):QChar(cs0, rs1)
+{
+  this-&gt;zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isUpper
- *    flags:    c
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, ushort rcs0):QChar(rcs0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, short rcs0):
+QChar(rcs0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, uint rcs0):QChar(rcs0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, int rcs0):
+QChar(rcs0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+QChar_php_qt::QChar_php_qt(zval * zend_ptr, SpecialCharacter scs0):QChar(scs0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method row
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uchar
+ * @flags	c
  */
-ZEND_METHOD(QChar, isUpper){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isUpper());
-	}
+
+ZEND_METHOD(QChar, row)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type uchar&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::row(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  joining
- *    flags:    c
+/*!
+ * method isSymbol
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, joining){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj-&gt;joining();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QChar, isSymbol)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isSymbol' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isSymbol());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::isSymbol(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  row
- *    flags:    c
+/*!
+ * method category
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Category
+ * @flags	c
  */
-ZEND_METHOD(QChar, row){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj-&gt;row(), 1);
-	}
+
+ZEND_METHOD(QChar, category)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type Category&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::category(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  QChar
- *    flags:    
+/*!
+ * method isPrint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *QChar_ptr = new QChar();
-				PHP_QT_REGISTER(QChar_ptr);
-				RETURN_NULL();
-	}
-		/* l public*/
 
-		/* char c,  */
-		/* o public*/
+ZEND_METHOD(QChar, isPrint)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isPrint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
-		/* QLatin1Char ch,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isPrint());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::isPrint(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
+/*!
+ * method digitValue
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QChar, digitValue)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'digitValue' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
-			QChar *QChar_ptr = new QChar((char) Z_LVAL_P(z_0));
-				PHP_QT_REGISTER(QChar_ptr);
-				RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;digitValue());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::digitValue(...) &quot;);
+}
 
+/*!
+ * method mirroredChar
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QLatin1Char&quot;) {
-/*				QChar *QChar_ptr = new QChar((QLatin1Char) obj_z_0);
-				PHP_QT_REGISTER(QChar_ptr);
-*/				RETURN_NULL();
-			}
-			if(obj_z_0-&gt;inherits(&quot;SpecialCharacter&quot;)) {
-/*				QChar *QChar_ptr = new QChar((SpecialCharacter) obj_z_0);
-				PHP_QT_REGISTER(QChar_ptr);
-*/				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ll public*/
+ZEND_METHOD(QChar, mirroredChar)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
 
-		/* unsigned char c, unsigned char r,  */
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'mirroredChar' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QChar *
+        return_object = new QChar;
 
-			QChar *QChar_ptr = new QChar((uchar) Z_LVAL_P(z_0) ,(uchar) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QChar_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
-}
+      *return_object = static_cast &lt; QChar &gt; (selfpointer-&gt;mirroredChar());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isSymbol
- *    flags:    c
- */
-ZEND_METHOD(QChar, isSymbol){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isSymbol());
-	}
+  php_error(E_ERROR, &quot;could not parse argument in QChar::mirroredChar(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  category
- *    flags:    c
+/*!
+ * method fromAscii
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	char cs0
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	s
  */
-ZEND_METHOD(QChar, category){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj-&gt;category();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isPrint
- *    flags:    c
- */
-ZEND_METHOD(QChar, isPrint){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isPrint());
-	}
+ZEND_METHOD(QChar, fromAscii)
+{
+  ///char cs0
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try char cs0,
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QChar *
+        return_object = new QChar;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QChar &gt; (QChar::fromAscii((char)Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QChar &gt; (selfpointer-&gt;fromAscii((char)Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QChar::fromAscii(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  digitValue
- *    flags:    c
+/*!
+ * method isSpace
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, digitValue){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;digitValue());
-	}
-}
 
-/*********************************
- *    class     QChar */
-/*
- *    function  mirroredChar
- *    flags:    c
- */
-ZEND_METHOD(QChar, mirroredChar){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-				QChar return_object = (QChar) obj-&gt;mirroredChar();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QChar, isSpace)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isSpace' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isSpace());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::isSpace(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  fromLatin1
- *    flags:    s
+/*!
+ * method decomposition
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QChar, fromLatin1){
-		/* l public*/
 
-		/* char c,  */
+ZEND_METHOD(QChar, decomposition)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'decomposition' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-				QChar return_object = (QChar) obj-&gt;fromLatin1((char) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;decomposition());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QChar::decomposition(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  fromAscii
- *    flags:    s
+/*!
+ * method toUpper
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	c
  */
-ZEND_METHOD(QChar, fromAscii){
-		/* l public*/
 
-		/* char c,  */
+ZEND_METHOD(QChar, toUpper)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toUpper' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-				QChar return_object = (QChar) obj-&gt;fromAscii((char) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QChar *
+        return_object = new QChar;
+
+      *return_object = static_cast &lt; QChar &gt; (selfpointer-&gt;toUpper());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QChar::toUpper(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isSpace
- *    flags:    c
+/*!
+ * method isPunct
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, isSpace){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isSpace());
-	}
+
+ZEND_METHOD(QChar, isPunct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isPunct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isPunct());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::isPunct(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  toLatin1
- *    flags:    c
+/*!
+ * method direction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Direction
+ * @flags	c
  */
-ZEND_METHOD(QChar, toLatin1){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj-&gt;toLatin1();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QChar, direction)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type Direction&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::direction(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  toUpper
- *    flags:    c
+/*!
+ * method hasMirrored
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, toUpper){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-				QChar return_object = (QChar) obj-&gt;toUpper();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QChar, hasMirrored)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hasMirrored' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;hasMirrored());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::hasMirrored(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  decomposition
- *    flags:    c
+/*!
+ * method setRow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uchar rows0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QChar, decomposition){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;decomposition();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QChar, setRow)
+{
+// notice: unknown argument uchar rows0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QChar::setRow(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isPunct
- *    flags:    c
+/*!
+ * method isLetter
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, isPunct){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isPunct());
-	}
+
+ZEND_METHOD(QChar, isLetter)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isLetter' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isLetter());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::isLetter(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isDigit
- *    flags:    c
+/*!
+ * method unicodeVersion
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	UnicodeVersion
+ * @flags	c
  */
-ZEND_METHOD(QChar, isDigit){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isDigit());
-	}
+
+ZEND_METHOD(QChar, unicodeVersion)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type UnicodeVersion&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::unicodeVersion(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  decompositionTag
- *    flags:    c
+/*!
+ * method toAscii
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char
+ * @flags	c
  */
-ZEND_METHOD(QChar, decompositionTag){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj-&gt;decompositionTag();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QChar, toAscii)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toAscii' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer-&gt;toAscii(), 1);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::toAscii(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isLower
- *    flags:    c
+/*!
+ * method combiningClass
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	unsigned char
+ * @flags	c
  */
-ZEND_METHOD(QChar, isLower){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isLower());
-	}
+
+ZEND_METHOD(QChar, combiningClass)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'combiningClass' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer-&gt;combiningClass(), 1);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::combiningClass(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  direction
- *    flags:    c
+/*!
+ * method isUpper
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, direction){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;direction());
-	}
+
+ZEND_METHOD(QChar, isUpper)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isUpper' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isUpper());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::isUpper(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  hasMirrored
- *    flags:    c
+/*!
+ * method joining
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Joining
+ * @flags	c
  */
-ZEND_METHOD(QChar, hasMirrored){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;hasMirrored());
-	}
+
+ZEND_METHOD(QChar, joining)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type Joining&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::joining(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  toLower
- *    flags:    c
+/*!
+ * method QChar
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	char cs0
+ * 
+ * overloaded args:
+ * @param	uchar cs0
+ * 
+ * overloaded args:
+ * @param	QLatin1Char chs0
+ * 
+ * overloaded args:
+ * @param	uchar cs0
+ * @param	uchar rs1
+ * 
+ * overloaded args:
+ * @param	ushort rcs0
+ * 
+ * overloaded args:
+ * @param	short rcs0
+ * 
+ * overloaded args:
+ * @param	uint rcs0
+ * 
+ * overloaded args:
+ * @param	int rcs0
+ * 
+ * overloaded args:
+ * @param	SpecialCharacter scs0
+ * 
+ * overloaded args:
+ * @param	char c
+ * 
+ * overloaded args:
+ * @param	uchar c
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QChar, toLower){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-				QChar return_object = (QChar) obj-&gt;toLower();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QChar, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar_php_qt *
+        selfpointer = new QChar_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///char cs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try char cs0,
+      QChar_php_qt *
+        selfpointer = new QChar_php_qt(getThis(), (char)Z_STRVAL_P(arg_0)[0]);
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+// notice: unknown argument uchar cs0, skipped
+
+  ///QLatin1Char chs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1Char
+      if (inherits(Z_OBJCE_P(arg_0), 39)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLatin1Char chs0,
+        QLatin1Char *
+          cpp_arg_0 = static_cast &lt; QLatin1Char * &gt;(php_qt_fetch(arg_0));
+        QChar_php_qt *
+          selfpointer = new QChar_php_qt(getThis(), (QLatin1Char) * cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument uchar cs0, skipped
+
+  ///ushort rcs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try ushort rcs0,
+      QChar_php_qt *
+        selfpointer = new QChar_php_qt(getThis(), (ushort) Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///short rcs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try short rcs0,
+      QChar_php_qt *
+        selfpointer = new QChar_php_qt(getThis(), (short)Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///uint rcs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try uint rcs0,
+      QChar_php_qt *
+        selfpointer = new QChar_php_qt(getThis(), (uint) Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///int rcs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int rcs0,
+      QChar_php_qt *
+        selfpointer = new QChar_php_qt(getThis(), (int)Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+// notice: unknown argument SpecialCharacter scs0, skipped
+
+  ///char c
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QChar::__construct(...) cannot be called with 'char c,'.&quot;);
+    }
+  }
+// notice: unknown argument uchar c, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QChar::QChar(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  unicode
- *    flags:    c
+/*!
+ * method fromLatin1
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	char cs0
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	s
  */
-ZEND_METHOD(QChar, unicode){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj-&gt;unicode();
-			RETURN_NULL();
-	}
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-				ushort &amp; return_object = (ushort &amp;) obj-&gt;unicode();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QChar_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QChar, fromLatin1)
+{
+  ///char cs0
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try char cs0,
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QChar *
+        return_object = new QChar;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QChar &gt; (QChar::fromLatin1((char)Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QChar &gt; (selfpointer-&gt;fromLatin1((char)Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QChar::fromLatin1(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isLetter
- *    flags:    c
+/*!
+ * method toLatin1
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char
+ * @flags	c
  */
-ZEND_METHOD(QChar, isLetter){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isLetter());
-	}
+
+ZEND_METHOD(QChar, toLatin1)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toLatin1' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer-&gt;toLatin1(), 1);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::toLatin1(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  setRow
- *    flags:    
+/*!
+ * method isDigit
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, setRow){
-		/* l public*/
 
-		/* unsigned char row,  */
+ZEND_METHOD(QChar, isDigit)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isDigit' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isDigit());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::isDigit(...) &quot;);
+}
 
+/*!
+ * method decompositionTag
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Decomposition
+ * @flags	c
+ */
 
-			obj-&gt;setRow((uchar) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QChar, decompositionTag)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type Decomposition&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::decompositionTag(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isLetterOrNumber
- *    flags:    c
+/*!
+ * method isLower
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, isLetterOrNumber){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isLetterOrNumber());
-	}
+
+ZEND_METHOD(QChar, isLower)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isLower' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isLower());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::isLower(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  cell
- *    flags:    c
+/*!
+ * method toLower
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	c
  */
-ZEND_METHOD(QChar, cell){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj-&gt;cell(), 1);
-	}
+
+ZEND_METHOD(QChar, toLower)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toLower' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QChar *
+        return_object = new QChar;
+
+      *return_object = static_cast &lt; QChar &gt; (selfpointer-&gt;toLower());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QChar::toLower(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isNumber
- *    flags:    c
+/*!
+ * method unicode
+ * 
+ * @param: -
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const ushort
+ * @flags	c
  */
-ZEND_METHOD(QChar, isNumber){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isNumber());
-	}
+
+ZEND_METHOD(QChar, unicode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'unicode' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;unicode());
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'unicode' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;unicode());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::unicode(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  setCell
- *    flags:    
+/*!
+ * method cell
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uchar
+ * @flags	c
  */
-ZEND_METHOD(QChar, setCell){
-		/* l public*/
 
-		/* unsigned char cell,  */
+ZEND_METHOD(QChar, cell)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type uchar&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::cell(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
+/*!
+ * method isLetterOrNumber
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
+ZEND_METHOD(QChar, isLetterOrNumber)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isLetterOrNumber' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
-			obj-&gt;setCell((uchar) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isLetterOrNumber());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::isLetterOrNumber(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  unicodeVersion
- *    flags:    c
+/*!
+ * method setCell
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uchar cells0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QChar, unicodeVersion){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj-&gt;unicodeVersion();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QChar, setCell)
+{
+// notice: unknown argument uchar cells0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QChar::setCell(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  toAscii
- *    flags:    c
+/*!
+ * method isNumber
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, toAscii){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			obj-&gt;toAscii();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QChar, isNumber)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isNumber' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isNumber());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::isNumber(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isMark
- *    flags:    c
+/*!
+ * method isMark
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, isMark){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isMark());
-	}
+
+ZEND_METHOD(QChar, isMark)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isMark' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isMark());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::isMark(...) &quot;);
 }
 
-/*********************************
- *    class     QChar */
-/*
- *    function  isNull
- *    flags:    c
+/*!
+ * method isNull
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChar, isNull){
-	if (ZEND_NUM_ARGS() == 0){
-			QChar *obj = (QChar*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isNull());
-	}
-}
 
+ZEND_METHOD(QChar, isNull)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isNull' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChar *
+        selfpointer;
 
-PHP_QT_DESTRUCT(QChar);
-
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChar * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isNull());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QChar::isNull(...) &quot;);
+}

Modified: trunk/qt/classes/qcharref.cpp
===================================================================
--- trunk/qt/classes/qcharref.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qcharref.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,432 +19,767 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QCharRef.cpp - QCharRef PHP implementation.
- * begin           : Sun Jan 22 20:52:15 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QCharRef&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isDigit
- *    flags:    c
+#include &lt;QCharRef&gt;
+/*!
+ * method row
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uchar
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isDigit){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isDigit());
-	}
+
+ZEND_METHOD(QCharRef, row)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type uchar&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::row(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  combiningClass
- *    flags:    c
+/*!
+ * method category
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar::Category
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, combiningClass){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj-&gt;combiningClass(), 1);
-	}
+
+ZEND_METHOD(QCharRef, category)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::category(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::category(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  decompositionTag
- *    flags:    c
+/*!
+ * method digitValue
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, decompositionTag){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;decompositionTag());
-	}
+
+ZEND_METHOD(QCharRef, digitValue)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::digitValue(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::digitValue(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  joining
- *    flags:    c
+/*!
+ * method isPrint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, joining){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;joining());
-	}
+
+ZEND_METHOD(QCharRef, isPrint)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::isPrint(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::isPrint(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  direction
- *    flags:    c
+/*!
+ * method mirroredChar
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, direction){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;direction());
-	}
+
+ZEND_METHOD(QCharRef, mirroredChar)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::mirroredChar(...) cannot be called with ''.&quot;);
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::mirroredChar(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  hasMirrored
- *    flags:    c
+/*!
+ * method isSpace
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, hasMirrored){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;hasMirrored());
-	}
+
+ZEND_METHOD(QCharRef, isSpace)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::isSpace(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::isSpace(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  toLower
- *    flags:    c
+/*!
+ * method decomposition
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, toLower){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-				QChar return_object = (QChar) obj-&gt;toLower();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCharRef_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCharRef, decomposition)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::decomposition(...) cannot be called with ''.&quot;);
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::decomposition(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  unicode
- *    flags:    c
+/*!
+ * method toUpper
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, unicode){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			obj-&gt;unicode();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QCharRef, toUpper)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::toUpper(...) cannot be called with ''.&quot;);
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::toUpper(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  row
- *    flags:    c
+/*!
+ * method isPunct
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, row){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj-&gt;row(), 1);
-	}
+
+ZEND_METHOD(QCharRef, isPunct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::isPunct(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::isPunct(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  setRow
- *    flags:    
+/*!
+ * method direction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar::Direction
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, setRow){
-		/* l public*/
 
-		/* unsigned char row,  */
+ZEND_METHOD(QCharRef, direction)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::direction(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::direction(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
+/*!
+ * method hasMirrored
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-
-			obj-&gt;setRow((uchar) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QCharRef, hasMirrored)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::hasMirrored(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::hasMirrored(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  category
- *    flags:    c
+/*!
+ * method setRow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uchar rows0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QCharRef, category){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;category());
-	}
+
+ZEND_METHOD(QCharRef, setRow)
+{
+// notice: unknown argument uchar rows0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::setRow(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isLetter
- *    flags:    c
+/*!
+ * method isLetter
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isLetter){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isLetter());
-	}
+
+ZEND_METHOD(QCharRef, isLetter)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::isLetter(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::isLetter(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  cell
- *    flags:    c
+/*!
+ * method unicodeVersion
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar::UnicodeVersion
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, cell){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj-&gt;cell(), 1);
-	}
+
+ZEND_METHOD(QCharRef, unicodeVersion)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::unicodeVersion(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::unicodeVersion(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  digitValue
- *    flags:    c
+/*!
+ * method toAscii
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, digitValue){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;digitValue());
-	}
+
+ZEND_METHOD(QCharRef, toAscii)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::toAscii(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::toAscii(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isPrint
- *    flags:    c
+/*!
+ * method combiningClass
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uchar
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isPrint){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isPrint());
-	}
+
+ZEND_METHOD(QCharRef, combiningClass)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type uchar&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::combiningClass(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isLetterOrNumber
- *    flags:    
+/*!
+ * method joining
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar::Joining
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isLetterOrNumber){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isLetterOrNumber());
-	}
+
+ZEND_METHOD(QCharRef, joining)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::joining(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::joining(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  mirroredChar
- *    flags:    c
+/*!
+ * method toLatin1
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, mirroredChar){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-				QChar return_object = (QChar) obj-&gt;mirroredChar();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCharRef_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCharRef, toLatin1)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::toLatin1(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::toLatin1(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  setCell
- *    flags:    
+/*!
+ * method QCharRef
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QString &amp;strs0
+ * @param	 int idxs1
+ * 
+ * @access	private
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QCharRef, setCell){
-		/* l public*/
 
-		/* unsigned char cell,  */
+ZEND_METHOD(QCharRef, __construct)
+{
+  ///QString &amp;strs0, int idxs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QCharRef::__construct(...) cannot be called with 'QString &amp;strs0, int idxs1,'.&quot;);
+      }
+#endif
 
-
-			obj-&gt;setCell((uchar) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::QCharRef(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isNumber
- *    flags:    c
+/*!
+ * method operator QChar
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isNumber){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isNumber());
-	}
-}
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  unicodeVersion
- *    flags:    c
+/*!
+ * method isDigit
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, unicodeVersion){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;unicodeVersion());
-	}
+
+ZEND_METHOD(QCharRef, isDigit)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::isDigit(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::isDigit(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isSpace
- *    flags:    c
+/*!
+ * method decompositionTag
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar::Decomposition
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isSpace){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isSpace());
-	}
+
+ZEND_METHOD(QCharRef, decompositionTag)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::decompositionTag(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::decompositionTag(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  toLatin1
- *    flags:    c
+/*!
+ * method toLower
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, toLatin1){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			obj-&gt;toLatin1();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QCharRef, toLower)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::toLower(...) cannot be called with ''.&quot;);
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::toLower(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  toAscii
- *    flags:    c
+/*!
+ * method unicode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const ushort
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, toAscii){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			obj-&gt;toAscii();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QCharRef, unicode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::unicode(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::unicode(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  decomposition
- *    flags:    c
+/*!
+ * method cell
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uchar
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, decomposition){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;decomposition();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCharRef_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCharRef, cell)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type uchar&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::cell(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  toUpper
- *    flags:    c
+/*!
+ * method isLetterOrNumber
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QCharRef, toUpper){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-				QChar return_object = (QChar) obj-&gt;toUpper();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCharRef_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCharRef, isLetterOrNumber)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::isLetterOrNumber(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::isLetterOrNumber(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isMark
- *    flags:    c
+/*!
+ * method setCell
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uchar cells0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QCharRef, isMark){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isMark());
-	}
+
+ZEND_METHOD(QCharRef, setCell)
+{
+// notice: unknown argument uchar cells0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::setCell(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isPunct
- *    flags:    c
+/*!
+ * method isNumber
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isPunct){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isPunct());
-	}
+
+ZEND_METHOD(QCharRef, isNumber)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::isNumber(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::isNumber(...) &quot;);
 }
 
-/*********************************
- *    class     QCharRef */
-/*
- *    function  isNull
- *    flags:    c
+/*!
+ * method isMark
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QCharRef, isNull){
-	if (ZEND_NUM_ARGS() == 0){
-			QCharRef *obj = (QCharRef*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isNull());
-	}
+
+ZEND_METHOD(QCharRef, isMark)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::isMark(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::isMark(...) &quot;);
 }
 
+/*!
+ * method isNull
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QCharRef);
+ZEND_METHOD(QCharRef, isNull)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCharRef::isNull(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCharRef::isNull(...) &quot;);
+}
 
+/*!
+ * method operator=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QChar &amp;cs0
+ * 
+ * overloaded args:
+ * @param	char c
+ * 
+ * overloaded args:
+ * @param	uchar c
+ * 
+ * overloaded args:
+ * @param	const QCharRef &amp;c
+ * 
+ * overloaded args:
+ * @param	ushort rc
+ * 
+ * overloaded args:
+ * @param	short rc
+ * 
+ * overloaded args:
+ * @param	uint rc
+ * 
+ * overloaded args:
+ * @param	int rc
+ * 
+ * @access	public
+ * @return	QCharRef &amp;
+ * @flags	
+ */

Modified: trunk/qt/classes/qchildevent.cpp
===================================================================
--- trunk/qt/classes/qchildevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qchildevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QChildEvent.cpp - QChildEvent PHP implementation.
- * begin           : Tue Apr 11 10:33:13 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -31,107 +30,188 @@
 
 
 #include &lt;QChildEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QChildEvent_php_qt:public QChildEvent
+{
 
+public:
+  QChildEvent_php_qt(zval * zend_ptr, Type types0, QObject * childs1);
+
+
+  zval *zend_ptr;
+};
+
+QChildEvent_php_qt::QChildEvent_php_qt(zval * zend_ptr, Type types0, QObject * childs1):QChildEvent(types0, childs1)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
 /*!
- *    @class     QChildEvent
- *    @function  polished
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method polished
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QChildEvent, polished)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'polished' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChildEvent *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QChildEvent *obj = (QChildEvent *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;polished());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChildEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;polished());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QChildEvent::polished(...) &quot;);
 }
 
 /*!
- *    @class     QChildEvent
- *    @function  removed
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method added
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChildEvent, removed)
+
+ZEND_METHOD(QChildEvent, added)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'added' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChildEvent *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QChildEvent *obj = (QChildEvent *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;removed());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChildEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;added());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QChildEvent::added(...) &quot;);
 }
 
 /*!
- *    @class     QChildEvent
- *    @function  added
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method child
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject *
+ * @flags	c
  */
-ZEND_METHOD(QChildEvent, added)
+
+ZEND_METHOD(QChildEvent, child)
 {
+  ///
+#ifdef PHP_QT_QObject           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'child' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChildEvent *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QChildEvent *obj = (QChildEvent *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChildEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-      RETURN_BOOL(obj-&gt;added());
-    }                           /// 5 END getThis(), simple types
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast &lt; QObject * &gt;(selfpointer-&gt;child());
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QChildEvent::child(...) &quot;);
 }
 
 /*!
- *    @class     QChildEvent
- *    @function  child
- *
- *    @flags    c
- *    @access    public
- *    @return    QObject *
- *    @param    
+ * method removed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QChildEvent, child)
+
+ZEND_METHOD(QChildEvent, removed)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    QObject **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'removed' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QChildEvent *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QChildEvent *obj = (QChildEvent *) PHP_QT_FETCH();
-
-/// return: pointer
-
-/// return value is object: QObject *
-      *return_object = static_cast &lt; QObject * &gt;(obj-&gt;child());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QChildEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;removed());
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QChildEvent_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, &quot;could not parse argument in QChildEvent::removed(...) &quot;);
 }
 
+/*!
+ * method QChildEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	QObject *childs1s1
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QChildEvent);
+ZEND_METHOD(QChildEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QChildEvent::QChildEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qclipboardevent.cpp
===================================================================
--- trunk/qt/classes/qclipboardevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qclipboardevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,36 +19,118 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QClipboardEvent.cpp - QClipboardEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QClipboardEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QClipboardEvent */
-/*
- *    function  data
- *    flags:    
+#include &lt;QClipboardEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QClipboardEvent_php_qt:public QClipboardEvent
+{
+
+public:
+  QClipboardEvent_php_qt(zval * zend_ptr, QEventPrivate * datas0);
+
+
+  zval *zend_ptr;
+};
+
+QClipboardEvent_php_qt::QClipboardEvent_php_qt(zval * zend_ptr, QEventPrivate * datas0):QClipboardEvent(datas0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QClipboardEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEventPrivate *datas0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QClipboardEvent, data){
-	if (ZEND_NUM_ARGS() == 0){
-			QClipboardEvent *obj = (QClipboardEvent*) PHP_QT_FETCH();
-				QEventPrivate * return_object = (QEventPrivate *) obj-&gt;data();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QClipboardEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QClipboardEvent, __construct)
+{
+  ///QEventPrivate *datas0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QEventPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QEventPrivate *datas0s0,
+        QEventPrivate *
+          cpp_arg_0 = static_cast &lt; QEventPrivate * &gt;(php_qt_fetch(arg_0));
+        QClipboardEvent_php_qt *
+          selfpointer = new QClipboardEvent_php_qt(getThis(), (QEventPrivate *) cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QClipboardEvent::QClipboardEvent(...) &quot;);
 }
 
+/*!
+ * method data
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QEventPrivate *
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QClipboardEvent);
+ZEND_METHOD(QClipboardEvent, data)
+{
+  ///
+#ifdef PHP_QT_QEventPrivate     // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'data' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QClipboardEvent *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QClipboardEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast &lt; QEventPrivate * &gt;(selfpointer-&gt;data());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QClipboardEvent::data(...) &quot;);
+}

Modified: trunk/qt/classes/qcloseevent.cpp
===================================================================
--- trunk/qt/classes/qcloseevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qcloseevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,62 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QCloseEvent.cpp - QCloseEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QCloseEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
+#include &lt;QCloseEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QCloseEvent_php_qt:public QCloseEvent
+{
 
-PHP_QT_DESTRUCT(QCloseEvent);
+public:
+  QCloseEvent_php_qt(zval * zend_ptr);
 
+
+  zval *zend_ptr;
+};
+
+QCloseEvent_php_qt::QCloseEvent_php_qt(zval * zend_ptr):QCloseEvent()
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QCloseEvent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QCloseEvent, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QCloseEvent_php_qt *
+        selfpointer = new QCloseEvent_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCloseEvent::QCloseEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qcontextmenuevent.cpp
===================================================================
--- trunk/qt/classes/qcontextmenuevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qcontextmenuevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,128 +19,306 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QContextMenuEvent.cpp - QContextMenuEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QContextMenuEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
+#include &lt;QContextMenuEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QContextMenuEvent_php_qt:public QContextMenuEvent
+{
 
-/*		public enumReason:long {
-			Reason = 0,
-			Reason = 0,
-			Reason = 0,
-		}
-*/
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  y
- *    flags:    c
+public:
+  QContextMenuEvent_php_qt(zval * zend_ptr, Reason reasons0, const QPoint &amp; poss1, const QPoint &amp; globalPoss2);
+    QContextMenuEvent_php_qt(zval * zend_ptr, Reason reasons0, const QPoint &amp; poss1);
+
+
+  zval *zend_ptr;
+};
+QContextMenuEvent_php_qt::QContextMenuEvent_php_qt(zval * zend_ptr, Reason reasons0, const QPoint &amp; poss1, const QPoint &amp; globalPoss2):
+QContextMenuEvent(reasons0, poss1, globalPoss2)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QContextMenuEvent_php_qt::QContextMenuEvent_php_qt(zval * zend_ptr, Reason reasons0, const QPoint &amp; poss1):
+QContextMenuEvent(reasons0, poss1)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method y
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QContextMenuEvent, y){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;y());
-	}
+
+ZEND_METHOD(QContextMenuEvent, y)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'y' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QContextMenuEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QContextMenuEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;y());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QContextMenuEvent::y(...) &quot;);
 }
 
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  reason
- *    flags:    c
+/*!
+ * method reason
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Reason
+ * @flags	c
  */
-ZEND_METHOD(QContextMenuEvent, reason){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-			obj-&gt;reason();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QContextMenuEvent, reason)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type Reason&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QContextMenuEvent::reason(...) &quot;);
 }
 
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  globalY
- *    flags:    c
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint&amp;
+ * @flags	c
  */
-ZEND_METHOD(QContextMenuEvent, globalY){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;globalY());
-	}
+
+ZEND_METHOD(QContextMenuEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QContextMenuEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QContextMenuEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QContextMenuEvent::pos(...) &quot;);
 }
 
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method QContextMenuEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Reason reasons0s0
+ * @param	const QPoint &amp;poss1s1
+ * @param	const QPoint &amp;globalPoss2s2
+ * 
+ * overloaded args:
+ * @param	Reason reasons0
+ * @param	const QPoint &amp;poss1
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QContextMenuEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-				const QPoint&amp; return_object = (const QPoint&amp;) obj-&gt;pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QContextMenuEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QContextMenuEvent, __construct)
+{
+// notice: unknown argument Reason reasons0s0, skipped
+
+// notice: unknown argument Reason reasons0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QContextMenuEvent::QContextMenuEvent(...) &quot;);
 }
 
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  x
- *    flags:    c
+/*!
+ * method globalPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint&amp;
+ * @flags	c
  */
-ZEND_METHOD(QContextMenuEvent, x){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;x());
-	}
+
+ZEND_METHOD(QContextMenuEvent, globalPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalPos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QContextMenuEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QContextMenuEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;globalPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QContextMenuEvent::globalPos(...) &quot;);
 }
 
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  globalPos
- *    flags:    c
+/*!
+ * method globalX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QContextMenuEvent, globalPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-				const QPoint&amp; return_object = (const QPoint&amp;) obj-&gt;globalPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QContextMenuEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QContextMenuEvent, globalX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalX' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QContextMenuEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QContextMenuEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;globalX());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QContextMenuEvent::globalX(...) &quot;);
 }
 
-/*********************************
- *    class     QContextMenuEvent */
-/*
- *    function  globalX
- *    flags:    c
+/*!
+ * method x
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QContextMenuEvent, globalX){
-	if (ZEND_NUM_ARGS() == 0){
-			QContextMenuEvent *obj = (QContextMenuEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;globalX());
-	}
+
+ZEND_METHOD(QContextMenuEvent, x)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'x' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QContextMenuEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QContextMenuEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;x());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QContextMenuEvent::x(...) &quot;);
 }
 
+/*!
+ * method globalY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QContextMenuEvent);
+ZEND_METHOD(QContextMenuEvent, globalY)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalY' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QContextMenuEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QContextMenuEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;globalY());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QContextMenuEvent::globalY(...) &quot;);
+}

Modified: trunk/qt/classes/qcoreapplication.cpp
===================================================================
--- trunk/qt/classes/qcoreapplication.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qcoreapplication.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,818 +19,1913 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QCoreApplication.cpp - QCoreApplication PHP implementation.
- * begin           : Thu Feb 23 15:23:15 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
+
 #include &quot;../php_qt.h&quot;
 
 
 #include &lt;QCoreApplication&gt;
 #include &lt;QStringList&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QCoreApplication_php_qt:public QCoreApplication
+{
 
+public:
+  QCoreApplication_php_qt(zval * zend_ptr, int &amp;argcs0, char **argvs1);
 
-/*		public enumEncoding:long {
-			Encoding = 0,
-			Encoding = 1
-		}
-*/
-/*********************************
- *    class     QCoreApplication
- *    function  removeTranslator
- *    flags:    s
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+QCoreApplication_php_qt::QCoreApplication_php_qt(zval * zend_ptr, int &amp;argcs0, char **argvs1):
+QCoreApplication(argcs0, argvs1)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QCoreApplication&quot;,&amp;staticMetaObject));
+}
+
+PHP_QT_MOC(QCoreApplication);
+
+/*!
+ * method removeTranslator
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTranslator *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, removeTranslator){
-//qt_QTranslator*
-		/* o public*/
 
-		/* qt_QTranslator* ,  */
+ZEND_METHOD(QCoreApplication, removeTranslator)
+{
+  ///QTranslator *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QTranslator
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try QTranslator *s0,
+        QCoreApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+        }
+        QTranslator *cpp_arg_0 = static_cast &lt; QTranslator * &gt;(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::removeTranslator((QTranslator *) cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;removeTranslator((QTranslator *) cpp_arg_0));
+        }
+      }
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QTranslator&quot;)) {
-				obj-&gt;removeTranslator((QTranslator*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::removeTranslator(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  tr
- *    flags:    s
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QCoreApplication, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QCoreApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QCoreApplication::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QCoreApplication::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QCoreApplication::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  installTranslator
- *    flags:    s
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QCoreApplication, installTranslator){
-//qt_QTranslator*
-		/* o public*/
 
-		/* qt_QTranslator* ,  */
+/*!
+ * method postEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *receivers0
+ * @param	 QEvent *events1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QCoreApplication, postEvent)
+{
+  ///QObject *receivers0, QEvent *events1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 46) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 21)) {
+        /// try QObject *receivers0, QEvent *events1,
+        QCoreApplication *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+        }
+        QObject *cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+        QEvent *cpp_arg_1 = static_cast &lt; QEvent * &gt;(php_qt_fetch(arg_1));
 
-			if(obj_z_0-&gt;inherits(&quot;QTranslator&quot;)) {
-				obj-&gt;installTranslator((QTranslator*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::postEvent((QObject *) cpp_arg_0, (QEvent *) cpp_arg_1));
+        } else {
+          RETURN_VOID(selfpointer-&gt;postEvent((QObject *) cpp_arg_0, (QEvent *) cpp_arg_1));
+        }
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::postEvent(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  startingUp
- *    flags:    s
+/*!
+ * method init
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	private
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QCoreApplication, startingUp){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;startingUp());
-	}
+
+ZEND_METHOD(QCoreApplication, init)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QCoreApplication::init(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::init(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  exit
- *    flags:    s
+/*!
+ * method addLibraryPath
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, exit){
-		/* l public*/
 
-		/* int retcode,  */
+ZEND_METHOD(QCoreApplication, addLibraryPath)
+{
+  ///const QString &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;s0,
+        QCoreApplication *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			obj-&gt;exit((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::addLibraryPath((const QString &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;addLibraryPath((const QString &amp;)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::addLibraryPath(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  addLibraryPath
- *    flags:    s
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QCoreApplication, addLibraryPath){
-//const QString&amp;
-		/* o public*/
 
-		/* const QString&amp; ,  */
+/*!
+ * method libraryPaths
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QStringList
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QCoreApplication, libraryPaths)
+{
+  ///
+#ifdef PHP_QT_QStringList       // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QString&quot;)) {
-				obj-&gt;addLibraryPath((const QString&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QStringList *return_object = new QStringList;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QStringList &gt; (QCoreApplication::libraryPaths());
+      } else {
+        *return_object = static_cast &lt; QStringList &gt; (selfpointer-&gt;libraryPaths());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::libraryPaths(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  setOrganizationDomain
- *    flags:    s
+/*!
+ * method aboutToQuit
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QCoreApplication, setOrganizationDomain){
-//const QString&amp;
-		/* o public*/
 
-		/* const QString&amp; orgDomain,  */
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method bool
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 *EventFilter)(void *messages0
+ * @param	 long *results1
+ * 
+ * @access	public
+ * @return	typedef
+ * @flags	
+ */
 
-
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QString&quot;)) {
-				obj-&gt;setOrganizationDomain((const QString&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+ZEND_METHOD(QCoreApplication, bool)
+{
+// notice: unknown argument  long *results1, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::bool(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  argv
- *    flags:    s
+/*!
+ * method removeLibraryPath
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, argv){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			char *** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (char **) obj-&gt;argv();
-			} else {
-				*return_object = (char **) QCoreApplication::argv();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCoreApplication, removeLibraryPath)
+{
+  ///const QString &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;s0,
+        QCoreApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::removeLibraryPath((const QString &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;removeLibraryPath((const QString &amp;)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::removeLibraryPath(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  libraryPaths
- *    flags:    s
+/*!
+ * method organizationName
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, libraryPaths){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QStringList* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QStringList) obj-&gt;libraryPaths();
-			} else {
-				*return_object = (QStringList) QCoreApplication::libraryPaths();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCoreApplication, organizationName)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QCoreApplication::organizationName());
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;organizationName());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::organizationName(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  exec
- *    flags:    s
+/*!
+ * method instance
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QCoreApplication *
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, exec){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;exec());
-	}
+
+ZEND_METHOD(QCoreApplication, instance)
+{
+  ///
+#ifdef PHP_QT_QCoreApplication  // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QCoreApplication * &gt;(QCoreApplication::instance());
+      } else {
+        le.ptr = static_cast &lt; QCoreApplication * &gt;(selfpointer-&gt;instance());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::instance(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  setLibraryPaths
- *    flags:    s
+/*!
+ * method organizationDomain
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, setLibraryPaths){
-//const QStringList&amp;
-		/* o public*/
 
-		/* const QStringList&amp; ,  */
+ZEND_METHOD(QCoreApplication, organizationDomain)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QStringList&quot;)) {
-				obj-&gt;setLibraryPaths((const QStringList&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QCoreApplication::organizationDomain());
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;organizationDomain());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::organizationDomain(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  removeLibraryPath
- *    flags:    s
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QCoreApplication, removeLibraryPath){
-//const QString&amp;
-		/* o public*/
 
-		/* const QString&amp; ,  */
+/*!
+ * method hasPendingEvents
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QCoreApplication, hasPendingEvents)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QCoreApplication::hasPendingEvents());
+      } else {
+        RETURN_BOOL(selfpointer-&gt;hasPendingEvents());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::hasPendingEvents(...) &quot;);
+}
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QString&quot;)) {
-				obj-&gt;removeLibraryPath((const QString&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+/*!
+ * method sendPostedEvents
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *receivers0
+ * @param	 int event_types1
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
+
+ZEND_METHOD(QCoreApplication, sendPostedEvents)
+{
+  ///QObject *receivers0, int event_types1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        /// try QObject *receivers0, int event_types1,
+        QCoreApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+        }
+        QObject *cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::sendPostedEvents((QObject *) cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        } else {
+          RETURN_VOID(selfpointer-&gt;sendPostedEvents((QObject *) cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }}
+#endif
+
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::sendPostedEvents());
+      } else {
+        RETURN_VOID(selfpointer-&gt;sendPostedEvents());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::sendPostedEvents(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  organizationName
- *    flags:    s
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QCoreApplication, organizationName){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;organizationName();
-			} else {
-				*return_object = (QString) QCoreApplication::organizationName();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method flush
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
+
+ZEND_METHOD(QCoreApplication, flush)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::flush());
+      } else {
+        RETURN_VOID(selfpointer-&gt;flush());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::flush(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  setOrganizationName
- *    flags:    s
+/*!
+ * method translate
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char * contexts0
+ * @param	 const char * keys1
+ * @param	 const char * comment = 0s2
+ * @param	 Encoding encoding = DefaultCodecs3
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, setOrganizationName){
-//const QString&amp;
-		/* o public*/
 
-		/* const QString&amp; orgName,  */
+ZEND_METHOD(QCoreApplication, translate)
+{
+  ///const char * contexts0, const char * keys1, const char * comment = 0s2, Encoding encoding = DefaultCodecs3
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try const char * contexts0, const char * keys1,
+      QCoreApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QString&quot;)) {
-				obj-&gt;setOrganizationName((const QString&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QCoreApplication::translate((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;translate((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING &amp;&amp; Z_TYPE_P(arg_2) == IS_STRING) {
+      /// try const char * contexts0, const char * keys1, const char * comment = 0s2,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object =
+          static_cast &lt; QString &gt;
+          (QCoreApplication::translate((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0], (const char *)&amp;Z_STRVAL_P(arg_2)[0]));
+      } else {
+        *return_object =
+          static_cast &lt; QString &gt;
+          (selfpointer-&gt;translate((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0], (const char *)&amp;Z_STRVAL_P(arg_2)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+// notice: unknown argument  Encoding encoding = DefaultCodecs3, skipped
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::translate(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  event
- *    flags:    
+/*!
+ * method setEventFilter
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	EventFilter filters0
+ * 
+ * @access	public
+ * @return	EventFilter
+ * @flags	
  */
-ZEND_METHOD(QCoreApplication, event){
-		/* o protected*/
+
+ZEND_METHOD(QCoreApplication, setEventFilter)
+{
+// notice: unknown argument EventFilter filters0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::setEventFilter(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  instance
- *    flags:    s
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, instance){
-	if (ZEND_NUM_ARGS() == 0){
 
-			QCoreApplication ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-			    QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-				*return_object = static_cast&lt;QCoreApplication*&gt;(obj-&gt;instance());
-			} else {
-                return_object = (QCoreApplication **) malloc(sizeof(QCoreApplication::instance()));
-				*return_object = static_cast&lt;QCoreApplication *&gt;(QCoreApplication::instance());
-			}
-			zend_class_entry *ce;                                   
-			object_init_ex(return_value, QCoreApplication_ce_ptr);     
-			zend_rsrc_list_entry le;                            
-			le.ptr = return_object[0];
-			php_qt_register(return_value,le);                   
-			return;                                             
-	}
+ZEND_METHOD(QCoreApplication, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QCoreApplication::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  organizationDomain
- *    flags:    s
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QCoreApplication, organizationDomain){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;organizationDomain();
-			} else {
-				*return_object = (QString) QCoreApplication::organizationDomain();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method sendEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *receivers0
+ * @param	 QEvent *events1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
+ */
+
+ZEND_METHOD(QCoreApplication, sendEvent)
+{
+  ///QObject *receivers0, QEvent *events1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 46) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 21)) {
+        /// try QObject *receivers0, QEvent *events1,
+        QCoreApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+        }
+        QObject *cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+        QEvent *cpp_arg_1 = static_cast &lt; QEvent * &gt;(php_qt_fetch(arg_1));
+
+        if (getThis() == NULL) {
+          RETURN_BOOL(QCoreApplication::sendEvent((QObject *) cpp_arg_0, (QEvent *) cpp_arg_1));
+        } else {
+          RETURN_BOOL(selfpointer-&gt;sendEvent((QObject *) cpp_arg_0, (QEvent *) cpp_arg_1));
+        }
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::sendEvent(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  hasPendingEvents
- *    flags:    s
+/*!
+ * method argc
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, hasPendingEvents){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;hasPendingEvents());
-	}
+
+ZEND_METHOD(QCoreApplication, argc)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QCoreApplication::argc());
+      } else {
+        RETURN_LONG(selfpointer-&gt;argc());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::argc(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  sendPostedEvents
- *    flags:    s
+/*!
+ * method QCoreApplication
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int &amp;argcs0s0
+ * @param	char   **argvs1s1
+ * 
+ * overloaded args:
+ * @param	QCoreApplicationPrivate &amp;p
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QCoreApplication, sendPostedEvents){
-//qt_QObject*
-		/* ol public*/
 
-		/* qt_QObject* receiver, int event_type,  */
+ZEND_METHOD(QCoreApplication, __construct)
+{
+  ///int &amp;argcs0s0,char   **argvs1s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_ARRAY) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int &amp;argcs0s0,char   **argvs1s1,
+      QCoreApplication_php_qt *selfpointer = new QCoreApplication_php_qt(getThis(), (int &amp;)Z_LVAL_P(arg_0), new char *[1]);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QCoreApplicationPrivate &amp;p
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QCoreApplicationPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QCoreApplicationPrivate &amp;p,
+        QCoreApplicationPrivate *cpp_arg_0 = static_cast &lt; QCoreApplicationPrivate * &gt;(php_qt_fetch(arg_0));
+        QCoreApplication_php_qt *selfpointer = new QCoreApplication_php_qt(getThis(), (QCoreApplicationPrivate &amp;) * cpp_arg_0);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QObject&quot;)) {
-				obj-&gt;sendPostedEvents((QObject*) obj_z_0, (int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::QCoreApplication(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  applicationName
- *    flags:    s
+/*!
+ * method watchUnixSignal
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int signals0
+ * @param	 bool watchs1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, applicationName){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;applicationName();
-			} else {
-				*return_object = (QString) QCoreApplication::applicationName();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCoreApplication, watchUnixSignal)
+{
+  ///int signals0, bool watchs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_BOOL) {
+      /// try int signals0, bool watchs1,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::watchUnixSignal((int)Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;watchUnixSignal((int)Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::watchUnixSignal(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  flush
- *    flags:    s
+/*!
+ * method applicationFilePath
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, flush){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			obj-&gt;flush();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QCoreApplication, applicationFilePath)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QCoreApplication::applicationFilePath());
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;applicationFilePath());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::applicationFilePath(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  processEvents
- *    flags:    s
+/*!
+ * method removePostedEvents
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *receivers0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, processEvents){
-		/* l public*/
 
-		/* unsigned int flags,  */
+ZEND_METHOD(QCoreApplication, removePostedEvents)
+{
+  ///QObject *receivers0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        /// try QObject *receivers0,
+        QCoreApplication *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+        }
+        QObject *cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::removePostedEvents((QObject *) cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;removePostedEvents((QObject *) cpp_arg_0));
+        }
+      }
+#endif
 
-			obj-&gt;processEvents((QEventLoop::ProcessEventsFlags) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::removePostedEvents(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  translate
- *    flags:    s
+/*!
+ * method unixSignal
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QCoreApplication, translate){
-		/* sssl public*/
 
-		/* const char* context, const char* key, const char* comment, int encoding,  */
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING &amp;&amp; Z_TYPE_P(z_2) == IS_STRING &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
+/*!
+ * method installTranslator
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTranslator *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
+ZEND_METHOD(QCoreApplication, installTranslator)
+{
+  ///QTranslator *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QTranslator
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try QTranslator *s0,
+        QCoreApplication *selfpointer;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;translate( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1) , (const char*) Z_STRVAL_P(z_2) ,(QCoreApplication::Encoding) Z_LVAL_P(z_3));
-			} else {
-				*return_object = (QString) QCoreApplication::translate( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1) , (const char*) Z_STRVAL_P(z_2) ,(QCoreApplication::Encoding) Z_LVAL_P(z_3));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+        }
+        QTranslator *cpp_arg_0 = static_cast &lt; QTranslator * &gt;(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::installTranslator((QTranslator *) cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;installTranslator((QTranslator *) cpp_arg_0));
+        }
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::installTranslator(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  applicationDirPath
- *    flags:    s
+/*!
+ * method startingUp
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, applicationDirPath){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;applicationDirPath();
-			} else {
-				*return_object = (QString) QCoreApplication::applicationDirPath();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCoreApplication, startingUp)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QCoreApplication::startingUp());
+      } else {
+        RETURN_BOOL(selfpointer-&gt;startingUp());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::startingUp(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method exit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int retcode=0s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, staticMetaObject){
+
+ZEND_METHOD(QCoreApplication, exit)
+{
+  ///int retcode=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::exit());
+      } else {
+        RETURN_VOID(selfpointer-&gt;exit());
+      }
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int retcode=0s0,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::exit((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;exit((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::exit(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  qObject
- *    flags:    
+/*!
+ * method setOrganizationDomain
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;orgDomains0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, qObject){
+
+ZEND_METHOD(QCoreApplication, setOrganizationDomain)
+{
+  ///const QString &amp;orgDomains0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;orgDomains0,
+        QCoreApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::setOrganizationDomain((const QString &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setOrganizationDomain((const QString &amp;)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::setOrganizationDomain(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  argc
- *    flags:    s
+/*!
+ * method argv
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	char **
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, argc){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;argc());
-	}
+
+ZEND_METHOD(QCoreApplication, argv)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_ARRAY(QCoreApplication::argv());
+      } else {
+        RETURN_ARRAY(selfpointer-&gt;argv());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::argv(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  quit
- *    flags:    sl
+/*!
+ * method exec
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, quit){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			obj-&gt;quit();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QCoreApplication, exec)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QCoreApplication::exec());
+      } else {
+        RETURN_LONG(selfpointer-&gt;exec());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::exec(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  QCoreApplication
- *    flags:    
+/*!
+ * method setLibraryPaths
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QStringList &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, __construct){
-		/* ll public*/
 
-		/* int argc, char* * argv,  */
+ZEND_METHOD(QCoreApplication, setLibraryPaths)
+{
+  ///const QStringList &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QStringList
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        /// try const QStringList &amp;s0,
+        QCoreApplication *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+        }
+        QStringList *cpp_arg_0 = static_cast &lt; QStringList * &gt;(php_qt_fetch(arg_0));
 
-			QCoreApplication *QCoreApplication_ptr = new QCoreApplication((int&amp;) Z_LVAL_P(z_0) ,(char* *) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QCoreApplication_ptr);
-				RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::setLibraryPaths((const QStringList &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setLibraryPaths((const QStringList &amp;)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::setLibraryPaths(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  watchUnixSignal
- *    flags:    s
+/*!
+ * method setOrganizationName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;orgNames0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, watchUnixSignal){
-		/* ll public*/
 
-		/* int signal, int watch,  */
+ZEND_METHOD(QCoreApplication, setOrganizationName)
+{
+  ///const QString &amp;orgNames0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;orgNames0,
+        QCoreApplication *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			obj-&gt;watchUnixSignal((int) Z_LVAL_P(z_0) ,(bool) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::setOrganizationName((const QString &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setOrganizationName((const QString &amp;)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::setOrganizationName(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  removePostedEvents
- *    flags:    s
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QCoreApplication, removePostedEvents){
-//qt_QObject*
-		/* o public*/
 
-		/* qt_QObject* receiver,  */
+/*!
+ * method applicationName
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QCoreApplication, applicationName)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
 
-			if(obj_z_0-&gt;inherits(&quot;QObject&quot;)) {
-				obj-&gt;removePostedEvents((QObject*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QCoreApplication::applicationName());
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;applicationName());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::applicationName(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  applicationFilePath
- *    flags:    s
+/*!
+ * method processEvents
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEventLoop::ProcessEventsFlags flags = QEventLoop::AllEventss0
+ * 
+ * overloaded args:
+ * @param	QEventLoop::ProcessEventsFlags flags
+ * @param	 int maxtime
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, applicationFilePath){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;applicationFilePath();
-			} else {
-				*return_object = (QString) QCoreApplication::applicationFilePath();
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QCoreApplication, processEvents)
+{
+  ///QEventLoop::ProcessEventsFlags flags = QEventLoop::AllEventss0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::processEvents());
+      } else {
+        RETURN_VOID(selfpointer-&gt;processEvents());
+      }
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try QEventLoop::ProcessEventsFlags flags = QEventLoop::AllEventss0,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::processEvents((QEventLoop::ProcessEventsFlags) Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;processEvents((QEventLoop::ProcessEventsFlags) Z_LVAL_P(arg_0)));
+      }
+    }
+  }
+  ///QEventLoop::ProcessEventsFlags flags, int maxtime
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try QEventLoop::ProcessEventsFlags flags, int maxtime,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::processEvents((QEventLoop::ProcessEventsFlags) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;processEvents((QEventLoop::ProcessEventsFlags) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::processEvents(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  setApplicationName
- *    flags:    s
+/*!
+ * method applicationDirPath
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, setApplicationName){
-//const QString&amp;
-		/* o public*/
 
-		/* const QString&amp; application,  */
+ZEND_METHOD(QCoreApplication, applicationDirPath)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QString&quot;)) {
-				obj-&gt;setApplicationName((const QString&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QCoreApplication::applicationDirPath());
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;applicationDirPath());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::applicationDirPath(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method sendSpontaneousEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *receivers0
+ * @param	 QEvent *events1
+ * 
+ * @access	private
+ * @return	bool
+ * @flags	s
  */
-ZEND_METHOD(QCoreApplication, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QCoreApplication, sendSpontaneousEvent)
+{
+  ///QObject *receivers0, QEvent *events1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 46) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 21)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QCoreApplication::sendSpontaneousEvent(...) cannot be called with 'QObject *receivers0, QEvent *events1,'.&quot;);
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
+#endif
 
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::sendSpontaneousEvent(...) &quot;);
+}
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QCoreApplication::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QCoreApplication_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+/*!
+ * method notify
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * @param	 QEvent *s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
+
+/*!
+ * method quit
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	sl
+ */
+
+ZEND_METHOD(QCoreApplication, quit)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QCoreApplication::quit());
+      } else {
+        RETURN_VOID(selfpointer-&gt;quit());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::quit(...) &quot;);
 }
 
-/*********************************
- *    class     QCoreApplication
- *    function  closingDown
- *    flags:    s
+/*!
+ * method filterEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	void *messages0
+ * @param	 long *results1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QCoreApplication, closingDown){
-	if (ZEND_NUM_ARGS() == 0){
-			QCoreApplication *obj = (QCoreApplication*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;closingDown());
-	}
+
+ZEND_METHOD(QCoreApplication, filterEvent)
+{
+// notice: unknown argument  long *results1, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::filterEvent(...) &quot;);
 }
 
+/*!
+ * method setApplicationName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;applications0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-PHP_QT_DESTRUCT(QCoreApplication);
+ZEND_METHOD(QCoreApplication, setApplicationName)
+{
+  ///const QString &amp;applications0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;applications0,
+        QCoreApplication *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QCoreApplication::setApplicationName((const QString &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setApplicationName((const QString &amp;)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::setApplicationName(...) &quot;);
+}
+
+/*!
+ * method compressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * @param	 QObject *receivers1
+ * @param	 QPostEventList *s2
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	v
+ */
+
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
+
+ZEND_METHOD(QCoreApplication, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QCoreApplication::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QCoreApplication::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::trUtf8(...) &quot;);
+}
+
+/*!
+ * method closingDown
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
+ */
+
+ZEND_METHOD(QCoreApplication, closingDown)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QCoreApplication *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QCoreApplication * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QCoreApplication::closingDown());
+      } else {
+        RETURN_BOOL(selfpointer-&gt;closingDown());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QCoreApplication::closingDown(...) &quot;);
+}

Modified: trunk/qt/classes/qdate.cpp
===================================================================
--- trunk/qt/classes/qdate.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdate.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,711 +19,1425 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDate.cpp - QDate PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QDate&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QDate */
-/*
- *    function  longDayName
- *    flags:    s
- */
-ZEND_METHOD(QDate, longDayName){
-		/* l public*/
+#include &lt;QDate&gt;
+#include &lt;QMetaMethod&gt;
+class QDate_php_qt:public QDate
+{
 
-		/* int weekday,  */
+public:
+  QDate_php_qt(zval * zend_ptr);
+  QDate_php_qt(zval * zend_ptr, int ys0, int ms1, int ds2);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
 
+  zval *zend_ptr;
+};
 
-				QString return_object = (QString) obj-&gt;longDayName((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+QDate_php_qt::QDate_php_qt(zval * zend_ptr):QDate()
+{
+  this-&gt;zend_ptr = zend_ptr;
 }
-
-/*********************************
- *    class     QDate */
-/*
- *    function  dayOfWeek
- *    flags:    c
- */
-ZEND_METHOD(QDate, dayOfWeek){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;dayOfWeek());
-	}
+QDate_php_qt::QDate_php_qt(zval * zend_ptr, int ys0, int ms1, int ds2):
+QDate(ys0, ms1, ds2)
+{
+  this-&gt;zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  daysInMonth
- *    flags:    c
+/*!
+ * method isValid
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int y
+ * @param	 int m
+ * @param	 int d
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDate, daysInMonth){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;daysInMonth());
-	}
-}
 
-/*********************************
- *    class     QDate */
-/*
- *    function  month
- *    flags:    c
- */
-ZEND_METHOD(QDate, month){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;month());
-	}
+ZEND_METHOD(QDate, isValid)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isValid' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isValid());
+    }
+  }
+  ///int y, int m, int d
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      /// try int y, int m, int d,
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QDate::isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      } else {
+        RETURN_BOOL(selfpointer-&gt;isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::isValid(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  isValid
- *    flags:    c
+/*!
+ * method shortMonthName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int months0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QDate, isValid){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isValid());
-	}
-		/* lll public*/
 
-		/* int y, int m, int d,  */
+ZEND_METHOD(QDate, shortMonthName)
+{
+  ///int months0
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int months0,
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_BOOL(obj-&gt;isValid((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QDate::shortMonthName((int)Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;shortMonthName((int)Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDate::shortMonthName(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  setYMD
- *    flags:    
+/*!
+ * method fromJulianDay
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int jds0
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	s
  */
-ZEND_METHOD(QDate, setYMD){
-		/* lll public*/
 
-		/* int y, int m, int d,  */
+ZEND_METHOD(QDate, fromJulianDay)
+{
+  ///int jds0
+#ifdef PHP_QT_QDate             // return type
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int jds0,
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_BOOL(obj-&gt;setYMD((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDate *return_object = new QDate;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QDate &gt; (QDate::fromJulianDay((int)Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast &lt; QDate &gt; (selfpointer-&gt;fromJulianDay((int)Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDate::fromJulianDay(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  shortMonthName
- *    flags:    s
+/*!
+ * method currentDate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	s
  */
-ZEND_METHOD(QDate, shortMonthName){
-		/* l public*/
 
-		/* int month,  */
+ZEND_METHOD(QDate, currentDate)
+{
+  ///
+#ifdef PHP_QT_QDate             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj-&gt;shortMonthName((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDate *return_object = new QDate;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QDate &gt; (QDate::currentDate());
+      } else {
+        *return_object = static_cast &lt; QDate &gt; (selfpointer-&gt;currentDate());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDate::currentDate(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  toString
- *    flags:    c
+/*!
+ * method addDays
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int dayss0
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	c
  */
-ZEND_METHOD(QDate, toString){
-		/* l public*/
 
-		/* int f,  */
-		/* o public*/
+ZEND_METHOD(QDate, addDays)
+{
+  ///int dayss0
+#ifdef PHP_QT_QDate             // return type
 
-		/* const QString&amp; format,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addDays' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int dayss0,
+      QDate *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDate *return_object = new QDate;
 
-				QString return_object = (QString) obj-&gt;toString((Qt::DateFormat) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      *return_object = static_cast &lt; QDate &gt; (selfpointer-&gt;addDays((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
+  php_error(E_ERROR, &quot;could not parse argument in QDate::addDays(...) &quot;);
+}
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QString return_object = (QString) obj-&gt;toString((const QString&amp;) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+/*!
+ * method day
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QDate, day)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'day' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;day());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::day(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  isLeapYear
- *    flags:    s
+/*!
+ * method fromString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * @param	 Qt::DateFormat f = Qt::TextDates1
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * @param	 const QString &amp;format
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	s
  */
-ZEND_METHOD(QDate, isLeapYear){
-		/* l public*/
 
-		/* int year,  */
+ZEND_METHOD(QDate, fromString)
+{
+  ///const QString &amp;ss0, Qt::DateFormat f = Qt::TextDates1
+#ifdef PHP_QT_QDate             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;ss0,
+        QDate *selfpointer;
 
-			RETURN_BOOL(obj-&gt;isLeapYear((int) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QDate *return_object = new QDate;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QDate &gt; (QDate::fromString((const QString &amp;)*cpp_arg_0));
+        } else {
+          *return_object = static_cast &lt; QDate &gt; (selfpointer-&gt;fromString((const QString &amp;)*cpp_arg_0));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;ss0, Qt::DateFormat f = Qt::TextDates1,
+        QDate *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QDate *return_object = new QDate;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QDate &gt; (QDate::fromString((const QString &amp;)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
+        } else {
+          *return_object = static_cast &lt; QDate &gt; (selfpointer-&gt;fromString((const QString &amp;)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;s, const QString &amp;format
+#ifdef PHP_QT_QDate             // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        /// try const QString &amp;s, const QString &amp;format,
+        QDate *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QDate *return_object = new QDate;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QDate &gt; (QDate::fromString((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        } else {
+          *return_object = static_cast &lt; QDate &gt; (selfpointer-&gt;fromString((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDate::fromString(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  fromJulianDay
- *    flags:    s
+/*!
+ * method daysTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &amp;s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDate, fromJulianDay){
-		/* l public*/
 
-		/* int jd,  */
+ZEND_METHOD(QDate, daysTo)
+{
+  ///const QDate &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDate
+      if (inherits(Z_OBJCE_P(arg_0), 13)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'daysTo' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QDate &amp;s0,
+        QDate *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+        }
+        QDate *cpp_arg_0 = static_cast &lt; QDate * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_LONG(selfpointer-&gt;daysTo((const QDate &amp;)*cpp_arg_0));
+      }
+#endif
 
-				QDate return_object = (QDate) obj-&gt;fromJulianDay((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::daysTo(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  currentDate
- *    flags:    s
+/*!
+ * method month
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDate, currentDate){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-				QDate return_object = (QDate) obj-&gt;currentDate();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDate, month)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'month' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;month());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::month(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  addDays
- *    flags:    c
+/*!
+ * method operator&lt;
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDate, addDays){
-		/* l public*/
 
-		/* int days,  */
+/*!
+ * method operator==
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+/*!
+ * method isLeapYear
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int years0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	s
+ */
 
+ZEND_METHOD(QDate, isLeapYear)
+{
+  ///int years0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int years0,
+      QDate *selfpointer;
 
-				QDate return_object = (QDate) obj-&gt;addDays((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QDate::isLeapYear((int)Z_LVAL_P(arg_0)));
+      } else {
+        RETURN_BOOL(selfpointer-&gt;isLeapYear((int)Z_LVAL_P(arg_0)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::isLeapYear(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  day
- *    flags:    c
+/*!
+ * method gregorianToJulian
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ys0
+ * @param	 int ms1
+ * @param	 int ds2
+ * 
+ * @access	public
+ * @return	uint
+ * @flags	s
  */
-ZEND_METHOD(QDate, day){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;day());
-	}
+
+ZEND_METHOD(QDate, gregorianToJulian)
+{
+  ///int ys0, int ms1, int ds2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      /// try int ys0, int ms1, int ds2,
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QDate::gregorianToJulian((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      } else {
+        RETURN_LONG(selfpointer-&gt;gregorianToJulian((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::gregorianToJulian(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  gregorianToJulian
- *    flags:    s
+/*!
+ * method julianToGregorian
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uint jds0
+ * @param	 int &amp;ys1
+ * @param	 int &amp;ms2
+ * @param	 int &amp;ds3
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QDate, gregorianToJulian){
-		/* lll public*/
 
-		/* int y, int m, int d,  */
+ZEND_METHOD(QDate, julianToGregorian)
+{
+  ///uint jds0, int &amp;ys1, int &amp;ms2, int &amp;ds3
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      /// try uint jds0, int &amp;ys1, int &amp;ms2, int &amp;ds3,
+      QDate *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-
-
-			RETURN_LONG(obj-&gt;gregorianToJulian((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QDate::julianToGregorian((uint) Z_LVAL_P(arg_0), (int &amp;)Z_LVAL_P(arg_1), (int &amp;)Z_LVAL_P(arg_2), (int &amp;)Z_LVAL_P(arg_3)));
+      } else {
+        RETURN_VOID(selfpointer-&gt;julianToGregorian((uint) Z_LVAL_P(arg_0), (int &amp;)Z_LVAL_P(arg_1), (int &amp;)Z_LVAL_P(arg_2), (int &amp;)Z_LVAL_P(arg_3)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::julianToGregorian(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  longMonthName
- *    flags:    s
+/*!
+ * method QDate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ys0
+ * @param	int ms1
+ * @param	int ds2
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QDate, longMonthName){
-		/* l public*/
 
-		/* int month,  */
+ZEND_METHOD(QDate, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate_php_qt *selfpointer = new QDate_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///int ys0,int ms1,int ds2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ys0,int ms1,int ds2,
+      QDate_php_qt *selfpointer = new QDate_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2));
 
-
-				QString return_object = (QString) obj-&gt;longMonthName((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::QDate(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  julianToGregorian
- *    flags:    s
+/*!
+ * method weekNumber
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int *yearNum = 0s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDate, julianToGregorian){
-		/* llll public*/
 
-		/* unsigned int jd, int y, int m, int d,  */
+ZEND_METHOD(QDate, weekNumber)
+{
+  ///int *yearNum = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'weekNumber' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;weekNumber());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'weekNumber' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int *yearNum = 0s0,
+      QDate *selfpointer;
 
-
-			obj-&gt;julianToGregorian((uint) Z_LVAL_P(z_0) ,(int&amp;) Z_LVAL_P(z_1) ,(int&amp;) Z_LVAL_P(z_2) ,(int&amp;) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;weekNumber((int *)&amp;Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::weekNumber(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  QDate
- *    flags:    
+/*!
+ * method addMonths
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int monthss0
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	c
  */
-ZEND_METHOD(QDate, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *QDate_ptr = new QDate();
-				PHP_QT_REGISTER(QDate_ptr);
-				RETURN_NULL();
-	}
-		/* lll public*/
 
-		/* int y, int m, int d,  */
+ZEND_METHOD(QDate, addMonths)
+{
+  ///int monthss0
+#ifdef PHP_QT_QDate             // return type
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addMonths' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int monthss0,
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			QDate *QDate_ptr = new QDate((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				PHP_QT_REGISTER(QDate_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDate *return_object = new QDate;
+
+      *return_object = static_cast &lt; QDate &gt; (selfpointer-&gt;addMonths((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDate::addMonths(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  shortDayName
- *    flags:    s
+/*!
+ * method year
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDate, shortDayName){
-		/* l public*/
 
-		/* int weekday,  */
+ZEND_METHOD(QDate, year)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'year' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;year());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::year(...) &quot;);
+}
 
+/*!
+ * method dayOfWeek
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-				QString return_object = (QString) obj-&gt;shortDayName((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+ZEND_METHOD(QDate, dayOfWeek)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'dayOfWeek' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;dayOfWeek());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::dayOfWeek(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  fromString
- *    flags:    s
+/*!
+ * method operator!=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDate, fromString){
-		/* ol public*/
 
-		/* const QString&amp; s, int f,  */
-		/* oo public*/
+/*!
+ * method setYMD
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ys0
+ * @param	 int ms1
+ * @param	 int ds2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
 
-		/* const QString&amp; s, const QString&amp; format,  */
+ZEND_METHOD(QDate, setYMD)
+{
+  ///int ys0, int ms1, int ds2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setYMD' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ys0, int ms1, int ds2,
+      QDate *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;setYMD((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::setYMD(...) &quot;);
+}
 
+/*!
+ * method operator&gt;
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QDate return_object = (QDate) obj-&gt;fromString((const QString&amp;) obj_z_0, (Qt::DateFormat) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+/*!
+ * method dayOfYear
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QDate, dayOfYear)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'dayOfYear' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot;) {
-					QDate return_object = (QDate) obj-&gt;fromString((const QString&amp;) obj_z_0, (const QString&amp;) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;dayOfYear());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::dayOfYear(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  dayOfYear
- *    flags:    c
+/*!
+ * method toJulianDay
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDate, dayOfYear){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;dayOfYear());
-	}
+
+ZEND_METHOD(QDate, toJulianDay)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toJulianDay' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toJulianDay());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::toJulianDay(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  weekNumber
- *    flags:    c
+/*!
+ * method addYears
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int yearss0
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	c
  */
-ZEND_METHOD(QDate, weekNumber){
-		/* l public*/
 
-		/* int* yearNum,  */
+ZEND_METHOD(QDate, addYears)
+{
+  ///int yearss0
+#ifdef PHP_QT_QDate             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addYears' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int yearss0,
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_LONG(obj-&gt;weekNumber((int*) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDate *return_object = new QDate;
+
+      *return_object = static_cast &lt; QDate &gt; (selfpointer-&gt;addYears((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDate::addYears(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  addMonths
- *    flags:    c
+/*!
+ * method longDayName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int weekdays0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QDate, addMonths){
-		/* l public*/
 
-		/* int months,  */
+ZEND_METHOD(QDate, longDayName)
+{
+  ///int weekdays0
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int weekdays0,
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QDate return_object = (QDate) obj-&gt;addMonths((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QDate::longDayName((int)Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;longDayName((int)Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDate::longDayName(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  toJulianDay
- *    flags:    c
+/*!
+ * method daysInMonth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDate, toJulianDay){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;toJulianDay());
-	}
+
+ZEND_METHOD(QDate, daysInMonth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'daysInMonth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;daysInMonth());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::daysInMonth(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  addYears
- *    flags:    c
+/*!
+ * method operator&lt;=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDate, addYears){
-		/* l public*/
 
-		/* int years,  */
+/*!
+ * method toString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::DateFormat f = Qt::TextDates0
+ * 
+ * overloaded args:
+ * @param	const QString &amp;format
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
+ZEND_METHOD(QDate, toString)
+{
+  ///Qt::DateFormat f = Qt::TextDates0
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toString' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
 
-				QDate return_object = (QDate) obj-&gt;addYears((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDate_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toString());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toString' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::DateFormat f = Qt::TextDates0,
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toString((Qt::DateFormat) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;format
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'toString' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;format,
+        QDate *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toString((const QString &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDate::toString(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  daysTo
- *    flags:    c
+/*!
+ * method longMonthName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int months0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QDate, daysTo){
-		/* o public*/
 
-		/* const QDate&amp; ,  */
+ZEND_METHOD(QDate, longMonthName)
+{
+  ///int months0
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int months0,
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QDate&quot;) {
-				RETURN_LONG(obj-&gt;daysTo((const QDate&amp;) obj_z_0));
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QDate::longMonthName((int)Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;longMonthName((int)Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDate::longMonthName(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  isNull
- *    flags:    c
+/*!
+ * method shortDayName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int weekdays0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QDate, isNull){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isNull());
-	}
+
+ZEND_METHOD(QDate, shortDayName)
+{
+  ///int weekdays0
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int weekdays0,
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QDate::shortDayName((int)Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;shortDayName((int)Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDate::shortDayName(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  year
- *    flags:    c
+/*!
+ * method isNull
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDate, year){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;year());
-	}
+
+ZEND_METHOD(QDate, isNull)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isNull' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isNull());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::isNull(...) &quot;);
 }
 
-/*********************************
- *    class     QDate */
-/*
- *    function  daysInYear
- *    flags:    c
+/*!
+ * method operator&gt;=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDate, daysInYear){
-	if (ZEND_NUM_ARGS() == 0){
-			QDate *obj = (QDate*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;daysInYear());
-	}
-}
 
+/*!
+ * method daysInYear
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QDate);
+ZEND_METHOD(QDate, daysInYear)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'daysInYear' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDate *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDate * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;daysInYear());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDate::daysInYear(...) &quot;);
+}

Modified: trunk/qt/classes/qdatetime.cpp
===================================================================
--- trunk/qt/classes/qdatetime.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdatetime.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,635 +19,1384 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDateTime.cpp - QDateTime PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QDateTime&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  time
- *    flags:    c
+#include &lt;QDateTime&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QDateTime_php_qt:public QDateTime
+{
+
+public:
+  QDateTime_php_qt(zval * zend_ptr);
+  QDateTime_php_qt(zval * zend_ptr, const QDate &amp; s0);
+    QDateTime_php_qt(zval * zend_ptr, const QDate &amp; s0, const QTime &amp; s1, Qt::TimeSpec spec = Qt::LocalTime);
+    QDateTime_php_qt(zval * zend_ptr, const QDateTime &amp; others0);
+
+
+  zval *zend_ptr;
+};
+
+QDateTime_php_qt::QDateTime_php_qt(zval * zend_ptr):QDateTime()
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QDateTime_php_qt::QDateTime_php_qt(zval * zend_ptr, const QDate &amp; s0):
+QDateTime(s0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QDateTime_php_qt::QDateTime_php_qt(zval * zend_ptr, const QDate &amp; s0, const QTime &amp; s1, Qt::TimeSpec spec):
+QDateTime(s0, s1, spec)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QDateTime_php_qt::QDateTime_php_qt(zval * zend_ptr, const QDateTime &amp; others0):
+QDateTime(others0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method date
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QDate
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, time){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-				QTime return_object = (QTime) obj-&gt;time();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDateTime, date)
+{
+  ///
+#ifdef PHP_QT_QDate             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'date' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDate *return_object = new QDate;
+
+      *return_object = static_cast &lt; QDate &gt; (selfpointer-&gt;date());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::date(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  date
- *    flags:    c
+/*!
+ * method isValid
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, date){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-				QDate return_object = (QDate) obj-&gt;date();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDateTime, isValid)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isValid' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isValid());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::isValid(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  isValid
- *    flags:    c
+/*!
+ * method toTime_t
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uint
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, isValid){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isValid());
-	}
+
+ZEND_METHOD(QDateTime, toTime_t)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toTime_t' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toTime_t());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::toTime_t(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  toString
- *    flags:    c
+/*!
+ * method addDays
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int dayss0
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, toString){
-		/* l public*/
 
-		/* int f,  */
-		/* o public*/
+ZEND_METHOD(QDateTime, addDays)
+{
+  ///int dayss0
+#ifdef PHP_QT_QDateTime         // return type
 
-		/* const QString&amp; format,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addDays' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int dayss0,
+      QDateTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
 
-				QString return_object = (QString) obj-&gt;toString((Qt::DateFormat) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      *return_object = static_cast &lt; QDateTime &gt; (selfpointer-&gt;addDays((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QString return_object = (QString) obj-&gt;toString((const QString&amp;) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::addDays(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  toTime_t
- *    flags:    c
+/*!
+ * method fromString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * @param	 Qt::DateFormat f = Qt::TextDates1
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * @param	 const QString &amp;format
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	s
  */
-ZEND_METHOD(QDateTime, toTime_t){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;toTime_t());
-	}
+
+ZEND_METHOD(QDateTime, fromString)
+{
+  ///const QString &amp;ss0, Qt::DateFormat f = Qt::TextDates1
+#ifdef PHP_QT_QDateTime         // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;ss0,
+        QDateTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QDateTime *return_object = new QDateTime;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QDateTime &gt; (QDateTime::fromString((const QString &amp;)*cpp_arg_0));
+        } else {
+          *return_object = static_cast &lt; QDateTime &gt; (selfpointer-&gt;fromString((const QString &amp;)*cpp_arg_0));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;ss0, Qt::DateFormat f = Qt::TextDates1,
+        QDateTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QDateTime *return_object = new QDateTime;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QDateTime &gt; (QDateTime::fromString((const QString &amp;)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
+        } else {
+          *return_object = static_cast &lt; QDateTime &gt; (selfpointer-&gt;fromString((const QString &amp;)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;s, const QString &amp;format
+#ifdef PHP_QT_QDateTime         // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        /// try const QString &amp;s, const QString &amp;format,
+        QDateTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QDateTime *return_object = new QDateTime;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QDateTime &gt; (QDateTime::fromString((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        } else {
+          *return_object = static_cast &lt; QDateTime &gt; (selfpointer-&gt;fromString((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::fromString(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  setTime_t
- *    flags:    
+/*!
+ * method setDate
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &amp;dates0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDateTime, setTime_t){
-		/* l public*/
 
-		/* unsigned int secsSince1Jan1970UTC,  */
+ZEND_METHOD(QDateTime, setDate)
+{
+  ///const QDate &amp;dates0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDate
+      if (inherits(Z_OBJCE_P(arg_0), 13)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setDate' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QDate &amp;dates0,
+        QDateTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+        }
+        QDate *cpp_arg_0 = static_cast &lt; QDate * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setDate((const QDate &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;setTime_t((uint) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::setDate(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  addDays
- *    flags:    c
+/*!
+ * method currentDateTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	s
  */
-ZEND_METHOD(QDateTime, addDays){
-		/* l public*/
 
-		/* int days,  */
+ZEND_METHOD(QDateTime, currentDateTime)
+{
+  ///
+#ifdef PHP_QT_QDateTime         // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QDateTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QDateTime return_object = (QDateTime) obj-&gt;addDays((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QDateTime &gt; (QDateTime::currentDateTime());
+      } else {
+        *return_object = static_cast &lt; QDateTime &gt; (selfpointer-&gt;currentDateTime());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::currentDateTime(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  secsTo
- *    flags:    c
+/*!
+ * method daysTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &amp;s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, secsTo){
-		/* o public*/
 
-		/* const QDateTime&amp; ,  */
+ZEND_METHOD(QDateTime, daysTo)
+{
+  ///const QDateTime &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDateTime
+      if (inherits(Z_OBJCE_P(arg_0), 14)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'daysTo' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QDateTime &amp;s0,
+        QDateTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+        }
+        QDateTime *cpp_arg_0 = static_cast &lt; QDateTime * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_LONG(selfpointer-&gt;daysTo((const QDateTime &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QDateTime&quot;) {
-				RETURN_LONG(obj-&gt;secsTo((const QDateTime&amp;) obj_z_0));
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::daysTo(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  toTimeSpec
- *    flags:    c
+/*!
+ * method toUTC
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, toTimeSpec){
-		/* l public*/
 
-		/* int spec,  */
+ZEND_METHOD(QDateTime, toUTC)
+{
+  ///
+#ifdef PHP_QT_QDateTime         // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toUTC' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QDateTime return_object = (QDateTime) obj-&gt;toTimeSpec((Qt::TimeSpec) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
+
+      *return_object = static_cast &lt; QDateTime &gt; (selfpointer-&gt;toUTC());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::toUTC(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  fromString
- *    flags:    s
+/*!
+ * method setTimeSpec
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::TimeSpec specs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDateTime, fromString){
-		/* ol public*/
 
-		/* const QString&amp; s, int f,  */
-		/* oo public*/
+ZEND_METHOD(QDateTime, setTimeSpec)
+{
+  ///Qt::TimeSpec specs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setTimeSpec' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::TimeSpec specs0,
+      QDateTime *selfpointer;
 
-		/* const QString&amp; s, const QString&amp; format,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setTimeSpec((Qt::TimeSpec) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::setTimeSpec(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method time
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QTime
+ * @flags	c
+ */
 
+ZEND_METHOD(QDateTime, time)
+{
+  ///
+#ifdef PHP_QT_QTime             // return type
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QDateTime return_object = (QDateTime) obj-&gt;fromString((const QString&amp;) obj_z_0, (Qt::DateFormat) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'time' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot;) {
-					QDateTime return_object = (QDateTime) obj-&gt;fromString((const QString&amp;) obj_z_0, (const QString&amp;) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QTime *return_object = new QTime;
+
+      *return_object = static_cast &lt; QTime &gt; (selfpointer-&gt;time());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::time(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  timeSpec
- *    flags:    c
+/*!
+ * method operator&lt;
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, timeSpec){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;timeSpec());
-	}
-}
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  setTime
- *    flags:    
+/*!
+ * method operator==
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, setTime){
-		/* o public*/
 
-		/* const QTime&amp; time,  */
+/*!
+ * method addMonths
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int monthss0
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QDateTime, addMonths)
+{
+  ///int monthss0
+#ifdef PHP_QT_QDateTime         // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addMonths' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int monthss0,
+      QDateTime *selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QTime&quot;) {
-				obj-&gt;setTime((const QTime&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
+
+      *return_object = static_cast &lt; QDateTime &gt; (selfpointer-&gt;addMonths((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::addMonths(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  addMonths
- *    flags:    c
+/*!
+ * method addSecs
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int secss0
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, addMonths){
-		/* l public*/
 
-		/* int months,  */
+ZEND_METHOD(QDateTime, addSecs)
+{
+  ///int secss0
+#ifdef PHP_QT_QDateTime         // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addSecs' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int secss0,
+      QDateTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QDateTime return_object = (QDateTime) obj-&gt;addMonths((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
+
+      *return_object = static_cast &lt; QDateTime &gt; (selfpointer-&gt;addSecs((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::addSecs(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  QDateTime
- *    flags:    
+/*!
+ * method operator!=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *QDateTime_ptr = new QDateTime();
-				PHP_QT_REGISTER(QDateTime_ptr);
-				RETURN_NULL();
-	}
-		/* o public*/
 
-		/* const QDate&amp; ,  */
+/*!
+ * method operator&gt;
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method secsTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &amp;s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QDateTime, secsTo)
+{
+  ///const QDateTime &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDateTime
+      if (inherits(Z_OBJCE_P(arg_0), 14)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'secsTo' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QDateTime &amp;s0,
+        QDateTime *selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QDate&quot;) {
-				QDateTime *QDateTime_ptr = new QDateTime((const QDate&amp;) obj_z_0);
-				PHP_QT_REGISTER(QDateTime_ptr);
-				RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QDateTime&quot;) {
-				QDateTime *QDateTime_ptr = new QDateTime((const QDateTime&amp;) obj_z_0);
-				PHP_QT_REGISTER(QDateTime_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ool public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+        }
+        QDateTime *cpp_arg_0 = static_cast &lt; QDateTime * &gt;(php_qt_fetch(arg_0));
 
-		/* const QDate&amp; , const QTime&amp; , int spec,  */
+        RETURN_LONG(selfpointer-&gt;secsTo((const QDateTime &amp;)*cpp_arg_0));
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::secsTo(...) &quot;);
+}
 
+/*!
+ * method toTimeSpec
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::TimeSpec specs0
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QDate&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QTime&quot;) {
-				QDateTime *QDateTime_ptr = new QDateTime((const QDate&amp;) obj_z_0, (const QTime&amp;) obj_z_1, (Qt::TimeSpec) Z_LVAL_P(z_2));
-				PHP_QT_REGISTER(QDateTime_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QDateTime, toTimeSpec)
+{
+  ///Qt::TimeSpec specs0
+#ifdef PHP_QT_QDateTime         // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toTimeSpec' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::TimeSpec specs0,
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
+
+      *return_object = static_cast &lt; QDateTime &gt; (selfpointer-&gt;toTimeSpec((Qt::TimeSpec) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::toTimeSpec(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  addSecs
- *    flags:    c
+/*!
+ * method setTime
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &amp;times0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDateTime, addSecs){
-		/* l public*/
 
-		/* int secs,  */
+ZEND_METHOD(QDateTime, setTime)
+{
+  ///const QTime &amp;times0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QTime
+      if (inherits(Z_OBJCE_P(arg_0), 63)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setTime' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QTime &amp;times0,
+        QDateTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+        }
+        QTime *cpp_arg_0 = static_cast &lt; QTime * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setTime((const QTime &amp;)*cpp_arg_0));
+      }
+#endif
 
-				QDateTime return_object = (QDateTime) obj-&gt;addSecs((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::setTime(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  setDate
- *    flags:    
+/*!
+ * method addYears
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int yearss0
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, setDate){
-		/* o public*/
 
-		/* const QDate&amp; date,  */
+ZEND_METHOD(QDateTime, addYears)
+{
+  ///int yearss0
+#ifdef PHP_QT_QDateTime         // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addYears' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int yearss0,
+      QDateTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QDate&quot;) {
-				obj-&gt;setDate((const QDate&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
+
+      *return_object = static_cast &lt; QDateTime &gt; (selfpointer-&gt;addYears((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::addYears(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  currentDateTime
- *    flags:    s
+/*!
+ * method detach
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	private
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDateTime, currentDateTime){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-				QDateTime return_object = (QDateTime) obj-&gt;currentDateTime();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDateTime, detach)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QDateTime::detach(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::detach(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  daysTo
- *    flags:    c
+/*!
+ * method operator&lt;=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, daysTo){
-		/* o public*/
 
-		/* const QDateTime&amp; ,  */
+/*!
+ * method toString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::DateFormat f = Qt::TextDates0
+ * 
+ * overloaded args:
+ * @param	const QString &amp;format
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QDateTime, toString)
+{
+  ///Qt::DateFormat f = Qt::TextDates0
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toString' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QDateTime&quot;) {
-				RETURN_LONG(obj-&gt;daysTo((const QDateTime&amp;) obj_z_0));
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toString());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toString' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::DateFormat f = Qt::TextDates0,
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toString((Qt::DateFormat) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;format
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'toString' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;format,
+        QDateTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toString((const QString &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::toString(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  addYears
- *    flags:    c
+/*!
+ * method setTime_t
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uint secsSince1Jan1970UTCs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDateTime, addYears){
-		/* l public*/
 
-		/* int years,  */
+ZEND_METHOD(QDateTime, setTime_t)
+{
+  ///uint secsSince1Jan1970UTCs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setTime_t' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try uint secsSince1Jan1970UTCs0,
+      QDateTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setTime_t((uint) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::setTime_t(...) &quot;);
+}
 
+/*!
+ * method timeSpec
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::TimeSpec
+ * @flags	c
+ */
 
-				QDateTime return_object = (QDateTime) obj-&gt;addYears((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+ZEND_METHOD(QDateTime, timeSpec)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'timeSpec' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;timeSpec());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::timeSpec(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  isNull
- *    flags:    c
+/*!
+ * method QDateTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDate &amp;s0
+ * 
+ * overloaded args:
+ * @param	const QDate &amp;s0
+ * @param	const QTime &amp;s1
+ * @param	 Qt::TimeSpec spec = Qt::LocalTime
+ * 
+ * overloaded args:
+ * @param	const QDateTime &amp;others0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QDateTime, isNull){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isNull());
-	}
+
+ZEND_METHOD(QDateTime, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QDate &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDate
+      if (inherits(Z_OBJCE_P(arg_0), 13)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QDate &amp;s0,
+        QDate *cpp_arg_0 = static_cast &lt; QDate * &gt;(php_qt_fetch(arg_0));
+        QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis(), (const QDate &amp;)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QDate &amp;s0,const QTime &amp;s1, Qt::TimeSpec spec = Qt::LocalTime
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QDate
+#ifdef PHP_QT_QTime
+      if (inherits(Z_OBJCE_P(arg_0), 13) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 63)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QDate &amp;s0,const QTime &amp;s1,
+        QDate *cpp_arg_0 = static_cast &lt; QDate * &gt;(php_qt_fetch(arg_0));
+        QTime *cpp_arg_1 = static_cast &lt; QTime * &gt;(php_qt_fetch(arg_1));
+        QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis(), (const QDate &amp;)*cpp_arg_0, (const QTime &amp;)*cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QDate
+#ifdef PHP_QT_QTime
+      if (inherits(Z_OBJCE_P(arg_0), 13) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 63)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QDate &amp;s0,const QTime &amp;s1, Qt::TimeSpec spec = Qt::LocalTime,
+        QDate *cpp_arg_0 = static_cast &lt; QDate * &gt;(php_qt_fetch(arg_0));
+        QTime *cpp_arg_1 = static_cast &lt; QTime * &gt;(php_qt_fetch(arg_1));
+        QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis(), (const QDate &amp;)*cpp_arg_0, (const QTime &amp;)*cpp_arg_1, (Qt::TimeSpec) Z_LVAL_P(arg_2));
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QDateTime &amp;others0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDateTime
+      if (inherits(Z_OBJCE_P(arg_0), 14)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QDateTime &amp;others0,
+        QDateTime *cpp_arg_0 = static_cast &lt; QDateTime * &gt;(php_qt_fetch(arg_0));
+        QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis(), (const QDateTime &amp;)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::QDateTime(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  toUTC
- *    flags:    c
+/*!
+ * method isNull
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, toUTC){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-				QDateTime return_object = (QDateTime) obj-&gt;toUTC();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDateTime, isNull)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isNull' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isNull());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::isNull(...) &quot;);
 }
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  toLocalTime
- *    flags:    c
+/*!
+ * method operator=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &amp;others0
+ * 
+ * @access	public
+ * @return	QDateTime &amp;
+ * @flags	
  */
-ZEND_METHOD(QDateTime, toLocalTime){
-	if (ZEND_NUM_ARGS() == 0){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
-				QDateTime return_object = (QDateTime) obj-&gt;toLocalTime();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDateTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QDateTime */
-/*
- *    function  setTimeSpec
- *    flags:    
+/*!
+ * method operator&gt;=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QDateTime &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDateTime, setTimeSpec){
-		/* l public*/
 
-		/* int spec,  */
+/*!
+ * method toLocalTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QDateTime
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDateTime *obj = (QDateTime*) PHP_QT_FETCH();
+ZEND_METHOD(QDateTime, toLocalTime)
+{
+  ///
+#ifdef PHP_QT_QDateTime         // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toLocalTime' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDateTime *selfpointer;
 
-			obj-&gt;setTimeSpec((Qt::TimeSpec) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDateTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QDateTime *return_object = new QDateTime;
 
-PHP_QT_DESTRUCT(QDateTime);
+      *return_object = static_cast &lt; QDateTime &gt; (selfpointer-&gt;toLocalTime());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
+  php_error(E_ERROR, &quot;could not parse argument in QDateTime::toLocalTime(...) &quot;);
+}

Modified: trunk/qt/classes/qdialog.cpp
===================================================================
--- trunk/qt/classes/qdialog.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdialog.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDialog.cpp - QDialog PHP implementation.
- * begin           : Thu May 11 20:44:24 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -31,850 +30,1285 @@
 
 
 #include &lt;QDialog&gt;
+/// DEBUG:destructor skipped.
 #include &lt;QMetaMethod&gt;
-
-class QDialog_moc : public QDialog
+class QDialog_php_qt:public QDialog
 {
-    public:
-        QDialog_moc(zval* zend_ptr);
 
-        zval* zend_ptr;
-        QMetaObject* dynamicMetaObject;
+public:
+  QDialog_php_qt(zval * zend_ptr, QWidget * parent = 0, Qt::WFlags f = 0);
 
-        const QMetaObject* metaObject() const;
-        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
-        
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
 };
 
-const QMetaObject *QDialog_moc::metaObject() const
+QDialog_php_qt::QDialog_php_qt(zval * zend_ptr, QWidget * parent, Qt::WFlags f):QDialog(parent, f)
 {
-    return php_qt_getMocData(this-&gt;zend_ptr,&quot;QDialog&quot;,&amp;staticMetaObject);;
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QDialog&quot;,&amp;staticMetaObject));
 }
 
-QDialog_moc::QDialog_moc(zval* zend_ptr)
-{
-    this-&gt;zend_ptr = zend_ptr;
-    dynamicMetaObject = new QMetaObject;
-    dynamicMetaObject = php_qt_getMocData(this-&gt;zend_ptr,&quot;QDialog&quot;,&amp;staticMetaObject);
-}
+PHP_QT_MOC(QDialog);
 
-int QDialog_moc::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
+
+ZEND_METHOD(QDialog, tr)
 {
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-    QMetaObject* d = (QMetaObject*) this-&gt;metaObject();
-    char* method_name = new char[strlen((d-&gt;method(_id)).signature())];
-    strcpy(method_name,(char*) (d-&gt;method(_id)).signature());
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QDialog *
+        selfpointer;
 
-    // breaks the string at the first bracket
-    int i;
-    for(i = 0; i &lt; strlen(method_name); i++){
-        if(method_name[i] == 40){
-            method_name[i] = 0;
-            break;
-        }
-    }
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-    // is a Slot
-    if(d-&gt;method(_id).methodType() == QMetaMethod::Slot){
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        int j = 0;
-        zval** args[1];
-        QList&lt;QByteArray&gt; qargs = d-&gt;method(_id).parameterTypes();
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QDialog::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QDialog *
+        selfpointer;
 
-        for(i = 0; i &lt; qargs.count(); i++){
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-            zval *arg;
-            MAKE_STD_ZVAL(arg);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-            // invoke to zend types
-            if(!strncmp(&quot;int&quot;,(const char*) qargs[i],3)){
-                ZVAL_LONG(arg, *reinterpret_cast&lt; int*&gt;(_a[i+1]));
-            } else if(!strncmp(&quot;char*&quot;,(const char*) qargs[i],5)){
-                ZVAL_STRING(arg, *reinterpret_cast&lt; char**&gt;(_a[i+1]), 1);
-            } else if(!strncmp(&quot;bool&quot;,(const char*) qargs[i],4)){
-                ZVAL_BOOL(arg, *reinterpret_cast&lt; bool*&gt;(_a[i+1]));
-            } else if(!strncmp(&quot;double&quot;,(const char*) qargs[i],4)){
-                ZVAL_DOUBLE(arg, *reinterpret_cast&lt; double*&gt;(_a[i+1]));
-            } else {
-                    // must be an object
-                    zend_class_entry *ce;
-                    object_init_ex(arg, QDialog_ce_ptr);
-                    zend_rsrc_list_entry le;
-                    le.ptr = *reinterpret_cast&lt; QObject**&gt;(_a[1]);
-                    php_qt_register(arg, le);
-                    
-            }
-
-            args[j++] = &arg;
-
-        }
-
-        php_qt_callmethod(this-&gt;zend_ptr, method_name, j, args);
-
-    // is a signal
-    } else {
-        void *_b[] = { 0, _a[1] };
-        QMetaObject::activate(this, d, 0, _b);
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QDialog::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
+  }
+#endif // return type
 
-    delete d;
-    delete method_name;
-
-    return _id;
-
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::tr(...) &quot;);
 }
 
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-/*		public enumDialogCode:long {
-			DialogCode = 0,
-			DialogCode = 1
-		}
-*/
 /*!
- *    @class     QDialog
- *    @function  tr
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method setModal
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool modals0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, tr)
+
+ZEND_METHOD(QDialog, setModal)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  ///bool modals0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setModal' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool modals0,
+      QDialog *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setModal((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::setModal(...) &quot;);
+}
 
-        QString *return_object;
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
+ */
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast &lt; QString &gt; (obj-&gt;tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QDialog::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));       /// memory allocation
-          *return_object = static_cast &lt; QString &gt; (QDialog::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-        object_init_ex(return_value, QString_ce_ptr);
-        zend_rsrc_list_entry le;
+/*!
+ * method isSizeGripEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARG
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+ZEND_METHOD(QDialog, isSizeGripEnabled)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isSizeGripEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING) {
-        QString *return_object = new QString;
-        if (getThis() != NULL) {
-/// return value is object: QString
-            QDialog *obj = static_cast&lt;QDialog *&gt;(PHP_QT_FETCH());
-            *return_object = static_cast &lt; QString &gt; (obj-&gt;tr((const char *)Z_STRVAL_P(z_0)));
-/// check whether method call is static.
-        } else {
-            *return_object = static_cast &lt; QString &gt; (QDialog::tr((const char *)Z_STRVAL_P(z_0)));
-        } 
-            zend_class_entry *ce;
-            object_init_ex(return_value, QString_ce_ptr);
-            zend_rsrc_list_entry le;
-            le.ptr = return_object;
-            php_qt_register(return_value, le);
-            return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isSizeGripEnabled());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::isSizeGripEnabled(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  setSizeGripEnabled
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QDialog, setSizeGripEnabled)
-{
-/*! l public*/
-/*! int ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+/*!
+ * method adjustPosition
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-        void *return_object;
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-        if (getThis() != NULL) {
-          obj-&gt;setSizeGripEnabled((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
-
 /*!
- *    @class     QDialog
- *    @function  setModal
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool modal
+ * method setExtension
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * extensions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, setModal)
+
+ZEND_METHOD(QDialog, setExtension)
 {
-/*! l public*/
-/*! int modal,  */
+  ///QWidget * extensions0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setExtension' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget * extensions0,
+        QDialog *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
-        void *return_object;
+        RETURN_VOID(selfpointer-&gt;setExtension((QWidget *) cpp_arg_0));
+      }
+#endif
 
-        if (getThis() != NULL) {
-          obj-&gt;setModal((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::setExtension(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  exec
- *
- *    @flags    
- *    @access    public
- *    @return    int
- *    @param    
+ * method result
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QDialog, exec)
+
+ZEND_METHOD(QDialog, result)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'result' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;exec());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;result());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::result(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  showExtension
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QDialog, showExtension)
+
+ZEND_METHOD(QDialog, staticMetaObject)
 {
-/*! l public*/
-/*! int ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QDialog *
+        selfpointer;
 
-        void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-          obj-&gt;showExtension((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QDialog::staticMetaObject());
       } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::staticMetaObject(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  rejected
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method QDialog
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parent = 0s0
+ * @param	 Qt::WFlags f = 0s1
+ * 
+ * overloaded args:
+ * @param	QDialogPrivate &amp;
+ * @param	 QWidget *parent
+ * @param	 Qt::WFlags f = 0
+ * 
+ * overloaded args:
+ * @param	const QDialog &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QDialog, rejected)
+
+ZEND_METHOD(QDialog, __construct)
 {
-/*  if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+  ///QWidget *parent = 0s0, Qt::WFlags f = 0s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog_php_qt *
+        selfpointer = new QDialog_php_qt(getThis());
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget *parent = 0s0,
+      QWidget *
+        cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QDialog_php_qt *
+        selfpointer = new QDialog_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-      obj-&gt;rejected();
+      PHP_QT_REGISTER(selfpointer);
       RETURN_NULL();
-    }                           /// END getThis(), NULL
-  }*/
-}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget *parent = 0s0, Qt::WFlags f = 0s1,
+      QWidget *
+        cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QDialog_php_qt *
+        selfpointer = new QDialog_php_qt(getThis(), (QWidget *) cpp_arg_0, (Qt::WFlags) Z_LVAL_P(arg_1));
 
-/*!
- *    @class     QDialog
- *    @function  isSizeGripEnabled
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
- */
-ZEND_METHOD(QDialog, isSizeGripEnabled)
-{
-  if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QDialogPrivate &amp;, QWidget *parent, Qt::WFlags f = 0
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QDialogPrivate
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 71)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QDialogPrivate &amp;, QWidget *parent,
+        QDialogPrivate *
+          cpp_arg_0 = static_cast &lt; QDialogPrivate * &gt;(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+        QDialog_php_qt *
+          selfpointer = new QDialog_php_qt(getThis(), (QDialogPrivate &amp;) * cpp_arg_0, (QWidget *) cpp_arg_1);
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-      RETURN_BOOL(obj-&gt;isSizeGripEnabled());
-    }                           /// 5 END getThis(), simple types
+#endif
+
+    }
   }
-}
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QDialogPrivate
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 71)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QDialogPrivate &amp;, QWidget *parent, Qt::WFlags f = 0,
+        QDialogPrivate *
+          cpp_arg_0 = static_cast &lt; QDialogPrivate * &gt;(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+        QDialog_php_qt *
+          selfpointer = new QDialog_php_qt(getThis(), (QDialogPrivate &amp;) * cpp_arg_0, (QWidget *) cpp_arg_1, (Qt::WFlags) Z_LVAL_P(arg_2));
 
-/*!
- *    @class     QDialog
- *    @function  event
- *
- *    @flags    
- *    @access    public
- *    @return    bool
- *    @param    QEvent *
- */
-ZEND_METHOD(QDialog, event)
-{
-///qt_QEvent*
-/*! o public*/
-/*! qt_QEvent* ,  */
-/*  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+#endif
 
-        if (!strcmp(Z_OBJCE_P(z_0)-&gt;name, &quot;QEvent&quot;)) {
-          bool *return_object;
+    }
+  }
+  ///const QDialog &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QDialog
+      if (inherits(Z_OBJCE_P(arg_0), 15)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QDialog::__construct(...) cannot be called with 'const QDialog &amp;,'.&quot;);
+      }
+#endif
 
-          if (getThis() != NULL) {
-            RETURN_BOOL(obj-&gt;event((QEvent *) obj_z_0));
-          }                     /// 5 END getThis(), simple types
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS*/
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::QDialog(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  adjustPosition
- *
- *    @flags    
- *    @access    protected
- *    @return    void
- *    @param    QWidget*
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-// method adjustPosition is protected, skipped.
 
 /*!
- *    @class     QDialog
- *    @function  setExtension
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QWidget* extension
+ * method minimumSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QDialog, setExtension)
+
+ZEND_METHOD(QDialog, minimumSizeHint)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* extension,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumSizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-          if (getThis() != NULL) {
-            obj-&gt;setExtension((QWidget *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;minimumSizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::minimumSizeHint(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  finished
- *
- *    @flags    
- *    @access    public
- *    @return    Q_SIGNALS: void
- *    @param    int result
+ * method setOrientation
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Orientation orientations0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, finished)
+
+ZEND_METHOD(QDialog, setOrientation)
 {
-/*! l public*/
-/*! int result,  */
-/*  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///Qt::Orientation orientations0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setOrientation' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::Orientation orientations0,
+      QDialog *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;finished((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS*/
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setOrientation((Qt::Orientation) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::setOrientation(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  result
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method setResult
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int rs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, result)
+
+ZEND_METHOD(QDialog, setResult)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+  ///int rs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setResult' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int rs0,
+      QDialog *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;result());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setResult((int)Z_LVAL_P(arg_0)));
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::setResult(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  orientation
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::Orientation
- *    @param    
+ * method eventFilter
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * @param	 QEvent *s1
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QDialog, orientation)
+
+/*!
+ * method contextMenuEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QContextMenuEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
+
+/*!
+ * method accepted
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QDialog, accepted)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::Orientation * return_object;
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'accepted' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-      RETURN_LONG(obj-&gt;orientation());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;accepted());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::accepted(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  QDialog
- *
- *    @flags    t
- *    @access    public
- *    @return    
- *    @param    QWidget *parent = 0, Qt::WFlags f = 0
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QDialog, __construct)
-{
-///QWidget*
-/*! ol public*/
-/*! QWidget* parent, int f,  */
 
-  if (ZEND_NUM_ARGS() == 0) {
+/*!
+ * method done
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	v
+ */
 
-    QDialog_moc *QDialog_ptr = new QDialog_moc(getThis());
+/*!
+ * method closeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QCloseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-    PHP_QT_REGISTER(QDialog_ptr);
-    RETURN_NULL();
-                                /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+/*!
+ * method setSizeGripEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+ZEND_METHOD(QDialog, setSizeGripEnabled)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setSizeGripEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QDialog *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
-
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          QDialog *QDialog_ptr = new QDialog((QWidget *) obj_z_0, (Qt::WFlags) Z_LVAL_P(z_1));
-
-          PHP_QT_REGISTER(QDialog_ptr);
-          RETURN_NULL();
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setSizeGripEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::setSizeGripEnabled(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  staticMetaObject
- *
- *    @flags    s
- *    @access    public
- *    @return    QMetaObject*
- *    @param    
+ * method resizeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QResizeEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, staticMetaObject)
-{
-}
 
 /*!
- *    @class     QDialog
- *    @function  qObject
- *
- *    @flags    
- *    @access    public
- *    @return    QObject*
- *    @param    
+ * method exec
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	
  */
-ZEND_METHOD(QDialog, qObject)
+
+ZEND_METHOD(QDialog, exec)
 {
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'exec' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;exec());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::exec(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  sizeHint
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method showExtension
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, sizeHint)
+
+ZEND_METHOD(QDialog, showExtension)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'showExtension' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QDialog *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
-
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;sizeHint());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;showExtension((bool) Z_LVAL_P(arg_0)));
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QDialog_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::showExtension(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  minimumSizeHint
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method rejected
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, minimumSizeHint)
+
+ZEND_METHOD(QDialog, rejected)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'rejected' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
-
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;minimumSizeHint());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;rejected());
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QDialog_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::rejected(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  extension
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget*
- *    @param    
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QDialog, extension)
+
+ZEND_METHOD(QDialog, event)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+  ///QEvent *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 21)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'event' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QEvent *s0,
+        QDialog *
+          selfpointer;
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+        }
+        QEvent *
+          cpp_arg_0 = static_cast &lt; QEvent * &gt;(php_qt_fetch(arg_0));
 
-/// return: pointer
+        RETURN_BOOL(selfpointer-&gt;event((QEvent *) cpp_arg_0));
+      }
+#endif
 
-/// return value is object: QWidget*
-      *return_object = static_cast &lt; QWidget * &gt;(obj-&gt;extension());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QDialog_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::event(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  setOrientation
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::Orientation orientation
+ * method showEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QShowEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDialog, setOrientation)
+
+/*!
+ * method finished
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int results0
+ * 
+ * @access	public
+ * @return	Q_SIGNALS: void
+ * @flags	
+ */
+
+ZEND_METHOD(QDialog, finished)
 {
-/*! l public*/
-/*! int orientation,  */
+  ///int results0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'finished' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int results0,
+      QDialog *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;finished((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::finished(...) &quot;);
+}
 
-        void *return_object;
+/*!
+ * method orientation
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientation
+ * @flags	c
+ */
 
-        if (getThis() != NULL) {
-          obj-&gt;setOrientation((Qt::Orientation) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+ZEND_METHOD(QDialog, orientation)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'orientation' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;orientation());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::orientation(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  setVisible
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool visible
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QDialog, setVisible)
+
+ZEND_METHOD(QDialog, sizeHint)
 {
-/*! l public*/
-/*! int visible,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-        void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-          obj-&gt;setVisible((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::sizeHint(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  setResult
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int r
+ * method extension
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget*
+ * @flags	c
  */
-ZEND_METHOD(QDialog, setResult)
+
+ZEND_METHOD(QDialog, extension)
 {
-/*! l public*/
-/*! int r,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QWidget           // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'extension' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDialog *
+        selfpointer;
 
-        void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-          obj-&gt;setResult((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;extension());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::extension(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  eventFilter
- *
- *    @flags    
- *    @access    protected
- *    @return    bool
- *    @param    QObject *, QEvent *
+ * method keyPressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method eventFilter is protected, skipped.
 
 /*!
- *    @class     QDialog
- *    @function  accepted
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method accept
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QDialog, accepted)
+
+/*!
+ * method setVisible
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool visibles0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QDialog, setVisible)
 {
-/*  if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+  ///bool visibles0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setVisible' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool visibles0,
+      QDialog *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QDialog *obj = (QDialog *) PHP_QT_FETCH();
-
-      obj-&gt;accepted();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
-  }*/
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setVisible((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::setVisible(...) &quot;);
 }
 
 /*!
- *    @class     QDialog
- *    @function  trUtf8
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
+
 ZEND_METHOD(QDialog, trUtf8)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING) {
-        QDialog *obj = (QDialog *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QDialog *
+        selfpointer;
 
-        QString *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast &lt; QString &gt; (obj-&gt;trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QDialog::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));   /// memory allocation
-          *return_object = static_cast &lt; QString &gt; (QDialog::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        object_init_ex(return_value, QDialog_ce_ptr);
-        zend_rsrc_list_entry le;
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QDialog::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QDialog *
+        selfpointer;
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDialog * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QDialog::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
       } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDialog::trUtf8(...) &quot;);
 }
 
-
-PHP_QT_DESTRUCT(QDialog);
+/*!
+ * method reject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	v
+ */

Modified: trunk/qt/classes/qdragenterevent.cpp
===================================================================
--- trunk/qt/classes/qdragenterevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdragenterevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,81 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDragEnterEvent.cpp - QDragEnterEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QDragEnterEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
+#include &lt;QDragEnterEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QDragEnterEvent_php_qt:public QDragEnterEvent
+{
 
-PHP_QT_DESTRUCT(QDragEnterEvent);
+public:
+  QDragEnterEvent_php_qt(zval * zend_ptr, const QPoint &amp; poss0, Qt::DropActions actionss1, const QMimeData * datas2, Qt::MouseButtons buttonss3,
+                         Qt::KeyboardModifiers modifierss4);
 
+
+  zval *zend_ptr;
+};
+QDragEnterEvent_php_qt::QDragEnterEvent_php_qt(zval * zend_ptr, const QPoint &amp; poss0, Qt::DropActions actionss1, const QMimeData * datas2,
+                                               Qt::MouseButtons buttonss3, Qt::KeyboardModifiers modifierss4):
+QDragEnterEvent(poss0, actionss1, datas2, buttonss3, modifierss4)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QDragEnterEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;poss0s0
+ * @param	Qt::DropActions actionss1s1
+ * @param	const QMimeData   *datas2s2
+ * @param	Qt::MouseButtons buttonss3s3
+ * @param	Qt::KeyboardModifiers modifierss4s4
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QDragEnterEvent, __construct)
+{
+  ///const QPoint &amp;poss0s0,Qt::DropActions actionss1s1,const QMimeData   *datas2s2,Qt::MouseButtons buttonss3s3,Qt::KeyboardModifiers modifierss4s4
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QMimeData
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;poss0s0,Qt::DropActions actionss1s1,const QMimeData   *datas2s2,Qt::MouseButtons buttonss3s3,Qt::KeyboardModifiers modifierss4s4,
+        QPoint *cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QMimeData *cpp_arg_2 = static_cast &lt; QMimeData * &gt;(php_qt_fetch(arg_2));
+        QDragEnterEvent_php_qt *selfpointer =
+          new QDragEnterEvent_php_qt(getThis(), (const QPoint &amp;)*cpp_arg_0, (Qt::DropActions) Z_LVAL_P(arg_1), (const QMimeData *)cpp_arg_2,
+                                     (Qt::MouseButtons) Z_LVAL_P(arg_3), (Qt::KeyboardModifiers) Z_LVAL_P(arg_4));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDragEnterEvent::QDragEnterEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qdragleaveevent.cpp
===================================================================
--- trunk/qt/classes/qdragleaveevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdragleaveevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,62 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDragLeaveEvent.cpp - QDragLeaveEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QDragLeaveEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
+#include &lt;QDragLeaveEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QDragLeaveEvent_php_qt:public QDragLeaveEvent
+{
 
-PHP_QT_DESTRUCT(QDragLeaveEvent);
+public:
+  QDragLeaveEvent_php_qt(zval * zend_ptr);
 
+
+  zval *zend_ptr;
+};
+
+QDragLeaveEvent_php_qt::QDragLeaveEvent_php_qt(zval * zend_ptr):QDragLeaveEvent()
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QDragLeaveEvent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QDragLeaveEvent, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDragLeaveEvent_php_qt *
+        selfpointer = new QDragLeaveEvent_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDragLeaveEvent::QDragLeaveEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qdragmoveevent.cpp
===================================================================
--- trunk/qt/classes/qdragmoveevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdragmoveevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,102 +19,249 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDragMoveEvent.cpp - QDragMoveEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QDragMoveEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QDragMoveEvent */
-/*
- *    function  accept
- *    flags:    
+#include &lt;QDragMoveEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QDragMoveEvent_php_qt:public QDragMoveEvent
+{
+
+public:
+  QDragMoveEvent_php_qt(zval * zend_ptr, const QPoint &amp; poss0, Qt::DropActions actionss1, const QMimeData * datas2, Qt::MouseButtons buttonss3,
+                        Qt::KeyboardModifiers modifierss4, Type type = DragMove);
+
+
+  zval *zend_ptr;
+};
+QDragMoveEvent_php_qt::QDragMoveEvent_php_qt(zval * zend_ptr, const QPoint &amp; poss0, Qt::DropActions actionss1, const QMimeData * datas2,
+                                             Qt::MouseButtons buttonss3, Qt::KeyboardModifiers modifierss4, Type type):
+QDragMoveEvent(poss0, actionss1, datas2, buttonss3, modifierss4, type)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method ignore
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &amp; r
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDragMoveEvent, accept){
-	if (ZEND_NUM_ARGS() == 0){
-			QDragMoveEvent *obj = (QDragMoveEvent*) PHP_QT_FETCH();
-			obj-&gt;accept();
-			RETURN_NULL();
-	}
-		/* o public*/
 
-		/* const QRect&amp; r,  */
+ZEND_METHOD(QDragMoveEvent, ignore)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'ignore' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDragMoveEvent *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDragMoveEvent *obj = (QDragMoveEvent*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDragMoveEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;ignore());
+    }
+  }
+  ///const QRect &amp; r
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'ignore' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp; r,
+        QDragMoveEvent *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDragMoveEvent * &gt;(PHP_QT_FETCH());
+        }
+        QRect *cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot;) {
-				obj-&gt;accept((const QRect&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_VOID(selfpointer-&gt;ignore((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDragMoveEvent::ignore(...) &quot;);
 }
 
-/*********************************
- *    class     QDragMoveEvent */
-/*
- *    function  answerRect
- *    flags:    c
+/*!
+ * method answerRect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-ZEND_METHOD(QDragMoveEvent, answerRect){
-	if (ZEND_NUM_ARGS() == 0){
-			QDragMoveEvent *obj = (QDragMoveEvent*) PHP_QT_FETCH();
-				QRect return_object = (QRect) obj-&gt;answerRect();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDragMoveEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDragMoveEvent, answerRect)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'answerRect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDragMoveEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDragMoveEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QRect *return_object = new QRect;
+
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;answerRect());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDragMoveEvent::answerRect(...) &quot;);
 }
 
-/*********************************
- *    class     QDragMoveEvent */
-/*
- *    function  ignore
- *    flags:    
+/*!
+ * method QDragMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;poss0s0
+ * @param	Qt::DropActions actionss1s1
+ * @param	const QMimeData   *datas2s2
+ * @param	Qt::MouseButtons buttonss3s3
+ * @param	Qt::KeyboardModifiers modifierss4s4
+ * @param	 Type type = DragMoves5
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QDragMoveEvent, ignore){
-	if (ZEND_NUM_ARGS() == 0){
-			QDragMoveEvent *obj = (QDragMoveEvent*) PHP_QT_FETCH();
-			obj-&gt;ignore();
-			RETURN_NULL();
-	}
-		/* o public*/
 
-		/* const QRect&amp; r,  */
+ZEND_METHOD(QDragMoveEvent, __construct)
+{
+  ///const QPoint &amp;poss0s0,Qt::DropActions actionss1s1,const QMimeData   *datas2s2,Qt::MouseButtons buttonss3s3,Qt::KeyboardModifiers modifierss4s4, Type type = DragMoves5
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QMimeData
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;poss0s0,Qt::DropActions actionss1s1,const QMimeData   *datas2s2,Qt::MouseButtons buttonss3s3,Qt::KeyboardModifiers modifierss4s4,
+        QPoint *cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QMimeData *cpp_arg_2 = static_cast &lt; QMimeData * &gt;(php_qt_fetch(arg_2));
+        QDragMoveEvent_php_qt *selfpointer =
+          new QDragMoveEvent_php_qt(getThis(), (const QPoint &amp;)*cpp_arg_0, (Qt::DropActions) Z_LVAL_P(arg_1), (const QMimeData *)cpp_arg_2,
+                                    (Qt::MouseButtons) Z_LVAL_P(arg_3), (Qt::KeyboardModifiers) Z_LVAL_P(arg_4));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QDragMoveEvent *obj = (QDragMoveEvent*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+#endif
 
-
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot;) {
-				obj-&gt;ignore((const QRect&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+// notice: unknown argument  Type type = DragMoves5, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QDragMoveEvent::QDragMoveEvent(...) &quot;);
 }
 
+/*!
+ * method accept
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &amp; r
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QDragMoveEvent);
+ZEND_METHOD(QDragMoveEvent, accept)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'accept' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDragMoveEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDragMoveEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;accept());
+    }
+  }
+  ///const QRect &amp; r
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'accept' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp; r,
+        QDragMoveEvent *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QDragMoveEvent * &gt;(PHP_QT_FETCH());
+        }
+        QRect *cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;accept((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDragMoveEvent::accept(...) &quot;);
+}

Modified: trunk/qt/classes/qdragresponseevent.cpp
===================================================================
--- trunk/qt/classes/qdragresponseevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdragresponseevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,30 +19,98 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDragResponseEvent.cpp - QDragResponseEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QDragResponseEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QDragResponseEvent */
-/*
- *    function  dragAccepted
- *    flags:    c
+#include &lt;QDragResponseEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QDragResponseEvent_php_qt:public QDragResponseEvent
+{
+
+public:
+  QDragResponseEvent_php_qt(zval * zend_ptr, bool accepteds0);
+
+
+  zval *zend_ptr;
+};
+
+QDragResponseEvent_php_qt::QDragResponseEvent_php_qt(zval * zend_ptr, bool accepteds0):QDragResponseEvent(accepteds0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method dragAccepted
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDragResponseEvent, dragAccepted){
-	if (ZEND_NUM_ARGS() == 0){
-			QDragResponseEvent *obj = (QDragResponseEvent*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;dragAccepted());
-	}
+
+ZEND_METHOD(QDragResponseEvent, dragAccepted)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'dragAccepted' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDragResponseEvent *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDragResponseEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;dragAccepted());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDragResponseEvent::dragAccepted(...) &quot;);
 }
 
+/*!
+ * method QDragResponseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool accepteds0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QDragResponseEvent);
+ZEND_METHOD(QDragResponseEvent, __construct)
+{
+  ///bool accepteds0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool accepteds0s0,
+      QDragResponseEvent_php_qt *
+        selfpointer = new QDragResponseEvent_php_qt(getThis(), (bool) Z_LVAL_P(arg_0));
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDragResponseEvent::QDragResponseEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qdropevent.cpp
===================================================================
--- trunk/qt/classes/qdropevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qdropevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,274 +19,582 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QDropEvent.cpp - QDropEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QDropEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  encodedData
- *    flags:    c
- */
-ZEND_METHOD(QDropEvent, encodedData){
-		/* s public*/
+#include &lt;QDropEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QDropEvent_php_qt:public QDropEvent
+{
 
-		/* const char* ,  */
+public:
+  QDropEvent_php_qt(zval * zend_ptr, const QPoint &amp; poss0, Qt::DropActions actionss1, const QMimeData * datas2, Qt::MouseButtons buttonss3,
+                    Qt::KeyboardModifiers modifierss4, Type type = Drop);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING){
-//			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
 
-
-//			RETURN_STRING((char*) obj-&gt;encodedData( (const char*) Z_STRVAL_P(z_0)), 1);
-			}
-		}
-	}
+  zval *zend_ptr;
+};
+QDropEvent_php_qt::QDropEvent_php_qt(zval * zend_ptr, const QPoint &amp; poss0, Qt::DropActions actionss1, const QMimeData * datas2, Qt::MouseButtons buttonss3,
+                                     Qt::KeyboardModifiers modifierss4, Type type):
+QDropEvent(poss0, actionss1, datas2, buttonss3, modifierss4, type)
+{
+  this-&gt;zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  source
- *    flags:    c
+/*!
+ * method dropAction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::DropAction
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, source){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-				QWidget* return_object = (QWidget*) obj-&gt;source();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDropEvent, dropAction)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'dropAction' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;dropAction());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::dropAction(...) &quot;);
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  keyboardModifiers
- *    flags:    c
+/*!
+ * method acceptProposedAction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDropEvent, keyboardModifiers){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-				Qt::KeyboardModifiers return_object = (Qt::KeyboardModifiers) obj-&gt;keyboardModifiers();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDropEvent, acceptProposedAction)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'acceptProposedAction' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;acceptProposedAction());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::acceptProposedAction(...) &quot;);
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  setDropAction
- *    flags:    
+/*!
+ * method mimeData
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QMimeData *
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, setDropAction){
-		/* l public*/
 
-		/* int action,  */
+ZEND_METHOD(QDropEvent, mimeData)
+{
+  ///
+#ifdef PHP_QT_QMimeData         // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'mimeData' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setDropAction((Qt::DropAction) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast &lt; QMimeData * &gt;(selfpointer-&gt;mimeData());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::mimeData(...) &quot;);
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  acceptProposedAction
- *    flags:    
+/*!
+ * method provides
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, acceptProposedAction){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-			obj-&gt;acceptProposedAction();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QDropEvent, provides)
+{
+  ///const char *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'provides' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try const char *s0,
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;provides((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::provides(...) &quot;);
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  dropAction
- *    flags:    c
+/*!
+ * method source
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget*
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, dropAction){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;dropAction());
-	}
+
+ZEND_METHOD(QDropEvent, source)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'source' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;source());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::source(...) &quot;);
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  mimeData
- *    flags:    c
+/*!
+ * method mouseButtons
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::MouseButtons
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, mimeData){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-				const QMimeData * return_object = (const QMimeData *) obj-&gt;mimeData();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDropEvent, mouseButtons)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'mouseButtons' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;mouseButtons());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::mouseButtons(...) &quot;);
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  provides
- *    flags:    c
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &amp;
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, provides){
-		/* s public*/
 
-		/* const char* ,  */
+ZEND_METHOD(QDropEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_BOOL(obj-&gt;provides( (const char*) Z_STRVAL_P(z_0)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::pos(...) &quot;);
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  format
- *    flags:    c
+/*!
+ * method possibleActions
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::DropActions
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, format){
-		/* l public*/
 
-		/* int n,  */
+ZEND_METHOD(QDropEvent, possibleActions)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'possibleActions' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;possibleActions());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::possibleActions(...) &quot;);
+}
 
+/*!
+ * method proposedAction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::DropAction
+ * @flags	c
+ */
 
-				const char* return_object = (const char*) obj-&gt;format((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+ZEND_METHOD(QDropEvent, proposedAction)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'proposedAction' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;proposedAction());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::proposedAction(...) &quot;);
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  mouseButtons
- *    flags:    c
+/*!
+ * method keyboardModifiers
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::KeyboardModifiers
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, mouseButtons){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-				Qt::MouseButtons return_object = (Qt::MouseButtons) obj-&gt;mouseButtons();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDropEvent, keyboardModifiers)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'keyboardModifiers' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;keyboardModifiers());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::keyboardModifiers(...) &quot;);
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  proposedAction
- *    flags:    c
+/*!
+ * method setDropAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::DropAction actions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QDropEvent, proposedAction){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;proposedAction());
-	}
+
+ZEND_METHOD(QDropEvent, setDropAction)
+{
+  ///Qt::DropAction actions0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setDropAction' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::DropAction actions0,
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setDropAction((Qt::DropAction) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::setDropAction(...) &quot;);
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method encodedData
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *s0
+ * 
+ * @access	public
+ * @return	QByteArray
+ * @flags	c
  */
-ZEND_METHOD(QDropEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-				const QPoint &amp; return_object = (const QPoint &amp;) obj-&gt;pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDropEvent, encodedData)
+{
+  ///const char *s0
+#ifdef PHP_QT_QByteArray        // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'encodedData' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try const char *s0,
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QByteArray *return_object = new QByteArray;
+
+      *return_object = static_cast &lt; QByteArray &gt; (selfpointer-&gt;encodedData((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::encodedData(...) &quot;);
 }
 
-/*********************************
- *    class     QDropEvent */
-/*
- *    function  possibleActions
- *    flags:    c
+/*!
+ * method QDropEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp; poss0s0
+ * @param	Qt::DropActions actionss1s1
+ * @param	const QMimeData  *datas2s2
+ * @param	Qt::MouseButtons buttonss3s3
+ * @param	Qt::KeyboardModifiers modifierss4s4
+ * @param	 Type type = Drops5
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QDropEvent, possibleActions){
-	if (ZEND_NUM_ARGS() == 0){
-			QDropEvent *obj = (QDropEvent*) PHP_QT_FETCH();
-				Qt::DropActions return_object = (Qt::DropActions) obj-&gt;possibleActions();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QDropEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QDropEvent, __construct)
+{
+  ///const QPoint &amp; poss0s0,Qt::DropActions actionss1s1,const QMimeData  *datas2s2,Qt::MouseButtons buttonss3s3,Qt::KeyboardModifiers modifierss4s4, Type type = Drops5
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QMimeData
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp; poss0s0,Qt::DropActions actionss1s1,const QMimeData  *datas2s2,Qt::MouseButtons buttonss3s3,Qt::KeyboardModifiers modifierss4s4,
+        QPoint *cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QMimeData *cpp_arg_2 = static_cast &lt; QMimeData * &gt;(php_qt_fetch(arg_2));
+        QDropEvent_php_qt *selfpointer =
+          new QDropEvent_php_qt(getThis(), (const QPoint &amp;)*cpp_arg_0, (Qt::DropActions) Z_LVAL_P(arg_1), (const QMimeData *)cpp_arg_2,
+                                (Qt::MouseButtons) Z_LVAL_P(arg_3), (Qt::KeyboardModifiers) Z_LVAL_P(arg_4));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+// notice: unknown argument  Type type = Drops5, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::QDropEvent(...) &quot;);
 }
 
+/*!
+ * method format
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int n = 0s0
+ * 
+ * @access	public
+ * @return	const char*
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QDropEvent);
+ZEND_METHOD(QDropEvent, format)
+{
+  ///int n = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'format' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QDropEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer-&gt;format(), 1);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'format' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int n = 0s0,
+      QDropEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QDropEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer-&gt;format((int)Z_LVAL_P(arg_0)), 1);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QDropEvent::format(...) &quot;);
+}

Modified: trunk/qt/classes/qfileopenevent.cpp
===================================================================
--- trunk/qt/classes/qfileopenevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qfileopenevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,36 +19,117 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QFileOpenEvent.cpp - QFileOpenEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QFileOpenEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QFileOpenEvent */
-/*
- *    function  file
- *    flags:    c
+#include &lt;QFileOpenEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QFileOpenEvent_php_qt:public QFileOpenEvent
+{
+
+public:
+  QFileOpenEvent_php_qt(zval * zend_ptr, const QString &amp; files0);
+
+
+  zval *zend_ptr;
+};
+QFileOpenEvent_php_qt::QFileOpenEvent_php_qt(zval * zend_ptr, const QString &amp; files0):
+QFileOpenEvent(files0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method file
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QFileOpenEvent, file){
-	if (ZEND_NUM_ARGS() == 0){
-			QFileOpenEvent *obj = (QFileOpenEvent*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;file();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFileOpenEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFileOpenEvent, file)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'file' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFileOpenEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFileOpenEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;file());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFileOpenEvent::file(...) &quot;);
 }
 
+/*!
+ * method QFileOpenEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;files0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QFileOpenEvent);
+ZEND_METHOD(QFileOpenEvent, __construct)
+{
+  ///const QString &amp;files0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;files0s0,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QFileOpenEvent_php_qt *selfpointer = new QFileOpenEvent_php_qt(getThis(), (const QString &amp;)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFileOpenEvent::QFileOpenEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qfocusevent.cpp
===================================================================
--- trunk/qt/classes/qfocusevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qfocusevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,62 +19,152 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QFocusEvent.cpp - QFocusEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QFocusEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QFocusEvent */
-/*
- *    function  lostFocus
- *    flags:    c
+#include &lt;QFocusEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QFocusEvent_php_qt:public QFocusEvent
+{
+
+public:
+  QFocusEvent_php_qt(zval * zend_ptr, Type types0, Qt::FocusReason reason = Qt::OtherFocusReason);
+
+
+  zval *zend_ptr;
+};
+
+QFocusEvent_php_qt::QFocusEvent_php_qt(zval * zend_ptr, Type types0, Qt::FocusReason reason):QFocusEvent(types0, reason)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method gotFocus
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFocusEvent, lostFocus){
-	if (ZEND_NUM_ARGS() == 0){
-			QFocusEvent *obj = (QFocusEvent*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;lostFocus());
-	}
+
+ZEND_METHOD(QFocusEvent, gotFocus)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'gotFocus' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFocusEvent *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFocusEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;gotFocus());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFocusEvent::gotFocus(...) &quot;);
 }
 
-/*********************************
- *    class     QFocusEvent */
-/*
- *    function  reason
- *    flags:    
+/*!
+ * method reason
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::FocusReason
+ * @flags	
  */
-ZEND_METHOD(QFocusEvent, reason){
-	if (ZEND_NUM_ARGS() == 0){
-			QFocusEvent *obj = (QFocusEvent*) PHP_QT_FETCH();
-				Qt::FocusReason return_object = (Qt::FocusReason) obj-&gt;reason();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFocusEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFocusEvent, reason)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'reason' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFocusEvent *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFocusEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;reason());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFocusEvent::reason(...) &quot;);
 }
 
-/*********************************
- *    class     QFocusEvent */
-/*
- *    function  gotFocus
- *    flags:    c
+/*!
+ * method lostFocus
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFocusEvent, gotFocus){
-	if (ZEND_NUM_ARGS() == 0){
-			QFocusEvent *obj = (QFocusEvent*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;gotFocus());
-	}
+
+ZEND_METHOD(QFocusEvent, lostFocus)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'lostFocus' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFocusEvent *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFocusEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;lostFocus());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFocusEvent::lostFocus(...) &quot;);
 }
 
+/*!
+ * method QFocusEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	 Qt::FocusReason reason=Qt::OtherFocusReasons1
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QFocusEvent);
-
+ZEND_METHOD(QFocusEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QFocusEvent::QFocusEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qfont.cpp
===================================================================
--- trunk/qt/classes/qfont.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qfont.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,1302 +19,2362 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QFont.cpp - QFont PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QFont&gt;
 #include &quot;../php_qt.h&quot;
 
+
+#include &lt;QFont&gt;
 #include &lt;QStringList&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QFont_php_qt:public QFont
+{
 
+public:
+  QFont_php_qt(zval * zend_ptr);
+  QFont_php_qt(zval * zend_ptr, const QString &amp; familys0, int pointSize = -1, int weight = -1, bool italic = false);
+    QFont_php_qt(zval * zend_ptr, const QFont &amp; s0, QPaintDevice * pds1);
+    QFont_php_qt(zval * zend_ptr, const QFont &amp; s0);
 
-/*		public enumStyleHint:long {
-			StyleHint = 0,
-			SansSerif = Helvetica,
-			StyleHint = 2,
-			Serif = Times,
-			StyleHint = 4,
-			TypeWriter = Courier,
-			StyleHint = 6,
-			Decorative = OldEnglish,
-			StyleHint = 8,
-			StyleHint = 9
-		}
-*/
 
-/*		public enumStyleStrategy:long {
-			PreferDefault = 0x0001,
-			PreferBitmap = 0x0002,
-			PreferDevice = 0x0004,
-			PreferOutline = 0x0008,
-			ForceOutline = 0x0010,
-			PreferMatch = 0x0020,
-			PreferQuality = 0x0040,
-			PreferAntialias = 0x0080,
-			NoAntialias = 0x0100,
-			OpenGLCompatible = 0x0200
-		}
-*/
+  zval *zend_ptr;
+};
 
-/*		public enumWeight:long {
-			Light = 25,
-			Normal = 50,
-			DemiBold = 63,
-			Bold = 75,
-			Black = 87
-		}
-*/
+QFont_php_qt::QFont_php_qt(zval * zend_ptr):QFont()
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QFont_php_qt::QFont_php_qt(zval * zend_ptr, const QString &amp; familys0, int pointSize, int weight, bool italic):
+QFont(familys0, pointSize, weight, italic)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QFont_php_qt::QFont_php_qt(zval * zend_ptr, const QFont &amp; s0, QPaintDevice * pds1):
+QFont(s0, pds1)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QFont_php_qt::QFont_php_qt(zval * zend_ptr, const QFont &amp; s0):
+QFont(s0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
 
-/*		public enumStyle:long {
-			Style = 0,
-			Style = 1,
-			Style = 2
-		}
-*/
-
-/*		public enumStretch:long {
-			UltraCondensed = 50,
-			ExtraCondensed = 62,
-			Condensed = 75,
-			SemiCondensed = 87,
-			Unstretched = 100,
-			SemiExpanded = 112,
-			Expanded = 125,
-			ExtraExpanded = 150,
-			UltraExpanded = 200
-		}
-*/
-/*********************************
- *    class     QFont */
-/*
- *    function  setOverline
- *    flags:    
+/*!
+ * method stretch
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFont, setOverline){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, stretch)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'stretch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;stretch());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::stretch(...) &quot;);
+}
 
+/*!
+ * method underline
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-			obj-&gt;setOverline((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QFont, underline)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'underline' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;underline());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::underline(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  insertSubstitution
- *    flags:    s
+/*!
+ * method fixedPitch
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, insertSubstitution){
-		/* oo public*/
 
-		/* const QString&amp; , const QString&amp; ,  */
+ZEND_METHOD(QFont, fixedPitch)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'fixedPitch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;fixedPitch());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::fixedPitch(...) &quot;);
+}
 
+/*!
+ * method italic
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot;) {
-				obj-&gt;insertSubstitution((const QString&amp;) obj_z_0, (const QString&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QFont, italic)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'italic' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;italic());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::italic(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  stretch
- *    flags:    c
+/*!
+ * method pixelSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFont, stretch){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;stretch());
-	}
+
+ZEND_METHOD(QFont, pixelSize)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pixelSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;pixelSize());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::pixelSize(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  styleStrategy
- *    flags:    c
+/*!
+ * method insertSubstitutions
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * @param	 const QStringList &amp;s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QFont, styleStrategy){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;styleStrategy());
-	}
+
+ZEND_METHOD(QFont, insertSubstitutions)
+{
+  ///const QString &amp;s0, const QStringList &amp;s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QStringList
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        /// try const QString &amp;s0, const QStringList &amp;s1,
+        QFont *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QStringList *cpp_arg_1 = static_cast &lt; QStringList * &gt;(php_qt_fetch(arg_1));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QFont::insertSubstitutions((const QString &amp;)*cpp_arg_0, (const QStringList &amp;)*cpp_arg_1));
+        } else {
+          RETURN_VOID(selfpointer-&gt;insertSubstitutions((const QString &amp;)*cpp_arg_0, (const QStringList &amp;)*cpp_arg_1));
+      }}
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::insertSubstitutions(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setKerning
- *    flags:    
+/*!
+ * method key
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QFont, setKerning){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, key)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'key' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setKerning((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;key());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFont::key(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  underline
- *    flags:    c
+/*!
+ * method setStrikeOut
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, underline){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;underline());
-	}
+
+ZEND_METHOD(QFont, setStrikeOut)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setStrikeOut' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setStrikeOut((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setStrikeOut(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  removeSubstitution
- *    flags:    s
+/*!
+ * method fromString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QFont, removeSubstitution){
-		/* o public*/
 
-		/* const QString&amp; ,  */
+ZEND_METHOD(QFont, fromString)
+{
+  ///const QString &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'fromString' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QFont *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				obj-&gt;removeSubstitution((const QString&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_BOOL(selfpointer-&gt;fromString((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::fromString(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  substitute
- *    flags:    s
+/*!
+ * method exactMatch
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, substitute){
-		/* o public*/
 
-		/* const QString&amp; ,  */
+ZEND_METHOD(QFont, exactMatch)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'exactMatch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;exactMatch());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::exactMatch(...) &quot;);
+}
 
+/*!
+ * method handle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::HANDLE
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QString return_object = (QString) obj-&gt;substitute((const QString&amp;) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+ZEND_METHOD(QFont, handle)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'handle' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;handle());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::handle(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setBold
- *    flags:    
+/*!
+ * method setStyle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Style styles0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, setBold){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, setStyle)
+{
+// notice: unknown argument Style styles0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setStyle(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+/*!
+ * method setUnderline
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QFont, setUnderline)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setUnderline' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
 
-			obj-&gt;setBold((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setUnderline((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setUnderline(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  resolve
- *    flags:    c
+/*!
+ * method family
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QFont, resolve){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;resolve());
-	}
-		/* l public*/
 
-		/* unsigned int mask,  */
-		/* o public*/
+ZEND_METHOD(QFont, family)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-		/* const QFont&amp; ,  */
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'family' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-			obj-&gt;resolve((uint) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;family());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QFont&quot;) {
-					QFont return_object = (QFont) obj-&gt;resolve((const QFont&amp;) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+  php_error(E_ERROR, &quot;could not parse argument in QFont::family(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  fixedPitch
- *    flags:    c
+/*!
+ * method rawMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, fixedPitch){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;fixedPitch());
-	}
+
+ZEND_METHOD(QFont, rawMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'rawMode' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;rawMode());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::rawMode(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  italic
- *    flags:    c
+/*!
+ * method operator QVariant
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	c
  */
-ZEND_METHOD(QFont, italic){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;italic());
-	}
-}
 
-/*********************************
- *    class     QFont */
-/*
- *    function  pixelSize
- *    flags:    c
+/*!
+ * method setStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, pixelSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;pixelSize());
-	}
+
+ZEND_METHOD(QFont, setStretch)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setStretch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setStretch((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setStretch(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  insertSubstitutions
- *    flags:    s
+/*!
+ * method operator&lt;
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &amp;s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, insertSubstitutions){
-		/* oo public*/
 
-		/* const QString&amp; , const QStringList&amp; ,  */
+/*!
+ * method operator==
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &amp;s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+/*!
+ * method defaultFamily
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
+ZEND_METHOD(QFont, defaultFamily)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QStringList&quot;) {
-				obj-&gt;insertSubstitutions((const QString&amp;) obj_z_0, (const QStringList&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'defaultFamily' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;defaultFamily());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFont::defaultFamily(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  key
- *    flags:    c
+/*!
+ * method kerning
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, key){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;key();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFont, kerning)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'kerning' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;kerning());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::kerning(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setStrikeOut
- *    flags:    
+/*!
+ * method QFont
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;familys0
+ * @param	 int pointSize = -1
+ * @param	 int weight = -1
+ * @param	 bool italic = false
+ * 
+ * overloaded args:
+ * @param	const QFont &amp;s0
+ * @param	QPaintDevice  *pds1
+ * 
+ * overloaded args:
+ * @param	const QFont &amp;s0
+ * 
+ * overloaded args:
+ * @param	QFontPrivate *
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QFont, setStrikeOut){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont_php_qt *selfpointer = new QFont_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QString &amp;familys0, int pointSize = -1, int weight = -1, bool italic = false
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;familys0,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QString &amp;)*cpp_arg_0);
 
-			obj-&gt;setStrikeOut((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;familys0, int pointSize = -1,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1));
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;familys0, int pointSize = -1, int weight = -1,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2));
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_BOOL) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;familys0, int pointSize = -1, int weight = -1, bool italic = false,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QFont_php_qt *selfpointer =
+          new QFont_php_qt(getThis(), (const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (bool) Z_LVAL_P(arg_3));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QFont &amp;s0,QPaintDevice  *pds1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+#ifdef PHP_QT_QPaintDevice
+      if (inherits(Z_OBJCE_P(arg_0), 24) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 49)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QFont &amp;s0,QPaintDevice  *pds1,
+        QFont *cpp_arg_0 = static_cast &lt; QFont * &gt;(php_qt_fetch(arg_0));
+        QPaintDevice *cpp_arg_1 = static_cast &lt; QPaintDevice * &gt;(php_qt_fetch(arg_1));
+        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QFont &amp;)*cpp_arg_0, (QPaintDevice *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QFont &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QFont &amp;s0,
+        QFont *cpp_arg_0 = static_cast &lt; QFont * &gt;(php_qt_fetch(arg_0));
+        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QFont &amp;)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///QFontPrivate *
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFontPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QFont::__construct(...) cannot be called with 'QFontPrivate *,'.&quot;);
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::QFont(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  weight
- *    flags:    c
+/*!
+ * method bold
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, weight){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;weight());
-	}
+
+ZEND_METHOD(QFont, bold)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'bold' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;bold());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::bold(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  pointSize
- *    flags:    c
+/*!
+ * method style
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Style
+ * @flags	c
  */
-ZEND_METHOD(QFont, pointSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;pointSize());
-	}
+
+ZEND_METHOD(QFont, style)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type Style&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::style(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  cleanup
- *    flags:    s
+/*!
+ * method setStyleStrategy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	StyleStrategy ss0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, cleanup){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			obj-&gt;cleanup();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QFont, setStyleStrategy)
+{
+// notice: unknown argument StyleStrategy ss0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setStyleStrategy(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  fromString
- *    flags:    
+/*!
+ * method cacheStatistics
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QFont, fromString){
-		/* o public*/
 
-		/* const QString&amp; ,  */
+ZEND_METHOD(QFont, cacheStatistics)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QFont::cacheStatistics());
+      } else {
+        RETURN_VOID(selfpointer-&gt;cacheStatistics());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::cacheStatistics(...) &quot;);
+}
 
+/*!
+ * method lastResortFont
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				RETURN_BOOL(obj-&gt;fromString((const QString&amp;) obj_z_0));
-			}
-			}
-		}
-	}
+ZEND_METHOD(QFont, lastResortFont)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'lastResortFont' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;lastResortFont());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFont::lastResortFont(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  exactMatch
- *    flags:    c
+/*!
+ * method lastResortFamily
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QFont, exactMatch){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;exactMatch());
-	}
+
+ZEND_METHOD(QFont, lastResortFamily)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'lastResortFamily' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;lastResortFamily());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFont::lastResortFamily(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setWeight
- *    flags:    
+/*!
+ * method overline
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, setWeight){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, overline)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'overline' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;overline());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::overline(...) &quot;);
+}
 
+/*!
+ * method setPointSizeF
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	qreal qreals0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj-&gt;setWeight((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QFont, setPointSizeF)
+{
+// notice: unknown argument qreal qreals0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setPointSizeF(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  styleHint
- *    flags:    c
+/*!
+ * method pointSizeF
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
-ZEND_METHOD(QFont, styleHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;styleHint());
-	}
+
+ZEND_METHOD(QFont, pointSizeF)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type qreal&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::pointSizeF(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  handle
- *    flags:    c
+/*!
+ * method setOverline
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, handle){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				Qt::HANDLE return_object = (Qt::HANDLE) obj-&gt;handle();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFont, setOverline)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setOverline' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setOverline((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setOverline(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setStyle
- *    flags:    
+/*!
+ * method insertSubstitution
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * @param	 const QString &amp;s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QFont, setStyle){
-		/* o public*/
 
-		/* QFont::Style style,  */
+ZEND_METHOD(QFont, insertSubstitution)
+{
+  ///const QString &amp;s0, const QString &amp;s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        /// try const QString &amp;s0, const QString &amp;s1,
+        QFont *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
 
-			obj-&gt;setStyle((QFont::Style) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_VOID(QFont::insertSubstitution((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        } else {
+          RETURN_VOID(selfpointer-&gt;insertSubstitution((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+      }}
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::insertSubstitution(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  rawName
- *    flags:    c
+/*!
+ * method operator!=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &amp;s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, rawName){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;rawName();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setUnderline
- *    flags:    
+/*!
+ * method styleStrategy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	StyleStrategy
+ * @flags	c
  */
-ZEND_METHOD(QFont, setUnderline){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, styleStrategy)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type StyleStrategy&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::styleStrategy(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+/*!
+ * method setKerning
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QFont, setKerning)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setKerning' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
 
-			obj-&gt;setUnderline((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setKerning((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setKerning(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  family
- *    flags:    c
+/*!
+ * method removeSubstitution
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QFont, family){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;family();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFont, removeSubstitution)
+{
+  ///const QString &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;s0,
+        QFont *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QFont::removeSubstitution((const QString &amp;)*cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;removeSubstitution((const QString &amp;)*cpp_arg_0));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::removeSubstitution(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  isCopyOf
- *    flags:    c
+/*!
+ * method substitute
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QFont, isCopyOf){
-		/* o public*/
 
-		/* const QFont&amp; ,  */
+ZEND_METHOD(QFont, substitute)
+{
+  ///const QString &amp;s0
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;s0,
+        QFont *selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QFont&quot;) {
-				RETURN_BOOL(obj-&gt;isCopyOf((const QFont&amp;) obj_z_0));
-			}
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QString &gt; (QFont::substitute((const QString &amp;)*cpp_arg_0));
+        } else {
+          *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;substitute((const QString &amp;)*cpp_arg_0));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFont::substitute(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  rawMode
- *    flags:    c
+/*!
+ * method setBold
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, rawMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;rawMode());
-	}
+
+ZEND_METHOD(QFont, setBold)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setBold' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setBold((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setBold(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  substitutes
- *    flags:    s
+/*!
+ * method resolve
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &amp;s0
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uint mask
+ * 
+ * @access	public
+ * @return	QFont
+ * @flags	c
  */
-ZEND_METHOD(QFont, substitutes){
-		/* o public*/
 
-		/* const QString&amp; ,  */
+ZEND_METHOD(QFont, resolve)
+{
+  ///const QFont &amp;s0
+#ifdef PHP_QT_QFont             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'resolve' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QFont &amp;s0,
+        QFont *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+        }
+        QFont *cpp_arg_0 = static_cast &lt; QFont * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QStringList return_object = (QStringList) obj-&gt;substitutes((const QString&amp;) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QFont *return_object = new QFont;
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setStretch
- *    flags:    
- */
-ZEND_METHOD(QFont, setStretch){
-		/* l public*/
+        *return_object = static_cast &lt; QFont &gt; (selfpointer-&gt;resolve((const QFont &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-		/* int ,  */
+    }
+  }
+#endif // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
 
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'resolve' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-			obj-&gt;setStretch((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;resolve());
+    }
+  }
+  ///uint mask
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'resolve' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try uint mask,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;resolve((uint) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::resolve(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  initialize
- *    flags:    s
+/*!
+ * method weight
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFont, initialize){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			obj-&gt;initialize();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QFont, weight)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'weight' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;weight());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::weight(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  toString
- *    flags:    c
+/*!
+ * method pointSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFont, toString){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;toString();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFont, pointSize)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pointSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;pointSize());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::pointSize(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  defaultFamily
- *    flags:    c
+/*!
+ * method cleanup
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QFont, defaultFamily){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;defaultFamily();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QFont, cleanup)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QFont::cleanup());
+      } else {
+        RETURN_VOID(selfpointer-&gt;cleanup());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::cleanup(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setRawMode
- *    flags:    
+/*!
+ * method setWeight
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, setRawMode){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, setWeight)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setWeight' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-
-
-			obj-&gt;setRawMode((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setWeight((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setWeight(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  kerning
- *    flags:    c
+/*!
+ * method styleHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	StyleHint
+ * @flags	c
  */
-ZEND_METHOD(QFont, kerning){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;kerning());
-	}
+
+ZEND_METHOD(QFont, styleHint)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type StyleHint&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::styleHint(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setStyleHint
- *    flags:    
+/*!
+ * method rawName
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QFont, setStyleHint){
-		/* ll public*/
 
-		/* int , int ,  */
+ZEND_METHOD(QFont, rawName)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'rawName' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setStyleHint((QFont::StyleHint) Z_LVAL_P(z_0) ,(QFont::StyleStrategy) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-/*********************************
- *    class     QFont */
-/*
- *    function  substitutions
- *    flags:    s
- */
-ZEND_METHOD(QFont, substitutions){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QStringList return_object = (QStringList) obj-&gt;substitutions();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;rawName());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFont::rawName(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setFamily
- *    flags:    
+/*!
+ * method isCopyOf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &amp;s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, setFamily){
-		/* o public*/
 
-		/* const QString&amp; ,  */
+ZEND_METHOD(QFont, isCopyOf)
+{
+  ///const QFont &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'isCopyOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QFont &amp;s0,
+        QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+        }
+        QFont *cpp_arg_0 = static_cast &lt; QFont * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_BOOL(selfpointer-&gt;isCopyOf((const QFont &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				obj-&gt;setFamily((const QString&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::isCopyOf(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  QFont
- *    flags:    
+/*!
+ * method substitutes
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	QStringList
+ * @flags	s
  */
-ZEND_METHOD(QFont, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *QFont_ptr = new QFont();
-				PHP_QT_REGISTER(QFont_ptr);
-				RETURN_NULL();
-	}
-		/* o public*/
 
-		/* const QFont&amp; ,  */
+ZEND_METHOD(QFont, substitutes)
+{
+  ///const QString &amp;s0
+#ifdef PHP_QT_QStringList       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;s0,
+        QFont *selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QFont&quot;) {
-				QFont *QFont_ptr = new QFont((const QFont&amp;) obj_z_0);
-				PHP_QT_REGISTER(QFont_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ol public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-		/* const QFont&amp; , qt_QPaintDevice* pd,  */
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QStringList *return_object = new QStringList;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QStringList &gt; (QFont::substitutes((const QString &amp;)*cpp_arg_0));
+        } else {
+          *return_object = static_cast &lt; QStringList &gt; (selfpointer-&gt;substitutes((const QString &amp;)*cpp_arg_0));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
+    }
+  }
+#endif // return type
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QFont&quot;) {
-				QFont *QFont_ptr = new QFont((const QFont&amp;) obj_z_0, (QPaintDevice*) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QFont_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* olll public*/
+  php_error(E_ERROR, &quot;could not parse argument in QFont::substitutes(...) &quot;);
+}
 
-		/* const QString&amp; family, int pointSize, int weight, int italic,  */
+/*!
+ * method detach
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	private
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-
-
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				QFont *QFont_ptr = new QFont((const QString&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (bool) Z_LVAL_P(z_3));
-				PHP_QT_REGISTER(QFont_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QFont, detach)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QFont::detach(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::detach(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  bold
- *    flags:    c
+/*!
+ * method initialize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QFont, bold){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;bold());
-	}
-}
 
-/*********************************
- *    class     QFont */
-/*
- *    function  style
- *    flags:    c
- */
-ZEND_METHOD(QFont, style){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QFont::Style return_object = (QFont::Style) obj-&gt;style();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QFont, initialize)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_VOID(QFont::initialize());
+      } else {
+        RETURN_VOID(selfpointer-&gt;initialize());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::initialize(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setPointSize
- *    flags:    
+/*!
+ * method toString
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QFont, setPointSize){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, toString)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toString' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setPointSize((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toString());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFont::toString(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setRawName
- *    flags:    
+/*!
+ * method setRawMode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, setRawName){
-		/* o public*/
 
-		/* const QString&amp; ,  */
+ZEND_METHOD(QFont, setRawMode)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setRawMode' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setRawMode((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setRawMode(...) &quot;);
+}
 
+/*!
+ * method setStyleHint
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	StyleHint StyleHints0
+ * @param	 StyleStrategy = PreferDefaults1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				obj-&gt;setRawName((const QString&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QFont, setStyleHint)
+{
+// notice: unknown argument StyleHint StyleHints0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setStyleHint(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setStyleStrategy
- *    flags:    
+/*!
+ * method substitutions
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QStringList
+ * @flags	s
  */
-ZEND_METHOD(QFont, setStyleStrategy){
-		/* l public*/
 
-		/* int s,  */
+ZEND_METHOD(QFont, substitutions)
+{
+  ///
+#ifdef PHP_QT_QStringList       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QFont *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setStyleStrategy((QFont::StyleStrategy) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QStringList *return_object = new QStringList;
 
-/*********************************
- *    class     QFont */
-/*
- *    function  cacheStatistics
- *    flags:    s
- */
-ZEND_METHOD(QFont, cacheStatistics){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			obj-&gt;cacheStatistics();
-			RETURN_NULL();
-	}
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QStringList &gt; (QFont::substitutions());
+      } else {
+        *return_object = static_cast &lt; QStringList &gt; (selfpointer-&gt;substitutions());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFont::substitutions(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setPixelSize
- *    flags:    
+/*!
+ * method setFamily
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, setPixelSize){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, setFamily)
+{
+  ///const QString &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setFamily' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QFont *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			obj-&gt;setPixelSize((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        RETURN_VOID(selfpointer-&gt;setFamily((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setFamily(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setFixedPitch
- *    flags:    
+/*!
+ * method setPointSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, setFixedPitch){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFont, setPointSize)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setPointSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-
-
-			obj-&gt;setFixedPitch((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setPointSize((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setPointSize(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setItalic
- *    flags:    
+/*!
+ * method setRawName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, setItalic){
-		/* l public*/
 
-		/* int b,  */
+ZEND_METHOD(QFont, setRawName)
+{
+  ///const QString &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setRawName' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QFont *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			obj-&gt;setItalic((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        RETURN_VOID(selfpointer-&gt;setRawName((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setRawName(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  strikeOut
- *    flags:    c
+/*!
+ * method setFixedPitch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, strikeOut){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;strikeOut());
-	}
+
+ZEND_METHOD(QFont, setFixedPitch)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setFixedPitch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setFixedPitch((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setFixedPitch(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  lastResortFont
- *    flags:    c
+/*!
+ * method setPixelSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, lastResortFont){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;lastResortFont();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QFont */
-/*
- *    function  lastResortFamily
- *    flags:    c
- */
-ZEND_METHOD(QFont, lastResortFamily){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;lastResortFamily();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFont_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QFont, setPixelSize)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setPixelSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setPixelSize((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setPixelSize(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  overline
- *    flags:    c
+/*!
+ * method setItalic
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFont, overline){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;overline());
-	}
-}
 
-/*********************************
- *    class     QFont */
-/*
- *    function  pointSizeF
- *    flags:    c
- */
-ZEND_METHOD(QFont, pointSizeF){
-	if (ZEND_NUM_ARGS() == 0){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj-&gt;pointSizeF());
-	}
+ZEND_METHOD(QFont, setItalic)
+{
+  ///bool bs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setItalic' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bs0,
+      QFont *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setItalic((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::setItalic(...) &quot;);
 }
 
-/*********************************
- *    class     QFont */
-/*
- *    function  setPointSizeF
- *    flags:    
+/*!
+ * method strikeOut
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QFont, setPointSizeF){
-		/* l public*/
 
-		/* double ,  */
+ZEND_METHOD(QFont, strikeOut)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'strikeOut' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFont *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFont *obj = (QFont*) PHP_QT_FETCH();
-
-
-			obj-&gt;setPointSizeF((qreal) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFont * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;strikeOut());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFont::strikeOut(...) &quot;);
 }
 
-
-PHP_QT_DESTRUCT(QFont);
-
+/*!
+ * method operator=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &amp;s0
+ * 
+ * @access	public
+ * @return	QFont &amp;
+ * @flags	
+ */

Modified: trunk/qt/classes/qframe.cpp
===================================================================
--- trunk/qt/classes/qframe.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qframe.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,495 +19,1006 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QFrame.cpp - QFrame PHP implementation.
- * begin           : Thu Feb 23 16:34:20 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
+
 #include &quot;../php_qt.h&quot;
 
 
 #include &lt;QFrame&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QFrame_php_qt:public QFrame
+{
 
+public:
+  QFrame_php_qt(zval * zend_ptr, QWidget * parent = 0, Qt::WFlags f = 0);
 
-/*		public enumShape:long {
-			NoFrame = 0,
-			Box = 0x0001,
-			Panel = 0x0002,
-			WinPanel = 0x0003,
-			HLine = 0x0004,
-			VLine = 0x0005,
-			StyledPanel = 0x0006
-		}
-*/
 
-/*		public enumShadow:long {
-			Plain = 0x0010,
-			Raised = 0x0020,
-			Sunken = 0x0030
-		}
-*/
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
-/*		public enum:long {
-			Shadow_Mask = 0x00f0,
-			Shape_Mask = 0x000f
-		}
-*/
-/*********************************
- *    class     QFrame
- *    function  tr
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+QFrame_php_qt::QFrame_php_qt(zval * zend_ptr, QWidget * parent, Qt::WFlags f):QFrame(parent, f)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QFrame&quot;,&amp;staticMetaObject));
+}
+
+PHP_QT_MOC(QFrame);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QFrame, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QFrame, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QFrame *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QFrame::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFrame_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QFrame::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QFrame::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  setLineWidth
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QFrame, setLineWidth){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method QFrame
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * parent = 0s0
+ * @param	 Qt::WFlags f = 0s1
+ * 
+ * overloaded args:
+ * @param	QFramePrivate &amp;dd
+ * @param	 QWidget* parent = 0
+ * @param	 Qt::WFlags f = 0
+ * 
+ * overloaded args:
+ * @param	const QFrame &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+ZEND_METHOD(QFrame, __construct)
+{
+  ///QWidget * parent = 0s0, Qt::WFlags f = 0s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame_php_qt *
+        selfpointer = new QFrame_php_qt(getThis());
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget * parent = 0s0,
+      QWidget *
+        cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QFrame_php_qt *
+        selfpointer = new QFrame_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-			obj-&gt;setLineWidth((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget * parent = 0s0, Qt::WFlags f = 0s1,
+      QWidget *
+        cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QFrame_php_qt *
+        selfpointer = new QFrame_php_qt(getThis(), (QWidget *) cpp_arg_0, (Qt::WFlags) Z_LVAL_P(arg_1));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QFramePrivate &amp;dd, QWidget* parent = 0, Qt::WFlags f = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFramePrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QFramePrivate &amp;dd,
+        QFramePrivate *
+          cpp_arg_0 = static_cast &lt; QFramePrivate * &gt;(php_qt_fetch(arg_0));
+        QFrame_php_qt *
+          selfpointer = new QFrame_php_qt(getThis(), (QFramePrivate &amp;) * cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QFramePrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QFramePrivate &amp;dd, QWidget* parent = 0,
+        QFramePrivate *
+          cpp_arg_0 = static_cast &lt; QFramePrivate * &gt;(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+        QFrame_php_qt *
+          selfpointer = new QFrame_php_qt(getThis(), (QFramePrivate &amp;) * cpp_arg_0, (QWidget *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QFramePrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QFramePrivate &amp;dd, QWidget* parent = 0, Qt::WFlags f = 0,
+        QFramePrivate *
+          cpp_arg_0 = static_cast &lt; QFramePrivate * &gt;(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+        QFrame_php_qt *
+          selfpointer = new QFrame_php_qt(getThis(), (QFramePrivate &amp;) * cpp_arg_0, (QWidget *) cpp_arg_1, (Qt::WFlags) Z_LVAL_P(arg_2));
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QFrame &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFrame
+      if (inherits(Z_OBJCE_P(arg_0), 25)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QFrame::__construct(...) cannot be called with 'const QFrame &amp;,'.&quot;);
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::QFrame(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  frameWidth
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method frameShadow
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Shadow
+ * @flags	c
  */
-ZEND_METHOD(QFrame, frameWidth){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;frameWidth());
-	}
+
+ZEND_METHOD(QFrame, frameShadow)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type Shadow&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::frameShadow(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  staticMetaObject
- *    flags:    s
- *    access:    public
- *    return:    QMetaObject*
- *    params:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QFrame, staticMetaObject){
-}
 
-/*********************************
- *    class     QFrame
- *    function  QFrame
- *    flags:    t
- *    access:    public
- *    return:    
- *    params:    QWidget* parent = 0, Qt::WFlags f = 0
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QFrame, __construct){
-//qt_QWidget*
-		/* ol public*/
 
-		/* qt_QWidget* parent, int f,  */
+/*!
+ * method drawFrame
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPainter *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				QFrame *QFrame_ptr = new QFrame((QWidget*) obj_z_0, (Qt::WFlags) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QFrame_ptr);
-				RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+/*!
+ * method setFrameShadow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Shadow Shadows0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QFrame, setFrameShadow)
+{
+// notice: unknown argument Shadow Shadows0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::setFrameShadow(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  midLineWidth
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method frameStyle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFrame, midLineWidth){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;midLineWidth());
-	}
+
+ZEND_METHOD(QFrame, frameStyle)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'frameStyle' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;frameStyle());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::frameStyle(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  frameShadow
- *    flags:    c
- *    access:    public
- *    return:    Shadow
- *    params:    
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QFrame, frameShadow){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			obj-&gt;frameShadow();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QFrame, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QFrame::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  qObject
- *    flags:    
- *    access:    public
- *    return:    QObject*
- *    params:    
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QFrame, qObject){
-}
 
-/*********************************
- *    class     QFrame
- *    function  frameShape
- *    flags:    c
- *    access:    public
- *    return:    Shape
- *    params:    
+/*!
+ * method setFrameShape
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Shape Shapes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFrame, frameShape){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			obj-&gt;frameShape();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QFrame, setFrameShape)
+{
+// notice: unknown argument Shape Shapes0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::setFrameShape(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  setFrameShape
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    Shape
+/*!
+ * method setFrameStyle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFrame, setFrameShape){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFrame, setFrameStyle)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setFrameStyle' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFrame *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setFrameStyle((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::setFrameStyle(...) &quot;);
+}
 
+/*!
+ * method setMidLineWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj-&gt;setFrameShape((QFrame::Shape) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+ZEND_METHOD(QFrame, setMidLineWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMidLineWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMidLineWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::setMidLineWidth(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  sizeHint
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QFrame, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;sizeHint();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFrame_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method frameWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QFrame, frameWidth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'frameWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;frameWidth());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::frameWidth(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  setFrameRect
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    const QRect &amp;
+/*!
+ * method midLineWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFrame, setFrameRect){
-//const QRect&amp;
-		/* o public*/
 
-		/* const QRect&amp; ,  */
+ZEND_METHOD(QFrame, midLineWidth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'midLineWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;midLineWidth());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::midLineWidth(...) &quot;);
+}
 
+/*!
+ * method frameShape
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Shape
+ * @flags	c
+ */
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QRect&quot;)) {
-				obj-&gt;setFrameRect((const QRect&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+ZEND_METHOD(QFrame, frameShape)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type Shape&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::frameShape(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  setFrameStyle
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method setFrameRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFrame, setFrameStyle){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QFrame, setFrameRect)
+{
+  ///const QRect &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setFrameRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;s0,
+        QFrame *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setFrameRect((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;setFrameStyle((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::setFrameRect(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  lineWidth
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method lineWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QFrame, lineWidth){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;lineWidth());
-	}
+
+ZEND_METHOD(QFrame, lineWidth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'lineWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;lineWidth());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::lineWidth(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  drawFrame
- *    flags:    
- *    access:    protected
- *    return:    void
- *    params:    QPainter *
+/*!
+ * method frameRect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-// method drawFrame is protected, skipped.
 
-/*********************************
- *    class     QFrame
- *    function  setMidLineWidth
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
- */
-ZEND_METHOD(QFrame, setMidLineWidth){
-		/* l public*/
+ZEND_METHOD(QFrame, frameRect)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
 
-		/* int ,  */
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'frameRect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
 
-			obj-&gt;setMidLineWidth((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;frameRect());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::frameRect(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  setFrameShadow
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    Shadow
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QFrame, setFrameShadow){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+/*!
+ * method setLineWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QFrame, setLineWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setLineWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QFrame *
+        selfpointer;
 
-			obj-&gt;setFrameShadow((QFrame::Shadow) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setLineWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::setLineWidth(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  trUtf8
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QFrame, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QFrame, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QFrame *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QFrame::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFrame_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
 
-/*********************************
- *    class     QFrame
- *    function  frameRect
- *    flags:    c
- *    access:    public
- *    return:    QRect
- *    params:    
- */
-ZEND_METHOD(QFrame, frameRect){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			QRect* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QRect) obj-&gt;frameRect();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QFrame_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::sizeHint(...) &quot;);
 }
 
-/*********************************
- *    class     QFrame
- *    function  frameStyle
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QFrame, frameStyle){
-	if (ZEND_NUM_ARGS() == 0){
-			QFrame *obj = (QFrame*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;frameStyle());
-	}
-}
 
+ZEND_METHOD(QFrame, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-PHP_QT_DESTRUCT(QFrame);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QFrame *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QFrame::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QFrame *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QFrame * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QFrame::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QFrame::trUtf8(...) &quot;);
+}

Modified: trunk/qt/classes/qgridlayout.cpp
===================================================================
--- trunk/qt/classes/qgridlayout.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qgridlayout.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QGridLayout.cpp - QGridLayout PHP implementation.
- * begin           : Tue Apr 11 10:33:13 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -31,1177 +30,1844 @@
 
 
 #include &lt;QGridLayout&gt;
-#include &lt;QWidget&gt;
-
-/*!
- *    @class     QGridLayout
- *    @function  tr
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
- */
-ZEND_METHOD(QGridLayout, tr)
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QGridLayout_php_qt:public QGridLayout
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+public:
+  QGridLayout_php_qt(zval * zend_ptr, QWidget * parents0);
+  QGridLayout_php_qt(zval * zend_ptr);
 
-        QString *return_object;
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast &lt; QString &gt; (obj-&gt;tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QGridLayout::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));   /// memory allocation
-          *return_object = static_cast &lt; QString &gt; (QGridLayout::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
-        object_init_ex(return_value, QGridLayout_ce_ptr);
-        zend_rsrc_list_entry le;
+QGridLayout_php_qt::QGridLayout_php_qt(zval * zend_ptr, QWidget * parents0):QGridLayout(parents0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QGridLayout&quot;,&amp;staticMetaObject));
+}
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+QGridLayout_php_qt::QGridLayout_php_qt(zval * zend_ptr):QGridLayout()
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QGridLayout&quot;,&amp;staticMetaObject));
 }
 
+PHP_QT_MOC(QGridLayout);
+
 /*!
- *    @class     QGridLayout
- *    @function  addLayout
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QLayout *, int row, int column, Qt::Alignment = 0
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QGridLayout, addLayout)
+
+ZEND_METHOD(QGridLayout, tr)
 {
-///qt_QLayout*
-/*! olll public*/
-/*! qt_QLayout* , int row, int column, int ,  */
-  if (ZEND_NUM_ARGS() == 4) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QGridLayout *
+        selfpointer;
 
-        if (obj_z_0-&gt;inherits(&quot;QLayout&quot;)) {
-          void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-          if (getThis() != NULL) {
-            obj-&gt;addLayout((QLayout *) obj_z_0, (int)Z_LVAL_P(z_1), (int)Z_LVAL_P(z_2), (Qt::Alignment) Z_LVAL_P(z_3));
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QGridLayout::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
       } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QGridLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QGridLayout::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::tr(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  QGridLayout
- *
- *    @flags    t
- *    @access    public
- *    @return    
- *    @param    QWidget *parent
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QGridLayout, __construct)
+
+/*!
+ * method addItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *items0
+ * @param	 int rows1
+ * @param	 int columns2
+ * @param	 int rowSpan = 1s3
+ * @param	 int columnSpan = 1s4
+ * @param	 Qt::Alignment = 0s5
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QGridLayout, addItem)
 {
-///QWidget*
-	if (ZEND_NUM_ARGS() == 0){
-			QGridLayout *QGridLayout_ptr = new QGridLayout();
-				PHP_QT_REGISTER(QGridLayout_ptr);
-				RETURN_NULL();
-	}
-/*! o public*/
-/*! QWidget* parent,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///QLayoutItem *items0, int rows1, int columns2, int rowSpan = 1s3, int columnSpan = 1s4, Qt::Alignment = 0s5
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addItem' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayoutItem *items0, int rows1, int columns2,
+        QGridLayout *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayoutItem *
+          cpp_arg_0 = static_cast &lt; QLayoutItem * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          QGridLayout *QGridLayout_ptr = new QGridLayout((QWidget *) obj_z_0);
+        RETURN_VOID(selfpointer-&gt;addItem((QLayoutItem *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-          PHP_QT_REGISTER(QGridLayout_ptr);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addItem' is not static&quot;);
           RETURN_NULL();
         }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
+        /// try QLayoutItem *items0, int rows1, int columns2, int rowSpan = 1s3,
+        QGridLayout *
+          selfpointer;
 
-/*!
- *    @class     QGridLayout
- *    @function  addItem
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QLayoutItem *item, int row, int column, int rowSpan = 1, int columnSpan = 1, Qt::Alignment = 0
- */
-ZEND_METHOD(QGridLayout, addItem)
-{
-///qt_QLayoutItem*
-/*! olllll public*/
-/*! qt_QLayoutItem* item, int row, int column, int rowSpan, int columnSpan, int ,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayoutItem *
+          cpp_arg_0 = static_cast &lt; QLayoutItem * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;addItem((QLayoutItem *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addItem' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayoutItem *items0, int rows1, int columns2, int rowSpan = 1s3, int columnSpan = 1s4,
+        QGridLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayoutItem *
+          cpp_arg_0 = static_cast &lt; QLayoutItem * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;addItem((QLayoutItem *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4)));
+      }
+#endif
+
+    }
+  }
   if (ZEND_NUM_ARGS() == 6) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
-    zval *z_4;                  /// define ZVAL
-    zval *z_5;                  /// define ZVAL
+    PHP_QT_FETCH_6_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addItem' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayoutItem *items0, int rows1, int columns2, int rowSpan = 1s3, int columnSpan = 1s4, Qt::Alignment = 0s5,
+        QGridLayout *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zzzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4, &amp;z_5) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_LONG &amp;&amp;
-          Z_TYPE_P(z_5) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayoutItem *
+          cpp_arg_0 = static_cast &lt; QLayoutItem * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QLayoutItem&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;
+                    addItem((QLayoutItem *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                            (Qt::Alignment) Z_LVAL_P(arg_5)));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;addItem((QLayoutItem *) obj_z_0, (int)Z_LVAL_P(z_1), (int)Z_LVAL_P(z_2), (int)Z_LVAL_P(z_3), (int)Z_LVAL_P(z_4),
-                         (Qt::Alignment) Z_LVAL_P(z_5));
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  ///QLayoutItem *
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+/// overloaded method is protected, skipped.
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::addItem(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  rowMinimumHeight
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    int row
+ * method rowMinimumHeight
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int rows0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QGridLayout, rowMinimumHeight)
 {
-/*! l public*/
-/*! int row,  */
+  ///int rows0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'rowMinimumHeight' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int rows0,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-        int *return_object;
-
-        if (getThis() != NULL) {
-          RETURN_LONG(obj-&gt;rowMinimumHeight((int)Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;rowMinimumHeight((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::rowMinimumHeight(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  setOriginCorner
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::Corner
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QGridLayout, setOriginCorner)
-{
-/*! l public*/
-/*! int ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setOriginCorner((Qt::Corner) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
-
 /*!
- *    @class     QGridLayout
- *    @function  count
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method count
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QGridLayout, count)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'count' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;count());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;count());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::count(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  originCorner
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::Corner
- *    @param    
+ * method originCorner
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Corner
+ * @flags	c
  */
+
 ZEND_METHOD(QGridLayout, originCorner)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::Corner * return_object;
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'originCorner' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-      RETURN_LONG(obj-&gt;originCorner());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;originCorner());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::originCorner(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  invalidate
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method setRowStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int rows0
+ * @param	 int stretchs1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, invalidate)
+
+ZEND_METHOD(QGridLayout, setRowStretch)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+  ///int rows0, int stretchs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setRowStretch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int rows0, int stretchs1,
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-      obj-&gt;invalidate();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setRowStretch((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::setRowStretch(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  setGeometry
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QRect&amp;
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QGridLayout, setGeometry)
-{
-///const QRect&amp;
-/*! o public*/
-/*! const QRect&amp; ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-        if (!strcmp(Z_OBJCE_P(z_0)-&gt;name, &quot;QRect&quot;)) {
-          void *return_object;
-
-          if (getThis() != NULL) {
-            obj-&gt;setGeometry((const QRect &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
-
 /*!
- *    @class     QGridLayout
- *    @function  setRowStretch
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int row, int stretch
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QGridLayout, setRowStretch)
+
+ZEND_METHOD(QGridLayout, staticMetaObject)
 {
-/*! ll public*/
-/*! int row, int stretch,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-        void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-          obj-&gt;setRowStretch((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QGridLayout::staticMetaObject());
       } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::staticMetaObject(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  getItemPosition
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int idx, int *row, int *column, int *rowSpan, int *columnSpan
+ * method itemAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, getItemPosition)
+
+ZEND_METHOD(QGridLayout, itemAt)
 {
-/*! lllll public*/
-/*! int idx, int* row, int* column, int* rowSpan, int* columnSpan,  */
-  if (ZEND_NUM_ARGS() == 5) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
-    zval *z_4;                  /// define ZVAL
-
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;getItemPosition((int)Z_LVAL_P(z_0), (int *)Z_LVAL_P(z_1), (int *)Z_LVAL_P(z_2), (int *)Z_LVAL_P(z_3), (int *)Z_LVAL_P(z_4));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+// notice: abstract class QLayoutItem cannot be instanciated, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::itemAt(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  setDefaultPositioning
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int n, Qt::Orientation orient
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, setDefaultPositioning)
+
+/*!
+ * method setColumnMinimumWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int columns0
+ * @param	 int minSizes1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QGridLayout, setColumnMinimumWidth)
 {
-/*! ll public*/
-/*! int n, int orient,  */
+  ///int columns0, int minSizes1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setColumnMinimumWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int columns0, int minSizes1,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setDefaultPositioning((int)Z_LVAL_P(z_0), (Qt::Orientation) Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setColumnMinimumWidth((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::setColumnMinimumWidth(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  columnStretch
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    int column
+ * method heightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, columnStretch)
+
+ZEND_METHOD(QGridLayout, heightForWidth)
 {
-/*! l public*/
-/*! int column,  */
+  ///int ints0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'heightForWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;heightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::heightForWidth(...) &quot;);
+}
 
-        int *return_object;
+/*!
+ * method hasHeightForWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-        if (getThis() != NULL) {
-          RETURN_LONG(obj-&gt;columnStretch((int)Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+ZEND_METHOD(QGridLayout, hasHeightForWidth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hasHeightForWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;hasHeightForWidth());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::hasHeightForWidth(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  addWidget
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QWidget *w
+ * method rowCount
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, addWidget)
+
+ZEND_METHOD(QGridLayout, rowCount)
 {
-///QWidget*
-	if (ZEND_NUM_ARGS() == 5){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-        zval *z_3; // define ZVAL
-        zval *z_4; // define ZVAL
-        
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4) == SUCCESS) {
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'rowCount' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-//			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_LONG){
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;rowCount());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::rowCount(...) &quot;);
+}
 
-			    QGridLayout *obj = (QGridLayout*) PHP_QT_FETCH();
-			    QWidget* obj_z_0 = static_cast&lt;QWidget*&gt;(php_qt_fetch(z_0));
+/*!
+ * method cellRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int rows0
+ * @param	 int columns1
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
+ */
 
-			    if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				    obj-&gt;addWidget(obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (Qt::Alignment) Z_LVAL_P(z_4));
-			        RETURN_NULL();
-			    } else { php_error(E_ERROR,&quot;argument is no QWidget&quot;); }
-//			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
-///QWidget*
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-//			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			    QGridLayout *obj = (QGridLayout*) PHP_QT_FETCH();
-			    QWidget* obj_z_0 = static_cast&lt;QWidget*&gt;(php_qt_fetch(z_0));
+ZEND_METHOD(QGridLayout, cellRect)
+{
+  ///int rows0, int columns1
+#ifdef PHP_QT_QRect             // return type
 
-			    if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				    obj-&gt;addWidget(obj_z_0, (int) Z_LVAL_P(z_1), (Qt::Alignment) Z_LVAL_P(z_2));
-			        RETURN_NULL();
-			    } else { php_error(E_ERROR,&quot;argument is no QWidget&quot;); }
-//			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
-/*! o public*/
-/*! QWidget* w,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'cellRect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int rows0, int columns1,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          void *return_object;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
 
-          if (getThis() != NULL) {
-            obj-&gt;addWidget((QWidget *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;cellRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::cellRect(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  takeAt
- *
- *    @flags    
- *    @access    public
- *    @return    QLayoutItem *
- *    @param    int
+ * method columnMinimumWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int columns0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, takeAt)
+
+ZEND_METHOD(QGridLayout, columnMinimumWidth)
 {
-/*! l public*/
-/*! int ,  */
+  ///int columns0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'columnMinimumWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int columns0,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;columnMinimumWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::columnMinimumWidth(...) &quot;);
+}
 
-        QLayoutItem **return_object;
+/*!
+ * method minimumHeightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-        if (getThis() != NULL) {
-/// return: pointer
+ZEND_METHOD(QGridLayout, minimumHeightForWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumHeightForWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QGridLayout *
+        selfpointer;
 
-/// return value is object: QLayoutItem *
-          *return_object = static_cast &lt; QLayoutItem * &gt;(obj-&gt;takeAt((int)Z_LVAL_P(z_0)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, &quot;Object not found&quot;);
-        }
-        zend_class_entry *ce;
-
-        object_init_ex(return_value, QGridLayout_ce_ptr);
-        zend_rsrc_list_entry le;
-
-        le.ptr = return_object[0];
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;minimumHeightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::minimumHeightForWidth(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  staticMetaObject
- *
- *    @flags    s
- *    @access    public
- *    @return    QMetaObject*
- *    @param    
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QGridLayout, staticMetaObject)
+
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	c
+ */
+
+ZEND_METHOD(QGridLayout, expandingDirections)
 {
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'expandingDirections' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;expandingDirections());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::expandingDirections(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  itemAt
- *
- *    @flags    c
- *    @access    public
- *    @return    QLayoutItem *
- *    @param    int
+ * method addLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayout *s0
+ * @param	 int rows1
+ * @param	 int columns2
+ * @param	 Qt::Alignment = 0s3
+ * 
+ * overloaded args:
+ * @param	QLayout *
+ * @param	 int row
+ * @param	 int column
+ * @param	 int rowSpan
+ * @param	 int columnSpan
+ * @param	 Qt::Alignment = 0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, itemAt)
+
+ZEND_METHOD(QGridLayout, addLayout)
 {
-/*! l public*/
-/*! int ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///QLayout *s0, int rows1, int columns2, Qt::Alignment = 0s3
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addLayout' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayout *s0, int rows1, int columns2,
+        QGridLayout *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast &lt; QLayout * &gt;(php_qt_fetch(arg_0));
 
-        QLayoutItem **return_object;
+        RETURN_VOID(selfpointer-&gt;addLayout((QLayout *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addLayout' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayout *s0, int rows1, int columns2, Qt::Alignment = 0s3,
+        QGridLayout *
+          selfpointer;
+
         if (getThis() != NULL) {
-/// return: pointer
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast &lt; QLayout * &gt;(php_qt_fetch(arg_0));
 
-/// return value is object: QLayoutItem *
-          *return_object = static_cast &lt; QLayoutItem * &gt;(obj-&gt;itemAt((int)Z_LVAL_P(z_0)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, &quot;Object not found&quot;);
+        RETURN_VOID(selfpointer-&gt;addLayout((QLayout *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (Qt::Alignment) Z_LVAL_P(arg_3)));
+      }
+#endif
+
+    }
+  }
+  ///QLayout *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addLayout' is not static&quot;);
+          RETURN_NULL();
         }
-        zend_class_entry *ce;
+        /// try QLayout *, int row, int column, int rowSpan, int columnSpan,
+        QGridLayout *
+          selfpointer;
 
-        object_init_ex(return_value, QGridLayout_ce_ptr);
-        zend_rsrc_list_entry le;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast &lt; QLayout * &gt;(php_qt_fetch(arg_0));
 
-        le.ptr = return_object[0];
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;addLayout((QLayout *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addLayout' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayout *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0,
+        QGridLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast &lt; QLayout * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;
+                    addLayout((QLayout *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                              (Qt::Alignment) Z_LVAL_P(arg_5)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::addLayout(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  qObject
- *
- *    @flags    
- *    @access    public
- *    @return    QObject*
- *    @param    
+ * method QGridLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parents0s0
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QGridLayout &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QGridLayout, qObject)
-{
-}
 
-/*!
- *    @class     QGridLayout
- *    @function  minimumSize
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
- */
-ZEND_METHOD(QGridLayout, minimumSize)
+ZEND_METHOD(QGridLayout, __construct)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+  ///QWidget *parents0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *parents0s0,
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+        QGridLayout_php_qt *
+          selfpointer = new QGridLayout_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;minimumSize());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
     }
-    zend_class_entry *ce;
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout_php_qt *
+        selfpointer = new QGridLayout_php_qt(getThis());
 
-    object_init_ex(return_value, QGridLayout_ce_ptr);
-    zend_rsrc_list_entry le;
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QGridLayout &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QGridLayout
+      if (inherits(Z_OBJCE_P(arg_0), 26)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QGridLayout::__construct(...) cannot be called with 'const QGridLayout &amp;,'.&quot;);
+      }
+#endif
 
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::QGridLayout(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  sizeHint
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method setOriginCorner
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Corner Qt::Corners0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, sizeHint)
+
+ZEND_METHOD(QGridLayout, setOriginCorner)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+  ///Qt::Corner Qt::Corners0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setOriginCorner' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::Corner Qt::Corners0,
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;sizeHint());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setOriginCorner((Qt::Corner) Z_LVAL_P(arg_0)));
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QGridLayout_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::setOriginCorner(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  setColumnMinimumWidth
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int column, int minSize
+ * method invalidate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, setColumnMinimumWidth)
+
+ZEND_METHOD(QGridLayout, invalidate)
 {
-/*! ll public*/
-/*! int column, int minSize,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'invalidate' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setColumnMinimumWidth((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;invalidate());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::invalidate(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  heightForWidth
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    int
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, heightForWidth)
+
+ZEND_METHOD(QGridLayout, setGeometry)
 {
-/*! l public*/
-/*! int ,  */
+  ///const QRect &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setGeometry' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;s0,
+        QGridLayout *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
-        int *return_object;
+        RETURN_VOID(selfpointer-&gt;setGeometry((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
 
-        if (getThis() != NULL) {
-          RETURN_LONG(obj-&gt;heightForWidth((int)Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::setGeometry(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  hasHeightForWidth
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method getItemPosition
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int idxs0
+ * @param	 int *rows1
+ * @param	 int *columns2
+ * @param	 int *rowSpans3
+ * @param	 int *columnSpans4
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, hasHeightForWidth)
+
+ZEND_METHOD(QGridLayout, getItemPosition)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+  ///int idxs0, int *rows1, int *columns2, int *rowSpans3, int *columnSpans4
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp; Z_TYPE_P(arg_4) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'getItemPosition' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int idxs0, int *rows1, int *columns2, int *rowSpans3, int *columnSpans4,
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;hasHeightForWidth());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;
+                  getItemPosition((int)Z_LVAL_P(arg_0), (int *)&amp;Z_LVAL_P(arg_1), (int *)&amp;Z_LVAL_P(arg_2), (int *)&amp;Z_LVAL_P(arg_3), (int *)&amp;Z_LVAL_P(arg_4)));
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::getItemPosition(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  setColumnStretch
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int column, int stretch
+ * method setDefaultPositioning
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ns0
+ * @param	 Qt::Orientation orients1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, setColumnStretch)
+
+ZEND_METHOD(QGridLayout, setDefaultPositioning)
 {
-/*! ll public*/
-/*! int column, int stretch,  */
+  ///int ns0, Qt::Orientation orients1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setDefaultPositioning' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ns0, Qt::Orientation orients1,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setColumnStretch((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setDefaultPositioning((int)Z_LVAL_P(arg_0), (Qt::Orientation) Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::setDefaultPositioning(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  rowCount
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method columnStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int columns0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, rowCount)
+
+ZEND_METHOD(QGridLayout, columnStretch)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+  ///int columns0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'columnStretch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int columns0,
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;rowCount());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;columnStretch((int)Z_LVAL_P(arg_0)));
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::columnStretch(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  columnMinimumWidth
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    int column
+ * method takeAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, columnMinimumWidth)
+
+ZEND_METHOD(QGridLayout, takeAt)
 {
-/*! l public*/
-/*! int column,  */
+// notice: abstract class QLayoutItem cannot be instanciated, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::takeAt(...) &quot;);
+}
+
+/*!
+ * method addWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * 
+ * overloaded args:
+ * @param	QWidget *
+ * @param	 int row
+ * @param	 int column
+ * @param	 Qt::Alignment = 0
+ * 
+ * overloaded args:
+ * @param	QWidget *
+ * @param	 int row
+ * @param	 int column
+ * @param	 int rowSpan
+ * @param	 int columnSpan
+ * @param	 Qt::Alignment = 0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QGridLayout, addWidget)
+{
+  ///QWidget *ws0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0,
+        QGridLayout *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
-        int *return_object;
+        RETURN_VOID(selfpointer-&gt;addWidget((QWidget *) cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///QWidget *, int row, int column, Qt::Alignment = 0
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *, int row, int column,
+        QGridLayout *
+          selfpointer;
+
         if (getThis() != NULL) {
-          RETURN_LONG(obj-&gt;columnMinimumWidth((int)Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
-/*!
- *    @class     QGridLayout
- *    @function  cellRect
- *
- *    @flags    c
- *    @access    public
- *    @return    QRect
- *    @param    int row, int column
- */
-ZEND_METHOD(QGridLayout, cellRect)
-{
-/*! ll public*/
-/*! int row, int column,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+        RETURN_VOID(selfpointer-&gt;addWidget((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *, int row, int column, Qt::Alignment = 0,
+        QGridLayout *
+          selfpointer;
 
-        QRect *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;addWidget((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (Qt::Alignment) Z_LVAL_P(arg_3)));
+      }
+#endif
+
+    }
+  }
+  ///QWidget *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *, int row, int column, int rowSpan, int columnSpan,
+        QGridLayout *
+          selfpointer;
+
         if (getThis() != NULL) {
-/// return value is object: QRect
-          *return_object = static_cast &lt; QRect &gt; (obj-&gt;cellRect((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, &quot;Object not found&quot;);
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
         }
-        zend_class_entry *ce;
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
-        object_init_ex(return_value, QGridLayout_ce_ptr);
-        zend_rsrc_list_entry le;
+        RETURN_VOID(selfpointer-&gt;addWidget((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4)));
+      }
+#endif
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0,
+        QGridLayout *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;
+                    addWidget((QWidget *) cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                              (Qt::Alignment) Z_LVAL_P(arg_5)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::addWidget(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  columnCount
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, columnCount)
+
+ZEND_METHOD(QGridLayout, minimumSize)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-      RETURN_LONG(obj-&gt;columnCount());
-    }                           /// 5 END getThis(), simple types
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;minimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::minimumSize(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  setRowMinimumHeight
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int row, int minSize
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, setRowMinimumHeight)
+
+ZEND_METHOD(QGridLayout, sizeHint)
 {
-/*! ll public*/
-/*! int row, int minSize,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-        void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-          obj-&gt;setRowMinimumHeight((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::sizeHint(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  trUtf8
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method setColumnStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int columns0
+ * @param	 int stretchs1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, trUtf8)
+
+ZEND_METHOD(QGridLayout, setColumnStretch)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
+  ///int columns0, int stretchs1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setColumnStretch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int columns0, int stretchs1,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setColumnStretch((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::setColumnStretch(...) &quot;);
+}
 
-        QString *return_object;
+/*!
+ * method columnCount
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast &lt; QString &gt; (obj-&gt;trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QGridLayout::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));       /// memory allocation
-          *return_object = static_cast &lt; QString &gt; (QGridLayout::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+ZEND_METHOD(QGridLayout, columnCount)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'columnCount' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-        object_init_ex(return_value, QGridLayout_ce_ptr);
-        zend_rsrc_list_entry le;
-
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;columnCount());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::columnCount(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  maximumSize
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method setRowMinimumHeight
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int rows0
+ * @param	 int minSizes1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QGridLayout, maximumSize)
+
+ZEND_METHOD(QGridLayout, setRowMinimumHeight)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+  ///int rows0, int minSizes1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setRowMinimumHeight' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int rows0, int minSizes1,
+      QGridLayout *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;maximumSize());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setRowMinimumHeight((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QGridLayout_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::setRowMinimumHeight(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  minimumHeightForWidth
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    int
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QGridLayout, minimumHeightForWidth)
+
+ZEND_METHOD(QGridLayout, trUtf8)
 {
-/*! l public*/
-/*! int ,  */
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        int *return_object;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        if (getThis() != NULL) {
-          RETURN_LONG(obj-&gt;minimumHeightForWidth((int)Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QGridLayout::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
       } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QGridLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QGridLayout::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::trUtf8(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  expandingDirections
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::Orientations
- *    @param    
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QGridLayout, expandingDirections)
+
+ZEND_METHOD(QGridLayout, maximumSize)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::Orientations * return_object;
-    if (getThis() != NULL) {
-      QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'maximumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QGridLayout *
+        selfpointer;
 
-      obj-&gt;expandingDirections();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;maximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::maximumSize(...) &quot;);
 }
 
 /*!
- *    @class     QGridLayout
- *    @function  rowStretch
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    int row
+ * method rowStretch
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int rows0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QGridLayout, rowStretch)
 {
-/*! l public*/
-/*! int row,  */
+  ///int rows0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'rowStretch' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int rows0,
+      QGridLayout *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QGridLayout *obj = (QGridLayout *) PHP_QT_FETCH();
-
-        int *return_object;
-
-        if (getThis() != NULL) {
-          RETURN_LONG(obj-&gt;rowStretch((int)Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QGridLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;rowStretch((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QGridLayout::rowStretch(...) &quot;);
 }
-
-
-PHP_QT_DESTRUCT(QGridLayout);

Modified: trunk/qt/classes/qhboxlayout.cpp
===================================================================
--- trunk/qt/classes/qhboxlayout.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qhboxlayout.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,133 +19,412 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QHBoxLayout.cpp - QHBoxLayout PHP implementation.
- * begin           : Thu Feb 23 16:39:38 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
+
 #include &quot;../php_qt.h&quot;
 
 
 #include &lt;QHBoxLayout&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QHBoxLayout_php_qt:public QHBoxLayout
+{
 
-/*********************************
- *    class     QHBoxLayout
- *    function  tr
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
- */
-ZEND_METHOD(QHBoxLayout, tr){
-		/* ss public*/
+public:
+  QHBoxLayout_php_qt(zval * zend_ptr);
+  QHBoxLayout_php_qt(zval * zend_ptr, QWidget * parents0);
 
-		/* const char* , const char* ,  */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QHBoxLayout *obj = (QHBoxLayout*) PHP_QT_FETCH();
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
+QHBoxLayout_php_qt::QHBoxLayout_php_qt(zval * zend_ptr):QHBoxLayout()
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QHBoxLayout&quot;,&amp;staticMetaObject));
+}
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QHBoxLayout::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QHBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+QHBoxLayout_php_qt::QHBoxLayout_php_qt(zval * zend_ptr, QWidget * parents0):QHBoxLayout(parents0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QHBoxLayout&quot;,&amp;staticMetaObject));
 }
 
-/*********************************
- *    class     QHBoxLayout
- *    function  staticMetaObject
- *    flags:    s
- *    access:    public
- *    return:    QMetaObject*
- *    params:    
+PHP_QT_MOC(QHBoxLayout);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QHBoxLayout, staticMetaObject){
+
+ZEND_METHOD(QHBoxLayout, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QHBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QHBoxLayout::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QHBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QHBoxLayout::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QHBoxLayout::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QHBoxLayout
- *    function  qObject
- *    flags:    
- *    access:    public
- *    return:    QObject*
- *    params:    
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QHBoxLayout, qObject){
-}
 
-/*********************************
- *    class     QHBoxLayout
- *    function  QHBoxLayout
- *    flags:    
- *    access:    public
- *    return:    
- *    params:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QHBoxLayout, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QHBoxLayout *QHBoxLayout_ptr = new QHBoxLayout();
-				PHP_QT_REGISTER(QHBoxLayout_ptr);
-				RETURN_NULL();
-	}
+
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
+
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
+
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
+
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
+ */
+
+ZEND_METHOD(QHBoxLayout, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QHBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QHBoxLayout::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QHBoxLayout::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QHBoxLayout
- *    function  trUtf8
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QHBoxLayout, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+/*!
+ * method QHBoxLayout
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parents0
+ * 
+ * overloaded args:
+ * @param	const QHBoxLayout &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QHBoxLayout *obj = (QHBoxLayout*) PHP_QT_FETCH();
+ZEND_METHOD(QHBoxLayout, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QHBoxLayout_php_qt *
+        selfpointer = new QHBoxLayout_php_qt(getThis());
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QWidget *parents0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *parents0,
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+        QHBoxLayout_php_qt *
+          selfpointer = new QHBoxLayout_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QHBoxLayout::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QHBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QHBoxLayout &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QHBoxLayout
+      if (inherits(Z_OBJCE_P(arg_0), 27)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QHBoxLayout::__construct(...) cannot be called with 'const QHBoxLayout &amp;,'.&quot;);
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QHBoxLayout::QHBoxLayout(...) &quot;);
 }
 
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-PHP_QT_DESTRUCT(QHBoxLayout);
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
 
+ZEND_METHOD(QHBoxLayout, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QHBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QHBoxLayout::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QHBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QHBoxLayout::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QHBoxLayout::trUtf8(...) &quot;);
+}

Modified: trunk/qt/classes/qhelpevent.cpp
===================================================================
--- trunk/qt/classes/qhelpevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qhelpevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,107 +19,271 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QHelpEvent.cpp - QHelpEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QHelpEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QHelpEvent */
-/*
- *    function  y
- *    flags:    c
+#include &lt;QHelpEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QHelpEvent_php_qt:public QHelpEvent
+{
+
+public:
+  QHelpEvent_php_qt(zval * zend_ptr, Type types0, const QPoint &amp; poss1, const QPoint &amp; globalPoss2);
+
+
+  zval *zend_ptr;
+};
+QHelpEvent_php_qt::QHelpEvent_php_qt(zval * zend_ptr, Type types0, const QPoint &amp; poss1, const QPoint &amp; globalPoss2):
+QHelpEvent(types0, poss1, globalPoss2)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method y
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QHelpEvent, y){
-	if (ZEND_NUM_ARGS() == 0){
-			QHelpEvent *obj = (QHelpEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;y());
-	}
+
+ZEND_METHOD(QHelpEvent, y)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'y' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QHelpEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHelpEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;y());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QHelpEvent::y(...) &quot;);
 }
 
-/*********************************
- *    class     QHelpEvent */
-/*
- *    function  globalY
- *    flags:    c
+/*!
+ * method QHelpEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	const QPoint &amp;poss1s1
+ * @param	const QPoint &amp;globalPoss2s2
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QHelpEvent, globalY){
-	if (ZEND_NUM_ARGS() == 0){
-			QHelpEvent *obj = (QHelpEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;globalY());
-	}
+
+ZEND_METHOD(QHelpEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QHelpEvent::QHelpEvent(...) &quot;);
 }
 
-/*********************************
- *    class     QHelpEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint&amp;
+ * @flags	c
  */
-ZEND_METHOD(QHelpEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QHelpEvent *obj = (QHelpEvent*) PHP_QT_FETCH();
-				const QPoint&amp; return_object = (const QPoint&amp;) obj-&gt;pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QHelpEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QHelpEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QHelpEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHelpEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QHelpEvent::pos(...) &quot;);
 }
 
-/*********************************
- *    class     QHelpEvent */
-/*
- *    function  x
- *    flags:    c
+/*!
+ * method globalPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint&amp;
+ * @flags	c
  */
-ZEND_METHOD(QHelpEvent, x){
-	if (ZEND_NUM_ARGS() == 0){
-			QHelpEvent *obj = (QHelpEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;x());
-	}
+
+ZEND_METHOD(QHelpEvent, globalPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalPos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QHelpEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHelpEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;globalPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QHelpEvent::globalPos(...) &quot;);
 }
 
-/*********************************
- *    class     QHelpEvent */
-/*
- *    function  globalPos
- *    flags:    c
+/*!
+ * method globalX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QHelpEvent, globalPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QHelpEvent *obj = (QHelpEvent*) PHP_QT_FETCH();
-				const QPoint&amp; return_object = (const QPoint&amp;) obj-&gt;globalPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QHelpEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QHelpEvent, globalX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalX' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QHelpEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHelpEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;globalX());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QHelpEvent::globalX(...) &quot;);
 }
 
-/*********************************
- *    class     QHelpEvent */
-/*
- *    function  globalX
- *    flags:    c
+/*!
+ * method x
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QHelpEvent, globalX){
-	if (ZEND_NUM_ARGS() == 0){
-			QHelpEvent *obj = (QHelpEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;globalX());
-	}
+
+ZEND_METHOD(QHelpEvent, x)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'x' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QHelpEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHelpEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;x());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QHelpEvent::x(...) &quot;);
 }
 
+/*!
+ * method globalY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QHelpEvent);
+ZEND_METHOD(QHelpEvent, globalY)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalY' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QHelpEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHelpEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;globalY());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QHelpEvent::globalY(...) &quot;);
+}

Modified: trunk/qt/classes/qhideevent.cpp
===================================================================
--- trunk/qt/classes/qhideevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qhideevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,62 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QHideEvent.cpp - QHideEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QHideEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
+#include &lt;QHideEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QHideEvent_php_qt:public QHideEvent
+{
 
-PHP_QT_DESTRUCT(QHideEvent);
+public:
+  QHideEvent_php_qt(zval * zend_ptr);
 
+
+  zval *zend_ptr;
+};
+
+QHideEvent_php_qt::QHideEvent_php_qt(zval * zend_ptr):QHideEvent()
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QHideEvent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QHideEvent, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QHideEvent_php_qt *
+        selfpointer = new QHideEvent_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QHideEvent::QHideEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qhoverevent.cpp
===================================================================
--- trunk/qt/classes/qhoverevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qhoverevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,55 +19,139 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QHoverEvent.cpp - QHoverEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QHoverEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QHoverEvent */
-/*
- *    function  oldPos
- *    flags:    c
+#include &lt;QHoverEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QHoverEvent_php_qt:public QHoverEvent
+{
+
+public:
+  QHoverEvent_php_qt(zval * zend_ptr, Type types0, const QPoint &amp; poss1, const QPoint &amp; oldPoss2);
+
+
+  zval *zend_ptr;
+};
+QHoverEvent_php_qt::QHoverEvent_php_qt(zval * zend_ptr, Type types0, const QPoint &amp; poss1, const QPoint &amp; oldPoss2):
+QHoverEvent(types0, poss1, oldPoss2)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &amp;
+ * @flags	c
  */
-ZEND_METHOD(QHoverEvent, oldPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QHoverEvent *obj = (QHoverEvent*) PHP_QT_FETCH();
-				const QPoint &amp; return_object = (const QPoint &amp;) obj-&gt;oldPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QHoverEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QHoverEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QHoverEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHoverEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QHoverEvent::pos(...) &quot;);
 }
 
-/*********************************
- *    class     QHoverEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method QHoverEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	const QPoint &amp;poss1s1
+ * @param	const QPoint &amp;oldPoss2s2
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QHoverEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QHoverEvent *obj = (QHoverEvent*) PHP_QT_FETCH();
-				const QPoint &amp; return_object = (const QPoint &amp;) obj-&gt;pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QHoverEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QHoverEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QHoverEvent::QHoverEvent(...) &quot;);
 }
 
+/*!
+ * method oldPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &amp;
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QHoverEvent);
+ZEND_METHOD(QHoverEvent, oldPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'oldPos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QHoverEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QHoverEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;oldPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QHoverEvent::oldPos(...) &quot;);
+}

Modified: trunk/qt/classes/qicondragevent.cpp
===================================================================
--- trunk/qt/classes/qicondragevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qicondragevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,62 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QIconDragEvent.cpp - QIconDragEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QIconDragEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
+#include &lt;QIconDragEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QIconDragEvent_php_qt:public QIconDragEvent
+{
 
-PHP_QT_DESTRUCT(QIconDragEvent);
+public:
+  QIconDragEvent_php_qt(zval * zend_ptr);
 
+
+  zval *zend_ptr;
+};
+
+QIconDragEvent_php_qt::QIconDragEvent_php_qt(zval * zend_ptr):QIconDragEvent()
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QIconDragEvent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QIconDragEvent, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QIconDragEvent_php_qt *
+        selfpointer = new QIconDragEvent_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QIconDragEvent::QIconDragEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qinputevent.cpp
===================================================================
--- trunk/qt/classes/qinputevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qinputevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,36 +19,84 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QInputEvent.cpp - QInputEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QInputEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QInputEvent */
-/*
- *    function  modifiers
- *    flags:    c
+#include &lt;QInputEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QInputEvent_php_qt:public QInputEvent
+{
+
+public:
+  QInputEvent_php_qt(zval * zend_ptr, Type types0, Qt::KeyboardModifiers modifiers = Qt::NoModifier);
+
+
+  zval *zend_ptr;
+};
+
+QInputEvent_php_qt::QInputEvent_php_qt(zval * zend_ptr, Type types0, Qt::KeyboardModifiers modifiers):QInputEvent(types0, modifiers)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QInputEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	 Qt::KeyboardModifiers modifiers = Qt::NoModifiers1
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QInputEvent, modifiers){
-	if (ZEND_NUM_ARGS() == 0){
-			QInputEvent *obj = (QInputEvent*) PHP_QT_FETCH();
-				Qt::KeyboardModifiers return_object = (Qt::KeyboardModifiers) obj-&gt;modifiers();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QInputEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QInputEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QInputEvent::QInputEvent(...) &quot;);
 }
 
+/*!
+ * method modifiers
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::KeyboardModifiers
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QInputEvent);
+ZEND_METHOD(QInputEvent, modifiers)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'modifiers' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QInputEvent *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QInputEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;modifiers());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QInputEvent::modifiers(...) &quot;);
+}

Modified: trunk/qt/classes/qinputmethodevent.cpp
===================================================================
--- trunk/qt/classes/qinputmethodevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qinputmethodevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,119 +19,420 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QInputMethodEvent.cpp - QInputMethodEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QInputMethodEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
+#include &lt;QInputMethodEvent&gt;
+#include &lt;QMetaMethod&gt;
+class QInputMethodEvent_php_qt:public QInputMethodEvent
+{
 
-/*		public enumAttributeType:long {
-			AttributeType = 0,
-			AttributeType = 0,
-			AttributeType = 0,
-			AttributeType = 0,
-		}
-*/
-/*********************************
- *    class     QInputMethodEvent */
-/*
- *    function  commitString
- *    flags:    c
+public:
+  QInputMethodEvent_php_qt(zval * zend_ptr);
+  QInputMethodEvent_php_qt(zval * zend_ptr, const QString &amp; preeditTexts0, const QList &lt; Attribute &gt; &amp;attributess1);
+    QInputMethodEvent_php_qt(zval * zend_ptr, const QInputMethodEvent &amp; others0);
+
+
+  zval *zend_ptr;
+};
+
+QInputMethodEvent_php_qt::QInputMethodEvent_php_qt(zval * zend_ptr):QInputMethodEvent()
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QInputMethodEvent_php_qt::QInputMethodEvent_php_qt(zval * zend_ptr, const QString &amp; preeditTexts0, const QList &lt; Attribute &gt; &amp;attributess1):
+QInputMethodEvent(preeditTexts0, attributess1)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QInputMethodEvent_php_qt::QInputMethodEvent_php_qt(zval * zend_ptr, const QInputMethodEvent &amp; others0):
+QInputMethodEvent(others0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method commitString
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QString &amp;
+ * @flags	c
  */
-ZEND_METHOD(QInputMethodEvent, commitString){
-	if (ZEND_NUM_ARGS() == 0){
-			QInputMethodEvent *obj = (QInputMethodEvent*) PHP_QT_FETCH();
-				const QString &amp; return_object = (const QString &amp;) obj-&gt;commitString();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QInputMethodEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QInputMethodEvent, commitString)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'commitString' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QInputMethodEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QInputMethodEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QString &amp; &gt;(selfpointer-&gt;commitString());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QInputMethodEvent::commitString(...) &quot;);
 }
 
-/*********************************
- *    class     QInputMethodEvent */
-/*
- *    function  replacementStart
- *    flags:    c
+/*!
+ * method attributes
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QList&lt;Attribute&gt; &amp;
+ * @flags	c
  */
-ZEND_METHOD(QInputMethodEvent, replacementStart){
-	if (ZEND_NUM_ARGS() == 0){
-			QInputMethodEvent *obj = (QInputMethodEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;replacementStart());
-	}
+
+ZEND_METHOD(QInputMethodEvent, attributes)
+{
+  ///
+#ifdef PHP_QT_QList             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'attributes' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QInputMethodEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QInputMethodEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QList &lt; Attribute &gt; &amp;&gt;(selfpointer-&gt;attributes());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QInputMethodEvent::attributes(...) &quot;);
 }
 
-/*********************************
- *    class     QInputMethodEvent */
-/*
- *    function  setCommitString
- *    flags:    
+/*!
+ * method replacementLength
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QInputMethodEvent, setCommitString){
-		/* oll public*/
 
-		/* const QString&amp; commitString, int replaceFrom, int replaceLength,  */
+ZEND_METHOD(QInputMethodEvent, replacementLength)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'replacementLength' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QInputMethodEvent *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QInputMethodEvent *obj = (QInputMethodEvent*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QInputMethodEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;replacementLength());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QInputMethodEvent::replacementLength(...) &quot;);
+}
 
+/*!
+ * method replacementStart
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				obj-&gt;setCommitString((const QString&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QInputMethodEvent, replacementStart)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'replacementStart' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QInputMethodEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QInputMethodEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;replacementStart());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QInputMethodEvent::replacementStart(...) &quot;);
 }
 
-/*********************************
- *    class     QInputMethodEvent */
-/*
- *    function  replacementLength
- *    flags:    c
+/*!
+ * method preeditString
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QString &amp;
+ * @flags	c
  */
-ZEND_METHOD(QInputMethodEvent, replacementLength){
-	if (ZEND_NUM_ARGS() == 0){
-			QInputMethodEvent *obj = (QInputMethodEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;replacementLength());
-	}
+
+ZEND_METHOD(QInputMethodEvent, preeditString)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'preeditString' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QInputMethodEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QInputMethodEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QString &amp; &gt;(selfpointer-&gt;preeditString());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QInputMethodEvent::preeditString(...) &quot;);
 }
 
-/*********************************
- *    class     QInputMethodEvent */
-/*
- *    function  preeditString
- *    flags:    c
+/*!
+ * method setCommitString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;commitStrings0
+ * @param	 int replaceFrom = 0s1
+ * @param	 int replaceLength = 0s2
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QInputMethodEvent, preeditString){
-	if (ZEND_NUM_ARGS() == 0){
-			QInputMethodEvent *obj = (QInputMethodEvent*) PHP_QT_FETCH();
-				const QString &amp; return_object = (const QString &amp;) obj-&gt;preeditString();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QInputMethodEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QInputMethodEvent, setCommitString)
+{
+  ///const QString &amp;commitStrings0, int replaceFrom = 0s1, int replaceLength = 0s2
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setCommitString' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;commitStrings0,
+        QInputMethodEvent *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QInputMethodEvent * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setCommitString((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setCommitString' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;commitStrings0, int replaceFrom = 0s1,
+        QInputMethodEvent *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QInputMethodEvent * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setCommitString((const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setCommitString' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;commitStrings0, int replaceFrom = 0s1, int replaceLength = 0s2,
+        QInputMethodEvent *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QInputMethodEvent * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setCommitString((const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QInputMethodEvent::setCommitString(...) &quot;);
 }
 
+/*!
+ * method QInputMethodEvent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;preeditTexts0
+ * @param	const QList&lt;Attribute&gt; &amp;attributess1
+ * 
+ * overloaded args:
+ * @param	const QInputMethodEvent &amp;others0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QInputMethodEvent);
+ZEND_METHOD(QInputMethodEvent, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QInputMethodEvent_php_qt *selfpointer = new QInputMethodEvent_php_qt(getThis());
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QString &amp;preeditTexts0,const QList&lt;Attribute&gt; &amp;attributess1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QList
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;preeditTexts0,const QList&lt;Attribute&gt; &amp;attributess1,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        QList &lt; Attribute &gt; *cpp_arg_1 = static_cast &lt; QList &lt; Attribute &gt; *&gt;(php_qt_fetch(arg_1));
+        QInputMethodEvent_php_qt *selfpointer = new QInputMethodEvent_php_qt(getThis(), (const QString &amp;)*cpp_arg_0, (const QList &lt; Attribute &gt; &amp;)*cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QInputMethodEvent &amp;others0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QInputMethodEvent
+      if (inherits(Z_OBJCE_P(arg_0), 33)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QInputMethodEvent &amp;others0,
+        QInputMethodEvent *cpp_arg_0 = static_cast &lt; QInputMethodEvent * &gt;(php_qt_fetch(arg_0));
+        QInputMethodEvent_php_qt *selfpointer = new QInputMethodEvent_php_qt(getThis(), (const QInputMethodEvent &amp;)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QInputMethodEvent::QInputMethodEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qinputmethodevent__attribute.cpp
===================================================================
--- trunk/qt/classes/qinputmethodevent__attribute.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qinputmethodevent__attribute.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,50 +19,51 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Attribute.cpp - Attribute PHP implementation.
- * begin           : Wed Jan 11 20:29:53 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;Attribute&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     Attribute */
-/*
- *    function  Attribute
- *    flags:    
- */
-ZEND_METHOD(Attribute, __construct){
+#include &lt;Attribute&gt;
+#include &lt;QMetaMethod&gt;
+class Attribute_php_qt:public Attribute
+{
 
-	if (ZEND_NUM_ARGS() == 4){
-		/* ollo */
-		zval* z_var_ollo_0;   // default: 
-		long var_ollo_1;    // default: 
-		long var_ollo_2;    // default: 
-		zval* z_var_ollo_3;   // default: 
+public:
+  Attribute_php_qt(zval * zend_ptr, AttributeType ts0, int ss1, int ls2, QVariant vals3);
 
-		/* AttributeType t, int s, int l, QVariant val,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;ollo&quot;, &amp;z_var_ollo_0, &amp;var_ollo_1, &amp;var_ollo_2, &amp;z_var_ollo_3) == SUCCESS) {
-			Attribute *obj = (Attribute*) PHP_QT_FETCH();
-			QObject* var_ollo_0 = (QObject*) php_qt_fetch(z_var_ollo_0);
-			QObject* var_ollo_3 = (QObject*) php_qt_fetch(z_var_ollo_3);
 
-			QString tmp_ollo_0(var_ollo_0-&gt;metaObject()-&gt;className());
-			QString tmp_ollo_1(var_ollo_3-&gt;metaObject()-&gt;className());
-			
-			if(tmp_ollo_0 == &quot;AttributeType&quot; &amp;&amp; tmp_ollo_1 == &quot;QVariant&quot;) {
-				Attribute *Attribute_ptr = new Attribute((AttributeType) var_ollo_0, (int) var_ollo_1, (int) var_ollo_2, (QVariant) var_ollo_3);
-			PHP_QT_REGISTER(Attribute_ptr);
-			RETURN_NULL();
-			}
-		}
-	}
+  zval *zend_ptr;
+};
+Attribute_php_qt::Attribute_php_qt(zval * zend_ptr, AttributeType ts0, int ss1, int ls2, QVariant vals3):
+Attribute(ts0, ss1, ls2, vals3)
+{
+  this-&gt;zend_ptr = zend_ptr;
 }
 
+/*!
+ * method Attribute
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	AttributeType ts0s0
+ * @param	int ss1s1
+ * @param	int ls2s2
+ * @param	QVariant vals3s3
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(Attribute);
-
+ZEND_METHOD(Attribute, __construct)
+{
+// notice: unknown argument AttributeType ts0s0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in Attribute::Attribute(...) &quot;);
+}

Modified: trunk/qt/classes/qinternal.cpp
===================================================================
--- trunk/qt/classes/qinternal.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qinternal.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,35 +19,14 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QInternal.cpp - QInternal PHP implementation.
- * begin           : Wed Jan 11 20:29:53 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QInternal&gt;
 #include &quot;../php_qt.h&quot;
 
 
-
-/*		public enumPaintDeviceFlags:long {
-			UnknownDevice = 0x00,
-			Widget = 0x01,
-			Pixmap = 0x02,
-			Image = 0x03,
-			Printer = 0x04,
-			Picture = 0x05,
-			Pbuffer = 0x06
-		}
-*/
-
-/*		public enumRelayoutType:long {
-			RelayoutType = 0,
-			RelayoutType = 1,
-			RelayoutType = 2
-		}
-*/
-
-PHP_QT_DESTRUCT(QInternal);
-
+#include &lt;QInternal&gt;

Modified: trunk/qt/classes/qkeyevent.cpp
===================================================================
--- trunk/qt/classes/qkeyevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qkeyevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,94 +19,234 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QKeyEvent.cpp - QKeyEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QKeyEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QKeyEvent */
-/*
- *    function  count
- *    flags:    c
+#include &lt;QKeyEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QKeyEvent_php_qt:public QKeyEvent
+{
+
+public:
+  QKeyEvent_php_qt(zval * zend_ptr, Type types0, int keys1, Qt::KeyboardModifiers modifierss2, const QString &amp; text = QString(), bool autorep =
+                   false, ushort count = 1);
+
+
+  zval *zend_ptr;
+};
+QKeyEvent_php_qt::QKeyEvent_php_qt(zval * zend_ptr, Type types0, int keys1, Qt::KeyboardModifiers modifierss2, const QString &amp; text, bool autorep,
+                                   ushort count):
+QKeyEvent(types0, keys1, modifierss2, text, autorep, count)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method key
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QKeyEvent, count){
-	if (ZEND_NUM_ARGS() == 0){
-			QKeyEvent *obj = (QKeyEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;count());
-	}
+
+ZEND_METHOD(QKeyEvent, key)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'key' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QKeyEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QKeyEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;key());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QKeyEvent::key(...) &quot;);
 }
 
-/*********************************
- *    class     QKeyEvent */
-/*
- *    function  text
- *    flags:    c
+/*!
+ * method count
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QKeyEvent, text){
-	if (ZEND_NUM_ARGS() == 0){
-			QKeyEvent *obj = (QKeyEvent*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;text();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QKeyEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QKeyEvent, count)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'count' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QKeyEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QKeyEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;count());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QKeyEvent::count(...) &quot;);
 }
 
-/*********************************
- *    class     QKeyEvent */
-/*
- *    function  isAutoRepeat
- *    flags:    c
+/*!
+ * method text
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QKeyEvent, isAutoRepeat){
-	if (ZEND_NUM_ARGS() == 0){
-			QKeyEvent *obj = (QKeyEvent*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isAutoRepeat());
-	}
+
+ZEND_METHOD(QKeyEvent, text)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'text' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QKeyEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QKeyEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;text());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QKeyEvent::text(...) &quot;);
 }
 
-/*********************************
- *    class     QKeyEvent */
-/*
- *    function  modifiers
- *    flags:    c
+/*!
+ * method QKeyEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	int keys1s1
+ * @param	Qt::KeyboardModifiers modifierss2s2
+ * @param	 const QString &amp; text = QString()s3
+ * @param	 bool autorep = falses4
+ * @param	 ushort count = 1s5
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QKeyEvent, modifiers){
-	if (ZEND_NUM_ARGS() == 0){
-			QKeyEvent *obj = (QKeyEvent*) PHP_QT_FETCH();
-				Qt::KeyboardModifiers return_object = (Qt::KeyboardModifiers) obj-&gt;modifiers();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QKeyEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QKeyEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QKeyEvent::QKeyEvent(...) &quot;);
 }
 
-/*********************************
- *    class     QKeyEvent */
-/*
- *    function  key
- *    flags:    c
+/*!
+ * method modifiers
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::KeyboardModifiers
+ * @flags	c
  */
-ZEND_METHOD(QKeyEvent, key){
-	if (ZEND_NUM_ARGS() == 0){
-			QKeyEvent *obj = (QKeyEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;key());
-	}
+
+ZEND_METHOD(QKeyEvent, modifiers)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'modifiers' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QKeyEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QKeyEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;modifiers());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QKeyEvent::modifiers(...) &quot;);
 }
 
+/*!
+ * method isAutoRepeat
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QKeyEvent);
+ZEND_METHOD(QKeyEvent, isAutoRepeat)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isAutoRepeat' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QKeyEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QKeyEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isAutoRepeat());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QKeyEvent::isAutoRepeat(...) &quot;);
+}

Modified: trunk/qt/classes/qlabel.cpp
===================================================================
--- trunk/qt/classes/qlabel.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlabel.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,786 +19,1567 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLabel.cpp - QLabel PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QLabel&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  tr
- *    flags:    s
- */
-ZEND_METHOD(QLabel, tr){
-		/* ss public*/
+#include &lt;QLabel&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QLabel_php_qt:public QLabel
+{
 
-		/* const char* , const char* ,  */
+public:
+  QLabel_php_qt(zval * zend_ptr, QWidget * parent = 0, Qt::WFlags f = 0);
+  QLabel_php_qt(zval * zend_ptr, const QString &amp; texts0, QWidget * parent = 0, Qt::WFlags f = 0);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
 
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
-				QString return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+QLabel_php_qt::QLabel_php_qt(zval * zend_ptr, QWidget * parent, Qt::WFlags f):QLabel(parent, f)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QLabel&quot;,&amp;staticMetaObject));
 }
+QLabel_php_qt::QLabel_php_qt(zval * zend_ptr, const QString &amp; texts0, QWidget * parent, Qt::WFlags f):
+QLabel(texts0, parent, f)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QLabel&quot;,&amp;staticMetaObject));
+}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setMargin
- *    flags:    
+PHP_QT_MOC(QLabel);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLabel, setMargin){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLabel, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setMargin((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLabel::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLabel::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  clear
- *    flags:    l
+/*!
+ * method setMargin
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLabel, clear){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			obj-&gt;clear();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLabel, setMargin)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMargin' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMargin((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::setMargin(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  qt_invoke
- *    flags:    v
+/*!
+ * method clear
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLabel, qt_invoke){
+
+ZEND_METHOD(QLabel, clear)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'clear' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;clear());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::clear(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setBuddy
- *    flags:    
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLabel, setBuddy){
-		/* o public*/
 
-		/* qt_QWidget* ,  */
+/*!
+ * method hasScaledContents
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QLabel, hasScaledContents)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hasScaledContents' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
 
-
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				obj-&gt;setBuddy((QWidget*) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;hasScaledContents());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::hasScaledContents(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  movie
- *    flags:    c
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QLabel, movie){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				QMovie * return_object = (QMovie *) obj-&gt;movie();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  hasScaledContents
- *    flags:    c
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QLabel, hasScaledContents){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;hasScaledContents());
-	}
+
+/*!
+ * method setScaledContents
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLabel, setScaledContents)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setScaledContents' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setScaledContents((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::setScaledContents(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method indent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLabel, qt_cast){
+
+ZEND_METHOD(QLabel, indent)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'indent' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;indent());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::indent(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  metaObject
- *    flags:    cv
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLabel, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				QMetaObject * return_object = (QMetaObject *) obj-&gt;metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method setAlignment
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Alignment Qt::Alignments0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLabel, setAlignment)
+{
+  ///Qt::Alignment Qt::Alignments0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setAlignment' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::Alignment Qt::Alignments0,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setAlignment((Qt::Alignment) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::setAlignment(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setScaledContents
- *    flags:    
+/*!
+ * method pixmap
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPixmap *
+ * @flags	c
  */
-ZEND_METHOD(QLabel, setScaledContents){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLabel, pixmap)
+{
+  ///
+#ifdef PHP_QT_QPixmap           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pixmap' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setScaledContents((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast &lt; QPixmap * &gt;(selfpointer-&gt;pixmap());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::pixmap(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  event
- *    flags:    
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QLabel, event){
-		/* o protected*/
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  indent
- *    flags:    c
+/*!
+ * method buddy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
-ZEND_METHOD(QLabel, indent){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;indent());
-	}
+
+ZEND_METHOD(QLabel, buddy)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'buddy' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;buddy());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::buddy(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method setMovie
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMovie *movies0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLabel, qt_emit){
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  pixmap
- *    flags:    c
- */
-ZEND_METHOD(QLabel, pixmap){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				const QPixmap * return_object = (const QPixmap *) obj-&gt;pixmap();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QLabel, setMovie)
+{
+  ///QMovie *movies0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QMovie
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setMovie' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QMovie *movies0,
+        QLabel *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+        }
+        QMovie *cpp_arg_0 = static_cast &lt; QMovie * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setMovie((QMovie *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::setMovie(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setAlignment
- *    flags:    
+/*!
+ * method setPicture
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPicture &amp;s0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLabel, setAlignment){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLabel, setPicture)
+{
+  ///const QPicture &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPicture
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setPicture' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPicture &amp;s0,
+        QLabel *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+        }
+        QPicture *cpp_arg_0 = static_cast &lt; QPicture * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setPicture((const QPicture &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;setAlignment((Qt::Alignment) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::setPicture(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method setNum
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * overloaded args:
+ * @param	double
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLabel, className){
+
+ZEND_METHOD(QLabel, setNum)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setNum((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  ///double
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try double,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setNum((double)Z_DVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::setNum(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  buddy
- *    flags:    c
+/*!
+ * method wordWrap
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLabel, buddy){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				QWidget * return_object = (QWidget *) obj-&gt;buddy();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  textFormat
- *    flags:    c
- */
-ZEND_METHOD(QLabel, textFormat){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;textFormat());
-	}
+ZEND_METHOD(QLabel, wordWrap)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'wordWrap' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;wordWrap());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::wordWrap(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setMovie
- *    flags:    l
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QLabel, setMovie){
-		/* o public_slots*/
 
-		/* qt_QMovie* movie,  */
+ZEND_METHOD(QLabel, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0-&gt;inherits(&quot;QMovie&quot;)) {
-				obj-&gt;setMovie((QMovie*) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QLabel::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setPicture
- *    flags:    l
+/*!
+ * method setTextFormat
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::TextFormat Qt::TextFormats0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLabel, setPicture){
-		/* o public_slots*/
 
-		/* const QPicture&amp; ,  */
+ZEND_METHOD(QLabel, setTextFormat)
+{
+  ///Qt::TextFormat Qt::TextFormats0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setTextFormat' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::TextFormat Qt::TextFormats0,
+      QLabel *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setTextFormat((Qt::TextFormat) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::setTextFormat(...) &quot;);
+}
 
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
+ */
 
-			if(obj_z_0-&gt;inherits(&quot;QPicture&quot;)) {
-				obj-&gt;setPicture((const QPicture&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+/*!
+ * method text
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
+
+ZEND_METHOD(QLabel, text)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'text' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;text());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::text(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setNum
- *    flags:    l
+/*!
+ * method minimumSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLabel, setNum){
-		/* l public_slots*/
 
-		/* int ,  */
+ZEND_METHOD(QLabel, minimumSizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumSizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setNum((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;minimumSizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::minimumSizeHint(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  wordWrap
- *    flags:    c
+/*!
+ * method heightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLabel, wordWrap){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;wordWrap());
-	}
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  staticMetaObject
- *    flags:    s
- */
-ZEND_METHOD(QLabel, staticMetaObject){
+ZEND_METHOD(QLabel, heightForWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'heightForWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;heightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::heightForWidth(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setTextFormat
- *    flags:    
+/*!
+ * method setPixmap
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPixmap &amp;s0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLabel, setTextFormat){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLabel, setPixmap)
+{
+  ///const QPixmap &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPixmap &amp;s0,
+        QLabel *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+        }
+        QPixmap *cpp_arg_0 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setPixmap((const QPixmap &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;setTextFormat((Qt::TextFormat) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::setPixmap(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLabel, qObject){
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setText
- *    flags:    l
+/*!
+ * method setBuddy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLabel, setText){
-		/* o public_slots*/
 
-		/* const QString&amp; ,  */
+ZEND_METHOD(QLabel, setBuddy)
+{
+  ///QWidget *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setBuddy' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *s0,
+        QLabel *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setBuddy((QWidget *) cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				obj-&gt;setText((const QString&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::setBuddy(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  text
- *    flags:    c
+/*!
+ * method movie
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMovie *
+ * @flags	c
  */
-ZEND_METHOD(QLabel, text){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;text();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLabel, movie)
+{
+  ///
+#ifdef PHP_QT_QMovie            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'movie' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QMovie * &gt;(selfpointer-&gt;movie());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::movie(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  alignment
- *    flags:    c
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *es0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QLabel, alignment){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;alignment());
-	}
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method textFormat
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::TextFormat
+ * @flags	c
  */
-ZEND_METHOD(QLabel, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj-&gt;sizeHint();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLabel, textFormat)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'textFormat' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;textFormat());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::textFormat(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  minimumSizeHint
- *    flags:    c
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLabel, minimumSizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj-&gt;minimumSizeHint();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  heightForWidth
- *    flags:    c
+/*!
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLabel, heightForWidth){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method setText
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+ZEND_METHOD(QLabel, setText)
+{
+  ///const QString &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QLabel *selfpointer;
 
-			RETURN_LONG(obj-&gt;heightForWidth((int) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setText((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::setText(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setPixmap
- *    flags:    l
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLabel, setPixmap){
-		/* o public_slots*/
 
-		/* const QPixmap&amp; ,  */
+ZEND_METHOD(QLabel, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0-&gt;inherits(&quot;QPixmap&quot;)) {
-				obj-&gt;setPixmap((const QPixmap&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  picture
- *    flags:    c
- */
-ZEND_METHOD(QLabel, picture){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-				const QPicture * return_object = (const QPicture *) obj-&gt;picture();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::sizeHint(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setWordWrap
- *    flags:    
+/*!
+ * method alignment
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Alignment
+ * @flags	c
  */
-ZEND_METHOD(QLabel, setWordWrap){
-		/* l public*/
 
-		/* int on,  */
+ZEND_METHOD(QLabel, alignment)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'alignment' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-
-
-			obj-&gt;setWordWrap((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;alignment());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::alignment(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method picture
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPicture *
+ * @flags	c
  */
-ZEND_METHOD(QLabel, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QLabel, picture)
+{
+  ///
+#ifdef PHP_QT_QPicture          // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'picture' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLabel_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast &lt; QPicture * &gt;(selfpointer-&gt;picture());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::picture(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method setWordWrap
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool ons0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLabel, qt_property){
+
+ZEND_METHOD(QLabel, setWordWrap)
+{
+  ///bool ons0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setWordWrap' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool ons0,
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setWordWrap((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::setWordWrap(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  QLabel
- *    flags:    t
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLabel, __construct){
-		/* ol public*/
 
-		/* qt_QWidget* parent, int f,  */
+ZEND_METHOD(QLabel, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				QLabel *QLabel_ptr = new QLabel((QWidget*) obj_z_0, (Qt::WFlags) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QLabel_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ool public*/
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-		/* const QString&amp; text, qt_QWidget* parent, int f,  */
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLabel::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLabel *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; obj_z_1-&gt;inherits(&quot;QWidget&quot;)) {
-				QLabel *QLabel_ptr = new QLabel((const QString&amp;) obj_z_0, (QWidget*) obj_z_1, (Qt::WFlags) Z_LVAL_P(z_2));
-				PHP_QT_REGISTER(QLabel_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLabel::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::trUtf8(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  setIndent
- *    flags:    
+/*!
+ * method QLabel
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parent=0s0
+ * @param	 Qt::WFlags f=0s1
+ * 
+ * overloaded args:
+ * @param	const QString &amp;texts0
+ * @param	 QWidget  *parent=0
+ * @param	 Qt::WFlags f=0
+ * 
+ * overloaded args:
+ * @param	const QLabel &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QLabel, setIndent){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLabel, __construct)
+{
+  ///QWidget *parent=0s0, Qt::WFlags f=0s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel_php_qt *selfpointer = new QLabel_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget *parent=0s0,
+      QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QLabel_php_qt *selfpointer = new QLabel_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget *parent=0s0, Qt::WFlags f=0s1,
+      QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QLabel_php_qt *selfpointer = new QLabel_php_qt(getThis(), (QWidget *) cpp_arg_0, (Qt::WFlags) Z_LVAL_P(arg_1));
 
-			obj-&gt;setIndent((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QString &amp;texts0, QWidget  *parent=0, Qt::WFlags f=0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;texts0,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QLabel_php_qt *selfpointer = new QLabel_php_qt(getThis(), (const QString &amp;)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;texts0, QWidget  *parent=0,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QWidget *cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+        QLabel_php_qt *selfpointer = new QLabel_php_qt(getThis(), (const QString &amp;)*cpp_arg_0, (QWidget *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;texts0, QWidget  *parent=0, Qt::WFlags f=0,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QWidget *cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+        QLabel_php_qt *selfpointer = new QLabel_php_qt(getThis(), (const QString &amp;)*cpp_arg_0, (QWidget *) cpp_arg_1, (Qt::WFlags) Z_LVAL_P(arg_2));
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QLabel &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLabel
+      if (inherits(Z_OBJCE_P(arg_0), 38)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QLabel::__construct(...) cannot be called with 'const QLabel &amp;,'.&quot;);
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::QLabel(...) &quot;);
 }
 
-/*********************************
- *    class     QLabel */
-/*
- *    function  margin
- *    flags:    c
+/*!
+ * method margin
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLabel, margin){
-	if (ZEND_NUM_ARGS() == 0){
-			QLabel *obj = (QLabel*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;margin());
-	}
+
+ZEND_METHOD(QLabel, margin)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'margin' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLabel *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;margin());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::margin(...) &quot;);
 }
 
+/*!
+ * method setIndent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QLabel);
+ZEND_METHOD(QLabel, setIndent)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setIndent' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLabel *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLabel * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setIndent((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLabel::setIndent(...) &quot;);
+}

Modified: trunk/qt/classes/qlatin1char.cpp
===================================================================
--- trunk/qt/classes/qlatin1char.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlatin1char.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,70 +19,128 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLatin1Char.cpp - QLatin1Char PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QLatin1Char&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QLatin1Char */
-/*
- *    function  unicode
- *    flags:    c
- */
-ZEND_METHOD(QLatin1Char, unicode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLatin1Char *obj = (QLatin1Char*) PHP_QT_FETCH();
-			obj-&gt;unicode();
-			RETURN_NULL();
-	}
+#include &lt;QLatin1Char&gt;
+#include &lt;QMetaMethod&gt;
+class QLatin1Char_php_qt:public QLatin1Char
+{
+
+public:
+  QLatin1Char_php_qt(zval * zend_ptr, char cs0);
+
+
+  zval *zend_ptr;
+};
+QLatin1Char_php_qt::QLatin1Char_php_qt(zval * zend_ptr, char cs0):
+QLatin1Char(cs0)
+{
+  this-&gt;zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QLatin1Char */
-/*
- *    function  QLatin1Char
- *    flags:    t
+/*!
+ * method QLatin1Char
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	char cs0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QLatin1Char, __construct){
-		/* l public*/
 
-		/* char c,  */
+ZEND_METHOD(QLatin1Char, __construct)
+{
+  ///char cs0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try char cs0s0,
+      QLatin1Char_php_qt *selfpointer = new QLatin1Char_php_qt(getThis(), (char)Z_STRVAL_P(arg_0)[0]);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLatin1Char::QLatin1Char(...) &quot;);
+}
 
+/*!
+ * method toLatin1
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char
+ * @flags	c
+ */
 
-			QLatin1Char *QLatin1Char_ptr = new QLatin1Char((char) Z_LVAL_P(z_0));
-				PHP_QT_REGISTER(QLatin1Char_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QLatin1Char, toLatin1)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toLatin1' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLatin1Char *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLatin1Char * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer-&gt;toLatin1(), 1);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLatin1Char::toLatin1(...) &quot;);
 }
 
-/*********************************
- *    class     QLatin1Char */
-/*
- *    function  toLatin1
- *    flags:    c
+/*!
+ * method unicode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const ushort
+ * @flags	c
  */
-ZEND_METHOD(QLatin1Char, toLatin1){
-	if (ZEND_NUM_ARGS() == 0){
-			QLatin1Char *obj = (QLatin1Char*) PHP_QT_FETCH();
-			obj-&gt;toLatin1();
-			RETURN_NULL();
-	}
-}
 
+ZEND_METHOD(QLatin1Char, unicode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'unicode' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLatin1Char *selfpointer;
 
-PHP_QT_DESTRUCT(QLatin1Char);
-
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLatin1Char * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;unicode());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLatin1Char::unicode(...) &quot;);
+}

Modified: trunk/qt/classes/qlatin1string.cpp
===================================================================
--- trunk/qt/classes/qlatin1string.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlatin1string.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,61 +19,173 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLatin1String.cpp - QLatin1String PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QLatin1String&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QLatin1String */
-/*
- *    function  QLatin1String
- *    flags:    t
- */
-ZEND_METHOD(QLatin1String, __construct){
-		/* s public*/
+#include &lt;QLatin1String&gt;
+#include &lt;QMetaMethod&gt;
+class QLatin1String_php_qt:public QLatin1String
+{
 
-		/* const char* s,  */
+public:
+  QLatin1String_php_qt(zval * zend_ptr, const char *ss0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING){
 
-
-			QLatin1String *QLatin1String_ptr = new QLatin1String( (const char*) Z_STRVAL_P(z_0));
-				PHP_QT_REGISTER(QLatin1String_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
+  zval *zend_ptr;
+};
+QLatin1String_php_qt::QLatin1String_php_qt(zval * zend_ptr, const char *ss0):
+QLatin1String(ss0)
+{
+  this-&gt;zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QLatin1String */
-/*
- *    function  latin1
- *    flags:    c
+/*!
+ * method QLatin1String
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *ss0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QLatin1String, latin1){
-	if (ZEND_NUM_ARGS() == 0){
-			QLatin1String *obj = (QLatin1String*) PHP_QT_FETCH();
-				const char * return_object = (const char *) obj-&gt;latin1();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLatin1String_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLatin1String, __construct)
+{
+  ///const char *ss0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try const char *ss0s0,
+      QLatin1String_php_qt *selfpointer = new QLatin1String_php_qt(getThis(), (const char *)&amp;Z_STRVAL_P(arg_0)[0]);
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLatin1String::QLatin1String(...) &quot;);
 }
 
+/*!
+ * method operator&lt;
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QLatin1String);
+/*!
+ * method operator==
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
+/*!
+ * method operator!=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+/*!
+ * method operator&gt;
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+/*!
+ * method operator&lt;=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+/*!
+ * method latin1
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	c
+ */
+
+ZEND_METHOD(QLatin1String, latin1)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'latin1' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLatin1String *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLatin1String * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_STRING((char *)selfpointer-&gt;latin1(), 1);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLatin1String::latin1(...) &quot;);
+}
+
+/*!
+ * method operator&gt;=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */

Modified: trunk/qt/classes/qlayout.cpp
===================================================================
--- trunk/qt/classes/qlayout.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlayout.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,873 +19,1904 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLayout.cpp - QLayout PHP implementation.
- * begin           : Thu Feb 23 16:36:28 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
+
 #include &quot;../php_qt.h&quot;
 
 
 #include &lt;QLayout&gt;
+/// DEBUG:destructor skipped.
+/*!
+ * method addItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *
+ * 
+ * @access	public
+ * @return	void
+ * @flags	pv
+ */
 
+/*!
+ * method count
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cpv
+ */
 
-/*		public enumSizeConstraint:long {
-			SizeConstraint = 0,
-			SizeConstraint = 1,
-			SizeConstraint = 2,
-			SizeConstraint = 3,
-			SizeConstraint = 4,
-			SizeConstraint = 5
-		}
-*/
-/*********************************
- *    class     QLayout
- *    function  totalHeightForWidth
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    int w
+/*!
+ * method itemAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int index
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	cpv
  */
-ZEND_METHOD(QLayout, totalHeightForWidth){
-		/* l public*/
 
-		/* int w,  */
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect&amp;
+ * 
+ * @access	public
+ * @return	void
+ * @flags	p
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+/*!
+ * method takeAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int index
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	pv
+ */
 
+#include &lt;QLayoutItem&gt;
+#include &lt;QRect&gt;
+#include &lt;QMetaMethod&gt;
+class QLayout_php_qt:public QLayout
+{
 
-			RETURN_LONG(obj-&gt;totalHeightForWidth((int) Z_LVAL_P(z_0)));
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+public:
+  QLayout_php_qt(zval * zend_ptr, QWidget * parents0);
+  QLayout_php_qt(zval * zend_ptr);
+
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+  virtual void addItem(QLayoutItem * s0);       // pure 
+
+  virtual int count() const;    // pure 
+
+  virtual QLayoutItem *itemAt(int indexs0) const;       // pure 
+
+  virtual QLayoutItem *takeAt(int indexs0);     // pure 
+protected:
+  void protected_setGeometry(const QRect &amp; s0); // pure 
+};
+
+QLayout_php_qt::QLayout_php_qt(zval * zend_ptr, QWidget * parents0):QLayout(parents0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QLayout&quot;,&amp;staticMetaObject));
 }
 
-/*********************************
- *    class     QLayout
- *    function  tr
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
- */
-ZEND_METHOD(QLayout, tr){
-		/* ss public*/
+QLayout_php_qt::QLayout_php_qt(zval * zend_ptr):QLayout()
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QLayout&quot;,&amp;staticMetaObject));
+}
 
-		/* const char* , const char* ,  */
+// virtual, pure 
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+void
+QLayout_php_qt::addItem(QLayoutItem * s0)
+{
+}
 
+// virtual, pure 
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QLayout::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+int
+QLayout_php_qt::count() const
+{
 }
 
-/*********************************
- *    class     QLayout
- *    function  isEmpty
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
+// virtual, pure 
+
+QLayoutItem *
+QLayout_php_qt::itemAt(int indexs0) const
+{
+}
+
+// virtual, pure 
+
+QLayoutItem *
+QLayout_php_qt::takeAt(int indexs0)
+{
+}
+void
+QLayout_php_qt::protected_setGeometry(const QRect &amp; s0)
+{
+  this-&gt;setGeometry(s0);
+}
+
+PHP_QT_MOC(QLayout);
+
+/*!
+ * method totalHeightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ws0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLayout, isEmpty){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isEmpty());
-	}
+
+ZEND_METHOD(QLayout, totalHeightForWidth)
+{
+  ///int ws0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'totalHeightForWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ws0,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;totalHeightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::totalHeightForWidth(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  setMargin
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLayout, setMargin){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLayout, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLayout *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setMargin((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLayout::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLayout::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  activate
- *    flags:    
- *    access:    public
- *    return:    bool
- *    params:    
+/*!
+ * method setMargin
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, activate){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;activate());
-	}
+
+ZEND_METHOD(QLayout, setMargin)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMargin' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMargin((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::setMargin(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  setMenuBar
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QWidget *w
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLayout, setMenuBar){
-//qt_QWidget*
-		/* o public*/
 
-		/* qt_QWidget* w,  */
+/*!
+ * method addItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *s0s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	pv
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method activate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
 
+ZEND_METHOD(QLayout, activate)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'activate' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				obj-&gt;setMenuBar((QWidget*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;activate());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::activate(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  layout
- *    flags:    
- *    access:    public
- *    return:    QLayout *
- *    params:    
+/*!
+ * method setMenuBar
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, layout){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QLayout ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QLayout *) obj-&gt;layout();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLayout, setMenuBar)
+{
+  ///QWidget *ws0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setMenuBar' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0,
+        QLayout *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setMenuBar((QWidget *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::setMenuBar(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  totalMaximumSize
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method layout
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QLayout *
+ * @flags	
  */
-ZEND_METHOD(QLayout, totalMaximumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;totalMaximumSize();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLayout, layout)
+{
+  ///
+#ifdef PHP_QT_QLayout           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'layout' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QLayout * &gt;(selfpointer-&gt;layout());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::layout(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  sizeConstraint
- *    flags:    c
- *    access:    public
- *    return:    SizeConstraint
- *    params:    
+/*!
+ * method totalMaximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLayout, sizeConstraint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			obj-&gt;sizeConstraint();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLayout, totalMaximumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'totalMaximumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;totalMaximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::totalMaximumSize(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  geometry
- *    flags:    c
- *    access:    public
- *    return:    QRect
- *    params:    
+/*!
+ * method sizeConstraint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	SizeConstraint
+ * @flags	c
  */
-ZEND_METHOD(QLayout, geometry){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QRect* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QRect) obj-&gt;geometry();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLayout, sizeConstraint)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type SizeConstraint&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::sizeConstraint(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  invalidate
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QLayout, invalidate){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			obj-&gt;invalidate();
-			RETURN_NULL();
-	}
+
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
+
+/*!
+ * method count
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cpv
+ */
+
+/*!
+ * method widgetEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
+
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
+
+/*!
+ * method setAlignment
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * @param	 Qt::Alignment alignments1
+ * 
+ * overloaded args:
+ * @param	QLayout *l
+ * @param	 Qt::Alignment alignment
+ * 
+ * overloaded args:
+ * @param	Qt::Alignment alignment
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
+
+ZEND_METHOD(QLayout, setAlignment)
+{
+  ///QWidget *ws0, Qt::Alignment alignments1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setAlignment' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0, Qt::Alignment alignments1,
+        QLayout *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;setAlignment((QWidget *) cpp_arg_0, (Qt::Alignment) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///QLayout *l, Qt::Alignment alignment
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setAlignment' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayout *l, Qt::Alignment alignment,
+        QLayout *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayout *cpp_arg_0 = static_cast &lt; QLayout * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;setAlignment((QLayout *) cpp_arg_0, (Qt::Alignment) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///Qt::Alignment alignment
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setAlignment' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::Alignment alignment,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setAlignment((Qt::Alignment) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::setAlignment(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  setGeometry
- *    flags:    p
- *    access:    public
- *    return:    void
- *    params:    const QRect&amp;
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QLayout, setGeometry){
-//const QRect&amp;
-		/* o public*/
 
-		/* const QRect&amp; ,  */
+/*!
+ * method removeWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QLayout, removeWidget)
+{
+  ///QWidget *ws0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'removeWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0,
+        QLayout *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QRect&quot;)) {
-				obj-&gt;setGeometry((const QRect&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+        RETURN_VOID(selfpointer-&gt;removeWidget((QWidget *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::removeWidget(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  setAlignment
- *    flags:    
- *    access:    public
- *    return:    bool
- *    params:    QWidget *w, Qt::Alignment alignment
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QLayout, setAlignment){
-//qt_QWidget*
-		/* ol public*/
 
-		/* qt_QWidget* w, int alignment,  */
+ZEND_METHOD(QLayout, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QLayout *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				RETURN_BOOL(obj-&gt;setAlignment((QWidget*) obj_z_0, (Qt::Alignment) Z_LVAL_P(z_1)));
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QLayout::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  removeWidget
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QWidget *w
+/*!
+ * method itemAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0s0
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	cpv
  */
-ZEND_METHOD(QLayout, removeWidget){
-//qt_QWidget*
-		/* o public*/
 
-		/* qt_QWidget* w,  */
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method totalMinimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
+ */
 
+ZEND_METHOD(QLayout, totalMinimumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				obj-&gt;removeWidget((QWidget*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'totalMinimumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;totalMinimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::totalMinimumSize(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  setEnabled
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    bool
+/*!
+ * method childEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChildEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, setEnabled){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method QLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parents0s0
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutPrivate &amp;d
+ * @param	 QLayout*
+ * @param	 QWidget*
+ * 
+ * overloaded args:
+ * @param	const QLayout &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+ZEND_METHOD(QLayout, __construct)
+{
+  ///QWidget *parents0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *parents0s0,
+        QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+        QLayout_php_qt *selfpointer = new QLayout_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-			obj-&gt;setEnabled((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout_php_qt *selfpointer = new QLayout_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QLayoutPrivate &amp;d, QLayout*, QWidget*
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QLayoutPrivate
+#ifdef PHP_QT_QLayout
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 41) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 71)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayoutPrivate &amp;d, QLayout*, QWidget*,
+        QLayoutPrivate *cpp_arg_0 = static_cast &lt; QLayoutPrivate * &gt;(php_qt_fetch(arg_0));
+        QLayout *cpp_arg_1 = static_cast &lt; QLayout * &gt;(php_qt_fetch(arg_1));
+        QWidget *cpp_arg_2 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_2));
+        QLayout_php_qt *selfpointer = new QLayout_php_qt(getThis(), (QLayoutPrivate &amp;) * cpp_arg_0, (QLayout *) cpp_arg_1, (QWidget *) cpp_arg_2);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+  ///const QLayout &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QLayout::__construct(...) cannot be called with 'const QLayout &amp;,'.&quot;);
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::QLayout(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  addWidget
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QWidget *w
+/*!
+ * method setSpacing
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, addWidget){
-//qt_QWidget*
-		/* o public*/
 
-		/* qt_QWidget* w,  */
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
+ZEND_METHOD(QLayout, setSpacing)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setSpacing' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLayout *selfpointer;
 
-			    QLayout *obj = static_cast&lt;QLayout*&gt;(PHP_QT_FETCH());
-			    QWidget* obj_z_0 = static_cast&lt;QWidget*&gt;(php_qt_fetch(z_0));
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setSpacing((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::setSpacing(...) &quot;);
+}
 
-//			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				obj-&gt;addWidget(obj_z_0);
-			    RETURN_NULL();
-//			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+/*!
+ * method setSizeConstraint
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	SizeConstraint SizeConstraints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLayout, setSizeConstraint)
+{
+// notice: unknown argument SizeConstraint SizeConstraints0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::setSizeConstraint(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  removeItem
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    QLayoutItem *
+/*!
+ * method menuBar
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
-ZEND_METHOD(QLayout, removeItem){
-//qt_QLayoutItem*
-		/* o public*/
 
-		/* qt_QLayoutItem* ,  */
+ZEND_METHOD(QLayout, menuBar)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'menuBar' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(obj_z_0-&gt;inherits(&quot;QLayoutItem&quot;)) {
-				obj-&gt;removeItem((QLayoutItem*) obj_z_0);
-			RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;menuBar());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::menuBar(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  staticMetaObject
- *    flags:    s
- *    access:    public
- *    return:    QMetaObject*
- *    params:    
+/*!
+ * method totalSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLayout, staticMetaObject){
+
+ZEND_METHOD(QLayout, totalSizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'totalSizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;totalSizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::totalSizeHint(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  qObject
- *    flags:    
- *    access:    public
- *    return:    QObject*
- *    params:    
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLayout, qObject){
+
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	c
+ */
+
+ZEND_METHOD(QLayout, expandingDirections)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'expandingDirections' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;expandingDirections());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::expandingDirections(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  totalMinimumSize
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method indexOf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cv
  */
-ZEND_METHOD(QLayout, totalMinimumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;totalMinimumSize();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method update
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLayout, update)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'update' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;update());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::update(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  minimumSize
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method addChildWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, minimumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;minimumSize();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method alignmentRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;s0
+ * 
+ * @access	protected
+ * @return	QRect
+ * @flags	c
+ */
+
+/*!
+ * method isEmpty
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+ZEND_METHOD(QLayout, isEmpty)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isEmpty' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isEmpty());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::isEmpty(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  setSpacing
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    int
+/*!
+ * method geometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-ZEND_METHOD(QLayout, setSpacing){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLayout, geometry)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'geometry' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setSpacing((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QRect *return_object = new QRect;
+
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;geometry());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::geometry(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  isEnabled
- *    flags:    c
- *    access:    public
- *    return:    bool
- *    params:    
+/*!
+ * method invalidate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, isEnabled){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isEnabled());
-	}
+
+ZEND_METHOD(QLayout, invalidate)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'invalidate' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;invalidate());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::invalidate(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  setSizeConstraint
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    SizeConstraint
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;s0s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	p
  */
-ZEND_METHOD(QLayout, setSizeConstraint){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLayout, setGeometry)
+{
+  ///const QRect &amp;s0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setGeometry' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;s0s0,
+        QLayout *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+        }
+        QRect *cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setGeometry((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;setSizeConstraint((QLayout::SizeConstraint) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::setGeometry(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  menuBar
- *    flags:    c
- *    access:    public
- *    return:    QWidget *
- *    params:    
+/*!
+ * method addChildLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayout *ls0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, menuBar){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj-&gt;menuBar();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method setEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLayout, setEnabled)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::setEnabled(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  totalSizeHint
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method takeAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int indexs0s0
+ * 
+ * @access	public
+ * @return	QLayoutItem *
+ * @flags	pv
  */
-ZEND_METHOD(QLayout, totalSizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;totalSizeHint();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+/*!
+ * method removeItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLayout, removeItem)
+{
+  ///QLayoutItem *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'removeItem' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayoutItem *s0,
+        QLayout *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+        }
+        QLayoutItem *cpp_arg_0 = static_cast &lt; QLayoutItem * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;removeItem((QLayoutItem *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::removeItem(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  closestAcceptableSize
- *    flags:    s
- *    access:    public
- *    return:    QSize
- *    params:    const QWidget *w, const QSize &amp;s
+/*!
+ * method addWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLayout, closestAcceptableSize){
-//const QWidget*
-//const QSize&amp;
-		/* oo public*/
 
-		/* const QWidget* w, const QSize&amp; s,  */
+ZEND_METHOD(QLayout, addWidget)
+{
+  ///QWidget *ws0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addWidget' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0,
+        QLayout *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;addWidget((QWidget *) cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;) &amp;&amp; obj_z_1-&gt;inherits(&quot;QSize&quot;)) {
-				QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;closestAcceptableSize((const QWidget*) obj_z_0, (const QSize&amp;) *obj_z_1);
-			} else {
-				*return_object = (QSize) QLayout::closestAcceptableSize((const QWidget*) obj_z_0, (const QSize&amp;) *obj_z_1);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::addWidget(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  parentWidget
- *    flags:    c
- *    access:    public
- *    return:    QWidget *
- *    params:    
+/*!
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLayout, parentWidget){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QWidget ** return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QWidget *) obj-&gt;parentWidget();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLayout, minimumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;minimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::minimumSize(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  trUtf8
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+/*!
+ * method isEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLayout, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QLayout, isEnabled)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isEnabled());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::isEnabled(...) &quot;);
+}
 
+/*!
+ * method closestAcceptableSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QWidget *ws0
+ * @param	 const QSize  &amp;ss1
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	s
+ */
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QLayout::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+ZEND_METHOD(QLayout, closestAcceptableSize)
+{
+  ///const QWidget *ws0, const QSize  &amp;ss1
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 71) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        /// try const QWidget *ws0, const QSize  &amp;ss1,
+        QLayout *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+        QSize *cpp_arg_1 = static_cast &lt; QSize * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QSize *return_object = new QSize;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QSize &gt; (QLayout::closestAcceptableSize((const QWidget *)cpp_arg_0, (const QSize &amp;)*cpp_arg_1));
+        } else {
+          *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;closestAcceptableSize((const QWidget *)cpp_arg_0, (const QSize &amp;)*cpp_arg_1));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::closestAcceptableSize(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  maximumSize
- *    flags:    c
- *    access:    public
- *    return:    QSize
- *    params:    
+/*!
+ * method parentWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
-ZEND_METHOD(QLayout, maximumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			QSize* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;maximumSize();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLayout, parentWidget)
+{
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'parentWidget' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;parentWidget());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::parentWidget(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  margin
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLayout, margin){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;margin());
-	}
+
+ZEND_METHOD(QLayout, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLayout::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLayout::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::trUtf8(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  expandingDirections
- *    flags:    c
- *    access:    public
- *    return:    Qt::Orientations
- *    params:    
+/*!
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLayout, expandingDirections){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			obj-&gt;expandingDirections();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLayout, maximumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'maximumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;maximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::maximumSize(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  spacing
- *    flags:    c
- *    access:    public
- *    return:    int
- *    params:    
+/*!
+ * method margin
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLayout, spacing){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;spacing());
-	}
+
+ZEND_METHOD(QLayout, margin)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'margin' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;margin());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::margin(...) &quot;);
 }
 
-/*********************************
- *    class     QLayout
- *    function  update
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    
+/*!
+ * method spacing
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLayout, update){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayout *obj = (QLayout*) PHP_QT_FETCH();
-			obj-&gt;update();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLayout, spacing)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'spacing' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayout *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayout * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;spacing());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::spacing(...) &quot;);
 }
 
+/*!
+ * method activateRecursiveHelper
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayoutItem *items0
+ * 
+ * @access	private
+ * @return	void
+ * @flags	s
+ */
 
-PHP_QT_DESTRUCT(QLayout);
+ZEND_METHOD(QLayout, activateRecursiveHelper)
+{
+  ///QLayoutItem *items0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayoutItem
+      if (inherits(Z_OBJCE_P(arg_0), 42)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QLayout::activateRecursiveHelper(...) cannot be called with 'QLayoutItem *items0,'.&quot;);
+      }
+#endif
 
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayout::activateRecursiveHelper(...) &quot;);
+}

Modified: trunk/qt/classes/qlayoutitem.cpp
===================================================================
--- trunk/qt/classes/qlayoutitem.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlayoutitem.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,59 +19,446 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLayoutItem.cpp - QLayoutItem PHP implementation.
- * begin           : Thu Feb 23 16:34:20 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
+
 #include &quot;../php_qt.h&quot;
 
 
 #include &lt;QLayoutItem&gt;
+/// DEBUG:destructor skipped.
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	cpv
+ */
 
-/*********************************
- *    class     QLayoutItem
- *    function  alignment
- *    flags:    c
- *    access:    public
- *    return:    Qt::Alignment
- *    params:    
+/*!
+ * method isEmpty
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	cpv
  */
-ZEND_METHOD(QLayoutItem, alignment){
-	if (ZEND_NUM_ARGS() == 0){
-			QLayoutItem *obj = (QLayoutItem*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;alignment());
-	}
+
+/*!
+ * method geometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	cpv
+ */
+
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect&amp;
+ * 
+ * @access	public
+ * @return	void
+ * @flags	pv
+ */
+
+/*!
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cpv
+ */
+
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cpv
+ */
+
+/*!
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cpv
+ */
+
+#include &lt;QRect&gt;
+#include &lt;QMetaMethod&gt;
+class QLayoutItem_php_qt:public QLayoutItem
+{
+
+public:
+  QLayoutItem_php_qt(zval * zend_ptr, Qt::Alignment alignment = 0);
+
+
+  zval *zend_ptr;
+  virtual Qt::Orientations expandingDirections() const; // pure 
+
+  virtual bool isEmpty() const; // pure 
+
+  virtual QRect geometry() const;       // pure 
+
+  virtual void setGeometry(const QRect &amp; s0);   // pure 
+
+  virtual QSize minimumSize() const;    // pure 
+
+  virtual QSize sizeHint() const;       // pure 
+
+  virtual QSize maximumSize() const;    // pure 
+};
+
+QLayoutItem_php_qt::QLayoutItem_php_qt(zval * zend_ptr, Qt::Alignment alignment):QLayoutItem(alignment)
+{
+  this-&gt;zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QLayoutItem
- *    function  setAlignment
- *    flags:    
- *    access:    public
- *    return:    void
- *    params:    Qt::Alignment a
+// virtual, pure 
+
+Qt::Orientations QLayoutItem_php_qt::expandingDirections() const
+{
+}
+
+// virtual, pure 
+
+bool
+QLayoutItem_php_qt::isEmpty() const
+{
+}
+
+// virtual, pure 
+
+QRect
+QLayoutItem_php_qt::geometry() const
+{
+}
+
+// virtual, pure 
+
+void
+QLayoutItem_php_qt::setGeometry(const QRect &amp; s0)
+{
+}
+
+// virtual, pure 
+
+QSize
+QLayoutItem_php_qt::minimumSize() const
+{
+}
+
+// virtual, pure 
+
+QSize
+QLayoutItem_php_qt::sizeHint() const
+{
+}
+
+// virtual, pure 
+
+QSize
+QLayoutItem_php_qt::maximumSize() const
+{
+}
+
+/*!
+ * method layout
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QLayout *
+ * @flags	v
  */
-ZEND_METHOD(QLayoutItem, setAlignment){
-		/* l public*/
 
-		/* int a,  */
+/*!
+ * method spacerItem
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSpacerItem *
+ * @flags	v
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLayoutItem *obj = (QLayoutItem*) PHP_QT_FETCH();
+/*!
+ * method QLayoutItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Alignment alignment = 0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
+ */
 
+ZEND_METHOD(QLayoutItem, __construct)
+{
+  ///Qt::Alignment alignment = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayoutItem_php_qt *selfpointer = new QLayoutItem_php_qt(getThis());
 
-			obj-&gt;setAlignment((Qt::Alignment) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::Alignment alignment = 0s0,
+      QLayoutItem_php_qt *selfpointer = new QLayoutItem_php_qt(getThis(), (Qt::Alignment) Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayoutItem::QLayoutItem(...) &quot;);
 }
 
+/*!
+ * method setAlignment
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Alignment as0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QLayoutItem);
+ZEND_METHOD(QLayoutItem, setAlignment)
+{
+  ///Qt::Alignment as0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setAlignment' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::Alignment as0,
+      QLayoutItem *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayoutItem * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setAlignment((Qt::Alignment) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayoutItem::setAlignment(...) &quot;);
+}
+
+/*!
+ * method heightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cv
+ */
+
+/*!
+ * method hasHeightForWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	cv
+ */
+
+/*!
+ * method minimumHeightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cv
+ */
+
+/*!
+ * method widget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	v
+ */
+
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	cpv
+ */
+
+/*!
+ * method isEmpty
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	cpv
+ */
+
+/*!
+ * method geometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	cpv
+ */
+
+/*!
+ * method invalidate
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;s0s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	pv
+ */
+
+/*!
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cpv
+ */
+
+/*!
+ * method alignment
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Alignment
+ * @flags	c
+ */
+
+ZEND_METHOD(QLayoutItem, alignment)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'alignment' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLayoutItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLayoutItem * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;alignment());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLayoutItem::alignment(...) &quot;);
+}
+
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cpv
+ */
+
+/*!
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cpv
+ */

Modified: trunk/qt/classes/qlcdnumber.cpp
===================================================================
--- trunk/qt/classes/qlcdnumber.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlcdnumber.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,545 +19,1089 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLCDNumber.cpp - QLCDNumber PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QLCDNumber&gt;
 #include &quot;../php_qt.h&quot;
 
 
+#include &lt;QLCDNumber&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QLCDNumber_php_qt:public QLCDNumber
+{
 
-/*		public enumMode:long {
-			Mode = 0,
-			Mode = 1,
-			Mode = 2,
-			Mode = 3
-		}
-*/
+public:
+  QLCDNumber_php_qt(zval * zend_ptr, QWidget * parent = 0);
+  QLCDNumber_php_qt(zval * zend_ptr, uint numDigitss0, QWidget * parent = 0);
 
-/*		public enumSegmentStyle:long {
-			SegmentStyle = 0,
-			SegmentStyle = 1,
-			SegmentStyle = 2
-		}
-*/
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  tr
- *    flags:    s
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+
+QLCDNumber_php_qt::QLCDNumber_php_qt(zval * zend_ptr, QWidget * parent):QLCDNumber(parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QLCDNumber&quot;,&amp;staticMetaObject));
+}
+
+QLCDNumber_php_qt::QLCDNumber_php_qt(zval * zend_ptr, uint numDigitss0, QWidget * parent):QLCDNumber(numDigitss0, parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QLCDNumber&quot;,&amp;staticMetaObject));
+}
+
+PHP_QT_MOC(QLCDNumber);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLCDNumber, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QLCDNumber, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLCDNumber *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-				QString return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLCDNumber_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLCDNumber::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLCDNumber::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  segmentStyle
- *    flags:    c
+/*!
+ * method mode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Mode
+ * @flags	c
  */
-ZEND_METHOD(QLCDNumber, segmentStyle){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-				QLCDNumber::SegmentStyle return_object = (QLCDNumber::SegmentStyle) obj-&gt;segmentStyle();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLCDNumber_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  mode
- *    flags:    c
- */
-ZEND_METHOD(QLCDNumber, mode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;mode());
-	}
+ZEND_METHOD(QLCDNumber, mode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type Mode&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::mode(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  checkOverflow
- *    flags:    c
+/*!
+ * method checkOverflow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	double nums0
+ * 
+ * overloaded args:
+ * @param	int num
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLCDNumber, checkOverflow){
-		/* l public*/
 
-		/* double num,  */
+ZEND_METHOD(QLCDNumber, checkOverflow)
+{
+  ///double nums0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'checkOverflow' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try double nums0,
+      QLCDNumber *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;checkOverflow((double)Z_DVAL_P(arg_0)));
+    }
+  }
+  ///int num
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'checkOverflow' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int num,
+      QLCDNumber *
+        selfpointer;
 
-
-			RETURN_BOOL(obj-&gt;checkOverflow((double) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;checkOverflow((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::checkOverflow(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  qt_invoke
- *    flags:    v
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLCDNumber, qt_invoke){
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method setSegmentStyle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	SegmentStyle SegmentStyles0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLCDNumber, staticMetaObject){
+
+ZEND_METHOD(QLCDNumber, setSegmentStyle)
+{
+// notice: unknown argument SegmentStyle SegmentStyles0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::setSegmentStyle(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setOctMode
- *    flags:    l
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QLCDNumber, setOctMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			obj-&gt;setOctMode();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  display
- *    flags:    l
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QLCDNumber, display){
-		/* l public_slots*/
 
-		/* int num,  */
-		/* o public_slots*/
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-		/* const QString&amp; str,  */
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+/*!
+ * method intValue
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QLCDNumber, intValue)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'intValue' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
 
-			obj-&gt;display((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;intValue());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::intValue(...) &quot;);
+}
 
+/*!
+ * method smallDecimalPoint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				obj-&gt;display((const QString&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QLCDNumber, smallDecimalPoint)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'smallDecimalPoint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;smallDecimalPoint());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::smallDecimalPoint(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setSegmentStyle
- *    flags:    
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QLCDNumber, setSegmentStyle){
-		/* o public*/
 
-		/* QLCDNumber::SegmentStyle ,  */
+ZEND_METHOD(QLCDNumber, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QLCDNumber *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj-&gt;setSegmentStyle((QLCDNumber::SegmentStyle) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QLCDNumber::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setHexMode
- *    flags:    l
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QLCDNumber, setHexMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			obj-&gt;setHexMode();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method overflow
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QLCDNumber, qObject){
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setSmallDecimalPoint
- *    flags:    l
+/*!
+ * method setNumDigits
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int nDigitss0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLCDNumber, setSmallDecimalPoint){
-		/* l public_slots*/
 
-		/* int ,  */
+ZEND_METHOD(QLCDNumber, setNumDigits)
+{
+  ///int nDigitss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNumDigits' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int nDigitss0,
+      QLCDNumber *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-
-
-			obj-&gt;setSmallDecimalPoint((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setNumDigits((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::setNumDigits(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLCDNumber, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj-&gt;sizeHint();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLCDNumber_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method setBinMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLCDNumber, qt_cast){
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  metaObject
- *    flags:    cv
- */
-ZEND_METHOD(QLCDNumber, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-				QMetaObject * return_object = (QMetaObject *) obj-&gt;metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLCDNumber_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
+ZEND_METHOD(QLCDNumber, setBinMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setBinMode' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  value
- *    flags:    c
- */
-ZEND_METHOD(QLCDNumber, value){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj-&gt;value());
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setBinMode());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::setBinMode(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setDecMode
- *    flags:    l
+/*!
+ * method segmentStyle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	SegmentStyle
+ * @flags	c
  */
-ZEND_METHOD(QLCDNumber, setDecMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			obj-&gt;setDecMode();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  qt_emit
- *    flags:    v
- */
-ZEND_METHOD(QLCDNumber, qt_emit){
+ZEND_METHOD(QLCDNumber, segmentStyle)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type SegmentStyle&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::segmentStyle(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method setOctMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLCDNumber, className){
-}
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  intValue
- *    flags:    c
- */
-ZEND_METHOD(QLCDNumber, intValue){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;intValue());
-	}
+ZEND_METHOD(QLCDNumber, setOctMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setOctMode' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setOctMode());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::setOctMode(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  QLCDNumber
- *    flags:    t
+/*!
+ * method display
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;strs0
+ * 
+ * overloaded args:
+ * @param	int num
+ * 
+ * overloaded args:
+ * @param	double num
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLCDNumber, __construct){
-		/* o public*/
 
-		/* qt_QWidget* parent,  */
+ZEND_METHOD(QLCDNumber, display)
+{
+  ///const QString &amp;strs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'display' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;strs0,
+        QLCDNumber *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				QLCDNumber *QLCDNumber_ptr = new QLCDNumber((QWidget*) obj_z_0);
-				PHP_QT_REGISTER(QLCDNumber_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* lo public*/
+        RETURN_VOID(selfpointer-&gt;display((const QString &amp;)*cpp_arg_0));
+      }
+#endif
 
-		/* unsigned int numDigits, qt_QWidget* parent,  */
+    }
+  }
+  ///int num
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'display' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int num,
+      QLCDNumber *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;display((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  ///double num
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'display' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try double num,
+      QLCDNumber *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;display((double)Z_DVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::display(...) &quot;);
+}
 
-			if(obj_z_1-&gt;inherits(&quot;QWidget&quot;)) {
-				QLCDNumber *QLCDNumber_ptr = new QLCDNumber((uint) Z_LVAL_P(z_0), (QWidget*) obj_z_1);
-				PHP_QT_REGISTER(QLCDNumber_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+/*!
+ * method value
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	double
+ * @flags	c
+ */
+
+ZEND_METHOD(QLCDNumber, value)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'value' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_DOUBLE(selfpointer-&gt;value());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::value(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setNumDigits
- *    flags:    
+/*!
+ * method QLCDNumber
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * parent = 0s0
+ * 
+ * overloaded args:
+ * @param	uint numDigitss0
+ * @param	 QWidget * parent = 0
+ * 
+ * overloaded args:
+ * @param	const QLCDNumber &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QLCDNumber, setNumDigits){
-		/* l public*/
 
-		/* int nDigits,  */
+ZEND_METHOD(QLCDNumber, __construct)
+{
+  ///QWidget * parent = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber_php_qt *
+        selfpointer = new QLCDNumber_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget * parent = 0s0,
+      QWidget *
+        cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QLCDNumber_php_qt *
+        selfpointer = new QLCDNumber_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///uint numDigitss0, QWidget * parent = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try uint numDigitss0,
+      QLCDNumber_php_qt *
+        selfpointer = new QLCDNumber_php_qt(getThis(), (uint) Z_LVAL_P(arg_0));
 
-			obj-&gt;setNumDigits((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try uint numDigitss0, QWidget * parent = 0,
+      QWidget *
+        cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+      QLCDNumber_php_qt *
+        selfpointer = new QLCDNumber_php_qt(getThis(), (uint) Z_LVAL_P(arg_0), (QWidget *) cpp_arg_1);
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QLCDNumber &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLCDNumber
+      if (inherits(Z_OBJCE_P(arg_0), 37)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QLCDNumber::__construct(...) cannot be called with 'const QLCDNumber &amp;,'.&quot;);
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::QLCDNumber(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  numDigits
- *    flags:    c
+/*!
+ * method numDigits
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLCDNumber, numDigits){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;numDigits());
-	}
+
+ZEND_METHOD(QLCDNumber, numDigits)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'numDigits' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;numDigits());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::numDigits(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setMode
- *    flags:    
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLCDNumber, setMode){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method setHexMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+ZEND_METHOD(QLCDNumber, setHexMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setHexMode' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setHexMode());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::setHexMode(...) &quot;);
+}
 
-			obj-&gt;setMode((QLCDNumber::Mode) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+/*!
+ * method setSmallDecimalPoint
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
+
+ZEND_METHOD(QLCDNumber, setSmallDecimalPoint)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setSmallDecimalPoint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setSmallDecimalPoint((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::setSmallDecimalPoint(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLCDNumber, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QLCDNumber, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-				QString return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLCDNumber_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::sizeHint(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method setDecMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLCDNumber, qt_property){
+
+ZEND_METHOD(QLCDNumber, setDecMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setDecMode' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setDecMode());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::setDecMode(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  smallDecimalPoint
- *    flags:    c
+/*!
+ * method setMode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Mode Modes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLCDNumber, smallDecimalPoint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;smallDecimalPoint());
-	}
+
+ZEND_METHOD(QLCDNumber, setMode)
+{
+// notice: unknown argument Mode Modes0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::setMode(...) &quot;);
 }
 
-/*********************************
- *    class     QLCDNumber */
-/*
- *    function  setBinMode
- *    flags:    l
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLCDNumber, setBinMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLCDNumber *obj = (QLCDNumber*) PHP_QT_FETCH();
-			obj-&gt;setBinMode();
-			RETURN_NULL();
-	}
-}
 
+ZEND_METHOD(QLCDNumber, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-PHP_QT_DESTRUCT(QLCDNumber);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLCDNumber *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLCDNumber::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLCDNumber *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLCDNumber * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLCDNumber::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLCDNumber::trUtf8(...) &quot;);
+}

Modified: trunk/qt/classes/qlineedit.cpp
===================================================================
--- trunk/qt/classes/qlineedit.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qlineedit.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QLineEdit.cpp - QLineEdit PHP implementation.
- * begin           : Thu Feb  9 23:08:03 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -28,1358 +27,2655 @@
 using namespace std;
 
 #include &quot;../php_qt.h&quot;
+
+
 #include &lt;QLineEdit&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QLineEdit_php_qt:public QLineEdit
+{
 
+public:
+  QLineEdit_php_qt(zval * zend_ptr, QWidget * parent = 0);
+  QLineEdit_php_qt(zval * zend_ptr, const QString &amp; s0, QWidget * parent = 0);
 
 
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
-/*		public enumEchoMode:long {
-			EchoMode = 0,
-			EchoMode = 1,
-			EchoMode = 2
-		}
-*/
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  tr
- *    flags:    s
+QLineEdit_php_qt::QLineEdit_php_qt(zval * zend_ptr, QWidget * parent):QLineEdit(parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QLineEdit&quot;,&amp;staticMetaObject));
+}
+QLineEdit_php_qt::QLineEdit_php_qt(zval * zend_ptr, const QString &amp; s0, QWidget * parent):
+QLineEdit(s0, parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QLineEdit&quot;,&amp;staticMetaObject));
+}
+
+PHP_QT_MOC(QLineEdit);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLineEdit, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QLineEdit, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QLineEdit::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLineEdit::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLineEdit::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  inputMask
- *    flags:    c
+/*!
+ * method inputMask
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, inputMask){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;inputMask();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, inputMask)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'inputMask' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;inputMask());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::inputMask(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  insert
- *    flags:    
+/*!
+ * method insert
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, insert){
-		/* o public*/
 
-		/* const QString&amp; ,  */
+ZEND_METHOD(QLineEdit, insert)
+{
+  ///const QString &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'insert' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QLineEdit *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QString&quot;)) {
-				obj-&gt;insert((const QString&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_VOID(selfpointer-&gt;insert((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::insert(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cursorPosition
- *    flags:    c
+/*!
+ * method cursorPosition
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, cursorPosition){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;cursorPosition());
-	}
+
+ZEND_METHOD(QLineEdit, cursorPosition)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'cursorPosition' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;cursorPosition());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::cursorPosition(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  clear
- *    flags:    l
+/*!
+ * method mouseMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, clear){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj-&gt;clear();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  selectionStart
- *    flags:    c
+/*!
+ * method clear
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, selectionStart){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;selectionStart());
-	}
+
+ZEND_METHOD(QLineEdit, clear)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'clear' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;clear());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::clear(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setMaxLength
- *    flags:    
+/*!
+ * method selectionStart
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, setMaxLength){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLineEdit, selectionStart)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'selectionStart' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;selectionStart());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::selectionStart(...) &quot;);
+}
 
+/*!
+ * method setMaxLength
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj-&gt;setMaxLength((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QLineEdit, setMaxLength)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMaxLength' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMaxLength((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::setMaxLength(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  qt_invoke
- *    flags:    v
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QLineEdit, qt_invoke){
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setModified
- *    flags:    
+/*!
+ * method setModified
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, setModified){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLineEdit, setModified)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setModified' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setModified((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::setModified(...) &quot;);
+}
 
+/*!
+ * method setFrame
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj-&gt;setModified((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QLineEdit, setFrame)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setFrame' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setFrame((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::setFrame(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setFrame
- *    flags:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QLineEdit, setFrame){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method setReadOnly
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+ZEND_METHOD(QLineEdit, setReadOnly)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setReadOnly' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QLineEdit *selfpointer;
 
-
-			obj-&gt;setFrame((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setReadOnly((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::setReadOnly(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method setEchoMode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	EchoMode EchoModes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, qt_cast){
+
+ZEND_METHOD(QLineEdit, setEchoMode)
+{
+// notice: unknown argument EchoMode EchoModes0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::setEchoMode(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setReadOnly
- *    flags:    
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QLineEdit, setReadOnly){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method cursorBackward
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool marks0
+ * @param	 int steps = 1s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_BOOL){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+ZEND_METHOD(QLineEdit, cursorBackward)
+{
+  ///bool marks0, int steps = 1s1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'cursorBackward' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool marks0,
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;cursorBackward((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'cursorBackward' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool marks0, int steps = 1s1,
+      QLineEdit *selfpointer;
 
-			obj-&gt;setReadOnly((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;cursorBackward((bool) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::cursorBackward(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setEchoMode
- *    flags:    
+/*!
+ * method cursorWordBackward
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool marks0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, setEchoMode){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLineEdit, cursorWordBackward)
+{
+  ///bool marks0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'cursorWordBackward' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool marks0,
+      QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;cursorWordBackward((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::cursorWordBackward(...) &quot;);
+}
 
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-			obj-&gt;setEchoMode((QLineEdit::EchoMode) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+/*!
+ * method setAlignment
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::Alignment flags0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLineEdit, setAlignment)
+{
+  ///Qt::Alignment flags0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setAlignment' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::Alignment flags0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setAlignment((Qt::Alignment) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::setAlignment(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  metaObject
- *    flags:    cv
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QLineEdit, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QMetaObject ** return_object = new QMetaObject *;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QMetaObject *) obj-&gt;metaObject();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cursorBackward
- *    flags:    
+/*!
+ * method dragLeaveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDragLeaveEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, cursorBackward){
-		/* ll public*/
 
-		/* int mark, int steps,  */
+/*!
+ * method QLineEdit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * parent=0s0
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * @param	 QWidget * parent=0
+ * 
+ * overloaded args:
+ * @param	const QLineEdit &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+ZEND_METHOD(QLineEdit, __construct)
+{
+  ///QWidget * parent=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit_php_qt *selfpointer = new QLineEdit_php_qt(getThis());
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget * parent=0s0,
+      QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QLineEdit_php_qt *selfpointer = new QLineEdit_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-			obj-&gt;cursorBackward((bool) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QString &amp;s0, QWidget * parent=0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cursorWordBackward
- *    flags:    
- */
-ZEND_METHOD(QLineEdit, cursorWordBackward){
-		/* l public*/
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QLineEdit_php_qt *selfpointer = new QLineEdit_php_qt(getThis(), (const QString &amp;)*cpp_arg_0);
 
-		/* int mark,  */
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0, QWidget * parent=0,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QWidget *cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+        QLineEdit_php_qt *selfpointer = new QLineEdit_php_qt(getThis(), (const QString &amp;)*cpp_arg_0, (QWidget *) cpp_arg_1);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-			obj-&gt;cursorWordBackward((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+    }
+  }
+  ///const QLineEdit &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLineEdit
+      if (inherits(Z_OBJCE_P(arg_0), 43)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QLineEdit::__construct(...) cannot be called with 'const QLineEdit &amp;,'.&quot;);
+      }
+#endif
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  qt_emit
- *    flags:    v
- */
-ZEND_METHOD(QLineEdit, qt_emit){
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::QLineEdit(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setAlignment
- *    flags:    
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QLineEdit, setAlignment){
-		/* l public*/
 
-		/* int flag,  */
+ZEND_METHOD(QLineEdit, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setAlignment((Qt::Alignment) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QLineEdit::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method mouseReleaseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, className){
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  QLineEdit
- *    flags:    t
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, __construct){
-		/* o public*/
 
-		/* qt_QWidget* parent,  */
+/*!
+ * method inputMethodQuery
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::InputMethodQuery Qt::InputMethodQuerys0
+ * 
+ * @access	public
+ * @return	QVariant
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			    QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QLineEdit, inputMethodQuery)
+{
+  ///Qt::InputMethodQuery Qt::InputMethodQuerys0
+#ifdef PHP_QT_QVariant          // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'inputMethodQuery' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::InputMethodQuery Qt::InputMethodQuerys0,
+      QLineEdit *selfpointer;
 
-			    if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				    QLineEdit *QLineEdit_ptr = new QLineEdit((QWidget*) obj_z_0);
-				    PHP_QT_REGISTER(QLineEdit_ptr);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				    RETURN_NULL();
-			    }
-			} else if(Z_TYPE_P(z_0) == IS_STRING){
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QVariant *return_object = new QVariant;
 
-			    QString *str = new QString(&quot;&quot;);
-			    *str = QString(QString::fromUtf8(Z_STRVAL_P(z_0)));
+      *return_object = static_cast &lt; QVariant &gt; (selfpointer-&gt;inputMethodQuery((Qt::InputMethodQuery) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			    zend_class_entry *ce;                                   
-			    object_init_ex(z_0, QString_ce_ptr);
-			    zend_rsrc_list_entry le_;                            
-			    le_.ptr = str;
-			    php_qt_register(z_0,le_);                                 
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::inputMethodQuery(...) &quot;);
+}
 
-			    QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method text
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-				QLineEdit *QLineEdit_ptr = new QLineEdit((const QString&amp;) *obj_z_0);
-				PHP_QT_REGISTER(QLineEdit_ptr);
-				RETURN_NULL();
+ZEND_METHOD(QLineEdit, text)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-			}
-            
-		}
-	}
-		/* oo public*/
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'text' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-		/* const QString&amp; , qt_QWidget* parent,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;text());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			if(Z_TYPE_P(z_0) == IS_STRING){
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::text(...) &quot;);
+}
 
-			  QString *str = new QString(&quot;&quot;);
-			  *str = QString(QString::fromUtf8(Z_STRVAL_P(z_0)));
+/*!
+ * method minimumSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
+ */
 
-			  zend_class_entry *ce;                                   
-			  object_init_ex(z_0, QString_ce_ptr);
-			  zend_rsrc_list_entry le;                            
-			  le.ptr = str;
-			  php_qt_register(z_0,le);                                 
+ZEND_METHOD(QLineEdit, minimumSizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-			}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumSizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
 
-//			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QString&quot;) &amp;&amp; obj_z_1-&gt;inherits(&quot;QWidget&quot;)) {
-				QLineEdit *QLineEdit_ptr = new QLineEdit((const QString&amp;) *obj_z_0, (QWidget*) obj_z_1);
-				PHP_QT_REGISTER(QLineEdit_ptr);
-				RETURN_NULL();
-//			}
-			}
-		}
-	}
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;minimumSizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::minimumSizeHint(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method home
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool marks0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, staticMetaObject){
+
+ZEND_METHOD(QLineEdit, home)
+{
+  ///bool marks0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'home' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool marks0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;home((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::home(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method returnPressed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QLineEdit, qObject){
+
+/*!
+ * method del
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QLineEdit, del)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'del' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;del());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::del(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  inputMethodQuery
- *    flags:    c
+/*!
+ * method dropEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDropEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, inputMethodQuery){
-		/* l public*/
 
-		/* int ,  */
+/*!
+ * method cursorForward
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool marks0
+ * @param	 int steps = 1s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+ZEND_METHOD(QLineEdit, cursorForward)
+{
+  ///bool marks0, int steps = 1s1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'cursorForward' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool marks0,
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;cursorForward((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'cursorForward' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool marks0, int steps = 1s1,
+      QLineEdit *selfpointer;
 
-			QVariant* return_object = new QVariant;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QVariant) obj-&gt;inputMethodQuery((Qt::InputMethodQuery) Z_LVAL_P(z_0));
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;cursorForward((bool) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::cursorForward(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  text
- *    flags:    c
+/*!
+ * method setDragEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, text){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;text();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, setDragEnabled)
+{
+  ///bool bs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setDragEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bs0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setDragEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::setDragEnabled(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  minimumSizeHint
- *    flags:    c
+/*!
+ * method contextMenuEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QContextMenuEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, minimumSizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QSize* return_object = new QSize;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;minimumSizeHint();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  home
- *    flags:    
+/*!
+ * method cursorPositionChanged
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * @param	 int  ints1
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QLineEdit, home){
-		/* l public*/
 
-		/* int mark,  */
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+/*!
+ * method echoMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	EchoMode
+ * @flags	c
+ */
 
-
-			obj-&gt;home((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QLineEdit, echoMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type EchoMode&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::echoMode(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  del
- *    flags:    
+/*!
+ * method inputMethodEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QInputMethodEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, del){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj-&gt;del();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cursorForward
- *    flags:    
+/*!
+ * method setValidator
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QValidator *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, cursorForward){
-		/* ll public*/
 
-		/* int mark, int steps,  */
+ZEND_METHOD(QLineEdit, setValidator)
+{
+  ///const QValidator *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QValidator
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setValidator' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QValidator *s0,
+        QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+        }
+        QValidator *cpp_arg_0 = static_cast &lt; QValidator * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setValidator((const QValidator *)cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;cursorForward((bool) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::setValidator(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setDragEnabled
- *    flags:    
+/*!
+ * method hasSelectedText
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, setDragEnabled){
-		/* l public*/
 
-		/* int b,  */
+ZEND_METHOD(QLineEdit, hasSelectedText)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hasSelectedText' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-
-
-			obj-&gt;setDragEnabled((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;hasSelectedText());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::hasSelectedText(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method textChanged
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QLineEdit, qt_property){
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  echoMode
- *    flags:    c
+/*!
+ * method paste
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, echoMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;echoMode());
-	}
+
+ZEND_METHOD(QLineEdit, paste)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'paste' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;paste());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::paste(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setValidator
- *    flags:    
+/*!
+ * method hasAcceptableInput
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, setValidator){
-		/* o public*/
 
-		/* const QValidator* ,  */
+ZEND_METHOD(QLineEdit, hasAcceptableInput)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hasAcceptableInput' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;hasAcceptableInput());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::hasAcceptableInput(...) &quot;);
+}
 
+/*!
+ * method copy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	cl
+ */
 
-			if(obj_z_0-&gt;inherits(&quot;QValidator&quot;)) {
-				obj-&gt;setValidator((const QValidator*) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QLineEdit, copy)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'copy' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;copy());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::copy(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  hasSelectedText
- *    flags:    c
+/*!
+ * method redo
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, hasSelectedText){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;hasSelectedText());
-	}
+
+ZEND_METHOD(QLineEdit, redo)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'redo' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;redo());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::redo(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  hasAcceptableInput
- *    flags:    c
+/*!
+ * method dragEnterEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDragEnterEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, hasAcceptableInput){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;hasAcceptableInput());
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  paste
- *    flags:    l
+/*!
+ * method undo
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, paste){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj-&gt;paste();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLineEdit, undo)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'undo' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;undo());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::undo(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  redo
- *    flags:    l
+/*!
+ * method cursorWordForward
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool marks0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, redo){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj-&gt;redo();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLineEdit, cursorWordForward)
+{
+  ///bool marks0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'cursorWordForward' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool marks0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;cursorWordForward((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::cursorWordForward(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  copy
- *    flags:    cl
+/*!
+ * method displayText
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, copy){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj-&gt;copy();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLineEdit, displayText)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'displayText' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;displayText());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::displayText(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  undo
- *    flags:    l
+/*!
+ * method focusOutEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, undo){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj-&gt;undo();
-			RETURN_NULL();
-	}
+
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
+
+ZEND_METHOD(QLineEdit, event)
+{
+  ///QEvent *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 21)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'event' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QEvent *s0,
+        QLineEdit *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+        }
+        QEvent *cpp_arg_0 = static_cast &lt; QEvent * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;event((QEvent *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::event(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  displayText
- *    flags:    c
+/*!
+ * method end
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool marks0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, displayText){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;displayText();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, end)
+{
+  ///bool marks0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'end' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool marks0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;end((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::end(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cursorWordForward
- *    flags:    
+/*!
+ * method validator
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QValidator *
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, cursorWordForward){
-		/* l public*/
 
-		/* int mark,  */
+ZEND_METHOD(QLineEdit, validator)
+{
+  ///
+#ifdef PHP_QT_QValidator        // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'validator' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;cursorWordForward((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast &lt; QValidator * &gt;(selfpointer-&gt;validator());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::validator(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  event
- *    flags:    
+/*!
+ * method isRedoAvailable
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, event){
-		/* o public*/
 
-		/* qt_QEvent* ,  */
+ZEND_METHOD(QLineEdit, isRedoAvailable)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isRedoAvailable' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isRedoAvailable());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::isRedoAvailable(...) &quot;);
+}
 
+/*!
+ * method deselect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QEvent&quot;)) {
-				RETURN_BOOL(obj-&gt;event((QEvent*) obj_z_0));
-			}
-			}
-		}
-	}
+ZEND_METHOD(QLineEdit, deselect)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'deselect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;deselect());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::deselect(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  validator
- *    flags:    c
+/*!
+ * method cursorPositionAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;poss0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, validator){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			const QValidator ** return_object = new const QValidator *;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (const QValidator *) obj-&gt;validator();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, cursorPositionAt)
+{
+  ///const QPoint &amp;poss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'cursorPositionAt' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;poss0,
+        QLineEdit *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;cursorPositionAt((const QPoint &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::cursorPositionAt(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  end
- *    flags:    
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, end){
-		/* l public*/
 
-		/* int mark,  */
+/*!
+ * method selectedText
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+ZEND_METHOD(QLineEdit, selectedText)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'selectedText' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-			obj-&gt;end((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;selectedText());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::selectedText(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  isRedoAvailable
- *    flags:    c
+/*!
+ * method setSelection
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * @param	 int  ints1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, isRedoAvailable){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isRedoAvailable());
-	}
+
+ZEND_METHOD(QLineEdit, setSelection)
+{
+  ///int ints0, int  ints1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setSelection' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0, int  ints1,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setSelection((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::setSelection(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cursorPositionAt
- *    flags:    
+/*!
+ * method mouseDoubleClickEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, cursorPositionAt){
-		/* l public*/
 
-		/* const QPoint&amp; pos,  */
+/*!
+ * method selectionChanged
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+/*!
+ * method isUndoAvailable
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
+ZEND_METHOD(QLineEdit, isUndoAvailable)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isUndoAvailable' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
-			RETURN_LONG(obj-&gt;cursorPositionAt((const QPoint&amp;) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isUndoAvailable());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::isUndoAvailable(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  deselect
- *    flags:    
+/*!
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, deselect){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj-&gt;deselect();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setSelection
- *    flags:    
+/*!
+ * method setInputMask
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;inputMasks0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, setSelection){
-		/* ll public*/
 
-		/* int , int ,  */
+ZEND_METHOD(QLineEdit, setInputMask)
+{
+  ///const QString &amp;inputMasks0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setInputMask' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;inputMasks0,
+        QLineEdit *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			obj-&gt;setSelection((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+        RETURN_VOID(selfpointer-&gt;setInputMask((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::setInputMask(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  selectedText
- *    flags:    c
+/*!
+ * method hasFrame
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, selectedText){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;selectedText();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, hasFrame)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hasFrame' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;hasFrame());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::hasFrame(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  isUndoAvailable
- *    flags:    c
+/*!
+ * method mousePressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, isUndoAvailable){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isUndoAvailable());
-	}
+
+/*!
+ * method dragEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+ZEND_METHOD(QLineEdit, dragEnabled)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'dragEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;dragEnabled());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::dragEnabled(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  hasFrame
- *    flags:    c
+/*!
+ * method cut
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, hasFrame){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;hasFrame());
-	}
+
+ZEND_METHOD(QLineEdit, cut)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'cut' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;cut());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::cut(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setInputMask
- *    flags:    
+/*!
+ * method setText
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, setInputMask){
-		/* o public*/
 
-		/* const QString&amp; inputMask,  */
+ZEND_METHOD(QLineEdit, setText)
+{
+  ///const QString &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QLineEdit *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QString&quot;)) {
-				obj-&gt;setInputMask((const QString&amp;) *obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_VOID(selfpointer-&gt;setText((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::setText(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  dragEnabled
- *    flags:    c
+/*!
+ * method alignment
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Alignment
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, dragEnabled){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;dragEnabled());
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  cut
- *    flags:    l
- */
-ZEND_METHOD(QLineEdit, cut){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj-&gt;cut();
-			RETURN_NULL();
-	}
+ZEND_METHOD(QLineEdit, alignment)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'alignment' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;alignment());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::alignment(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setText
- *    flags:    l
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, setText){
-		/* o public_slots*/
 
-		/* const QString&amp; ,  */
+ZEND_METHOD(QLineEdit, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QString&quot;)) {
-				obj-&gt;setText((const QString&amp;) *obj_z_0);
-			    RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_STRING){
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
 
-			    QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-				obj-&gt;setText(Z_STRVAL_P(z_0));
-			    RETURN_NULL();
-			}
-			
-
-		}
-
-	}
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::sizeHint(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  alignment
- *    flags:    c
+/*!
+ * method dragMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDragMoveEvent *es0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, alignment){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;alignment());
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method setCursorPosition
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QSize* return_object = new QSize;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;sizeHint();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, setCursorPosition)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setCursorPosition' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setCursorPosition((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::setCursorPosition(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  setCursorPosition
- *    flags:    
+/*!
+ * method createStandardContextMenu
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMenu *
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, setCursorPosition){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QLineEdit, createStandardContextMenu)
+{
+  ///
+#ifdef PHP_QT_QMenu             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'createStandardContextMenu' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setCursorPosition((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QMenu * &gt;(selfpointer-&gt;createStandardContextMenu());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::createStandardContextMenu(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  createStandardContextMenu
- *    flags:    
+/*!
+ * method backspace
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, createStandardContextMenu){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			QMenu ** return_object = new QMenu *;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QMenu *) obj-&gt;createStandardContextMenu();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QLineEdit, backspace)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'backspace' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;backspace());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::backspace(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  backspace
- *    flags:    
+/*!
+ * method keyPressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, backspace){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj-&gt;backspace();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  selectAll
- *    flags:    l
+/*!
+ * method selectAll
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QLineEdit, selectAll){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			obj-&gt;selectAll();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QLineEdit, selectAll)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'selectAll' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;selectAll());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::selectAll(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  maxLength
- *    flags:    c
+/*!
+ * method focusInEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QLineEdit, maxLength){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;maxLength());
-	}
-}
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  isModified
- *    flags:    c
+/*!
+ * method editingFinished
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QLineEdit, isModified){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isModified());
-	}
+
+/*!
+ * method textEdited
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
+
+/*!
+ * method maxLength
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QLineEdit, maxLength)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'maxLength' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;maxLength());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::maxLength(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QLineEdit, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QLineEdit, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QLineEdit::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QLineEdit_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLineEdit::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QLineEdit::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::trUtf8(...) &quot;);
 }
 
-/*********************************
- *    class     QLineEdit */
-/*
- *    function  isReadOnly
- *    flags:    c
+/*!
+ * method isModified
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QLineEdit, isReadOnly){
-	if (ZEND_NUM_ARGS() == 0){
-			QLineEdit *obj = (QLineEdit*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isReadOnly());
-	}
+
+ZEND_METHOD(QLineEdit, isModified)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isModified' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isModified());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::isModified(...) &quot;);
 }
 
+/*!
+ * method isReadOnly
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QLineEdit);
+ZEND_METHOD(QLineEdit, isReadOnly)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isReadOnly' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QLineEdit *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QLineEdit * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isReadOnly());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QLineEdit::isReadOnly(...) &quot;);
+}

Modified: trunk/qt/classes/qmouseevent.cpp
===================================================================
--- trunk/qt/classes/qmouseevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qmouseevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,145 +19,359 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QMouseEvent.cpp - QMouseEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QMouseEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  x
- *    flags:    c
+#include &lt;QMouseEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QMouseEvent_php_qt:public QMouseEvent
+{
+
+public:
+  QMouseEvent_php_qt(zval * zend_ptr, Type types0, const QPoint &amp; poss1, Qt::MouseButton buttons2, Qt::MouseButtons buttonss3,
+                     Qt::KeyboardModifiers modifierss4);
+    QMouseEvent_php_qt(zval * zend_ptr, Type types0, const QPoint &amp; poss1, const QPoint &amp; globalPoss2, Qt::MouseButton buttons3, Qt::MouseButtons buttonss4,
+                       Qt::KeyboardModifiers modifierss5);
+
+
+  zval *zend_ptr;
+};
+QMouseEvent_php_qt::QMouseEvent_php_qt(zval * zend_ptr, Type types0, const QPoint &amp; poss1, Qt::MouseButton buttons2, Qt::MouseButtons buttonss3,
+                                       Qt::KeyboardModifiers modifierss4):
+QMouseEvent(types0, poss1, buttons2, buttonss3, modifierss4)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QMouseEvent_php_qt::QMouseEvent_php_qt(zval * zend_ptr, Type types0, const QPoint &amp; poss1, const QPoint &amp; globalPoss2, Qt::MouseButton buttons3,
+                                       Qt::MouseButtons buttonss4, Qt::KeyboardModifiers modifierss5):
+QMouseEvent(types0, poss1, globalPoss2, buttons3, buttonss4, modifierss5)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method y
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, x){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;x());
-	}
+
+ZEND_METHOD(QMouseEvent, y)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'y' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QMouseEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;y());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QMouseEvent::y(...) &quot;);
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  globalX
- *    flags:    c
+/*!
+ * method QMouseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type types0s0
+ * @param	const QPoint &amp;poss1s1
+ * @param	Qt::MouseButton buttons2s2
+ * @param	Qt::MouseButtons buttonss3s3
+ * @param	Qt::KeyboardModifiers modifierss4s4
+ * 
+ * overloaded args:
+ * @param	Type types0
+ * @param	const QPoint &amp;poss1
+ * @param	const QPoint &amp;globalPoss2
+ * @param	Qt::MouseButton buttons3
+ * @param	Qt::MouseButtons buttonss4
+ * @param	Qt::KeyboardModifiers modifierss5
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QMouseEvent, globalX){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;globalX());
-	}
+
+ZEND_METHOD(QMouseEvent, __construct)
+{
+// notice: unknown argument Type types0s0, skipped
+
+// notice: unknown argument Type types0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QMouseEvent::QMouseEvent(...) &quot;);
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  globalPos
- *    flags:    c
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &amp;
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, globalPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-				const QPoint &amp; return_object = (const QPoint &amp;) obj-&gt;globalPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QMouseEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QMouseEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QMouseEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QMouseEvent::pos(...) &quot;);
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  y
- *    flags:    c
+/*!
+ * method globalX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, y){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;y());
-	}
+
+ZEND_METHOD(QMouseEvent, globalX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalX' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QMouseEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;globalX());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QMouseEvent::globalX(...) &quot;);
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  globalY
- *    flags:    c
+/*!
+ * method globalPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &amp;
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, globalY){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;globalY());
-	}
+
+ZEND_METHOD(QMouseEvent, globalPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalPos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QMouseEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;globalPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QMouseEvent::globalPos(...) &quot;);
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method buttons
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::MouseButtons
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-				const QPoint &amp; return_object = (const QPoint &amp;) obj-&gt;pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QMouseEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QMouseEvent, buttons)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'buttons' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QMouseEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;buttons());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QMouseEvent::buttons(...) &quot;);
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  button
- *    flags:    c
+/*!
+ * method x
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, button){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-				Qt::MouseButton return_object = (Qt::MouseButton) obj-&gt;button();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QMouseEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QMouseEvent, x)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'x' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QMouseEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;x());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QMouseEvent::x(...) &quot;);
 }
 
-/*********************************
- *    class     QMouseEvent */
-/*
- *    function  buttons
- *    flags:    c
+/*!
+ * method globalY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QMouseEvent, buttons){
-	if (ZEND_NUM_ARGS() == 0){
-			QMouseEvent *obj = (QMouseEvent*) PHP_QT_FETCH();
-				Qt::MouseButtons return_object = (Qt::MouseButtons) obj-&gt;buttons();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QMouseEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QMouseEvent, globalY)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalY' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QMouseEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;globalY());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QMouseEvent::globalY(...) &quot;);
 }
 
+/*!
+ * method button
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::MouseButton
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QMouseEvent);
+ZEND_METHOD(QMouseEvent, button)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'button' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QMouseEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QMouseEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;button());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QMouseEvent::button(...) &quot;);
+}

Modified: trunk/qt/classes/qmoveevent.cpp
===================================================================
--- trunk/qt/classes/qmoveevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qmoveevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,55 +19,162 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QMoveEvent.cpp - QMoveEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QMoveEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QMoveEvent */
-/*
- *    function  oldPos
- *    flags:    c
+#include &lt;QMoveEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QMoveEvent_php_qt:public QMoveEvent
+{
+
+public:
+  QMoveEvent_php_qt(zval * zend_ptr, const QPoint &amp; poss0, const QPoint &amp; oldPoss1);
+
+
+  zval *zend_ptr;
+};
+QMoveEvent_php_qt::QMoveEvent_php_qt(zval * zend_ptr, const QPoint &amp; poss0, const QPoint &amp; oldPoss1):
+QMoveEvent(poss0, oldPoss1)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &amp;
+ * @flags	c
  */
-ZEND_METHOD(QMoveEvent, oldPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QMoveEvent *obj = (QMoveEvent*) PHP_QT_FETCH();
-				const QPoint &amp; return_object = (const QPoint &amp;) obj-&gt;oldPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QMoveEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QMoveEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QMoveEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QMoveEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QMoveEvent::pos(...) &quot;);
 }
 
-/*********************************
- *    class     QMoveEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method QMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;poss0s0
+ * @param	const QPoint &amp;oldPoss1s1
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QMoveEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QMoveEvent *obj = (QMoveEvent*) PHP_QT_FETCH();
-				const QPoint &amp; return_object = (const QPoint &amp;) obj-&gt;pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QMoveEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QMoveEvent, __construct)
+{
+  ///const QPoint &amp;poss0s0,const QPoint &amp;oldPoss1s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;poss0s0,const QPoint &amp;oldPoss1s1,
+        QPoint *cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QPoint *cpp_arg_1 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_1));
+        QMoveEvent_php_qt *selfpointer = new QMoveEvent_php_qt(getThis(), (const QPoint &amp;)*cpp_arg_0, (const QPoint &amp;)*cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QMoveEvent::QMoveEvent(...) &quot;);
 }
 
+/*!
+ * method oldPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &amp;
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QMoveEvent);
+ZEND_METHOD(QMoveEvent, oldPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'oldPos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QMoveEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QMoveEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;oldPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QMoveEvent::oldPos(...) &quot;);
+}

Modified: trunk/qt/classes/qobject.cpp
===================================================================
--- trunk/qt/classes/qobject.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qobject.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,1110 +19,2080 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QObject.cpp - QObject PHP implementation.
- * begin           : Wed Jan 11 20:29:53 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QObject&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QObject */
-/*
- *    function  removeEventFilter
- *    flags:    
- */
-ZEND_METHOD(QObject, removeEventFilter){
+#include &lt;QObject&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QObject_php_qt:public QObject
+{
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+public:
+  QObject_php_qt(zval * zend_ptr, QObject * parent = 0);
 
-		/* QObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;o&quot;, &amp;z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
 
-			QString tmp_o_0(var_o_0-&gt;metaObject()-&gt;className());
-			
-			if(tmp_o_0 == &quot;QObject*&quot;) {
-				obj-&gt;removeEventFilter((QObject*) var_o_0);
-			RETURN_NULL();
-			}
-		}
-	}
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+
+QObject_php_qt::QObject_php_qt(zval * zend_ptr, QObject * parent):QObject(parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QObject&quot;,&amp;staticMetaObject));
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  connectNotify
- *    flags:    v
+PHP_QT_MOC(QObject);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * overloaded args:
+ * @param	const char *
+ * @param	 const char *
+ * 
+ * overloaded args:
+ * @param	const char *sourceText
+ * @param	 const char * = 0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QObject, connectNotify){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+ZEND_METHOD(QObject, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QObject *
+        selfpointer;
 
-		/* const char* signal,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s&quot;, &amp;var_s_0, len_s_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			
-			obj-&gt;connectNotify( (const char*) var_s_0);
-			RETURN_NULL();
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-/*********************************
- *    class     QObject */
-/*
- *    function  tr
- *    flags:    s
- */
-ZEND_METHOD(QObject, tr){
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QObject::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QObject *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* ss */
-		char* var_ss_0;   // default: 
-		int len_ss_0;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-		char* var_ss_1;   // default: 0
-		int len_ss_1;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QObject::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-		/* const char* , const char* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;ss|&quot;, &amp;var_ss_0, len_ss_0, &amp;var_ss_1, len_ss_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
 
-									
-			QString return_object = (QString) obj-&gt;tr( (const char*) var_ss_0 , (const char*) var_ss_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-		}
-	}
-}
+  ///const char *, const char *
+#ifdef PHP_QT_QString           // return type
 
-/*********************************
- *    class     QObject */
-/*
- *    function  disconnect
- *    flags:    
- */
-ZEND_METHOD(QObject, disconnect){
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try const char *, const char *,
+      QObject *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* os */
-		zval* z_var_os_0;   // default: 
-		char* var_os_1;   // default: 0
-		int len_os_1;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-		/* const QObject* receiver, const char* member,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;os|&quot;, &amp;z_var_os_0, &amp;var_os_1, len_os_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_os_0 = (QObject*) php_qt_fetch(z_var_os_0);
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QObject::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			QString tmp_os_0(var_os_0-&gt;metaObject()-&gt;className());
-			
-			if(tmp_os_0 == &quot;const QObject*&quot;) {
-				RETURN_BOOL(obj-&gt;disconnect((const QObject*) var_os_0, (const char*) var_os_1));
-			}
-		}
-	}
 
-	if (ZEND_NUM_ARGS() == 3){
-		/* sos */
-		char* var_sos_0;   // default: 0
-		int len_sos_0;
+  ///const char *sourceText, const char * = 0
+#ifdef PHP_QT_QString           // return type
 
-		zval* z_var_sos_1;   // default: 0
-		char* var_sos_2;   // default: 0
-		int len_sos_2;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *sourceText,
+      QObject *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-		/* const char* signal, const QObject* receiver, const char* member,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s|o|s|&quot;, &amp;var_sos_0, len_sos_0, &amp;z_var_sos_1, &amp;var_sos_2, len_sos_2) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_sos_1 = (QObject*) php_qt_fetch(z_var_sos_1);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-			QString tmp_sos_0(var_sos_1-&gt;metaObject()-&gt;className());
-			
-			if(tmp_sos_0 == &quot;const QObject*&quot;) {
-				RETURN_BOOL(obj-&gt;disconnect((const char*) var_sos_0, (const QObject*) var_sos_1, (const char*) var_sos_2));
-			}
-		}
-	}
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QObject::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try const char *sourceText, const char * = 0,
+      QObject *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 4){
-		/* osos */
-		zval* z_var_osos_0;   // default: 
-		char* var_osos_1;   // default: 
-		int len_osos_1;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-		zval* z_var_osos_2;   // default: 
-		char* var_osos_3;   // default: 
-		int len_osos_3;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QObject::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-		/* const QObject* sender, const char* signal, const QObject* receiver, const char* member,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;osos&quot;, &amp;z_var_osos_0, &amp;var_osos_1, len_osos_1, &amp;z_var_osos_2, &amp;var_osos_3, len_osos_3) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_osos_0 = (QObject*) php_qt_fetch(z_var_osos_0);
-			QObject* var_osos_2 = (QObject*) php_qt_fetch(z_var_osos_2);
-
-			QString tmp_osos_0(var_osos_0-&gt;metaObject()-&gt;className());
-			QString tmp_osos_1(var_osos_2-&gt;metaObject()-&gt;className());
-			
-			if(tmp_osos_0 == &quot;const QObject*&quot; &amp;&amp; tmp_osos_1 == &quot;const QObject*&quot;) {
-				RETURN_BOOL(obj-&gt;disconnect((const QObject*) var_osos_0, (const char*) var_osos_1, (const QObject*) var_osos_2, (const char*) var_osos_3));
-			}
-		}
-	}
+  php_error(E_ERROR, &quot;could not parse argument in QObject::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  children
- *    flags:    c
+/*!
+ * method children
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QObjectList &amp;
+ * @flags	c
  */
-ZEND_METHOD(QObject, children){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			const QObjectList &amp; return_object = (const QObjectList &amp;) obj-&gt;children();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QObject, children)
+{
+  ///
+#ifdef PHP_QT_QObjectList       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'children' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &amp;const_cast &lt; QObjectList &amp; &gt;(selfpointer-&gt;children());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QObject::children(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  qt_invoke
- *    flags:    v
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QObject, qt_invoke){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* lo */
-		long var_lo_0;    // default: 
-		zval* z_var_lo_1;   // default: 
+/*!
+ * method installEventFilter
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-		/* int , QUObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;lo&quot;, &amp;var_lo_0, &amp;z_var_lo_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_lo_1 = (QObject*) php_qt_fetch(z_var_lo_1);
+ZEND_METHOD(QObject, installEventFilter)
+{
+  ///QObject *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'installEventFilter' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QObject *s0,
+        QObject *
+          selfpointer;
 
-			QString tmp_lo_0(var_lo_1-&gt;metaObject()-&gt;className());
-			
-			if(tmp_lo_0 == &quot;QUObject*&quot;) {
-				RETURN_BOOL(obj-&gt;qt_invoke((int) var_lo_0, (QUObject*) var_lo_1));
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;installEventFilter((QObject *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::installEventFilter(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  deleteLater
- *    flags:    l
+/*!
+ * method destroyed
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject * = 0s0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QObject, deleteLater){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			obj-&gt;deleteLater();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  installEventFilter
- *    flags:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QObject, installEventFilter){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+/*!
+ * method setProperty
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *names0
+ * @param	 const QVariant  &amp;values1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
 
-		/* QObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;o&quot;, &amp;z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+ZEND_METHOD(QObject, setProperty)
+{
+  ///const char *names0, const QVariant  &amp;values1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QVariant
+      if (inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setProperty' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const char *names0, const QVariant  &amp;values1,
+        QObject *
+          selfpointer;
 
-			QString tmp_o_0(var_o_0-&gt;metaObject()-&gt;className());
-			
-			if(tmp_o_0 == &quot;QObject*&quot;) {
-				obj-&gt;installEventFilter((QObject*) var_o_0);
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QVariant *
+          cpp_arg_1 = static_cast &lt; QVariant * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_BOOL(selfpointer-&gt;setProperty((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const QVariant &amp;)*cpp_arg_1));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::setProperty(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *names0
+ * 
+ * @access	public
+ * @return	QVariant
+ * @flags	c
  */
-ZEND_METHOD(QObject, qt_cast){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+ZEND_METHOD(QObject, property)
+{
+  ///const char *names0
+#ifdef PHP_QT_QVariant          // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'property' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try const char *names0,
+      QObject *
+        selfpointer;
 
-		/* const char* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s&quot;, &amp;var_s_0, len_s_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			
-			obj-&gt;qt_cast( (const char*) var_s_0);
-			RETURN_NULL();
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QVariant *
+        return_object = new QVariant;
+
+      *return_object = static_cast &lt; QVariant &gt; (selfpointer-&gt;property((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QObject::property(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  setProperty
- *    flags:    
+/*!
+ * method dumpObjectInfo
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, setProperty){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* so */
-		char* var_so_0;   // default: 
-		int len_so_0;
+ZEND_METHOD(QObject, dumpObjectInfo)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'dumpObjectInfo' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
 
-		zval* z_var_so_1;   // default: 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;dumpObjectInfo());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::dumpObjectInfo(...) &quot;);
+}
 
-		/* const char* name, const QVariant&amp; value,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;so&quot;, &amp;var_so_0, len_so_0, &amp;z_var_so_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_so_1 = (QObject*) php_qt_fetch(z_var_so_1);
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-			QString tmp_so_0(var_so_1-&gt;metaObject()-&gt;className());
-			
-			if(tmp_so_0 == &quot;const QVariant&amp;&quot;) {
-				RETURN_BOOL(obj-&gt;setProperty((const char*) var_so_0, (const QVariant&amp;) var_so_1));
-			}
-		}
-	}
-}
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-/*********************************
- *    class     QObject */
-/*
- *    function  disconnectNotify
- *    flags:    v
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QObject, disconnectNotify){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+/*!
+ * method timerEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTimerEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
 
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
+ */
 
-		/* const char* signal,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s&quot;, &amp;var_s_0, len_s_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+ZEND_METHOD(QObject, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-			
-			obj-&gt;disconnectNotify( (const char*) var_s_0);
-			RETURN_NULL();
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QObject::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QObject::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  property
- *    flags:    c
+/*!
+ * method userData
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uint ids0
+ * 
+ * @access	public
+ * @return	QObjectUserData*
+ * @flags	c
  */
-ZEND_METHOD(QObject, property){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+ZEND_METHOD(QObject, userData)
+{
+  ///uint ids0
+#ifdef PHP_QT_QObjectUserData   // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'userData' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try uint ids0,
+      QObject *
+        selfpointer;
 
-		/* const char* name,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s&quot;, &amp;var_s_0, len_s_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			
-			QVariant return_object = (QVariant) obj-&gt;property( (const char*) var_s_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/*********************************
- *    class     QObject */
-/*
- *    function  dumpObjectInfo
- *    flags:    
- */
-ZEND_METHOD(QObject, dumpObjectInfo){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			obj-&gt;dumpObjectInfo();
-			RETURN_NULL();
-	}
+      le.ptr = static_cast &lt; QObjectUserData * &gt;(selfpointer-&gt;userData((uint) Z_LVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QObject::userData(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  registerUserData
- *    flags:    s
+/*!
+ * method setUserData
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	uint ids0
+ * @param	 QObjectUserData * datas1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, registerUserData){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;registerUserData());
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  metaObject
- *    flags:    cv
- */
-ZEND_METHOD(QObject, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QMetaObject * return_object = (QMetaObject *) obj-&gt;metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			const QMetaObject * return_object = (const QMetaObject *) obj-&gt;metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QObject, setUserData)
+{
+  ///uint ids0, QObjectUserData * datas1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QObjectUserData
+      if (inherits(Z_OBJCE_P(arg_1), 48)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setUserData' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try uint ids0, QObjectUserData * datas1,
+        QObject *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QObjectUserData *
+          cpp_arg_1 = static_cast &lt; QObjectUserData * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;setUserData((uint) Z_LVAL_P(arg_0), (QObjectUserData *) cpp_arg_1));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::setUserData(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  parent
- *    flags:    c
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QObject, parent){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject * return_object = (QObject *) obj-&gt;parent();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  receivers
- *    flags:    c
+/*!
+ * method setParent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, receivers){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+ZEND_METHOD(QObject, setParent)
+{
+  ///QObject *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setParent' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QObject *s0,
+        QObject *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
 
-		/* const char* signal,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s&quot;, &amp;var_s_0, len_s_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer-&gt;setParent((QObject *) cpp_arg_0));
+      }
+#endif
 
-			
-			RETURN_LONG(obj-&gt;receivers( (const char*) var_s_0));
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::setParent(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method killTimer
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ids0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, qt_emit){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* lo */
-		long var_lo_0;    // default: 
-		zval* z_var_lo_1;   // default: 
+ZEND_METHOD(QObject, killTimer)
+{
+  ///int ids0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'killTimer' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ids0,
+      QObject *
+        selfpointer;
 
-		/* int , QUObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;lo&quot;, &amp;var_lo_0, &amp;z_var_lo_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_lo_1 = (QObject*) php_qt_fetch(z_var_lo_1);
-
-			QString tmp_lo_0(var_lo_1-&gt;metaObject()-&gt;className());
-			
-			if(tmp_lo_0 == &quot;QUObject*&quot;) {
-				RETURN_BOOL(obj-&gt;qt_emit((int) var_lo_0, (QUObject*) var_lo_1));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;killTimer((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::killTimer(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  event
- *    flags:    v
+/*!
+ * method childEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChildEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QObject, event){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+/*!
+ * method moveToThread
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QThread *threads0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-		/* QEvent* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;o&quot;, &amp;z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+ZEND_METHOD(QObject, moveToThread)
+{
+  ///QThread *threads0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QThread
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'moveToThread' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QThread *threads0,
+        QObject *
+          selfpointer;
 
-			QString tmp_o_0(var_o_0-&gt;metaObject()-&gt;className());
-			
-			if(tmp_o_0 == &quot;QEvent*&quot;) {
-				RETURN_BOOL(obj-&gt;event((QEvent*) var_o_0));
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QThread *
+          cpp_arg_0 = static_cast &lt; QThread * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;moveToThread((QThread *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::moveToThread(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method dumpObjectTree
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, className){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			const char * return_object = (const char *) obj-&gt;className();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QObject, dumpObjectTree)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'dumpObjectTree' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;dumpObjectTree());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::dumpObjectTree(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  thread
- *    flags:    c
+/*!
+ * method eventFilter
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * @param	 QEvent *s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QObject, thread){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QThread * return_object = (QThread *) obj-&gt;thread();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  isWidgetType
- *    flags:    c
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QObject, isWidgetType){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isWidgetType());
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  sender
- *    flags:    c
+/*!
+ * method removeEventFilter
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, sender){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject * return_object = (QObject *) obj-&gt;sender();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QObject, removeEventFilter)
+{
+  ///QObject *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'removeEventFilter' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QObject *s0,
+        QObject *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;removeEventFilter((QObject *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::removeEventFilter(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  signalsBlocked
- *    flags:    c
+/*!
+ * method connectNotify
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *signals0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QObject, signalsBlocked){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;signalsBlocked());
-	}
+
+/*!
+ * method disconnect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *signal = 0s0
+ * @param	 const QObject *receiver = 0s1
+ * @param	 const char *member = 0s2
+ * 
+ * overloaded args:
+ * @param	const QObject *receiver
+ * @param	 const char *member = 0
+ * 
+ * overloaded args:
+ * @param	const QObject *sender
+ * @param	 const char *signal
+ * @param	 const QObject *receiver
+ * @param	 const char *member
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
+
+ZEND_METHOD(QObject, disconnect)
+{
+  ///const char *signal = 0s0, const QObject *receiver = 0s1, const char *member = 0s2
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'disconnect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;disconnect());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'disconnect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try const char *signal = 0s0,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;disconnect((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'disconnect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try const char *signal = 0s0, const QObject *receiver = 0s1,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      QObject *
+        cpp_arg_1 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_1));
+
+      RETURN_BOOL(selfpointer-&gt;disconnect((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const QObject *)cpp_arg_1));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'disconnect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try const char *signal = 0s0, const QObject *receiver = 0s1, const char *member = 0s2,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      QObject *
+        cpp_arg_1 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_1));
+
+      RETURN_BOOL(selfpointer-&gt;disconnect((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const QObject *)cpp_arg_1, (const char *)&amp;Z_STRVAL_P(arg_2)[0]));
+    }
+  }
+  ///const QObject *receiver, const char *member = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'disconnect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QObject *receiver,
+        QObject *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;disconnect((const QObject *)cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'disconnect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QObject *receiver, const char *member = 0,
+        QObject *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;disconnect((const QObject *)cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      }
+#endif
+
+    }
+  }
+  ///const QObject *sender, const char *signal, const QObject *receiver, const char *member
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_STRING) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 46)) {
+        /// try const QObject *sender, const char *signal, const QObject *receiver, const char *member,
+        QObject *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+        QObject *
+          cpp_arg_2 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_2));
+
+        if (getThis() == NULL) {
+          RETURN_BOOL(QObject::
+                      disconnect((const QObject *)cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0], (const QObject *)cpp_arg_2,
+                                 (const char *)&amp;Z_STRVAL_P(arg_3)[0]));
+        } else {
+          RETURN_BOOL(selfpointer-&gt;
+                      disconnect((const QObject *)cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0], (const QObject *)cpp_arg_2,
+                                 (const char *)&amp;Z_STRVAL_P(arg_3)[0]));
+      }}
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::disconnect(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method deleteLater
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QObject, staticMetaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QMetaObject* return_object = (QMetaObject*) obj-&gt;staticMetaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QObject, deleteLater)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'deleteLater' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;deleteLater());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::deleteLater(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  setUserData
- *    flags:    
+/*!
+ * method disconnectNotify
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *signals0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QObject, setUserData){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* lo */
-		long var_lo_0;    // default: 
-		zval* z_var_lo_1;   // default: 
+/*!
+ * method registerUserData
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	uint
+ * @flags	s
+ */
 
-		/* uint id, QObjectUserData* data,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;lo&quot;, &amp;var_lo_0, &amp;z_var_lo_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_lo_1 = (QObject*) php_qt_fetch(z_var_lo_1);
+ZEND_METHOD(QObject, registerUserData)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QObject *
+        selfpointer;
 
-			QString tmp_lo_0(var_lo_1-&gt;metaObject()-&gt;className());
-			
-			if(tmp_lo_0 == &quot;QObjectUserData*&quot;) {
-				obj-&gt;setUserData((uint) var_lo_0, (QObjectUserData*) var_lo_1);
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_LONG(QObject::registerUserData());
+      } else {
+        RETURN_LONG(selfpointer-&gt;registerUserData());
+      }
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::registerUserData(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  userData
- *    flags:    c
+/*!
+ * method parent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject *
+ * @flags	c
  */
-ZEND_METHOD(QObject, userData){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* l */
-		long var_l_0;    // default: 
+ZEND_METHOD(QObject, parent)
+{
+  ///
+#ifdef PHP_QT_QObject           // return type
 
-		/* uint id,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;l&quot;, &amp;var_l_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'parent' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
 
-			
-			QObjectUserData* return_object = (QObjectUserData*) obj-&gt;userData((uint) var_l_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast &lt; QObject * &gt;(selfpointer-&gt;parent());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QObject::parent(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method receivers
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char * signals0
+ * 
+ * @access	protected
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QObject, qObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* return_object = (QObject*) obj-&gt;qObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  setObjectName
- *    flags:    
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QObject, setObjectName){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+/*!
+ * method thread
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QThread *
+ * @flags	c
+ */
 
-		/* const QString&amp; name,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;o&quot;, &amp;z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+ZEND_METHOD(QObject, thread)
+{
+  ///
+#ifdef PHP_QT_QThread           // return type
 
-			QString tmp_o_0(var_o_0-&gt;metaObject()-&gt;className());
-			
-			if(tmp_o_0 == &quot;const QString&amp;&quot;) {
-				obj-&gt;setObjectName((const QString&amp;) var_o_0);
-			RETURN_NULL();
-			}
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'thread' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast &lt; QThread * &gt;(selfpointer-&gt;thread());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QObject::thread(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  killTimer
- *    flags:    
+/*!
+ * method isWidgetType
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QObject, killTimer){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* l */
-		long var_l_0;    // default: 
+ZEND_METHOD(QObject, isWidgetType)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isWidgetType' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
 
-		/* int id,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;l&quot;, &amp;var_l_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-
-			
-			obj-&gt;killTimer((int) var_l_0);
-			RETURN_NULL();
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isWidgetType());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::isWidgetType(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  setParent
- *    flags:    
+/*!
+ * method sender
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	QObject *
+ * @flags	c
  */
-ZEND_METHOD(QObject, setParent){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+/*!
+ * method signalsBlocked
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-		/* QObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;o&quot;, &amp;z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+ZEND_METHOD(QObject, signalsBlocked)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'signalsBlocked' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
 
-			QString tmp_o_0(var_o_0-&gt;metaObject()-&gt;className());
-			
-			if(tmp_o_0 == &quot;QObject*&quot;) {
-				obj-&gt;setParent((QObject*) var_o_0);
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;signalsBlocked());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::signalsBlocked(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  moveToThread
- *    flags:    
+/*!
+ * method setObjectName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;names0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QObject, moveToThread){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+ZEND_METHOD(QObject, setObjectName)
+{
+  ///const QString &amp;names0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-		/* QThread* thread,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;o&quot;, &amp;z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setObjectName' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;names0,
+        QObject *
+          selfpointer;
 
-			QString tmp_o_0(var_o_0-&gt;metaObject()-&gt;className());
-			
-			if(tmp_o_0 == &quot;QThread*&quot;) {
-				obj-&gt;moveToThread((QThread*) var_o_0);
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setObjectName((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::setObjectName(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  connect
- *    flags:    c
+/*!
+ * method connect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QObject *senders0
+ * @param	 const char *signals1
+ * @param	 const char *members2
+ * @param	 Qt::ConnectionType type = Qt::AutoConnection s3
+ * 
+ * overloaded args:
+ * @param	const QObject *sender
+ * @param	 const char *signal
+ * @param	 const QObject *receiver
+ * @param	 const char *member
+ * @param	 Qt::ConnectionType = Qt::AutoConnection 
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QObject, connect){
 
-	if (ZEND_NUM_ARGS() == 4){
-		/* ossl */
-		zval* z_var_ossl_0;   // default: 
-		char* var_ossl_1;   // default: 
-		int len_ossl_1;
+ZEND_METHOD(QObject, connect)
+{
+  ///const QObject *senders0, const char *signals1, const char *members2, Qt::ConnectionType type = Qt::AutoConnection s3
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING &amp;&amp; Z_TYPE_P(arg_2) == IS_STRING) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'connect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QObject *senders0, const char *signals1, const char *members2,
+        QObject *
+          selfpointer;
 
-		char* var_ossl_2;   // default: 
-		int len_ossl_2;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
 
-		long var_ossl_3;    // default: Qt::AutoConnection
+        RETURN_BOOL(selfpointer-&gt;connect((const QObject *)cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0], (const char *)&amp;Z_STRVAL_P(arg_2)[0]));
+      }
+#endif
 
-		/* const QObject* sender, const char* signal, const char* member, int type,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;ossl|&quot;, &amp;z_var_ossl_0, &amp;var_ossl_1, len_ossl_1, &amp;var_ossl_2, len_ossl_2, &amp;var_ossl_3) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_ossl_0 = (QObject*) php_qt_fetch(z_var_ossl_0);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING &amp;&amp; Z_TYPE_P(arg_2) == IS_STRING &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'connect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QObject *senders0, const char *signals1, const char *members2, Qt::ConnectionType type = Qt::AutoConnection s3,
+        QObject *
+          selfpointer;
 
-			QString tmp_ossl_0(var_ossl_0-&gt;metaObject()-&gt;className());
-			
-			if(tmp_ossl_0 == &quot;const QObject*&quot;) {
-				RETURN_BOOL(obj-&gt;connect((const QObject*) var_ossl_0, (const char*) var_ossl_1, (const char*) var_ossl_2, (Qt::ConnectionType) var_ossl_3));
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 5){
-		/* ososl */
-		zval* z_var_ososl_0;   // default: 
-		char* var_ososl_1;   // default: 
-		int len_ososl_1;
+        RETURN_BOOL(selfpointer-&gt;
+                    connect((const QObject *)cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0], (const char *)&amp;Z_STRVAL_P(arg_2)[0],
+                            (Qt::ConnectionType) Z_LVAL_P(arg_3)));
+      }
+#endif
 
-		zval* z_var_ososl_2;   // default: 
-		char* var_ososl_3;   // default: 
-		int len_ososl_3;
+    }
+  }
+  ///const QObject *sender, const char *signal, const QObject *receiver, const char *member, Qt::ConnectionType = Qt::AutoConnection 
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_STRING) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 46)) {
+        /// try const QObject *sender, const char *signal, const QObject *receiver, const char *member,
+        QObject *
+          selfpointer;
 
-		long var_ososl_4;    // default: Qt::AutoConnection
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+        QObject *
+          cpp_arg_2 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_2));
 
-		/* const QObject* sender, const char* signal, const QObject* receiver, const char* member, int ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;ososl|&quot;, &amp;z_var_ososl_0, &amp;var_ososl_1, len_ososl_1, &amp;z_var_ososl_2, &amp;var_ososl_3, len_ososl_3, &amp;var_ososl_4) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_ososl_0 = (QObject*) php_qt_fetch(z_var_ososl_0);
-			QObject* var_ososl_2 = (QObject*) php_qt_fetch(z_var_ososl_2);
+        if (getThis() == NULL) {
+          RETURN_BOOL(QObject::
+                      connect((const QObject *)cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0], (const QObject *)cpp_arg_2,
+                              (const char *)&amp;Z_STRVAL_P(arg_3)[0]));
+        } else {
+          RETURN_BOOL(selfpointer-&gt;
+                      connect((const QObject *)cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0], (const QObject *)cpp_arg_2,
+                              (const char *)&amp;Z_STRVAL_P(arg_3)[0]));
+      }}
+#endif
 
-			QString tmp_ososl_0(var_ososl_0-&gt;metaObject()-&gt;className());
-			QString tmp_ososl_1(var_ososl_2-&gt;metaObject()-&gt;className());
-			
-			if(tmp_ososl_0 == &quot;const QObject*&quot; &amp;&amp; tmp_ososl_1 == &quot;const QObject*&quot;) {
-				RETURN_BOOL(obj-&gt;connect((const QObject*) var_ososl_0, (const char*) var_ososl_1, (const QObject*) var_ososl_2, (const char*) var_ososl_3, (Qt::ConnectionType) var_ososl_4));
-			}
-		}
-	}
-}
+#endif
 
-/*********************************
- *    class     QObject */
-/*
- *    function  blockSignals
- *    flags:    
- */
-ZEND_METHOD(QObject, blockSignals){
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_STRING &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QObject
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 46)) {
+        /// try const QObject *sender, const char *signal, const QObject *receiver, const char *member, Qt::ConnectionType = Qt::AutoConnection ,
+        QObject *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* b */
-		bool var_b_0;   // _default: 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+        QObject *
+          cpp_arg_2 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_2));
 
-		/* bool b,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;b&quot;, &amp;var_b_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+        if (getThis() == NULL) {
+          RETURN_BOOL(QObject::
+                      connect((const QObject *)cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0], (const QObject *)cpp_arg_2, (const char *)&amp;Z_STRVAL_P(arg_3)[0],
+                              (Qt::ConnectionType) Z_LVAL_P(arg_4)));
+        } else {
+          RETURN_BOOL(selfpointer-&gt;
+                      connect((const QObject *)cpp_arg_0, (const char *)&amp;Z_STRVAL_P(arg_1)[0], (const QObject *)cpp_arg_2, (const char *)&amp;Z_STRVAL_P(arg_3)[0],
+                              (Qt::ConnectionType) Z_LVAL_P(arg_4)));
+      }}
+#endif
 
-			
-			RETURN_BOOL(obj-&gt;blockSignals((bool) var_b_0));
-		}
-	}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::connect(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  objectName
- *    flags:    c
+/*!
+ * method blockSignals
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bs0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QObject, objectName){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QString return_object = (QString) obj-&gt;objectName();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QObject, blockSignals)
+{
+  ///bool bs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'blockSignals' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bs0,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;blockSignals((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::blockSignals(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  QObject
- *    flags:    t
+/*!
+ * method objectName
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QObject, __construct){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 0
+ZEND_METHOD(QObject, objectName)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-		/* QObject* parent,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;o|&quot;, &amp;z_var_o_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'objectName' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QObject *
+        selfpointer;
 
-			QString tmp_o_0(var_o_0-&gt;metaObject()-&gt;className());
-			
-			if(tmp_o_0 == &quot;QObject*&quot;) {
-				QObject *QObject_ptr = new QObject((QObject*) var_o_0);
-			PHP_QT_REGISTER(QObject_ptr);
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* oo */
-		zval* z_var_oo_0;   // default: 
-		zval* z_var_oo_1;   // default: 0
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-		/* QObjectPrivate&amp; dd, QObject* parent,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;oo|&quot;, &amp;z_var_oo_0, &amp;z_var_oo_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_oo_0 = (QObject*) php_qt_fetch(z_var_oo_0);
-			QObject* var_oo_1 = (QObject*) php_qt_fetch(z_var_oo_1);
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;objectName());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			QString tmp_oo_0(var_oo_0-&gt;metaObject()-&gt;className());
-			QString tmp_oo_1(var_oo_1-&gt;metaObject()-&gt;className());
-			
-			if(tmp_oo_0 == &quot;QObjectPrivate&amp;&quot; &amp;&amp; tmp_oo_1 == &quot;QObject*&quot;) {
-				QObject *QObject_ptr = new QObject((QObjectPrivate&amp;) var_oo_0, (QObject*) var_oo_1);
-			PHP_QT_REGISTER(QObject_ptr);
-			RETURN_NULL();
-			}
-		}
-	}
+  php_error(E_ERROR, &quot;could not parse argument in QObject::objectName(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  dumpObjectTree
- *    flags:    
+/*!
+ * method customEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QObject, dumpObjectTree){
-	if (ZEND_NUM_ARGS() == 0){
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			obj-&gt;dumpObjectTree();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QObject */
-/*
- *    function  startTimer
- *    flags:    
+/*!
+ * method QObject
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *parent=0s0
+ * 
+ * overloaded args:
+ * @param	QObjectPrivate &amp;dd
+ * @param	 QObject *parent = 0
+ * 
+ * overloaded args:
+ * @param	const QObject &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QObject, startTimer){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* l */
-		long var_l_0;    // default: 
+ZEND_METHOD(QObject, __construct)
+{
+  ///QObject *parent=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QObject_php_qt *
+        selfpointer = new QObject_php_qt(getThis());
 
-		/* int interval,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;l&quot;, &amp;var_l_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QObject *parent=0s0,
+      QObject *
+        cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+      QObject_php_qt *
+        selfpointer = new QObject_php_qt(getThis(), (QObject *) cpp_arg_0);
 
-			
-			RETURN_LONG(obj-&gt;startTimer((int) var_l_0));
-		}
-	}
-}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QObjectPrivate &amp;dd, QObject *parent = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObjectPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QObjectPrivate &amp;dd,
+        QObjectPrivate *
+          cpp_arg_0 = static_cast &lt; QObjectPrivate * &gt;(php_qt_fetch(arg_0));
+        QObject_php_qt *
+          selfpointer = new QObject_php_qt(getThis(), (QObjectPrivate &amp;) * cpp_arg_0);
 
-/*********************************
- *    class     QObject */
-/*
- *    function  inherits
- *    flags:    c
- */
-ZEND_METHOD(QObject, inherits){
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QObjectPrivate
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QObjectPrivate &amp;dd, QObject *parent = 0,
+        QObjectPrivate *
+          cpp_arg_0 = static_cast &lt; QObjectPrivate * &gt;(php_qt_fetch(arg_0));
+        QObject *
+          cpp_arg_1 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_1));
+        QObject_php_qt *
+          selfpointer = new QObject_php_qt(getThis(), (QObjectPrivate &amp;) * cpp_arg_0, (QObject *) cpp_arg_1);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-		/* const char* classname,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s&quot;, &amp;var_s_0, len_s_0) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+    }
+  }
+  ///const QObject &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_0), 46)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QObject::__construct(...) cannot be called with 'const QObject &amp;,'.&quot;);
+      }
+#endif
 
-			
-			RETURN_BOOL(obj-&gt;inherits( (const char*) var_s_0));
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::QObject(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  eventFilter
- *    flags:    v
+/*!
+ * method startTimer
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int intervals0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	
  */
-ZEND_METHOD(QObject, eventFilter){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* oo */
-		zval* z_var_oo_0;   // default: 
-		zval* z_var_oo_1;   // default: 
+ZEND_METHOD(QObject, startTimer)
+{
+  ///int intervals0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'startTimer' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int intervals0,
+      QObject *
+        selfpointer;
 
-		/* QObject* , QEvent* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;oo&quot;, &amp;z_var_oo_0, &amp;z_var_oo_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_oo_0 = (QObject*) php_qt_fetch(z_var_oo_0);
-			QObject* var_oo_1 = (QObject*) php_qt_fetch(z_var_oo_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;startTimer((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::startTimer(...) &quot;);
+}
 
-			QString tmp_oo_0(var_oo_0-&gt;metaObject()-&gt;className());
-			QString tmp_oo_1(var_oo_1-&gt;metaObject()-&gt;className());
-			
-			if(tmp_oo_0 == &quot;QObject*&quot; &amp;&amp; tmp_oo_1 == &quot;QEvent*&quot;) {
-				RETURN_BOOL(obj-&gt;eventFilter((QObject*) var_oo_0, (QEvent*) var_oo_1));
-			}
-		}
-	}
+/*!
+ * method inherits
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *classnames0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+ZEND_METHOD(QObject, inherits)
+{
+  ///const char *classnames0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'inherits' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try const char *classnames0,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;inherits((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QObject::inherits(...) &quot;);
 }
 
-/*********************************
- *    class     QObject */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * overloaded args:
+ * @param	const char *
+ * @param	 const char *
+ * 
+ * overloaded args:
+ * @param	const char *sourceText
+ * @param	 const char * = 0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QObject, trUtf8){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* ss */
-		char* var_ss_0;   // default: 
-		int len_ss_0;
+ZEND_METHOD(QObject, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-		char* var_ss_1;   // default: 0
-		int len_ss_1;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QObject *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-		/* const char* , const char* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;ss|&quot;, &amp;var_ss_0, len_ss_0, &amp;var_ss_1, len_ss_1) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-									
-			QString return_object = (QString) obj-&gt;trUtf8( (const char*) var_ss_0 , (const char*) var_ss_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QObject_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-		}
-	}
-}
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QObject::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QObject *
+        selfpointer;
 
-/*********************************
- *    class     QObject */
-/*
- *    function  qt_property
- *    flags:    v
- */
-ZEND_METHOD(QObject, qt_property){
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-	if (ZEND_NUM_ARGS() == 3){
-		/* llo */
-		long var_llo_0;    // default: 
-		long var_llo_1;    // default: 
-		zval* z_var_llo_2;   // default: 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-		/* int , int , QVariant* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;llo&quot;, &amp;var_llo_0, &amp;var_llo_1, &amp;z_var_llo_2) == SUCCESS) {
-			QObject *obj = (QObject*) PHP_QT_FETCH();
-			QObject* var_llo_2 = (QObject*) php_qt_fetch(z_var_llo_2);
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QObject::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			QString tmp_llo_0(var_llo_2-&gt;metaObject()-&gt;className());
-			
-			if(tmp_llo_0 == &quot;QVariant*&quot;) {
-				RETURN_BOOL(obj-&gt;qt_property((int) var_llo_0, (int) var_llo_1, (QVariant*) var_llo_2));
-			}
-		}
-	}
-}
 
+  ///const char *, const char *
+#ifdef PHP_QT_QString           // return type
 
-PHP_QT_DESTRUCT(QObject);
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try const char *, const char *,
+      QObject *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QObject::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const char *sourceText, const char * = 0
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *sourceText,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QObject::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try const char *sourceText, const char * = 0,
+      QObject *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QObject * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QObject::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QObject::trUtf8(...) &quot;);
+}

Modified: trunk/qt/classes/qobjectdata.cpp
===================================================================
--- trunk/qt/classes/qobjectdata.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qobjectdata.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,16 +19,15 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QObjectData.cpp - QObjectData PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QObjectData&gt;
 #include &quot;../php_qt.h&quot;
 
 
-PHP_QT_DESTRUCT(QObjectData);
-
+#include &lt;QObjectData&gt;
+/// DEBUG:destructor skipped.

Modified: trunk/qt/classes/qobjectuserdata.cpp
===================================================================
--- trunk/qt/classes/qobjectuserdata.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qobjectuserdata.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,16 +19,15 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QObjectUserData.cpp - QObjectUserData PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QObjectUserData&gt;
 #include &quot;../php_qt.h&quot;
 
 
-PHP_QT_DESTRUCT(QObjectUserData);
-
+#include &lt;QObjectUserData&gt;
+/// DEBUG:destructor skipped.

Modified: trunk/qt/classes/qpaintdevice.cpp
===================================================================
--- trunk/qt/classes/qpaintdevice.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qpaintdevice.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QPaintDevice.cpp - QPaintDevice PHP implementation.
- * begin           : Tue Apr 11 10:33:13 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -31,262 +30,316 @@
 
 
 #include &lt;QPaintDevice&gt;
-
-
-/*		public enumPaintDeviceMetric:long {
-			PdmWidth = 1,
-			PaintDeviceMetric = 1,
-			PaintDeviceMetric = 2,
-			PaintDeviceMetric = 3,
-			PaintDeviceMetric = 4,
-			PaintDeviceMetric = 5,
-			PaintDeviceMetric = 6,
-			PaintDeviceMetric = 7,
-			PaintDeviceMetric = 8,
-			PaintDeviceMetric = 9
-		}
-*/
+/// DEBUG:destructor skipped.
 /*!
- *    @class     QPaintDevice
- *    @function  width
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method logicalDpiY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, width)
+
+ZEND_METHOD(QPaintDevice, logicalDpiY)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;width());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QPaintDevice::logicalDpiY(...) cannot be called with ''.&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QPaintDevice::logicalDpiY(...) &quot;);
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  physicalDpiX
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method heightMM
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, physicalDpiX)
+
+ZEND_METHOD(QPaintDevice, heightMM)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;physicalDpiX());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QPaintDevice::heightMM(...) cannot be called with ''.&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QPaintDevice::heightMM(...) &quot;);
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  logicalDpiY
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method numColors
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, logicalDpiY)
+
+ZEND_METHOD(QPaintDevice, numColors)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;logicalDpiY());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QPaintDevice::numColors(...) cannot be called with ''.&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QPaintDevice::numColors(...) &quot;);
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  heightMM
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method logicalDpiX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, heightMM)
+
+ZEND_METHOD(QPaintDevice, logicalDpiX)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;heightMM());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QPaintDevice::logicalDpiX(...) cannot be called with ''.&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QPaintDevice::logicalDpiX(...) &quot;);
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  paintingActive
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method width
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, paintingActive)
+
+ZEND_METHOD(QPaintDevice, width)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;paintingActive());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QPaintDevice::width(...) cannot be called with ''.&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QPaintDevice::width(...) &quot;);
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  numColors
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method height
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, numColors)
+
+ZEND_METHOD(QPaintDevice, height)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;numColors());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QPaintDevice::height(...) cannot be called with ''.&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QPaintDevice::height(...) &quot;);
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  logicalDpiX
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method QPaintDevice
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPaintDevice &amp;
+ * 
+ * @access	protected
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QPaintDevice, logicalDpiX)
+
+/*!
+ * method devType
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cv
+ */
+
+/*!
+ * method widthMM
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QPaintDevice, widthMM)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;logicalDpiX());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QPaintDevice::widthMM(...) cannot be called with ''.&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QPaintDevice::widthMM(...) &quot;);
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  depth
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method depth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QPaintDevice, depth)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;depth());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QPaintDevice::depth(...) cannot be called with ''.&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QPaintDevice::depth(...) &quot;);
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  height
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method physicalDpiY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, height)
+
+ZEND_METHOD(QPaintDevice, physicalDpiY)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;height());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QPaintDevice::physicalDpiY(...) cannot be called with ''.&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QPaintDevice::physicalDpiY(...) &quot;);
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  physicalDpiY
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method physicalDpiX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QPaintDevice, physicalDpiY)
+
+ZEND_METHOD(QPaintDevice, physicalDpiX)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;physicalDpiY());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QPaintDevice::physicalDpiX(...) cannot be called with ''.&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QPaintDevice::physicalDpiX(...) &quot;);
 }
 
 /*!
- *    @class     QPaintDevice
- *    @function  widthMM
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method paintEngine
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPaintEngine *
+ * @flags	cpv
  */
-ZEND_METHOD(QPaintDevice, widthMM)
+
+/*!
+ * method metric
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	PaintDeviceMetric metrics0
+ * 
+ * @access	protected
+ * @return	int
+ * @flags	cv
+ */
+
+/*!
+ * method paintingActive
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+ZEND_METHOD(QPaintDevice, paintingActive)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
-
-    if (getThis() != NULL) {
-      QPaintDevice *obj = (QPaintDevice *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;widthMM());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QPaintDevice::paintingActive(...) cannot be called with ''.&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QPaintDevice::paintingActive(...) &quot;);
 }
-
-
-PHP_QT_DESTRUCT(QPaintDevice);

Modified: trunk/qt/classes/qpainter.cpp
===================================================================
--- trunk/qt/classes/qpainter.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qpainter.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,2888 +19,7259 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QPainter.cpp - QPainter PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QPainter&gt;
 #include &quot;../php_qt.h&quot;
 
+
+#include &lt;QPainter&gt;
 #include &lt;QPainterPath&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QPainter_php_qt:public QPainter
+{
 
+public:
+  QPainter_php_qt(zval * zend_ptr);
+  QPainter_php_qt(zval * zend_ptr, QPaintDevice * s0);
 
-/*		public enumRenderHint:long {
-			Antialiasing = 0x01,
-			TextAntialiasing = 0x02,
-			SmoothPixmapTransform = 0x04,
-		}
-*/
 
-/*		public enumCompositionMode:long {
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-			CompositionMode = 0,
-		}
-*/
-/*********************************
- *    class     QPainter */
-/*
- *    function  eraseRect
- *    flags:    
+  zval *zend_ptr;
+};
+
+QPainter_php_qt::QPainter_php_qt(zval * zend_ptr):QPainter()
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+QPainter_php_qt::QPainter_php_qt(zval * zend_ptr, QPaintDevice * s0):QPainter(s0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method eraseRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;s0
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, eraseRect){
-		/* o public*/
 
-		/* const QRectF&amp; ,  */
+ZEND_METHOD(QPainter, eraseRect)
+{
+  ///const QRectF &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'eraseRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;s0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;eraseRect((const QRectF &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot;) {
-				obj-&gt;eraseRect((const QRectF&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot;) {
-				obj-&gt;eraseRect((const QRect&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llll public*/
+    }
+  }
+  ///int x, int y, int w, int h
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'eraseRect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h,
+      QPainter *
+        selfpointer;
 
-		/* int x, int y, int w, int h,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;eraseRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  ///const QRect &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'eraseRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;eraseRect((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;eraseRect((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::eraseRect(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setClipPath
- *    flags:    
+/*!
+ * method setClipPath
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPainterPath &amp;paths0
+ * @param	 Qt::ClipOperation op = Qt::ReplaceClips1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setClipPath){
-		/* ll public*/
 
-		/* const QPainterPath&amp; path, int op,  */
+ZEND_METHOD(QPainter, setClipPath)
+{
+  ///const QPainterPath &amp;paths0, Qt::ClipOperation op = Qt::ReplaceClips1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPainterPath
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setClipPath' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPainterPath &amp;paths0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPainterPath *
+          cpp_arg_0 = static_cast &lt; QPainterPath * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setClipPath((const QPainterPath &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;setClipPath((const QPainterPath&amp;) Z_LVAL_P(z_0) ,(Qt::ClipOperation) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPainterPath
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setClipPath' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPainterPath &amp;paths0, Qt::ClipOperation op = Qt::ReplaceClips1,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPainterPath *
+          cpp_arg_0 = static_cast &lt; QPainterPath * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setClipPath((const QPainterPath &amp;)*cpp_arg_0, (Qt::ClipOperation) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setClipPath(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  matrixEnabled
- *    flags:    c
+/*!
+ * method matrixEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QPainter, matrixEnabled){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;matrixEnabled());
-	}
+
+ZEND_METHOD(QPainter, matrixEnabled)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'matrixEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;matrixEnabled());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::matrixEnabled(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  shear
- *    flags:    
+/*!
+ * method shear
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	qreal shs0
+ * @param	 qreal svs1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, shear){
-		/* ll public*/
 
-		/* double sh, double sv,  */
+ZEND_METHOD(QPainter, shear)
+{
+// notice: unknown argument qreal shs0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::shear(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+/*!
+ * method save
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QPainter, save)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'save' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
-			obj-&gt;shear((qreal) Z_LVAL_P(z_0) ,(qreal) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;save());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::save(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  save
- *    flags:    
+/*!
+ * method resetMatrix
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, save){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			obj-&gt;save();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  resetMatrix
- *    flags:    
- */
-ZEND_METHOD(QPainter, resetMatrix){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			obj-&gt;resetMatrix();
-			RETURN_NULL();
-	}
+ZEND_METHOD(QPainter, resetMatrix)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'resetMatrix' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;resetMatrix());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::resetMatrix(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  initFrom
- *    flags:    
+/*!
+ * method initFrom
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QWidget *widgets0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, initFrom){
-		/* o public*/
 
-		/* const QWidget* widget,  */
+ZEND_METHOD(QPainter, initFrom)
+{
+  ///const QWidget *widgets0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'initFrom' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QWidget *widgets0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;initFrom((const QWidget *)cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				obj-&gt;initFrom((const QWidget*) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::initFrom(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  fontInfo
- *    flags:    c
+/*!
+ * method fontInfo
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QFontInfo
+ * @flags	c
  */
-ZEND_METHOD(QPainter, fontInfo){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QFontInfo return_object = (QFontInfo) obj-&gt;fontInfo();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setLayoutDirection
- *    flags:    
- */
-ZEND_METHOD(QPainter, setLayoutDirection){
-		/* l public*/
+ZEND_METHOD(QPainter, fontInfo)
+{
+  ///
+#ifdef PHP_QT_QFontInfo         // return type
 
-		/* int direction,  */
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'fontInfo' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QFontInfo *
+        return_object = new QFontInfo;
 
-			obj-&gt;setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      *return_object = static_cast &lt; QFontInfo &gt; (selfpointer-&gt;fontInfo());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::fontInfo(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setBrushOrigin
- *    flags:    
+/*!
+ * method setLayoutDirection
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::LayoutDirection directions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setBrushOrigin){
-		/* l public*/
 
-		/* const QPoint&amp; ,  */
+ZEND_METHOD(QPainter, setLayoutDirection)
+{
+  ///Qt::LayoutDirection directions0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setLayoutDirection' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::LayoutDirection directions0,
+      QPainter *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setLayoutDirection(...) &quot;);
+}
 
+/*!
+ * method setBrushOrigin
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int xs0
+ * @param	 int ys1
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;
+ * 
+ * overloaded args:
+ * @param	const QPointF &amp;
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj-&gt;setBrushOrigin((const QPoint&amp;) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-		/* ll public*/
+ZEND_METHOD(QPainter, setBrushOrigin)
+{
+  ///int xs0, int ys1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setBrushOrigin' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int xs0, int ys1,
+      QPainter *
+        selfpointer;
 
-		/* int x, int y,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setBrushOrigin((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  ///const QPoint &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setBrushOrigin' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setBrushOrigin((const QPoint &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;setBrushOrigin((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+    }
+  }
+  ///const QPointF &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setBrushOrigin' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF &amp;,
+        QPainter *
+          selfpointer;
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  pen
- *    flags:    c
- */
-ZEND_METHOD(QPainter, pen){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				const QPen &amp; return_object = (const QPen &amp;) obj-&gt;pen();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setBrushOrigin((const QPointF &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setBrushOrigin(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawRects
- *    flags:    
+/*!
+ * method pen
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPen &amp;
+ * @flags	c
  */
-ZEND_METHOD(QPainter, drawRects){
-		/* ol public*/
 
-		/* const QRectF* rects, int rectCount,  */
+ZEND_METHOD(QPainter, pen)
+{
+  ///
+#ifdef PHP_QT_QPen              // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pen' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot;) {
-				obj-&gt;drawRects((const QRectF*) obj_z_0, (int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &amp;const_cast &lt; QPen &amp; &gt;(selfpointer-&gt;pen());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::pen(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPath
- *    flags:    
+/*!
+ * method drawRects
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF *rectss0
+ * @param	 int rectCounts1
+ * 
+ * overloaded args:
+ * @param	const QVector&lt;QRectF&gt; &amp;rectangles
+ * 
+ * overloaded args:
+ * @param	const QRect *rects
+ * @param	 int rectCount
+ * 
+ * overloaded args:
+ * @param	const QVector&lt;QRect&gt; &amp;rectangles
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPath){
-		/* l public*/
 
-		/* const QPainterPath&amp; path,  */
+ZEND_METHOD(QPainter, drawRects)
+{
+  ///const QRectF *rectss0, int rectCounts1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawRects' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF *rectss0, int rectCounts1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawRects((const QRectF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			obj-&gt;drawPath((const QPainterPath&amp;) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+    }
+  }
+  ///const QVector&lt;QRectF&gt; &amp;rectangles
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVector
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawRects' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QVector&lt;QRectF&gt; &amp;rectangles,
+        QPainter *
+          selfpointer;
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  fillPath
- *    flags:    
- */
-ZEND_METHOD(QPainter, fillPath){
-		/* lo public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QVector &lt; QRectF &gt; *cpp_arg_0 = static_cast &lt; QVector &lt; QRectF &gt; *&gt;(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer-&gt;drawRects((const QVector &lt; QRectF &gt; &amp;)*cpp_arg_0));
+      }
+#endif
 
-		/* const QPainterPath&amp; path, const QBrush&amp; brush,  */
+    }
+  }
+  ///const QRect *rects, int rectCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawRects' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect *rects, int rectCount,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawRects((const QRect *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			if(obj_z_1-&gt;inherits(&quot;QBrush&quot;)) {
-				obj-&gt;fillPath((const QPainterPath&amp;) Z_LVAL_P(z_0), (const QBrush&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  ///const QVector&lt;QRect&gt; &amp;rectangles
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVector
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawRects' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QVector&lt;QRect&gt; &amp;rectangles,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QVector &lt; QRect &gt; *cpp_arg_0 = static_cast &lt; QVector &lt; QRect &gt; *&gt;(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer-&gt;drawRects((const QVector &lt; QRect &gt; &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawRects(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  rotate
- *    flags:    
+/*!
+ * method drawPath
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPainterPath &amp;paths0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, rotate){
-		/* l public*/
 
-		/* double a,  */
+ZEND_METHOD(QPainter, drawPath)
+{
+  ///const QPainterPath &amp;paths0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPainterPath
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPath' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPainterPath &amp;paths0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPainterPath *
+          cpp_arg_0 = static_cast &lt; QPainterPath * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawPath((const QPainterPath &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;rotate((qreal) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawPath(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPie
- *    flags:    
+/*!
+ * method fillPath
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPainterPath &amp;paths0
+ * @param	 const QBrush &amp;brushs1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPie){
-		/* oll public*/
 
-		/* const QRectF&amp; rect, int a, int alen,  */
+ZEND_METHOD(QPainter, fillPath)
+{
+  ///const QPainterPath &amp;paths0, const QBrush &amp;brushs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPainterPath
+#ifdef PHP_QT_QBrush
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'fillPath' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPainterPath &amp;paths0, const QBrush &amp;brushs1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPainterPath *
+          cpp_arg_0 = static_cast &lt; QPainterPath * &gt;(php_qt_fetch(arg_0));
+        QBrush *
+          cpp_arg_1 = static_cast &lt; QBrush * &gt;(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer-&gt;fillPath((const QPainterPath &amp;)*cpp_arg_0, (const QBrush &amp;)*cpp_arg_1));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot;) {
-				obj-&gt;drawPie((const QRectF&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot;) {
-				obj-&gt;drawPie((const QRect&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllll public*/
+#endif
 
-		/* int x, int y, int w, int h, int a, int alen,  */
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::fillPath(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 6){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4, &amp;z_5) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_LONG &amp;&amp; Z_TYPE_P(z_5) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+/*!
+ * method rotate
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	qreal as0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-
-			obj-&gt;drawPie((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3) ,(int) Z_LVAL_P(z_4) ,(int) Z_LVAL_P(z_5));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QPainter, rotate)
+{
+// notice: unknown argument qreal as0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::rotate(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  translate
- *    flags:    
+/*!
+ * method drawPie
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;rects0
+ * @param	 int as1
+ * @param	 int alens2
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 int a
+ * @param	 int alen
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;
+ * @param	 int a
+ * @param	 int alen
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, translate){
-		/* l public*/
 
-		/* const QPointF&amp; offset,  */
+ZEND_METHOD(QPainter, drawPie)
+{
+  ///const QRectF &amp;rects0, int as1, int alens2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPie' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rects0, int as1, int alens2,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawPie((const QRectF &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-			obj-&gt;translate((const QPointF&amp;) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-		/* ll public*/
+    }
+  }
+  ///int x, int y, int w, int h, int a, int alen
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp; Z_TYPE_P(arg_4) == IS_LONG
+        &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'drawPie' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h, int a, int alen,
+      QPainter *
+        selfpointer;
 
-		/* double dx, double dy,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;
+                  drawPie((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4), (int)Z_LVAL_P(arg_5)));
+    }
+  }
+  ///const QRect &amp;, int a, int alen
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPie' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;, int a, int alen,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawPie((const QRect &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-			obj-&gt;translate((qreal) Z_LVAL_P(z_0) ,(qreal) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawPie(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setCompositionMode
- *    flags:    
+/*!
+ * method translate
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF &amp;offsets0
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;offset
+ * 
+ * overloaded args:
+ * @param	qreal dx
+ * @param	 qreal dy
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setCompositionMode){
-		/* l public*/
 
-		/* QPainter::CompositionMode mode,  */
+ZEND_METHOD(QPainter, translate)
+{
+  ///const QPointF &amp;offsets0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'translate' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF &amp;offsets0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;translate((const QPointF &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;setCompositionMode((QPainter::CompositionMode) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  ///const QPoint &amp;offset
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'translate' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;offset,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;translate((const QPoint &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument qreal dx, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::translate(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setWindow
- *    flags:    
+/*!
+ * method setCompositionMode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	CompositionMode modes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setWindow){
-		/* o public*/
 
-		/* const QRect&amp; window,  */
+ZEND_METHOD(QPainter, setCompositionMode)
+{
+// notice: unknown argument CompositionMode modes0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setCompositionMode(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method setWindow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;windows0
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QPainter, setWindow)
+{
+  ///const QRect &amp;windows0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setWindow' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;windows0,
+        QPainter *
+          selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot;) {
-				obj-&gt;setWindow((const QRect&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llll public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
-		/* int x, int y, int w, int h,  */
+        RETURN_VOID(selfpointer-&gt;setWindow((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+    }
+  }
+  ///int x, int y, int w, int h
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setWindow' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h,
+      QPainter *
+        selfpointer;
 
-
-			obj-&gt;setWindow((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setWindow((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setWindow(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  fontMetrics
- *    flags:    c
+/*!
+ * method fontMetrics
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QFontMetrics
+ * @flags	c
  */
-ZEND_METHOD(QPainter, fontMetrics){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QFontMetrics return_object = (QFontMetrics) obj-&gt;fontMetrics();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, fontMetrics)
+{
+  ///
+#ifdef PHP_QT_QFontMetrics      // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'fontMetrics' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QFontMetrics *
+        return_object = new QFontMetrics;
+
+      *return_object = static_cast &lt; QFontMetrics &gt; (selfpointer-&gt;fontMetrics());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::fontMetrics(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPixmap
- *    flags:    
+/*!
+ * method drawPixmap
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;targetRects0
+ * @param	 const QPixmap &amp;pixmaps1
+ * @param	 const QRectF &amp;sourceRects2
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;targetRect
+ * @param	 const QPixmap &amp;pixmap
+ * @param	 const QRect &amp;sourceRect
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 const QPixmap &amp;pm
+ * @param	 int sx
+ * @param	 int sy
+ * @param	 int sw
+ * @param	 int sh
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 const QPixmap &amp;pm
+ * @param	 int sx
+ * @param	 int sy
+ * @param	 int sw
+ * @param	 int sh
+ * 
+ * overloaded args:
+ * @param	const QPointF &amp;p
+ * @param	 const QPixmap &amp;pm
+ * @param	 const QRectF &amp;sr
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;p
+ * @param	 const QPixmap &amp;pm
+ * @param	 const QRect &amp;sr
+ * 
+ * overloaded args:
+ * @param	const QPointF &amp;p
+ * @param	 const QPixmap &amp;pm
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;p
+ * @param	 const QPixmap &amp;pm
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 const QPixmap &amp;pm
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;r
+ * @param	 const QPixmap &amp;pm
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 const QPixmap &amp;pm
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPixmap){
-		/* oo public*/
 
-		/* const QRect&amp; r, const QPixmap&amp; pm,  */
-		/* lo public*/
+ZEND_METHOD(QPainter, drawPixmap)
+{
+  ///const QRectF &amp;targetRects0, const QPixmap &amp;pixmaps1, const QRectF &amp;sourceRects2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QPixmap
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;targetRects0, const QPixmap &amp;pixmaps1, const QRectF &amp;sourceRects2,
+        QPainter *
+          selfpointer;
 
-		/* const QPointF&amp; p, const QPixmap&amp; pm,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_1));
+        QRectF *
+          cpp_arg_2 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_2));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        RETURN_VOID(selfpointer-&gt;drawPixmap((const QRectF &amp;)*cpp_arg_0, (const QPixmap &amp;)*cpp_arg_1, (const QRectF &amp;)*cpp_arg_2));
+      }
+#endif
 
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot; &amp;&amp; obj_z_1-&gt;inherits(&quot;QPixmap&quot;)) {
-				obj-&gt;drawPixmap((const QRect&amp;) obj_z_0, (const QPixmap&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+#endif
 
+    }
+  }
+  ///const QRect &amp;targetRect, const QPixmap &amp;pixmap, const QRect &amp;sourceRect
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QPixmap
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;targetRect, const QPixmap &amp;pixmap, const QRect &amp;sourceRect,
+        QPainter *
+          selfpointer;
 
-			if(obj_z_1-&gt;inherits(&quot;QPixmap&quot;)) {
-				obj-&gt;drawPixmap((const QPointF&amp;) Z_LVAL_P(z_0), (const QPixmap&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* loo public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_1));
+        QRect *
+          cpp_arg_2 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_2));
 
-		/* const QPointF&amp; p, const QPixmap&amp; pm, const QRectF&amp; sr,  */
-		/* ooo public*/
+        RETURN_VOID(selfpointer-&gt;drawPixmap((const QRect &amp;)*cpp_arg_0, (const QPixmap &amp;)*cpp_arg_1, (const QRect &amp;)*cpp_arg_2));
+      }
+#endif
 
-		/* const QRectF&amp; targetRect, const QPixmap&amp; pixmap, const QRectF&amp; sourceRect,  */
-		/* llo public*/
+#endif
 
-		/* int x, int y, const QPixmap&amp; pm,  */
+#endif
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+    }
+  }
+  ///int x, int y, int w, int h, const QPixmap &amp;pm, int sx, int sy, int sw, int sh
+  if (ZEND_NUM_ARGS() == 9) {
+    PHP_QT_FETCH_9_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG &amp;&amp; Z_TYPE_P(arg_6) == IS_LONG &amp;&amp; Z_TYPE_P(arg_7) == IS_LONG &amp;&amp; Z_TYPE_P(arg_8) == IS_LONG) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_4), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, const QPixmap &amp;pm, int sx, int sy, int sw, int sh,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_4 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_4));
 
-			if(obj_z_1-&gt;inherits(&quot;QPixmap&quot;) &amp;&amp; Z_OBJCE_P(z_2)-&gt;name == &quot;QRectF&quot;) {
-				obj-&gt;drawPixmap((const QPointF&amp;) Z_LVAL_P(z_0), (const QPixmap&amp;) obj_z_1, (const QRectF&amp;) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        RETURN_VOID(selfpointer-&gt;
+                    drawPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &amp;)*cpp_arg_4,
+                               (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6), (int)Z_LVAL_P(arg_7), (int)Z_LVAL_P(arg_8)));
+      }
+#endif
 
+    }
+  }
+  ///int x, int y, const QPixmap &amp;pm, int sx, int sy, int sw, int sh
+  if (ZEND_NUM_ARGS() == 7) {
+    PHP_QT_FETCH_7_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG &amp;&amp; Z_TYPE_P(arg_6) == IS_LONG) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QPixmap &amp;pm, int sx, int sy, int sw, int sh,
+        QPainter *
+          selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot; &amp;&amp; obj_z_1-&gt;inherits(&quot;QPixmap&quot;) &amp;&amp; Z_OBJCE_P(z_2)-&gt;name == &quot;QRectF&quot;) {
-				obj-&gt;drawPixmap((const QRectF&amp;) obj_z_0, (const QPixmap&amp;) obj_z_1, (const QRectF&amp;) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_2 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer-&gt;
+                    drawPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QPixmap &amp;)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                               (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6)));
+      }
+#endif
 
-			if(obj_z_2-&gt;inherits(&quot;QPixmap&quot;)) {
-				obj-&gt;drawPixmap((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QPixmap&amp;) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllo public*/
+    }
+  }
+  ///const QPointF &amp;p, const QPixmap &amp;pm, const QRectF &amp;sr
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QPixmap
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF &amp;p, const QPixmap &amp;pm, const QRectF &amp;sr,
+        QPainter *
+          selfpointer;
 
-		/* int x, int y, int w, int h, const QPixmap&amp; pm,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_1));
+        QRectF *
+          cpp_arg_2 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_2));
 
-	if (ZEND_NUM_ARGS() == 5){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_4 = (QObject*) php_qt_fetch(z_4);
+        RETURN_VOID(selfpointer-&gt;drawPixmap((const QPointF &amp;)*cpp_arg_0, (const QPixmap &amp;)*cpp_arg_1, (const QRectF &amp;)*cpp_arg_2));
+      }
+#endif
 
+#endif
 
-			if(obj_z_4-&gt;inherits(&quot;QPixmap&quot;)) {
-				obj-&gt;drawPixmap((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (const QPixmap&amp;) obj_z_4);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llollll public*/
+#endif
 
-		/* int x, int y, const QPixmap&amp; pm, int sx, int sy, int sw, int sh,  */
+    }
+  }
+  ///const QPoint &amp;p, const QPixmap &amp;pm, const QRect &amp;sr
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPixmap
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;p, const QPixmap &amp;pm, const QRect &amp;sr,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 7){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		zval *z_6; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4, &amp;z_5, &amp;z_6) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_LONG &amp;&amp; Z_TYPE_P(z_5) == IS_LONG &amp;&amp; Z_TYPE_P(z_6) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_1));
+        QRect *
+          cpp_arg_2 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer-&gt;drawPixmap((const QPoint &amp;)*cpp_arg_0, (const QPixmap &amp;)*cpp_arg_1, (const QRect &amp;)*cpp_arg_2));
+      }
+#endif
 
-			if(obj_z_2-&gt;inherits(&quot;QPixmap&quot;)) {
-				obj-&gt;drawPixmap((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QPixmap&amp;) obj_z_2, (int) Z_LVAL_P(z_3), (int) Z_LVAL_P(z_4), (int) Z_LVAL_P(z_5), (int) Z_LVAL_P(z_6));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllollll public*/
+#endif
 
-		/* int x, int y, int w, int h, const QPixmap&amp; pm, int sx, int sy, int sw, int sh,  */
+#endif
 
-	if (ZEND_NUM_ARGS() == 9){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		zval *z_6; // define ZVAL
-		zval *z_7; // define ZVAL
-		zval *z_8; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzzzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4, &amp;z_5, &amp;z_6, &amp;z_7, &amp;z_8) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_5) == IS_LONG &amp;&amp; Z_TYPE_P(z_6) == IS_LONG &amp;&amp; Z_TYPE_P(z_7) == IS_LONG &amp;&amp; Z_TYPE_P(z_8) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_4 = (QObject*) php_qt_fetch(z_4);
+    }
+  }
+  ///const QPointF &amp;p, const QPixmap &amp;pm
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF &amp;p, const QPixmap &amp;pm,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_1));
 
-			if(obj_z_4-&gt;inherits(&quot;QPixmap&quot;)) {
-				obj-&gt;drawPixmap((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (const QPixmap&amp;) obj_z_4, (int) Z_LVAL_P(z_5), (int) Z_LVAL_P(z_6), (int) Z_LVAL_P(z_7), (int) Z_LVAL_P(z_8));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_VOID(selfpointer-&gt;drawPixmap((const QPointF &amp;)*cpp_arg_0, (const QPixmap &amp;)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QPoint &amp;p, const QPixmap &amp;pm
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;p, const QPixmap &amp;pm,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;drawPixmap((const QPoint &amp;)*cpp_arg_0, (const QPixmap &amp;)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///int x, int y, const QPixmap &amp;pm
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QPixmap &amp;pm,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_2 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;drawPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QPixmap &amp;)*cpp_arg_2));
+      }
+#endif
+
+    }
+  }
+  ///const QRect &amp;r, const QPixmap &amp;pm
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;r, const QPixmap &amp;pm,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;drawPixmap((const QRect &amp;)*cpp_arg_0, (const QPixmap &amp;)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///int x, int y, int w, int h, const QPixmap &amp;pm
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_OBJECT) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_4), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, const QPixmap &amp;pm,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_4 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_4));
+
+        RETURN_VOID(selfpointer-&gt;
+                    drawPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &amp;)*cpp_arg_4));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawPixmap(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPolyline
- *    flags:    
+/*!
+ * method drawPolyline
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF *pointss0
+ * @param	 int pointCounts1
+ * 
+ * overloaded args:
+ * @param	const QPolygonF &amp;polyline
+ * 
+ * overloaded args:
+ * @param	const QPoint *points
+ * @param	 int pointCount
+ * 
+ * overloaded args:
+ * @param	const QPolygon &amp;polygon
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPolyline){
-		/* o public*/
 
-		/* const QPolygonF&amp; polyline,  */
+ZEND_METHOD(QPainter, drawPolyline)
+{
+  ///const QPointF *pointss0, int pointCounts1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPolyline' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF *pointss0, int pointCounts1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawPolyline((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QPolygonF&quot;) {
-				obj-&gt;drawPolyline((const QPolygonF&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QPolygon&quot;) {
-				obj-&gt;drawPolyline((const QPolygon&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ll public*/
+    }
+  }
+  ///const QPolygonF &amp;polyline
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygonF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPolyline' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPolygonF &amp;polyline,
+        QPainter *
+          selfpointer;
 
-		/* const QPointF* points, int pointCount,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPolygonF *
+          cpp_arg_0 = static_cast &lt; QPolygonF * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer-&gt;drawPolyline((const QPolygonF &amp;)*cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///const QPoint *points, int pointCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPolyline' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint *points, int pointCount,
+        QPainter *
+          selfpointer;
 
-			obj-&gt;drawPolyline((const QPointF*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawPolyline((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QPolygon &amp;polygon
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPolyline' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPolygon &amp;polygon,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPolygon *
+          cpp_arg_0 = static_cast &lt; QPolygon * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawPolyline((const QPolygon &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawPolyline(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  deviceMatrix
- *    flags:    c
+/*!
+ * method deviceMatrix
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QMatrix &amp;
+ * @flags	c
  */
-ZEND_METHOD(QPainter, deviceMatrix){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				const QMatrix &amp; return_object = (const QMatrix &amp;) obj-&gt;deviceMatrix();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, deviceMatrix)
+{
+  ///
+#ifdef PHP_QT_QMatrix           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'deviceMatrix' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &amp;const_cast &lt; QMatrix &amp; &gt;(selfpointer-&gt;deviceMatrix());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::deviceMatrix(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawLine
- *    flags:    
+/*!
+ * method drawLine
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QLineF &amp;lines0
+ * 
+ * overloaded args:
+ * @param	const QLine &amp;line
+ * 
+ * overloaded args:
+ * @param	int x1
+ * @param	 int y1
+ * @param	 int x2
+ * @param	 int y2
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;p1
+ * @param	 const QPoint &amp;p2
+ * 
+ * overloaded args:
+ * @param	const QPointF &amp;p1
+ * @param	 const QPointF &amp;p2
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawLine){
-		/* o public*/
 
-		/* const QLineF&amp; line,  */
+ZEND_METHOD(QPainter, drawLine)
+{
+  ///const QLineF &amp;lines0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLineF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawLine' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QLineF &amp;lines0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QLineF *
+          cpp_arg_0 = static_cast &lt; QLineF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawLine((const QLineF &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QLineF&quot;)) {
-				obj-&gt;drawLine((const QLineF&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ll public*/
+    }
+  }
+  ///const QLine &amp;line
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLine
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawLine' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QLine &amp;line,
+        QPainter *
+          selfpointer;
 
-		/* const QPoint&amp; p1, const QPoint&amp; p2,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QLine *
+          cpp_arg_0 = static_cast &lt; QLine * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer-&gt;drawLine((const QLine &amp;)*cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///int x1, int y1, int x2, int y2
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'drawLine' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x1, int y1, int x2, int y2,
+      QPainter *
+        selfpointer;
 
-			obj-&gt;drawLine((const QPoint&amp;) Z_LVAL_P(z_0) ,(const QPoint&amp;) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
-		/* llll public*/
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;drawLine((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  ///const QPoint &amp;p1, const QPoint &amp;p2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawLine' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;p1, const QPoint &amp;p2,
+        QPainter *
+          selfpointer;
 
-		/* int x1, int y1, int x2, int y2,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QPoint *
+          cpp_arg_1 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_1));
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer-&gt;drawLine((const QPoint &amp;)*cpp_arg_0, (const QPoint &amp;)*cpp_arg_1));
+      }
+#endif
 
+#endif
 
-			obj-&gt;drawLine((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  ///const QPointF &amp;p1, const QPointF &amp;p2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawLine' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF &amp;p1, const QPointF &amp;p2,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
+        QPointF *
+          cpp_arg_1 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;drawLine((const QPointF &amp;)*cpp_arg_0, (const QPointF &amp;)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawLine(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  fillRect
- *    flags:    
+/*!
+ * method fillRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;s0
+ * @param	 const QBrush &amp;s1
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 const QBrush &amp;
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;
+ * @param	 const QBrush &amp;
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, fillRect){
-		/* oo public*/
 
-		/* const QRectF&amp; , const QBrush&amp; ,  */
+ZEND_METHOD(QPainter, fillRect)
+{
+  ///const QRectF &amp;s0, const QBrush &amp;s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QBrush
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'fillRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;s0, const QBrush &amp;s1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QBrush *
+          cpp_arg_1 = static_cast &lt; QBrush * &gt;(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer-&gt;fillRect((const QRectF &amp;)*cpp_arg_0, (const QBrush &amp;)*cpp_arg_1));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot; &amp;&amp; obj_z_1-&gt;inherits(&quot;QBrush&quot;)) {
-				obj-&gt;fillRect((const QRectF&amp;) obj_z_0, (const QBrush&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot; &amp;&amp; obj_z_1-&gt;inherits(&quot;QBrush&quot;)) {
-				obj-&gt;fillRect((const QRect&amp;) obj_z_0, (const QBrush&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllo public*/
+#endif
 
-		/* int x, int y, int w, int h, const QBrush&amp; ,  */
+    }
+  }
+  ///int x, int y, int w, int h, const QBrush &amp;
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_OBJECT) {
+#ifdef PHP_QT_QBrush
+      if (inherits(Z_OBJCE_P(arg_4), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'fillRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, const QBrush &amp;,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 5){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_4 = (QObject*) php_qt_fetch(z_4);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QBrush *
+          cpp_arg_4 = static_cast &lt; QBrush * &gt;(php_qt_fetch(arg_4));
 
+        RETURN_VOID(selfpointer-&gt;fillRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QBrush &amp;)*cpp_arg_4));
+      }
+#endif
 
-			if(obj_z_4-&gt;inherits(&quot;QBrush&quot;)) {
-				obj-&gt;fillRect((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (const QBrush&amp;) obj_z_4);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  ///const QRect &amp;, const QBrush &amp;
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QBrush
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'fillRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;, const QBrush &amp;,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+        QBrush *
+          cpp_arg_1 = static_cast &lt; QBrush * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;fillRect((const QRect &amp;)*cpp_arg_0, (const QBrush &amp;)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::fillRect(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  boundingRect
- *    flags:    
+/*!
+ * method boundingRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;rects0
+ * @param	 int flagss1
+ * @param	 const QString &amp;texts2
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;rect
+ * @param	 int flags
+ * @param	 const QString &amp;text
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 int flags
+ * @param	 const QString &amp;text
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;rect
+ * @param	 const QString &amp;text
+ * @param	 const QTextOption &amp;o = QTextOption()
+ * 
+ * @access	public
+ * @return	QRectF
+ * @flags	
  */
-ZEND_METHOD(QPainter, boundingRect){
-		/* ooo public*/
 
-		/* const QRectF&amp; rect, const QString&amp; text, const QTextOption&amp; o,  */
-		/* olo public*/
+ZEND_METHOD(QPainter, boundingRect)
+{
+  ///const QRectF &amp;rects0, int flagss1, const QString &amp;texts2
+#ifdef PHP_QT_QRectF            // return type
 
-		/* const QRectF&amp; rect, int flags, const QString&amp; text,  */
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'boundingRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rects0, int flagss1, const QString &amp;texts2,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_2 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_2));
+        zend_class_entry *
+          ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot; &amp;&amp; obj_z_2-&gt;inherits(&quot;QTextOption&quot;)) {
-				obj-&gt;boundingRect((const QRectF&amp;) obj_z_0, (const QString&amp;) obj_z_1, (const QTextOption&amp;) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QRectF *
+          return_object = new QRectF;
 
+        *return_object = static_cast &lt; QRectF &gt; (selfpointer-&gt;boundingRect((const QRectF &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &amp;)*cpp_arg_2));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot; &amp;&amp; Z_OBJCE_P(z_2)-&gt;name == &quot;QString&quot;) {
-/*					QRect return_object = (QRect) obj-&gt;boundingRect((const QRectF&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (const QString&amp;) obj_z_2);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-*/				return;                                             
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot; &amp;&amp; Z_OBJCE_P(z_2)-&gt;name == &quot;QString&quot;) {
-					QRect return_object = (QRect) obj-&gt;boundingRect((const QRect&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (const QString&amp;) obj_z_2);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* lllllo public*/
+#endif
 
-		/* int x, int y, int w, int h, int flags, const QString&amp; text,  */
+    }
+  }
+#endif // return type
 
-	if (ZEND_NUM_ARGS() == 6){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4, &amp;z_5) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_LONG &amp;&amp; Z_TYPE_P(z_5) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_5 = (QObject*) php_qt_fetch(z_5);
 
+  ///const QRect &amp;rect, int flags, const QString &amp;text
+#ifdef PHP_QT_QRect             // return type
 
-			if(Z_OBJCE_P(z_5)-&gt;name == &quot;QString&quot;) {
-					QRect return_object = (QRect) obj-&gt;boundingRect((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (int) Z_LVAL_P(z_4), (const QString&amp;) obj_z_5);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'boundingRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;rect, int flags, const QString &amp;text,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_2 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_2));
+        zend_class_entry *
+          ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QRect *
+          return_object = new QRect;
+
+        *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;boundingRect((const QRect &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &amp;)*cpp_arg_2));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///int x, int y, int w, int h, int flags, const QString &amp;text
+#ifdef PHP_QT_QRect             // return type
+
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    arg_5 = invokeToQString(arg_5);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp; Z_TYPE_P(arg_4) == IS_LONG
+        &amp;&amp; Z_TYPE_P(arg_5) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_5), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'boundingRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, int flags, const QString &amp;text,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_5 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_5));
+        zend_class_entry *
+          ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QRect *
+          return_object = new QRect;
+
+        *return_object =
+          static_cast &lt; QRect &gt;
+          (selfpointer-&gt;
+           boundingRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                        (const QString &amp;)*cpp_arg_5));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QRectF &amp;rect, const QString &amp;text, const QTextOption &amp;o = QTextOption()
+#ifdef PHP_QT_QRectF            // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'boundingRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rect, const QString &amp;text,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *
+          ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QRectF *
+          return_object = new QRectF;
+
+        *return_object = static_cast &lt; QRectF &gt; (selfpointer-&gt;boundingRect((const QRectF &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_1 = invokeToQString(arg_1);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'boundingRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rect, const QString &amp;text, const QTextOption &amp;o = QTextOption(),
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        QTextOption *
+          cpp_arg_2 = static_cast &lt; QTextOption * &gt;(php_qt_fetch(arg_2));
+        zend_class_entry *
+          ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QRectF *
+          return_object = new QRectF;
+
+        *return_object =
+          static_cast &lt; QRectF &gt; (selfpointer-&gt;boundingRect((const QRectF &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1, (const QTextOption &amp;)*cpp_arg_2));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::boundingRect(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setClipRect
- *    flags:    
+/*!
+ * method setClipRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;s0
+ * @param	 Qt::ClipOperation op = Qt::ReplaceClips1
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;
+ * @param	 Qt::ClipOperation op = Qt::ReplaceClip
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 Qt::ClipOperation op = Qt::ReplaceClip
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setClipRect){
-		/* ol public*/
 
-		/* const QRectF&amp; , int op,  */
+ZEND_METHOD(QPainter, setClipRect)
+{
+  ///const QRectF &amp;s0, Qt::ClipOperation op = Qt::ReplaceClips1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setClipRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;s0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setClipRect((const QRectF &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot;) {
-				obj-&gt;setClipRect((const QRectF&amp;) obj_z_0, (Qt::ClipOperation) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* lllll public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setClipRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;s0, Qt::ClipOperation op = Qt::ReplaceClips1,
+        QPainter *
+          selfpointer;
 
-		/* int x, int y, int w, int h, int op,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 5){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer-&gt;setClipRect((const QRectF &amp;)*cpp_arg_0, (Qt::ClipOperation) Z_LVAL_P(arg_1)));
+      }
+#endif
 
+    }
+  }
+  ///const QRect &amp;, Qt::ClipOperation op = Qt::ReplaceClip
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setClipRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;,
+        QPainter *
+          selfpointer;
 
-			obj-&gt;setClipRect((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3) ,(Qt::ClipOperation) Z_LVAL_P(z_4));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setClipRect((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setClipRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;, Qt::ClipOperation op = Qt::ReplaceClip,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setClipRect((const QRect &amp;)*cpp_arg_0, (Qt::ClipOperation) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///int x, int y, int w, int h, Qt::ClipOperation op = Qt::ReplaceClip
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setClipRect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setClipRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp; Z_TYPE_P(arg_4) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setClipRect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h, Qt::ClipOperation op = Qt::ReplaceClip,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;
+                  setClipRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (Qt::ClipOperation) Z_LVAL_P(arg_4)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setClipRect(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawImage
- *    flags:    
+/*!
+ * method drawImage
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;targetRects0
+ * @param	 const QImage &amp;images1
+ * @param	 const QRectF &amp;sourceRects2
+ * @param	 Qt::ImageConversionFlags flags = Qt::AutoColors3
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;targetRect
+ * @param	 const QImage &amp;image
+ * @param	 const QRect &amp;sourceRect
+ * @param	 Qt::ImageConversionFlags flags = Qt::AutoColor
+ * 
+ * overloaded args:
+ * @param	const QPointF &amp;p
+ * @param	 const QImage &amp;image
+ * @param	 const QRectF &amp;sr
+ * @param	 Qt::ImageConversionFlags flags = Qt::AutoColor
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;p
+ * @param	 const QImage &amp;image
+ * @param	 const QRect &amp;sr
+ * @param	 Qt::ImageConversionFlags flags = Qt::AutoColor
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;r
+ * @param	 const QImage &amp;image
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;r
+ * @param	 const QImage &amp;image
+ * 
+ * overloaded args:
+ * @param	const QPointF &amp;p
+ * @param	 const QImage &amp;image
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;p
+ * @param	 const QImage &amp;image
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 const QImage &amp;image
+ * @param	 int sx = 0
+ * @param	 int sy = 0
+ * @param	 int sw = -1
+ * @param	 int sh = -1
+ * @param	 Qt::ImageConversionFlags flags = Qt::AutoColor
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawImage){
-NOT_YET_IMPLEMENTED
-		/* oo public*/
 
-		/* const QRectF&amp; r, const QImage&amp; image,  */
-		/* lo public*/
+ZEND_METHOD(QPainter, drawImage)
+{
+  ///const QRectF &amp;targetRects0, const QImage &amp;images1, const QRectF &amp;sourceRects2, Qt::ImageConversionFlags flags = Qt::AutoColors3
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;targetRects0, const QImage &amp;images1, const QRectF &amp;sourceRects2,
+        QPainter *
+          selfpointer;
 
-		/* const QPointF&amp; p, const QImage&amp; image,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_1));
+        QRectF *
+          cpp_arg_2 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_2));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        RETURN_VOID(selfpointer-&gt;drawImage((const QRectF &amp;)*cpp_arg_0, (const QImage &amp;)*cpp_arg_1, (const QRectF &amp;)*cpp_arg_2));
+      }
+#endif
 
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot; &amp;&amp; obj_z_1-&gt;inherits(&quot;QImage&quot;)) {
-				obj-&gt;drawImage((const QRectF&amp;) obj_z_0, (const QImage&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+#endif
 
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;targetRects0, const QImage &amp;images1, const QRectF &amp;sourceRects2, Qt::ImageConversionFlags flags = Qt::AutoColors3,
+        QPainter *
+          selfpointer;
 
-			if(obj_z_1-&gt;inherits(&quot;QImage&quot;)) {
-				obj-&gt;drawImage((const QPointF&amp;) Z_LVAL_P(z_0), (const QImage&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* looo public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_1));
+        QRectF *
+          cpp_arg_2 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_2));
 
-		/* const QPointF&amp; p, const QImage&amp; image, const QRectF&amp; sr, Qt::ImageConversionFlags flags,  */
-		/* oooo public*/
+        RETURN_VOID(selfpointer-&gt;
+                    drawImage((const QRectF &amp;)*cpp_arg_0, (const QImage &amp;)*cpp_arg_1, (const QRectF &amp;)*cpp_arg_2, (Qt::ImageConversionFlags) Z_LVAL_P(arg_3)));
+      }
+#endif
 
-		/* const QRectF&amp; targetRect, const QImage&amp; image, const QRectF&amp; sourceRect, Qt::ImageConversionFlags flags,  */
+#endif
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_3) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
-			QObject* obj_z_3 = (QObject*) php_qt_fetch(z_3);
+#endif
 
+    }
+  }
+  ///const QRect &amp;targetRect, const QImage &amp;image, const QRect &amp;sourceRect, Qt::ImageConversionFlags flags = Qt::AutoColor
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;targetRect, const QImage &amp;image, const QRect &amp;sourceRect,
+        QPainter *
+          selfpointer;
 
-			if(obj_z_1-&gt;inherits(&quot;QImage&quot;) &amp;&amp; Z_OBJCE_P(z_2)-&gt;name == &quot;QRectF&quot; &amp;&amp; obj_z_3-&gt;inherits(&quot;Qt::ImageConversionFlags&quot;)) {
-//				obj-&gt;drawImage((const QPointF&amp;) Z_LVAL_P(z_0), (const QImage&amp;) obj_z_1, (const QRectF&amp;) obj_z_2, (Qt::ImageConversionFlags) obj_z_3);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_3) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
-			QObject* obj_z_3 = (QObject*) php_qt_fetch(z_3);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_1));
+        QRect *
+          cpp_arg_2 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer-&gt;drawImage((const QRect &amp;)*cpp_arg_0, (const QImage &amp;)*cpp_arg_1, (const QRect &amp;)*cpp_arg_2));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot; &amp;&amp; obj_z_1-&gt;inherits(&quot;QImage&quot;) &amp;&amp; Z_OBJCE_P(z_2)-&gt;name == &quot;QRectF&quot; &amp;&amp; obj_z_3-&gt;inherits(&quot;Qt::ImageConversionFlags&quot;)) {
-//				obj-&gt;drawImage((const QRectF&amp;) obj_z_0, (const QImage&amp;) obj_z_1, (const QRectF&amp;) obj_z_2, (Qt::ImageConversionFlags) obj_z_3);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llollllo public*/
+#endif
 
-		/* int x, int y, const QImage&amp; image, int sx, int sy, int sw, int sh, Qt::ImageConversionFlags flags,  */
+#endif
 
-	if (ZEND_NUM_ARGS() == 8){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		zval *z_6; // define ZVAL
-		zval *z_7; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4, &amp;z_5, &amp;z_6, &amp;z_7) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_LONG &amp;&amp; Z_TYPE_P(z_5) == IS_LONG &amp;&amp; Z_TYPE_P(z_6) == IS_LONG &amp;&amp; Z_TYPE_P(z_7) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
-			QObject* obj_z_7 = (QObject*) php_qt_fetch(z_7);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;targetRect, const QImage &amp;image, const QRect &amp;sourceRect, Qt::ImageConversionFlags flags = Qt::AutoColor,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_1));
+        QRect *
+          cpp_arg_2 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_2));
 
-			if(obj_z_2-&gt;inherits(&quot;QImage&quot;) &amp;&amp; obj_z_7-&gt;inherits(&quot;Qt::ImageConversionFlags&quot;)) {
-//				obj-&gt;drawImage((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QImage&amp;) obj_z_2, (int) Z_LVAL_P(z_3), (int) Z_LVAL_P(z_4), (int) Z_LVAL_P(z_5), (int) Z_LVAL_P(z_6), (Qt::ImageConversionFlags) obj_z_7);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+        RETURN_VOID(selfpointer-&gt;
+                    drawImage((const QRect &amp;)*cpp_arg_0, (const QImage &amp;)*cpp_arg_1, (const QRect &amp;)*cpp_arg_2, (Qt::ImageConversionFlags) Z_LVAL_P(arg_3)));
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+  ///const QPointF &amp;p, const QImage &amp;image, const QRectF &amp;sr, Qt::ImageConversionFlags flags = Qt::AutoColor
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF &amp;p, const QImage &amp;image, const QRectF &amp;sr,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_1));
+        QRectF *
+          cpp_arg_2 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;drawImage((const QPointF &amp;)*cpp_arg_0, (const QImage &amp;)*cpp_arg_1, (const QRectF &amp;)*cpp_arg_2));
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF &amp;p, const QImage &amp;image, const QRectF &amp;sr, Qt::ImageConversionFlags flags = Qt::AutoColor,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_1));
+        QRectF *
+          cpp_arg_2 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;
+                    drawImage((const QPointF &amp;)*cpp_arg_0, (const QImage &amp;)*cpp_arg_1, (const QRectF &amp;)*cpp_arg_2, (Qt::ImageConversionFlags) Z_LVAL_P(arg_3)));
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+  ///const QPoint &amp;p, const QImage &amp;image, const QRect &amp;sr, Qt::ImageConversionFlags flags = Qt::AutoColor
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;p, const QImage &amp;image, const QRect &amp;sr,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_1));
+        QRect *
+          cpp_arg_2 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;drawImage((const QPoint &amp;)*cpp_arg_0, (const QImage &amp;)*cpp_arg_1, (const QRect &amp;)*cpp_arg_2));
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QImage
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;p, const QImage &amp;image, const QRect &amp;sr, Qt::ImageConversionFlags flags = Qt::AutoColor,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_1));
+        QRect *
+          cpp_arg_2 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;
+                    drawImage((const QPoint &amp;)*cpp_arg_0, (const QImage &amp;)*cpp_arg_1, (const QRect &amp;)*cpp_arg_2, (Qt::ImageConversionFlags) Z_LVAL_P(arg_3)));
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+  ///const QRectF &amp;r, const QImage &amp;image
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;r, const QImage &amp;image,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;drawImage((const QRectF &amp;)*cpp_arg_0, (const QImage &amp;)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QRect &amp;r, const QImage &amp;image
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;r, const QImage &amp;image,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;drawImage((const QRect &amp;)*cpp_arg_0, (const QImage &amp;)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QPointF &amp;p, const QImage &amp;image
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF &amp;p, const QImage &amp;image,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;drawImage((const QPointF &amp;)*cpp_arg_0, (const QImage &amp;)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QPoint &amp;p, const QImage &amp;image
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;p, const QImage &amp;image,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QImage *
+          cpp_arg_1 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;drawImage((const QPoint &amp;)*cpp_arg_0, (const QImage &amp;)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///int x, int y, const QImage &amp;image, int sx = 0, int sy = 0, int sw = -1, int sh = -1, Qt::ImageConversionFlags flags = Qt::AutoColor
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QImage &amp;image,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QImage *
+          cpp_arg_2 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &amp;)*cpp_arg_2));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QImage &amp;image, int sx = 0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QImage *
+          cpp_arg_2 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &amp;)*cpp_arg_2, (int)Z_LVAL_P(arg_3)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QImage &amp;image, int sx = 0, int sy = 0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QImage *
+          cpp_arg_2 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &amp;)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG) {
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QImage &amp;image, int sx = 0, int sy = 0, int sw = -1,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QImage *
+          cpp_arg_2 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;
+                    drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &amp;)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                              (int)Z_LVAL_P(arg_5)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 7) {
+    PHP_QT_FETCH_7_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG &amp;&amp; Z_TYPE_P(arg_6) == IS_LONG) {
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QImage &amp;image, int sx = 0, int sy = 0, int sw = -1, int sh = -1,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QImage *
+          cpp_arg_2 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;
+                    drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &amp;)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                              (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 8) {
+    PHP_QT_FETCH_8_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG &amp;&amp; Z_TYPE_P(arg_6) == IS_LONG &amp;&amp; Z_TYPE_P(arg_7) == IS_LONG) {
+#ifdef PHP_QT_QImage
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawImage' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QImage &amp;image, int sx = 0, int sy = 0, int sw = -1, int sh = -1, Qt::ImageConversionFlags flags = Qt::AutoColor,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QImage *
+          cpp_arg_2 = static_cast &lt; QImage * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;
+                    drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &amp;)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                              (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6), (Qt::ImageConversionFlags) Z_LVAL_P(arg_7)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawImage(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawTiledPixmap
- *    flags:    
+/*!
+ * method drawTiledPixmap
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;rects0
+ * @param	 const QPixmap &amp;pms1
+ * @param	 const QPointF &amp;offset = QPointF()s2
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 const QPixmap &amp;
+ * @param	 int sx=0
+ * @param	 int sy=0
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;
+ * @param	 const QPixmap &amp;
+ * @param	 const QPoint &amp; = QPoint()
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawTiledPixmap){
-		/* ool public*/
 
-		/* const QRectF&amp; rect, const QPixmap&amp; pm, const QPointF&amp; offset,  */
+ZEND_METHOD(QPainter, drawTiledPixmap)
+{
+  ///const QRectF &amp;rects0, const QPixmap &amp;pms1, const QPointF &amp;offset = QPointF()s2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawTiledPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rects0, const QPixmap &amp;pms1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer-&gt;drawTiledPixmap((const QRectF &amp;)*cpp_arg_0, (const QPixmap &amp;)*cpp_arg_1));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot; &amp;&amp; obj_z_1-&gt;inherits(&quot;QPixmap&quot;)) {
-				obj-&gt;drawTiledPixmap((const QRectF&amp;) obj_z_0, (const QPixmap&amp;) obj_z_1, (const QPointF&amp;) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot; &amp;&amp; obj_z_1-&gt;inherits(&quot;QPixmap&quot;)) {
-				obj-&gt;drawTiledPixmap((const QRect&amp;) obj_z_0, (const QPixmap&amp;) obj_z_1, (const QPoint&amp;) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* lllloll public*/
+#endif
 
-		/* int x, int y, int w, int h, const QPixmap&amp; , int sx, int sy,  */
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawTiledPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rects0, const QPixmap &amp;pms1, const QPointF &amp;offset = QPointF()s2,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 7){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		zval *z_6; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4, &amp;z_5, &amp;z_6) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_5) == IS_LONG &amp;&amp; Z_TYPE_P(z_6) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_4 = (QObject*) php_qt_fetch(z_4);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_1));
+        QPointF *
+          cpp_arg_2 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer-&gt;drawTiledPixmap((const QRectF &amp;)*cpp_arg_0, (const QPixmap &amp;)*cpp_arg_1, (const QPointF &amp;)*cpp_arg_2));
+      }
+#endif
 
-			if(obj_z_4-&gt;inherits(&quot;QPixmap&quot;)) {
-				obj-&gt;drawTiledPixmap((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (const QPixmap&amp;) obj_z_4, (int) Z_LVAL_P(z_5), (int) Z_LVAL_P(z_6));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+#endif
+
+    }
+  }
+  ///int x, int y, int w, int h, const QPixmap &amp;, int sx=0, int sy=0
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_OBJECT) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_4), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawTiledPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, const QPixmap &amp;,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_4 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_4));
+
+        RETURN_VOID(selfpointer-&gt;
+                    drawTiledPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &amp;)*cpp_arg_4));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_4), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawTiledPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, const QPixmap &amp;, int sx=0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_4 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_4));
+
+        RETURN_VOID(selfpointer-&gt;
+                    drawTiledPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &amp;)*cpp_arg_4,
+                                    (int)Z_LVAL_P(arg_5)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 7) {
+    PHP_QT_FETCH_7_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG &amp;&amp; Z_TYPE_P(arg_6) == IS_LONG) {
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_4), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawTiledPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, const QPixmap &amp;, int sx=0, int sy=0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPixmap *
+          cpp_arg_4 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_4));
+
+        RETURN_VOID(selfpointer-&gt;
+                    drawTiledPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &amp;)*cpp_arg_4,
+                                    (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6)));
+      }
+#endif
+
+    }
+  }
+  ///const QRect &amp;, const QPixmap &amp;, const QPoint &amp; = QPoint()
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawTiledPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;, const QPixmap &amp;,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;drawTiledPixmap((const QRect &amp;)*cpp_arg_0, (const QPixmap &amp;)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QPixmap
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawTiledPixmap' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;, const QPixmap &amp;, const QPoint &amp; = QPoint(),
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+        QPixmap *
+          cpp_arg_1 = static_cast &lt; QPixmap * &gt;(php_qt_fetch(arg_1));
+        QPoint *
+          cpp_arg_2 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;drawTiledPixmap((const QRect &amp;)*cpp_arg_0, (const QPixmap &amp;)*cpp_arg_1, (const QPoint &amp;)*cpp_arg_2));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawTiledPixmap(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  layoutDirection
- *    flags:    c
+/*!
+ * method layoutDirection
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::LayoutDirection
+ * @flags	c
  */
-ZEND_METHOD(QPainter, layoutDirection){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;layoutDirection());
-	}
+
+ZEND_METHOD(QPainter, layoutDirection)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'layoutDirection' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;layoutDirection());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::layoutDirection(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  background
- *    flags:    c
+/*!
+ * method background
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QBrush &amp;
+ * @flags	c
  */
-ZEND_METHOD(QPainter, background){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				const QBrush &amp; return_object = (const QBrush &amp;) obj-&gt;background();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, background)
+{
+  ///
+#ifdef PHP_QT_QBrush            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'background' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &amp;const_cast &lt; QBrush &amp; &gt;(selfpointer-&gt;background());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::background(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPolygon
- *    flags:    
+/*!
+ * method drawPolygon
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF *pointss0
+ * @param	 int pointCounts1
+ * @param	 Qt::FillRule fillRule = Qt::OddEvenFills2
+ * 
+ * overloaded args:
+ * @param	const QPolygonF &amp;polygon
+ * @param	 Qt::FillRule fillRule = Qt::OddEvenFill
+ * 
+ * overloaded args:
+ * @param	const QPoint *points
+ * @param	 int pointCount
+ * @param	 Qt::FillRule fillRule = Qt::OddEvenFill
+ * 
+ * overloaded args:
+ * @param	const QPolygon &amp;polygon
+ * @param	 Qt::FillRule fillRule = Qt::OddEvenFill
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPolygon){
-		/* ol public*/
 
-		/* const QPolygonF&amp; polygon, int fillRule,  */
+ZEND_METHOD(QPainter, drawPolygon)
+{
+  ///const QPointF *pointss0, int pointCounts1, Qt::FillRule fillRule = Qt::OddEvenFills2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPolygon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF *pointss0, int pointCounts1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawPolygon((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QPolygonF&quot;) {
-				obj-&gt;drawPolygon((const QPolygonF&amp;) obj_z_0, (Qt::FillRule) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QPolygon&quot;) {
-				obj-&gt;drawPolygon((const QPolygon&amp;) obj_z_0, (Qt::FillRule) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* lll public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPolygon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF *pointss0, int pointCounts1, Qt::FillRule fillRule = Qt::OddEvenFills2,
+        QPainter *
+          selfpointer;
 
-		/* const QPointF* points, int pointCount, int fillRule,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer-&gt;drawPolygon((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::FillRule) Z_LVAL_P(arg_2)));
+      }
+#endif
 
+    }
+  }
+  ///const QPolygonF &amp;polygon, Qt::FillRule fillRule = Qt::OddEvenFill
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygonF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPolygon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPolygonF &amp;polygon,
+        QPainter *
+          selfpointer;
 
-			obj-&gt;drawPolygon((const QPointF*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(Qt::FillRule) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPolygonF *
+          cpp_arg_0 = static_cast &lt; QPolygonF * &gt;(php_qt_fetch(arg_0));
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  device
- *    flags:    c
- */
-ZEND_METHOD(QPainter, device){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QPaintDevice * return_object = (QPaintDevice *) obj-&gt;device();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+        RETURN_VOID(selfpointer-&gt;drawPolygon((const QPolygonF &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPolygonF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPolygon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPolygonF &amp;polygon, Qt::FillRule fillRule = Qt::OddEvenFill,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPolygonF *
+          cpp_arg_0 = static_cast &lt; QPolygonF * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawPolygon((const QPolygonF &amp;)*cpp_arg_0, (Qt::FillRule) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QPoint *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPolygon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint *points, int pointCount,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawPolygon((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPolygon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawPolygon((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::FillRule) Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  ///const QPolygon &amp;polygon, Qt::FillRule fillRule = Qt::OddEvenFill
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPolygon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPolygon &amp;polygon,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPolygon *
+          cpp_arg_0 = static_cast &lt; QPolygon * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawPolygon((const QPolygon &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPolygon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPolygon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPolygon &amp;polygon, Qt::FillRule fillRule = Qt::OddEvenFill,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPolygon *
+          cpp_arg_0 = static_cast &lt; QPolygon * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawPolygon((const QPolygon &amp;)*cpp_arg_0, (Qt::FillRule) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawPolygon(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setClipRegion
- *    flags:    
+/*!
+ * method setClipRegion
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRegion &amp;s0
+ * @param	 Qt::ClipOperation op = Qt::ReplaceClips1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setClipRegion){
-		/* ol public*/
 
-		/* const QRegion&amp; , int op,  */
+ZEND_METHOD(QPainter, setClipRegion)
+{
+  ///const QRegion &amp;s0, Qt::ClipOperation op = Qt::ReplaceClips1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegion
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setClipRegion' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegion &amp;s0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRegion *
+          cpp_arg_0 = static_cast &lt; QRegion * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setClipRegion((const QRegion &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QRegion&quot;)) {
-				obj-&gt;setClipRegion((const QRegion&amp;) obj_z_0, (Qt::ClipOperation) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRegion
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setClipRegion' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegion &amp;s0, Qt::ClipOperation op = Qt::ReplaceClips1,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRegion *
+          cpp_arg_0 = static_cast &lt; QRegion * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setClipRegion((const QRegion &amp;)*cpp_arg_0, (Qt::ClipOperation) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setClipRegion(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  restoreRedirected
- *    flags:    s
+/*!
+ * method device
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPaintDevice *
+ * @flags	c
  */
-ZEND_METHOD(QPainter, restoreRedirected){
-		/* l public*/
 
-		/* const QPaintDevice* device,  */
+ZEND_METHOD(QPainter, device)
+{
+  ///
+#ifdef PHP_QT_QPaintDevice      // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'device' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj-&gt;restoreRedirected((const QPaintDevice*) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast &lt; QPaintDevice * &gt;(selfpointer-&gt;device());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::device(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setMatrixEnabled
- *    flags:    
+/*!
+ * method restoreRedirected
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPaintDevice *devices0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QPainter, setMatrixEnabled){
-		/* l public*/
 
-		/* int enabled,  */
+ZEND_METHOD(QPainter, restoreRedirected)
+{
+  ///const QPaintDevice *devices0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPaintDevice
+      if (inherits(Z_OBJCE_P(arg_0), 49)) {
+        /// try const QPaintDevice *devices0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPaintDevice *
+          cpp_arg_0 = static_cast &lt; QPaintDevice * &gt;(php_qt_fetch(arg_0));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QPainter::restoreRedirected((const QPaintDevice *)cpp_arg_0));
+        } else {
+          RETURN_VOID(selfpointer-&gt;restoreRedirected((const QPaintDevice *)cpp_arg_0));
+      }}
+#endif
 
-			obj-&gt;setMatrixEnabled((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::restoreRedirected(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPoints
- *    flags:    
+/*!
+ * method setMatrixEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enableds0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPoints){
-		/* o public*/
 
-		/* const QPolygonF&amp; points,  */
+ZEND_METHOD(QPainter, setMatrixEnabled)
+{
+  ///bool enableds0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMatrixEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool enableds0,
+      QPainter *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMatrixEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setMatrixEnabled(...) &quot;);
+}
 
+/*!
+ * method drawPoints
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF *pointss0
+ * @param	 int pointCounts1
+ * 
+ * overloaded args:
+ * @param	const QPolygonF &amp;points
+ * 
+ * overloaded args:
+ * @param	const QPoint *points
+ * @param	 int pointCount
+ * 
+ * overloaded args:
+ * @param	const QPolygon &amp;points
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QPolygonF&quot;) {
-				obj-&gt;drawPoints((const QPolygonF&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QPolygon&quot;) {
-				obj-&gt;drawPoints((const QPolygon&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ll public*/
+ZEND_METHOD(QPainter, drawPoints)
+{
+  ///const QPointF *pointss0, int pointCounts1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPoints' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF *pointss0, int pointCounts1,
+        QPainter *
+          selfpointer;
 
-		/* const QPointF* points, int pointCount,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer-&gt;drawPoints((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
+    }
+  }
+  ///const QPolygonF &amp;points
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygonF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPoints' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPolygonF &amp;points,
+        QPainter *
+          selfpointer;
 
-			obj-&gt;drawPoints((const QPointF*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPolygonF *
+          cpp_arg_0 = static_cast &lt; QPolygonF * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawPoints((const QPolygonF &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///const QPoint *points, int pointCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPoints' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint *points, int pointCount,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawPoints((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QPolygon &amp;points
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPoints' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPolygon &amp;points,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPolygon *
+          cpp_arg_0 = static_cast &lt; QPolygon * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawPoints((const QPolygon &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawPoints(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawRoundRect
- *    flags:    
+/*!
+ * method drawRoundRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;rs0
+ * @param	 int xround = 25s1
+ * @param	 int yround = 25s2
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 int = 25
+ * @param	 int = 25
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;r
+ * @param	 int xround = 25
+ * @param	 int yround = 25
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawRoundRect){
-		/* oll public*/
 
-		/* const QRectF&amp; r, int xround, int yround,  */
+ZEND_METHOD(QPainter, drawRoundRect)
+{
+  ///const QRectF &amp;rs0, int xround = 25s1, int yround = 25s2
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawRoundRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rs0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawRoundRect((const QRectF &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot;) {
-				obj-&gt;drawRoundRect((const QRectF&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot;) {
-				obj-&gt;drawRoundRect((const QRect&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllll public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawRoundRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rs0, int xround = 25s1,
+        QPainter *
+          selfpointer;
 
-		/* int x, int y, int w, int h, int , int ,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 6){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4, &amp;z_5) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_LONG &amp;&amp; Z_TYPE_P(z_5) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer-&gt;drawRoundRect((const QRectF &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawRoundRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rs0, int xround = 25s1, int yround = 25s2,
+        QPainter *
+          selfpointer;
 
-			obj-&gt;drawRoundRect((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3) ,(int) Z_LVAL_P(z_4) ,(int) Z_LVAL_P(z_5));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawRoundRect((const QRectF &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  ///int x, int y, int w, int h, int = 25, int = 25
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'drawRoundRect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;drawRoundRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp; Z_TYPE_P(arg_4) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'drawRoundRect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h, int = 25,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;drawRoundRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp; Z_TYPE_P(arg_4) == IS_LONG
+        &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'drawRoundRect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h, int = 25, int = 25,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;
+                  drawRoundRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                                (int)Z_LVAL_P(arg_5)));
+    }
+  }
+  ///const QRect &amp;r, int xround = 25, int yround = 25
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawRoundRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;r,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawRoundRect((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawRoundRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;r, int xround = 25,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawRoundRect((const QRect &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawRoundRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;r, int xround = 25, int yround = 25,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawRoundRect((const QRect &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawRoundRect(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawConvexPolygon
- *    flags:    
+/*!
+ * method drawConvexPolygon
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF *pointss0
+ * @param	 int pointCounts1
+ * 
+ * overloaded args:
+ * @param	const QPolygonF &amp;polygon
+ * 
+ * overloaded args:
+ * @param	const QPoint *points
+ * @param	 int pointCount
+ * 
+ * overloaded args:
+ * @param	const QPolygon &amp;polygon
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawConvexPolygon){
-		/* o public*/
 
-		/* const QPolygonF&amp; polygon,  */
+ZEND_METHOD(QPainter, drawConvexPolygon)
+{
+  ///const QPointF *pointss0, int pointCounts1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawConvexPolygon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF *pointss0, int pointCounts1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawConvexPolygon((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QPolygonF&quot;) {
-				obj-&gt;drawConvexPolygon((const QPolygonF&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QPolygon&quot;) {
-				obj-&gt;drawConvexPolygon((const QPolygon&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ll public*/
+    }
+  }
+  ///const QPolygonF &amp;polygon
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygonF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawConvexPolygon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPolygonF &amp;polygon,
+        QPainter *
+          selfpointer;
 
-		/* const QPointF* points, int pointCount,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPolygonF *
+          cpp_arg_0 = static_cast &lt; QPolygonF * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer-&gt;drawConvexPolygon((const QPolygonF &amp;)*cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///const QPoint *points, int pointCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawConvexPolygon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint *points, int pointCount,
+        QPainter *
+          selfpointer;
 
-			obj-&gt;drawConvexPolygon((const QPointF*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawConvexPolygon((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QPolygon &amp;polygon
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPolygon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawConvexPolygon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPolygon &amp;polygon,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPolygon *
+          cpp_arg_0 = static_cast &lt; QPolygon * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawConvexPolygon((const QPolygon &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawConvexPolygon(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setMatrix
- *    flags:    
+/*!
+ * method drawPicture
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF &amp;ps0
+ * @param	 const QPicture &amp;pictures1
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 const QPicture &amp;picture
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;p
+ * @param	 const QPicture &amp;picture
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setMatrix){
-		/* ol public*/
 
-		/* const QMatrix&amp; matrix, int combine,  */
+ZEND_METHOD(QPainter, drawPicture)
+{
+  ///const QPointF &amp;ps0, const QPicture &amp;pictures1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QPicture
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPicture' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF &amp;ps0, const QPicture &amp;pictures1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
+        QPicture *
+          cpp_arg_1 = static_cast &lt; QPicture * &gt;(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer-&gt;drawPicture((const QPointF &amp;)*cpp_arg_0, (const QPicture &amp;)*cpp_arg_1));
+      }
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QMatrix&quot;)) {
-				obj-&gt;setMatrix((const QMatrix&amp;) obj_z_0, (bool) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+#endif
+
+    }
+  }
+  ///int x, int y, const QPicture &amp;picture
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPicture
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPicture' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QPicture &amp;picture,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPicture *
+          cpp_arg_2 = static_cast &lt; QPicture * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;drawPicture((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QPicture &amp;)*cpp_arg_2));
+      }
+#endif
+
+    }
+  }
+  ///const QPoint &amp;p, const QPicture &amp;picture
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPicture
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPicture' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;p, const QPicture &amp;picture,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QPicture *
+          cpp_arg_1 = static_cast &lt; QPicture * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;drawPicture((const QPoint &amp;)*cpp_arg_0, (const QPicture &amp;)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawPicture(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPicture
- *    flags:    
+/*!
+ * method setMatrix
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QMatrix &amp;matrixs0
+ * @param	 bool combine = falses1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPicture){
-		/* lo public*/
 
-		/* const QPointF&amp; p, const QPicture&amp; picture,  */
+ZEND_METHOD(QPainter, setMatrix)
+{
+  ///const QMatrix &amp;matrixs0, bool combine = falses1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QMatrix
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setMatrix' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QMatrix &amp;matrixs0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QMatrix *
+          cpp_arg_0 = static_cast &lt; QMatrix * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setMatrix((const QMatrix &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_1-&gt;inherits(&quot;QPicture&quot;)) {
-				obj-&gt;drawPicture((const QPointF&amp;) Z_LVAL_P(z_0), (const QPicture&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			if(obj_z_1-&gt;inherits(&quot;QPicture&quot;)) {
-				obj-&gt;drawPicture((const QPoint&amp;) Z_LVAL_P(z_0), (const QPicture&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llo public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_BOOL) {
+#ifdef PHP_QT_QMatrix
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setMatrix' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QMatrix &amp;matrixs0, bool combine = falses1,
+        QPainter *
+          selfpointer;
 
-		/* int x, int y, const QPicture&amp; picture,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QMatrix *
+          cpp_arg_0 = static_cast &lt; QMatrix * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        RETURN_VOID(selfpointer-&gt;setMatrix((const QMatrix &amp;)*cpp_arg_0, (bool) Z_LVAL_P(arg_1)));
+      }
+#endif
 
-
-			if(obj_z_2-&gt;inherits(&quot;QPicture&quot;)) {
-				obj-&gt;drawPicture((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QPicture&amp;) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setMatrix(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  restore
- *    flags:    
+/*!
+ * method restore
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, restore){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			obj-&gt;restore();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QPainter, restore)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'restore' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;restore());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::restore(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  font
- *    flags:    c
+/*!
+ * method matrix
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QMatrix &amp;
+ * @flags	c
  */
-ZEND_METHOD(QPainter, font){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				const QFont &amp; return_object = (const QFont &amp;) obj-&gt;font();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, matrix)
+{
+  ///
+#ifdef PHP_QT_QMatrix           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'matrix' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &amp;const_cast &lt; QMatrix &amp; &gt;(selfpointer-&gt;matrix());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::matrix(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  matrix
- *    flags:    c
+/*!
+ * method font
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QFont &amp;
+ * @flags	c
  */
-ZEND_METHOD(QPainter, matrix){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				const QMatrix &amp; return_object = (const QMatrix &amp;) obj-&gt;matrix();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, font)
+{
+  ///
+#ifdef PHP_QT_QFont             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'font' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &amp;const_cast &lt; QFont &amp; &gt;(selfpointer-&gt;font());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::font(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  viewport
- *    flags:    c
+/*!
+ * method viewport
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-ZEND_METHOD(QPainter, viewport){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QRect return_object = (QRect) obj-&gt;viewport();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, viewport)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'viewport' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;viewport());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::viewport(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  viewTransformEnabled
- *    flags:    c
+/*!
+ * method viewTransformEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QPainter, viewTransformEnabled){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;viewTransformEnabled());
-	}
+
+ZEND_METHOD(QPainter, viewTransformEnabled)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'viewTransformEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;viewTransformEnabled());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::viewTransformEnabled(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawText
- *    flags:    
+/*!
+ * method drawText
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF &amp;ps0
+ * @param	 const QString &amp;ss1
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;p
+ * @param	 const QString &amp;s
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 const QString &amp;s
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;r
+ * @param	 int flags
+ * @param	 const QString &amp;text
+ * @param	 QRectF *br=0
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;r
+ * @param	 int flags
+ * @param	 const QString &amp;text
+ * @param	 QRect *br=0
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 int flags
+ * @param	 const QString &amp;text
+ * @param	 QRect *br=0
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;r
+ * @param	 const QString &amp;text
+ * @param	 const QTextOption &amp;o = QTextOption()
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawText){
-		/* lo public*/
 
-		/* const QPointF&amp; p, const QString&amp; s,  */
+ZEND_METHOD(QPainter, drawText)
+{
+  ///const QPointF &amp;ps0, const QString &amp;ss1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF &amp;ps0, const QString &amp;ss1,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
 
-			if(Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot;) {
-				obj-&gt;drawText((const QPointF&amp;) Z_LVAL_P(z_0), (const QString&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ooo public*/
+        RETURN_VOID(selfpointer-&gt;drawText((const QPointF &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+      }
+#endif
 
-		/* const QRectF&amp; r, const QString&amp; text, const QTextOption&amp; o,  */
-		/* llo public*/
+#endif
 
-		/* int x, int y, const QString&amp; s,  */
+    }
+  }
+  ///const QPoint &amp;p, const QString &amp;s
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;p, const QString &amp;s,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot; &amp;&amp; obj_z_2-&gt;inherits(&quot;QTextOption&quot;)) {
-				obj-&gt;drawText((const QRectF&amp;) obj_z_0, (const QString&amp;) obj_z_1, (const QTextOption&amp;) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        RETURN_VOID(selfpointer-&gt;drawText((const QPoint &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+      }
+#endif
 
+#endif
 
-			if(Z_OBJCE_P(z_2)-&gt;name == &quot;QString&quot;) {
-				obj-&gt;drawText((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QString&amp;) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* oloo public*/
+    }
+  }
+  ///int x, int y, const QString &amp;s
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
 
-		/* const QRectF&amp; r, int flags, const QString&amp; text, QRectF* br,  */
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QString &amp;s,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_3) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
-			QObject* obj_z_3 = (QObject*) php_qt_fetch(z_3);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_2 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer-&gt;drawText((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QString &amp;)*cpp_arg_2));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot; &amp;&amp; Z_OBJCE_P(z_2)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_3)-&gt;name == &quot;QRectF&quot;) {
-				obj-&gt;drawText((const QRectF&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (const QString&amp;) obj_z_2, (QRectF*) obj_z_3);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllloo public*/
+    }
+  }
+  ///const QRectF &amp;r, int flags, const QString &amp;text, QRectF *br=0
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
 
-		/* int x, int y, int w, int h, int flags, const QString&amp; text, qt_QRect* br,  */
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;r, int flags, const QString &amp;text,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 7){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		zval *z_6; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4, &amp;z_5, &amp;z_6) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_LONG &amp;&amp; Z_TYPE_P(z_5) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_6) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_5 = (QObject*) php_qt_fetch(z_5);
-			QObject* obj_z_6 = (QObject*) php_qt_fetch(z_6);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_2 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer-&gt;drawText((const QRectF &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &amp;)*cpp_arg_2));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_5)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_6)-&gt;name == &quot;QRect&quot;) {
-				obj-&gt;drawText((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (int) Z_LVAL_P(z_4), (const QString&amp;) obj_z_5, (QRect*) obj_z_6);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    arg_2 = invokeToQString(arg_2);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;r, int flags, const QString &amp;text, QRectF *br=0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_2 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_2));
+        QRectF *
+          cpp_arg_3 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_3));
+
+        RETURN_VOID(selfpointer-&gt;drawText((const QRectF &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &amp;)*cpp_arg_2, (QRectF *) cpp_arg_3));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QRect &amp;r, int flags, const QString &amp;text, QRect *br=0
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;r, int flags, const QString &amp;text,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_2 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;drawText((const QRect &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &amp;)*cpp_arg_2));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    arg_2 = invokeToQString(arg_2);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;r, int flags, const QString &amp;text, QRect *br=0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_2 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_2));
+        QRect *
+          cpp_arg_3 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_3));
+
+        RETURN_VOID(selfpointer-&gt;drawText((const QRect &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &amp;)*cpp_arg_2, (QRect *) cpp_arg_3));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///int x, int y, int w, int h, int flags, const QString &amp;text, QRect *br=0
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    arg_5 = invokeToQString(arg_5);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp; Z_TYPE_P(arg_4) == IS_LONG
+        &amp;&amp; Z_TYPE_P(arg_5) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_5), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, int flags, const QString &amp;text,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_5 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_5));
+
+        RETURN_VOID(selfpointer-&gt;
+                    drawText((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                             (const QString &amp;)*cpp_arg_5));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 7) {
+    PHP_QT_FETCH_7_ARGS();
+    arg_5 = invokeToQString(arg_5);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp; Z_TYPE_P(arg_4) == IS_LONG
+        &amp;&amp; Z_TYPE_P(arg_5) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_6) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_5), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, int w, int h, int flags, const QString &amp;text, QRect *br=0,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_5 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_5));
+        QRect *
+          cpp_arg_6 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_6));
+
+        RETURN_VOID(selfpointer-&gt;
+                    drawText((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                             (const QString &amp;)*cpp_arg_5, (QRect *) cpp_arg_6));
+      }
+#endif
+
+    }
+  }
+  ///const QRectF &amp;r, const QString &amp;text, const QTextOption &amp;o = QTextOption()
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;r, const QString &amp;text,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+
+        RETURN_VOID(selfpointer-&gt;drawText((const QRectF &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_1 = invokeToQString(arg_1);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;r, const QString &amp;text, const QTextOption &amp;o = QTextOption(),
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+        QString *
+          cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        QTextOption *
+          cpp_arg_2 = static_cast &lt; QTextOption * &gt;(php_qt_fetch(arg_2));
+
+        RETURN_VOID(selfpointer-&gt;drawText((const QRectF &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1, (const QTextOption &amp;)*cpp_arg_2));
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawText(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawChord
- *    flags:    
+/*!
+ * method drawChord
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;rects0
+ * @param	 int as1
+ * @param	 int alens2
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 int a
+ * @param	 int alen
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;
+ * @param	 int a
+ * @param	 int alen
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawChord){
-		/* oll public*/
 
-		/* const QRectF&amp; rect, int a, int alen,  */
+ZEND_METHOD(QPainter, drawChord)
+{
+  ///const QRectF &amp;rects0, int as1, int alens2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawChord' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rects0, int as1, int alens2,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawChord((const QRectF &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot;) {
-				obj-&gt;drawChord((const QRectF&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot;) {
-				obj-&gt;drawChord((const QRect&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllll public*/
+    }
+  }
+  ///int x, int y, int w, int h, int a, int alen
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp; Z_TYPE_P(arg_4) == IS_LONG
+        &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'drawChord' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h, int a, int alen,
+      QPainter *
+        selfpointer;
 
-		/* int x, int y, int w, int h, int a, int alen,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;
+                  drawChord((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
+                            (int)Z_LVAL_P(arg_5)));
+    }
+  }
+  ///const QRect &amp;, int a, int alen
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawChord' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;, int a, int alen,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 6){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4, &amp;z_5) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_LONG &amp;&amp; Z_TYPE_P(z_5) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawChord((const QRect &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-			obj-&gt;drawChord((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3) ,(int) Z_LVAL_P(z_4) ,(int) Z_LVAL_P(z_5));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawChord(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  clipRegion
- *    flags:    c
+/*!
+ * method clipRegion
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRegion
+ * @flags	c
  */
-ZEND_METHOD(QPainter, clipRegion){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QRegion return_object = (QRegion) obj-&gt;clipRegion();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, clipRegion)
+{
+  ///
+#ifdef PHP_QT_QRegion           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'clipRegion' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRegion *
+        return_object = new QRegion;
+
+      *return_object = static_cast &lt; QRegion &gt; (selfpointer-&gt;clipRegion());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::clipRegion(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  end
- *    flags:    
+/*!
+ * method brushOrigin
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
-ZEND_METHOD(QPainter, end){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;end());
-	}
+
+ZEND_METHOD(QPainter, brushOrigin)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'brushOrigin' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QPoint *
+        return_object = new QPoint;
+
+      *return_object = static_cast &lt; QPoint &gt; (selfpointer-&gt;brushOrigin());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::brushOrigin(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  brushOrigin
- *    flags:    c
+/*!
+ * method end
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QPainter, brushOrigin){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QPoint return_object = (QPoint) obj-&gt;brushOrigin();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, end)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'end' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;end());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::end(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setViewTransformEnabled
- *    flags:    
+/*!
+ * method setViewTransformEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enables0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setViewTransformEnabled){
-		/* l public*/
 
-		/* int enable,  */
+ZEND_METHOD(QPainter, setViewTransformEnabled)
+{
+  ///bool enables0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setViewTransformEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool enables0,
+      QPainter *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setViewTransformEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setViewTransformEnabled(...) &quot;);
+}
 
+/*!
+ * method scale
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	qreal sxs0
+ * @param	 qreal sys1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			obj-&gt;setViewTransformEnabled((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+ZEND_METHOD(QPainter, scale)
+{
+// notice: unknown argument qreal sxs0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::scale(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  scale
- *    flags:    
+/*!
+ * method setPen
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QColor &amp;colors0
+ * 
+ * overloaded args:
+ * @param	const QPen &amp;pen
+ * 
+ * overloaded args:
+ * @param	Qt::PenStyle style
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, scale){
-		/* ll public*/
 
-		/* double sx, double sy,  */
+ZEND_METHOD(QPainter, setPen)
+{
+  ///const QColor &amp;colors0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QColor
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setPen' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QColor &amp;colors0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QColor *
+          cpp_arg_0 = static_cast &lt; QColor * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setPen((const QColor &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;scale((qreal) Z_LVAL_P(z_0) ,(qreal) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  ///const QPen &amp;pen
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPen
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setPen' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPen &amp;pen,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPen *
+          cpp_arg_0 = static_cast &lt; QPen * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setPen((const QPen &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///Qt::PenStyle style
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setPen' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::PenStyle style,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setPen((Qt::PenStyle) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setPen(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setPen
- *    flags:    
+/*!
+ * method window
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-ZEND_METHOD(QPainter, setPen){
-		/* l public*/
 
-		/* int style,  */
-		/* o public*/
+ZEND_METHOD(QPainter, window)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
 
-		/* const QColor&amp; color,  */
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'window' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
 
-			obj-&gt;setPen((Qt::PenStyle) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;window());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::window(...) &quot;);
+}
 
-			if(obj_z_0-&gt;inherits(&quot;QColor&quot;)) {
-				obj-&gt;setPen((const QColor&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			if(obj_z_0-&gt;inherits(&quot;QPen&quot;)) {
-				obj-&gt;setPen((const QPen&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+/*!
+ * method setBackgroundMode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::BGMode modes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QPainter, setBackgroundMode)
+{
+  ///Qt::BGMode modes0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setBackgroundMode' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::BGMode modes0,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setBackgroundMode((Qt::BGMode) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setBackgroundMode(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setBackgroundMode
- *    flags:    
+/*!
+ * method paintEngine
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPaintEngine *
+ * @flags	c
  */
-ZEND_METHOD(QPainter, setBackgroundMode){
-		/* l public*/
 
-		/* int mode,  */
+ZEND_METHOD(QPainter, paintEngine)
+{
+  ///
+#ifdef PHP_QT_QPaintEngine      // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'paintEngine' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj-&gt;setBackgroundMode((Qt::BGMode) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast &lt; QPaintEngine * &gt;(selfpointer-&gt;paintEngine());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::paintEngine(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  window
- *    flags:    c
+/*!
+ * method setRenderHint
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	RenderHint hints0
+ * @param	 bool on = trues1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, window){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QRect return_object = (QRect) obj-&gt;window();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  paintEngine
- *    flags:    c
- */
-ZEND_METHOD(QPainter, paintEngine){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QPaintEngine * return_object = (QPaintEngine *) obj-&gt;paintEngine();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QPainter, setRenderHint)
+{
+// notice: unknown argument RenderHint hints0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setRenderHint(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setRenderHint
- *    flags:    
+/*!
+ * method strokePath
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPainterPath &amp;paths0
+ * @param	 const QPen &amp;pens1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setRenderHint){
-		/* ll public*/
 
-		/* QPainter::RenderHint hint, int on,  */
+ZEND_METHOD(QPainter, strokePath)
+{
+  ///const QPainterPath &amp;paths0, const QPen &amp;pens1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPainterPath
+#ifdef PHP_QT_QPen
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'strokePath' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPainterPath &amp;paths0, const QPen &amp;pens1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPainterPath *
+          cpp_arg_0 = static_cast &lt; QPainterPath * &gt;(php_qt_fetch(arg_0));
+        QPen *
+          cpp_arg_1 = static_cast &lt; QPen * &gt;(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer-&gt;strokePath((const QPainterPath &amp;)*cpp_arg_0, (const QPen &amp;)*cpp_arg_1));
+      }
+#endif
 
-			obj-&gt;setRenderHint((QPainter::RenderHint) Z_LVAL_P(z_0) ,(bool) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+#endif
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  brush
- *    flags:    c
- */
-ZEND_METHOD(QPainter, brush){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				const QBrush &amp; return_object = (const QBrush &amp;) obj-&gt;brush();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::strokePath(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  strokePath
- *    flags:    
+/*!
+ * method brush
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QBrush &amp;
+ * @flags	c
  */
-ZEND_METHOD(QPainter, strokePath){
-		/* lo public*/
 
-		/* const QPainterPath&amp; path, const QPen&amp; pen,  */
+ZEND_METHOD(QPainter, brush)
+{
+  ///
+#ifdef PHP_QT_QBrush            // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'brush' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			if(obj_z_1-&gt;inherits(&quot;QPen&quot;)) {
-				obj-&gt;strokePath((const QPainterPath&amp;) Z_LVAL_P(z_0), (const QPen&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &amp;const_cast &lt; QBrush &amp; &gt;(selfpointer-&gt;brush());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::brush(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setBrush
- *    flags:    
+/*!
+ * method setBrush
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QBrush &amp;brushs0
+ * 
+ * overloaded args:
+ * @param	Qt::BrushStyle style
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setBrush){
-		/* l public*/
 
-		/* int style,  */
-		/* o public*/
+ZEND_METHOD(QPainter, setBrush)
+{
+  ///const QBrush &amp;brushs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QBrush
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setBrush' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QBrush &amp;brushs0,
+        QPainter *
+          selfpointer;
 
-		/* const QBrush&amp; brush,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QBrush *
+          cpp_arg_0 = static_cast &lt; QBrush * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer-&gt;setBrush((const QBrush &amp;)*cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///Qt::BrushStyle style
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setBrush' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::BrushStyle style,
+      QPainter *
+        selfpointer;
 
-			obj-&gt;setBrush((Qt::BrushStyle) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-
-
-			if(obj_z_0-&gt;inherits(&quot;QBrush&quot;)) {
-				obj-&gt;setBrush((const QBrush&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setBrush((Qt::BrushStyle) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setBrush(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawPoint
- *    flags:    
+/*!
+ * method drawPoint
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF &amp;pts0
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;p
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawPoint){
-		/* l public*/
 
-		/* const QPointF&amp; pt,  */
+ZEND_METHOD(QPainter, drawPoint)
+{
+  ///const QPointF &amp;pts0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPoint' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF &amp;pts0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawPoint((const QPointF &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;drawPoint((const QPointF&amp;) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-		/* ll public*/
+    }
+  }
+  ///const QPoint &amp;p
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawPoint' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;p,
+        QPainter *
+          selfpointer;
 
-		/* int x, int y,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer-&gt;drawPoint((const QPoint &amp;)*cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///int x, int y
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'drawPoint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y,
+      QPainter *
+        selfpointer;
 
-			obj-&gt;drawPoint((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;drawPoint((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawPoint(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  QPainter
- *    flags:    
+/*!
+ * method QPainter
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintDevice *s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QPainter, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *QPainter_ptr = new QPainter();
-				PHP_QT_REGISTER(QPainter_ptr);
-				RETURN_NULL();
-	}
-		/* l public*/
 
-		/* qt_QPaintDevice* ,  */
+ZEND_METHOD(QPainter, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter_php_qt *
+        selfpointer = new QPainter_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QPaintDevice *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPaintDevice
+      if (inherits(Z_OBJCE_P(arg_0), 49)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QPaintDevice *s0,
+        QPaintDevice *
+          cpp_arg_0 = static_cast &lt; QPaintDevice * &gt;(php_qt_fetch(arg_0));
+        QPainter_php_qt *
+          selfpointer = new QPainter_php_qt(getThis(), (QPaintDevice *) cpp_arg_0);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-			QPainter *QPainter_ptr = new QPainter((QPaintDevice*) Z_LVAL_P(z_0));
-				PHP_QT_REGISTER(QPainter_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::QPainter(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setRedirected
- *    flags:    s
+/*!
+ * method setRedirected
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPaintDevice *devices0
+ * @param	 QPaintDevice *replacements1
+ * @param	 const QPoint &amp; offset = QPoint()s2
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QPainter, setRedirected){
-		/* lll public*/
 
-		/* const QPaintDevice* device, qt_QPaintDevice* replacement, const QPoint&amp; offset,  */
+ZEND_METHOD(QPainter, setRedirected)
+{
+  ///const QPaintDevice *devices0, QPaintDevice *replacements1, const QPoint &amp; offset = QPoint()s2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPaintDevice
+#ifdef PHP_QT_QPaintDevice
+      if (inherits(Z_OBJCE_P(arg_0), 49) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 49)) {
+        /// try const QPaintDevice *devices0, QPaintDevice *replacements1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPaintDevice *
+          cpp_arg_0 = static_cast &lt; QPaintDevice * &gt;(php_qt_fetch(arg_0));
+        QPaintDevice *
+          cpp_arg_1 = static_cast &lt; QPaintDevice * &gt;(php_qt_fetch(arg_1));
 
+        if (getThis() == NULL) {
+          RETURN_VOID(QPainter::setRedirected((const QPaintDevice *)cpp_arg_0, (QPaintDevice *) cpp_arg_1));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setRedirected((const QPaintDevice *)cpp_arg_0, (QPaintDevice *) cpp_arg_1));
+      }}
+#endif
 
-			obj-&gt;setRedirected((const QPaintDevice*) Z_LVAL_P(z_0) ,(QPaintDevice*) Z_LVAL_P(z_1) ,(const QPoint&amp;) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-		}
-	}
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QPaintDevice
+#ifdef PHP_QT_QPaintDevice
+      if (inherits(Z_OBJCE_P(arg_0), 49) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 49)) {
+        /// try const QPaintDevice *devices0, QPaintDevice *replacements1, const QPoint &amp; offset = QPoint()s2,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPaintDevice *
+          cpp_arg_0 = static_cast &lt; QPaintDevice * &gt;(php_qt_fetch(arg_0));
+        QPaintDevice *
+          cpp_arg_1 = static_cast &lt; QPaintDevice * &gt;(php_qt_fetch(arg_1));
+        QPoint *
+          cpp_arg_2 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_2));
+
+        if (getThis() == NULL) {
+          RETURN_VOID(QPainter::setRedirected((const QPaintDevice *)cpp_arg_0, (QPaintDevice *) cpp_arg_1, (const QPoint &amp;)*cpp_arg_2));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setRedirected((const QPaintDevice *)cpp_arg_0, (QPaintDevice *) cpp_arg_1, (const QPoint &amp;)*cpp_arg_2));
+      }}
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setRedirected(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  compositionMode
- *    flags:    c
+/*!
+ * method compositionMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	CompositionMode
+ * @flags	c
  */
-ZEND_METHOD(QPainter, compositionMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-				QPainter::CompositionMode return_object = (QPainter::CompositionMode) obj-&gt;compositionMode();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPainter, compositionMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type CompositionMode&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::compositionMode(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setFont
- *    flags:    
+/*!
+ * method setFont
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &amp;fs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setFont){
-		/* o public*/
 
-		/* const QFont&amp; f,  */
+ZEND_METHOD(QPainter, setFont)
+{
+  ///const QFont &amp;fs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setFont' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QFont &amp;fs0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QFont *
+          cpp_arg_0 = static_cast &lt; QFont * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setFont((const QFont &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QFont&quot;) {
-				obj-&gt;setFont((const QFont&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setFont(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  begin
- *    flags:    
+/*!
+ * method begin
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintDevice *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QPainter, begin){
-		/* l public*/
 
-		/* qt_QPaintDevice* ,  */
+ZEND_METHOD(QPainter, begin)
+{
+  ///QPaintDevice *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPaintDevice
+      if (inherits(Z_OBJCE_P(arg_0), 49)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'begin' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QPaintDevice *s0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPaintDevice *
+          cpp_arg_0 = static_cast &lt; QPaintDevice * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_BOOL(selfpointer-&gt;begin((QPaintDevice *) cpp_arg_0));
+      }
+#endif
 
-			RETURN_BOOL(obj-&gt;begin((QPaintDevice*) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::begin(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setViewport
- *    flags:    
+/*!
+ * method setViewport
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;viewports0
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setViewport){
-		/* o public*/
 
-		/* const QRect&amp; viewport,  */
+ZEND_METHOD(QPainter, setViewport)
+{
+  ///const QRect &amp;viewports0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setViewport' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;viewports0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setViewport((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot;) {
-				obj-&gt;setViewport((const QRect&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llll public*/
+    }
+  }
+  ///int x, int y, int w, int h
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setViewport' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h,
+      QPainter *
+        selfpointer;
 
-		/* int x, int y, int w, int h,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setViewport((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setViewport(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+/*!
+ * method drawEllipse
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;rs0
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;r
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QPainter, drawEllipse)
+{
+  ///const QRectF &amp;rs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawEllipse' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rs0,
+        QPainter *
+          selfpointer;
 
-			obj-&gt;setViewport((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawEllipse((const QRectF &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///const QRect &amp;r
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawEllipse' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;r,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawEllipse((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///int x, int y, int w, int h
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'drawEllipse' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;drawEllipse((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawEllipse(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawEllipse
- *    flags:    
+/*!
+ * method drawArc
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;rects0
+ * @param	 int as1
+ * @param	 int alens2
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;
+ * @param	 int a
+ * @param	 int alen
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 int w
+ * @param	 int h
+ * @param	 int a
+ * @param	 int alen
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawEllipse){
-		/* o public*/
 
-		/* const QRectF&amp; r,  */
+ZEND_METHOD(QPainter, drawArc)
+{
+  ///const QRectF &amp;rects0, int as1, int alens2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawArc' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rects0, int as1, int alens2,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawArc((const QRectF &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot;) {
-				obj-&gt;drawEllipse((const QRectF&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llll public*/
+    }
+  }
+  ///const QRect &amp;, int a, int alen
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawArc' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;, int a, int alen,
+        QPainter *
+          selfpointer;
 
-		/* int x, int y, int w, int h,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        RETURN_VOID(selfpointer-&gt;drawArc((const QRect &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      }
+#endif
 
+    }
+  }
+  ///int x, int y, int w, int h, int a, int alen
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp; Z_TYPE_P(arg_4) == IS_LONG
+        &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'drawArc' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x, int y, int w, int h, int a, int alen,
+      QPainter *
+        selfpointer;
 
-			obj-&gt;drawEllipse((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;
+                  drawArc((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4), (int)Z_LVAL_P(arg_5)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawArc(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawArc
- *    flags:    
+/*!
+ * method drawRect
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRectF &amp;rects0
+ * 
+ * overloaded args:
+ * @param	int x1
+ * @param	 int y1
+ * @param	 int w
+ * @param	 int h
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;rect
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawArc){
-		/* oll public*/
 
-		/* const QRectF&amp; rect, int a, int alen,  */
+ZEND_METHOD(QPainter, drawRect)
+{
+  ///const QRectF &amp;rects0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRectF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRectF &amp;rects0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRectF *
+          cpp_arg_0 = static_cast &lt; QRectF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawRect((const QRectF &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot;) {
-				obj-&gt;drawArc((const QRectF&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot;) {
-				obj-&gt;drawArc((const QRect&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llllll public*/
+    }
+  }
+  ///int x1, int y1, int w, int h
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'drawRect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int x1, int y1, int w, int h,
+      QPainter *
+        selfpointer;
 
-		/* int x, int y, int w, int h, int a, int alen,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;drawRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  ///const QRect &amp;rect
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawRect' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;rect,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 6){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		zval *z_5; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4, &amp;z_5) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_LONG &amp;&amp; Z_TYPE_P(z_5) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawRect((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;drawArc((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3) ,(int) Z_LVAL_P(z_4) ,(int) Z_LVAL_P(z_5));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawRect(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setBackground
- *    flags:    
+/*!
+ * method setBackground
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QBrush &amp;bgs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, setBackground){
-		/* o public*/
 
-		/* const QBrush&amp; bg,  */
+ZEND_METHOD(QPainter, setBackground)
+{
+  ///const QBrush &amp;bgs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QBrush
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setBackground' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QBrush &amp;bgs0,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QBrush *
+          cpp_arg_0 = static_cast &lt; QBrush * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;setBackground((const QBrush &amp;)*cpp_arg_0));
+      }
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QBrush&quot;)) {
-				obj-&gt;setBackground((const QBrush&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setBackground(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  isActive
- *    flags:    c
+/*!
+ * method isActive
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QPainter, isActive){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isActive());
-	}
+
+ZEND_METHOD(QPainter, isActive)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isActive' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isActive());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::isActive(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawRect
- *    flags:    
+/*!
+ * method drawLines
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QLineF *liness0
+ * @param	 int lineCounts1
+ * 
+ * overloaded args:
+ * @param	const QVector&lt;QLineF&gt; &amp;lines
+ * 
+ * overloaded args:
+ * @param	const QPointF *pointPairs
+ * @param	 int lineCount
+ * 
+ * overloaded args:
+ * @param	const QVector&lt;QPointF&gt; &amp;pointPairs
+ * 
+ * overloaded args:
+ * @param	const QLine *lines
+ * @param	 int lineCount
+ * 
+ * overloaded args:
+ * @param	const QVector&lt;QLine&gt; &amp;lines
+ * 
+ * overloaded args:
+ * @param	const QPoint *pointPairs
+ * @param	 int lineCount
+ * 
+ * overloaded args:
+ * @param	const QVector&lt;QPoint&gt; &amp;pointPairs
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawRect){
-		/* o public*/
 
-		/* const QRectF&amp; rect,  */
+ZEND_METHOD(QPainter, drawLines)
+{
+  ///const QLineF *liness0, int lineCounts1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLineF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawLines' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QLineF *liness0, int lineCounts1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QLineF *
+          cpp_arg_0 = static_cast &lt; QLineF * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawLines((const QLineF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRectF&quot;) {
-				obj-&gt;drawRect((const QRectF&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot;) {
-				obj-&gt;drawRect((const QRect&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llll public*/
+    }
+  }
+  ///const QVector&lt;QLineF&gt; &amp;lines
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVector
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawLines' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QVector&lt;QLineF&gt; &amp;lines,
+        QPainter *
+          selfpointer;
 
-		/* int x1, int y1, int w, int h,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QVector &lt; QLineF &gt; *cpp_arg_0 = static_cast &lt; QVector &lt; QLineF &gt; *&gt;(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer-&gt;drawLines((const QVector &lt; QLineF &gt; &amp;)*cpp_arg_0));
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+    }
+  }
+  ///const QPointF *pointPairs, int lineCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPointF
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawLines' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF *pointPairs, int lineCount,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
 
-			obj-&gt;drawRect((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+        RETURN_VOID(selfpointer-&gt;drawLines((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawLines
- *    flags:    
- */
-ZEND_METHOD(QPainter, drawLines){
-		/* ol public*/
+    }
+  }
+  ///const QVector&lt;QPointF&gt; &amp;pointPairs
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVector
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawLines' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QVector&lt;QPointF&gt; &amp;pointPairs,
+        QPainter *
+          selfpointer;
 
-		/* const QLineF* lines, int lineCount,  */
-		/* ll public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QVector &lt; QPointF &gt; *cpp_arg_0 = static_cast &lt; QVector &lt; QPointF &gt; *&gt;(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer-&gt;drawLines((const QVector &lt; QPointF &gt; &amp;)*cpp_arg_0));
+      }
+#endif
 
-		/* const QPointF* pointPairs, int lineCount,  */
+    }
+  }
+  ///const QLine *lines, int lineCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLine
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawLines' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QLine *lines, int lineCount,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QLine *
+          cpp_arg_0 = static_cast &lt; QLine * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;drawLines((const QLine *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-			if(obj_z_0-&gt;inherits(&quot;QLineF&quot;)) {
-				obj-&gt;drawLines((const QLineF*) obj_z_0, (int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			if(obj_z_0-&gt;inherits(&quot;QLine&quot;)) {
-				obj-&gt;drawLines((const QLine*) obj_z_0, (int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+    }
+  }
+  ///const QVector&lt;QLine&gt; &amp;lines
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVector
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawLines' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QVector&lt;QLine&gt; &amp;lines,
+        QPainter *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QVector &lt; QLine &gt; *cpp_arg_0 = static_cast &lt; QVector &lt; QLine &gt; *&gt;(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer-&gt;drawLines((const QVector &lt; QLine &gt; &amp;)*cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;drawLines((const QPointF*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  ///const QPoint *pointPairs, int lineCount
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawLines' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint *pointPairs, int lineCount,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;drawLines((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QVector&lt;QPoint&gt; &amp;pointPairs
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVector
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawLines' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QVector&lt;QPoint&gt; &amp;pointPairs,
+        QPainter *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QVector &lt; QPoint &gt; *cpp_arg_0 = static_cast &lt; QVector &lt; QPoint &gt; *&gt;(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer-&gt;drawLines((const QVector &lt; QPoint &gt; &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawLines(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  renderHints
- *    flags:    c
+/*!
+ * method renderHints
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	RenderHints
+ * @flags	c
  */
-ZEND_METHOD(QPainter, renderHints){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			obj-&gt;renderHints();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  backgroundMode
- *    flags:    c
- */
-ZEND_METHOD(QPainter, backgroundMode){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;backgroundMode());
-	}
+ZEND_METHOD(QPainter, renderHints)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type RenderHints&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::renderHints(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  redirected
- *    flags:    s
+/*!
+ * method backgroundMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::BGMode
+ * @flags	c
  */
-ZEND_METHOD(QPainter, redirected){
-		/* ll public*/
 
-		/* const QPaintDevice* device, qt_QPoint* offset,  */
+ZEND_METHOD(QPainter, backgroundMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'backgroundMode' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;backgroundMode());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::backgroundMode(...) &quot;);
+}
 
+/*!
+ * method redirected
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPaintDevice *devices0
+ * @param	 QPoint *offset = 0s1
+ * 
+ * @access	public
+ * @return	QPaintDevice *
+ * @flags	s
+ */
 
-				QPaintDevice * return_object = (QPaintDevice *) obj-&gt;redirected((const QPaintDevice*) Z_LVAL_P(z_0) ,(QPoint*) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPainter_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+ZEND_METHOD(QPainter, redirected)
+{
+// notice: abstract class QPaintDevice cannot be instanciated, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::redirected(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  hasClipping
- *    flags:    c
+/*!
+ * method hasClipping
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QPainter, hasClipping){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;hasClipping());
-	}
+
+ZEND_METHOD(QPainter, hasClipping)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hasClipping' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;hasClipping());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::hasClipping(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  drawTextItem
- *    flags:    
+/*!
+ * method drawTextItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPointF &amp;ps0
+ * @param	 const QTextItem &amp;tis1
+ * 
+ * overloaded args:
+ * @param	int x
+ * @param	 int y
+ * @param	 const QTextItem &amp;ti
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;p
+ * @param	 const QTextItem &amp;ti
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, drawTextItem){
-		/* lo public*/
 
-		/* const QPointF&amp; p, const QTextItem&amp; ti,  */
+ZEND_METHOD(QPainter, drawTextItem)
+{
+  ///const QPointF &amp;ps0, const QTextItem &amp;tis1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPointF
+#ifdef PHP_QT_QTextItem
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawTextItem' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPointF &amp;ps0, const QTextItem &amp;tis1,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPointF *
+          cpp_arg_0 = static_cast &lt; QPointF * &gt;(php_qt_fetch(arg_0));
+        QTextItem *
+          cpp_arg_1 = static_cast &lt; QTextItem * &gt;(php_qt_fetch(arg_1));
 
+        RETURN_VOID(selfpointer-&gt;drawTextItem((const QPointF &amp;)*cpp_arg_0, (const QTextItem &amp;)*cpp_arg_1));
+      }
+#endif
 
-			if(obj_z_1-&gt;inherits(&quot;QTextItem&quot;)) {
-				obj-&gt;drawTextItem((const QPointF&amp;) Z_LVAL_P(z_0), (const QTextItem&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			if(obj_z_1-&gt;inherits(&quot;QTextItem&quot;)) {
-				obj-&gt;drawTextItem((const QPoint&amp;) Z_LVAL_P(z_0), (const QTextItem&amp;) obj_z_1);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* llo public*/
+#endif
 
-		/* int x, int y, const QTextItem&amp; ti,  */
+    }
+  }
+  ///int x, int y, const QTextItem &amp;ti
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QTextItem
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawTextItem' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int x, int y, const QTextItem &amp;ti,
+        QPainter *
+          selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QTextItem *
+          cpp_arg_2 = static_cast &lt; QTextItem * &gt;(php_qt_fetch(arg_2));
 
+        RETURN_VOID(selfpointer-&gt;drawTextItem((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QTextItem &amp;)*cpp_arg_2));
+      }
+#endif
 
-			if(obj_z_2-&gt;inherits(&quot;QTextItem&quot;)) {
-				obj-&gt;drawTextItem((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QTextItem&amp;) obj_z_2);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-}
+    }
+  }
+  ///const QPoint &amp;p, const QTextItem &amp;ti
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QTextItem
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'drawTextItem' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;p, const QTextItem &amp;ti,
+        QPainter *
+          selfpointer;
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  setClipping
- *    flags:    
- */
-ZEND_METHOD(QPainter, setClipping){
-		/* l public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QTextItem *
+          cpp_arg_1 = static_cast &lt; QTextItem * &gt;(php_qt_fetch(arg_1));
 
-		/* int enable,  */
+        RETURN_VOID(selfpointer-&gt;drawTextItem((const QPoint &amp;)*cpp_arg_0, (const QTextItem &amp;)*cpp_arg_1));
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
+#endif
 
-
-			obj-&gt;setClipping((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::drawTextItem(...) &quot;);
 }
 
-/*********************************
- *    class     QPainter */
-/*
- *    function  clipPath
- *    flags:    c
+/*!
+ * method setClipping
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enables0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPainter, clipPath){
-	if (ZEND_NUM_ARGS() == 0){
-			QPainter *obj = (QPainter*) PHP_QT_FETCH();
-			obj-&gt;clipPath();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QPainter, setClipping)
+{
+  ///bool enables0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setClipping' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool enables0,
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setClipping((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::setClipping(...) &quot;);
 }
 
+/*!
+ * method clipPath
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPainterPath
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QPainter);
+ZEND_METHOD(QPainter, clipPath)
+{
+  ///
+#ifdef PHP_QT_QPainterPath      // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'clipPath' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPainter *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPainter * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QPainterPath *
+        return_object = new QPainterPath;
+
+      *return_object = static_cast &lt; QPainterPath &gt; (selfpointer-&gt;clipPath());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPainter::clipPath(...) &quot;);
+}

Modified: trunk/qt/classes/qpaintevent.cpp
===================================================================
--- trunk/qt/classes/qpaintevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qpaintevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,55 +19,187 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QPaintEvent.cpp - QPaintEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QPaintEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QPaintEvent */
-/*
- *    function  rect
- *    flags:    c
+#include &lt;QPaintEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QPaintEvent_php_qt:public QPaintEvent
+{
+
+public:
+  QPaintEvent_php_qt(zval * zend_ptr, const QRegion &amp; paintRegions0);
+    QPaintEvent_php_qt(zval * zend_ptr, const QRect &amp; paintRects0);
+
+
+  zval *zend_ptr;
+};
+QPaintEvent_php_qt::QPaintEvent_php_qt(zval * zend_ptr, const QRegion &amp; paintRegions0):
+QPaintEvent(paintRegions0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QPaintEvent_php_qt::QPaintEvent_php_qt(zval * zend_ptr, const QRect &amp; paintRects0):
+QPaintEvent(paintRects0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method region
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QRegion &amp;
+ * @flags	c
  */
-ZEND_METHOD(QPaintEvent, rect){
-	if (ZEND_NUM_ARGS() == 0){
-			QPaintEvent *obj = (QPaintEvent*) PHP_QT_FETCH();
-				const QRect &amp; return_object = (const QRect &amp;) obj-&gt;rect();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPaintEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPaintEvent, region)
+{
+  ///
+#ifdef PHP_QT_QRegion           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'region' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPaintEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPaintEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QRegion &amp; &gt;(selfpointer-&gt;region());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPaintEvent::region(...) &quot;);
 }
 
-/*********************************
- *    class     QPaintEvent */
-/*
- *    function  region
- *    flags:    c
+/*!
+ * method QPaintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRegion &amp; paintRegions0s0
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;paintRects0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QPaintEvent, region){
-	if (ZEND_NUM_ARGS() == 0){
-			QPaintEvent *obj = (QPaintEvent*) PHP_QT_FETCH();
-				const QRegion &amp; return_object = (const QRegion &amp;) obj-&gt;region();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPaintEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPaintEvent, __construct)
+{
+  ///const QRegion &amp; paintRegions0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegion
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegion &amp; paintRegions0s0,
+        QRegion *cpp_arg_0 = static_cast &lt; QRegion * &gt;(php_qt_fetch(arg_0));
+        QPaintEvent_php_qt *selfpointer = new QPaintEvent_php_qt(getThis(), (const QRegion &amp;)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QRect &amp;paintRects0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;paintRects0,
+        QRect *cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+        QPaintEvent_php_qt *selfpointer = new QPaintEvent_php_qt(getThis(), (const QRect &amp;)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPaintEvent::QPaintEvent(...) &quot;);
 }
 
+/*!
+ * method rect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QRect &amp;
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QPaintEvent);
+ZEND_METHOD(QPaintEvent, rect)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'rect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPaintEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPaintEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QRect &amp; &gt;(selfpointer-&gt;rect());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPaintEvent::rect(...) &quot;);
+}

Modified: trunk/qt/classes/qpushbutton.cpp
===================================================================
--- trunk/qt/classes/qpushbutton.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qpushbutton.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,439 +19,918 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QPushButton.cpp - QPushButton PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QPushButton&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  tr
- *    flags:    s
- */
-ZEND_METHOD(QPushButton, tr){
-		/* ss public*/
+#include &lt;QPushButton&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QPushButton_php_qt:public QPushButton
+{
 
-		/* const char* , const char* ,  */
+public:
+  QPushButton_php_qt(zval * zend_ptr, QWidget * parent = 0);
+  QPushButton_php_qt(zval * zend_ptr, const QString &amp; texts0, QWidget * parent = 0);
+    QPushButton_php_qt(zval * zend_ptr, const QIcon &amp; icons0, const QString &amp; texts1, QWidget * parent = 0);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
 
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
-				QString return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPushButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+QPushButton_php_qt::QPushButton_php_qt(zval * zend_ptr, QWidget * parent):QPushButton(parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QPushButton&quot;,&amp;staticMetaObject));
 }
-
-/*********************************
- *    class     QPushButton */
-/*
- *    function  showMenu
- *    flags:    l
- */
-ZEND_METHOD(QPushButton, showMenu){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-			obj-&gt;showMenu();
-			RETURN_NULL();
-	}
+QPushButton_php_qt::QPushButton_php_qt(zval * zend_ptr, const QString &amp; texts0, QWidget * parent):
+QPushButton(texts0, parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QPushButton&quot;,&amp;staticMetaObject));
 }
+QPushButton_php_qt::QPushButton_php_qt(zval * zend_ptr, const QIcon &amp; icons0, const QString &amp; texts1, QWidget * parent):
+QPushButton(icons0, texts1, parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QPushButton&quot;,&amp;staticMetaObject));
+}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  setFlat
- *    flags:    
+PHP_QT_MOC(QPushButton);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QPushButton, setFlat){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QPushButton, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QPushButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setFlat((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  qt_invoke
- *    flags:    v
- */
-ZEND_METHOD(QPushButton, qt_invoke){
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QPushButton::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QPushButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QPushButton::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QPushButton, staticMetaObject){
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QPushButton, qObject){
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  isDefault
- *    flags:    c
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QPushButton, isDefault){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isDefault());
-	}
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  setAutoDefault
- *    flags:    
+/*!
+ * method QPushButton
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parent=0s0
+ * 
+ * overloaded args:
+ * @param	const QString &amp;texts0
+ * @param	 QWidget  *parent=0
+ * 
+ * overloaded args:
+ * @param	const QIcon &amp; icons0
+ * @param	const QString &amp;texts1
+ * @param	 QWidget *parent=0
+ * 
+ * overloaded args:
+ * @param	const QPushButton &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QPushButton, setAutoDefault){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QPushButton, __construct)
+{
+  ///QWidget *parent=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton_php_qt *selfpointer = new QPushButton_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget *parent=0s0,
+      QWidget *cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QPushButton_php_qt *selfpointer = new QPushButton_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QString &amp;texts0, QWidget  *parent=0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-			obj-&gt;setAutoDefault((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;texts0,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QPushButton_php_qt *selfpointer = new QPushButton_php_qt(getThis(), (const QString &amp;)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;texts0, QWidget  *parent=0,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QWidget *cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+        QPushButton_php_qt *selfpointer = new QPushButton_php_qt(getThis(), (const QString &amp;)*cpp_arg_0, (QWidget *) cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QIcon &amp; icons0,const QString &amp;texts1, QWidget *parent=0
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QIcon
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QIcon &amp; icons0,const QString &amp;texts1,
+        QIcon *cpp_arg_0 = static_cast &lt; QIcon * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        QPushButton_php_qt *selfpointer = new QPushButton_php_qt(getThis(), (const QIcon &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_1 = invokeToQString(arg_1);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QIcon
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QIcon &amp; icons0,const QString &amp;texts1, QWidget *parent=0,
+        QIcon *cpp_arg_0 = static_cast &lt; QIcon * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        QWidget *cpp_arg_2 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_2));
+        QPushButton_php_qt *selfpointer = new QPushButton_php_qt(getThis(), (const QIcon &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1, (QWidget *) cpp_arg_2);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  ///const QPushButton &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPushButton
+      if (inherits(Z_OBJCE_P(arg_0), 52)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QPushButton::__construct(...) cannot be called with 'const QPushButton &amp;,'.&quot;);
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::QPushButton(...) &quot;);
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QPushButton, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj-&gt;sizeHint();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPushButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QPushButton, qt_cast){
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  metaObject
- *    flags:    cv
+/*!
+ * method autoDefault
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QPushButton, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-				QMetaObject * return_object = (QMetaObject *) obj-&gt;metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPushButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPushButton, autoDefault)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'autoDefault' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;autoDefault());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::autoDefault(...) &quot;);
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  menu
- *    flags:    c
+/*!
+ * method setMenu
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMenu * menus0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPushButton, menu){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-				QMenu* return_object = (QMenu*) obj-&gt;menu();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPushButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QPushButton, setMenu)
+{
+  ///QMenu * menus0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QMenu
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setMenu' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QMenu * menus0,
+        QPushButton *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+        }
+        QMenu *cpp_arg_0 = static_cast &lt; QMenu * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setMenu((QMenu *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::setMenu(...) &quot;);
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  setDefault
- *    flags:    
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QPushButton, setDefault){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QPushButton, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QPushButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;setDefault((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QPushButton::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QPushButton, qt_emit){
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  QPushButton
- *    flags:    t
+/*!
+ * method isDefault
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QPushButton, __construct){
-		/* o public*/
 
-		/* qt_QWidget* parent,  */
+ZEND_METHOD(QPushButton, isDefault)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isDefault' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isDefault());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::isDefault(...) &quot;);
+}
 
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				QPushButton *QPushButton_ptr = new QPushButton((QWidget*) obj_z_0);
-				PHP_QT_REGISTER(QPushButton_ptr);
-				RETURN_NULL();
-			}
-			} else if(Z_TYPE_P(z_0) == IS_STRING) { 
-				QPushButton *QPushButton_ptr = new QPushButton((const char*) Z_STRVAL_P(z_0));
-				PHP_QT_REGISTER(QPushButton_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
-		/* oo public*/
+/*!
+ * method setFlat
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-		/* const QString&amp; text, qt_QWidget* parent,  */
+ZEND_METHOD(QPushButton, setFlat)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setFlat' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QPushButton *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setFlat((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::setFlat(...) &quot;);
+}
 
-			if(!(strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QString&quot;)) &amp;&amp; obj_z_1-&gt;inherits(&quot;QWidget&quot;)) {
-				QPushButton *QPushButton_ptr = new QPushButton((const QString&amp;) obj_z_0, (QWidget*) obj_z_1);
-				PHP_QT_REGISTER(QPushButton_ptr);
-				RETURN_NULL();
-			} 
-			} else if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
+/*!
+ * method focusOutEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-			  QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+/*!
+ * method setDefault
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-			if(obj_z_1-&gt;inherits(&quot;QWidget&quot;)) {
-				QPushButton *QPushButton_ptr = new QPushButton((const char*) Z_STRVAL_P(z_0), (QWidget*) obj_z_1);
-				PHP_QT_REGISTER(QPushButton_ptr);
-				RETURN_NULL();
-			} 
-			}
-		}
-	}
-		/* ooo public*/
+ZEND_METHOD(QPushButton, setDefault)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setDefault' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QPushButton *selfpointer;
 
-		/* const QIcon&amp; icon, const QString&amp; text, qt_QWidget* parent,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setDefault((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::setDefault(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
+/*!
+ * method showMenu
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
 
-			if(obj_z_0-&gt;inherits(&quot;QIcon&quot;) &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot; &amp;&amp; obj_z_2-&gt;inherits(&quot;QWidget&quot;)) {
-				QPushButton *QPushButton_ptr = new QPushButton((const QIcon&amp;) obj_z_0, (const QString&amp;) obj_z_1, (QWidget*) obj_z_2);
-				PHP_QT_REGISTER(QPushButton_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+ZEND_METHOD(QPushButton, showMenu)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'showMenu' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;showMenu());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::showMenu(...) &quot;);
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method setAutoDefault
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPushButton, className){
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  autoDefault
- *    flags:    c
- */
-ZEND_METHOD(QPushButton, autoDefault){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;autoDefault());
-	}
+ZEND_METHOD(QPushButton, setAutoDefault)
+{
+  ///bool bools0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setAutoDefault' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QPushButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setAutoDefault((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::setAutoDefault(...) &quot;);
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QPushButton, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QPushButton, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QPushButton_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::sizeHint(...) &quot;);
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  isFlat
- *    flags:    c
+/*!
+ * method keyPressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPushButton, isFlat){
-	if (ZEND_NUM_ARGS() == 0){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isFlat());
-	}
-}
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method menu
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMenu*
+ * @flags	c
  */
-ZEND_METHOD(QPushButton, qt_property){
+
+ZEND_METHOD(QPushButton, menu)
+{
+  ///
+#ifdef PHP_QT_QMenu             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'menu' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QMenu * &gt;(selfpointer-&gt;menu());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::menu(...) &quot;);
 }
 
-/*********************************
- *    class     QPushButton */
-/*
- *    function  setMenu
- *    flags:    
+/*!
+ * method focusInEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QPushButton, setMenu){
-		/* o public*/
 
-		/* QMenu* menu,  */
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QPushButton *obj = (QPushButton*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QPushButton, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QPushButton *selfpointer;
 
-			if(obj_z_0-&gt;inherits(&quot;QMenu&quot;)) {
-				obj-&gt;setMenu((QMenu*) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QPushButton::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QPushButton *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QPushButton::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::trUtf8(...) &quot;);
 }
 
+/*!
+ * method isFlat
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QPushButton);
+ZEND_METHOD(QPushButton, isFlat)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isFlat' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QPushButton *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QPushButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isFlat());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QPushButton::isFlat(...) &quot;);
+}

Modified: trunk/qt/classes/qresizeevent.cpp
===================================================================
--- trunk/qt/classes/qresizeevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qresizeevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,55 +19,162 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QResizeEvent.cpp - QResizeEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QResizeEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QResizeEvent */
-/*
- *    function  oldSize
- *    flags:    c
+#include &lt;QResizeEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QResizeEvent_php_qt:public QResizeEvent
+{
+
+public:
+  QResizeEvent_php_qt(zval * zend_ptr, const QSize &amp; sizes0, const QSize &amp; oldSizes1);
+
+
+  zval *zend_ptr;
+};
+QResizeEvent_php_qt::QResizeEvent_php_qt(zval * zend_ptr, const QSize &amp; sizes0, const QSize &amp; oldSizes1):
+QResizeEvent(sizes0, oldSizes1)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QResizeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &amp;sizes0s0
+ * @param	const QSize &amp;oldSizes1s1
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QResizeEvent, oldSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QResizeEvent *obj = (QResizeEvent*) PHP_QT_FETCH();
-				const QSize &amp; return_object = (const QSize &amp;) obj-&gt;oldSize();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QResizeEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QResizeEvent, __construct)
+{
+  ///const QSize &amp;sizes0s0,const QSize &amp;oldSizes1s1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QSize &amp;sizes0s0,const QSize &amp;oldSizes1s1,
+        QSize *cpp_arg_0 = static_cast &lt; QSize * &gt;(php_qt_fetch(arg_0));
+        QSize *cpp_arg_1 = static_cast &lt; QSize * &gt;(php_qt_fetch(arg_1));
+        QResizeEvent_php_qt *selfpointer = new QResizeEvent_php_qt(getThis(), (const QSize &amp;)*cpp_arg_0, (const QSize &amp;)*cpp_arg_1);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QResizeEvent::QResizeEvent(...) &quot;);
 }
 
-/*********************************
- *    class     QResizeEvent */
-/*
- *    function  size
- *    flags:    c
+/*!
+ * method size
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QSize &amp;
+ * @flags	c
  */
-ZEND_METHOD(QResizeEvent, size){
-	if (ZEND_NUM_ARGS() == 0){
-			QResizeEvent *obj = (QResizeEvent*) PHP_QT_FETCH();
-				const QSize &amp; return_object = (const QSize &amp;) obj-&gt;size();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QResizeEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QResizeEvent, size)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'size' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QResizeEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QResizeEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QSize &amp; &gt;(selfpointer-&gt;size());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QResizeEvent::size(...) &quot;);
 }
 
+/*!
+ * method oldSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QSize &amp;
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QResizeEvent);
+ZEND_METHOD(QResizeEvent, oldSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'oldSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QResizeEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QResizeEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QSize &amp; &gt;(selfpointer-&gt;oldSize());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QResizeEvent::oldSize(...) &quot;);
+}

Modified: trunk/qt/classes/qshortcutevent.cpp
===================================================================
--- trunk/qt/classes/qshortcutevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qshortcutevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,62 +19,201 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QShortcutEvent.cpp - QShortcutEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QShortcutEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QShortcutEvent */
-/*
- *    function  shortcutId
- *    flags:    
+#include &lt;QShortcutEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QShortcutEvent_php_qt:public QShortcutEvent
+{
+
+public:
+  QShortcutEvent_php_qt(zval * zend_ptr, const QKeySequence &amp; keys0, int ids1, bool ambiguous = false);
+
+
+  zval *zend_ptr;
+};
+QShortcutEvent_php_qt::QShortcutEvent_php_qt(zval * zend_ptr, const QKeySequence &amp; keys0, int ids1, bool ambiguous):
+QShortcutEvent(keys0, ids1, ambiguous)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method key
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QKeySequence &amp;
+ * @flags	
  */
-ZEND_METHOD(QShortcutEvent, shortcutId){
-	if (ZEND_NUM_ARGS() == 0){
-			QShortcutEvent *obj = (QShortcutEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;shortcutId());
-	}
+
+ZEND_METHOD(QShortcutEvent, key)
+{
+  ///
+#ifdef PHP_QT_QKeySequence      // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'key' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QShortcutEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QShortcutEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QKeySequence &amp; &gt;(selfpointer-&gt;key());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QShortcutEvent::key(...) &quot;);
 }
 
-/*********************************
- *    class     QShortcutEvent */
-/*
- *    function  isAmbiguous
- *    flags:    
+/*!
+ * method shortcutId
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	
  */
-ZEND_METHOD(QShortcutEvent, isAmbiguous){
-	if (ZEND_NUM_ARGS() == 0){
-			QShortcutEvent *obj = (QShortcutEvent*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isAmbiguous());
-	}
+
+ZEND_METHOD(QShortcutEvent, shortcutId)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'shortcutId' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QShortcutEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QShortcutEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;shortcutId());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QShortcutEvent::shortcutId(...) &quot;);
 }
 
-/*********************************
- *    class     QShortcutEvent */
-/*
- *    function  key
- *    flags:    
+/*!
+ * method isAmbiguous
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QShortcutEvent, key){
-	if (ZEND_NUM_ARGS() == 0){
-			QShortcutEvent *obj = (QShortcutEvent*) PHP_QT_FETCH();
-				const QKeySequence &amp; return_object = (const QKeySequence &amp;) obj-&gt;key();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QShortcutEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QShortcutEvent, isAmbiguous)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isAmbiguous' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QShortcutEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QShortcutEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isAmbiguous());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QShortcutEvent::isAmbiguous(...) &quot;);
 }
 
+/*!
+ * method QShortcutEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QKeySequence &amp;keys0s0
+ * @param	int ids1s1
+ * @param	 bool ambiguous = falses2
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QShortcutEvent);
+ZEND_METHOD(QShortcutEvent, __construct)
+{
+  ///const QKeySequence &amp;keys0s0,int ids1s1, bool ambiguous = falses2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QKeySequence
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QKeySequence &amp;keys0s0,int ids1s1,
+        QKeySequence *cpp_arg_0 = static_cast &lt; QKeySequence * &gt;(php_qt_fetch(arg_0));
+        QShortcutEvent_php_qt *selfpointer = new QShortcutEvent_php_qt(getThis(), (const QKeySequence &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1));
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_BOOL) {
+#ifdef PHP_QT_QKeySequence
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QKeySequence &amp;keys0s0,int ids1s1, bool ambiguous = falses2,
+        QKeySequence *cpp_arg_0 = static_cast &lt; QKeySequence * &gt;(php_qt_fetch(arg_0));
+        QShortcutEvent_php_qt *selfpointer =
+          new QShortcutEvent_php_qt(getThis(), (const QKeySequence &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (bool) Z_LVAL_P(arg_2));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QShortcutEvent::QShortcutEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qshowevent.cpp
===================================================================
--- trunk/qt/classes/qshowevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qshowevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,62 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QShowEvent.cpp - QShowEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QShowEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
+#include &lt;QShowEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QShowEvent_php_qt:public QShowEvent
+{
 
-PHP_QT_DESTRUCT(QShowEvent);
+public:
+  QShowEvent_php_qt(zval * zend_ptr);
 
+
+  zval *zend_ptr;
+};
+
+QShowEvent_php_qt::QShowEvent_php_qt(zval * zend_ptr):QShowEvent()
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QShowEvent
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QShowEvent, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QShowEvent_php_qt *
+        selfpointer = new QShowEvent_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QShowEvent::QShowEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qslider.cpp
===================================================================
--- trunk/qt/classes/qslider.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qslider.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,391 +19,750 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QSlider.cpp - QSlider PHP implementation.
- * begin           : Thu Feb 23 10:18:44 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
+
 #include &quot;../php_qt.h&quot;
 
 
 #include &lt;QSlider&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QSlider_php_qt:public QSlider
+{
 
+public:
+  QSlider_php_qt(zval * zend_ptr, QWidget * parent = 0);
+  QSlider_php_qt(zval * zend_ptr, Qt::Orientation orientations0, QWidget * parent = 0);
 
-/*		public enumTickPosition:long {
-			NoTicks = 0,
-			TicksAbove = 1,
-			TicksLeft = TicksAbove,
-			TicksBelow = 2,
-			TicksRight = TicksBelow,
-			TicksBothSides = 3
-		}
-*/
-/*********************************
- *    class     QSlider */
-/*
- *    function  tr
- *    flags:    s
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+
+QSlider_php_qt::QSlider_php_qt(zval * zend_ptr, QWidget * parent):QSlider(parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QSlider&quot;,&amp;staticMetaObject));
+}
+
+QSlider_php_qt::QSlider_php_qt(zval * zend_ptr, Qt::Orientation orientations0, QWidget * parent):QSlider(orientations0, parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QSlider&quot;,&amp;staticMetaObject));
+}
+
+PHP_QT_MOC(QSlider);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QSlider, tr){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QSlider, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QSlider *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSlider * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QSlider::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  qt_invoke
- *    flags:    v
- */
-ZEND_METHOD(QSlider, qt_invoke){
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QSlider::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSlider * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QSlider::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QSlider::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method mouseMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *evs0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSlider, staticMetaObject){
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QSlider, qObject){
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  QSlider
- *    flags:    t
+/*!
+ * method QSlider
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parent = 0s0
+ * 
+ * overloaded args:
+ * @param	Qt::Orientation orientations0
+ * @param	 QWidget *parent = 0
+ * 
+ * overloaded args:
+ * @param	const QSlider &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QSlider, __construct){
-		/* o public*/
 
-		/* qt_QWidget* parent,  */
+ZEND_METHOD(QSlider, __construct)
+{
+  ///QWidget *parent = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QSlider_php_qt *
+        selfpointer = new QSlider_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget *parent = 0s0,
+      QWidget *
+        cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QSlider_php_qt *
+        selfpointer = new QSlider_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///Qt::Orientation orientations0, QWidget *parent = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::Orientation orientations0,
+      QSlider_php_qt *
+        selfpointer = new QSlider_php_qt(getThis(), (Qt::Orientation) Z_LVAL_P(arg_0));
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				QSlider *QSlider_ptr = new QSlider((QWidget*) obj_z_0);
-				PHP_QT_REGISTER(QSlider_ptr);
-				RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
-		/* lo public*/
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::Orientation orientations0, QWidget *parent = 0,
+      QWidget *
+        cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+      QSlider_php_qt *
+        selfpointer = new QSlider_php_qt(getThis(), (Qt::Orientation) Z_LVAL_P(arg_0), (QWidget *) cpp_arg_1);
 
-		/* int orientation, qt_QWidget* parent,  */
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QSlider &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSlider
+      if (inherits(Z_OBJCE_P(arg_0), 56)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QSlider::__construct(...) cannot be called with 'const QSlider &amp;,'.&quot;);
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-
-
-			if(obj_z_1-&gt;inherits(&quot;QWidget&quot;)) {
-				QSlider *QSlider_ptr = new QSlider((Qt::Orientation) Z_LVAL_P(z_0), (QWidget*) obj_z_1);
-				PHP_QT_REGISTER(QSlider_ptr);
-				RETURN_NULL();
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QSlider::QSlider(...) &quot;);
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  minimumSizeHint
- *    flags:    c
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QSlider, minimumSizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
-			QSize* return_object = new QSize;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;minimumSizeHint();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QSlider, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
-			QSize* return_object = new QSize;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QSize) obj-&gt;sizeHint();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method setTickInterval
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int tis0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSlider, qt_cast){
+
+ZEND_METHOD(QSlider, setTickInterval)
+{
+  ///int tis0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setTickInterval' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int tis0,
+      QSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setTickInterval((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QSlider::setTickInterval(...) &quot;);
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  metaObject
- *    flags:    cv
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QSlider, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
-			QMetaObject ** return_object = new QMetaObject *;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QMetaObject *) obj-&gt;metaObject();
-			} else {
-				php_error(E_ERROR,&quot;Object not found&quot;);
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  tickInterval
- *    flags:    c
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(QSlider, tickInterval){
-	if (ZEND_NUM_ARGS() == 0){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;tickInterval());
-	}
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  setTickInterval
- *    flags:    
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QSlider, setTickInterval){
-		/* l public*/
 
-		/* int ti,  */
+ZEND_METHOD(QSlider, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QSlider *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSlider * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj-&gt;setTickInterval((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QSlider::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QSlider::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  tickPosition
- *    flags:    c
+/*!
+ * method mouseReleaseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *evs0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSlider, tickPosition){
-	if (ZEND_NUM_ARGS() == 0){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
-			obj-&gt;tickPosition();
-			RETURN_NULL();
-	}
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QSlider, qt_emit){
-}
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  event
- *    flags:    
+/*!
+ * method minimumSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QSlider, event){
-		/* o public*/
 
-		/* qt_QEvent* event,  */
+ZEND_METHOD(QSlider, minimumSizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumSizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QSlider *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSlider * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			if(!strcmp(Z_OBJCE_P(z_0)-&gt;name,&quot;QEvent&quot;)) {
-				RETURN_BOOL(obj-&gt;event((QEvent*) obj_z_0));
-			}
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;minimumSizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QSlider::minimumSizeHint(...) &quot;);
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QSlider, className){
+
+/*!
+ * method tickInterval
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QSlider, tickInterval)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'tickInterval' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSlider * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;tickInterval());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QSlider::tickInterval(...) &quot;);
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  setTickPosition
- *    flags:    
+/*!
+ * method tickPosition
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	TickPosition
+ * @flags	c
  */
-ZEND_METHOD(QSlider, setTickPosition){
-		/* l public*/
 
-		/* int position,  */
+ZEND_METHOD(QSlider, tickPosition)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type TickPosition&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QSlider::tickPosition(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *events0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
+ */
 
+ZEND_METHOD(QSlider, event)
+{
+  ///QEvent *events0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QEvent
+      if (inherits(Z_OBJCE_P(arg_0), 21)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'event' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QEvent *events0,
+        QSlider *
+          selfpointer;
 
-			obj-&gt;setTickPosition((QSlider::TickPosition) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QSlider * &gt;(PHP_QT_FETCH());
+        }
+        QEvent *
+          cpp_arg_0 = static_cast &lt; QEvent * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;event((QEvent *) cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QSlider::event(...) &quot;);
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *evs0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSlider, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+/*!
+ * method mousePressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *evs0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QSlider *obj = (QSlider*) PHP_QT_FETCH();
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
+ */
 
+ZEND_METHOD(QSlider, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-			QString* return_object = new QString;
-			// static?
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QSlider::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSlider_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSlider * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QSlider::sizeHint(...) &quot;);
 }
 
-/*********************************
- *    class     QSlider */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method setTickPosition
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	TickPosition positions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSlider, qt_property){
+
+ZEND_METHOD(QSlider, setTickPosition)
+{
+// notice: unknown argument TickPosition positions0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QSlider::setTickPosition(...) &quot;);
 }
 
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
 
-PHP_QT_DESTRUCT(QSlider);
+ZEND_METHOD(QSlider, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSlider * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QSlider::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QSlider *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSlider * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QSlider::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QSlider::trUtf8(...) &quot;);
+}

Modified: trunk/qt/classes/qspaceritem.cpp
===================================================================
--- trunk/qt/classes/qspaceritem.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qspaceritem.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,236 +19,501 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QSpacerItem.cpp - QSpacerItem PHP implementation.
- * begin           : Wed Jan 11 20:29:53 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QSpacerItem&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  changeSize
- *    flags:    
- */
-ZEND_METHOD(QSpacerItem, changeSize){
+#include &lt;QSpacerItem&gt;
+#include &lt;QMetaMethod&gt;
+class QSpacerItem_php_qt:public QSpacerItem
+{
 
-	if (ZEND_NUM_ARGS() == 4){
-		/* lloo */
-		long var_lloo_0;    // default: 
-		long var_lloo_1;    // default: 
-		zval* z_var_lloo_2;   // default: QSizePolicy::Minimum
-		zval* z_var_lloo_3;   // default: QSizePolicy::Minimum
+public:
+  QSpacerItem_php_qt(zval * zend_ptr, int ws0, int hs1, QSizePolicy::Policy hData = QSizePolicy::Minimum, QSizePolicy::Policy vData = QSizePolicy::Minimum);
 
-		/* int w, int h, QSizePolicy::Policy hData, QSizePolicy::Policy vData,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;llo|o|&quot;, &amp;var_lloo_0, &amp;var_lloo_1, &amp;z_var_lloo_2, &amp;z_var_lloo_3) == SUCCESS) {
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QObject* var_lloo_2 = (QObject*) php_qt_fetch(z_var_lloo_2);
-			QObject* var_lloo_3 = (QObject*) php_qt_fetch(z_var_lloo_3);
 
-			QString tmp_lloo_0(var_lloo_2-&gt;metaObject()-&gt;className());
-			QString tmp_lloo_1(var_lloo_3-&gt;metaObject()-&gt;className());
-			
-			if(tmp_lloo_0 == &quot;QSizePolicy::Policy&quot; &amp;&amp; tmp_lloo_1 == &quot;QSizePolicy::Policy&quot;) {
-//				obj-&gt;changeSize((int) var_lloo_0, (int) var_lloo_1, (QSizePolicy::Policy) var_lloo_2, (QSizePolicy::Policy) var_lloo_3);
-			RETURN_NULL();
-			}
-		}
-	}
+  zval *zend_ptr;
+};
+QSpacerItem_php_qt::QSpacerItem_php_qt(zval * zend_ptr, int ws0, int hs1, QSizePolicy::Policy hData, QSizePolicy::Policy vData):
+QSpacerItem(ws0, hs1, hData, vData)
+{
+  this-&gt;zend_ptr = zend_ptr;
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  isEmpty
- *    flags:    c
+/*!
+ * method spacerItem
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSpacerItem *
+ * @flags	
  */
-ZEND_METHOD(QSpacerItem, isEmpty){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isEmpty());
-	}
+
+ZEND_METHOD(QSpacerItem, spacerItem)
+{
+  ///
+#ifdef PHP_QT_QSpacerItem       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'spacerItem' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSpacerItem * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QSpacerItem * &gt;(selfpointer-&gt;spacerItem());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QSpacerItem::spacerItem(...) &quot;);
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  setGeometry
- *    flags:    
+/*!
+ * method changeSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ws0
+ * @param	 int hs1
+ * @param	 QSizePolicy::Policy hData = QSizePolicy::Minimums2
+ * @param	 QSizePolicy::Policy vData = QSizePolicy::Minimums3
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSpacerItem, setGeometry){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* o */
-		zval* z_var_o_0;   // default: 
+ZEND_METHOD(QSpacerItem, changeSize)
+{
+  ///int ws0, int hs1, QSizePolicy::Policy hData = QSizePolicy::Minimums2, QSizePolicy::Policy vData = QSizePolicy::Minimums3
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'changeSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ws0, int hs1,
+      QSpacerItem *selfpointer;
 
-		/* const QRect&amp; ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;o&quot;, &amp;z_var_o_0) == SUCCESS) {
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QObject* var_o_0 = (QObject*) php_qt_fetch(z_var_o_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSpacerItem * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;changeSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'changeSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ws0, int hs1, QSizePolicy::Policy hData = QSizePolicy::Minimums2,
+      QSpacerItem *selfpointer;
 
-			QString tmp_o_0(var_o_0-&gt;metaObject()-&gt;className());
-			
-			if(tmp_o_0 == &quot;const QRect&amp;&quot;) {
-				obj-&gt;setGeometry((const QRect&amp;) var_o_0);
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSpacerItem * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;changeSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (QSizePolicy::Policy) Z_LVAL_P(arg_2)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'changeSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ws0, int hs1, QSizePolicy::Policy hData = QSizePolicy::Minimums2, QSizePolicy::Policy vData = QSizePolicy::Minimums3,
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSpacerItem * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;
+                  changeSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (QSizePolicy::Policy) Z_LVAL_P(arg_2), (QSizePolicy::Policy) Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QSpacerItem::changeSize(...) &quot;);
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  spacerItem
- *    flags:    
+/*!
+ * method QSpacerItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ws0s0
+ * @param	int hs1s1
+ * @param	 QSizePolicy::Policy hData = QSizePolicy::Minimums2
+ * @param	 QSizePolicy::Policy vData = QSizePolicy::Minimums3
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QSpacerItem, spacerItem){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QSpacerItem * return_object = (QSpacerItem *) obj-&gt;spacerItem();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSpacerItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QSpacerItem, __construct)
+{
+  ///int ws0s0,int hs1s1, QSizePolicy::Policy hData = QSizePolicy::Minimums2, QSizePolicy::Policy vData = QSizePolicy::Minimums3
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ws0s0,int hs1s1,
+      QSpacerItem_php_qt *selfpointer = new QSpacerItem_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ws0s0,int hs1s1, QSizePolicy::Policy hData = QSizePolicy::Minimums2,
+      QSpacerItem_php_qt *selfpointer = new QSpacerItem_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (QSizePolicy::Policy) Z_LVAL_P(arg_2));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ws0s0,int hs1s1, QSizePolicy::Policy hData = QSizePolicy::Minimums2, QSizePolicy::Policy vData = QSizePolicy::Minimums3,
+      QSpacerItem_php_qt *selfpointer =
+        new QSpacerItem_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (QSizePolicy::Policy) Z_LVAL_P(arg_2),
+                               (QSizePolicy::Policy) Z_LVAL_P(arg_3));
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QSpacerItem::QSpacerItem(...) &quot;);
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  minimumSize
- *    flags:    c
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	c
  */
-ZEND_METHOD(QSpacerItem, minimumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QSize return_object = (QSize) obj-&gt;minimumSize();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSpacerItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QSpacerItem, expandingDirections)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'expandingDirections' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSpacerItem * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;expandingDirections());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QSpacerItem::expandingDirections(...) &quot;);
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method isEmpty
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QSpacerItem, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QSize return_object = (QSize) obj-&gt;sizeHint();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSpacerItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QSpacerItem, isEmpty)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isEmpty' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSpacerItem * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isEmpty());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QSpacerItem::isEmpty(...) &quot;);
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  maximumSize
- *    flags:    c
+/*!
+ * method geometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-ZEND_METHOD(QSpacerItem, maximumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QSize return_object = (QSize) obj-&gt;maximumSize();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSpacerItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QSpacerItem, geometry)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'geometry' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSpacerItem * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QRect *return_object = new QRect;
+
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;geometry());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QSpacerItem::geometry(...) &quot;);
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  geometry
- *    flags:    c
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QSpacerItem, geometry){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QRect return_object = (QRect) obj-&gt;geometry();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSpacerItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QSpacerItem, setGeometry)
+{
+  ///const QRect &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setGeometry' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;s0,
+        QSpacerItem *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QSpacerItem * &gt;(PHP_QT_FETCH());
+        }
+        QRect *cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setGeometry((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QSpacerItem::setGeometry(...) &quot;);
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  expandingDirections
- *    flags:    c
+/*!
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QSpacerItem, expandingDirections){
-	if (ZEND_NUM_ARGS() == 0){
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			Qt::Orientations return_object = (Qt::Orientations) obj-&gt;expandingDirections();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QSpacerItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QSpacerItem, minimumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSpacerItem * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;minimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QSpacerItem::minimumSize(...) &quot;);
 }
 
-/*********************************
- *    class     QSpacerItem */
-/*
- *    function  QSpacerItem
- *    flags:    
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QSpacerItem, __construct){
 
-	if (ZEND_NUM_ARGS() == 4){
-		/* lloo */
-		long var_lloo_0;    // default: 
-		long var_lloo_1;    // default: 
-		zval* z_var_lloo_2;   // default: QSizePolicy::Minimum
-		zval* z_var_lloo_3;   // default: QSizePolicy::Minimum
+ZEND_METHOD(QSpacerItem, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-		/* int w, int h, QSizePolicy::Policy hData, QSizePolicy::Policy vData,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;llo|o|&quot;, &amp;var_lloo_0, &amp;var_lloo_1, &amp;z_var_lloo_2, &amp;z_var_lloo_3) == SUCCESS) {
-			QSpacerItem *obj = (QSpacerItem*) PHP_QT_FETCH();
-			QObject* var_lloo_2 = (QObject*) php_qt_fetch(z_var_lloo_2);
-			QObject* var_lloo_3 = (QObject*) php_qt_fetch(z_var_lloo_3);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
 
-			QString tmp_lloo_0(var_lloo_2-&gt;metaObject()-&gt;className());
-			QString tmp_lloo_1(var_lloo_3-&gt;metaObject()-&gt;className());
-			
-			if(tmp_lloo_0 == &quot;QSizePolicy::Policy&quot; &amp;&amp; tmp_lloo_1 == &quot;QSizePolicy::Policy&quot;) {
-//				QSpacerItem *QSpacerItem_ptr = new QSpacerItem((int) var_lloo_0, (int) var_lloo_1, (QSizePolicy::Policy) var_lloo_2, (QSizePolicy::Policy) var_lloo_3);
-//			PHP_QT_REGISTER(QSpacerItem_ptr);
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSpacerItem * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QSpacerItem::sizeHint(...) &quot;);
 }
 
+/*!
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QSpacerItem);
+ZEND_METHOD(QSpacerItem, maximumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'maximumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QSpacerItem *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QSpacerItem * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QSize *return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;maximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QSpacerItem::maximumSize(...) &quot;);
+}

Modified: trunk/qt/classes/qstatustipevent.cpp
===================================================================
--- trunk/qt/classes/qstatustipevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qstatustipevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,36 +19,117 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QStatusTipEvent.cpp - QStatusTipEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QStatusTipEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QStatusTipEvent */
-/*
- *    function  tip
- *    flags:    c
+#include &lt;QStatusTipEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QStatusTipEvent_php_qt:public QStatusTipEvent
+{
+
+public:
+  QStatusTipEvent_php_qt(zval * zend_ptr, const QString &amp; tips0);
+
+
+  zval *zend_ptr;
+};
+QStatusTipEvent_php_qt::QStatusTipEvent_php_qt(zval * zend_ptr, const QString &amp; tips0):
+QStatusTipEvent(tips0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method tip
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QStatusTipEvent, tip){
-	if (ZEND_NUM_ARGS() == 0){
-			QStatusTipEvent *obj = (QStatusTipEvent*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;tip();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QStatusTipEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QStatusTipEvent, tip)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'tip' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QStatusTipEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QStatusTipEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tip());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QStatusTipEvent::tip(...) &quot;);
 }
 
+/*!
+ * method QStatusTipEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;tips0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QStatusTipEvent);
+ZEND_METHOD(QStatusTipEvent, __construct)
+{
+  ///const QString &amp;tips0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;tips0s0,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QStatusTipEvent_php_qt *selfpointer = new QStatusTipEvent_php_qt(getThis(), (const QString &amp;)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QStatusTipEvent::QStatusTipEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qstring.cpp
===================================================================
--- trunk/qt/classes/qstring.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qstring.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,2844 +19,8301 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QString.cpp - QString PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QString&gt;
 #include &quot;../php_qt.h&quot;
 
 
-ZEND_METHOD(QString,__toString){
+#include &lt;QString&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QString_php_qt:public QString
+{
 
-  QString *QString_ptr = (QString *) PHP_QT_FETCH();
+public:
+  QString_php_qt(zval * zend_ptr);
+  QString_php_qt(zval * zend_ptr, const QChar * unicodes0, int sizes1);
+    QString_php_qt(zval * zend_ptr, QChar cs0);
+    QString_php_qt(zval * zend_ptr, int sizes0, QChar cs1);
+    QString_php_qt(zval * zend_ptr, const QLatin1String &amp; latin1s0);
+    QString_php_qt(zval * zend_ptr, const QString &amp; s0);
+    QString_php_qt(zval * zend_ptr, const char *chs0);
+    QString_php_qt(zval * zend_ptr, const QByteArray &amp; as0);
+    QString_php_qt(zval * zend_ptr, const Null &amp; s0);
 
-  int l = QString_ptr-&gt;size();
-  char* c = (char*) (QString_ptr-&gt;toAscii()).constData();
-  RETURN_STRING(c,l);
-}
 
+  zval *zend_ptr;
+};
 
-/*		public enumSectionFlag:long {
-			SectionDefault = 0x00,
-			SectionSkipEmpty = 0x01,
-			SectionIncludeLeadingSep = 0x02,
-			SectionIncludeTrailingSep = 0x04,
-			SectionCaseInsensitiveSeps = 0x08
-		}
-*/
+QString_php_qt::QString_php_qt(zval * zend_ptr):QString()
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, const QChar * unicodes0, int sizes1):
+QString(unicodes0, sizes1)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
 
-/*		public enumSplitBehavior:long {
-			SplitBehavior = 0,
-			SplitBehavior = 1
-		}
-*/
+QString_php_qt::QString_php_qt(zval * zend_ptr, QChar cs0):QString(cs0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, int sizes0, QChar cs1):
+QString(sizes0, cs1)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, const QLatin1String &amp; latin1s0):
+QString(latin1s0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, const QString &amp; s0):
+QString(s0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, const char *chs0):
+QString(chs0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, const QByteArray &amp; as0):
+QString(as0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QString_php_qt::QString_php_qt(zval * zend_ptr, const Null &amp; s0):
+QString(s0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
 
-/*		public enumNormalizationForm:long {
-			NormalizationForm = 0,
-			NormalizationForm = 1,
-			NormalizationForm = 2,
-			NormalizationForm = 3
-		}
-*/
-/*********************************
- *    class     QString */
-/*
- *    function  compare
- *    flags:    c
+/*!
+ * method compare
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s1
+ * @param	 const QString &amp;s2
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QString, compare){
-		/* o public*/
 
-		/* const QString&amp; s,  */
+ZEND_METHOD(QString, compare)
+{
+  ///const QString &amp;ss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'compare' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;ss0,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				RETURN_LONG(obj-&gt;compare((const QString&amp;) obj_z_0));
-			}
-			}
-		}
-	}
-		/* oo public*/
+        RETURN_LONG(selfpointer-&gt;compare((const QString &amp;)*cpp_arg_0));
+      }
+#endif
 
-		/* const QString&amp; s1, const QString&amp; s2,  */
+    }
+  }
+  ///const QString &amp;s1, const QString &amp;s2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        /// try const QString &amp;s1, const QString &amp;s2,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot;) {
-				RETURN_LONG(obj-&gt;compare((const QString&amp;) obj_z_0, (const QString&amp;) obj_z_1));
-			}
-			}
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_LONG(QString::compare((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        } else {
+          RETURN_LONG(selfpointer-&gt;compare((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+      }}
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::compare(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  utf16
- *    flags:    c
+/*!
+ * method utf16
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const ushort *
+ * @flags	c
  */
-ZEND_METHOD(QString, utf16){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				const ushort * return_object = (const ushort *) obj-&gt;utf16();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, utf16)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'utf16' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;utf16());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::utf16(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  constData
- *    flags:    c
+/*!
+ * method constData
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QChar *
+ * @flags	c
  */
-ZEND_METHOD(QString, constData){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				const QChar * return_object = (const QChar *) obj-&gt;constData();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, constData)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'constData' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast &lt; QChar * &gt;(selfpointer-&gt;constData());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::constData(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  insert
- *    flags:    
+/*!
+ * method insert
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * @param	 QChar cs1
+ * 
+ * overloaded args:
+ * @param	int i
+ * @param	 const QChar *uc
+ * @param	 int len
+ * 
+ * overloaded args:
+ * @param	int i
+ * @param	 const QString &amp;s
+ * 
+ * overloaded args:
+ * @param	int i
+ * @param	 const QLatin1String &amp;s
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
  */
-ZEND_METHOD(QString, insert){
-		/* ll public*/
 
-		/* int i, char c,  */
-		/* lo public*/
+ZEND_METHOD(QString, insert)
+{
+  ///int is0, QChar cs1
+#ifdef PHP_QT_QString           // return type
 
-		/* int i, const QString&amp; s,  */
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_1), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'insert' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int is0, QChar cs1,
+        QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_1 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
 
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
 
-				QString &amp; return_object = (QString &amp;) obj-&gt;insert((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;insert((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
+    }
+  }
+#endif // return type
 
-			if(Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;insert((int) Z_LVAL_P(z_0), (const QString&amp;) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* lol public*/
 
-		/* int i, const QChar* uc, int len,  */
+  ///int i, const QChar *uc, int len
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_1), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'insert' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int i, const QChar *uc, int len,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_1 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_1)-&gt;name == &quot;char&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;insert((int) Z_LVAL_P(z_0), (const QChar*) obj_z_1, (int) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;insert((int)Z_LVAL_P(arg_0), (const QChar *)cpp_arg_1, (int)Z_LVAL_P(arg_2)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///int i, const QString &amp;s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'insert' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int i, const QString &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;insert((int)Z_LVAL_P(arg_0), (const QString &amp;)*cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///int i, const QLatin1String &amp;s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_1), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'insert' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int i, const QLatin1String &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_1 = static_cast &lt; QLatin1String * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;insert((int)Z_LVAL_P(arg_0), (const QLatin1String &amp;)*cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::insert(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  clear
- *    flags:    
+/*!
+ * method clear
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, clear){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			obj-&gt;clear();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QString, clear)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'clear' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;clear());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::clear(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  setUtf16
- *    flags:    
+/*!
+ * method setUtf16
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const ushort *utf16s0
+ * @param	 int sizes1
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
  */
-ZEND_METHOD(QString, setUtf16){
-		/* ol public*/
 
-		/* const ushort* utf16, int size,  */
+ZEND_METHOD(QString, setUtf16)
+{
+  ///const ushort *utf16s0, int sizes1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setUtf16' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try const ushort *utf16s0, int sizes1,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString &amp; return_object = (QString &amp;) obj-&gt;setUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setUtf16((const ushort *)&amp;Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::setUtf16(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  prepend
- *    flags:    
+/*!
+ * method prepend
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;s
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;s
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
  */
-ZEND_METHOD(QString, prepend){
-		/* l public*/
 
-		/* char c,  */
-		/* s public*/
+ZEND_METHOD(QString, prepend)
+{
+  ///QChar cs0
+#ifdef PHP_QT_QString           // return type
 
-		/* const char* s,  */
-		/* o public*/
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'prepend' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
-		/* const QString&amp; s,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
 
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;prepend((QChar) * cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-				QString &amp; return_object = (QString &amp;) obj-&gt;prepend((char) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_STRING){
-			QString *obj = (QString*) PHP_QT_FETCH();
+    }
+  }
+#endif // return type
 
 
-				QString &amp; return_object = (QString &amp;) obj-&gt;prepend( (const char*) Z_STRVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  ///const QString &amp;s
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;prepend((const QString&amp;) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QByteArray&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;prepend((const QByteArray&amp;) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'prepend' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;prepend((const QString &amp;)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QLatin1String &amp;s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'prepend' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_0 = static_cast &lt; QLatin1String * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;prepend((const QLatin1String &amp;)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const char *s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'prepend' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try const char *s,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;prepend((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const QByteArray &amp;s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QByteArray
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'prepend' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QByteArray &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QByteArray *cpp_arg_0 = static_cast &lt; QByteArray * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;prepend((const QByteArray &amp;)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::prepend(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  trimmed
- *    flags:    c
+/*!
+ * method grow
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	private
+ * @return	int
+ * @flags	s
  */
-ZEND_METHOD(QString, trimmed){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;trimmed();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, grow)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QString::grow(...) cannot be called with 'int ints0,'.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::grow(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  chop
- *    flags:    
+/*!
+ * method trimmed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, chop){
-		/* l public*/
 
-		/* int n,  */
+ZEND_METHOD(QString, trimmed)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'trimmed' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;chop((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trimmed());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::trimmed(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  leftJustified
- *    flags:    c
+/*!
+ * method chop
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ns0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, leftJustified){
-		/* lll public*/
 
-		/* int width, char fill, int trunc,  */
+ZEND_METHOD(QString, chop)
+{
+  ///int ns0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'chop' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ns0,
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;chop((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::chop(...) &quot;);
+}
 
+/*!
+ * method leftJustified
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int widths0
+ * @param	 QChar fill = QLatin1Char(' ')s1
+ * @param	 bool trunc = falses2
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-				QString return_object = (QString) obj-&gt;leftJustified((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(bool) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+ZEND_METHOD(QString, leftJustified)
+{
+  ///int widths0, QChar fill = QLatin1Char(' ')s1, bool trunc = falses2
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'leftJustified' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int widths0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;leftJustified((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'leftJustified' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int widths0, QChar fill = QLatin1Char(' ')s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_1 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_1));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;leftJustified((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'leftJustified' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int widths0, QChar fill = QLatin1Char(' ')s1, bool trunc = falses2,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_1 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_1));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;leftJustified((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1, (bool) Z_LVAL_P(arg_2)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::leftJustified(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  squeeze
- *    flags:    
+/*!
+ * method squeeze
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, squeeze){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			obj-&gt;squeeze();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QString, squeeze)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'squeeze' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;squeeze());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::squeeze(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  count
- *    flags:    c
+/*!
+ * method count
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar c
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &amp;
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QString, count){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;count());
-	}
-		/* o public*/
 
-		/* const QRegExp&amp; ,  */
+ZEND_METHOD(QString, count)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'count' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;count());
+    }
+  }
+  ///QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'count' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar c,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRegExp&quot;) {
-				RETURN_LONG(obj-&gt;count((const QRegExp&amp;) obj_z_0));
-			}
-			}
-		}
-	}
-		/* ol public*/
+        RETURN_LONG(selfpointer-&gt;count((QChar) * cpp_arg_0));
+      }
+#endif
 
-		/* const QString&amp; s, int cs,  */
-		/* ll public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'count' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
 
-		/* char c, int cs,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        RETURN_LONG(selfpointer-&gt;count((QChar) * cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
 
+    }
+  }
+  ///const QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				RETURN_LONG(obj-&gt;count((const QString&amp;) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1)));
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'count' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			RETURN_LONG(obj-&gt;count((char) Z_LVAL_P(z_0) ,(Qt::CaseSensitivity) Z_LVAL_P(z_1)));
-			}
-		}
-	}
-}
+        RETURN_LONG(selfpointer-&gt;count((const QString &amp;)*cpp_arg_0));
+      }
+#endif
 
-/*********************************
- *    class     QString */
-/*
- *    function  fromAscii
- *    flags:    s
- */
-ZEND_METHOD(QString, fromAscii){
-		/* sl public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'count' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
 
-		/* const char* , int size,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        RETURN_LONG(selfpointer-&gt;count((const QString &amp;)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
 
+    }
+  }
+  ///const QRegExp &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'count' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegExp &amp;,
+        QString *selfpointer;
 
-				QString return_object = (QString) obj-&gt;fromAscii( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast &lt; QRegExp * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;count((const QRegExp &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::count(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toLongLong
- *    flags:    c
+/*!
+ * method fromAscii
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *s0
+ * @param	 int size = -1s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, toLongLong){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, fromAscii)
+{
+  ///const char *s0, int size = -1s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;toLongLong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::fromAscii((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;fromAscii((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try const char *s0, int size = -1s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::fromAscii((const char *)&amp;Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;fromAscii((const char *)&amp;Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::fromAscii(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toUpper
- *    flags:    c
+/*!
+ * method toLongLong
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	qlonglong
+ * @flags	c
  */
-ZEND_METHOD(QString, toUpper){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;toUpper();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, toLongLong)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type qlonglong&quot;);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      php_error(E_ERROR, &quot;unsupported return type qlonglong&quot;);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      php_error(E_ERROR, &quot;unsupported return type qlonglong&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::toLongLong(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  QString
- *    flags:    
+/*!
+ * method toUpper
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *QString_ptr = new QString();
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-	}
-		/* l public*/
 
-		/* char c,  */
-		/* s public*/
+ZEND_METHOD(QString, toUpper)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-		/* const char* ch,  */
-		/* o public*/
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toUpper' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-		/* const QLatin1String&amp; latin1,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toUpper());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-			QString *QString_ptr = new QString((char) Z_LVAL_P(z_0));
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_STRING){
+  php_error(E_ERROR, &quot;could not parse argument in QString::toUpper(...) &quot;);
+}
 
+/*!
+ * method QString
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QChar *unicodes0
+ * @param	int sizes1
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	int sizes0
+ * @param	QChar cs1
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;latin1s0
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * overloaded args:
+ * @param	const char *chs0
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;as0
+ * 
+ * overloaded args:
+ * @param	const Null &amp;s0
+ * 
+ * overloaded args:
+ * @param	const char *ch
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;a
+ * 
+ * overloaded args:
+ * @param	Data *dd
+ * @param	 int
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-			QString *QString_ptr = new QString( (const char*) Z_STRVAL_P(z_0));
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QString, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString_php_qt *selfpointer = new QString_php_qt(getThis());
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QChar *unicodes0,int sizes1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QChar *unicodes0,int sizes1,
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const QChar *)cpp_arg_0, (int)Z_LVAL_P(arg_1));
 
-			if(obj_z_0-&gt;inherits(&quot;QLatin1String&quot;)) {
-				QString *QString_ptr = new QString((const QLatin1String&amp;) obj_z_0);
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				QString *QString_ptr = new QString((const QString&amp;) obj_z_0);
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QByteArray&quot;) {
-				QString *QString_ptr = new QString((const QByteArray&amp;) obj_z_0);
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			if(obj_z_0-&gt;inherits(&quot;Null&quot;)) {
-				QString *QString_ptr = new QString((const Null&amp;) obj_z_0);
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ol public*/
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-		/* const QChar* unicode, int size,  */
-		/* ll public*/
+    }
+  }
+  ///QChar cs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (QChar) * cpp_arg_0);
 
-		/* int size, char c,  */
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    }
+  }
+  ///int sizes0,QChar cs1
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_1), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int sizes0,QChar cs1,
+        QChar *cpp_arg_1 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_1));
+        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;char&quot;) {
-				QString *QString_ptr = new QString((const QChar*) obj_z_0, (int) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+    }
+  }
+  ///const QLatin1String &amp;latin1s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &amp;latin1s0,
+        QLatin1String *cpp_arg_0 = static_cast &lt; QLatin1String * &gt;(php_qt_fetch(arg_0));
+        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const QLatin1String &amp;)*cpp_arg_0);
 
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-			QString *QString_ptr = new QString((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
-}
+    }
+  }
+  ///const QString &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-/*********************************
- *    class     QString */
-/*
- *    function  normalized
- *    flags:    c
- */
-ZEND_METHOD(QString, normalized){
-		/* o public*/
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const QString &amp;)*cpp_arg_0);
 
-		/* QString::NormalizationForm mode,  */
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+    }
+  }
+  ///const char *chs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try const char *chs0,
+      QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const char *)&amp;Z_STRVAL_P(arg_0)[0]);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QByteArray &amp;as0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QByteArray
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QByteArray &amp;as0,
+        QByteArray *cpp_arg_0 = static_cast &lt; QByteArray * &gt;(php_qt_fetch(arg_0));
+        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const QByteArray &amp;)*cpp_arg_0);
 
-				QString return_object = (QString) obj-&gt;normalized((QString::NormalizationForm) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
-		/* ol public*/
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-		/* QString::NormalizationForm mode, int version,  */
+    }
+  }
+// notice: unknown argument const Null &amp;s0, skipped
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  ///const char *ch
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QString::__construct(...) cannot be called with 'const char *ch,'.&quot;);
+    }
+  }
+  ///const QByteArray &amp;a
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QByteArray
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QString::__construct(...) cannot be called with 'const QByteArray &amp;a,'.&quot;);
+      }
+#endif
 
+    }
+  }
+// notice: unknown argument Data *dd, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QString::QString(...) &quot;);
+}
 
-				QString return_object = (QString) obj-&gt;normalized((QString::NormalizationForm) Z_LVAL_P(z_0) ,(QChar::UnicodeVersion) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+/*!
+ * method normalized
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	NormalizationForm modes0
+ * 
+ * overloaded args:
+ * @param	NormalizationForm mode
+ * @param	 QChar::UnicodeVersion version
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
+
+ZEND_METHOD(QString, normalized)
+{
+// notice: unknown argument NormalizationForm modes0, skipped
+
+// notice: unknown argument NormalizationForm mode, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QString::normalized(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  fromUtf16
- *    flags:    s
+/*!
+ * method fromUtf16
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const ushort *s0
+ * @param	 int size = -1s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, fromUtf16){
-		/* ol public*/
 
-		/* const ushort* , int size,  */
+ZEND_METHOD(QString, fromUtf16)
+{
+  ///const ushort *s0, int size = -1s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try const ushort *s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj-&gt;fromUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::fromUtf16((const ushort *)&amp;Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;fromUtf16((const ushort *)&amp;Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try const ushort *s0, int size = -1s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::fromUtf16((const ushort *)&amp;Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;fromUtf16((const ushort *)&amp;Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::fromUtf16(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  isRightToLeft
- *    flags:    c
+/*!
+ * method isRightToLeft
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, isRightToLeft){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isRightToLeft());
-	}
+
+ZEND_METHOD(QString, isRightToLeft)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isRightToLeft' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isRightToLeft());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::isRightToLeft(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  setNum
- *    flags:    
+/*!
+ * method setNum
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	short shorts0
+ * @param	 int base=10s1
+ * 
+ * overloaded args:
+ * @param	ushort
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	int
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	uint
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	long
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	ulong
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	qlonglong
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	qulonglong
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	float
+ * @param	 char f='g'
+ * @param	 int prec=6
+ * 
+ * overloaded args:
+ * @param	double
+ * @param	 char f='g'
+ * @param	 int prec=6
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
  */
-ZEND_METHOD(QString, setNum){
-		/* ol public*/
 
-		/* short , int base,  */
+ZEND_METHOD(QString, setNum)
+{
+  ///short shorts0, int base=10s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try short shorts0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString &amp; return_object = (QString &amp;) obj-&gt;setNum((short) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
-		/* oll public*/
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
 
-		/* float , char f, int prec,  */
-		/* lll public*/
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((short)Z_LVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try short shorts0, int base=10s1,
+      QString *selfpointer;
 
-		/* double , char f, int prec,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
 
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((short)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-				QString &amp; return_object = (QString &amp;) obj-&gt;setNum((float) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
 
+  ///ushort, int base=10
+#ifdef PHP_QT_QString           // return type
 
-				QString &amp; return_object = (QString &amp;) obj-&gt;setNum((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try ushort,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((ushort) Z_LVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try ushort, int base=10,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((ushort) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///int, int base=10
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((int)Z_LVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int, int base=10,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///uint, int base=10
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try uint,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((uint) Z_LVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try uint, int base=10,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+// notice: unknown argument long, skipped
+
+// notice: unknown argument ulong, skipped
+
+// notice: unknown argument qlonglong, skipped
+
+// notice: unknown argument qulonglong, skipped
+
+  ///float, char f='g', int prec=6
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try float,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((float)Z_DVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try float, char f='g',
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((float)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0]));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try float, char f='g', int prec=6,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((float)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0], (int)Z_LVAL_P(arg_2)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///double, char f='g', int prec=6
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try double,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((double)Z_DVAL_P(arg_0)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try double, char f='g',
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0]));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setNum' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try double, char f='g', int prec=6,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setNum((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0], (int)Z_LVAL_P(arg_2)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::setNum(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  endsWith
- *    flags:    c
+/*!
+ * method operator[]
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * 
+ * overloaded args:
+ * @param	int i
+ * 
+ * overloaded args:
+ * @param	uint i
+ * 
+ * overloaded args:
+ * @param	uint i
+ * 
+ * @access	public
+ * @return	const QChar
+ * @flags	c
  */
-ZEND_METHOD(QString, endsWith){
-		/* ol public*/
 
-		/* const QString&amp; s, int cs,  */
+/*!
+ * method endsWith
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives1
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;s
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QChar &amp;c
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QString, endsWith)
+{
+  ///const QString &amp;ss0, Qt::CaseSensitivity cs = Qt::CaseSensitives1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'endsWith' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;ss0,
+        QString *selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				RETURN_BOOL(obj-&gt;endsWith((const QString&amp;) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1)));
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;char&quot;) {
-				RETURN_BOOL(obj-&gt;endsWith((const QChar&amp;) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1)));
-			}
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;endsWith((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'endsWith' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;ss0, Qt::CaseSensitivity cs = Qt::CaseSensitives1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;endsWith((const QString &amp;)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QLatin1String &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'endsWith' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_0 = static_cast &lt; QLatin1String * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;endsWith((const QLatin1String &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'endsWith' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_0 = static_cast &lt; QLatin1String * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;endsWith((const QLatin1String &amp;)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QChar &amp;c, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'endsWith' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QChar &amp;c,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;endsWith((const QChar &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'endsWith' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QChar &amp;c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;endsWith((const QChar &amp;)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::endsWith(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  number
- *    flags:    s
+/*!
+ * method number
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * @param	 int base=10s1
+ * 
+ * overloaded args:
+ * @param	uint
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	long
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	ulong
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	qlonglong
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	qulonglong
+ * @param	 int base=10
+ * 
+ * overloaded args:
+ * @param	double
+ * @param	 char f='g'
+ * @param	 int prec=6
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, number){
-		/* ol public*/
 
-		/* unsigned long , int base,  */
-		/* ll public*/
+ZEND_METHOD(QString, number)
+{
+  ///int ints0, int base=10s1
+#ifdef PHP_QT_QString           // return type
 
-		/* int , int base,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try int ints0,
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-				QString return_object = (QString) obj-&gt;number((ulong) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::number((int)Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;number((int)Z_LVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try int ints0, int base=10s1,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj-&gt;number((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
-		/* lll public*/
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-		/* double , char f, int prec,  */
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::number((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;number((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
 
+  ///uint, int base=10
+#ifdef PHP_QT_QString           // return type
 
-				QString return_object = (QString) obj-&gt;number((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      /// try uint,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::number((uint) Z_LVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;number((uint) Z_LVAL_P(arg_0)));
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try uint, int base=10,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::number((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;number((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+// notice: unknown argument long, skipped
+
+// notice: unknown argument ulong, skipped
+
+// notice: unknown argument qlonglong, skipped
+
+// notice: unknown argument qulonglong, skipped
+
+  ///double, char f='g', int prec=6
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      /// try double,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::number((double)Z_DVAL_P(arg_0)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;number((double)Z_DVAL_P(arg_0)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try double, char f='g',
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::number((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;number((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      /// try double, char f='g', int prec=6,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::number((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0], (int)Z_LVAL_P(arg_2)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;number((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0], (int)Z_LVAL_P(arg_2)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::number(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  localeAwareCompare
- *    flags:    c
+/*!
+ * method localeAwareCompare
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp; ss0
+ * 
+ * overloaded args:
+ * @param	const QString&amp; s1
+ * @param	 const QString&amp; s2
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QString, localeAwareCompare){
-		/* o public*/
 
-		/* const QString&amp; s,  */
+ZEND_METHOD(QString, localeAwareCompare)
+{
+  ///const QString &amp; ss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'localeAwareCompare' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp; ss0,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				RETURN_LONG(obj-&gt;localeAwareCompare((const QString&amp;) obj_z_0));
-			}
-			}
-		}
-	}
-		/* oo public*/
+        RETURN_LONG(selfpointer-&gt;localeAwareCompare((const QString &amp;)*cpp_arg_0));
+      }
+#endif
 
-		/* const QString&amp; s1, const QString&amp; s2,  */
+    }
+  }
+  ///const QString&amp; s1, const QString&amp; s2
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        /// try const QString&amp; s1, const QString&amp; s2,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot;) {
-				RETURN_LONG(obj-&gt;localeAwareCompare((const QString&amp;) obj_z_0, (const QString&amp;) obj_z_1));
-			}
-			}
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_LONG(QString::localeAwareCompare((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        } else {
+          RETURN_LONG(selfpointer-&gt;localeAwareCompare((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+      }}
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::localeAwareCompare(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  section
- *    flags:    c
+/*!
+ * method section
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar seps0
+ * @param	 int starts1
+ * @param	 int end = -1s2
+ * @param	 SectionFlags flags = SectionDefaults3
+ * 
+ * overloaded args:
+ * @param	const QString &amp;in_sep
+ * @param	 int start
+ * @param	 int end = -1
+ * @param	 SectionFlags flags = SectionDefault
+ * 
+ * overloaded args:
+ * @param	const QRegExp &amp;reg
+ * @param	 int start
+ * @param	 int end = -1
+ * @param	 SectionFlags flags = SectionDefault
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, section){
-		/* lllo public*/
 
-		/* char sep, int start, int end, QString::SectionFlags flags,  */
-		/* ollo public*/
+ZEND_METHOD(QString, section)
+{
+  ///QChar seps0, int starts1, int end = -1s2, SectionFlags flags = SectionDefaults3
+#ifdef PHP_QT_QString           // return type
 
-		/* const QString&amp; in_sep, int start, int end, QString::SectionFlags flags,  */
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'section' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar seps0, int starts1,
+        QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
 
-				QString return_object = (QString) obj-&gt;section((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(QString::SectionFlags) Z_LVAL_P(z_3));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;section((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'section' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar seps0, int starts1, int end = -1s2,
+        QString *selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QString return_object = (QString) obj-&gt;section((const QString&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (QString::SectionFlags) Z_LVAL_P(z_3));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRegExp&quot;) {
-					QString return_object = (QString) obj-&gt;section((const QRegExp&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (QString::SectionFlags) Z_LVAL_P(z_3));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;section((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument  SectionFlags flags = SectionDefaults3, skipped
+#endif // return type
+
+
+  ///const QString &amp;in_sep, int start, int end = -1, SectionFlags flags = SectionDefault
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'section' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;in_sep, int start,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;section((const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'section' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;in_sep, int start, int end = -1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;section((const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument  SectionFlags flags = SectionDefault, skipped
+#endif // return type
+
+
+  ///const QRegExp &amp;reg, int start, int end = -1, SectionFlags flags = SectionDefault
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'section' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegExp &amp;reg, int start,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast &lt; QRegExp * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;section((const QRegExp &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'section' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegExp &amp;reg, int start, int end = -1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast &lt; QRegExp * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;section((const QRegExp &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument  SectionFlags flags = SectionDefault, skipped
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::section(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  isSimpleText
- *    flags:    c
+/*!
+ * method operator&lt;
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;s
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;s
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, isSimpleText){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isSimpleText());
-	}
+
+/*!
+ * method isSimpleText
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
+ZEND_METHOD(QString, isSimpleText)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isSimpleText' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isSimpleText());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::isSimpleText(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  size
- *    flags:    c
+/*!
+ * method operator==
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;s
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;s
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, size){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;size());
-	}
+
+/*!
+ * method size
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QString, size)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'size' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;size());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::size(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  simplified
- *    flags:    c
+/*!
+ * method updateProperties
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	private
+ * @return	void
+ * @flags	c
  */
-ZEND_METHOD(QString, simplified){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;simplified();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, updateProperties)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QString::updateProperties(...) cannot be called with ''.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::updateProperties(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toUInt
- *    flags:    c
+/*!
+ * method simplified
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, toUInt){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, simplified)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'simplified' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_LONG(obj-&gt;toUInt((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;simplified());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::simplified(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toUShort
- *    flags:    c
+/*!
+ * method toUInt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	uint
+ * @flags	c
  */
-ZEND_METHOD(QString, toUShort){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, toUInt)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toUInt' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toUInt());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toUInt' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toUInt((bool *) &amp; Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toUInt' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0, int base=10s1,
+      QString *selfpointer;
 
-			RETURN_LONG(obj-&gt;toUShort((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toUInt((bool *) &amp; Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::toUInt(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  truncate
- *    flags:    
+/*!
+ * method toUShort
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	ushort
+ * @flags	c
  */
-ZEND_METHOD(QString, truncate){
-		/* l public*/
 
-		/* int pos,  */
+ZEND_METHOD(QString, toUShort)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toUShort' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toUShort());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toUShort' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toUShort((bool *) &amp; Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toUShort' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0, int base=10s1,
+      QString *selfpointer;
 
-			obj-&gt;truncate((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toUShort((bool *) &amp; Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::toUShort(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toAscii
- *    flags:    c
+/*!
+ * method truncate
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int poss0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, toAscii){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj-&gt;toAscii(), 1);
-	}
-}
 
-/*********************************
- *    class     QString */
-/*
- *    function  length
- *    flags:    c
- */
-ZEND_METHOD(QString, length){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;length());
-	}
+ZEND_METHOD(QString, truncate)
+{
+  ///int poss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'truncate' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int poss0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;truncate((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::truncate(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  right
- *    flags:    c
+/*!
+ * method toAscii
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QByteArray
+ * @flags	c
  */
-ZEND_METHOD(QString, right){
-		/* l public*/
 
-		/* int len,  */
+ZEND_METHOD(QString, toAscii)
+{
+  ///
+#ifdef PHP_QT_QByteArray        // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toAscii' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj-&gt;right((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QByteArray *return_object = new QByteArray;
+
+      *return_object = static_cast &lt; QByteArray &gt; (selfpointer-&gt;toAscii());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::toAscii(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  push_front
- *    flags:    
+/*!
+ * method right
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int lens0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, push_front){
-		/* l public*/
 
-		/* char c,  */
-		/* o public*/
+ZEND_METHOD(QString, right)
+{
+  ///int lens0
+#ifdef PHP_QT_QString           // return type
 
-		/* const QString&amp; s,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'right' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int lens0,
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-			obj-&gt;push_front((char) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;right((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
+  php_error(E_ERROR, &quot;could not parse argument in QString::right(...) &quot;);
+}
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				obj-&gt;push_front((const QString&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+/*!
+ * method length
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QString, length)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'length' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;length());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::length(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toUtf8
- *    flags:    c
+/*!
+ * method expand
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * 
+ * @access	private
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, toUtf8){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj-&gt;toUtf8(), 1);
-	}
+
+ZEND_METHOD(QString, expand)
+{
+  ///int is0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QString::expand(...) cannot be called with 'int is0,'.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::expand(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toULongLong
- *    flags:    c
+/*!
+ * method push_front
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, toULongLong){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, push_front)
+{
+  ///QChar cs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'push_front' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;push_front((QChar) * cpp_arg_0));
+      }
+#endif
 
-			obj-&gt;toULongLong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
+    }
+  }
+  ///const QString &amp;s
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'push_front' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;push_front((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::push_front(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  indexOf
- *    flags:    c
+/*!
+ * method toUtf8
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QByteArray
+ * @flags	c
  */
-ZEND_METHOD(QString, indexOf){
-		/* ol public*/
 
-		/* const QRegExp&amp; , int from,  */
+ZEND_METHOD(QString, toUtf8)
+{
+  ///
+#ifdef PHP_QT_QByteArray        // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toUtf8' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRegExp&quot;) {
-				RETURN_LONG(obj-&gt;indexOf((const QRegExp&amp;) obj_z_0, (int) Z_LVAL_P(z_1)));
-			}
-			}
-		}
-	}
-		/* oll public*/
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QByteArray *return_object = new QByteArray;
 
-		/* const QString&amp; s, int from, int cs,  */
-		/* lll public*/
+      *return_object = static_cast &lt; QByteArray &gt; (selfpointer-&gt;toUtf8());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-		/* char c, int from, int cs,  */
+  php_error(E_ERROR, &quot;could not parse argument in QString::toUtf8(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+/*!
+ * method toULongLong
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	qulonglong
+ * @flags	c
+ */
 
+ZEND_METHOD(QString, toULongLong)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type qulonglong&quot;);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      php_error(E_ERROR, &quot;unsupported return type qulonglong&quot;);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      php_error(E_ERROR, &quot;unsupported return type qulonglong&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::toULongLong(...) &quot;);
+}
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				RETURN_LONG(obj-&gt;indexOf((const QString&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (Qt::CaseSensitivity) Z_LVAL_P(z_2)));
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+/*!
+ * method indexOf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * @param	 int from = 0s1
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives2
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * @param	 int from = 0
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &amp;
+ * @param	 int from = 0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QString, indexOf)
+{
+  ///QChar cs0, int from = 0s1, Qt::CaseSensitivity cs = Qt::CaseSensitives2
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'indexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
-			RETURN_LONG(obj-&gt;indexOf((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(Qt::CaseSensitivity) Z_LVAL_P(z_2)));
-			}
-		}
-	}
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;indexOf((QChar) * cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'indexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0, int from = 0s1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;indexOf((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'indexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0, int from = 0s1, Qt::CaseSensitivity cs = Qt::CaseSensitives2,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;indexOf((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  ///const QString &amp;s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'indexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;indexOf((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'indexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s, int from = 0,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;indexOf((const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'indexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;indexOf((const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  ///const QRegExp &amp;, int from = 0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'indexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegExp &amp;,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast &lt; QRegExp * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;indexOf((const QRegExp &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'indexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegExp &amp;, int from = 0,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast &lt; QRegExp * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;indexOf((const QRegExp &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::indexOf(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  fromRawData
- *    flags:    s
+/*!
+ * method fromRawData
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QChar *s0
+ * @param	 int sizes1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, fromRawData){
-		/* ol public*/
 
-		/* const QChar* , int size,  */
+ZEND_METHOD(QString, fromRawData)
+{
+  ///const QChar *s0, int sizes1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        /// try const QChar *s0, int sizes1,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;char&quot;) {
-					QString return_object = (QString) obj-&gt;fromRawData((const QChar*) obj_z_0, (int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QString &gt; (QString::fromRawData((const QChar *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        } else {
+          *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;fromRawData((const QChar *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::fromRawData(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  constEnd
- *    flags:    c
+/*!
+ * method constEnd
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const_iterator
+ * @flags	c
  */
-ZEND_METHOD(QString, constEnd){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			obj-&gt;constEnd();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QString, constEnd)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type const_iterator&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::constEnd(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  left
- *    flags:    c
+/*!
+ * method left
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int lens0
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, left){
-		/* l public*/
 
-		/* int len,  */
+ZEND_METHOD(QString, left)
+{
+  ///int lens0
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'left' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int lens0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj-&gt;left((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;left((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::left(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  fromLocal8Bit
- *    flags:    s
+/*!
+ * method fromLocal8Bit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *s0
+ * @param	 int size = -1s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, fromLocal8Bit){
-		/* sl public*/
 
-		/* const char* , int size,  */
+ZEND_METHOD(QString, fromLocal8Bit)
+{
+  ///const char *s0, int size = -1s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj-&gt;fromLocal8Bit( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::fromLocal8Bit((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;fromLocal8Bit((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try const char *s0, int size = -1s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::fromLocal8Bit((const char *)&amp;Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;fromLocal8Bit((const char *)&amp;Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::fromLocal8Bit(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  startsWith
- *    flags:    c
+/*!
+ * method remove
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * @param	 int lens1
+ * 
+ * overloaded args:
+ * @param	QChar c
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &amp;rx
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
  */
-ZEND_METHOD(QString, startsWith){
-		/* ol public*/
 
-		/* const QString&amp; s, int cs,  */
+ZEND_METHOD(QString, remove)
+{
+  ///int is0, int lens1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'remove' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int is0, int lens1,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				RETURN_BOOL(obj-&gt;startsWith((const QString&amp;) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1)));
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;char&quot;) {
-				RETURN_BOOL(obj-&gt;startsWith((const QChar&amp;) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1)));
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;remove((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'remove' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar c,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;remove((QChar) * cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'remove' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;remove((QChar) * cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'remove' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;remove((const QString &amp;)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'remove' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;remove((const QString &amp;)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QRegExp &amp;rx
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'remove' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegExp &amp;rx,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast &lt; QRegExp * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;remove((const QRegExp &amp;)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::remove(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  remove
- *    flags:    
+/*!
+ * method startsWith
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives1
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;s
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QChar &amp;c
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, remove){
-		/* o public*/
 
-		/* const QRegExp&amp; rx,  */
+ZEND_METHOD(QString, startsWith)
+{
+  ///const QString &amp;ss0, Qt::CaseSensitivity cs = Qt::CaseSensitives1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'startsWith' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;ss0,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRegExp&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;remove((const QRegExp&amp;) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* ol public*/
+        RETURN_BOOL(selfpointer-&gt;startsWith((const QString &amp;)*cpp_arg_0));
+      }
+#endif
 
-		/* const QString&amp; s, int cs,  */
-		/* ll public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'startsWith' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;ss0, Qt::CaseSensitivity cs = Qt::CaseSensitives1,
+        QString *selfpointer;
 
-		/* int i, int len,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        RETURN_BOOL(selfpointer-&gt;startsWith((const QString &amp;)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
 
+    }
+  }
+  ///const QLatin1String &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'startsWith' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &amp;s,
+        QString *selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;remove((const QString&amp;) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_0 = static_cast &lt; QLatin1String * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_BOOL(selfpointer-&gt;startsWith((const QLatin1String &amp;)*cpp_arg_0));
+      }
+#endif
 
-				QString &amp; return_object = (QString &amp;) obj-&gt;remove((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'startsWith' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_0 = static_cast &lt; QLatin1String * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;startsWith((const QLatin1String &amp;)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  ///const QChar &amp;c, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'startsWith' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QChar &amp;c,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;startsWith((const QChar &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'startsWith' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QChar &amp;c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_BOOL(selfpointer-&gt;startsWith((const QChar &amp;)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::startsWith(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  isEmpty
- *    flags:    c
+/*!
+ * method operator!=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;s
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;s
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, isEmpty){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isEmpty());
-	}
-}
 
-/*********************************
- *    class     QString */
-/*
- *    function  arg
- *    flags:    c
+/*!
+ * method arg
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	qlonglong as0
+ * @param	 int fieldwidth=0s1
+ * @param	 int base=10s2
+ * @param	 const QChar &amp;fillChar = QLatin1Char(' ')s3
+ * 
+ * overloaded args:
+ * @param	qulonglong a
+ * @param	 int fieldwidth=0
+ * @param	 int base=10
+ * @param	 const QChar &amp;fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	long a
+ * @param	 int fieldwidth=0
+ * @param	 int base=10
+ * @param	 const QChar &amp;fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	ulong a
+ * @param	 int fieldwidth=0
+ * @param	 int base=10
+ * @param	 const QChar &amp;fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	int a
+ * @param	 int fieldWidth = 0
+ * @param	 int base = 10
+ * @param	 const QChar &amp;fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	uint a
+ * @param	 int fieldWidth = 0
+ * @param	 int base = 10
+ * @param	 const QChar &amp;fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	short a
+ * @param	 int fieldWidth = 0
+ * @param	 int base = 10
+ * @param	 const QChar &amp;fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	ushort a
+ * @param	 int fieldWidth = 0
+ * @param	 int base = 10
+ * @param	 const QChar &amp;fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	double a
+ * @param	 int fieldWidth = 0
+ * @param	 char fmt = 'g'
+ * @param	 int prec = -1
+ * @param	 const QChar &amp;fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	char a
+ * @param	 int fieldWidth = 0
+ * @param	 const QChar &amp;fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	QChar a
+ * @param	 int fieldWidth = 0
+ * @param	 const QChar &amp;fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	const QString &amp;a
+ * @param	 int fieldWidth = 0
+ * @param	 const QChar &amp;fillChar = QLatin1Char(' ')
+ * 
+ * overloaded args:
+ * @param	const QString &amp;a1
+ * @param	 const QString &amp;a2
+ * 
+ * overloaded args:
+ * @param	const QString &amp;a1
+ * @param	 const QString &amp;a2
+ * @param	 const QString &amp;a3
+ * 
+ * overloaded args:
+ * @param	const QString &amp;a1
+ * @param	 const QString &amp;a2
+ * @param	 const QString &amp;a3
+ * @param	 const QString &amp;a4
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, arg){
-		/* oo public*/
 
-		/* const QString&amp; a1, const QString&amp; a2,  */
+ZEND_METHOD(QString, arg)
+{
+// notice: unknown argument qlonglong as0, skipped
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+// notice: unknown argument qulonglong a, skipped
 
+// notice: unknown argument long a, skipped
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot;) {
-					QString return_object = (QString) obj-&gt;arg((const QString&amp;) obj_z_0, (const QString&amp;) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* ooo public*/
+// notice: unknown argument ulong a, skipped
 
-		/* const QString&amp; a1, const QString&amp; a2, const QString&amp; a3,  */
-		/* olo public*/
+  ///int a, int fieldWidth = 0, int base = 10, const QChar &amp;fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
 
-		/* const QString&amp; a, int fieldWidth, const QChar&amp; fillChar,  */
-		/* llo public*/
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int a,
+      QString *selfpointer;
 
-		/* char a, int fieldWidth, const QChar&amp; fillChar,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int a, int fieldWidth = 0,
+      QString *selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_2)-&gt;name == &quot;QString&quot;) {
-					QString return_object = (QString) obj-&gt;arg((const QString&amp;) obj_z_0, (const QString&amp;) obj_z_1, (const QString&amp;) obj_z_2);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_2)-&gt;name == &quot;char&quot;) {
-					QString return_object = (QString) obj-&gt;arg((const QString&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (const QChar&amp;) obj_z_2);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int a, int fieldWidth = 0, int base = 10,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_2)-&gt;name == &quot;char&quot;) {
-					QString return_object = (QString) obj-&gt;arg((char) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QChar&amp;) obj_z_2);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* lllo public*/
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-		/* int a, int fieldWidth, int base, const QChar&amp; fillChar,  */
-		/* ollo public*/
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int a, int fieldWidth = 0, int base = 10, const QChar &amp;fillChar = QLatin1Char(' '),
+      QString *selfpointer;
 
-		/* qlonglong a, int fieldwidth, int base, const QChar&amp; fillChar,  */
-		/* oooo public*/
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_3 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_3));
+      zend_class_entry *ce;
 
-		/* const QString&amp; a1, const QString&amp; a2, const QString&amp; a3, const QString&amp; a4,  */
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_3 = (QObject*) php_qt_fetch(z_3);
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (const QChar &amp;)*cpp_arg_3));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
 
-			if(Z_OBJCE_P(z_3)-&gt;name == &quot;char&quot;) {
-					QString return_object = (QString) obj-&gt;arg((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&amp;) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_3 = (QObject*) php_qt_fetch(z_3);
+  ///uint a, int fieldWidth = 0, int base = 10, const QChar &amp;fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try uint a,
+      QString *selfpointer;
 
-			if(Z_OBJCE_P(z_3)-&gt;name == &quot;char&quot;) {
-					QString return_object = (QString) obj-&gt;arg((qlonglong) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&amp;) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_3)-&gt;name == &quot;char&quot;) {
-					QString return_object = (QString) obj-&gt;arg((qulonglong) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&amp;) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_3)-&gt;name == &quot;char&quot;) {
-					QString return_object = (QString) obj-&gt;arg((long) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&amp;) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_3)-&gt;name == &quot;char&quot;) {
-					QString return_object = (QString) obj-&gt;arg((ulong) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&amp;) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_3)-&gt;name == &quot;char&quot;) {
-					QString return_object = (QString) obj-&gt;arg((short) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&amp;) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_3)-&gt;name == &quot;char&quot;) {
-					QString return_object = (QString) obj-&gt;arg((ushort) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (int) Z_LVAL_P(z_2), (const QChar&amp;) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_3) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
-			QObject* obj_z_3 = (QObject*) php_qt_fetch(z_3);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_2)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_3)-&gt;name == &quot;QString&quot;) {
-					QString return_object = (QString) obj-&gt;arg((const QString&amp;) obj_z_0, (const QString&amp;) obj_z_1, (const QString&amp;) obj_z_2, (const QString&amp;) obj_z_3);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* llllo public*/
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((uint) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try uint a, int fieldWidth = 0,
+      QString *selfpointer;
 
-		/* double a, int fieldWidth, char fmt, int prec, const QChar&amp; fillChar,  */
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 5){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		zval *z_4; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_4 = (QObject*) php_qt_fetch(z_4);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try uint a, int fieldWidth = 0, int base = 10,
+      QString *selfpointer;
 
-			if(Z_OBJCE_P(z_4)-&gt;name == &quot;char&quot;) {
-					QString return_object = (QString) obj-&gt;arg((double) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (char) Z_LVAL_P(z_2), (int) Z_LVAL_P(z_3), (const QChar&amp;) obj_z_4);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-/*********************************
- *    class     QString */
-/*
- *    function  vsprintf
- *    flags:    
- */
-ZEND_METHOD(QString, vsprintf){
-		/* so public*/
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-		/* const char* format, va_list ap,  */
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try uint a, int fieldWidth = 0, int base = 10, const QChar &amp;fillChar = QLatin1Char(' '),
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_3 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_3));
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
 
-			if(obj_z_1-&gt;inherits(&quot;va_list&quot;)) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;vsprintf((const char*) Z_LVAL_P(z_0), (va_list) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+      *return_object =
+        static_cast &lt; QString &gt; (selfpointer-&gt;arg((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (const QChar &amp;)*cpp_arg_3));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///short a, int fieldWidth = 0, int base = 10, const QChar &amp;fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try short a,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((short)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try short a, int fieldWidth = 0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((short)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try short a, int fieldWidth = 0, int base = 10,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((short)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try short a, int fieldWidth = 0, int base = 10, const QChar &amp;fillChar = QLatin1Char(' '),
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_3 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_3));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object =
+        static_cast &lt; QString &gt; (selfpointer-&gt;arg((short)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (const QChar &amp;)*cpp_arg_3));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///ushort a, int fieldWidth = 0, int base = 10, const QChar &amp;fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try ushort a,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((ushort) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try ushort a, int fieldWidth = 0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((ushort) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try ushort a, int fieldWidth = 0, int base = 10,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((ushort) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try ushort a, int fieldWidth = 0, int base = 10, const QChar &amp;fillChar = QLatin1Char(' '),
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_3 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_3));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object =
+        static_cast &lt; QString &gt; (selfpointer-&gt;arg((ushort) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (const QChar &amp;)*cpp_arg_3));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///double a, int fieldWidth = 0, char fmt = 'g', int prec = -1, const QChar &amp;fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try double a,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((double)Z_DVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try double a, int fieldWidth = 0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((double)Z_DVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try double a, int fieldWidth = 0, char fmt = 'g',
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((double)Z_DVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (char)Z_STRVAL_P(arg_2)[0]));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_STRING &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try double a, int fieldWidth = 0, char fmt = 'g', int prec = -1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object =
+        static_cast &lt; QString &gt; (selfpointer-&gt;arg((double)Z_DVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (char)Z_STRVAL_P(arg_2)[0], (int)Z_LVAL_P(arg_3)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_DOUBLE &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_STRING &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try double a, int fieldWidth = 0, char fmt = 'g', int prec = -1, const QChar &amp;fillChar = QLatin1Char(' '),
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_4 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_4));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object =
+        static_cast &lt; QString &gt;
+        (selfpointer-&gt;arg((double)Z_DVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (char)Z_STRVAL_P(arg_2)[0], (int)Z_LVAL_P(arg_3), (const QChar &amp;)*cpp_arg_4));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///char a, int fieldWidth = 0, const QChar &amp;fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try char a,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((char)Z_STRVAL_P(arg_0)[0]));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try char a, int fieldWidth = 0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((char)Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try char a, int fieldWidth = 0, const QChar &amp;fillChar = QLatin1Char(' '),
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_2 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_2));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((char)Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1), (const QChar &amp;)*cpp_arg_2));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///QChar a, int fieldWidth = 0, const QChar &amp;fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar a,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((QChar) * cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar a, int fieldWidth = 0,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar a, int fieldWidth = 0, const QChar &amp;fillChar = QLatin1Char(' '),
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        QChar *cpp_arg_2 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_2));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QChar &amp;)*cpp_arg_2));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;a, int fieldWidth = 0, const QChar &amp;fillChar = QLatin1Char(' ')
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;a,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((const QString &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;a, int fieldWidth = 0,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;a, int fieldWidth = 0, const QChar &amp;fillChar = QLatin1Char(' '),
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QChar *cpp_arg_2 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_2));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QChar &amp;)*cpp_arg_2));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;a1, const QString &amp;a2
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;a1, const QString &amp;a2,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;a1, const QString &amp;a2, const QString &amp;a3
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;a1, const QString &amp;a2, const QString &amp;a3,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        QString *cpp_arg_2 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_2));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;arg((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1, (const QString &amp;)*cpp_arg_2));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;a1, const QString &amp;a2, const QString &amp;a3, const QString &amp;a4
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    arg_3 = invokeToQString(arg_3);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_2), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_3), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'arg' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;a1, const QString &amp;a2, const QString &amp;a3, const QString &amp;a4,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        QString *cpp_arg_2 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_2));
+        QString *cpp_arg_3 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_3));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object =
+          static_cast &lt; QString &gt;
+          (selfpointer-&gt;arg((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1, (const QString &amp;)*cpp_arg_2, (const QString &amp;)*cpp_arg_3));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::arg(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toFloat
- *    flags:    c
+/*!
+ * method isEmpty
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, toFloat){
-		/* l public*/
 
-		/* int* ok,  */
+ZEND_METHOD(QString, isEmpty)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isEmpty' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isEmpty());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::isEmpty(...) &quot;);
+}
 
+/*!
+ * method vsprintf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *formats0
+ * @param	 va_list aps1
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
+ */
 
-			RETURN_FLOAT(obj-&gt;toFloat((bool*) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+ZEND_METHOD(QString, vsprintf)
+{
+// notice: unknown argument  va_list aps1, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QString::vsprintf(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  isDetached
- *    flags:    c
+/*!
+ * method toFloat
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * 
+ * @access	public
+ * @return	float
+ * @flags	c
  */
-ZEND_METHOD(QString, isDetached){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isDetached());
-	}
+
+ZEND_METHOD(QString, toFloat)
+{
+  ///bool *ok=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toFloat' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_DOUBLE(selfpointer-&gt;toFloat());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toFloat' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_DOUBLE(selfpointer-&gt;toFloat((bool *) &amp; Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::toFloat(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  reserve
- *    flags:    
+/*!
+ * method operator&gt;
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;s
+ * 
+ * overloaded args:
+ * @param	const char *s2
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;s
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, reserve){
-		/* l public*/
 
-		/* int size,  */
+/*!
+ * method isDetached
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+ZEND_METHOD(QString, isDetached)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isDetached' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-
-			obj-&gt;reserve((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isDetached());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::isDetached(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toULong
- *    flags:    c
+/*!
+ * method toULong
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	ulong
+ * @flags	c
  */
-ZEND_METHOD(QString, toULong){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, toULong)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type ulong&quot;);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      php_error(E_ERROR, &quot;unsupported return type ulong&quot;);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      php_error(E_ERROR, &quot;unsupported return type ulong&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::toULong(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+/*!
+ * method reserve
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int sizes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QString, reserve)
+{
+  ///int sizes0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'reserve' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int sizes0,
+      QString *selfpointer;
 
-			RETURN_ULONG(obj-&gt;toULong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;reserve((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::reserve(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toShort
- *    flags:    c
+/*!
+ * method toShort
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	short
+ * @flags	c
  */
-ZEND_METHOD(QString, toShort){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, toShort)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toShort' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toShort());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toShort' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toShort((bool *) &amp; Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toShort' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0, int base=10s1,
+      QString *selfpointer;
 
-			RETURN_SHORT(obj-&gt;toShort((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toShort((bool *) &amp; Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::toShort(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  split
- *    flags:    c
+/*!
+ * method split
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;seps0
+ * @param	 SplitBehavior behavior = KeepEmptyPartss1
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives2
+ * 
+ * overloaded args:
+ * @param	const QChar &amp;sep
+ * @param	 SplitBehavior behavior = KeepEmptyParts
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &amp;sep
+ * @param	 SplitBehavior behavior = KeepEmptyParts
+ * 
+ * @access	public
+ * @return	QStringList
+ * @flags	c
  */
-ZEND_METHOD(QString, split){
-		/* oo public*/
 
-		/* const QRegExp&amp; sep, QString::SplitBehavior behavior,  */
+ZEND_METHOD(QString, split)
+{
+  ///const QString &amp;seps0, SplitBehavior behavior = KeepEmptyPartss1, Qt::CaseSensitivity cs = Qt::CaseSensitives2
+#ifdef PHP_QT_QStringList       // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'split' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;seps0,
+        QString *selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRegExp&quot;) {
-					QStringList return_object = (QStringList) obj-&gt;split((const QRegExp&amp;) obj_z_0, (QString::SplitBehavior) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* ool public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-		/* const QString&amp; sep, QString::SplitBehavior behavior, int cs,  */
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QStringList *return_object = new QStringList;
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        *return_object = static_cast &lt; QStringList &gt; (selfpointer-&gt;split((const QString &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
+    }
+  }
+// notice: unknown argument  SplitBehavior behavior = KeepEmptyPartss1, skipped
+#endif // return type
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QStringList return_object = (QStringList) obj-&gt;split((const QString&amp;) obj_z_0, (QString::SplitBehavior) Z_LVAL_P(z_1), (Qt::CaseSensitivity) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+
+  ///const QChar &amp;sep, SplitBehavior behavior = KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QStringList       // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'split' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QChar &amp;sep,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QStringList *return_object = new QStringList;
+
+        *return_object = static_cast &lt; QStringList &gt; (selfpointer-&gt;split((const QChar &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument  SplitBehavior behavior = KeepEmptyParts, skipped
+#endif // return type
+
+
+  ///const QRegExp &amp;sep, SplitBehavior behavior = KeepEmptyParts
+#ifdef PHP_QT_QStringList       // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'split' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegExp &amp;sep,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast &lt; QRegExp * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QStringList *return_object = new QStringList;
+
+        *return_object = static_cast &lt; QStringList &gt; (selfpointer-&gt;split((const QRegExp &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+// notice: unknown argument  SplitBehavior behavior = KeepEmptyParts, skipped
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::split(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  setUnicode
- *    flags:    
+/*!
+ * method setUnicode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QChar *unicodes0
+ * @param	 int sizes1
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
  */
-ZEND_METHOD(QString, setUnicode){
-		/* ol public*/
 
-		/* const QChar* unicode, int size,  */
+ZEND_METHOD(QString, setUnicode)
+{
+  ///const QChar *unicodes0, int sizes1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setUnicode' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QChar *unicodes0, int sizes1,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;char&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;setUnicode((const QChar*) obj_z_0, (int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;setUnicode((const QChar *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::setUnicode(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  fromLatin1
- *    flags:    s
+/*!
+ * method fromLatin1
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *s0
+ * @param	 int size = -1s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, fromLatin1){
-		/* sl public*/
 
-		/* const char* , int size,  */
+ZEND_METHOD(QString, fromLatin1)
+{
+  ///const char *s0, int size = -1s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QString return_object = (QString) obj-&gt;fromLatin1( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::fromLatin1((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;fromLatin1((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try const char *s0, int size = -1s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::fromLatin1((const char *)&amp;Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;fromLatin1((const char *)&amp;Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::fromLatin1(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  data
- *    flags:    
+/*!
+ * method toLatin1
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QByteArray
+ * @flags	c
  */
-ZEND_METHOD(QString, data){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				QChar * return_object = (QChar *) obj-&gt;data();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, toLatin1)
+{
+  ///
+#ifdef PHP_QT_QByteArray        // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toLatin1' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QByteArray *return_object = new QByteArray;
+
+      *return_object = static_cast &lt; QByteArray &gt; (selfpointer-&gt;toLatin1());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::toLatin1(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toLatin1
- *    flags:    c
+/*!
+ * method data
+ * 
+ * @param: -
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QChar *
+ * @flags	
  */
-ZEND_METHOD(QString, toLatin1){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj-&gt;toLatin1(), 1);
-	}
+
+ZEND_METHOD(QString, data)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'data' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = static_cast &lt; QChar * &gt;(selfpointer-&gt;data());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'data' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast &lt; QChar * &gt;(selfpointer-&gt;data());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::data(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  end
- *    flags:    
+/*!
+ * method end
+ * 
+ * @param: -
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	iterator
+ * @flags	
  */
-ZEND_METHOD(QString, end){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_INTPTR(obj-&gt;end());
-	}
+
+ZEND_METHOD(QString, end)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type iterator&quot;);
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type const_iterator&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::end(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  contains
- *    flags:    c
+/*!
+ * method contains
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives1
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &amp;rx
+ * 
+ * @access	public
+ * @return	QBool
+ * @flags	c
  */
-ZEND_METHOD(QString, contains){
-		/* o public*/
 
-		/* const QRegExp&amp; rx,  */
+ZEND_METHOD(QString, contains)
+{
+  ///QChar cs0, Qt::CaseSensitivity cs = Qt::CaseSensitives1
+#ifdef PHP_QT_QBool             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'contains' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRegExp&quot;) {
-				obj-&gt;contains((const QRegExp&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
-		/* ol public*/
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QBool *return_object = new QBool;
 
-		/* const QString&amp; s, int cs,  */
-		/* ll public*/
+        *return_object = static_cast &lt; QBool &gt; (selfpointer-&gt;contains((QChar) * cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-		/* char c, int cs,  */
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'contains' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0, Qt::CaseSensitivity cs = Qt::CaseSensitives1,
+        QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QBool *return_object = new QBool;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				obj-&gt;contains((const QString&amp;) obj_z_0, (Qt::CaseSensitivity) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        *return_object = static_cast &lt; QBool &gt; (selfpointer-&gt;contains((QChar) * cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
+    }
+  }
+#endif // return type
 
-			obj-&gt;contains((char) Z_LVAL_P(z_0) ,(Qt::CaseSensitivity) Z_LVAL_P(z_1));
-			RETURN_NULL();
-			}
-		}
-	}
-}
 
-/*********************************
- *    class     QString */
-/*
- *    function  resize
- *    flags:    
- */
-ZEND_METHOD(QString, resize){
-		/* l public*/
+  ///const QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QBool             // return type
 
-		/* int size,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'contains' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-			obj-&gt;resize((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QBool *return_object = new QBool;
+
+        *return_object = static_cast &lt; QBool &gt; (selfpointer-&gt;contains((const QString &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'contains' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QBool *return_object = new QBool;
+
+        *return_object = static_cast &lt; QBool &gt; (selfpointer-&gt;contains((const QString &amp;)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QRegExp &amp;rx
+#ifdef PHP_QT_QBool             // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'contains' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegExp &amp;rx,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast &lt; QRegExp * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QBool *return_object = new QBool;
+
+        *return_object = static_cast &lt; QBool &gt; (selfpointer-&gt;contains((const QRegExp &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::contains(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  replace
- *    flags:    
+/*!
+ * method replace
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * @param	 int lens1
+ * @param	 QChar afters2
+ * 
+ * overloaded args:
+ * @param	int i
+ * @param	 int len
+ * @param	 const QChar *s
+ * @param	 int slen
+ * 
+ * overloaded args:
+ * @param	int i
+ * @param	 int len
+ * @param	 const QString &amp;after
+ * 
+ * overloaded args:
+ * @param	QChar before
+ * @param	 QChar after
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	QChar c
+ * @param	 const QString &amp;after
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QString &amp;before
+ * @param	 const QString &amp;after
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &amp;rx
+ * @param	 const QString &amp;after
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
  */
-ZEND_METHOD(QString, replace){
-		/* oo public*/
 
-		/* const QRegExp&amp; rx, const QString&amp; after,  */
+ZEND_METHOD(QString, replace)
+{
+  ///int is0, int lens1, QChar afters2
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_2), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'replace' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int is0, int lens1, QChar afters2,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_2 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_2));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRegExp&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;replace((const QRegExp&amp;) obj_z_0, (const QString&amp;) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* ool public*/
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
 
-		/* const QString&amp; before, const QString&amp; after, int cs,  */
-		/* lol public*/
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;replace((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (QChar) * cpp_arg_2));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-		/* char c, const QString&amp; after, int cs,  */
-		/* lll public*/
+    }
+  }
+#endif // return type
 
-		/* int i, int len, char after,  */
-		/* llo public*/
 
-		/* int i, int len, const QString&amp; after,  */
+  ///int i, int len, const QChar *s, int slen
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_2), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'replace' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int i, int len, const QChar *s, int slen,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_2 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_2));
+        zend_class_entry *ce;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;replace((const QString&amp;) obj_z_0, (const QString&amp;) obj_z_1, (Qt::CaseSensitivity) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
 
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;replace((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QChar *)cpp_arg_2, (int)Z_LVAL_P(arg_3)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-			if(Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;replace((char) Z_LVAL_P(z_0), (const QString&amp;) obj_z_1, (Qt::CaseSensitivity) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+    }
+  }
+#endif // return type
 
 
-				QString &amp; return_object = (QString &amp;) obj-&gt;replace((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(char) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+  ///int i, int len, const QString &amp;after
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_2 = invokeToQString(arg_2);
 
-			if(Z_OBJCE_P(z_2)-&gt;name == &quot;QString&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;replace((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QString&amp;) obj_z_2);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
-		/* llol public*/
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_2), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'replace' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int i, int len, const QString &amp;after,
+        QString *selfpointer;
 
-		/* int i, int len, const QChar* s, int slen,  */
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_2 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_2));
+        zend_class_entry *ce;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) php_qt_fetch(z_2);
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
 
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;replace((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QString &amp;)*cpp_arg_2));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-			if(Z_OBJCE_P(z_2)-&gt;name == &quot;char&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;replace((int) Z_LVAL_P(z_0), (int) Z_LVAL_P(z_1), (const QChar*) obj_z_2, (int) Z_LVAL_P(z_3));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+    }
+  }
+#endif // return type
+
+
+  ///QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'replace' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar before, QChar after,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        QChar *cpp_arg_1 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;replace((QChar) * cpp_arg_0, (QChar) * cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QChar
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'replace' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        QChar *cpp_arg_1 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;replace((QChar) * cpp_arg_0, (QChar) * cpp_arg_1, (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///QChar c, const QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 6) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'replace' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar c, const QString &amp;after,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;replace((QChar) * cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_1 = invokeToQString(arg_1);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QChar
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 6) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'replace' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar c, const QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;replace((QChar) * cpp_arg_0, (const QString &amp;)*cpp_arg_1, (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;before, const QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'replace' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;before, const QString &amp;after,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;replace((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_1 = invokeToQString(arg_1);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'replace' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;before, const QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr =
+          &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;replace((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1, (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QRegExp &amp;rx, const QString &amp;after
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'replace' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegExp &amp;rx, const QString &amp;after,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast &lt; QRegExp * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;replace((const QRegExp &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::replace(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  fromUtf8
- *    flags:    s
+/*!
+ * method operator+=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	QChar::SpecialCharacter c
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;s
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;s
+ * 
+ * overloaded args:
+ * @param	char c
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;s
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
  */
-ZEND_METHOD(QString, fromUtf8){
-		/* sl public*/
 
-		/* const char* , int size,  */
+/*!
+ * method resize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int sizes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+ZEND_METHOD(QString, resize)
+{
+  ///int sizes0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'resize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int sizes0,
+      QString *selfpointer;
 
-
-				QString return_object = (QString) obj-&gt;fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;resize((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::resize(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toLong
- *    flags:    c
+/*!
+ * method fromUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *s0
+ * @param	 int size = -1s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QString, toLong){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, fromUtf8)
+{
+  ///const char *s0, int size = -1s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try const char *s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_LONG(obj-&gt;toLong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::fromUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;fromUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      /// try const char *s0, int size = -1s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QString::fromUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;fromUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::fromUtf8(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  detach
- *    flags:    
+/*!
+ * method toLong
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	long
+ * @flags	c
  */
-ZEND_METHOD(QString, detach){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			obj-&gt;detach();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QString, toLong)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type long&quot;);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      php_error(E_ERROR, &quot;unsupported return type long&quot;);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      php_error(E_ERROR, &quot;unsupported return type long&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::toLong(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  append
- *    flags:    
+/*!
+ * method realloc
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int alloc
+ * 
+ * @access	private
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QString, append){
-		/* l public*/
 
-		/* char c,  */
-		/* s public*/
+ZEND_METHOD(QString, realloc)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QString::realloc(...) cannot be called with ''.&quot;);
+    }
+  }
+  ///int alloc
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QString::realloc(...) cannot be called with 'int alloc,'.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::realloc(...) &quot;);
+}
 
-		/* const char* s,  */
-		/* o public*/
+/*!
+ * method detach
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-		/* const QString&amp; s,  */
+ZEND_METHOD(QString, detach)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'detach' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;detach());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::detach(...) &quot;);
+}
 
+/*!
+ * method append
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;s
+ * 
+ * overloaded args:
+ * @param	const char *s
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;s
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
+ */
 
-				QString &amp; return_object = (QString &amp;) obj-&gt;append((char) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_STRING){
-			QString *obj = (QString*) PHP_QT_FETCH();
+ZEND_METHOD(QString, append)
+{
+  ///QChar cs0
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'append' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
-				QString &amp; return_object = (QString &amp;) obj-&gt;append( (const char*) Z_STRVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;append((const QString&amp;) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QByteArray&quot;) {
-					QString &amp; return_object = (QString &amp;) obj-&gt;append((const QByteArray&amp;) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;append((QChar) * cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'append' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;append((const QString &amp;)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QLatin1String &amp;s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLatin1String
+      if (inherits(Z_OBJCE_P(arg_0), 40)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'append' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QLatin1String &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QLatin1String *cpp_arg_0 = static_cast &lt; QLatin1String * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;append((const QLatin1String &amp;)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const char *s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'append' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try const char *s,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;append((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const QByteArray &amp;s
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QByteArray
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'append' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QByteArray &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QByteArray *cpp_arg_0 = static_cast &lt; QByteArray * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;append((const QByteArray &amp;)*cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::append(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  mid
- *    flags:    c
+/*!
+ * method operator&lt;=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;s
+ * 
+ * overloaded args:
+ * @param	const char *s2
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;s
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, mid){
-		/* ll public*/
 
-		/* int i, int len,  */
+/*!
+ * method multiArg
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int numArgss0
+ * @param	 const QString **argss1
+ * 
+ * @access	private
+ * @return	QString
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+ZEND_METHOD(QString, multiArg)
+{
+  ///int numArgss0, const QString **argss1
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
 
-				QString return_object = (QString) obj-&gt;mid((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_1), 59)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QString::multiArg(...) cannot be called with 'int numArgss0, const QString **argss1,'.&quot;);
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::multiArg(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toDouble
- *    flags:    c
+/*!
+ * method toDouble
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * 
+ * @access	public
+ * @return	double
+ * @flags	c
  */
-ZEND_METHOD(QString, toDouble){
-		/* l public*/
 
-		/* int* ok,  */
+ZEND_METHOD(QString, toDouble)
+{
+  ///bool *ok=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toDouble' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_DOUBLE(selfpointer-&gt;toDouble());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toDouble' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_DOUBLE(selfpointer-&gt;toDouble((bool *) &amp; Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::toDouble(...) &quot;);
+}
 
-			RETURN_DOUBLE(obj-&gt;toDouble((bool*) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+/*!
+ * method mid
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * @param	 int len = -1s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
+
+ZEND_METHOD(QString, mid)
+{
+  ///int is0, int len = -1s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'mid' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int is0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;mid((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'mid' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int is0, int len = -1s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;mid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::mid(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  fill
- *    flags:    
+/*!
+ * method fill
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * @param	 int size = -1s1
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
  */
-ZEND_METHOD(QString, fill){
-		/* ll public*/
 
-		/* char c, int size,  */
+ZEND_METHOD(QString, fill)
+{
+  ///QChar cs0, int size = -1s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'fill' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-				QString &amp; return_object = (QString &amp;) obj-&gt;fill((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;fill((QChar) * cpp_arg_0));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'fill' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0, int size = -1s1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+
+        le.ptr = &amp;static_cast &lt; QString &amp; &gt;(selfpointer-&gt;fill((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::fill(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  rightJustified
- *    flags:    c
+/*!
+ * method free
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Data *s0
+ * 
+ * @access	private
+ * @return	void
+ * @flags	s
  */
-ZEND_METHOD(QString, rightJustified){
-		/* lll public*/
 
-		/* int width, char fill, int trunc,  */
+ZEND_METHOD(QString, free)
+{
+// notice: unknown argument Data *s0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QString::free(...) &quot;);
+}
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+/*!
+ * method toLower
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
+ZEND_METHOD(QString, toLower)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
-				QString return_object = (QString) obj-&gt;rightJustified((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(bool) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toLower' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toLower());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::toLower(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toLower
- *    flags:    c
+/*!
+ * method rightJustified
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int widths0
+ * @param	 QChar fill = QLatin1Char(' ')s1
+ * @param	 bool trunc = falses2
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QString, toLower){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;toLower();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, rightJustified)
+{
+  ///int widths0, QChar fill = QLatin1Char(' ')s1, bool trunc = falses2
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'rightJustified' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int widths0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;rightJustified((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'rightJustified' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int widths0, QChar fill = QLatin1Char(' ')s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_1 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_1));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;rightJustified((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'rightJustified' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int widths0, QChar fill = QLatin1Char(' ')s1, bool trunc = falses2,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      QChar *cpp_arg_1 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_1));
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;rightJustified((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1, (bool) Z_LVAL_P(arg_2)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::rightJustified(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  lastIndexOf
- *    flags:    c
+/*!
+ * method lastIndexOf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * @param	 int from = -1s1
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives2
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * @param	 int from = -1
+ * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
+ * 
+ * overloaded args:
+ * @param	const QRegExp &amp;
+ * @param	 int from = -1
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QString, lastIndexOf){
-		/* ol public*/
 
-		/* const QRegExp&amp; , int from,  */
+ZEND_METHOD(QString, lastIndexOf)
+{
+  ///QChar cs0, int from = -1s1, Qt::CaseSensitivity cs = Qt::CaseSensitives2
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'lastIndexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_LONG(selfpointer-&gt;lastIndexOf((QChar) * cpp_arg_0));
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRegExp&quot;) {
-				RETURN_LONG(obj-&gt;lastIndexOf((const QRegExp&amp;) obj_z_0, (int) Z_LVAL_P(z_1)));
-			}
-			}
-		}
-	}
-		/* oll public*/
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'lastIndexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0, int from = -1s1,
+        QString *selfpointer;
 
-		/* const QString&amp; s, int from, int cs,  */
-		/* lll public*/
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
 
-		/* char c, int from, int cs,  */
+        RETURN_LONG(selfpointer-&gt;lastIndexOf((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'lastIndexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0, int from = -1s1, Qt::CaseSensitivity cs = Qt::CaseSensitives2,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				RETURN_LONG(obj-&gt;lastIndexOf((const QString&amp;) obj_z_0, (int) Z_LVAL_P(z_1), (Qt::CaseSensitivity) Z_LVAL_P(z_2)));
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+        RETURN_LONG(selfpointer-&gt;lastIndexOf((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+      }
+#endif
 
+    }
+  }
+  ///const QString &amp;s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-			RETURN_LONG(obj-&gt;lastIndexOf((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(Qt::CaseSensitivity) Z_LVAL_P(z_2)));
-			}
-		}
-	}
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'lastIndexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;lastIndexOf((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'lastIndexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s, int from = -1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;lastIndexOf((const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'lastIndexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;lastIndexOf((const QString &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
+      }
+#endif
+
+    }
+  }
+  ///const QRegExp &amp;, int from = -1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'lastIndexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegExp &amp;,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast &lt; QRegExp * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;lastIndexOf((const QRegExp &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QRegExp
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'lastIndexOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegExp &amp;, int from = -1,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QRegExp *cpp_arg_0 = static_cast &lt; QRegExp * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;lastIndexOf((const QRegExp &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::lastIndexOf(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  unicode
- *    flags:    c
+/*!
+ * method unicode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QChar *
+ * @flags	c
  */
-ZEND_METHOD(QString, unicode){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				const QChar * return_object = (const QChar *) obj-&gt;unicode();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QString_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QString, unicode)
+{
+  ///
+#ifdef PHP_QT_QChar             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'unicode' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = const_cast &lt; QChar * &gt;(selfpointer-&gt;unicode());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::unicode(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  at
- *    flags:    c
+/*!
+ * method at
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int is0
+ * 
+ * @access	public
+ * @return	const QChar
+ * @flags	c
  */
-ZEND_METHOD(QString, at){
-		/* l public*/
 
-		/* int i,  */
+ZEND_METHOD(QString, at)
+{
+  ///int is0
+#ifdef PHP_QT_QChar             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'at' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int is0,
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			obj-&gt;at((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QChar *return_object = new QChar;
+
+      *return_object = const_cast &lt; QChar &gt; (selfpointer-&gt;at((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::at(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  begin
- *    flags:    
+/*!
+ * method begin
+ * 
+ * @param: -
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	iterator
+ * @flags	
  */
-ZEND_METHOD(QString, begin){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_INTPTR(obj-&gt;begin());
-	}
+
+ZEND_METHOD(QString, begin)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type iterator&quot;);
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type const_iterator&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::begin(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  push_back
- *    flags:    
+/*!
+ * method sprintf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const char *formats0
+ * @param	 ...  ...s1
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
  */
-ZEND_METHOD(QString, push_back){
-		/* l public*/
 
-		/* char c,  */
-		/* o public*/
+ZEND_METHOD(QString, sprintf)
+{
+// notice: unknown argument  ...  ...s1, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QString::sprintf(...) &quot;);
+}
 
-		/* const QString&amp; s,  */
+/*!
+ * method push_back
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+ZEND_METHOD(QString, push_back)
+{
+  ///QChar cs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QChar
+      if (inherits(Z_OBJCE_P(arg_0), 6)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'push_back' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QChar cs0,
+        QString *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QChar *cpp_arg_0 = static_cast &lt; QChar * &gt;(php_qt_fetch(arg_0));
 
-			obj-&gt;push_back((char) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        RETURN_VOID(selfpointer-&gt;push_back((QChar) * cpp_arg_0));
+      }
+#endif
 
+    }
+  }
+  ///const QString &amp;s
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-				obj-&gt;push_back((const QString&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'push_back' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s,
+        QString *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;push_back((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::push_back(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  capacity
- *    flags:    c
+/*!
+ * method capacity
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QString, capacity){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;capacity());
-	}
+
+ZEND_METHOD(QString, capacity)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'capacity' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;capacity());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::capacity(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  constBegin
- *    flags:    c
+/*!
+ * method constBegin
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const_iterator
+ * @flags	c
  */
-ZEND_METHOD(QString, constBegin){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			obj-&gt;constBegin();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QString, constBegin)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type const_iterator&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::constBegin(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toLocal8Bit
- *    flags:    c
+/*!
+ * method toInt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool *ok=0s0
+ * @param	 int base=10s1
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QString, toLocal8Bit){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_STRING((char*) obj-&gt;toLocal8Bit(), 1);
-	}
+
+ZEND_METHOD(QString, toInt)
+{
+  ///bool *ok=0s0, int base=10s1
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toInt' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toInt());
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toInt' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toInt((bool *) &amp; Z_LVAL_P(arg_0)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toInt' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool *ok=0s0, int base=10s1,
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toInt((bool *) &amp; Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::toInt(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  toInt
- *    flags:    c
+/*!
+ * method toLocal8Bit
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QByteArray
+ * @flags	c
  */
-ZEND_METHOD(QString, toInt){
-		/* ll public*/
 
-		/* int* ok, int base,  */
+ZEND_METHOD(QString, toLocal8Bit)
+{
+  ///
+#ifdef PHP_QT_QByteArray        // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toLocal8Bit' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_LONG(obj-&gt;toInt((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QByteArray *return_object = new QByteArray;
+
+      *return_object = static_cast &lt; QByteArray &gt; (selfpointer-&gt;toLocal8Bit());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QString::toLocal8Bit(...) &quot;);
 }
 
-/*********************************
- *    class     QString */
-/*
- *    function  isNull
- *    flags:    c
+/*!
+ * method isNull
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QString, isNull){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isNull());
-	}
+
+ZEND_METHOD(QString, isNull)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isNull' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QString *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QString * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isNull());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QString::isNull(...) &quot;);
 }
 
+/*!
+ * method operator=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QChar cs0
+ * 
+ * overloaded args:
+ * @param	const QString &amp;
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;
+ * 
+ * overloaded args:
+ * @param	const char *ch
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;a
+ * 
+ * overloaded args:
+ * @param	char c
+ * 
+ * overloaded args:
+ * @param	const Null &amp;
+ * 
+ * overloaded args:
+ * @param	const char *ch
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;a
+ * 
+ * @access	public
+ * @return	QString &amp;
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QString);
-
+/*!
+ * method operator&gt;=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * 
+ * overloaded args:
+ * @param	const QLatin1String &amp;s
+ * 
+ * overloaded args:
+ * @param	const char *s2
+ * 
+ * overloaded args:
+ * @param	const QByteArray &amp;s
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */

Modified: trunk/qt/classes/qt.cpp
===================================================================
--- trunk/qt/classes/qt.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qt.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,1167 +19,206 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Qt.cpp - Qt PHP implementation.
- * begin           : Wed Jan 11 20:29:53 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;Qt&gt;
 #include &quot;../php_qt.h&quot;
 
 
-
-/*		public enumGlobalColor:long {
-			GlobalColor = 0,
-			GlobalColor = 1,
-			GlobalColor = 2,
-			GlobalColor = 3,
-			GlobalColor = 4,
-			GlobalColor = 5,
-			GlobalColor = 6,
-			GlobalColor = 7,
-			GlobalColor = 8,
-			GlobalColor = 9,
-			GlobalColor = 10,
-			GlobalColor = 11,
-			GlobalColor = 12,
-			GlobalColor = 13,
-			GlobalColor = 14,
-			GlobalColor = 15,
-			GlobalColor = 16,
-			GlobalColor = 17,
-			GlobalColor = 18,
-			GlobalColor = 19
-		}
-*/
-
-/*		public enumKeyboardModifier:long {
-			NoModifier = 0x00000000,
-			ShiftModifier = 0x02000000,
-			ControlModifier = 0x04000000,
-			AltModifier = 0x08000000,
-			MetaModifier = 0x10000000,
-			KeypadModifier = 0x20000000,
-			KeyboardModifierMask = 0xfe000000
-		}
-*/
-
-/*		public enumModifier:long {
-			META = Qt.MetaModifier,
-			SHIFT = Qt.ShiftModifier,
-			CTRL = Qt.ControlModifier,
-			ALT = Qt.AltModifier,
-			MODIFIER_MASK = KeyboardModifierMask,
-			UNICODE_ACCEL = 0x00000000
-		}
-*/
-
-/*		public enumMouseButton:long {
-			NoButton = 0x00000000,
-			LeftButton = 0x00000001,
-			RightButton = 0x00000002,
-			MidButton = 0x00000004,
-			XButton1 = 0x00000008,
-			XButton2 = 0x00000010,
-			MouseButtonMask = 0x000000ff
-		}
-*/
-
-/*		public enumOrientation:long {
-			Horizontal = 0x1,
-			Vertical = 0x2
-		}
-*/
-
-/*		public enumFocusPolicy:long {
-			NoFocus = 0,
-			TabFocus = 0x1,
-			ClickFocus = 0x2,
-			StrongFocus = TabFocus|ClickFocus|0x8,
-			WheelFocus = StrongFocus|0x4
-		}
-*/
-
-/*		public enumSortOrder:long {
-			SortOrder = 0,
-			SortOrder = 1
-		}
-*/
-
-/*		public enumAlignmentFlag:long {
-			AlignLeft = 0x0001,
-			AlignLeading = AlignLeft,
-			AlignRight = 0x0002,
-			AlignTrailing = AlignRight,
-			AlignHCenter = 0x0004,
-			AlignJustify = 0x0008,
-			AlignAbsolute = 0x0010,
-			AlignHorizontal_Mask = AlignLeft|AlignRight|AlignHCenter|AlignJustify|AlignAbsolute,
-			AlignTop = 0x0020,
-			AlignBottom = 0x0040,
-			AlignVCenter = 0x0080,
-			AlignVertical_Mask = AlignTop|AlignBottom|AlignVCenter,
-			AlignCenter = AlignVCenter|AlignHCenter
-		}
-*/
-
-/*		public enumTextFlag:long {
-			TextSingleLine = 0x0100,
-			TextDontClip = 0x0200,
-			TextExpandTabs = 0x0400,
-			TextShowMnemonic = 0x0800,
-			TextWordWrap = 0x1000,
-			TextWrapAnywhere = 0x2000,
-			TextDontPrint = 0x4000,
-			TextIncludeTrailingSpaces = 0x08000000,
-			TextHideMnemonic = 0x8000
-		}
-*/
-
-/*		public enumTextElideMode:long {
-			TextElideMode = 0,
-			TextElideMode = 1,
-			TextElideMode = 2
-		}
-*/
-
-/*		public enumWindowType:long {
-			Widget = 0x00000000,
-			Window = 0x00000001,
-			Dialog = 0x00000002|Window,
-			Sheet = 0x00000004|Window,
-			Drawer = 0x00000006|Window,
-			Popup = 0x00000008|Window,
-			Tool = 0x0000000a|Window,
-			ToolTip = 0x0000000c|Window,
-			SplashScreen = 0x0000000e|Window,
-			Desktop = 0x00000010|Window,
-			SubWindow = 0x00000012,
-			WindowType_Mask = 0x000000ff,
-			MSWindowsFixedSizeDialogHint = 0x00000100,
-			MSWindowsOwnDC = 0x00000200,
-			X11BypassWindowManagerHint = 0x00000400,
-			FramelessWindowHint = 0x00000800,
-			WindowTitleHint = 0x00001000,
-			WindowSystemMenuHint = 0x00002000,
-			WindowMinimizeButtonHint = 0x00004000,
-			WindowMaximizeButtonHint = 0x00008000,
-			WindowMinMaxButtonsHint = WindowMinimizeButtonHint|WindowMaximizeButtonHint,
-			WindowContextHelpButtonHint = 0x00010000,
-			WindowShadeButtonHint = 0x00020000,
-			WindowStaysOnTopHint = 0x00040000
-		}
-*/
-
-/*		public enumWindowState:long {
-			WindowNoState = 0x00000000,
-			WindowMinimized = 0x00000001,
-			WindowMaximized = 0x00000002,
-			WindowFullScreen = 0x00000004,
-			WindowActive = 0x00000008
-		}
-*/
-
-/*		public enumWidgetAttribute:long {
-			WA_Disabled = 0,
-			WA_UnderMouse = 1,
-			WA_MouseTracking = 2,
-			WA_ContentsPropagated = 3,
-			WA_OpaquePaintEvent = 4,
-			WA_NoBackground = WA_OpaquePaintEvent,
-			WA_StaticContents = 5,
-			WA_LaidOut = 7,
-			WA_PaintOnScreen = 8,
-			WA_NoSystemBackground = 9,
-			WA_UpdatesDisabled = 10,
-			WA_Mapped = 11,
-			WA_MacNoClickThrough = 12,
-			WA_PaintOutsidePaintEvent = 13,
-			WA_InputMethodEnabled = 14,
-			WA_WState_Visible = 15,
-			WA_WState_Hidden = 16,
-			WA_ForceDisabled = 32,
-			WA_KeyCompression = 33,
-			WA_PendingMoveEvent = 34,
-			WA_PendingResizeEvent = 35,
-			WA_SetPalette = 36,
-			WA_SetFont = 37,
-			WA_SetCursor = 38,
-			WA_NoChildEventsFromChildren = 39,
-			WA_WindowModified = 41,
-			WA_Resized = 42,
-			WA_Moved = 43,
-			WA_PendingUpdate = 44,
-			WA_InvalidSize = 45,
-			WA_MacMetalStyle = 46,
-			WA_CustomWhatsThis = 47,
-			WA_LayoutOnEntireRect = 48,
-			WA_OutsideWSRange = 49,
-			WA_GrabbedShortcut = 50,
-			WA_TransparentForMouseEvents = 51,
-			WA_PaintUnclipped = 52,
-			WA_SetWindowIcon = 53,
-			WA_NoMouseReplay = 54,
-			WA_DeleteOnClose = 55,
-			WA_RightToLeft = 56,
-			WA_SetLayoutDirection = 57,
-			WA_NoChildEventsForParent = 58,
-			WA_ForceUpdatesDisabled = 59,
-			WA_WState_Created = 60,
-			WA_WState_CompressKeys = 61,
-			WA_WState_InPaintEvent = 62,
-			WA_WState_Reparented = 63,
-			WA_WState_ConfigPending = 64,
-			WA_WState_Polished = 66,
-			WA_WState_DND = 67,
-			WA_WState_OwnSizePolicy = 68,
-			WA_WState_ExplicitShowHide = 69,
-			WA_ShowModal = 70,
-			WA_MouseNoMask = 71,
-			WA_GroupLeader = 72,
-			WA_NoMousePropagation = 73,
-			WA_Hover = 74,
-			WA_InputMethodTransparent = 75,
-			WA_QuitOnClose = 76,
-			WA_KeyboardFocusChange = 77,
-			WA_AcceptDrops = 78,
-			WA_DropSiteRegistered = 79,
-			WA_ForceAcceptDrops = WA_DropSiteRegistered,
-			WA_WindowPropagation = 80,
-			WA_NoX11EventCompression = 81,
-			WA_TintedBackground = 82,
-			WidgetAttribute = 67
-		}
-*/
-
-/*		public enumImageConversionFlag:long {
-			ColorMode_Mask = 0x00000003,
-			AutoColor = 0x00000000,
-			ColorOnly = 0x00000003,
-			MonoOnly = 0x00000002,
-			AlphaDither_Mask = 0x0000000c,
-			ThresholdAlphaDither = 0x00000000,
-			OrderedAlphaDither = 0x00000004,
-			DiffuseAlphaDither = 0x00000008,
-			NoAlpha = 0x0000000c,
-			Dither_Mask = 0x00000030,
-			DiffuseDither = 0x00000000,
-			OrderedDither = 0x00000010,
-			ThresholdDither = 0x00000020,
-			DitherMode_Mask = 0x000000c0,
-			AutoDither = 0x00000000,
-			PreferDither = 0x00000040,
-			AvoidDither = 0x00000080
-		}
-*/
-
-/*		public enumBGMode:long {
-			BGMode = 0,
-			BGMode = 1
-		}
-*/
-
-/*		public enumKey:long {
-			Key_Escape = 0x01000000,
-			Key_Tab = 0x01000001,
-			Key_Backtab = 0x01000002,
-			Key_Backspace = 0x01000003,
-			Key_Return = 0x01000004,
-			Key_Enter = 0x01000005,
-			Key_Insert = 0x01000006,
-			Key_Delete = 0x01000007,
-			Key_Pause = 0x01000008,
-			Key_Print = 0x01000009,
-			Key_SysReq = 0x0100000a,
-			Key_Clear = 0x0100000b,
-			Key_Home = 0x01000010,
-			Key_End = 0x01000011,
-			Key_Left = 0x01000012,
-			Key_Up = 0x01000013,
-			Key_Right = 0x01000014,
-			Key_Down = 0x01000015,
-			Key_PageUp = 0x01000016,
-			Key_PageDown = 0x01000017,
-			Key_Shift = 0x01000020,
-			Key_Control = 0x01000021,
-			Key_Meta = 0x01000022,
-			Key_Alt = 0x01000023,
-			Key_CapsLock = 0x01000024,
-			Key_NumLock = 0x01000025,
-			Key_ScrollLock = 0x01000026,
-			Key_F1 = 0x01000030,
-			Key_F2 = 0x01000031,
-			Key_F3 = 0x01000032,
-			Key_F4 = 0x01000033,
-			Key_F5 = 0x01000034,
-			Key_F6 = 0x01000035,
-			Key_F7 = 0x01000036,
-			Key_F8 = 0x01000037,
-			Key_F9 = 0x01000038,
-			Key_F10 = 0x01000039,
-			Key_F11 = 0x0100003a,
-			Key_F12 = 0x0100003b,
-			Key_F13 = 0x0100003c,
-			Key_F14 = 0x0100003d,
-			Key_F15 = 0x0100003e,
-			Key_F16 = 0x0100003f,
-			Key_F17 = 0x01000040,
-			Key_F18 = 0x01000041,
-			Key_F19 = 0x01000042,
-			Key_F20 = 0x01000043,
-			Key_F21 = 0x01000044,
-			Key_F22 = 0x01000045,
-			Key_F23 = 0x01000046,
-			Key_F24 = 0x01000047,
-			Key_F25 = 0x01000048,
-			Key_F26 = 0x01000049,
-			Key_F27 = 0x0100004a,
-			Key_F28 = 0x0100004b,
-			Key_F29 = 0x0100004c,
-			Key_F30 = 0x0100004d,
-			Key_F31 = 0x0100004e,
-			Key_F32 = 0x0100004f,
-			Key_F33 = 0x01000050,
-			Key_F34 = 0x01000051,
-			Key_F35 = 0x01000052,
-			Key_Super_L = 0x01000053,
-			Key_Super_R = 0x01000054,
-			Key_Menu = 0x01000055,
-			Key_Hyper_L = 0x01000056,
-			Key_Hyper_R = 0x01000057,
-			Key_Help = 0x01000058,
-			Key_Direction_L = 0x01000059,
-			Key_Direction_R = 0x01000060,
-			Key_Space = 0x20,
-			Key_Any = Key_Space,
-			Key_Exclam = 0x21,
-			Key_QuoteDbl = 0x22,
-			Key_NumberSign = 0x23,
-			Key_Dollar = 0x24,
-			Key_Percent = 0x25,
-			Key_Ampersand = 0x26,
-			Key_Apostrophe = 0x27,
-			Key_ParenLeft = 0x28,
-			Key_ParenRight = 0x29,
-			Key_Asterisk = 0x2a,
-			Key_Plus = 0x2b,
-			Key_Comma = 0x2c,
-			Key_Minus = 0x2d,
-			Key_Period = 0x2e,
-			Key_Slash = 0x2f,
-			Key_0 = 0x30,
-			Key_1 = 0x31,
-			Key_2 = 0x32,
-			Key_3 = 0x33,
-			Key_4 = 0x34,
-			Key_5 = 0x35,
-			Key_6 = 0x36,
-			Key_7 = 0x37,
-			Key_8 = 0x38,
-			Key_9 = 0x39,
-			Key_Colon = 0x3a,
-			Key_Semicolon = 0x3b,
-			Key_Less = 0x3c,
-			Key_Equal = 0x3d,
-			Key_Greater = 0x3e,
-			Key_Question = 0x3f,
-			Key_At = 0x40,
-			Key_A = 0x41,
-			Key_B = 0x42,
-			Key_C = 0x43,
-			Key_D = 0x44,
-			Key_E = 0x45,
-			Key_F = 0x46,
-			Key_G = 0x47,
-			Key_H = 0x48,
-			Key_I = 0x49,
-			Key_J = 0x4a,
-			Key_K = 0x4b,
-			Key_L = 0x4c,
-			Key_M = 0x4d,
-			Key_N = 0x4e,
-			Key_O = 0x4f,
-			Key_P = 0x50,
-			Key_Q = 0x51,
-			Key_R = 0x52,
-			Key_S = 0x53,
-			Key_T = 0x54,
-			Key_U = 0x55,
-			Key_V = 0x56,
-			Key_W = 0x57,
-			Key_X = 0x58,
-			Key_Y = 0x59,
-			Key_Z = 0x5a,
-			Key_BracketLeft = 0x5b,
-			Key_Backslash = 0x5c,
-			Key_BracketRight = 0x5d,
-			Key_AsciiCircum = 0x5e,
-			Key_Underscore = 0x5f,
-			Key_QuoteLeft = 0x60,
-			Key_BraceLeft = 0x7b,
-			Key_Bar = 0x7c,
-			Key_BraceRight = 0x7d,
-			Key_AsciiTilde = 0x7e,
-			Key_nobreakspace = 0x0a0,
-			Key_exclamdown = 0x0a1,
-			Key_cent = 0x0a2,
-			Key_sterling = 0x0a3,
-			Key_currency = 0x0a4,
-			Key_yen = 0x0a5,
-			Key_brokenbar = 0x0a6,
-			Key_section = 0x0a7,
-			Key_diaeresis = 0x0a8,
-			Key_copyright = 0x0a9,
-			Key_ordfeminine = 0x0aa,
-			Key_guillemotleft = 0x0ab,
-			Key_notsign = 0x0ac,
-			Key_hyphen = 0x0ad,
-			Key_registered = 0x0ae,
-			Key_macron = 0x0af,
-			Key_degree = 0x0b0,
-			Key_plusminus = 0x0b1,
-			Key_twosuperior = 0x0b2,
-			Key_threesuperior = 0x0b3,
-			Key_acute = 0x0b4,
-			Key_mu = 0x0b5,
-			Key_paragraph = 0x0b6,
-			Key_periodcentered = 0x0b7,
-			Key_cedilla = 0x0b8,
-			Key_onesuperior = 0x0b9,
-			Key_masculine = 0x0ba,
-			Key_guillemotright = 0x0bb,
-			Key_onequarter = 0x0bc,
-			Key_onehalf = 0x0bd,
-			Key_threequarters = 0x0be,
-			Key_questiondown = 0x0bf,
-			Key_Agrave = 0x0c0,
-			Key_Aacute = 0x0c1,
-			Key_Acircumflex = 0x0c2,
-			Key_Atilde = 0x0c3,
-			Key_Adiaeresis = 0x0c4,
-			Key_Aring = 0x0c5,
-			Key_AE = 0x0c6,
-			Key_Ccedilla = 0x0c7,
-			Key_Egrave = 0x0c8,
-			Key_Eacute = 0x0c9,
-			Key_Ecircumflex = 0x0ca,
-			Key_Ediaeresis = 0x0cb,
-			Key_Igrave = 0x0cc,
-			Key_Iacute = 0x0cd,
-			Key_Icircumflex = 0x0ce,
-			Key_Idiaeresis = 0x0cf,
-			Key_ETH = 0x0d0,
-			Key_Ntilde = 0x0d1,
-			Key_Ograve = 0x0d2,
-			Key_Oacute = 0x0d3,
-			Key_Ocircumflex = 0x0d4,
-			Key_Otilde = 0x0d5,
-			Key_Odiaeresis = 0x0d6,
-			Key_multiply = 0x0d7,
-			Key_Ooblique = 0x0d8,
-			Key_Ugrave = 0x0d9,
-			Key_Uacute = 0x0da,
-			Key_Ucircumflex = 0x0db,
-			Key_Udiaeresis = 0x0dc,
-			Key_Yacute = 0x0dd,
-			Key_THORN = 0x0de,
-			Key_ssharp = 0x0df,
-			Key_division = 0x0f7,
-			Key_ydiaeresis = 0x0ff,
-			Key_AltGr = 0x01001103,
-			Key_Multi_key = 0x01001120,
-			Key_Codeinput = 0x01001137,
-			Key_SingleCandidate = 0x0100113c,
-			Key_MultipleCandidate = 0x0100113d,
-			Key_PreviousCandidate = 0x0100113e,
-			Key_Mode_switch = 0x0100117e,
-			Key_Kanji = 0x01001121,
-			Key_Muhenkan = 0x01001122,
-			Key_Henkan = 0x01001123,
-			Key_Romaji = 0x01001124,
-			Key_Hiragana = 0x01001125,
-			Key_Katakana = 0x01001126,
-			Key_Hiragana_Katakana = 0x01001127,
-			Key_Zenkaku = 0x01001128,
-			Key_Hankaku = 0x01001129,
-			Key_Zenkaku_Hankaku = 0x0100112a,
-			Key_Touroku = 0x0100112b,
-			Key_Massyo = 0x0100112c,
-			Key_Kana_Lock = 0x0100112d,
-			Key_Kana_Shift = 0x0100112e,
-			Key_Eisu_Shift = 0x0100112f,
-			Key_Eisu_toggle = 0x01001130,
-			Key_Hangul = 0x01001131,
-			Key_Hangul_Start = 0x01001132,
-			Key_Hangul_End = 0x01001133,
-			Key_Hangul_Hanja = 0x01001134,
-			Key_Hangul_Jamo = 0x01001135,
-			Key_Hangul_Romaja = 0x01001136,
-			Key_Hangul_Jeonja = 0x01001138,
-			Key_Hangul_Banja = 0x01001139,
-			Key_Hangul_PreHanja = 0x0100113a,
-			Key_Hangul_PostHanja = 0x0100113b,
-			Key_Hangul_Special = 0x0100113f,
-			Key_Dead_Grave = 0x01001250,
-			Key_Dead_Acute = 0x01001251,
-			Key_Dead_Circumflex = 0x01001252,
-			Key_Dead_Tilde = 0x01001253,
-			Key_Dead_Macron = 0x01001254,
-			Key_Dead_Breve = 0x01001255,
-			Key_Dead_Abovedot = 0x01001256,
-			Key_Dead_Diaeresis = 0x01001257,
-			Key_Dead_Abovering = 0x01001258,
-			Key_Dead_Doubleacute = 0x01001259,
-			Key_Dead_Caron = 0x0100125a,
-			Key_Dead_Cedilla = 0x0100125b,
-			Key_Dead_Ogonek = 0x0100125c,
-			Key_Dead_Iota = 0x0100125d,
-			Key_Dead_Voiced_Sound = 0x0100125e,
-			Key_Dead_Semivoiced_Sound = 0x0100125f,
-			Key_Dead_Belowdot = 0x01001260,
-			Key_Dead_Hook = 0x01001261,
-			Key_Dead_Horn = 0x01001262,
-			Key_Back = 0x01000061,
-			Key_Forward = 0x01000062,
-			Key_Stop = 0x01000063,
-			Key_Refresh = 0x01000064,
-			Key_VolumeDown = 0x01000070,
-			Key_VolumeMute = 0x01000071,
-			Key_VolumeUp = 0x01000072,
-			Key_BassBoost = 0x01000073,
-			Key_BassUp = 0x01000074,
-			Key_BassDown = 0x01000075,
-			Key_TrebleUp = 0x01000076,
-			Key_TrebleDown = 0x01000077,
-			Key_MediaPlay = 0x01000080,
-			Key_MediaStop = 0x01000081,
-			Key_MediaPrevious = 0x01000082,
-			Key_MediaNext = 0x01000083,
-			Key_MediaRecord = 0x01000084,
-			Key_HomePage = 0x01000090,
-			Key_Favorites = 0x01000091,
-			Key_Search = 0x01000092,
-			Key_Standby = 0x01000093,
-			Key_OpenUrl = 0x01000094,
-			Key_LaunchMail = 0x010000a0,
-			Key_LaunchMedia = 0x010000a1,
-			Key_Launch0 = 0x010000a2,
-			Key_Launch1 = 0x010000a3,
-			Key_Launch2 = 0x010000a4,
-			Key_Launch3 = 0x010000a5,
-			Key_Launch4 = 0x010000a6,
-			Key_Launch5 = 0x010000a7,
-			Key_Launch6 = 0x010000a8,
-			Key_Launch7 = 0x010000a9,
-			Key_Launch8 = 0x010000aa,
-			Key_Launch9 = 0x010000ab,
-			Key_LaunchA = 0x010000ac,
-			Key_LaunchB = 0x010000ad,
-			Key_LaunchC = 0x010000ae,
-			Key_LaunchD = 0x010000af,
-			Key_LaunchE = 0x010000b0,
-			Key_LaunchF = 0x010000b1,
-			Key_MediaLast = 0x0100ffff,
-			Key_Select = 0x01010000,
-			Key_Yes = 0x01010001,
-			Key_No = 0x01010002,
-			Key_Context1 = 0x01100000,
-			Key_Context2 = 0x01100001,
-			Key_Context3 = 0x01100002,
-			Key_Context4 = 0x01100003,
-			Key_Call = 0x01100004,
-			Key_Hangup = 0x01100005,
-			Key_Flip = 0x01100006,
-			Key_unknown = 0x01ffffff
-		}
-*/
-
-/*		public enumArrowType:long {
-			ArrowType = 0,
-			ArrowType = 1,
-			ArrowType = 2,
-			ArrowType = 3,
-			ArrowType = 4
-		}
-*/
-
-/*		public enumPenStyle:long {
-			PenStyle = 0,
-			PenStyle = 1,
-			PenStyle = 2,
-			PenStyle = 3,
-			PenStyle = 4,
-			PenStyle = 5,
-			PenStyle = 6,
-			MPenStyle = 0x0f
-		}
-*/
-
-/*		public enumPenCapStyle:long {
-			FlatCap = 0x00,
-			SquareCap = 0x10,
-			RoundCap = 0x20,
-			MPenCapStyle = 0x30
-		}
-*/
-
-/*		public enumPenJoinStyle:long {
-			MiterJoin = 0x00,
-			BevelJoin = 0x40,
-			RoundJoin = 0x80,
-			MPenJoinStyle = 0xc0
-		}
-*/
-
-/*		public enumBrushStyle:long {
-			BrushStyle = 0,
-			BrushStyle = 1,
-			BrushStyle = 2,
-			BrushStyle = 3,
-			BrushStyle = 4,
-			BrushStyle = 5,
-			BrushStyle = 6,
-			BrushStyle = 7,
-			BrushStyle = 8,
-			BrushStyle = 9,
-			BrushStyle = 10,
-			BrushStyle = 11,
-			BrushStyle = 12,
-			BrushStyle = 13,
-			BrushStyle = 14,
-			BrushStyle = 15,
-			BrushStyle = 16,
-			BrushStyle = 17,
-			TexturePattern = 24
-		}
-*/
-
-/*		public enumUIEffect:long {
-			UIEffect = 0,
-			UIEffect = 1,
-			UIEffect = 2,
-			UIEffect = 3,
-			UIEffect = 4,
-			UIEffect = 5,
-			UIEffect = 6
-		}
-*/
-
-/*		public enumCursorShape:long {
-			CursorShape = 0,
-			CursorShape = 1,
-			CursorShape = 2,
-			CursorShape = 3,
-			CursorShape = 4,
-			CursorShape = 5,
-			CursorShape = 6,
-			CursorShape = 7,
-			CursorShape = 8,
-			CursorShape = 9,
-			CursorShape = 10,
-			CursorShape = 11,
-			CursorShape = 12,
-			CursorShape = 13,
-			CursorShape = 14,
-			CursorShape = 15,
-			CursorShape = 16,
-			LastCursor = BusyCursor,
-			BitmapCursor = 24
-		}
-*/
-
-/*		public enumTextFormat:long {
-			TextFormat = 0,
-			TextFormat = 1,
-			TextFormat = 2,
-			TextFormat = 3
-		}
-*/
-
-/*		public enumAspectRatioMode:long {
-			AspectRatioMode = 0,
-			AspectRatioMode = 1,
-			AspectRatioMode = 2
-		}
-*/
-
-/*		public enumAnchorAttribute:long {
-			AnchorAttribute = 0,
-			AnchorAttribute = 1
-		}
-*/
-
-/*		public enumDockWidgetArea:long {
-			LeftDockWidgetArea = 0x1,
-			RightDockWidgetArea = 0x2,
-			TopDockWidgetArea = 0x4,
-			BottomDockWidgetArea = 0x8,
-			DockWidgetArea_Mask = 0xf,
-			AllDockWidgetAreas = DockWidgetArea_Mask
-		}
-*/
-
-/*		public enum:long {
-			NDockWidgetAreas = 4
-		}
-*/
-
-/*		public enumToolBarArea:long {
-			LeftToolBarArea = 0x1,
-			RightToolBarArea = 0x2,
-			TopToolBarArea = 0x4,
-			BottomToolBarArea = 0x8,
-			ToolBarArea_Mask = 0xf,
-			AllToolBarAreas = ToolBarArea_Mask
-		}
-*/
-
-/*		public enum:long {
-			NToolBarAreas = 4
-		}
-*/
-
-/*		public enumDateFormat:long {
-			DateFormat = 0,
-			DateFormat = 1,
-			DateFormat = 2
-		}
-*/
-
-/*		public enumTimeSpec:long {
-			TimeSpec = 0,
-			TimeSpec = 1
-		}
-*/
-
-/*		public enumDayOfWeek:long {
-			Monday = 1,
-			Tuesday = 2,
-			Wednesday = 3,
-			Thursday = 4,
-			Friday = 5,
-			Saturday = 6,
-			Sunday = 7
-		}
-*/
-
-/*		public enumScrollBarPolicy:long {
-			ScrollBarPolicy = 0,
-			ScrollBarPolicy = 1,
-			ScrollBarPolicy = 2
-		}
-*/
-
-/*		public enumCaseSensitivity:long {
-			CaseSensitivity = 0,
-			CaseSensitivity = 1
-		}
-*/
-
-/*		public enumCorner:long {
-			TopLeftCorner = 0x00000,
-			TopRightCorner = 0x00001,
-			BottomLeftCorner = 0x00002,
-			BottomRightCorner = 0x00003
-		}
-*/
-
-/*		public enumConnectionType:long {
-			ConnectionType = 0,
-			ConnectionType = 1,
-			ConnectionType = 2,
-			ConnectionType = 3
-		}
-*/
-
-/*		public enumShortcutContext:long {
-			ShortcutContext = 0,
-			ShortcutContext = 1,
-			ShortcutContext = 2
-		}
-*/
-
-/*		public enumFillRule:long {
-			FillRule = 0,
-			FillRule = 1
-		}
-*/
-
-/*		public enumClipOperation:long {
-			ClipOperation = 0,
-			ClipOperation = 1,
-			ClipOperation = 2,
-			ClipOperation = 3
-		}
-*/
-
-/*		public enumTransformationMode:long {
-			TransformationMode = 0,
-			TransformationMode = 1
-		}
-*/
-
-/*		public enumFocusReason:long {
-			FocusReason = 0,
-			FocusReason = 1,
-			FocusReason = 2,
-			FocusReason = 3,
-			FocusReason = 4,
-			FocusReason = 5,
-			FocusReason = 6,
-			FocusReason = 7,
-			FocusReason = 8
-		}
-*/
-
-/*		public enumContextMenuPolicy:long {
-			ContextMenuPolicy = 0,
-			ContextMenuPolicy = 1,
-			ContextMenuPolicy = 2,
-			ContextMenuPolicy = 3
-		}
-*/
-
-/*		public enumInputMethodQuery:long {
-			InputMethodQuery = 0,
-			InputMethodQuery = 1,
-			InputMethodQuery = 2,
-			InputMethodQuery = 3,
-			InputMethodQuery = 4
-		}
-*/
-
-/*		public enumToolButtonStyle:long {
-			ToolButtonStyle = 0,
-			ToolButtonStyle = 1,
-			ToolButtonStyle = 2,
-			ToolButtonStyle = 3
-		}
-*/
-
-/*		public enumLayoutDirection:long {
-			LayoutDirection = 0,
-			LayoutDirection = 1
-		}
-*/
-
-/*		public enumDropAction:long {
-			CopyAction = 0x1,
-			MoveAction = 0x2,
-			LinkAction = 0x4,
-			ActionMask = 0xff,
-			TargetMoveAction = 0x8002,
-			IgnoreAction = 0x0
-		}
-*/
-
-/*		public enumCheckState:long {
-			CheckState = 0,
-			CheckState = 1,
-			CheckState = 2
-		}
-*/
-
-/*		public enumItemDataRole:long {
-			DisplayRole = 0,
-			DecorationRole = 1,
-			EditRole = 2,
-			ToolTipRole = 3,
-			StatusTipRole = 4,
-			WhatsThisRole = 5,
-			FontRole = 6,
-			TextAlignmentRole = 7,
-			BackgroundColorRole = 8,
-			TextColorRole = 9,
-			CheckStateRole = 10,
-			AccessibleTextRole = 11,
-			AccessibleDescriptionRole = 12,
-			SizeHintRole = 13,
-			UserRole = 32
-		}
-*/
-
-/*		public enumItemFlag:long {
-			ItemIsSelectable = 1,
-			ItemIsEditable = 2,
-			ItemIsDragEnabled = 4,
-			ItemIsDropEnabled = 8,
-			ItemIsUserCheckable = 16,
-			ItemIsEnabled = 32,
-			ItemIsTristate = 64
-		}
-*/
-
-/*		public enumMatchFlag:long {
-			MatchExactly = 0,
-			MatchContains = 1,
-			MatchStartsWith = 2,
-			MatchEndsWith = 3,
-			MatchRegExp = 4,
-			MatchWildcard = 5,
-			MatchCaseSensitive = 16,
-			MatchWrap = 32,
-			MatchRecursive = 64
-		}
-*/
-
-/*		public enumWindowModality:long {
-			WindowModality = 0,
-			WindowModality = 1,
-			WindowModality = 2
-		}
-*/
-/*********************************
- *    class     Qt */
-/*
- *    function  metaObject
- *    flags:    cv
+#include &lt;Qt&gt;
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(Qt, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			QMetaObject * return_object = (QMetaObject *) obj-&gt;metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, Qt_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     Qt */
-/*
- *    function  tr
- *    flags:    s
- */
-ZEND_METHOD(Qt, tr){
+ZEND_METHOD(Qt, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* ss */
-		char* var_ss_0;   // default: 
-		int len_ss_0;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;Qt::tr(...) cannot be called with ' const char *s0,'.&quot;);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;Qt::tr(...) cannot be called with ' const char *s0, const char * = 0 s1,'.&quot;);
+    }
+  }
+#endif // return type
 
-		char* var_ss_1;   // default: 0
-		int len_ss_1;
-
-
-		/* const char* , const char* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;ss|&quot;, &amp;var_ss_0, len_ss_0, &amp;var_ss_1, len_ss_1) == SUCCESS) {
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-
-			
-			QString return_object = (QString) obj-&gt;tr( (const char*) var_ss_0 , (const char*) var_ss_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, Qt_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-		}
-	}
+  php_error(E_ERROR, &quot;could not parse argument in Qt::tr(...) &quot;);
 }
 
-/*********************************
- *    class     Qt */
-/*
- *    function  qt_invoke
- *    flags:    v
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(Qt, qt_invoke){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* lo */
-		long var_lo_0;    // default: 
-		zval* z_var_lo_1;   // default: 
-
-		/* int , QUObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;lo&quot;, &amp;var_lo_0, &amp;z_var_lo_1) == SUCCESS) {
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			QObject* var_lo_1 = (QObject*) php_qt_fetch(z_var_lo_1);
-
-			QString tmp_lo_0(var_lo_1-&gt;metaObject()-&gt;className());
-			
-			if(tmp_lo_0 == &quot;QUObject*&quot;) {
-				RETURN_BOOL(obj-&gt;qt_invoke((int) var_lo_0, (QUObject*) var_lo_1));
-			}
-		}
-	}
-}
-
-/*********************************
- *    class     Qt */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(Qt, staticMetaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			QMetaObject* return_object = (QMetaObject*) obj-&gt;staticMetaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, Qt_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     Qt */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(Qt, qt_emit){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* lo */
-		long var_lo_0;    // default: 
-		zval* z_var_lo_1;   // default: 
-
-		/* int , QUObject* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;lo&quot;, &amp;var_lo_0, &amp;z_var_lo_1) == SUCCESS) {
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			QObject* var_lo_1 = (QObject*) php_qt_fetch(z_var_lo_1);
-
-			QString tmp_lo_0(var_lo_1-&gt;metaObject()-&gt;className());
-			
-			if(tmp_lo_0 == &quot;QUObject*&quot;) {
-				RETURN_BOOL(obj-&gt;qt_emit((int) var_lo_0, (QUObject*) var_lo_1));
-			}
-		}
-	}
-}
-
-/*********************************
- *    class     Qt */
-/*
- *    function  className
- *    flags:    cv
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
-ZEND_METHOD(Qt, className){
-	if (ZEND_NUM_ARGS() == 0){
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			const char * return_object = (const char *) obj-&gt;className();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, Qt_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     Qt */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(Qt, qObject){
-	if (ZEND_NUM_ARGS() == 0){
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			QObject* return_object = (QObject*) obj-&gt;qObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, Qt_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     Qt */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(Qt, trUtf8){
 
-	if (ZEND_NUM_ARGS() == 2){
-		/* ss */
-		char* var_ss_0;   // default: 
-		int len_ss_0;
+ZEND_METHOD(Qt, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-		char* var_ss_1;   // default: 0
-		int len_ss_1;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;Qt::trUtf8(...) cannot be called with ' const char *s0,'.&quot;);
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;Qt::trUtf8(...) cannot be called with ' const char *s0, const char * = 0 s1,'.&quot;);
+    }
+  }
+#endif // return type
 
-
-		/* const char* , const char* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;ss|&quot;, &amp;var_ss_0, len_ss_0, &amp;var_ss_1, len_ss_1) == SUCCESS) {
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-
-			
-			QString return_object = (QString) obj-&gt;trUtf8( (const char*) var_ss_0 , (const char*) var_ss_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, Qt_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-		}
-	}
+  php_error(E_ERROR, &quot;could not parse argument in Qt::trUtf8(...) &quot;);
 }
 
-/*********************************
- *    class     Qt */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(Qt, qt_property){
 
-	if (ZEND_NUM_ARGS() == 3){
-		/* llo */
-		long var_llo_0;    // default: 
-		long var_llo_1;    // default: 
-		zval* z_var_llo_2;   // default: 
-
-		/* int , int , QVariant* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;llo&quot;, &amp;var_llo_0, &amp;var_llo_1, &amp;z_var_llo_2) == SUCCESS) {
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-			QObject* var_llo_2 = (QObject*) php_qt_fetch(z_var_llo_2);
-
-			QString tmp_llo_0(var_llo_2-&gt;metaObject()-&gt;className());
-			
-			if(tmp_llo_0 == &quot;QVariant*&quot;) {
-				RETURN_BOOL(obj-&gt;qt_property((int) var_llo_0, (int) var_llo_1, (QVariant*) var_llo_2));
-			}
-		}
-	}
-}
-
-/*********************************
- *    class     Qt */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(Qt, qt_cast){
 
-	if (ZEND_NUM_ARGS() == 1){
-		/* s */
-		char* var_s_0;   // default: 
-		int len_s_0;
+ZEND_METHOD(Qt, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;Qt::staticMetaObject(...) cannot be called with ''.&quot;);
+    }
+  }
+#endif // return type
 
-		/* const char* ,  */
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;s&quot;, &amp;var_s_0, len_s_0) == SUCCESS) {
-			Qt *obj = (Qt*) PHP_QT_FETCH();
-
-			
-			obj-&gt;qt_cast( (const char*) var_s_0);
-			RETURN_NULL();
-		}
-	}
+  php_error(E_ERROR, &quot;could not parse argument in Qt::staticMetaObject(...) &quot;);
 }
 
-
-PHP_QT_DESTRUCT(Qt);
-
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */

Modified: trunk/qt/classes/qtabletevent.cpp
===================================================================
--- trunk/qt/classes/qtabletevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qtabletevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,290 +19,614 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QTabletEvent.cpp - QTabletEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QTabletEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
+#include &lt;QTabletEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QTabletEvent_php_qt:public QTabletEvent
+{
 
-/*		public enumTabletDevice:long {
-			TabletDevice = 0,
-			TabletDevice = 0,
-			TabletDevice = 0,
-			TabletDevice = 0,
-			TabletDevice = 0,
-			TabletDevice = 0,
-		}
-*/
+public:
+  QTabletEvent_php_qt(zval * zend_ptr, Type ts0, const QPoint &amp; poss1, const QPoint &amp; globalPoss2, const QPointF &amp; hiResGlobalPoss3, int devices4,
+                      int pointerTypes5, qreal pressures6, int xTilts7, int yTilts8, qreal tangentialPressures9, qreal rotations10, int zs11,
+                      Qt::KeyboardModifiers keyStates12, qint64 uniqueIDs13);
 
-/*		public enumPointerType:long {
-			PointerType = 0,
-			PointerType = 0,
-			PointerType = 0,
-			PointerType = 0,
-		}
-*/
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  hiResGlobalX
- *    flags:    c
+
+  zval *zend_ptr;
+};
+QTabletEvent_php_qt::QTabletEvent_php_qt(zval * zend_ptr, Type ts0, const QPoint &amp; poss1, const QPoint &amp; globalPoss2, const QPointF &amp; hiResGlobalPoss3,
+                                         int devices4, int pointerTypes5, qreal pressures6, int xTilts7, int yTilts8, qreal tangentialPressures9,
+                                         qreal rotations10, int zs11, Qt::KeyboardModifiers keyStates12, qint64 uniqueIDs13):
+QTabletEvent(ts0, poss1, globalPoss2, hiResGlobalPoss3, devices4, pointerTypes5, pressures6, xTilts7, yTilts8, tangentialPressures9, rotations10, zs11,
+             keyStates12, uniqueIDs13)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method pressure
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, hiResGlobalX){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj-&gt;hiResGlobalX());
-	}
+
+ZEND_METHOD(QTabletEvent, pressure)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type qreal&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::pressure(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  pressure
- *    flags:    c
+/*!
+ * method hiResGlobalPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPointF &amp;
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, pressure){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj-&gt;pressure());
-	}
+
+ZEND_METHOD(QTabletEvent, hiResGlobalPos)
+{
+  ///
+#ifdef PHP_QT_QPointF           // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hiResGlobalPos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTabletEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPointF &amp; &gt;(selfpointer-&gt;hiResGlobalPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::hiResGlobalPos(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  hiResGlobalPos
- *    flags:    c
+/*!
+ * method y
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, hiResGlobalPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-				const QPointF &amp; return_object = (const QPointF &amp;) obj-&gt;hiResGlobalPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTabletEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QTabletEvent, y)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'y' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTabletEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;y());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::y(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  tangentialPressure
- *    flags:    c
+/*!
+ * method xTilt
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, tangentialPressure){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj-&gt;tangentialPressure());
-	}
+
+ZEND_METHOD(QTabletEvent, xTilt)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'xTilt' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTabletEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;xTilt());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::xTilt(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  x
- *    flags:    c
+/*!
+ * method rotation
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, x){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;x());
-	}
+
+ZEND_METHOD(QTabletEvent, rotation)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type qreal&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::rotation(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  globalX
- *    flags:    c
+/*!
+ * method pointerType
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	PointerType
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, globalX){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;globalX());
-	}
+
+ZEND_METHOD(QTabletEvent, pointerType)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type PointerType&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::pointerType(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  globalPos
- *    flags:    c
+/*!
+ * method yTilt
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, globalPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-				const QPoint &amp; return_object = (const QPoint &amp;) obj-&gt;globalPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTabletEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QTabletEvent, yTilt)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'yTilt' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTabletEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;yTilt());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::yTilt(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  y
- *    flags:    c
+/*!
+ * method z
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, y){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;y());
-	}
+
+ZEND_METHOD(QTabletEvent, z)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'z' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTabletEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;z());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::z(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  uniqueId
- *    flags:    c
+/*!
+ * method hiResGlobalX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, uniqueId){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			obj-&gt;uniqueId();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QTabletEvent, hiResGlobalX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type qreal&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::hiResGlobalX(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  hiResGlobalY
- *    flags:    c
+/*!
+ * method hiResGlobalY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, hiResGlobalY){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj-&gt;hiResGlobalY());
-	}
+
+ZEND_METHOD(QTabletEvent, hiResGlobalY)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type qreal&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::hiResGlobalY(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &amp;
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-				const QPoint &amp; return_object = (const QPoint &amp;) obj-&gt;pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTabletEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QTabletEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTabletEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::pos(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  xTilt
- *    flags:    c
+/*!
+ * method device
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	TabletDevice
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, xTilt){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;xTilt());
-	}
+
+ZEND_METHOD(QTabletEvent, device)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type TabletDevice&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::device(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  rotation
- *    flags:    c
+/*!
+ * method tangentialPressure
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, rotation){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_DOUBLE(obj-&gt;rotation());
-	}
+
+ZEND_METHOD(QTabletEvent, tangentialPressure)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type qreal&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::tangentialPressure(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  pointerType
- *    flags:    c
+/*!
+ * method globalX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, pointerType){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			obj-&gt;pointerType();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QTabletEvent, globalX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalX' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTabletEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;globalX());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::globalX(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  yTilt
- *    flags:    c
+/*!
+ * method globalPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &amp;
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, yTilt){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;yTilt());
-	}
+
+ZEND_METHOD(QTabletEvent, globalPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalPos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTabletEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;globalPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::globalPos(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  device
- *    flags:    c
+/*!
+ * method x
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, device){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			obj-&gt;device();
-			RETURN_NULL();
-	}
+
+ZEND_METHOD(QTabletEvent, x)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'x' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTabletEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;x());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::x(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  globalY
- *    flags:    c
+/*!
+ * method uniqueId
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qint64
+ * @flags	c
  */
-ZEND_METHOD(QTabletEvent, globalY){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;globalY());
-	}
+
+ZEND_METHOD(QTabletEvent, uniqueId)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type qint64&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::uniqueId(...) &quot;);
 }
 
-/*********************************
- *    class     QTabletEvent */
-/*
- *    function  z
- *    flags:    c
+/*!
+ * method QTabletEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Type ts0s0
+ * @param	const QPoint &amp;poss1s1
+ * @param	const QPoint &amp;globalPoss2s2
+ * @param	const QPointF &amp;hiResGlobalPoss3s3
+ * @param	int devices4s4
+ * @param	int pointerTypes5s5
+ * @param	qreal pressures6s6
+ * @param	int xTilts7s7
+ * @param	int yTilts8s8
+ * @param	qreal tangentialPressures9s9
+ * @param	qreal rotations10s10
+ * @param	int zs11s11
+ * @param	Qt::KeyboardModifiers keyStates12s12
+ * @param	qint64 uniqueIDs13s13
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QTabletEvent, z){
-	if (ZEND_NUM_ARGS() == 0){
-			QTabletEvent *obj = (QTabletEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;z());
-	}
+
+ZEND_METHOD(QTabletEvent, __construct)
+{
+// notice: unknown argument Type ts0s0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::QTabletEvent(...) &quot;);
 }
 
+/*!
+ * method globalY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QTabletEvent);
+ZEND_METHOD(QTabletEvent, globalY)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalY' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTabletEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTabletEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;globalY());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTabletEvent::globalY(...) &quot;);
+}

Modified: trunk/qt/classes/qtime.cpp
===================================================================
--- trunk/qt/classes/qtime.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qtime.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,447 +19,1055 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QTime.cpp - QTime PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QTime&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QTime */
-/*
- *    function  hour
- *    flags:    c
+#include &lt;QTime&gt;
+#include &lt;QMetaMethod&gt;
+class QTime_php_qt:public QTime
+{
+
+public:
+  QTime_php_qt(zval * zend_ptr);
+  QTime_php_qt(zval * zend_ptr, int hs0, int ms1, int s = 0, int ms = 0);
+
+
+  zval *zend_ptr;
+};
+
+QTime_php_qt::QTime_php_qt(zval * zend_ptr):QTime()
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QTime_php_qt::QTime_php_qt(zval * zend_ptr, int hs0, int ms1, int s, int ms):
+QTime(hs0, ms1, s, ms)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method hour
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTime, hour){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;hour());
-	}
+
+ZEND_METHOD(QTime, hour)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hour' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;hour());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::hour(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  isValid
- *    flags:    c
+/*!
+ * method isValid
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int h
+ * @param	 int m
+ * @param	 int s
+ * @param	 int ms = 0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QTime, isValid){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isValid());
-	}
-		/* llll public*/
 
-		/* int h, int m, int s, int ms,  */
+ZEND_METHOD(QTime, isValid)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isValid' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isValid());
+    }
+  }
+  ///int h, int m, int s, int ms = 0
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      /// try int h, int m, int s,
+      QTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QTime::isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+      } else {
+        RETURN_BOOL(selfpointer-&gt;isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+    }}
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      /// try int h, int m, int s, int ms = 0,
+      QTime *selfpointer;
 
-			RETURN_BOOL(obj-&gt;isValid((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3)));
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      if (getThis() == NULL) {
+        RETURN_BOOL(QTime::isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+      } else {
+        RETURN_BOOL(selfpointer-&gt;isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }}
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::isValid(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  elapsed
- *    flags:    c
+/*!
+ * method elapsed
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTime, elapsed){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;elapsed());
-	}
+
+ZEND_METHOD(QTime, elapsed)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'elapsed' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;elapsed());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::elapsed(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  toString
- *    flags:    c
+/*!
+ * method fromString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;ss0
+ * @param	 Qt::DateFormat f = Qt::TextDates1
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s
+ * @param	 const QString &amp;format
+ * 
+ * @access	public
+ * @return	QTime
+ * @flags	s
  */
-ZEND_METHOD(QTime, toString){
-		/* l public*/
 
-		/* int f,  */
-		/* o public*/
+ZEND_METHOD(QTime, fromString)
+{
+  ///const QString &amp;ss0, Qt::DateFormat f = Qt::TextDates1
+#ifdef PHP_QT_QTime             // return type
 
-		/* const QString&amp; format,  */
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;ss0,
+        QTime *selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
 
-				QString return_object = (QString) obj-&gt;toString((Qt::DateFormat) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QTime *return_object = new QTime;
 
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QTime &gt; (QTime::fromString((const QString &amp;)*cpp_arg_0));
+        } else {
+          *return_object = static_cast &lt; QTime &gt; (selfpointer-&gt;fromString((const QString &amp;)*cpp_arg_0));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QString return_object = (QString) obj-&gt;toString((const QString&amp;) obj_z_0);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_0 = invokeToQString(arg_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        /// try const QString &amp;ss0, Qt::DateFormat f = Qt::TextDates1,
+        QTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QTime *return_object = new QTime;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QTime &gt; (QTime::fromString((const QString &amp;)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
+        } else {
+          *return_object = static_cast &lt; QTime &gt; (selfpointer-&gt;fromString((const QString &amp;)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;s, const QString &amp;format
+#ifdef PHP_QT_QTime             // return type
+
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    arg_1 = invokeToQString(arg_1);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 59)) {
+        /// try const QString &amp;s, const QString &amp;format,
+        QTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QString *cpp_arg_1 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QTime *return_object = new QTime;
+
+        if (getThis() == NULL) {
+          *return_object = static_cast &lt; QTime &gt; (QTime::fromString((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        } else {
+          *return_object = static_cast &lt; QTime &gt; (selfpointer-&gt;fromString((const QString &amp;)*cpp_arg_0, (const QString &amp;)*cpp_arg_1));
+        } le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QTime::fromString(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  msec
- *    flags:    c
+/*!
+ * method second
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTime, msec){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;msec());
-	}
+
+ZEND_METHOD(QTime, second)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'second' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;second());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::second(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  secsTo
- *    flags:    c
+/*!
+ * method setHMS
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int hs0
+ * @param	 int ms1
+ * @param	 int ss2
+ * @param	 int ms = 0s3
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	
  */
-ZEND_METHOD(QTime, secsTo){
-		/* o public*/
 
-		/* const QTime&amp; ,  */
+ZEND_METHOD(QTime, setHMS)
+{
+  ///int hs0, int ms1, int ss2, int ms = 0s3
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setHMS' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int hs0, int ms1, int ss2,
+      QTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;setHMS((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setHMS' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int hs0, int ms1, int ss2, int ms = 0s3,
+      QTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;setHMS((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::setHMS(...) &quot;);
+}
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QTime&quot;) {
-				RETURN_LONG(obj-&gt;secsTo((const QTime&amp;) obj_z_0));
-			}
-			}
-		}
-	}
+/*!
+ * method minute
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QTime, minute)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minute' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;minute());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::minute(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  restart
- *    flags:    
+/*!
+ * method start
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QTime, restart){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;restart());
-	}
+
+ZEND_METHOD(QTime, start)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'start' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;start());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::start(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  fromString
- *    flags:    s
+/*!
+ * method operator&lt;
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QTime, fromString){
-		/* ol public*/
 
-		/* const QString&amp; s, int f,  */
-		/* oo public*/
+/*!
+ * method operator==
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-		/* const QString&amp; s, const QString&amp; format,  */
+/*!
+ * method addSecs
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int secss0
+ * 
+ * @access	public
+ * @return	QTime
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QTime, addSecs)
+{
+  ///int secss0
+#ifdef PHP_QT_QTime             // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addSecs' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int secss0,
+      QTime *selfpointer;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot;) {
-					QTime return_object = (QTime) obj-&gt;fromString((const QString&amp;) obj_z_0, (Qt::DateFormat) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QTime *return_object = new QTime;
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QString&quot; &amp;&amp; Z_OBJCE_P(z_1)-&gt;name == &quot;QString&quot;) {
-					QTime return_object = (QTime) obj-&gt;fromString((const QString&amp;) obj_z_0, (const QString&amp;) obj_z_1);
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-			}
-		}
-	}
+      *return_object = static_cast &lt; QTime &gt; (selfpointer-&gt;addSecs((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QTime::addSecs(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  second
- *    flags:    c
+/*!
+ * method currentTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QTime
+ * @flags	s
  */
-ZEND_METHOD(QTime, second){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;second());
-	}
+
+ZEND_METHOD(QTime, currentTime)
+{
+  ///
+#ifdef PHP_QT_QTime             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QTime *return_object = new QTime;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QTime &gt; (QTime::currentTime());
+      } else {
+        *return_object = static_cast &lt; QTime &gt; (selfpointer-&gt;currentTime());
+      }
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QTime::currentTime(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  QTime
- *    flags:    
+/*!
+ * method operator!=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QTime, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *QTime_ptr = new QTime();
-				PHP_QT_REGISTER(QTime_ptr);
-				RETURN_NULL();
-	}
-		/* llll public*/
 
-		/* int h, int m, int s, int ms,  */
+/*!
+ * method operator&gt;
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
+/*!
+ * method msec
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
+ZEND_METHOD(QTime, msec)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'msec' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
 
-			QTime *QTime_ptr = new QTime((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3));
-				PHP_QT_REGISTER(QTime_ptr);
-				RETURN_NULL();
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;msec());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::msec(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  addSecs
- *    flags:    c
+/*!
+ * method secsTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &amp;s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTime, addSecs){
-		/* l public*/
 
-		/* int secs,  */
+ZEND_METHOD(QTime, secsTo)
+{
+  ///const QTime &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QTime
+      if (inherits(Z_OBJCE_P(arg_0), 63)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'secsTo' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QTime &amp;s0,
+        QTime *selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+        }
+        QTime *cpp_arg_0 = static_cast &lt; QTime * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_LONG(selfpointer-&gt;secsTo((const QTime &amp;)*cpp_arg_0));
+      }
+#endif
 
-				QTime return_object = (QTime) obj-&gt;addSecs((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::secsTo(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  addMSecs
- *    flags:    c
+/*!
+ * method addMSecs
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int mss0
+ * 
+ * @access	public
+ * @return	QTime
+ * @flags	c
  */
-ZEND_METHOD(QTime, addMSecs){
-		/* l public*/
 
-		/* int ms,  */
+ZEND_METHOD(QTime, addMSecs)
+{
+  ///int mss0
+#ifdef PHP_QT_QTime             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'addMSecs' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int mss0,
+      QTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-				QTime return_object = (QTime) obj-&gt;addMSecs((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QTime *return_object = new QTime;
+
+      *return_object = static_cast &lt; QTime &gt; (selfpointer-&gt;addMSecs((int)Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QTime::addMSecs(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  currentTime
- *    flags:    s
+/*!
+ * method msecsTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &amp;s0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTime, currentTime){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-				QTime return_object = (QTime) obj-&gt;currentTime();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTime_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QTime, msecsTo)
+{
+  ///const QTime &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QTime
+      if (inherits(Z_OBJCE_P(arg_0), 63)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'msecsTo' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QTime &amp;s0,
+        QTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+        }
+        QTime *cpp_arg_0 = static_cast &lt; QTime * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;msecsTo((const QTime &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::msecsTo(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  minute
- *    flags:    c
+/*!
+ * method operator&lt;=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QTime, minute){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;minute());
-	}
-}
 
-/*********************************
- *    class     QTime */
-/*
- *    function  setHMS
- *    flags:    
+/*!
+ * method toString
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::DateFormat f = Qt::TextDates0
+ * 
+ * overloaded args:
+ * @param	const QString &amp;format
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
-ZEND_METHOD(QTime, setHMS){
-		/* llll public*/
 
-		/* int h, int m, int s, int ms,  */
+ZEND_METHOD(QTime, toString)
+{
+  ///Qt::DateFormat f = Qt::TextDates0
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 4){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		zval *z_3; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toString' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
 
-			RETURN_BOOL(obj-&gt;setHMS((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(int) Z_LVAL_P(z_3)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toString());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toString' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::DateFormat f = Qt::TextDates0,
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toString((Qt::DateFormat) Z_LVAL_P(arg_0)));
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+
+  ///const QString &amp;format
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'toString' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;format,
+        QTime *selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+        }
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *ce;
+
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry le;
+        QString *return_object = new QString;
+
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toString((const QString &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QTime::toString(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  isNull
- *    flags:    c
+/*!
+ * method restart
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	
  */
-ZEND_METHOD(QTime, isNull){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isNull());
-	}
+
+ZEND_METHOD(QTime, restart)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'restart' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;restart());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::restart(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  msecsTo
- *    flags:    c
+/*!
+ * method QTime
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int hs0
+ * @param	int ms1
+ * @param	 int s = 0
+ * @param	 int ms = 0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QTime, msecsTo){
-		/* o public*/
 
-		/* const QTime&amp; ,  */
+ZEND_METHOD(QTime, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTime_php_qt *selfpointer = new QTime_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///int hs0,int ms1, int s = 0, int ms = 0
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int hs0,int ms1,
+      QTime_php_qt *selfpointer = new QTime_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1));
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int hs0,int ms1, int s = 0,
+      QTime_php_qt *selfpointer = new QTime_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2));
 
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QTime&quot;) {
-				RETURN_LONG(obj-&gt;msecsTo((const QTime&amp;) obj_z_0));
-			}
-			}
-		}
-	}
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int hs0,int ms1, int s = 0, int ms = 0,
+      QTime_php_qt *selfpointer = new QTime_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::QTime(...) &quot;);
 }
 
-/*********************************
- *    class     QTime */
-/*
- *    function  start
- *    flags:    
+/*!
+ * method isNull
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QTime, start){
-	if (ZEND_NUM_ARGS() == 0){
-			QTime *obj = (QTime*) PHP_QT_FETCH();
-			obj-&gt;start();
-			RETURN_NULL();
-	}
-}
 
+ZEND_METHOD(QTime, isNull)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isNull' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTime *selfpointer;
 
-PHP_QT_DESTRUCT(QTime);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTime * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isNull());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTime::isNull(...) &quot;);
+}
 
+/*!
+ * method operator&gt;=
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QTime &amp;others0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */

Modified: trunk/qt/classes/qtimer.cpp
===================================================================
--- trunk/qt/classes/qtimer.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qtimer.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,365 +19,816 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QTimer.cpp - QTimer PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QTimer&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  tr
- *    flags:    s
- */
-ZEND_METHOD(QTimer, tr){
-		/* ss public*/
+#include &lt;QTimer&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QTimer_php_qt:public QTimer
+{
 
-		/* const char* , const char* ,  */
+public:
+  QTimer_php_qt(zval * zend_ptr, QObject * parent = 0);
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
 
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
-				QString return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTimer_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+QTimer_php_qt::QTimer_php_qt(zval * zend_ptr, QObject * parent):QTimer(parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QTimer&quot;,&amp;staticMetaObject));
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  qt_invoke
- *    flags:    v
+PHP_QT_MOC(QTimer);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QTimer, qt_invoke){
+
+ZEND_METHOD(QTimer, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QTimer::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QTimer::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  staticMetaObject
- *    flags:    s
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QTimer, staticMetaObject){
-}
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  setInterval
- *    flags:    
+/*!
+ * method timeout
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
  */
-ZEND_METHOD(QTimer, setInterval){
-		/* l public*/
 
-		/* int msec,  */
+/*!
+ * method singleShot
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int msecs0
+ * @param	 QObject *receivers1
+ * @param	 const char *members2
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
+ZEND_METHOD(QTimer, singleShot)
+{
+  ///int msecs0, QObject *receivers1, const char *members2
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_STRING) {
+#ifdef PHP_QT_QObject
+      if (inherits(Z_OBJCE_P(arg_1), 46)) {
+        /// try int msecs0, QObject *receivers1, const char *members2,
+        QTimer *
+          selfpointer;
 
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+        }
+        QObject *
+          cpp_arg_1 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_1));
 
-			obj-&gt;setInterval((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
+        if (getThis() == NULL) {
+          RETURN_VOID(QTimer::singleShot((int)Z_LVAL_P(arg_0), (QObject *) cpp_arg_1, (const char *)&amp;Z_STRVAL_P(arg_2)[0]));
+        } else {
+          RETURN_VOID(selfpointer-&gt;singleShot((int)Z_LVAL_P(arg_0), (QObject *) cpp_arg_1, (const char *)&amp;Z_STRVAL_P(arg_2)[0]));
+      }}
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::singleShot(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  qObject
- *    flags:    
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QTimer, qObject){
-}
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  timerId
- *    flags:    c
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
-ZEND_METHOD(QTimer, timerId){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;timerId());
-	}
-}
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  singleShot
- *    flags:    s
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QTimer, singleShot){
-		/* los public*/
 
-		/* int msec, qt_QObject* receiver, const char* member,  */
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 3){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_STRING){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) php_qt_fetch(z_1);
+/*!
+ * method start
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int msecs0
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
 
+ZEND_METHOD(QTimer, start)
+{
+  ///int msecs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'start' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int msecs0,
+      QTimer *
+        selfpointer;
 
-			if(obj_z_1-&gt;inherits(&quot;QObject&quot;)) {
-				obj-&gt;singleShot((int) Z_LVAL_P(z_0), (QObject*) obj_z_1, (const char*) Z_LVAL_P(z_2));
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;start((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'start' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;start());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::start(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  qt_cast
- *    flags:    v
+/*!
+ * method timerEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTimerEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QTimer, qt_cast){
-}
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  metaObject
- *    flags:    cv
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QTimer, metaObject){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-				QMetaObject * return_object = (QMetaObject *) obj-&gt;metaObject();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTimer_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QTimer, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QTimer::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  stop
- *    flags:    l
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QTimer, stop){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			obj-&gt;stop();
-			RETURN_NULL();
-	}
+
+/*!
+ * method timerId
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QTimer, timerId)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'timerId' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;timerId());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::timerId(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  isActive
- *    flags:    c
+/*!
+ * method killTimer
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	private
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QTimer, isActive){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isActive());
-	}
+
+ZEND_METHOD(QTimer, killTimer)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QTimer::killTimer(...) cannot be called with 'int ints0,'.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::killTimer(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  QTimer
- *    flags:    t
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QTimer, __construct){
-		/* o public*/
 
-		/* qt_QObject* parent,  */
+/*!
+ * method isSingleShot
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+ZEND_METHOD(QTimer, isSingleShot)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isSingleShot' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer *
+        selfpointer;
 
-
-			if(obj_z_0-&gt;inherits(&quot;QObject&quot;)) {
-				QTimer *QTimer_ptr = new QTimer((QObject*) obj_z_0);
-				PHP_QT_REGISTER(QTimer_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isSingleShot());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::isSingleShot(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  qt_emit
- *    flags:    v
+/*!
+ * method interval
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QTimer, qt_emit){
+
+ZEND_METHOD(QTimer, interval)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'interval' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;interval());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::interval(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  interval
- *    flags:    c
+/*!
+ * method setInterval
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int msecs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QTimer, interval){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;interval());
-	}
+
+ZEND_METHOD(QTimer, setInterval)
+{
+  ///int msecs0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setInterval' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int msecs0,
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setInterval((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::setInterval(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  setSingleShot
- *    flags:    
+/*!
+ * method stop
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
-ZEND_METHOD(QTimer, setSingleShot){
-		/* l public*/
 
-		/* int singleShot,  */
+ZEND_METHOD(QTimer, stop)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'stop' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer *
+        selfpointer;
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;stop());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::stop(...) &quot;);
+}
 
+/*!
+ * method isActive
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
 
-			obj-&gt;setSingleShot((bool) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+ZEND_METHOD(QTimer, isActive)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isActive' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer *
+        selfpointer;
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  className
- *    flags:    cv
- */
-ZEND_METHOD(QTimer, className){
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isActive());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::isActive(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  trUtf8
- *    flags:    s
+/*!
+ * method QTimer
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QObject *parent = 0s0
+ * 
+ * overloaded args:
+ * @param	const QTimer &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QTimer, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+ZEND_METHOD(QTimer, __construct)
+{
+  ///QObject *parent = 0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTimer_php_qt *
+        selfpointer = new QTimer_php_qt(getThis());
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QObject *parent = 0s0,
+      QObject *
+        cpp_arg_0 = static_cast &lt; QObject * &gt;(php_qt_fetch(arg_0));
+      QTimer_php_qt *
+        selfpointer = new QTimer_php_qt(getThis(), (QObject *) cpp_arg_0);
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///const QTimer &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QTimer
+      if (inherits(Z_OBJCE_P(arg_0), 64)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QTimer::__construct(...) cannot be called with 'const QTimer &amp;,'.&quot;);
+      }
+#endif
 
-				QString return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QTimer_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::QTimer(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  qt_property
- *    flags:    v
+/*!
+ * method setSingleShot
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool singleShots0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QTimer, qt_property){
+
+ZEND_METHOD(QTimer, setSingleShot)
+{
+  ///bool singleShots0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setSingleShot' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool singleShots0,
+      QTimer *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setSingleShot((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::setSingleShot(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  isSingleShot
- *    flags:    c
+/*!
+ * method startTimer
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	private
+ * @return	int
+ * @flags	
  */
-ZEND_METHOD(QTimer, isSingleShot){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isSingleShot());
-	}
+
+ZEND_METHOD(QTimer, startTimer)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QTimer::startTimer(...) cannot be called with 'int ints0,'.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::startTimer(...) &quot;);
 }
 
-/*********************************
- *    class     QTimer */
-/*
- *    function  start
- *    flags:    l
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QTimer, start){
-	if (ZEND_NUM_ARGS() == 0){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
-			obj-&gt;start();
-			RETURN_NULL();
-	}
-		/* l public_slots*/
 
-		/* int msec,  */
+ZEND_METHOD(QTimer, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QTimer *obj = (QTimer*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QTimer *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			obj-&gt;start((int) Z_LVAL_P(z_0));
-			RETURN_NULL();
-			}
-		}
-	}
-}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QTimer::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QTimer *
+        selfpointer;
 
-PHP_QT_DESTRUCT(QTimer);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimer * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QTimer::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QTimer::trUtf8(...) &quot;);
+}

Modified: trunk/qt/classes/qtimerevent.cpp
===================================================================
--- trunk/qt/classes/qtimerevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qtimerevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QTimerEvent.cpp - QTimerEvent PHP implementation.
- * begin           : Tue Apr 11 10:33:13 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -31,28 +30,85 @@
 
 
 #include &lt;QTimerEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QTimerEvent_php_qt:public QTimerEvent
+{
 
+public:
+  QTimerEvent_php_qt(zval * zend_ptr, int timerIds0);
+
+
+  zval *zend_ptr;
+};
+QTimerEvent_php_qt::QTimerEvent_php_qt(zval * zend_ptr, int timerIds0):
+QTimerEvent(timerIds0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
 /*!
- *    @class     QTimerEvent
- *    @function  timerId
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method timerId
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QTimerEvent, timerId)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'timerId' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QTimerEvent *selfpointer;
 
-    if (getThis() != NULL) {
-      QTimerEvent *obj = (QTimerEvent *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;timerId());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QTimerEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;timerId());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QTimerEvent::timerId(...) &quot;);
 }
 
+/*!
+ * method QTimerEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int timerIds0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QTimerEvent);
+ZEND_METHOD(QTimerEvent, __construct)
+{
+  ///int timerIds0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int timerIds0s0,
+      QTimerEvent_php_qt *selfpointer = new QTimerEvent_php_qt(getThis(), (int)Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QTimerEvent::QTimerEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qtoolbarchangeevent.cpp
===================================================================
--- trunk/qt/classes/qtoolbarchangeevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qtoolbarchangeevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,30 +19,98 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QToolBarChangeEvent.cpp - QToolBarChangeEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QToolBarChangeEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QToolBarChangeEvent */
-/*
- *    function  toggle
- *    flags:    c
+#include &lt;QToolBarChangeEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QToolBarChangeEvent_php_qt:public QToolBarChangeEvent
+{
+
+public:
+  QToolBarChangeEvent_php_qt(zval * zend_ptr, bool ts0);
+
+
+  zval *zend_ptr;
+};
+
+QToolBarChangeEvent_php_qt::QToolBarChangeEvent_php_qt(zval * zend_ptr, bool ts0):QToolBarChangeEvent(ts0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method toggle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QToolBarChangeEvent, toggle){
-	if (ZEND_NUM_ARGS() == 0){
-			QToolBarChangeEvent *obj = (QToolBarChangeEvent*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;toggle());
-	}
+
+ZEND_METHOD(QToolBarChangeEvent, toggle)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toggle' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QToolBarChangeEvent *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolBarChangeEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;toggle());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QToolBarChangeEvent::toggle(...) &quot;);
 }
 
+/*!
+ * method QToolBarChangeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool ts0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
 
-PHP_QT_DESTRUCT(QToolBarChangeEvent);
+ZEND_METHOD(QToolBarChangeEvent, __construct)
+{
+  ///bool ts0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool ts0s0,
+      QToolBarChangeEvent_php_qt *
+        selfpointer = new QToolBarChangeEvent_php_qt(getThis(), (bool) Z_LVAL_P(arg_0));
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QToolBarChangeEvent::QToolBarChangeEvent(...) &quot;);
+}

Modified: trunk/qt/classes/qtoolbutton.cpp
===================================================================
--- trunk/qt/classes/qtoolbutton.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qtoolbutton.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QToolButton.cpp - QToolButton PHP implementation.
- * begin           : Thu May 11 21:32:50 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -31,719 +30,1147 @@
 
 
 #include &lt;QToolButton&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QToolButton_php_qt:public QToolButton
+{
 
+public:
+  QToolButton_php_qt(zval * zend_ptr, QWidget * parent = 0);
 
-/*		public enumToolButtonPopupMode:long {
-			ToolButtonPopupMode = 0,
-			ToolButtonPopupMode = 1,
-			ToolButtonPopupMode = 2
-		}
-*/
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
+
+QToolButton_php_qt::QToolButton_php_qt(zval * zend_ptr, QWidget * parent):QToolButton(parent)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QToolButton&quot;,&amp;staticMetaObject));
+}
+
+PHP_QT_MOC(QToolButton);
+
 /*!
- *    @class     QToolButton
- *    @function  tr
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
+
 ZEND_METHOD(QToolButton, tr)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QToolButton *
+        selfpointer;
 
-        QString *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast &lt; QString &gt; (obj-&gt;tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QToolButton::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));   /// memory allocation
-          *return_object = static_cast &lt; QString &gt; (QToolButton::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        object_init_ex(return_value, QToolButton_ce_ptr);
-        zend_rsrc_list_entry le;
-
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QToolButton::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
       } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING) {
-        QString *return_object;
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QToolButton *
+        selfpointer;
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          QToolButton *obj = static_cast&lt;QToolButton *&gt;(PHP_QT_FETCH());
-          *return_object = static_cast &lt; QString &gt; (obj-&gt;tr((const char *)Z_STRVAL_P(z_0)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QToolButton::tr((const char *)Z_STRVAL_P(z_0))));   /// memory allocation
-          *return_object = static_cast &lt; QString &gt; (QToolButton::tr((const char *)Z_STRVAL_P(z_0)));
-        } zend_class_entry *ce;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        object_init_ex(return_value, QToolButton_ce_ptr);
-        zend_rsrc_list_entry le;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QToolButton::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
       } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::tr(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  defaultAction
- *
- *    @flags    c
- *    @access    public
- *    @return    QAction *
- *    @param    
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QToolButton, defaultAction)
-{
-  if (ZEND_NUM_ARGS() == 0) {
-    QAction **return_object;
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+/*!
+ * method actionEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QActionEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
+ */
 
-/// return: pointer
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
+ */
 
-/// return value is object: QAction *
-      *return_object = static_cast &lt; QAction * &gt;(obj-&gt;defaultAction());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
-    }
-    zend_class_entry *ce;
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-    object_init_ex(return_value, QToolButton_ce_ptr);
-    zend_rsrc_list_entry le;
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
-}
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
 /*!
- *    @class     QToolButton
- *    @function  showMenu
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method enterEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, showMenu)
+
+/*!
+ * method setToolButtonStyle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::ToolButtonStyle styles0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QToolButton, setToolButtonStyle)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+  ///Qt::ToolButtonStyle styles0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setToolButtonStyle' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::ToolButtonStyle styles0,
+      QToolButton *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
-
-      obj-&gt;showMenu();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setToolButtonStyle((Qt::ToolButtonStyle) Z_LVAL_P(arg_0)));
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::setToolButtonStyle(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  autoRaise
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method setMenu
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMenu * menus0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, autoRaise)
+
+ZEND_METHOD(QToolButton, setMenu)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+  ///QMenu * menus0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QMenu
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setMenu' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QMenu * menus0,
+        QToolButton *
+          selfpointer;
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+        }
+        QMenu *
+          cpp_arg_0 = static_cast &lt; QMenu * &gt;(php_qt_fetch(arg_0));
 
-      RETURN_BOOL(obj-&gt;autoRaise());
-    }                           /// 5 END getThis(), simple types
+        RETURN_VOID(selfpointer-&gt;setMenu((QMenu *) cpp_arg_0));
+      }
+#endif
+
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::setMenu(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  staticMetaObject
- *
- *    @flags    s
- *    @access    public
- *    @return    QMetaObject*
- *    @param    
+ * method timerEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTimerEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, staticMetaObject)
-{
-}
 
 /*!
- *    @class     QToolButton
- *    @function  arrowType
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::ArrowType
- *    @param    
+ * method defaultAction
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QAction *
+ * @flags	c
  */
-ZEND_METHOD(QToolButton, arrowType)
+
+ZEND_METHOD(QToolButton, defaultAction)
 {
+  ///
+#ifdef PHP_QT_QAction           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::ArrowType * return_object;
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'defaultAction' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-      RETURN_LONG(obj-&gt;arrowType());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast &lt; QAction * &gt;(selfpointer-&gt;defaultAction());
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::defaultAction(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  setDefaultAction
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QAction *
+ * method autoRaise
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QToolButton, setDefaultAction)
+
+ZEND_METHOD(QToolButton, autoRaise)
 {
-///qt_QAction*
-/*! o public*/
-/*! qt_QAction* ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'autoRaise' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
-
-        if (obj_z_0-&gt;inherits(&quot;QAction&quot;)) {
-          void *return_object;
-
-          if (getThis() != NULL) {
-            obj-&gt;setDefaultAction((QAction *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;autoRaise());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::autoRaise(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  popupMode
- *
- *    @flags    c
- *    @access    public
- *    @return    ToolButtonPopupMode
- *    @param    
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
  */
-ZEND_METHOD(QToolButton, popupMode)
+
+ZEND_METHOD(QToolButton, staticMetaObject)
 {
-/*  if (ZEND_NUM_ARGS() == 0) {
-    ToolButtonPopupMode *return_object;
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QToolButton *
+        selfpointer;
 
-      obj-&gt;popupMode();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
-  }*/
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QToolButton::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::staticMetaObject(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  qObject
- *
- *    @flags    
- *    @access    public
- *    @return    QObject*
- *    @param    
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QToolButton, qObject)
-{
-}
 
 /*!
- *    @class     QToolButton
- *    @function  minimumSizeHint
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method minimumSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QToolButton, minimumSizeHint)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumSizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;minimumSizeHint());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;minimumSizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QToolButton_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::minimumSizeHint(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  sizeHint
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method triggered
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QAction *s0
+ * 
+ * @access	public
+ * @return	Q_SIGNALS: void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, sizeHint)
+
+ZEND_METHOD(QToolButton, triggered)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+  ///QAction *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'triggered' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QAction *s0,
+        QToolButton *
+          selfpointer;
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+        }
+        QAction *
+          cpp_arg_0 = static_cast &lt; QAction * &gt;(php_qt_fetch(arg_0));
 
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;sizeHint());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+        RETURN_VOID(selfpointer-&gt;triggered((QAction *) cpp_arg_0));
+      }
+#endif
+
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QToolButton_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::triggered(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  QToolButton
- *
- *    @flags    t
- *    @access    public
- *    @return    
- *    @param    QWidget * parent=0
+ * method toolButtonStyle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::ToolButtonStyle
+ * @flags	c
  */
-ZEND_METHOD(QToolButton, __construct)
+
+ZEND_METHOD(QToolButton, toolButtonStyle)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* parent,  */
-
+  ///
   if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toolButtonStyle' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-    QToolButton *QToolButton_ptr = new QToolButton();
-    PHP_QT_REGISTER(QToolButton_ptr);
-    RETURN_NULL();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;toolButtonStyle());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::toolButtonStyle(...) &quot;);
+}
 
-  }                             /// END ZEND_NUM_ARGS
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
+/*!
+ * method setAutoRaise
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enables0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QToolButton, setAutoRaise)
+{
+  ///bool enables0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setAutoRaise' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool enables0,
+      QToolButton *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setAutoRaise((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::setAutoRaise(...) &quot;);
+}
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          QToolButton *QToolButton_ptr = new QToolButton((QWidget *) obj_z_0);
+/*!
+ * method arrowType
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::ArrowType
+ * @flags	c
+ */
 
-          PHP_QT_REGISTER(QToolButton_ptr);
-          RETURN_NULL();
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+ZEND_METHOD(QToolButton, arrowType)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'arrowType' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;arrowType());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::arrowType(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  menu
- *
- *    @flags    c
- *    @access    public
- *    @return    QMenu*
- *    @param    
+ * method setDefaultAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QAction *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, menu)
+
+ZEND_METHOD(QToolButton, setDefaultAction)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    QMenu **return_object;
+  ///QAction *s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setDefaultAction' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QAction *s0,
+        QToolButton *
+          selfpointer;
 
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+        }
+        QAction *
+          cpp_arg_0 = static_cast &lt; QAction * &gt;(php_qt_fetch(arg_0));
 
-/// return: pointer
+        RETURN_VOID(selfpointer-&gt;setDefaultAction((QAction *) cpp_arg_0));
+      }
+#endif
 
-/// return value is object: QMenu*
-      *return_object = static_cast &lt; QMenu * &gt;(obj-&gt;menu());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QToolButton_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::setDefaultAction(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  nextCheckState
- *
- *    @flags    
- *    @access    protected
- *    @return    void
- *    @param    
+ * method leaveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method nextCheckState is protected, skipped.
 
 /*!
- *    @class     QToolButton
- *    @function  triggered
- *
- *    @flags    
- *    @access    public
- *    @return    Q_SIGNALS: void
- *    @param    QAction *
+ * method nextCheckState
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, triggered)
-{
-///qt_QAction*
-/*! o public*/
-/*! qt_QAction* ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+/*!
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *es0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
+ */
 
-        if (obj_z_0-&gt;inherits(&quot;QAction&quot;)) {
-          void *return_object;
+/*!
+ * method setPopupMode
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	ToolButtonPopupMode modes0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-          if (getThis() != NULL) {
-//            obj-&gt;triggered((QAction *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+ZEND_METHOD(QToolButton, setPopupMode)
+{
+// notice: unknown argument ToolButtonPopupMode modes0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::setPopupMode(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  event
- *
- *    @flags    
- *    @access    protected
- *    @return    bool
- *    @param    QEvent *e
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method event is protected, skipped.
 
 /*!
- *    @class     QToolButton
- *    @function  toolButtonStyle
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::ToolButtonStyle
- *    @param    
+ * method setArrowType
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::ArrowType types0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, toolButtonStyle)
+
+ZEND_METHOD(QToolButton, setArrowType)
 {
-  if (ZEND_NUM_ARGS() == 0) {
-    Qt::ToolButtonStyle * return_object;
-    if (getThis() != NULL) {
-      QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+  ///Qt::ArrowType types0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setArrowType' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::ArrowType types0,
+      QToolButton *
+        selfpointer;
 
-      obj-&gt;toolButtonStyle();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setArrowType((Qt::ArrowType) Z_LVAL_P(arg_0)));
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::setArrowType(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  setPopupMode
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    ToolButtonPopupMode mode
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, setPopupMode)
-{
-///ToolButtonPopupMode
-/*! o public*/
-/*! ToolButtonPopupMode mode,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+/*!
+ * method showMenu
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
-        if (obj_z_0-&gt;inherits(&quot;ToolButtonPopupMode&quot;)) {
-          void *return_object;
+ZEND_METHOD(QToolButton, showMenu)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'showMenu' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-          if (getThis() != NULL) {
-//            obj-&gt;setPopupMode((ToolButtonPopupMode) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;showMenu());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::showMenu(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  setToolButtonStyle
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::ToolButtonStyle style
+ * method mousePressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QToolButton, setToolButtonStyle)
-{
-///Qt::ToolButtonStyle
-/*! o public*/
-/*! Qt::ToolButtonStyle style,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+/*!
+ * method popupMode
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	ToolButtonPopupMode
+ * @flags	c
+ */
 
-        if (obj_z_0-&gt;inherits(&quot;Qt::ToolButtonStyle&quot;)) {
-          void *return_object;
-
-          if (getThis() != NULL) {
-  //          obj-&gt;setToolButtonStyle((Qt::ToolButtonStyle) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+ZEND_METHOD(QToolButton, popupMode)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type ToolButtonPopupMode&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::popupMode(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  trUtf8
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QToolButton, trUtf8)
+
+ZEND_METHOD(QToolButton, sizeHint)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-        QString *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast &lt; QString &gt; (obj-&gt;trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QToolButton::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));       /// memory allocation
-          *return_object = static_cast &lt; QString &gt; (QToolButton::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
 
-        object_init_ex(return_value, QToolButton_ce_ptr);
-        zend_rsrc_list_entry le;
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::sizeHint(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  setMenu
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QMenu* menu
+ * method QToolButton
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * parent=0s0
+ * 
+ * overloaded args:
+ * @param	QToolButtonPrivate &amp;
+ * @param	 QWidget* parent
+ * 
+ * overloaded args:
+ * @param	const QToolButton &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QToolButton, setMenu)
+
+ZEND_METHOD(QToolButton, __construct)
 {
-///QMenu*
-/*! o public*/
-/*! QMenu* menu,  */
+  ///QWidget * parent=0s0
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton_php_qt *
+        selfpointer = new QToolButton_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget * parent=0s0,
+      QWidget *
+        cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QToolButton_php_qt *
+        selfpointer = new QToolButton_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QToolButtonPrivate &amp;, QWidget* parent
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QToolButtonPrivate
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 71)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QToolButtonPrivate &amp;, QWidget* parent,
+        QToolButtonPrivate *
+          cpp_arg_0 = static_cast &lt; QToolButtonPrivate * &gt;(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+        QToolButton_php_qt *
+          selfpointer = new QToolButton_php_qt(getThis(), (QToolButtonPrivate &amp;) * cpp_arg_0, (QWidget *) cpp_arg_1);
 
-        if (obj_z_0-&gt;inherits(&quot;QMenu&quot;)) {
-          void *return_object;
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setMenu((QMenu *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+#endif
+
+    }
+  }
+  ///const QToolButton &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QToolButton
+      if (inherits(Z_OBJCE_P(arg_0), 67)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QToolButton::__construct(...) cannot be called with 'const QToolButton &amp;,'.&quot;);
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::QToolButton(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  setAutoRaise
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool enable
+ * method menu
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMenu*
+ * @flags	c
  */
-ZEND_METHOD(QToolButton, setAutoRaise)
+
+ZEND_METHOD(QToolButton, menu)
 {
-/*! l public*/
-/*! int enable,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+  ///
+#ifdef PHP_QT_QMenu             // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'menu' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QToolButton *
+        selfpointer;
 
-        void *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-          obj-&gt;setAutoRaise((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast &lt; QMenu * &gt;(selfpointer-&gt;menu());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::menu(...) &quot;);
 }
 
 /*!
- *    @class     QToolButton
- *    @function  setArrowType
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::ArrowType type
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QToolButton, setArrowType)
+
+ZEND_METHOD(QToolButton, trUtf8)
 {
-/*! l public*/
-/*! int type,  */
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QToolButton *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QToolButton *obj = (QToolButton *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        void *return_object;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        if (getThis() != NULL) {
-          obj-&gt;setArrowType((Qt::ArrowType) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QToolButton::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
       } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QToolButton *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QToolButton * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-PHP_QT_DESTRUCT(QToolButton);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QToolButton::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QToolButton::trUtf8(...) &quot;);
+}

Modified: trunk/qt/classes/qvboxlayout.cpp
===================================================================
--- trunk/qt/classes/qvboxlayout.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qvboxlayout.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,143 +19,412 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QVBoxLayout.cpp - QVBoxLayout PHP implementation.
- * begin           : Thu Feb 23 16:39:38 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
+
 #include &quot;../php_qt.h&quot;
 
 
 #include &lt;QVBoxLayout&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QVBoxLayout_php_qt:public QVBoxLayout
+{
 
-/*********************************
- *    class     QVBoxLayout
- *    function  tr
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
- */
-ZEND_METHOD(QVBoxLayout, tr){
-		/* ss public*/
+public:
+  QVBoxLayout_php_qt(zval * zend_ptr);
+  QVBoxLayout_php_qt(zval * zend_ptr, QWidget * parents0);
 
-		/* const char* , const char* ,  */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QVBoxLayout *obj = (QVBoxLayout*) PHP_QT_FETCH();
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+};
 
+QVBoxLayout_php_qt::QVBoxLayout_php_qt(zval * zend_ptr):QVBoxLayout()
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QVBoxLayout&quot;,&amp;staticMetaObject));
+}
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QVBoxLayout::tr( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QVBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+QVBoxLayout_php_qt::QVBoxLayout_php_qt(zval * zend_ptr, QWidget * parents0):QVBoxLayout(parents0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QVBoxLayout&quot;,&amp;staticMetaObject));
 }
 
-/*********************************
- *    class     QVBoxLayout
- *    function  staticMetaObject
- *    flags:    s
- *    access:    public
- *    return:    QMetaObject*
- *    params:    
+PHP_QT_MOC(QVBoxLayout);
+
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
-ZEND_METHOD(QVBoxLayout, staticMetaObject){
+
+ZEND_METHOD(QVBoxLayout, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QVBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QVBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QVBoxLayout::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QVBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QVBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QVBoxLayout::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QVBoxLayout::tr(...) &quot;);
 }
 
-/*********************************
- *    class     QVBoxLayout
- *    function  qObject
- *    flags:    
- *    access:    public
- *    return:    QObject*
- *    params:    
+/*!
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
-ZEND_METHOD(QVBoxLayout, qObject){
-}
 
-/*********************************
- *    class     QVBoxLayout
- *    function  trUtf8
- *    flags:    s
- *    access:    public
- *    return:    QString
- *    params:     const char *, const char * = 0 
+/*!
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
-ZEND_METHOD(QVBoxLayout, trUtf8){
-		/* ss public*/
 
-		/* const char* , const char* ,  */
+/*!
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
+ */
 
-	if (ZEND_NUM_ARGS() == 2){
-		zval *z_0; // define ZVAL
-		zval *z_1; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING){
-			QVBoxLayout *obj = (QVBoxLayout*) PHP_QT_FETCH();
+/*!
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
 
+/*!
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
+ */
 
-			QString* return_object;
-			// check whether method call is static.
-			if(getThis() != NULL){
-				*return_object = (QString) obj-&gt;trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			} else {
-				*return_object = (QString) QVBoxLayout::trUtf8( (const char*) Z_STRVAL_P(z_0) , (const char*) Z_STRVAL_P(z_1));
-			}
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QVBoxLayout_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-			} else { php_error(E_ERROR,&quot;argument not allowed&quot;); }
-		}
-	}
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
+ */
+
+ZEND_METHOD(QVBoxLayout, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QVBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QVBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QVBoxLayout::staticMetaObject());
+      } else {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QVBoxLayout::staticMetaObject(...) &quot;);
 }
 
-/*********************************
- *    class     QVBoxLayout
- *    function  QVBoxLayout
- *    flags:    
- *    access:    public
- *    return:    
- *    params:    
+/*!
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QVBoxLayout, __construct){
-	if (ZEND_NUM_ARGS() == 0){
-			QVBoxLayout *QVBoxLayout_ptr = new QVBoxLayout();
-				PHP_QT_REGISTER(QVBoxLayout_ptr);
-				RETURN_NULL();
-	}
-/// handmade
-    if (ZEND_NUM_ARGS() == 1){
-    	zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-            QWidget *qw = static_cast&lt;QWidget*&gt;(php_qt_fetch(z_0));
-			QVBoxLayout *QVBoxLayout_ptr = new QVBoxLayout(qw);
-			PHP_QT_REGISTER(QVBoxLayout_ptr);
-			RETURN_NULL();
+
+/*!
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
+ */
+
+/*!
+ * method QVBoxLayout
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parents0
+ * 
+ * overloaded args:
+ * @param	const QVBoxLayout &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	
+ */
+
+ZEND_METHOD(QVBoxLayout, __construct)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QVBoxLayout_php_qt *
+        selfpointer = new QVBoxLayout_php_qt(getThis());
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  ///QWidget *parents0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
         }
-	}
+        /// try QWidget *parents0,
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+        QVBoxLayout_php_qt *
+          selfpointer = new QVBoxLayout_php_qt(getThis(), (QWidget *) cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QVBoxLayout &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QVBoxLayout
+      if (inherits(Z_OBJCE_P(arg_0), 68)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QVBoxLayout::__construct(...) cannot be called with 'const QVBoxLayout &amp;,'.&quot;);
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QVBoxLayout::QVBoxLayout(...) &quot;);
 }
 
+/*!
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
 
-PHP_QT_DESTRUCT(QVBoxLayout);
+ZEND_METHOD(QVBoxLayout, trUtf8)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QVBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QVBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QVBoxLayout::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QVBoxLayout *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QVBoxLayout * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QVBoxLayout::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QVBoxLayout::trUtf8(...) &quot;);
+}

Modified: trunk/qt/classes/qwhatsthisclickedevent.cpp
===================================================================
--- trunk/qt/classes/qwhatsthisclickedevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qwhatsthisclickedevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,36 +19,117 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QWhatsThisClickedEvent.cpp - QWhatsThisClickedEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QWhatsThisClickedEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QWhatsThisClickedEvent */
-/*
- *    function  href
- *    flags:    c
+#include &lt;QWhatsThisClickedEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QWhatsThisClickedEvent_php_qt:public QWhatsThisClickedEvent
+{
+
+public:
+  QWhatsThisClickedEvent_php_qt(zval * zend_ptr, const QString &amp; hrefs0);
+
+
+  zval *zend_ptr;
+};
+QWhatsThisClickedEvent_php_qt::QWhatsThisClickedEvent_php_qt(zval * zend_ptr, const QString &amp; hrefs0):
+QWhatsThisClickedEvent(hrefs0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QWhatsThisClickedEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;hrefs0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QWhatsThisClickedEvent, href){
-	if (ZEND_NUM_ARGS() == 0){
-			QWhatsThisClickedEvent *obj = (QWhatsThisClickedEvent*) PHP_QT_FETCH();
-				QString return_object = (QString) obj-&gt;href();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWhatsThisClickedEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWhatsThisClickedEvent, __construct)
+{
+  ///const QString &amp;hrefs0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
+
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;hrefs0s0,
+        QString *cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
+        QWhatsThisClickedEvent_php_qt *selfpointer = new QWhatsThisClickedEvent_php_qt(getThis(), (const QString &amp;)*cpp_arg_0);
+
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWhatsThisClickedEvent::QWhatsThisClickedEvent(...) &quot;);
 }
 
+/*!
+ * method href
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QWhatsThisClickedEvent);
+ZEND_METHOD(QWhatsThisClickedEvent, href)
+{
+  ///
+#ifdef PHP_QT_QString           // return type
 
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'href' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWhatsThisClickedEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWhatsThisClickedEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+      QString *return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;href());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWhatsThisClickedEvent::href(...) &quot;);
+}

Modified: trunk/qt/classes/qwheelevent.cpp
===================================================================
--- trunk/qt/classes/qwheelevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qwheelevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,152 +19,486 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QWheelEvent.cpp - QWheelEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QWheelEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  orientation
- *    flags:    c
+#include &lt;QWheelEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QWheelEvent_php_qt:public QWheelEvent
+{
+
+public:
+  QWheelEvent_php_qt(zval * zend_ptr, const QPoint &amp; poss0, int deltas1, Qt::MouseButtons buttonss2, Qt::KeyboardModifiers modifierss3, Qt::Orientation orient =
+                     Qt::Vertical);
+    QWheelEvent_php_qt(zval * zend_ptr, const QPoint &amp; poss0, const QPoint &amp; globalPoss1, int deltas2, Qt::MouseButtons buttonss3,
+                       Qt::KeyboardModifiers modifierss4, Qt::Orientation orient = Qt::Vertical);
+
+
+  zval *zend_ptr;
+};
+QWheelEvent_php_qt::QWheelEvent_php_qt(zval * zend_ptr, const QPoint &amp; poss0, int deltas1, Qt::MouseButtons buttonss2, Qt::KeyboardModifiers modifierss3,
+                                       Qt::Orientation orient):
+QWheelEvent(poss0, deltas1, buttonss2, modifierss3, orient)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+QWheelEvent_php_qt::QWheelEvent_php_qt(zval * zend_ptr, const QPoint &amp; poss0, const QPoint &amp; globalPoss1, int deltas2, Qt::MouseButtons buttonss3,
+                                       Qt::KeyboardModifiers modifierss4, Qt::Orientation orient):
+QWheelEvent(poss0, globalPoss1, deltas2, buttonss3, modifierss4, orient)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method y
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, orientation){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;orientation());
-	}
+
+ZEND_METHOD(QWheelEvent, y)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'y' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWheelEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;y());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWheelEvent::y(...) &quot;);
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  x
- *    flags:    c
+/*!
+ * method delta
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, x){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;x());
-	}
+
+ZEND_METHOD(QWheelEvent, delta)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'delta' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWheelEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;delta());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWheelEvent::delta(...) &quot;);
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  globalX
- *    flags:    c
+/*!
+ * method QWheelEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;poss0s0
+ * @param	int deltas1s1
+ * @param	Qt::MouseButtons buttonss2s2
+ * @param	Qt::KeyboardModifiers modifierss3s3
+ * @param	 Qt::Orientation orient = Qt::Verticals4
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;poss0
+ * @param	const QPoint&amp; globalPoss1
+ * @param	int deltas2
+ * @param	Qt::MouseButtons buttonss3
+ * @param	Qt::KeyboardModifiers modifierss4
+ * @param	 Qt::Orientation orient = Qt::Vertical
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QWheelEvent, globalX){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;globalX());
-	}
+
+ZEND_METHOD(QWheelEvent, __construct)
+{
+  ///const QPoint &amp;poss0s0,int deltas1s1,Qt::MouseButtons buttonss2s2,Qt::KeyboardModifiers modifierss3s3, Qt::Orientation orient = Qt::Verticals4
+  if (ZEND_NUM_ARGS() == 4) {
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;poss0s0,int deltas1s1,Qt::MouseButtons buttonss2s2,Qt::KeyboardModifiers modifierss3s3,
+        QPoint *cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QWheelEvent_php_qt *selfpointer =
+          new QWheelEvent_php_qt(getThis(), (const QPoint &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::MouseButtons) Z_LVAL_P(arg_2),
+                                 (Qt::KeyboardModifiers) Z_LVAL_P(arg_3));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;poss0s0,int deltas1s1,Qt::MouseButtons buttonss2s2,Qt::KeyboardModifiers modifierss3s3, Qt::Orientation orient = Qt::Verticals4,
+        QPoint *cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QWheelEvent_php_qt *selfpointer =
+          new QWheelEvent_php_qt(getThis(), (const QPoint &amp;)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::MouseButtons) Z_LVAL_P(arg_2),
+                                 (Qt::KeyboardModifiers) Z_LVAL_P(arg_3), (Qt::Orientation) Z_LVAL_P(arg_4));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+    }
+  }
+  ///const QPoint &amp;poss0,const QPoint&amp; globalPoss1,int deltas2,Qt::MouseButtons buttonss3,Qt::KeyboardModifiers modifierss4, Qt::Orientation orient = Qt::Vertical
+  if (ZEND_NUM_ARGS() == 5) {
+    PHP_QT_FETCH_5_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;poss0,const QPoint&amp; globalPoss1,int deltas2,Qt::MouseButtons buttonss3,Qt::KeyboardModifiers modifierss4,
+        QPoint *cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QPoint *cpp_arg_1 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_1));
+        QWheelEvent_php_qt *selfpointer =
+          new QWheelEvent_php_qt(getThis(), (const QPoint &amp;)*cpp_arg_0, (const QPoint &amp;)*cpp_arg_1, (int)Z_LVAL_P(arg_2), (Qt::MouseButtons) Z_LVAL_P(arg_3),
+                                 (Qt::KeyboardModifiers) Z_LVAL_P(arg_4));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  if (ZEND_NUM_ARGS() == 6) {
+    PHP_QT_FETCH_6_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG &amp;&amp;
+        Z_TYPE_P(arg_4) == IS_LONG &amp;&amp; Z_TYPE_P(arg_5) == IS_LONG) {
+#ifdef PHP_QT_QPoint
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;poss0,const QPoint&amp; globalPoss1,int deltas2,Qt::MouseButtons buttonss3,Qt::KeyboardModifiers modifierss4, Qt::Orientation orient = Qt::Vertical,
+        QPoint *cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        QPoint *cpp_arg_1 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_1));
+        QWheelEvent_php_qt *selfpointer =
+          new QWheelEvent_php_qt(getThis(), (const QPoint &amp;)*cpp_arg_0, (const QPoint &amp;)*cpp_arg_1, (int)Z_LVAL_P(arg_2), (Qt::MouseButtons) Z_LVAL_P(arg_3),
+                                 (Qt::KeyboardModifiers) Z_LVAL_P(arg_4), (Qt::Orientation) Z_LVAL_P(arg_5));
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
+
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWheelEvent::QWheelEvent(...) &quot;);
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  globalPos
- *    flags:    c
+/*!
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &amp;
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, globalPos){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-				const QPoint &amp; return_object = (const QPoint &amp;) obj-&gt;globalPos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWheelEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWheelEvent, pos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWheelEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;pos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWheelEvent::pos(...) &quot;);
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  y
- *    flags:    c
+/*!
+ * method globalX
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, y){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;y());
-	}
+
+ZEND_METHOD(QWheelEvent, globalX)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalX' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWheelEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;globalX());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWheelEvent::globalX(...) &quot;);
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  delta
- *    flags:    c
+/*!
+ * method globalPos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPoint &amp;
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, delta){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;delta());
-	}
+
+ZEND_METHOD(QWheelEvent, globalPos)
+{
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalPos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWheelEvent * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry le;
+
+      le.ptr = &amp;const_cast &lt; QPoint &amp; &gt;(selfpointer-&gt;globalPos());
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWheelEvent::globalPos(...) &quot;);
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  globalY
- *    flags:    c
+/*!
+ * method buttons
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::MouseButtons
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, globalY){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-			RETURN_LONG(obj-&gt;globalY());
-	}
+
+ZEND_METHOD(QWheelEvent, buttons)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'buttons' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWheelEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;buttons());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWheelEvent::buttons(...) &quot;);
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  pos
- *    flags:    c
+/*!
+ * method orientation
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientation
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, pos){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-				const QPoint &amp; return_object = (const QPoint &amp;) obj-&gt;pos();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWheelEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWheelEvent, orientation)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'orientation' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWheelEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;orientation());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWheelEvent::orientation(...) &quot;);
 }
 
-/*********************************
- *    class     QWheelEvent */
-/*
- *    function  buttons
- *    flags:    c
+/*!
+ * method x
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QWheelEvent, buttons){
-	if (ZEND_NUM_ARGS() == 0){
-			QWheelEvent *obj = (QWheelEvent*) PHP_QT_FETCH();
-				Qt::MouseButtons return_object = (Qt::MouseButtons) obj-&gt;buttons();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWheelEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWheelEvent, x)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'x' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWheelEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;x());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWheelEvent::x(...) &quot;);
 }
 
+/*!
+ * method globalY
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QWheelEvent);
+ZEND_METHOD(QWheelEvent, globalY)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'globalY' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWheelEvent *selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWheelEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;globalY());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWheelEvent::globalY(...) &quot;);
+}

Modified: trunk/qt/classes/qwidget.cpp
===================================================================
--- trunk/qt/classes/qwidget.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qwidget.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QWidget.cpp - QWidget PHP implementation.
- * begin           : Tue Apr 11 10:33:13 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
@@ -29,5858 +28,9192 @@
 
 #include &quot;../php_qt.h&quot;
 
+
 #include &lt;QWidget&gt;
 #include &lt;QIcon&gt;
+/// DEBUG:destructor skipped.
 #include &lt;QMetaMethod&gt;
-
-class QWidget_moc : public QWidget
+class QWidget_php_qt:public QWidget
 {
-    public:
-        QWidget_moc(zval* zend_ptr);
 
-        zval* zend_ptr;
-        QMetaObject* dynamicMetaObject;
+public:
+  QWidget_php_qt(zval * zend_ptr, QWidget * parent = 0, Qt::WFlags f = 0);
 
-        const QMetaObject* metaObject() const;
-        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
-        
+
+  zval *zend_ptr;
+  const QMetaObject *metaObject() const;
+  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
 };
 
-const QMetaObject *QWidget_moc::metaObject() const
+QWidget_php_qt::QWidget_php_qt(zval * zend_ptr, QWidget * parent, Qt::WFlags f):QWidget(parent, f)
 {
-    return php_qt_getMocData(this-&gt;zend_ptr,&quot;QWidget&quot;,&amp;staticMetaObject);;
+  this-&gt;zend_ptr = zend_ptr;
+// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this-&gt;zend_ptr,&quot;QWidget&quot;,&amp;staticMetaObject));
 }
 
-QWidget_moc::QWidget_moc(zval* zend_ptr)
-{
-    this-&gt;zend_ptr = zend_ptr;
-    dynamicMetaObject = new QMetaObject;
-    dynamicMetaObject = php_qt_getMocData(this-&gt;zend_ptr,&quot;QWidget&quot;,&amp;staticMetaObject);
-//    cout &lt;&lt; dynamicMetaObject-&gt;indexOfSignal(&quot;valueChanged(int)&quot;)&lt;&lt;&quot;\n&quot;;
-}
+PHP_QT_MOC(QWidget);
 
-int QWidget_moc::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+/*!
+ * method nextInFocusChain
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
+ */
+
+ZEND_METHOD(QWidget, nextInFocusChain)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
 
-    QMetaObject* d = (QMetaObject*) this-&gt;metaObject();
-    char* method_name = new char[strlen((d-&gt;method(_id)).signature())];
-    strcpy(method_name,(char*) (d-&gt;method(_id)).signature());
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'nextInFocusChain' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    // breaks the string at the first bracket
-    int i;
-    for(i = 0; i &lt; strlen(method_name); i++){
-        if(method_name[i] == 40){
-            method_name[i] = 0;
-            break;
-        }
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;nextInFocusChain());
+      php_qt_register(return_value, le);
+      return;
     }
+  }
+#endif // return type
 
-    // is a Slot
-    if(d-&gt;method(_id).methodType() == QMetaMethod::Slot){
-        int j = 0;
-        zval** args[1];
-        QList&lt;QByteArray&gt; qargs = d-&gt;method(_id).parameterTypes();
-        for(i = 0; i &lt; qargs.count(); i++){
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::nextInFocusChain(...) &quot;);
+}
 
-            zval *arg;
-            MAKE_STD_ZVAL(arg);
+/*!
+ * method tr
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
+ */
 
-            // invoke to zend types
-            if(!strncmp(&quot;int&quot;,(const char*) qargs[i],3)){
-                ZVAL_LONG(arg, *reinterpret_cast&lt; int*&gt;(_a[i+1]));
-            } else if(!strncmp(&quot;char*&quot;,(const char*) qargs[i],5)){
-                ZVAL_STRING(arg, *reinterpret_cast&lt; char**&gt;(_a[i+1]), 1);
-            } else if(!strncmp(&quot;bool&quot;,(const char*) qargs[i],4)){
-                ZVAL_BOOL(arg, *reinterpret_cast&lt; bool*&gt;(_a[i+1]));
-            } else if(!strncmp(&quot;double&quot;,(const char*) qargs[i],4)){
-                ZVAL_DOUBLE(arg, *reinterpret_cast&lt; double*&gt;(_a[i+1]));
-            } else {
-                    // must be an object
-                    zend_class_entry *ce;
-                    object_init_ex(arg, QWidget_ce_ptr);
-                    zend_rsrc_list_entry le;
-                    le.ptr = *reinterpret_cast&lt; QObject**&gt;(_a[1]);
-                    php_qt_register(arg, le);
-                    
-            }
+ZEND_METHOD(QWidget, tr)
+{
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-            args[j++] = &arg;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QWidget *
+        selfpointer;
 
-        }
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        php_qt_callmethod(this-&gt;zend_ptr, method_name, j, args);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-    // is a signal
-    } else {
-        void *_b[] = { 0, _a[1] };
-        QMetaObject::activate(this, d, 0, _b);
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QWidget::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QWidget *
+        selfpointer;
 
-    delete d;
-    delete method_name;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-    return _id;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QWidget::tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;tr((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::tr(...) &quot;);
 }
 
-
 /*!
- *    @class     QWidget
- *    @function  nextInFocusChain
- *
- *    @flags     c
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method focusPolicy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::FocusPolicy
+ * @flags	c
  */
-ZEND_METHOD(QWidget, nextInFocusChain)
+
+ZEND_METHOD(QWidget, focusPolicy)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'focusPolicy' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-/// return: pointer
-
-/// return value is object: QWidget *
-      *return_object = static_cast &lt; QWidget * &gt;(obj-&gt;nextInFocusChain());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;focusPolicy());
     }
-    zend_class_entry *ce;
-
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::focusPolicy(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  tr
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method mouseMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QWidget, tr)
+
+/*!
+ * method insertActions
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QAction *befores0
+ * @param	 QList&lt;QAction*&gt; actionss1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QWidget, insertActions)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
+  ///QAction *befores0, QList&lt;QAction*&gt; actionss1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+#ifdef PHP_QT_QList
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'insertActions' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QAction *befores0, QList&lt;QAction*&gt; actionss1,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        QString *return_object;
-
         if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast &lt; QString &gt; (obj-&gt;tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QWidget::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));       /// memory allocation
-          *return_object = static_cast &lt; QString &gt; (QWidget::tr((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QAction *
+          cpp_arg_0 = static_cast &lt; QAction * &gt;(php_qt_fetch(arg_0));
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+        QList &lt; QAction &gt; *cpp_arg_1 = static_cast &lt; QList &lt; QAction &gt; *&gt;(php_qt_fetch(arg_1));
+        RETURN_VOID(selfpointer-&gt;insertActions((QAction *) cpp_arg_0, (QList &lt; QAction &gt; *)cpp_arg_1));
+      }
+#endif
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
+#endif
 
-/*!
- *    @class     QWidget
- *    @function  focusPolicy
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::FocusPolicy
- *    @param    
- */
-ZEND_METHOD(QWidget, focusPolicy)
-{
-  if (ZEND_NUM_ARGS() == 0) {
-    Qt::FocusPolicy * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;focusPolicy());
-    }                           /// 5 END getThis(), simple types
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::insertActions(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowOpacity
- *
- *    @flags    c
- *    @access    public
- *    @return    qreal
- *    @param    
+ * method windowOpacity
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	qreal
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowOpacity)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    qreal *return_object;
-
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_DOUBLE(obj-&gt;windowOpacity());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type qreal&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::windowOpacity(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  y
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method y
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, y)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'y' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;y());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;y());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::y(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  clearFocus
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method clearFocus
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, clearFocus)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'clearFocus' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;clearFocus();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;clearFocus());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::clearFocus(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  fontInfo
- *
- *    @flags    c
- *    @access    public
- *    @return    QFontInfo
- *    @param    
+ * method fontInfo
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QFontInfo
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, fontInfo)
 {
+  ///
+#ifdef PHP_QT_QFontInfo         // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QFontInfo *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'fontInfo' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QFontInfo
-      *return_object = static_cast &lt; QFontInfo &gt; (obj-&gt;fontInfo());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QFontInfo *
+        return_object = new QFontInfo;
+
+      *return_object = static_cast &lt; QFontInfo &gt; (selfpointer-&gt;fontInfo());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::fontInfo(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isHidden
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isHidden
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isHidden)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isHidden' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isHidden());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isHidden());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isHidden(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMaximumWidth
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int maxw
+ * method qt_cast
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char * s0
+ * 
+ * @access	public
+ * @return	void*
+ * @flags	v
  */
+
+/*!
+ * method styleChange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QStyle &amp;s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method setMaximumWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int maxws0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setMaximumWidth)
 {
-/*! l public*/
-/*! int maxw,  */
+  ///int maxws0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMaximumWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int maxws0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setMaximumWidth((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMaximumWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setMaximumWidth(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  contentsRect
- *
- *    @flags    c
- *    @access    public
- *    @return    QRect
- *    @param    
+ * method metaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject *
+ * @flags	cv
  */
+
+/*!
+ * method contentsRect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, contentsRect)
 {
+  ///
+#ifdef PHP_QT_QRect             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRect *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'contentsRect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRect
-      *return_object = static_cast &lt; QRect &gt; (obj-&gt;contentsRect());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;contentsRect());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::contentsRect(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setContextMenuPolicy
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::ContextMenuPolicy policy
+ * method setContextMenuPolicy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::ContextMenuPolicy policys0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setContextMenuPolicy)
 {
-/*! l public*/
-/*! int policy,  */
+  ///Qt::ContextMenuPolicy policys0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setContextMenuPolicy' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::ContextMenuPolicy policys0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setContextMenuPolicy((Qt::ContextMenuPolicy) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setContextMenuPolicy((Qt::ContextMenuPolicy) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setContextMenuPolicy(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  focusProxy
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method focusProxy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, focusProxy)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'focusProxy' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast &lt; QWidget * &gt;(obj-&gt;focusProxy());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;focusProxy());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::focusProxy(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  statusTip
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method statusTip
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, statusTip)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'statusTip' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast &lt; QString &gt; (obj-&gt;statusTip());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;statusTip());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::statusTip(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  visibleRegion
- *
- *    @flags    c
- *    @access    public
- *    @return    QRegion
- *    @param    
+ * method visibleRegion
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRegion
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, visibleRegion)
 {
+  ///
+#ifdef PHP_QT_QRegion           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRegion *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'visibleRegion' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRegion
-      *return_object = static_cast &lt; QRegion &gt; (obj-&gt;visibleRegion());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRegion *
+        return_object = new QRegion;
+
+      *return_object = static_cast &lt; QRegion &gt; (selfpointer-&gt;visibleRegion());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::visibleRegion(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isVisibleTo
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    QWidget*
+ * method isVisibleTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isVisibleTo)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* ,  */
+  ///QWidget *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'isVisibleTo' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          bool *return_object;
+        RETURN_BOOL(selfpointer-&gt;isVisibleTo((QWidget *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            RETURN_BOOL(obj-&gt;isVisibleTo((QWidget *) obj_z_0));
-          }                     /// 5 END getThis(), simple types
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isVisibleTo(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  releaseMouse
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method releaseMouse
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, releaseMouse)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'releaseMouse' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;releaseMouse();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;releaseMouse());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::releaseMouse(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setTabOrder
- *
- *    @flags    s
- *    @access    public
- *    @return    void
- *    @param    QWidget *, QWidget *
+ * method setTabOrder
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * @param	 QWidget *s1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	s
  */
+
 ZEND_METHOD(QWidget, setTabOrder)
 {
-///QWidget*
-///QWidget*
-/*! oo public*/
-/*! QWidget* , QWidget* ,  */
+  ///QWidget *s0, QWidget *s1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 71)) {
+        /// try QWidget *s0, QWidget *s1,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
-        QObject *obj_z_1 = (QObject *) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;) &amp;&amp; obj_z_1-&gt;inherits(&quot;QWidget&quot;)) {
-          void *return_object;
+        if (getThis() == NULL) {
+          RETURN_VOID(QWidget::setTabOrder((QWidget *) cpp_arg_0, (QWidget *) cpp_arg_1));
+        } else {
+          RETURN_VOID(selfpointer-&gt;setTabOrder((QWidget *) cpp_arg_0, (QWidget *) cpp_arg_1));
+        }
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setTabOrder((QWidget *) obj_z_0, (QWidget *) obj_z_1);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setTabOrder(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setFocusProxy
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QWidget *
+ * method setFocusProxy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setFocusProxy)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* ,  */
+  ///QWidget *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setFocusProxy' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setFocusProxy((QWidget *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setFocusProxy((QWidget *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setFocusProxy(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  topLevelWidget
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method qt_emit
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
+
+/*!
+ * method topLevelWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, topLevelWidget)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'topLevelWidget' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast &lt; QWidget * &gt;(obj-&gt;topLevelWidget());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;topLevelWidget());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::topLevelWidget(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  mapToParent
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    const QPoint &amp;
+ * method mapToParent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;s0
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, mapToParent)
 {
-/*! l public*/
-/*! const QPoint&amp; ,  */
+  ///const QPoint &amp;s0
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'mapToParent' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        QPoint *return_object;
-
         if (getThis() != NULL) {
-/// return value is object: QPoint
-          *return_object = static_cast &lt; QPoint &gt; (obj-&gt;mapToParent((const QPoint &amp;)Z_LVAL_P(z_0)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, &quot;Object not found&quot;);
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
         }
-        zend_class_entry *ce;
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *
+          ce;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QPoint *
+          return_object = new QPoint;
 
-        le.ptr = return_object;
+        *return_object = static_cast &lt; QPoint &gt; (selfpointer-&gt;mapToParent((const QPoint &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
         php_qt_register(return_value, le);
         return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::mapToParent(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  overrideWindowFlags
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::WindowFlags type
+ * method className
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const char *
+ * @flags	cv
  */
+
+/*!
+ * method overrideWindowFlags
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WindowFlags types0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, overrideWindowFlags)
 {
-/*! l public*/
-/*! int type,  */
+  ///Qt::WindowFlags types0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'overrideWindowFlags' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::WindowFlags types0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;overrideWindowFlags((Qt::WindowFlags) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;overrideWindowFlags((Qt::WindowFlags) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::overrideWindowFlags(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  hide
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method hide
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, hide)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hide' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;hide();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;hide());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::hide(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  mapTo
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    QWidget *, const QPoint &amp;
+ * method mapTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * @param	 const QPoint  &amp;s1
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, mapTo)
 {
-///QWidget*
-/*! ol public*/
-/*! QWidget* , const QPoint&amp; ,  */
+  ///QWidget *s0, const QPoint  &amp;s1
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 71) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'mapTo' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *s0, const QPoint  &amp;s1,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+        QPoint *
+          cpp_arg_1 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *
+          ce;
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          QPoint *return_object;
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QPoint *
+          return_object = new QPoint;
 
-          if (getThis() != NULL) {
-/// return value is object: QPoint
-            *return_object = static_cast &lt; QPoint &gt; (obj-&gt;mapTo((QWidget *) obj_z_0, (const QPoint &amp;)Z_LVAL_P(z_1)));
-          } else {              /// END getThis(), static
-            php_error(E_ERROR, &quot;Object not found&quot;);
-          }
-          zend_class_entry *ce;
+        *return_object = static_cast &lt; QPoint &gt; (selfpointer-&gt;mapTo((QWidget *) cpp_arg_0, (const QPoint &amp;)*cpp_arg_1));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-          object_init_ex(return_value, QWidget_ce_ptr);
-          zend_rsrc_list_entry le;
+#endif
 
-          le.ptr = return_object;
-          php_qt_register(return_value, le);
-          return;
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::mapTo(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  childrenRect
- *
- *    @flags    c
- *    @access    public
- *    @return    QRect
- *    @param    
+ * method childrenRect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, childrenRect)
 {
+  ///
+#ifdef PHP_QT_QRect             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRect *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'childrenRect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRect
-      *return_object = static_cast &lt; QRect &gt; (obj-&gt;childrenRect());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;childrenRect());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::childrenRect(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setStyle
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QStyle *
+ * method setStyle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QStyle *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setStyle)
 {
-///qt_QStyle*
-/*! o public*/
-/*! qt_QStyle* ,  */
+  ///QStyle *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QStyle
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setStyle' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QStyle *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QStyle *
+          cpp_arg_0 = static_cast &lt; QStyle * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QStyle&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setStyle((QStyle *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setStyle((QStyle *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setStyle(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isRightToLeft
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isRightToLeft
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isRightToLeft)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isRightToLeft' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isRightToLeft());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isRightToLeft());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isRightToLeft(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowModified
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    bool
+ * method setWindowModified
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, setWindowModified)
 {
-/*! l public_slots*/
-/*! int ,  */
+  ///bool bools0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setWindowModified' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setWindowModified((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setWindowModified((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setWindowModified(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setBackgroundRole
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QPalette::ColorRole
+ * method setBackgroundRole
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPalette::ColorRole QPalette::ColorRoles0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setBackgroundRole)
 {
-/*! l public*/
-/*! int ,  */
+  ///QPalette::ColorRole QPalette::ColorRoles0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setBackgroundRole' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QPalette::ColorRole QPalette::ColorRoles0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setBackgroundRole((QPalette::ColorRole) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setBackgroundRole((QPalette::ColorRole) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setBackgroundRole(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setFixedSize
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QSize &amp;
+ * method setFixedSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &amp;s0
+ * 
+ * overloaded args:
+ * @param	int w
+ * @param	 int h
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setFixedSize)
 {
-///const QSize&amp;
-/*! o public*/
-/*! const QSize&amp; ,  */
+  ///const QSize &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setFixedSize' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QSize &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QSize *
+          cpp_arg_0 = static_cast &lt; QSize * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QSize&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setFixedSize((const QSize &amp;)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setFixedSize((const QSize &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  ///int w, int h
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setFixedSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int w, int h,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setFixedSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setFixedSize(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  focusPreviousChild
- *
- *    @flags    
- *    @access    protected
- *    @return    bool
- *    @param    
+ * method focusPreviousChild
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-// method focusPreviousChild is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  inputContext
- *
- *    @flags    
- *    @access    public
- *    @return    QInputContext *
- *    @param    
+ * method dragLeaveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDragLeaveEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method inputContext
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QInputContext *
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, inputContext)
 {
+  ///
+#ifdef PHP_QT_QInputContext     // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QInputContext **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'inputContext' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QInputContext *
-      *return_object = static_cast &lt; QInputContext * &gt;(obj-&gt;inputContext());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      le.ptr = static_cast &lt; QInputContext * &gt;(selfpointer-&gt;inputContext());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::inputContext(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  palette
- *
- *    @flags    c
- *    @access    public
- *    @return    const QPalette &amp;
- *    @param    
+ * method palette
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QPalette &amp;
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, palette)
 {
+  ///
+#ifdef PHP_QT_QPalette          // return type
+
   if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'palette' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &amp;const_cast &lt; QPalette &amp; &gt;(selfpointer-&gt;palette());
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::palette(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setFixedHeight
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int h
+ * method setFixedHeight
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int hs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setFixedHeight)
 {
-/*! l public*/
-/*! int h,  */
+  ///int hs0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setFixedHeight' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int hs0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setFixedHeight((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setFixedHeight((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setFixedHeight(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  repaint
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int x, int y, int w, int h
+ * method repaint
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int xs0
+ * @param	 int ys1
+ * @param	 int ws2
+ * @param	 int hs3
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;
+ * 
+ * overloaded args:
+ * @param	const QRegion &amp;
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, repaint)
 {
-/*! llll public*/
-/*! int x, int y, int w, int h,  */
+  ///int xs0, int ys1, int ws2, int hs3
   if (ZEND_NUM_ARGS() == 4) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'repaint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int xs0, int ys1, int ws2, int hs3,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;repaint((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  ///const QRect &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'repaint' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;,
+        QWidget *
+          selfpointer;
 
-        void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;repaint((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///const QRegion &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegion
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'repaint' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegion &amp;,
+        QWidget *
+          selfpointer;
+
         if (getThis() != NULL) {
-          obj-&gt;repaint((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1), (int)Z_LVAL_P(z_2), (int)Z_LVAL_P(z_3));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QRegion *
+          cpp_arg_0 = static_cast &lt; QRegion * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;repaint((const QRegion &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'repaint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;repaint());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::repaint(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  cursor
- *
- *    @flags    c
- *    @access    public
- *    @return    QCursor
- *    @param    
+ * method cursor
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QCursor
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, cursor)
 {
+  ///
+#ifdef PHP_QT_QCursor           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QCursor *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'cursor' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QCursor
-      *return_object = static_cast &lt; QCursor &gt; (obj-&gt;cursor());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QCursor *
+        return_object = new QCursor;
+
+      *return_object = static_cast &lt; QCursor &gt; (selfpointer-&gt;cursor());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::cursor(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowIconText
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &amp;
+ * method setWindowIconText
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWindowIconText)
 {
-///const QString&amp;
-/*! o public*/
-/*! const QString&amp; ,  */
+  ///const QString &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setWindowIconText' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)-&gt;name, &quot;QString&quot;)) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj-&gt;setWindowIconText((const QString &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;setWindowIconText((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setWindowIconText(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  fontMetrics
- *
- *    @flags    c
- *    @access    public
- *    @return    QFontMetrics
- *    @param    
+ * method fontMetrics
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QFontMetrics
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, fontMetrics)
 {
+  ///
+#ifdef PHP_QT_QFontMetrics      // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QFontMetrics *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'fontMetrics' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QFontMetrics
-      *return_object = static_cast &lt; QFontMetrics &gt; (obj-&gt;fontMetrics());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QFontMetrics *
+        return_object = new QFontMetrics;
+
+      *return_object = static_cast &lt; QFontMetrics &gt; (selfpointer-&gt;fontMetrics());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::fontMetrics(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  grabShortcut
- *
- *    @flags    
- *    @access    public
- *    @return    int
- *    @param    const QKeySequence &amp;key, Qt::ShortcutContext context = Qt::WindowShortcut
+ * method grabShortcut
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QKeySequence &amp;keys0
+ * @param	 Qt::ShortcutContext context = Qt::WindowShortcuts1
+ * 
+ * @access	public
+ * @return	int
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, grabShortcut)
 {
-///const QKeySequence&amp;
-/*! ol public*/
-/*! const QKeySequence&amp; key, int context,  */
+  ///const QKeySequence &amp;keys0, Qt::ShortcutContext context = Qt::WindowShortcuts1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QKeySequence
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'grabShortcut' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QKeySequence &amp;keys0,
+        QWidget *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QKeySequence *
+          cpp_arg_0 = static_cast &lt; QKeySequence * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_LONG(selfpointer-&gt;grabShortcut((const QKeySequence &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QKeySequence
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'grabShortcut' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QKeySequence &amp;keys0, Qt::ShortcutContext context = Qt::WindowShortcuts1,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QKeySequence *
+          cpp_arg_0 = static_cast &lt; QKeySequence * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QKeySequence&quot;)) {
-          int *return_object;
+        RETURN_LONG(selfpointer-&gt;grabShortcut((const QKeySequence &amp;)*cpp_arg_0, (Qt::ShortcutContext) Z_LVAL_P(arg_1)));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            RETURN_LONG(obj-&gt;grabShortcut((const QKeySequence &amp;)*obj_z_0, (Qt::ShortcutContext) Z_LVAL_P(z_1)));
-          }                     /// 5 END getThis(), simple types
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::grabShortcut(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  releaseKeyboard
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method releaseKeyboard
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, releaseKeyboard)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'releaseKeyboard' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;releaseKeyboard();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;releaseKeyboard());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::releaseKeyboard(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setAccessibleDescription
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &amp;description
+ * method setAccessibleDescription
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;descriptions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setAccessibleDescription)
 {
-///const QString&amp;
-/*! o public*/
-/*! const QString&amp; description,  */
+  ///const QString &amp;descriptions0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setAccessibleDescription' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;descriptions0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)-&gt;name, &quot;QString&quot;)) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj-&gt;setAccessibleDescription((const QString &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;setAccessibleDescription((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setAccessibleDescription(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  qObject
- *
- *    @flags    
- *    @access    public
- *    @return    QObject*
- *    @param    
+ * method qObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QObject*
+ * @flags	
  */
-ZEND_METHOD(QWidget, qObject)
-{
-}
 
 /*!
- *    @class     QWidget
- *    @function  maximumWidth
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method maximumWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, maximumWidth)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'maximumWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;maximumWidth());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;maximumWidth());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::maximumWidth(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowOpacity
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    qreal level
+ * method setWindowOpacity
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	qreal levels0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWindowOpacity)
 {
-/*! l public*/
-/*! double level,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
-
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setWindowOpacity((qreal) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+// notice: unknown argument qreal levels0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setWindowOpacity(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isTopLevel
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isTopLevel
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isTopLevel)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isTopLevel' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isTopLevel());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isTopLevel());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isTopLevel(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  mask
- *
- *    @flags    c
- *    @access    public
- *    @return    QRegion
- *    @param    
+ * method mask
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRegion
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, mask)
 {
+  ///
+#ifdef PHP_QT_QRegion           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRegion *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'mask' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRegion
-      *return_object = static_cast &lt; QRegion &gt; (obj-&gt;mask());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRegion *
+        return_object = new QRegion;
+
+      *return_object = static_cast &lt; QRegion &gt; (selfpointer-&gt;mask());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::mask(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isActiveWindow
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method fontChange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &amp;s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method isActiveWindow
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, isActiveWindow)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isActiveWindow' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isActiveWindow());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isActiveWindow());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isActiveWindow(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isEnabledTo
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    QWidget*
+ * method isEnabledTo
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isEnabledTo)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* ,  */
+  ///QWidget *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'isEnabledTo' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          bool *return_object;
+        RETURN_BOOL(selfpointer-&gt;isEnabledTo((QWidget *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            RETURN_BOOL(obj-&gt;isEnabledTo((QWidget *) obj_z_0));
-          }                     /// 5 END getThis(), simple types
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isEnabledTo(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  layoutDirection
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::LayoutDirection
- *    @param    
+ * method layoutDirection
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::LayoutDirection
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, layoutDirection)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::LayoutDirection * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'layoutDirection' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      RETURN_LONG(obj-&gt;layoutDirection());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;layoutDirection());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::layoutDirection(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isAncestorOf
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    const QWidget *child
+ * method isAncestorOf
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QWidget *childs0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isAncestorOf)
 {
-///const QWidget*
-/*! o public*/
-/*! const QWidget* child,  */
+  ///const QWidget *childs0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'isAncestorOf' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QWidget *childs0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          bool *return_object;
+        RETURN_BOOL(selfpointer-&gt;isAncestorOf((const QWidget *)cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            RETURN_BOOL(obj-&gt;isAncestorOf((const QWidget *)obj_z_0));
-          }                     /// 5 END getThis(), simple types
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isAncestorOf(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowIcon
- *
- *    @flags    c
- *    @access    public
- *    @return    QIcon
- *    @param    
+ * method windowIcon
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QIcon
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowIcon)
 {
+  ///
+#ifdef PHP_QT_QIcon             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QIcon *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'windowIcon' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-      obj-&gt;windowIcon();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QIcon *
+        return_object = new QIcon;
+
+      *return_object = static_cast &lt; QIcon &gt; (selfpointer-&gt;windowIcon());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::windowIcon(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  updatesEnabled
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method updatesEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, updatesEnabled)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'updatesEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;updatesEnabled());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;updatesEnabled());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::updatesEnabled(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isMinimized
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isMinimized
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isMinimized)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isMinimized' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isMinimized());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isMinimized());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isMinimized(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  height
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method height
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, height)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'height' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;height());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;height());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::height(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  normalGeometry
- *
- *    @flags    c
- *    @access    public
- *    @return    QRect
- *    @param    
+ * method normalGeometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, normalGeometry)
 {
+  ///
+#ifdef PHP_QT_QRect             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRect *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'normalGeometry' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRect
-      *return_object = static_cast &lt; QRect &gt; (obj-&gt;normalGeometry());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;normalGeometry());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::normalGeometry(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMask
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QBitmap &amp;
+ * method setMask
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QBitmap &amp;s0
+ * 
+ * overloaded args:
+ * @param	const QRegion &amp;
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setMask)
 {
-///const QBitmap&amp;
-/*! o public*/
-/*! const QBitmap&amp; ,  */
+  ///const QBitmap &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QBitmap
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setMask' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QBitmap &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QBitmap *
+          cpp_arg_0 = static_cast &lt; QBitmap * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QBitmap&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setMask((const QBitmap &amp;)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setMask((const QBitmap &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
+    }
+  }
+  ///const QRegion &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegion
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setMask' is not static&quot;);
+          RETURN_NULL();
         }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        /// try const QRegion &amp;,
+        QWidget *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QRegion *
+          cpp_arg_0 = static_cast &lt; QRegion * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setMask((const QRegion &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setMask(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setForegroundRole
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QPalette::ColorRole
+ * method setForegroundRole
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPalette::ColorRole QPalette::ColorRoles0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setForegroundRole)
 {
-/*! l public*/
-/*! int ,  */
+  ///QPalette::ColorRole QPalette::ColorRoles0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setForegroundRole' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QPalette::ColorRole QPalette::ColorRoles0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setForegroundRole((QPalette::ColorRole) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setForegroundRole((QPalette::ColorRole) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setForegroundRole(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  update
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int x, int y, int w, int h
+ * method update
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int xs0
+ * @param	 int ys1
+ * @param	 int ws2
+ * @param	 int hs3
+ * 
+ * overloaded args:
+ * @param	const QRect&amp;
+ * 
+ * overloaded args:
+ * @param	const QRegion&amp;
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, update)
 {
-/*! llll public*/
-/*! int x, int y, int w, int h,  */
+  ///int xs0, int ys1, int ws2, int hs3
   if (ZEND_NUM_ARGS() == 4) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'update' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int xs0, int ys1, int ws2, int hs3,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;update((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  ///const QRect&amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'update' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect&amp;,
+        QWidget *
+          selfpointer;
 
-        void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
+        RETURN_VOID(selfpointer-&gt;update((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///const QRegion&amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRegion
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'update' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRegion&amp;,
+        QWidget *
+          selfpointer;
+
         if (getThis() != NULL) {
-          obj-&gt;update((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1), (int)Z_LVAL_P(z_2), (int)Z_LVAL_P(z_3));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QRegion *
+          cpp_arg_0 = static_cast &lt; QRegion * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;update((const QRegion &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'update' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;update());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::update(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  adjustSize
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method adjustSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, adjustSize)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'adjustSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;adjustSize();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;adjustSize());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::adjustSize(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  toolTip
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method toolTip
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, toolTip)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'toolTip' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast &lt; QString &gt; (obj-&gt;toolTip());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;toolTip());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::toolTip(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setCursor
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QCursor &amp;
+ * method wheelEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWheelEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method setCursor
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QCursor &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setCursor)
 {
-///const QCursor&amp;
-/*! o public*/
-/*! const QCursor&amp; ,  */
+  ///const QCursor &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QCursor
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setCursor' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QCursor &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QCursor *
+          cpp_arg_0 = static_cast &lt; QCursor * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QCursor&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setCursor((const QCursor &amp;)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setCursor((const QCursor &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setCursor(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMinimumWidth
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int minw
+ * method setMinimumWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int minws0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setMinimumWidth)
 {
-/*! l public*/
-/*! int minw,  */
+  ///int minws0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMinimumWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int minws0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setMinimumWidth((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMinimumWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setMinimumWidth(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isEnabledToTLW
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isEnabledToTLW
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isEnabledToTLW)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isEnabledToTLW' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isEnabledToTLW());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isEnabledToTLW());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isEnabledToTLW(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowRole
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &amp;
+ * method setWindowRole
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWindowRole)
 {
-///const QString&amp;
-/*! o public*/
-/*! const QString&amp; ,  */
+  ///const QString &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setWindowRole' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)-&gt;name, &quot;QString&quot;)) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj-&gt;setWindowRole((const QString &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;setWindowRole((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setWindowRole(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setPalette
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QPalette &amp;
+ * method setPalette
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPalette &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setPalette)
 {
-///const QPalette&amp;
-/*! o public*/
-/*! const QPalette&amp; ,  */
+  ///const QPalette &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPalette
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setPalette' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPalette &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QPalette *
+          cpp_arg_0 = static_cast &lt; QPalette * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QPalette&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setPalette((const QPalette &amp;)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setPalette((const QPalette &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setPalette(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  acceptDrops
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method closeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QCloseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method resizeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QResizeEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method acceptDrops
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, acceptDrops)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'acceptDrops' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;acceptDrops());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;acceptDrops());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::acceptDrops(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  focusNextChild
- *
- *    @flags    
- *    @access    protected
- *    @return    bool
- *    @param    
+ * method focusNextChild
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-// method focusNextChild is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  setShortcutEnabled
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int id, bool enable = true
+ * method setShortcutEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ids0
+ * @param	 bool enable = trues1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setShortcutEnabled)
 {
-/*! ll public*/
-/*! int id, int enable,  */
+  ///int ids0, bool enable = trues1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setShortcutEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ids0,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setShortcutEnabled((int)Z_LVAL_P(arg_0)));
+    }
+  }
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setShortcutEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ids0, bool enable = trues1,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setShortcutEnabled((int)Z_LVAL_P(z_0), (bool) Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setShortcutEnabled((int)Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setShortcutEnabled(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  geometry
- *
- *    @flags    c
- *    @access    public
- *    @return    const QRect &amp;
- *    @param    
+ * method geometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QRect &amp;
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, geometry)
 {
+  ///
+#ifdef PHP_QT_QRect             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'geometry' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &amp;const_cast &lt; QRect &amp; &gt;(selfpointer-&gt;geometry());
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::geometry(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setShown
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    bool shown
+ * method focusNextPrevChild
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool nexts0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	v
  */
+
+/*!
+ * method windowActivationChange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method setShown
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool showns0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
+
 ZEND_METHOD(QWidget, setShown)
 {
-/*! l public_slots*/
-/*! int shown,  */
+  ///bool showns0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setShown' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool showns0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setShown((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setShown((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setShown(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  accessibleDescription
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method accessibleDescription
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, accessibleDescription)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'accessibleDescription' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast &lt; QString &gt; (obj-&gt;accessibleDescription());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;accessibleDescription());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::accessibleDescription(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMaximumSize
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QSize &amp;
+ * method setMaximumSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &amp;s0
+ * 
+ * overloaded args:
+ * @param	int maxw
+ * @param	 int maxh
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setMaximumSize)
 {
-///const QSize&amp;
-/*! o public*/
-/*! const QSize&amp; ,  */
+  ///const QSize &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setMaximumSize' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QSize &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QSize *
+          cpp_arg_0 = static_cast &lt; QSize * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QSize&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setMaximumSize((const QSize &amp;)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setMaximumSize((const QSize &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  ///int maxw, int maxh
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMaximumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int maxw, int maxh,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMaximumSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setMaximumSize(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setContentsMargins
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int left, int top, int right, int bottom
+ * method setContentsMargins
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int lefts0
+ * @param	 int tops1
+ * @param	 int rights2
+ * @param	 int bottoms3
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setContentsMargins)
 {
-/*! llll public*/
-/*! int left, int top, int right, int bottom,  */
+  ///int lefts0, int tops1, int rights2, int bottoms3
   if (ZEND_NUM_ARGS() == 4) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setContentsMargins' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int lefts0, int tops1, int rights2, int bottoms3,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setContentsMargins((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1), (int)Z_LVAL_P(z_2), (int)Z_LVAL_P(z_3));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setContentsMargins((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setContentsMargins(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  backgroundRole
- *
- *    @flags    c
- *    @access    public
- *    @return    QPalette::ColorRole
- *    @param    
+ * method backgroundRole
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPalette::ColorRole
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, backgroundRole)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    QPalette::ColorRole * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'backgroundRole' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      RETURN_LONG(obj-&gt;backgroundRole());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;backgroundRole());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::backgroundRole(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  mapFromParent
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    const QPoint &amp;
+ * method mapFromParent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;s0
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, mapFromParent)
 {
-/*! l public*/
-/*! const QPoint&amp; ,  */
+  ///const QPoint &amp;s0
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'mapFromParent' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        QPoint *return_object;
-
         if (getThis() != NULL) {
-/// return value is object: QPoint
-          *return_object = static_cast &lt; QPoint &gt; (obj-&gt;mapFromParent((const QPoint &amp;)Z_LVAL_P(z_0)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, &quot;Object not found&quot;);
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
         }
-        zend_class_entry *ce;
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *
+          ce;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QPoint *
+          return_object = new QPoint;
 
-        le.ptr = return_object;
+        *return_object = static_cast &lt; QPoint &gt; (selfpointer-&gt;mapFromParent((const QPoint &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
         php_qt_register(return_value, le);
         return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::mapFromParent(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  updateGeometry
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method updateGeometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, updateGeometry)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'updateGeometry' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;updateGeometry();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;updateGeometry());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::updateGeometry(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setAttribute
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::WidgetAttribute, bool on = true
+ * method setAttribute
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WidgetAttribute Qt::WidgetAttributes0
+ * @param	 bool on = trues1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setAttribute)
 {
-/*! ll public*/
-/*! int , int on,  */
+  ///Qt::WidgetAttribute Qt::WidgetAttributes0, bool on = trues1
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setAttribute' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::WidgetAttribute Qt::WidgetAttributes0,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setAttribute((Qt::WidgetAttribute) Z_LVAL_P(arg_0)));
+    }
+  }
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setAttribute' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::WidgetAttribute Qt::WidgetAttributes0, bool on = trues1,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setAttribute((Qt::WidgetAttribute) Z_LVAL_P(z_0), (bool) Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setAttribute((Qt::WidgetAttribute) Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setAttribute(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowType
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::WindowType
- *    @param    
+ * method windowType
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::WindowType
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowType)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::WindowType * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'windowType' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      obj-&gt;windowType();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;windowType());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::windowType(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  focusWidget
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method paintEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QPaintEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method mouseDoubleClickEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method focusWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, focusWidget)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'focusWidget' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast &lt; QWidget * &gt;(obj-&gt;focusWidget());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;focusWidget());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::focusWidget(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  ensurePolished
- *
- *    @flags    c
- *    @access    public
- *    @return    void
- *    @param    
+ * method changeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method ensurePolished
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, ensurePolished)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'ensurePolished' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;ensurePolished();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;ensurePolished());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::ensurePolished(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  foregroundRole
- *
- *    @flags    c
- *    @access    public
- *    @return    QPalette::ColorRole
- *    @param    
+ * method foregroundRole
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPalette::ColorRole
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, foregroundRole)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    QPalette::ColorRole * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'foregroundRole' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      RETURN_LONG(obj-&gt;foregroundRole());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;foregroundRole());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::foregroundRole(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setEnabled
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    bool
+ * method setEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, setEnabled)
 {
-/*! l public_slots*/
-/*! int ,  */
+  ///bool bools0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setEnabled((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setEnabled(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowIconText
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method windowIconText
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowIconText)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'windowIconText' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast &lt; QString &gt; (obj-&gt;windowIconText());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;windowIconText());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::windowIconText(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  updateMicroFocus
- *
- *    @flags    
- *    @access    protected
- *    @return    void
- *    @param    
+ * method updateMicroFocus
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method updateMicroFocus is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  metric
- *
- *    @flags    c
- *    @access    protected
- *    @return    int
- *    @param    PaintDeviceMetric
+ * method metric
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	PaintDeviceMetric PaintDeviceMetrics0
+ * 
+ * @access	protected
+ * @return	int
+ * @flags	c
  */
-// method metric is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  winId
- *
- *    @flags    c
- *    @access    public
- *    @return    WId
- *    @param    
+ * method paletteChange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPalette &amp;s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method winId
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	WId
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, winId)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    WId *return_object;
-
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;winId());
-    }                           /// 5 END getThis(), simple types
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      php_error(E_ERROR, &quot;unsupported return type WId&quot;);
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::winId(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  close
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    bool
- *    @param    
+ * method close
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	bool
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, close)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'close' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;close());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;close());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::close(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  childAt
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget *
- *    @param    int x, int y
+ * method childAt
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int xs0
+ * @param	 int ys1
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;p
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, childAt)
 {
-/*! ll public*/
-/*! int x, int y,  */
+  ///int xs0, int ys1
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'childAt' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int xs0, int ys1,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        QWidget **return_object;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-        if (getThis() != NULL) {
-/// return: pointer
+      le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;childAt((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
 
-/// return value is object: QWidget *
-          *return_object = static_cast &lt; QWidget * &gt;(obj-&gt;childAt((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, &quot;Object not found&quot;);
+
+  ///const QPoint &amp;p
+#ifdef PHP_QT_QWidget           // return type
+
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'childAt' is not static&quot;);
+          RETURN_NULL();
         }
-        zend_class_entry *ce;
+        /// try const QPoint &amp;p,
+        QWidget *
+          selfpointer;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *
+          ce;
 
-        le.ptr = return_object[0];
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+
+        le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;childAt((const QPoint &amp;)*cpp_arg_0));
         php_qt_register(return_value, le);
         return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::childAt(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setFixedWidth
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int w
+ * method setFixedWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ws0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setFixedWidth)
 {
-/*! l public*/
-/*! int w,  */
+  ///int ws0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setFixedWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ws0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setFixedWidth((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setFixedWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setFixedWidth(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowRole
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method windowRole
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowRole)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'windowRole' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast &lt; QString &gt; (obj-&gt;windowRole());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;windowRole());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::windowRole(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setFont
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QFont &amp;
+ * method setFont
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QFont &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setFont)
 {
-///const QFont&amp;
-/*! o public*/
-/*! const QFont&amp; ,  */
+  ///const QFont &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QFont
+      if (inherits(Z_OBJCE_P(arg_0), 24)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setFont' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QFont &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QFont *
+          cpp_arg_0 = static_cast &lt; QFont * &gt;(php_qt_fetch(arg_0));
 
-        if (!strcmp(Z_OBJCE_P(z_0)-&gt;name, &quot;QFont&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setFont((const QFont &amp;)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setFont((const QFont &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setFont(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  hasMouseTracking
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method hasMouseTracking
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, hasMouseTracking)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hasMouseTracking' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;hasMouseTracking());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;hasMouseTracking());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::hasMouseTracking(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  childrenRegion
- *
- *    @flags    c
- *    @access    public
- *    @return    QRegion
- *    @param    
+ * method childrenRegion
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRegion
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, childrenRegion)
 {
+  ///
+#ifdef PHP_QT_QRegion           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRegion *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'childrenRegion' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRegion
-      *return_object = static_cast &lt; QRegion &gt; (obj-&gt;childrenRegion());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRegion *
+        return_object = new QRegion;
+
+      *return_object = static_cast &lt; QRegion &gt; (selfpointer-&gt;childrenRegion());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::childrenRegion(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  QWidget
- *
- *    @flags    t
- *    @access    public
- *    @return    
- *    @param    QWidget* parent = 0, Qt::WFlags f = 0
+ * method QWidget
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget * parent = 0s0
+ * @param	 Qt::WFlags f = 0s1
+ * 
+ * overloaded args:
+ * @param	QWidgetPrivate &amp;d
+ * @param	 QWidget* parent
+ * @param	 Qt::WFlags f
+ * 
+ * overloaded args:
+ * @param	const QWidget &amp;
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
+
 ZEND_METHOD(QWidget, __construct)
 {
-///QWidget*
+  ///QWidget * parent = 0s0, Qt::WFlags f = 0s1
   if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget_php_qt *
+        selfpointer = new QWidget_php_qt(getThis());
 
-          QWidget_moc *QWidget_ptr = new QWidget_moc(this_ptr);
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget * parent = 0s0,
+      QWidget *
+        cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QWidget_php_qt *
+        selfpointer = new QWidget_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-          PHP_QT_REGISTER(QWidget_ptr);
-          RETURN_NULL();
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QWidget * parent = 0s0, Qt::WFlags f = 0s1,
+      QWidget *
+        cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+      QWidget_php_qt *
+        selfpointer = new QWidget_php_qt(getThis(), (QWidget *) cpp_arg_0, (Qt::WFlags) Z_LVAL_P(arg_1));
 
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
     }
+  }
+  ///QWidgetPrivate &amp;d, QWidget* parent, Qt::WFlags f
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG) {
+#ifdef PHP_QT_QWidgetPrivate
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 71)) {
+/// overloaded method is protected, skipped.
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidgetPrivate &amp;d, QWidget* parent, Qt::WFlags f,
+        QWidgetPrivate *
+          cpp_arg_0 = static_cast &lt; QWidgetPrivate * &gt;(php_qt_fetch(arg_0));
+        QWidget *
+          cpp_arg_1 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_1));
+        QWidget_php_qt *
+          selfpointer = new QWidget_php_qt(getThis(), (QWidgetPrivate &amp;) * cpp_arg_0, (QWidget *) cpp_arg_1, (Qt::WFlags) Z_LVAL_P(arg_2));
 
-/*! ol public*/
-/*! QWidget* parent, int f,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+#endif
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          QWidget *QWidget_ptr = new QWidget((QWidget *) obj_z_0, (Qt::WFlags) Z_LVAL_P(z_1));
+    }
+  }
+  ///const QWidget &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+/// method is private, skip
+        php_error(E_ERROR, &quot;QWidget::__construct(...) cannot be called with 'const QWidget &amp;,'.&quot;);
+      }
+#endif
 
-          PHP_QT_REGISTER(QWidget_ptr);
-          RETURN_NULL();
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::QWidget(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setInputContext
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QInputContext *
+ * method setInputContext
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QInputContext *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setInputContext)
 {
-///QInputContext*
-/*! o public*/
-/*! QInputContext* ,  */
+  ///QInputContext *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QInputContext
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setInputContext' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QInputContext *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QInputContext *
+          cpp_arg_0 = static_cast &lt; QInputContext * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QInputContext&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setInputContext((QInputContext *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setInputContext((QInputContext *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setInputContext(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  unsetLayoutDirection
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method unsetLayoutDirection
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, unsetLayoutDirection)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'unsetLayoutDirection' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;unsetLayoutDirection();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;unsetLayoutDirection());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::unsetLayoutDirection(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  sizeIncrement
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method sizeIncrement
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, sizeIncrement)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeIncrement' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;sizeIncrement());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeIncrement());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::sizeIncrement(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  mouseGrabber
- *
- *    @flags    s
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method focusInEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method setVisible
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool visibles0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	vl
+ */
+
+/*!
+ * method mouseGrabber
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
+ */
+
 ZEND_METHOD(QWidget, mouseGrabber)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast &lt; QWidget * &gt;(obj-&gt;mouseGrabber());
-/// check whether method call is static.
-    } else {
-      return_object = (QWidget **) malloc(sizeof (QWidget::mouseGrabber()));    /// memory allocation
-      *return_object = static_cast &lt; QWidget * &gt;(QWidget::mouseGrabber());
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QWidget * &gt;(QWidget::mouseGrabber());
+      } else {
+        le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;mouseGrabber());
+      }
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::mouseGrabber(...) &quot;);
+}
 
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
+/*!
+ * method addActions
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QList&lt;QAction *&gt; actionss0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
+ZEND_METHOD(QWidget, addActions)
+{
+  ///QList&lt;QAction *&gt; actionss0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QList
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addActions' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QList&lt;QAction *&gt; actionss0,
+        QWidget *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QList &lt; QAction * cpp_arg_0 = static_cast &lt; QList &lt; QAction * &gt;(php_qt_fetch(arg_0));
+        RETURN_VOID(selfpointer-&gt;addActions((QList &lt; QAction *) cpp_arg_0));
+      }
+#endif
+
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::addActions(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  trUtf8
- *
- *    @flags    s
- *    @access    public
- *    @return    QString
- *    @param     const char *, const char * = 0 
+ * method trUtf8
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 const char *s0
+ * @param	 const char * = 0 s1
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	s
  */
+
 ZEND_METHOD(QWidget, trUtf8)
 {
-/*! ss public*/
-/*! const char* , const char* ,  */
-  if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+  /// const char *s0, const char * = 0 s1
+#ifdef PHP_QT_QString           // return type
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_STRING) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING) {
+      /// try  const char *s0,
+      QWidget *
+        selfpointer;
 
-        QString *return_object;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        if (getThis() != NULL) {
-/// return value is object: QString
-          *return_object = static_cast &lt; QString &gt; (obj-&gt;trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-/// check whether method call is static.
-        } else {
-          return_object = (QString *) malloc(sizeof (QWidget::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1))));   /// memory allocation
-          *return_object = static_cast &lt; QString &gt; (QWidget::trUtf8((const char *)Z_STRVAL_P(z_0), (const char *)Z_STRVAL_P(z_1)));
-        } zend_class_entry *ce;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QWidget::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } else {
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_STRING &amp;&amp; Z_TYPE_P(arg_1) == IS_STRING) {
+      /// try  const char *s0, const char * = 0 s1,
+      QWidget *
+        selfpointer;
 
-        le.ptr = return_object;
-        php_qt_register(return_value, le);
-        return;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      if (getThis() == NULL) {
+        *return_object = static_cast &lt; QString &gt; (QWidget::trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
       } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;trUtf8((const char *)&amp;Z_STRVAL_P(arg_0)[0], (const char *)&amp;Z_STRVAL_P(arg_1)[0]));
+      } le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::trUtf8(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  resetInputContext
- *
- *    @flags    
- *    @access    protected
- *    @return    void
- *    @param    
+ * method resetInputContext
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method resetInputContext is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  isFullScreen
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isFullScreen
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isFullScreen)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isFullScreen' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isFullScreen());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isFullScreen());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isFullScreen(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  mapToGlobal
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    const QPoint &amp;
+ * method mapToGlobal
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;s0
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, mapToGlobal)
 {
-/*! l public*/
-/*! const QPoint&amp; ,  */
+  ///const QPoint &amp;s0
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'mapToGlobal' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        QPoint *return_object;
-
         if (getThis() != NULL) {
-/// return value is object: QPoint
-          *return_object = static_cast &lt; QPoint &gt; (obj-&gt;mapToGlobal((const QPoint &amp;)Z_LVAL_P(z_0)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, &quot;Object not found&quot;);
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
         }
-        zend_class_entry *ce;
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *
+          ce;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QPoint *
+          return_object = new QPoint;
 
-        le.ptr = return_object;
+        *return_object = static_cast &lt; QPoint &gt; (selfpointer-&gt;mapToGlobal((const QPoint &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
         php_qt_register(return_value, le);
         return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::mapToGlobal(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  move
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int x, int y
+ * method move
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int xs0
+ * @param	 int ys1
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, move)
 {
-/*! ll public*/
-/*! int x, int y,  */
+  ///int xs0, int ys1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'move' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int xs0, int ys1,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;move((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  ///const QPoint &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'move' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;,
+        QWidget *
+          selfpointer;
 
-        void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
 
-        if (getThis() != NULL) {
-          obj-&gt;move((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;move((const QPoint &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::move(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  mapFromGlobal
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    const QPoint &amp;
+ * method mapFromGlobal
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;s0
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, mapFromGlobal)
 {
-/*! l public*/
-/*! const QPoint&amp; ,  */
+  ///const QPoint &amp;s0
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'mapFromGlobal' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QPoint &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        QPoint *return_object;
-
         if (getThis() != NULL) {
-/// return value is object: QPoint
-          *return_object = static_cast &lt; QPoint &gt; (obj-&gt;mapFromGlobal((const QPoint &amp;)Z_LVAL_P(z_0)));
-        } else {                /// END getThis(), static
-          php_error(E_ERROR, &quot;Object not found&quot;);
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
         }
-        zend_class_entry *ce;
+        QPoint *
+          cpp_arg_0 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_0));
+        zend_class_entry *
+          ce;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QPoint *
+          return_object = new QPoint;
 
-        le.ptr = return_object;
+        *return_object = static_cast &lt; QPoint &gt; (selfpointer-&gt;mapFromGlobal((const QPoint &amp;)*cpp_arg_0));
+        le.ptr = (void *)return_object;
         php_qt_register(return_value, le);
         return;
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      }
+#endif
+
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::mapFromGlobal(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setUpdatesEnabled
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool enable
+ * method qt_invoke
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 QUObject * s1
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
+
+/*!
+ * method setUpdatesEnabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enables0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setUpdatesEnabled)
 {
-/*! l public*/
-/*! int enable,  */
+  ///bool enables0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setUpdatesEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool enables0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setUpdatesEnabled((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setUpdatesEnabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setUpdatesEnabled(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setSizeIncrement
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QSize &amp;
+ * method setSizeIncrement
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &amp;s0
+ * 
+ * overloaded args:
+ * @param	int w
+ * @param	 int h
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setSizeIncrement)
 {
-///const QSize&amp;
-/*! o public*/
-/*! const QSize&amp; ,  */
+  ///const QSize &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setSizeIncrement' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QSize &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QSize *
+          cpp_arg_0 = static_cast &lt; QSize * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QSize&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setSizeIncrement((const QSize &amp;)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setSizeIncrement((const QSize &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  ///int w, int h
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setSizeIncrement' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int w, int h,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setSizeIncrement((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setSizeIncrement(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  grabMouse
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method grabMouse
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QCursor &amp;
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, grabMouse)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'grabMouse' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;grabMouse());
+    }
+  }
+  ///const QCursor &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QCursor
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'grabMouse' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QCursor &amp;,
+        QWidget *
+          selfpointer;
 
-      obj-&gt;grabMouse();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QCursor *
+          cpp_arg_0 = static_cast &lt; QCursor * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;grabMouse((const QCursor &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::grabMouse(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  layout
- *
- *    @flags    c
- *    @access    public
- *    @return    QLayout *
- *    @param    
+ * method layout
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QLayout *
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, layout)
 {
+  ///
+#ifdef PHP_QT_QLayout           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QLayout **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'layout' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QLayout *
-      *return_object = static_cast &lt; QLayout * &gt;(obj-&gt;layout());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      le.ptr = static_cast &lt; QLayout * &gt;(selfpointer-&gt;layout());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::layout(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  mapFrom
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    QWidget *, const QPoint &amp;
+ * method actionEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QActionEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method mapFrom
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * @param	 const QPoint  &amp;s1
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, mapFrom)
 {
-///QWidget*
-/*! ol public*/
-/*! QWidget* , const QPoint&amp; ,  */
+  ///QWidget *s0, const QPoint  &amp;s1
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+#ifdef PHP_QT_QPoint
+      if (inherits(Z_OBJCE_P(arg_0), 71) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'mapFrom' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *s0, const QPoint  &amp;s1,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+        QPoint *
+          cpp_arg_1 = static_cast &lt; QPoint * &gt;(php_qt_fetch(arg_1));
+        zend_class_entry *
+          ce;
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          QPoint *return_object;
+        object_init_ex(return_value, QString_ce_ptr);
+        zend_rsrc_list_entry
+          le;
+        QPoint *
+          return_object = new QPoint;
 
-          if (getThis() != NULL) {
-/// return value is object: QPoint
-            *return_object = static_cast &lt; QPoint &gt; (obj-&gt;mapFrom((QWidget *) obj_z_0, (const QPoint &amp;)Z_LVAL_P(z_1)));
-          } else {              /// END getThis(), static
-            php_error(E_ERROR, &quot;Object not found&quot;);
-          }
-          zend_class_entry *ce;
+        *return_object = static_cast &lt; QPoint &gt; (selfpointer-&gt;mapFrom((QWidget *) cpp_arg_0, (const QPoint &amp;)*cpp_arg_1));
+        le.ptr = (void *)return_object;
+        php_qt_register(return_value, le);
+        return;
+      }
+#endif
 
-          object_init_ex(return_value, QWidget_ce_ptr);
-          zend_rsrc_list_entry le;
+#endif
 
-          le.ptr = return_object;
-          php_qt_register(return_value, le);
-          return;
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::mapFrom(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowFlags
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::WindowFlags
- *    @param    
+ * method windowFlags
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::WindowFlags
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowFlags)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::WindowFlags * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'windowFlags' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      RETURN_LONG(obj-&gt;windowFlags());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;windowFlags());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::windowFlags(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isModal
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isModal
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isModal)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isModal' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isModal());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isModal());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isModal(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  unsetCursor
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method unsetCursor
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, unsetCursor)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'unsetCursor' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;unsetCursor();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;unsetCursor());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::unsetCursor(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setLayoutDirection
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::LayoutDirection direction
+ * method setLayoutDirection
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::LayoutDirection directions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setLayoutDirection)
 {
-/*! l public*/
-/*! int direction,  */
+  ///Qt::LayoutDirection directions0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setLayoutDirection' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::LayoutDirection directions0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setLayoutDirection(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  maximumHeight
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method tabletEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QTabletEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method maximumHeight
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, maximumHeight)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'maximumHeight' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;maximumHeight());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;maximumHeight());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::maximumHeight(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  frameGeometry
- *
- *    @flags    c
- *    @access    public
- *    @return    QRect
- *    @param    
+ * method frameGeometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, frameGeometry)
 {
+  ///
+#ifdef PHP_QT_QRect             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRect *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'frameGeometry' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRect
-      *return_object = static_cast &lt; QRect &gt; (obj-&gt;frameGeometry());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;frameGeometry());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::frameGeometry(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  handle
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::HANDLE
- *    @param    
+ * method enterEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method customContextMenuRequested
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QPoint &amp;poss0
+ * 
+ * @access	signals
+ * @return	void
+ * @flags	n
+ */
+
+/*!
+ * method handle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::HANDLE
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, handle)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::HANDLE * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'handle' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      obj-&gt;handle();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;handle());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::handle(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  lower
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method lower
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, lower)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'lower' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;lower();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;lower());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::lower(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowTitle
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &amp;
+ * method setWindowTitle
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWindowTitle)
 {
-///const QString&amp;
-/*! o public*/
-/*! const QString&amp; ,  */
+  ///const QString &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setWindowTitle' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)-&gt;name, &quot;QString&quot;)) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj-&gt;setWindowTitle((const QString &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;setWindowTitle((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setWindowTitle(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowState
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::WindowStates state
+ * method setWindowState
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WindowStates states0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWindowState)
 {
-/*! l public*/
-/*! int state,  */
+  ///Qt::WindowStates states0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setWindowState' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::WindowStates states0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setWindowState((Qt::WindowStates) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setWindowState((Qt::WindowStates) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setWindowState(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  scroll
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int dx, int dy
+ * method scroll
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int dxs0
+ * @param	 int dys1
+ * 
+ * overloaded args:
+ * @param	int dx
+ * @param	 int dy
+ * @param	 const QRect&amp;
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, scroll)
 {
-/*! ll public*/
-/*! int dx, int dy,  */
+  ///int dxs0, int dys1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'scroll' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int dxs0, int dys1,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;scroll((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  ///int dx, int dy, const QRect&amp;
+  if (ZEND_NUM_ARGS() == 3) {
+    PHP_QT_FETCH_3_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_2), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'scroll' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try int dx, int dy, const QRect&amp;,
+        QWidget *
+          selfpointer;
 
-        void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_2 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_2));
 
-        if (getThis() != NULL) {
-          obj-&gt;scroll((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;scroll((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QRect &amp;)*cpp_arg_2));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::scroll(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  sizePolicy
- *
- *    @flags    c
- *    @access    public
- *    @return    QSizePolicy
- *    @param    
+ * method sizePolicy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSizePolicy
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, sizePolicy)
 {
+  ///
+#ifdef PHP_QT_QSizePolicy       // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSizePolicy *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizePolicy' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSizePolicy
-      *return_object = static_cast &lt; QSizePolicy &gt; (obj-&gt;sizePolicy());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSizePolicy *
+        return_object = new QSizePolicy;
+
+      *return_object = static_cast &lt; QSizePolicy &gt; (selfpointer-&gt;sizePolicy());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::sizePolicy(...) &quot;);
+}
 
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
+/*!
+ * method width
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
+ZEND_METHOD(QWidget, width)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'width' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;width());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::width(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  width
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method actions
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QList&lt;QAction*&gt;
+ * @flags	c
  */
-ZEND_METHOD(QWidget, width)
+
+ZEND_METHOD(QWidget, actions)
 {
+  ///
+#ifdef PHP_QT_QList             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'actions' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-      RETURN_LONG(obj-&gt;width());
-    }                           /// 5 END getThis(), simple types
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = static_cast &lt; QList &lt; QAction &gt; *&gt;(selfpointer-&gt;actions());
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::actions(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setHidden
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    bool hidden
+ * method setHidden
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool hiddens0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, setHidden)
 {
-/*! l public_slots*/
-/*! int hidden,  */
+  ///bool hiddens0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setHidden' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool hiddens0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setHidden((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setHidden((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setHidden(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  find
- *
- *    @flags    s
- *    @access    public
- *    @return    QWidget *
- *    @param    WId
+ * method find
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	WId WIds0
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
+
 ZEND_METHOD(QWidget, find)
 {
-/*! l public*/
-/*! unsigned int ,  */
-  if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+// notice: unknown argument WId WIds0, skipped
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::find(...) &quot;);
+}
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+/*!
+ * method staticMetaObject
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QMetaObject*
+ * @flags	s
+ */
 
-        QWidget **return_object;
+ZEND_METHOD(QWidget, staticMetaObject)
+{
+  ///
+#ifdef PHP_QT_QMetaObject       // return type
 
-        if (getThis() != NULL) {
-/// return: pointer
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QWidget *
+        selfpointer;
 
-/// return value is object: QWidget *
-          *return_object = static_cast &lt; QWidget * &gt;(obj-&gt;find((WId) Z_LVAL_P(z_0)));
-/// check whether method call is static.
-        } else {
-          return_object = (QWidget **) malloc(sizeof (QWidget::find((WId) Z_LVAL_P(z_0))));     /// memory allocation
-          *return_object = static_cast &lt; QWidget * &gt;(QWidget::find((WId) Z_LVAL_P(z_0)));
-        }
-        zend_class_entry *ce;
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-        object_init_ex(return_value, QWidget_ce_ptr);
-        zend_rsrc_list_entry le;
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-        le.ptr = return_object[0];
-        php_qt_register(return_value, le);
-        return;
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QMetaObject * &gt;(QWidget::staticMetaObject());
       } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        le.ptr = static_cast &lt; QMetaObject * &gt;(selfpointer-&gt;staticMetaObject());
+      }
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::staticMetaObject(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  staticMetaObject
- *
- *    @flags    s
- *    @access    public
- *    @return    QMetaObject*
- *    @param    
+ * method mouseReleaseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
-ZEND_METHOD(QWidget, staticMetaObject)
-{
-}
 
 /*!
- *    @class     QWidget
- *    @function  size
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method size
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, size)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'size' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;size());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;size());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::size(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  activateWindow
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method activateWindow
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, activateWindow)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'activateWindow' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;activateWindow();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;activateWindow());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::activateWindow(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setToolTip
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &amp;
+ * method hideEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QHideEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method setToolTip
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setToolTip)
 {
-///const QString&amp;
-/*! o public*/
-/*! const QString&amp; ,  */
+  ///const QString &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setToolTip' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)-&gt;name, &quot;QString&quot;)) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj-&gt;setToolTip((const QString &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;setToolTip((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setToolTip(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setParent
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QWidget *parent
+ * method inputMethodQuery
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::InputMethodQuery Qt::InputMethodQuerys0
+ * 
+ * @access	public
+ * @return	QVariant
+ * @flags	cv
  */
+
+/*!
+ * method setParent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *parents0
+ * 
+ * overloaded args:
+ * @param	QWidget *parent
+ * @param	 Qt::WFlags f
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setParent)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* parent,  */
+  ///QWidget *parents0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setParent' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *parents0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setParent((QWidget *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setParent((QWidget *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
+    }
+  }
+  ///QWidget *parent, Qt::WFlags f
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setParent' is not static&quot;);
+          RETURN_NULL();
         }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        /// try QWidget *parent, Qt::WFlags f,
+        QWidget *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setParent((QWidget *) cpp_arg_0, (Qt::WFlags) Z_LVAL_P(arg_1)));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setParent(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isWindowModified
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isWindowModified
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isWindowModified)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isWindowModified' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isWindowModified());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isWindowModified());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isWindowModified(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  testAttribute
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    Qt::WidgetAttribute
+ * method testAttribute
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WidgetAttribute Qt::WidgetAttributes0
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, testAttribute)
 {
-/*! l public*/
-/*! int ,  */
+  ///Qt::WidgetAttribute Qt::WidgetAttributes0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'testAttribute' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::WidgetAttribute Qt::WidgetAttributes0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;testAttribute((Qt::WidgetAttribute) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::testAttribute(...) &quot;);
+}
 
-        bool *return_object;
+/*!
+ * method minimumSizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cv
+ */
 
-        if (getThis() != NULL) {
-          RETURN_BOOL(obj-&gt;testAttribute((Qt::WidgetAttribute) Z_LVAL_P(z_0)));
-        }                       /// 5 END getThis(), simple types
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
+/*!
+ * method heightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	cv
+ */
 
 /*!
- *    @class     QWidget
- *    @function  pos
- *
- *    @flags    c
- *    @access    public
- *    @return    QPoint
- *    @param    
+ * method pos
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPoint
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, pos)
 {
+  ///
+#ifdef PHP_QT_QPoint            // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QPoint *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'pos' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QPoint
-      *return_object = static_cast &lt; QPoint &gt; (obj-&gt;pos());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QPoint *
+        return_object = new QPoint;
+
+      *return_object = static_cast &lt; QPoint &gt; (selfpointer-&gt;pos());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::pos(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isWindow
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isWindow
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isWindow)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isWindow' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isWindow());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isWindow());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isWindow(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  create
- *
- *    @flags    
- *    @access    protected
- *    @return    void
- *    @param    WId = 0, bool initializeWindow = true, bool destroyOldWindow = true
+ * method create
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	WId = 0s0
+ * @param	 bool initializeWindow = trues1
+ * @param	 bool destroyOldWindow = trues2
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method create is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  setFocusPolicy
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::FocusPolicy policy
+ * method setFocusPolicy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::FocusPolicy policys0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setFocusPolicy)
 {
-/*! l public*/
-/*! int policy,  */
+  ///Qt::FocusPolicy policys0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setFocusPolicy' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::FocusPolicy policys0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setFocusPolicy((Qt::FocusPolicy) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setFocusPolicy((Qt::FocusPolicy) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setFocusPolicy(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  getContentsMargins
- *
- *    @flags    c
- *    @access    public
- *    @return    void
- *    @param    int *left, int *top, int *right, int *bottom
+ * method getContentsMargins
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int *lefts0
+ * @param	 int *tops1
+ * @param	 int *rights2
+ * @param	 int *bottoms3
+ * 
+ * @access	public
+ * @return	void
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, getContentsMargins)
 {
-/*! llll public*/
-/*! int* left, int* top, int* right, int* bottom,  */
+  ///int *lefts0, int *tops1, int *rights2, int *bottoms3
   if (ZEND_NUM_ARGS() == 4) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'getContentsMargins' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int *lefts0, int *tops1, int *rights2, int *bottoms3,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;getContentsMargins((int *)Z_LVAL_P(z_0), (int *)Z_LVAL_P(z_1), (int *)Z_LVAL_P(z_2), (int *)Z_LVAL_P(z_3));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;getContentsMargins((int *)&amp;Z_LVAL_P(arg_0), (int *)&amp;Z_LVAL_P(arg_1), (int *)&amp;Z_LVAL_P(arg_2), (int *)&amp;Z_LVAL_P(arg_3)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::getContentsMargins(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowTitle
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method dropEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDropEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method windowTitle
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, windowTitle)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'windowTitle' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast &lt; QString &gt; (obj-&gt;windowTitle());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;windowTitle());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::windowTitle(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  style
- *
- *    @flags    c
- *    @access    public
- *    @return    QStyle *
- *    @param    
+ * method keyReleaseEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method style
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QStyle *
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, style)
 {
+  ///
+#ifdef PHP_QT_QStyle            // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QStyle **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'style' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QStyle *
-      *return_object = static_cast &lt; QStyle * &gt;(obj-&gt;style());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      le.ptr = static_cast &lt; QStyle * &gt;(selfpointer-&gt;style());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::style(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  windowState
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::WindowStates
- *    @param    
+ * method windowState
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::WindowStates
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, windowState)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::WindowStates * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'windowState' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      RETURN_LONG(obj-&gt;windowState());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;windowState());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::windowState(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  frameSize
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method frameSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, frameSize)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'frameSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;frameSize());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;frameSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::frameSize(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setAccessibleName
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &amp;name
+ * method setAccessibleName
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;names0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setAccessibleName)
 {
-///const QString&amp;
-/*! o public*/
-/*! const QString&amp; name,  */
+  ///const QString &amp;names0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setAccessibleName' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;names0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)-&gt;name, &quot;QString&quot;)) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj-&gt;setAccessibleName((const QString &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;setAccessibleName((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setAccessibleName(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setAcceptDrops
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool on
+ * method setAcceptDrops
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool ons0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setAcceptDrops)
 {
-/*! l public*/
-/*! int on,  */
+  ///bool ons0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setAcceptDrops' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool ons0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setAcceptDrops((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setAcceptDrops(...) &quot;);
+}
 
-        void *return_object;
+/*!
+ * method setSizePolicy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QSizePolicy QSizePolicys0
+ * 
+ * overloaded args:
+ * @param	QSizePolicy::Policy horizontal
+ * @param	 QSizePolicy::Policy vertical
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
 
+ZEND_METHOD(QWidget, setSizePolicy)
+{
+  ///QSizePolicy QSizePolicys0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSizePolicy
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setSizePolicy' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QSizePolicy QSizePolicys0,
+        QWidget *
+          selfpointer;
+
         if (getThis() != NULL) {
-          obj-&gt;setAcceptDrops((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QSizePolicy *
+          cpp_arg_0 = static_cast &lt; QSizePolicy * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setSizePolicy((QSizePolicy) * cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  ///QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setSizePolicy' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setSizePolicy((QSizePolicy::Policy) Z_LVAL_P(arg_0), (QSizePolicy::Policy) Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setSizePolicy(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  removeAction
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QAction *action
+ * method languageChange
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method removeAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QAction *actions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, removeAction)
 {
-///qt_QAction*
-/*! o public*/
-/*! qt_QAction* action,  */
+  ///QAction *actions0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'removeAction' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QAction *actions0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QAction *
+          cpp_arg_0 = static_cast &lt; QAction * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QAction&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;removeAction((QAction *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;removeAction((QAction *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::removeAction(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  hasFocus
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method hasFocus
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, hasFocus)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hasFocus' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;hasFocus());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;hasFocus());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::hasFocus(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  showFullScreen
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method contextMenuEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QContextMenuEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method showFullScreen
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
+
 ZEND_METHOD(QWidget, showFullScreen)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'showFullScreen' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;showFullScreen();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;showFullScreen());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::showFullScreen(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMouseTracking
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    bool enable
+ * method qt_property
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	 int  ints0
+ * @param	 int  ints1
+ * @param	 QVariant * s2
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	v
  */
+
+/*!
+ * method setMouseTracking
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool enables0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setMouseTracking)
 {
-/*! l public*/
-/*! int enable,  */
+  ///bool enables0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMouseTracking' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool enables0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setMouseTracking((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMouseTracking((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setMouseTracking(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  clearMask
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method clearMask
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, clearMask)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'clearMask' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;clearMask();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;clearMask());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::clearMask(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  showMaximized
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method moveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMoveEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method inputMethodEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QInputMethodEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
+
+/*!
+ * method showMaximized
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
+
 ZEND_METHOD(QWidget, showMaximized)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'showMaximized' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;showMaximized();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;showMaximized());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::showMaximized(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  devType
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method devType
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, devType)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'devType' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;devType());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;devType());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::devType(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  font
- *
- *    @flags    c
- *    @access    public
- *    @return    const QFont &amp;
- *    @param    
+ * method font
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	const QFont &amp;
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, font)
 {
+  ///
+#ifdef PHP_QT_QFont             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'font' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+
+      le.ptr = &amp;const_cast &lt; QFont &amp; &gt;(selfpointer-&gt;font());
+      php_qt_register(return_value, le);
+      return;
+    }
   }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::font(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  stackUnder
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QWidget*
+ * method stackUnder
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, stackUnder)
 {
-///QWidget*
-/*! o public*/
-/*! QWidget* ,  */
+  ///QWidget *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'stackUnder' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;stackUnder((QWidget *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;stackUnder((QWidget *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::stackUnder(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMinimumSize
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QSize &amp;
+ * method setMinimumSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &amp;s0
+ * 
+ * overloaded args:
+ * @param	int minw
+ * @param	 int minh
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setMinimumSize)
 {
-///const QSize&amp;
-/*! o public*/
-/*! const QSize&amp; ,  */
+  ///const QSize &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setMinimumSize' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QSize &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QSize *
+          cpp_arg_0 = static_cast &lt; QSize * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QSize&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setMinimumSize((const QSize &amp;)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setMinimumSize((const QSize &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  ///int minw, int minh
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMinimumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int minw, int minh,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMinimumSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setMinimumSize(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setDisabled
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    bool
+ * method setDisabled
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, setDisabled)
 {
-/*! l public_slots*/
-/*! int ,  */
+  ///bool bools0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_BOOL) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setDisabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try bool bools0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setDisabled((bool) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setDisabled(...) &quot;);
+}
 
-        void *return_object;
+/*!
+ * method leaveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
 
-        if (getThis() != NULL) {
-          obj-&gt;setDisabled((bool) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
-}
+/*!
+ * method dragEnterEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDragEnterEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
+ */
 
 /*!
- *    @class     QWidget
- *    @function  show
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method enabledChange
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool bools0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method show
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
+ */
+
 ZEND_METHOD(QWidget, show)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'show' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;show();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;show());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::show(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  underMouse
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method underMouse
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, underMouse)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'underMouse' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;underMouse());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;underMouse());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::underMouse(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowIcon
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QIcon &amp;icon
+ * method setWindowIcon
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QIcon &amp;icons0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWindowIcon)
 {
-///const QIcon&amp;
-/*! o public*/
-/*! const QIcon&amp; icon,  */
+  ///const QIcon &amp;icons0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QIcon
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setWindowIcon' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QIcon &amp;icons0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QIcon *
+          cpp_arg_0 = static_cast &lt; QIcon * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QIcon&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setWindowIcon((const QIcon &amp;)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setWindowIcon((const QIcon &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setWindowIcon(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  grabKeyboard
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    
+ * method focusOutEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QFocusEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method grabKeyboard
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, grabKeyboard)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'grabKeyboard' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;grabKeyboard();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;grabKeyboard());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::grabKeyboard(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  raise
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method raise
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, raise)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'raise' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;raise();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;raise());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::raise(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  event
- *
- *    @flags    
- *    @access    protected
- *    @return    bool
- *    @param    QEvent *
+ * method event
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QEvent *s0
+ * 
+ * @access	protected
+ * @return	bool
+ * @flags	
  */
-// method event is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  setWhatsThis
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &amp;
+ * method setWhatsThis
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setWhatsThis)
 {
-///const QString&amp;
-/*! o public*/
-/*! const QString&amp; ,  */
+  ///const QString &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setWhatsThis' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)-&gt;name, &quot;QString&quot;)) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj-&gt;setWhatsThis((const QString &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;setWhatsThis((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setWhatsThis(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setGeometry
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int x, int y, int w, int h
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int xs0
+ * @param	 int ys1
+ * @param	 int ws2
+ * @param	 int hs3
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setGeometry)
 {
-/*! llll public*/
-/*! int x, int y, int w, int h,  */
+  ///int xs0, int ys1, int ws2, int hs3
   if (ZEND_NUM_ARGS() == 4) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
-    zval *z_2;                  /// define ZVAL
-    zval *z_3;                  /// define ZVAL
+    PHP_QT_FETCH_4_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG &amp;&amp; Z_TYPE_P(arg_2) == IS_LONG &amp;&amp; Z_TYPE_P(arg_3) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setGeometry' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int xs0, int ys1, int ws2, int hs3,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setGeometry((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
+    }
+  }
+  ///const QRect &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setGeometry' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;,
+        QWidget *
+          selfpointer;
 
-        void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
 
-        if (getThis() != NULL) {
-          obj-&gt;setGeometry((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1), (int)Z_LVAL_P(z_2), (int)Z_LVAL_P(z_3));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;setGeometry((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setGeometry(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  contextMenuPolicy
- *
- *    @flags    c
- *    @access    public
- *    @return    Qt::ContextMenuPolicy
- *    @param    
+ * method contextMenuPolicy
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::ContextMenuPolicy
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, contextMenuPolicy)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    Qt::ContextMenuPolicy * return_object;
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'contextMenuPolicy' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-      RETURN_LONG(obj-&gt;contextMenuPolicy());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;contextMenuPolicy());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::contextMenuPolicy(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  resize
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int w, int h
+ * method resize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ws0
+ * @param	 int hs1
+ * 
+ * overloaded args:
+ * @param	const QSize &amp;
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, resize)
 {
-/*! ll public*/
-/*! int w, int h,  */
+  ///int ws0, int hs1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'resize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ws0, int hs1,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;resize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  ///const QSize &amp;
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'resize' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QSize &amp;,
+        QWidget *
+          selfpointer;
 
-        void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QSize *
+          cpp_arg_0 = static_cast &lt; QSize * &gt;(php_qt_fetch(arg_0));
 
-        if (getThis() != NULL) {
-          obj-&gt;resize((int)Z_LVAL_P(z_0), (int)Z_LVAL_P(z_1));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;resize((const QSize &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::resize(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isLeftToRight
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isLeftToRight
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isLeftToRight)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isLeftToRight' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isLeftToRight());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isLeftToRight());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isLeftToRight(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setWindowFlags
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::WindowFlags type
+ * method showEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QShowEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method setWindowFlags
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WindowFlags types0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setWindowFlags)
 {
-/*! l public*/
-/*! int type,  */
+  ///Qt::WindowFlags types0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setWindowFlags' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::WindowFlags types0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setWindowFlags((Qt::WindowFlags) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setWindowFlags((Qt::WindowFlags) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setWindowFlags(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  baseSize
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method baseSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, baseSize)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'baseSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;baseSize());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;baseSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::baseSize(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setLayout
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QLayout *
+ * method setLayout
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QLayout *s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setLayout)
 {
-///qt_QLayout*
-/*! o public*/
-/*! qt_QLayout* ,  */
+  ///QLayout *s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QLayout
+      if (inherits(Z_OBJCE_P(arg_0), 41)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setLayout' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QLayout *s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QLayout *
+          cpp_arg_0 = static_cast &lt; QLayout * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QLayout&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setLayout((QLayout *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setLayout((QLayout *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-    else {
-        php_error(E_ERROR, &quot;arg parse error.&quot;);
     }
-  }                             /// END ZEND_NUM_ARGS
-  else {
-    php_error(E_ERROR, &quot;wrong arg count.&quot;);
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setLayout(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMaximumHeight
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int maxh
+ * method setMaximumHeight
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int maxhs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setMaximumHeight)
 {
-/*! l public*/
-/*! int maxh,  */
+  ///int maxhs0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMaximumHeight' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int maxhs0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setMaximumHeight((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMaximumHeight((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setMaximumHeight(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  showNormal
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method showNormal
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, showNormal)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'showNormal' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;showNormal();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;showNormal());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::showNormal(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  insertAction
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QAction *before, QAction *action
+ * method insertAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QAction *befores0
+ * @param	 QAction *actions1
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, insertAction)
 {
-///qt_QAction*
-///qt_QAction*
-/*! oo public*/
-/*! qt_QAction* before, qt_QAction* action,  */
+  ///QAction *befores0, QAction *actions1
   if (ZEND_NUM_ARGS() == 2) {
-    zval *z_0;                  /// define ZVAL
-    zval *z_1;                  /// define ZVAL
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(arg_1) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_0), 0) &amp;&amp; inherits(Z_OBJCE_P(arg_1), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'insertAction' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QAction *befores0, QAction *actions1,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
-        QObject *obj_z_1 = (QObject *) php_qt_fetch(z_1);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QAction *
+          cpp_arg_0 = static_cast &lt; QAction * &gt;(php_qt_fetch(arg_0));
+        QAction *
+          cpp_arg_1 = static_cast &lt; QAction * &gt;(php_qt_fetch(arg_1));
 
-        if (obj_z_0-&gt;inherits(&quot;QAction&quot;) &amp;&amp; obj_z_1-&gt;inherits(&quot;QAction&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;insertAction((QAction *) cpp_arg_0, (QAction *) cpp_arg_1));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;insertAction((QAction *) obj_z_0, (QAction *) obj_z_1);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::insertAction(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  window
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method window
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, window)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'window' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast &lt; QWidget * &gt;(obj-&gt;window());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;window());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::window(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  paintEngine
- *
- *    @flags    c
- *    @access    public
- *    @return    QPaintEngine *
- *    @param    
+ * method paintEngine
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QPaintEngine *
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, paintEngine)
 {
+  ///
+#ifdef PHP_QT_QPaintEngine      // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QPaintEngine **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'paintEngine' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QPaintEngine *
-      *return_object = static_cast &lt; QPaintEngine * &gt;(obj-&gt;paintEngine());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      le.ptr = static_cast &lt; QPaintEngine * &gt;(selfpointer-&gt;paintEngine());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::paintEngine(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  minimumHeight
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method minimumHeight
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, minimumHeight)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumHeight' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;minimumHeight());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;minimumHeight());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::minimumHeight(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  x
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method x
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, x)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'x' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;x());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;x());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::x(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  releaseShortcut
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int id
+ * method releaseShortcut
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ids0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, releaseShortcut)
 {
-/*! l public*/
-/*! int id,  */
+  ///int ids0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'releaseShortcut' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ids0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;releaseShortcut((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;releaseShortcut((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::releaseShortcut(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setStatusTip
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QString &amp;
+ * method setStatusTip
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QString &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setStatusTip)
 {
-///const QString&amp;
-/*! o public*/
-/*! const QString&amp; ,  */
+  ///const QString &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    arg_0 = invokeToQString(arg_0);
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QString
+      if (inherits(Z_OBJCE_P(arg_0), 59)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setStatusTip' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QString &amp;s0,
+        QWidget *
+          selfpointer;
 
-        if (!strcmp(Z_OBJCE_P(z_0)-&gt;name, &quot;QString&quot;)) {
-          void *return_object;
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QString *
+          cpp_arg_0 = static_cast &lt; QString * &gt;(php_qt_fetch(arg_0));
 
-          if (getThis() != NULL) {
-            obj-&gt;setStatusTip((const QString &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+        RETURN_VOID(selfpointer-&gt;setStatusTip((const QString &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setStatusTip(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setBaseSize
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    const QSize &amp;
+ * method mousePressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QMouseEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method setBaseSize
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QSize &amp;s0
+ * 
+ * overloaded args:
+ * @param	int basew
+ * @param	 int baseh
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setBaseSize)
 {
-///const QSize&amp;
-/*! o public*/
-/*! const QSize&amp; ,  */
+  ///const QSize &amp;s0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QSize
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setBaseSize' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QSize &amp;s0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QSize *
+          cpp_arg_0 = static_cast &lt; QSize * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QSize&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;setBaseSize((const QSize &amp;)*cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;setBaseSize((const QSize &amp;)*obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  ///int basew, int baseh
+  if (ZEND_NUM_ARGS() == 2) {
+    PHP_QT_FETCH_2_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG &amp;&amp; Z_TYPE_P(arg_1) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setBaseSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int basew, int baseh,
+      QWidget *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setBaseSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setBaseSize(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  rect
- *
- *    @flags    c
- *    @access    public
- *    @return    QRect
- *    @param    
+ * method rect
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, rect)
 {
+  ///
+#ifdef PHP_QT_QRect             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QRect *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'rect' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QRect
-      *return_object = static_cast &lt; QRect &gt; (obj-&gt;rect());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;rect());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::rect(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  addAction
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    QAction *action
+ * method addAction
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QAction *actions0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, addAction)
 {
-///qt_QAction*
-/*! o public*/
-/*! qt_QAction* action,  */
+  ///QAction *actions0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QAction
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'addAction' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QAction *actions0,
+        QWidget *
+          selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_OBJECT) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-        QObject *obj_z_0 = (QObject *) php_qt_fetch(z_0);
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+        }
+        QAction *
+          cpp_arg_0 = static_cast &lt; QAction * &gt;(php_qt_fetch(arg_0));
 
-        if (obj_z_0-&gt;inherits(&quot;QAction&quot;)) {
-          void *return_object;
+        RETURN_VOID(selfpointer-&gt;addAction((QAction *) cpp_arg_0));
+      }
+#endif
 
-          if (getThis() != NULL) {
-            obj-&gt;addAction((QAction *) obj_z_0);
-            RETURN_NULL();
-          }                     /// END getThis(), NULL
-        }
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::addAction(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  minimumSize
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, minimumSize)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;minimumSize());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;minimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::minimumSize(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setFocus
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::FocusReason reason
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	cv
  */
+
+/*!
+ * method setFocus
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::FocusReason reasons0
+ * @param: -
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
+ */
+
 ZEND_METHOD(QWidget, setFocus)
 {
-/*! l public*/
-/*! int reason,  */
+  ///Qt::FocusReason reasons0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setFocus' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::FocusReason reasons0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setFocus((Qt::FocusReason) Z_LVAL_P(arg_0)));
+    }
+  }
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setFocus' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;setFocus((Qt::FocusReason) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setFocus());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setFocus(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  destroy
- *
- *    @flags    
- *    @access    protected
- *    @return    void
- *    @param    bool destroyWindow = true, bool destroySubWindows = true
+ * method destroy
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	bool destroyWindow = trues0
+ * @param	 bool destroySubWindows = trues1
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	
  */
-// method destroy is protected, skipped.
 
 /*!
- *    @class     QWidget
- *    @function  isVisible
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method dragMoveEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QDragMoveEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method isVisible
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, isVisible)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isVisible' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isVisible());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isVisible());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isVisible(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  accessibleName
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method accessibleName
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, accessibleName)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'accessibleName' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast &lt; QString &gt; (obj-&gt;accessibleName());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;accessibleName());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::accessibleName(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  minimumWidth
- *
- *    @flags    c
- *    @access    public
- *    @return    int
- *    @param    
+ * method keyPressEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QKeyEvent *s0
+ * 
+ * @access	protected
+ * @return	void
+ * @flags	v
  */
+
+/*!
+ * method minimumWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
+ */
+
 ZEND_METHOD(QWidget, minimumWidth)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    int *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_LONG(obj-&gt;minimumWidth());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;minimumWidth());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::minimumWidth(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isEnabled
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isEnabled
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isEnabled)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isEnabled' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isEnabled());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isEnabled());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isEnabled(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  keyboardGrabber
- *
- *    @flags    s
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method keyboardGrabber
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	s
  */
+
 ZEND_METHOD(QWidget, keyboardGrabber)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast &lt; QWidget * &gt;(obj-&gt;keyboardGrabber());
-/// check whether method call is static.
-    } else {
-      return_object = (QWidget **) malloc(sizeof (QWidget::keyboardGrabber())); /// memory allocation
-      *return_object = static_cast &lt; QWidget * &gt;(QWidget::keyboardGrabber());
+      if (getThis() == NULL) {
+        le.ptr = static_cast &lt; QWidget * &gt;(QWidget::keyboardGrabber());
+      } else {
+        le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;keyboardGrabber());
+      }
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::keyboardGrabber(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  overrideWindowState
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    Qt::WindowStates state
+ * method overrideWindowState
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WindowStates states0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, overrideWindowState)
 {
-/*! l public*/
-/*! int state,  */
+  ///Qt::WindowStates states0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'overrideWindowState' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::WindowStates states0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-        void *return_object;
-
-        if (getThis() != NULL) {
-          obj-&gt;overrideWindowState((Qt::WindowStates) Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;overrideWindowState((Qt::WindowStates) Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::overrideWindowState(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  setMinimumHeight
- *
- *    @flags    
- *    @access    public
- *    @return    void
- *    @param    int minh
+ * method setMinimumHeight
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int minhs0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
+
 ZEND_METHOD(QWidget, setMinimumHeight)
 {
-/*! l public*/
-/*! int minh,  */
+  ///int minhs0
   if (ZEND_NUM_ARGS() == 1) {
-    zval *z_0;                  /// define ZVAL
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'setMinimumHeight' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int minhs0,
+      QWidget *
+        selfpointer;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, &quot;z&quot;, &amp;z_0) == SUCCESS) {
-      if (Z_TYPE_P(z_0) == IS_LONG) {
-        QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;setMinimumHeight((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::setMinimumHeight(...) &quot;);
+}
 
-        void *return_object;
+/*!
+ * method testAttribute_helper
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WidgetAttribute Qt::WidgetAttributes0
+ * 
+ * @access	private
+ * @return	bool
+ * @flags	c
+ */
 
-        if (getThis() != NULL) {
-          obj-&gt;setMinimumHeight((int)Z_LVAL_P(z_0));
-          RETURN_NULL();
-        }                       /// END getThis(), NULL
-      } else {
-        php_error(E_ERROR, &quot;argument not allowed&quot;);
-      }                         /// END check of argument types
-    }                           /// END zend_parse_parameters
-  }                             /// END ZEND_NUM_ARGS
+ZEND_METHOD(QWidget, testAttribute_helper)
+{
+  ///Qt::WidgetAttribute Qt::WidgetAttributes0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+/// method is private, skip
+      php_error(E_ERROR, &quot;QWidget::testAttribute_helper(...) cannot be called with 'Qt::WidgetAttribute Qt::WidgetAttributes0,'.&quot;);
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::testAttribute_helper(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  isMaximized
- *
- *    @flags    c
- *    @access    public
- *    @return    bool
- *    @param    
+ * method isMaximized
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, isMaximized)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    bool *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isMaximized' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      RETURN_BOOL(obj-&gt;isMaximized());
-    }                           /// 5 END getThis(), simple types
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isMaximized());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::isMaximized(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  parentWidget
- *
- *    @flags    c
- *    @access    public
- *    @return    QWidget *
- *    @param    
+ * method parentWidget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, parentWidget)
 {
+  ///
+#ifdef PHP_QT_QWidget           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QWidget **return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'parentWidget' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return: pointer
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
 
-/// return value is object: QWidget *
-      *return_object = static_cast &lt; QWidget * &gt;(obj-&gt;parentWidget());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      le.ptr = static_cast &lt; QWidget * &gt;(selfpointer-&gt;parentWidget());
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object[0];
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::parentWidget(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  whatsThis
- *
- *    @flags    c
- *    @access    public
- *    @return    QString
- *    @param    
+ * method whatsThis
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QString
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, whatsThis)
 {
+  ///
+#ifdef PHP_QT_QString           // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QString *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'whatsThis' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QString
-      *return_object = static_cast &lt; QString &gt; (obj-&gt;whatsThis());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QString *
+        return_object = new QString;
+
+      *return_object = static_cast &lt; QString &gt; (selfpointer-&gt;whatsThis());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::whatsThis(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  maximumSize
- *
- *    @flags    c
- *    @access    public
- *    @return    QSize
- *    @param    
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
+
 ZEND_METHOD(QWidget, maximumSize)
 {
+  ///
+#ifdef PHP_QT_QSize             // return type
+
   if (ZEND_NUM_ARGS() == 0) {
-    QSize *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'maximumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-/// return value is object: QSize
-      *return_object = static_cast &lt; QSize &gt; (obj-&gt;maximumSize());
-    } else {                    /// END getThis(), static
-      php_error(E_ERROR, &quot;Object not found&quot;);
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;maximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
     }
-    zend_class_entry *ce;
+  }
+#endif // return type
 
-    object_init_ex(return_value, QWidget_ce_ptr);
-    zend_rsrc_list_entry le;
-
-    le.ptr = return_object;
-    php_qt_register(return_value, le);
-    return;
-  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::maximumSize(...) &quot;);
 }
 
 /*!
- *    @class     QWidget
- *    @function  showMinimized
- *
- *    @flags    l
- *    @access    public_slots
- *    @return    void
- *    @param    
+ * method showMinimized
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public_slots
+ * @return	void
+ * @flags	l
  */
+
 ZEND_METHOD(QWidget, showMinimized)
 {
+  ///
   if (ZEND_NUM_ARGS() == 0) {
-    void *return_object;
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'showMinimized' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidget *
+        selfpointer;
 
-    if (getThis() != NULL) {
-      QWidget *obj = (QWidget *) PHP_QT_FETCH();
-
-      obj-&gt;showMinimized();
-      RETURN_NULL();
-    }                           /// END getThis(), NULL
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidget * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_VOID(selfpointer-&gt;showMinimized());
+    }
   }
+  php_error(E_ERROR, &quot;could not parse argument in QWidget::showMinimized(...) &quot;);
 }
-
-
-PHP_QT_DESTRUCT(QWidget);

Modified: trunk/qt/classes/qwidgetdata.cpp
===================================================================
--- trunk/qt/classes/qwidgetdata.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qwidgetdata.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,17 +19,14 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QWidgetData.cpp - QWidgetData PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QWidgetData&gt;
 #include &quot;../php_qt.h&quot;
 
 
-
-PHP_QT_DESTRUCT(QWidgetData);
-
+#include &lt;QWidgetData&gt;

Modified: trunk/qt/classes/qwidgetitem.cpp
===================================================================
--- trunk/qt/classes/qwidgetitem.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qwidgetitem.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,237 +19,463 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QWidgetItem.cpp - QWidgetItem PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QWidgetItem&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  hasHeightForWidth
- *    flags:    c
+#include &lt;QWidgetItem&gt;
+#include &lt;QMetaMethod&gt;
+class QWidgetItem_php_qt:public QWidgetItem
+{
+
+public:
+  QWidgetItem_php_qt(zval * zend_ptr, QWidget * ws0);
+
+
+  zval *zend_ptr;
+};
+
+QWidgetItem_php_qt::QWidgetItem_php_qt(zval * zend_ptr, QWidget * ws0):QWidgetItem(ws0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method hasHeightForWidth
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, hasHeightForWidth){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;hasHeightForWidth());
-	}
+
+ZEND_METHOD(QWidgetItem, hasHeightForWidth)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'hasHeightForWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidgetItem * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;hasHeightForWidth());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidgetItem::hasHeightForWidth(...) &quot;);
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  isEmpty
- *    flags:    c
+/*!
+ * method widget
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QWidget *
+ * @flags	v
  */
-ZEND_METHOD(QWidgetItem, isEmpty){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-			RETURN_BOOL(obj-&gt;isEmpty());
-	}
+
+/*!
+ * method expandingDirections
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::Orientations
+ * @flags	c
+ */
+
+ZEND_METHOD(QWidgetItem, expandingDirections)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'expandingDirections' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidgetItem * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;expandingDirections());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidgetItem::expandingDirections(...) &quot;);
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  setGeometry
- *    flags:    
+/*!
+ * method QWidgetItem
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	QWidget *ws0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	t
  */
-ZEND_METHOD(QWidgetItem, setGeometry){
-		/* o public*/
 
-		/* const QRect&amp; ,  */
+ZEND_METHOD(QWidgetItem, __construct)
+{
+  ///QWidget *ws0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QWidget
+      if (inherits(Z_OBJCE_P(arg_0), 71)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try QWidget *ws0s0,
+        QWidget *
+          cpp_arg_0 = static_cast &lt; QWidget * &gt;(php_qt_fetch(arg_0));
+        QWidgetItem_php_qt *
+          selfpointer = new QWidgetItem_php_qt(getThis(), (QWidget *) cpp_arg_0);
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+        PHP_QT_REGISTER(selfpointer);
+        RETURN_NULL();
+      }
+#endif
 
-
-			if(Z_OBJCE_P(z_0)-&gt;name == &quot;QRect&quot;) {
-				obj-&gt;setGeometry((const QRect&amp;) obj_z_0);
-			RETURN_NULL();
-			}
-			}
-		}
-	}
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidgetItem::QWidgetItem(...) &quot;);
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  QWidgetItem
- *    flags:    t
+/*!
+ * method geometry
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QRect
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, __construct){
-		/* o public*/
 
-		/* qt_QWidget* w,  */
+ZEND_METHOD(QWidgetItem, geometry)
+{
+  ///
+#ifdef PHP_QT_QRect             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) php_qt_fetch(z_0);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'geometry' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidgetItem * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			if(obj_z_0-&gt;inherits(&quot;QWidget&quot;)) {
-				QWidgetItem *QWidgetItem_ptr = new QWidgetItem((QWidget*) obj_z_0);
-				PHP_QT_REGISTER(QWidgetItem_ptr);
-				RETURN_NULL();
-			}
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QRect *
+        return_object = new QRect;
+
+      *return_object = static_cast &lt; QRect &gt; (selfpointer-&gt;geometry());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidgetItem::geometry(...) &quot;);
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  minimumSize
- *    flags:    c
+/*!
+ * method heightForWidth
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	int ints0
+ * 
+ * @access	public
+ * @return	int
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, minimumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj-&gt;minimumSize();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWidgetItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWidgetItem, heightForWidth)
+{
+  ///int ints0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'heightForWidth' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try int ints0,
+      QWidgetItem *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidgetItem * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;heightForWidth((int)Z_LVAL_P(arg_0)));
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidgetItem::heightForWidth(...) &quot;);
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  sizeHint
- *    flags:    c
+/*!
+ * method isEmpty
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	bool
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, sizeHint){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj-&gt;sizeHint();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWidgetItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWidgetItem, isEmpty)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'isEmpty' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidgetItem * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_BOOL(selfpointer-&gt;isEmpty());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidgetItem::isEmpty(...) &quot;);
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  maximumSize
- *    flags:    c
+/*!
+ * method setGeometry
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	const QRect &amp;s0
+ * 
+ * @access	public
+ * @return	void
+ * @flags	
  */
-ZEND_METHOD(QWidgetItem, maximumSize){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-				QSize return_object = (QSize) obj-&gt;maximumSize();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWidgetItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWidgetItem, setGeometry)
+{
+  ///const QRect &amp;s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_OBJECT) {
+#ifdef PHP_QT_QRect
+      if (inherits(Z_OBJCE_P(arg_0), 0)) {
+        if (getThis() == NULL) {
+          php_error(E_ERROR, &quot;method 'setGeometry' is not static&quot;);
+          RETURN_NULL();
+        }
+        /// try const QRect &amp;s0,
+        QWidgetItem *
+          selfpointer;
+
+        if (getThis() != NULL) {
+          selfpointer = static_cast &lt; QWidgetItem * &gt;(PHP_QT_FETCH());
+        }
+        QRect *
+          cpp_arg_0 = static_cast &lt; QRect * &gt;(php_qt_fetch(arg_0));
+
+        RETURN_VOID(selfpointer-&gt;setGeometry((const QRect &amp;)*cpp_arg_0));
+      }
+#endif
+
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWidgetItem::setGeometry(...) &quot;);
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  heightForWidth
- *    flags:    c
+/*!
+ * method minimumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, heightForWidth){
-		/* l public*/
 
-		/* int ,  */
+ZEND_METHOD(QWidgetItem, minimumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-	if (ZEND_NUM_ARGS() == 1){
-		zval *z_0; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'minimumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidgetItem * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
 
-			RETURN_LONG(obj-&gt;heightForWidth((int) Z_LVAL_P(z_0)));
-			}
-		}
-	}
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;minimumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidgetItem::minimumSize(...) &quot;);
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  widget
- *    flags:    v
+/*!
+ * method sizeHint
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, widget){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-				QWidget * return_object = (QWidget *) obj-&gt;widget();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWidgetItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  expandingDirections
- *    flags:    c
- */
-ZEND_METHOD(QWidgetItem, expandingDirections){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-				Qt::Orientations return_object = (Qt::Orientations) obj-&gt;expandingDirections();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWidgetItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+ZEND_METHOD(QWidgetItem, sizeHint)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
+
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'sizeHint' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
+
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidgetItem * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;sizeHint());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidgetItem::sizeHint(...) &quot;);
 }
 
-/*********************************
- *    class     QWidgetItem */
-/*
- *    function  geometry
- *    flags:    c
+/*!
+ * method maximumSize
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	QSize
+ * @flags	c
  */
-ZEND_METHOD(QWidgetItem, geometry){
-	if (ZEND_NUM_ARGS() == 0){
-			QWidgetItem *obj = (QWidgetItem*) PHP_QT_FETCH();
-				QRect return_object = (QRect) obj-&gt;geometry();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWidgetItem_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
-}
 
+ZEND_METHOD(QWidgetItem, maximumSize)
+{
+  ///
+#ifdef PHP_QT_QSize             // return type
 
-PHP_QT_DESTRUCT(QWidgetItem);
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'maximumSize' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWidgetItem *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWidgetItem * &gt;(PHP_QT_FETCH());
+      }
+      zend_class_entry *
+        ce;
+
+      object_init_ex(return_value, QString_ce_ptr);
+      zend_rsrc_list_entry
+        le;
+      QSize *
+        return_object = new QSize;
+
+      *return_object = static_cast &lt; QSize &gt; (selfpointer-&gt;maximumSize());
+      le.ptr = (void *)return_object;
+      php_qt_register(return_value, le);
+      return;
+    }
+  }
+#endif // return type
+
+  php_error(E_ERROR, &quot;could not parse argument in QWidgetItem::maximumSize(...) &quot;);
+}

Modified: trunk/qt/classes/qwindowstatechangeevent.cpp
===================================================================
--- trunk/qt/classes/qwindowstatechangeevent.cpp	2006-06-06 20:42:00 UTC (rev 253)
+++ trunk/qt/classes/qwindowstatechangeevent.cpp	2006-06-06 20:44:55 UTC (rev 254)
@@ -1,9 +1,8 @@
 /*
  * PHP-Qt - The PHP language bindings for Qt
  *
- * Copyright (C) 2005
+ * Copyright (C) 2006
  * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,36 +19,98 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * QWindowStateChangeEvent.cpp - QWindowStateChangeEvent PHP implementation.
- * begin           : Sun Jan 22 19:46:39 2006
+ * begin           : Tue Jun  6 22:42:56 2006
  * generated by    : moni using kalyptus 0.9.
  */
 
 #include &lt;iostream&gt;
 using namespace std;
 
-#include &lt;QWindowStateChangeEvent&gt;
 #include &quot;../php_qt.h&quot;
 
 
-/*********************************
- *    class     QWindowStateChangeEvent */
-/*
- *    function  oldState
- *    flags:    c
+#include &lt;QWindowStateChangeEvent&gt;
+/// DEBUG:destructor skipped.
+#include &lt;QMetaMethod&gt;
+class QWindowStateChangeEvent_php_qt:public QWindowStateChangeEvent
+{
+
+public:
+  QWindowStateChangeEvent_php_qt(zval * zend_ptr, Qt::WindowStates aOldStates0);
+
+
+  zval *zend_ptr;
+};
+
+QWindowStateChangeEvent_php_qt::QWindowStateChangeEvent_php_qt(zval * zend_ptr, Qt::WindowStates aOldStates0):QWindowStateChangeEvent(aOldStates0)
+{
+  this-&gt;zend_ptr = zend_ptr;
+}
+
+/*!
+ * method QWindowStateChangeEvent
+ * 
+ * @param: -
+ * 
+ * overloaded args:
+ * @param	Qt::WindowStates aOldStates0s0
+ * 
+ * @access	public
+ * @return	
+ * @flags	
  */
-ZEND_METHOD(QWindowStateChangeEvent, oldState){
-	if (ZEND_NUM_ARGS() == 0){
-			QWindowStateChangeEvent *obj = (QWindowStateChangeEvent*) PHP_QT_FETCH();
-				Qt::WindowStates return_object = (Qt::WindowStates) obj-&gt;oldState();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, QWindowStateChangeEvent_ce_ptr);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &amp;return_object;                                       
-				php_qt_register(return_value,le);                   
-				return;                                             
-	}
+
+ZEND_METHOD(QWindowStateChangeEvent, __construct)
+{
+  ///Qt::WindowStates aOldStates0s0
+  if (ZEND_NUM_ARGS() == 1) {
+    PHP_QT_FETCH_1_ARGS();
+    if (1 &amp;&amp; Z_TYPE_P(arg_0) == IS_LONG) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method '__construct' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try Qt::WindowStates aOldStates0s0,
+      QWindowStateChangeEvent_php_qt *
+        selfpointer = new QWindowStateChangeEvent_php_qt(getThis(), (Qt::WindowStates) Z_LVAL_P(arg_0));
+
+      PHP_QT_REGISTER(selfpointer);
+      RETURN_NULL();
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWindowStateChangeEvent::QWindowStateChangeEvent(...) &quot;);
 }
 
+/*!
+ * method oldState
+ * 
+ * @param: -
+ * @param: -
+ * 
+ * @access	public
+ * @return	Qt::WindowStates
+ * @flags	c
+ */
 
-PHP_QT_DESTRUCT(QWindowStateChangeEvent);
+ZEND_METHOD(QWindowStateChangeEvent, oldState)
+{
+  ///
+  if (ZEND_NUM_ARGS() == 0) {
+    PHP_QT_FETCH_0_ARGS();
+    if (1) {
+      if (getThis() == NULL) {
+        php_error(E_ERROR, &quot;method 'oldState' is not static&quot;);
+        RETURN_NULL();
+      }
+      /// try 
+      QWindowStateChangeEvent *
+        selfpointer;
 
+      if (getThis() != NULL) {
+        selfpointer = static_cast &lt; QWindowStateChangeEvent * &gt;(PHP_QT_FETCH());
+      }
+      RETURN_LONG(selfpointer-&gt;oldState());
+    }
+  }
+  php_error(E_ERROR, &quot;could not parse argument in QWindowStateChangeEvent::oldState(...) &quot;);
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000097.html">[Php-qt-svn] r253 - trunk/qt/text_related
</A></li>
	<LI>Next message: <A HREF="000098.html">[Php-qt-svn] r255 - in trunk: tests tutorials/calculator tutorials/t1 tutorials/t2 tutorials/t3 tutorials/t4 tutorials/t5 tutorials/t6 tutorials/t7
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#99">[ date ]</a>
              <a href="thread.html#99">[ thread ]</a>
              <a href="subject.html#99">[ subject ]</a>
              <a href="author.html#99">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/php-qt-svn">More information about the Php-qt-svn
mailing list</a><br>
</body></html>
