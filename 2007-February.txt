From tm243 at mail.berlios.de  Mon Feb 19 22:35:06 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Mon, 19 Feb 2007 22:35:06 +0100
Subject: [Php-qt-svn] r290 - in trunk: . kalyptus php_qt smoke smoke/kde
	smoke/qt
Message-ID: <200702192135.l1JLZ6h6027914@sheep.berlios.de>

Author: tm243
Date: 2007-02-19 22:34:59 +0100 (Mon, 19 Feb 2007)
New Revision: 290

Added:
   trunk/CMakeLists.txt
   trunk/php_qt/
   trunk/php_qt/qstring.cpp
   trunk/smoke/CMakeLists.txt
   trunk/smoke/kde/CMakeLists.txt
   trunk/smoke/kde/generate.pl.cmake
   trunk/smoke/kde/qtguess.pl.cmake
   trunk/smoke/qt/CMakeLists.txt
   trunk/smoke/qt/generate.pl.cmake
   trunk/smoke/qt/qscintilla2_header_list
   trunk/smoke/qt/qtguess.pl.cmake
Removed:
   trunk/include/
   trunk/kalyptus/kalyptus.spec.in
   trunk/modules/
   trunk/qt/
   trunk/smoke/qwidgetitemdata_p.h
   trunk/tools/
Modified:
   trunk/ChangeLog
   trunk/README
   trunk/config.m4
   trunk/kalyptus/kalyptus
   trunk/kalyptus/kalyptusCxxToSmoke.pm
   trunk/kalyptus/kalyptusDataDict.pm
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/smokephp.cpp
   trunk/smoke/kde/header_list
   trunk/smoke/kde/kde_header_list
   trunk/smoke/qt/header_list
   trunk/smoke/qt/qt_smoke.h
   trunk/smoke/qt/qtdbus_header_list
   trunk/smoke/qt/qtguess.pl.in
   trunk/smoke/qt/qwt_header_list
   trunk/smoke/qt/smokeqt.pro
Log:
added cmake build system, added QString, updated smoke and kalyptus.

Added: trunk/CMakeLists.txt
===================================================================
--- trunk/CMakeLists.txt	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/CMakeLists.txt	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,22 @@
+
+PROJECT(PHP-Qt)
+
+set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/modules)
+set(kdebindings_SOURCE_DIR ${PHP-Qt_SOURCE_DIR})
+
+
+
+find_package(Perl REQUIRED)	# for kalyptus
+find_package(Qt4 REQUIRED)	# for kalyptus
+
+include(FindPHP5)
+
+IF(NOT PHP5_FOUND)
+    MESSAGE(FATAL_ERROR "PHP5 could not be found!")
+ENDIF(NOT PHP5_FOUND)
+
+add_subdirectory(smoke)
+add_subdirectory(php_qt)
+
+
+

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/ChangeLog	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,3 +1,9 @@
+2007-002-19  Thomas Moenicke <thomas.moenicke at kdemail.net>
+
+		* new cmake build system added
+		* implemented QString since it is not in Smoke
+		* Updated copies of smoke and kalyptus
+
 2006-011-18  Thomas Moenicke <thomas.moenicke at kdemail.net>
 
 		* method argument handling: support for arrays, references

Modified: trunk/README
===================================================================
--- trunk/README	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/README	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,5 +1,6 @@
 PHP-Qt - an extension for PHP5 that aims to write software with the Qt Toolkit.
-===============================================================================
+================================================================================
+
 PHP-Qt is an extension for PHP5 that aims to write software with the Qt Toolkit. 
 It provides an object-oriented interface to the Qt4 Framework and allowes 
 to write Qt applications in the PHP language.
@@ -7,42 +8,43 @@
 Requirements
 ============
 
-PHP-Qt requires PHP 5.1RC1 or greater and Qt4 header files.
+PHP-Qt requires PHP 5.1 or greater, the Qt4 header files and CMake.
 
 PHP5: You should have a the header files and the development scripts.
 Qt4: You should have the header files.
 
-Note: at this time it is only possible to compile it in a unix environment.
+Note: at this time compilation is only tested in a Unix environment.
 
 Compiling and installation
 ==========================
 
-You have a php-5.1.xxx build directory where you have compiled php. You also 
-have a copy of php_qt. After downloading or checking out from SVN copy the 
-unpacked php_qt directory into the php-5.1xxx/ext/ directory.
+short:
 
-We prefer to build PHP-Qt as module! In this example php is 
-installed in /usr/local/php511
+cmake /path/to/php_qt
+make
+make install
 
-At first it is neccessary to check your environment for compiling. 
-To do that change into the php-5.1xxx/ext/php_qt directory and run phpize, kdeize
-and configure:
+more detailed:
 
-/usr/local/php511/bin/phpize
+You have cmake installed and the path to your PHP5 header files. After 
+downloading or checking out from SVN the easiest way is to create a build 
+directory in your copy of PHP-Qt. The extension will be built out-of-source 
+which allows you to have a clean copy of PHP-Qt without any files of the build 
+system.
 
-./kdeize
+PHP-Qt will be compiled as module! 
 
-./configure \
-  --enable-php_qt \
-  --with-qt-includes=/usr/lib/qt4/include \
-  --with-qt-libraries=/usr/lib/qt4 \
-  --with-php-config=/usr/local/php511/bin/php-config \
+At first it is neccessary to create your build environment for compiling.
+To do that just change into the 'php_qt/build' directory and run cmake:
 
-If --with-qt-includes and --with-qt-config are omitted, configure will try to find files in default or standard pathes
+cmake ..
 
-To remove old objectfiles run 
+You can give arguments to cmake via the -D option:
+  -DQT_INCLUDE_DIR=/usr/lib/qt4/include \
+  -DQT_LIBRARY_DIR=/usr/lib/qt4
 
-make clean
+If no argument is given cmake will try to find the Qt4 and PHP5 files in the default or standard 
+pathes as /usr/include, /usr/local/include etc.
 
 Finally, run 
 
@@ -52,12 +54,16 @@
 
 make install
 
-to copy 'php_qt.so' into php's extension directory. If it fails please check 
-all related pathes on your system at first.
+to copy 'php_qt.so' into php's extension directory. If it fails please check if you have 
+permissions and all related pathes on your system are correct.
 
+To remove old objectfiles run 
+
+make clean
+
 To test it, simply run one of the test scripts in the php_qt/test/ subdirectory.
+To get a clean build system just remove all files in the build/ directory.
 
-
 Mailing lists
 =============
 
@@ -83,6 +89,6 @@
 
 The website for the project:
 
-    http://php-qt.berlios.de
+    http://www.php-qt.org
 
 

Modified: trunk/config.m4
===================================================================
--- trunk/config.m4	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/config.m4	2007-02-19 21:34:59 UTC (rev 290)
@@ -144,7 +144,7 @@
     x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp \
     smokedata.cpp,,shared_objects_php_qt,yes)
 
-  PHP_NEW_EXTENSION(php_qt, qt/smokephp.cpp qt/php_qt.cpp qt/functions.cpp,$ext_shared,cli)
-  PHP_ADD_BUILD_DIR($ext_builddir/qt)
+  PHP_NEW_EXTENSION(php_qt, php_qt/smokephp.cpp php_qt/php_qt.cpp php_qt/functions.cpp,$ext_shared,cli)
+  PHP_ADD_BUILD_DIR($ext_builddir/php_qt)
 
 fi

Modified: trunk/kalyptus/kalyptus
===================================================================
--- trunk/kalyptus/kalyptus	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/kalyptus/kalyptus	2007-02-19 21:34:59 UTC (rev 290)
@@ -2,7 +2,7 @@
 
 # KDOC -- C++ and CORBA IDL interface documentation tool.
 # Sirtaj Singh Kang <taj at kde.org>, Jan 1999.
-# $Id: kalyptus 596521 2006-10-17 19:47:11Z rdale $
+# $Id: kalyptus 630755 2007-02-06 09:42:26Z rdale $
 
 # All files in this project are distributed under the GNU General
 # Public License. This is Free Software.
@@ -22,7 +22,7 @@
 
 use vars qw/ %rootNodes $declNodeType @includes_list %options @formats_wanted $allow_k_dcop_accessors
         @includeclasses $includeclasses $skipInternal %defines $defines $match_qt_defines
-	$libdir $libname $outputdir @libs $parse_global_space $qt_embedded $qt4 $striphpath $doPrivate $readstdin
+	$libdir $libname $outputdir @libs $parse_global_space $qt_embedded $qt4 $properties $striphpath $doPrivate $readstdin
 	$Version $quiet $debug $debuggen $parseonly $currentfile $cSourceNode $exe
 	%formats %flagnames @allowed_k_dcop_accesors $allowed_k_dcop_accesors_re $rootNode 
 	@classStack $cNode $globalSpaceClassName
@@ -157,6 +157,7 @@
 	"globspace",	\$parse_global_space,
 	"qte",	\$qt_embedded,
 	"qt4",	\$qt4,
+	"properties",	\$properties,
 	"allow_k_dcop_accessors", \$allow_k_dcop_accessors,
 
 	"cpp|P",	\$cpp,
@@ -470,10 +471,13 @@
 		$p =~ s/Q_EXPORT_CODECS_BIG5//;
 		$p =~ s/Q_DECL_DEPRECATED//;
 		$p =~ s/Q_SCRIPTABLE//;
+		$p =~ s/QT_STATIC_CONST_IMPL/const/;
+		$p =~ s/QT_STATIC_CONST/static const/;
 		$p =~ s/QT_COMPAT / /;
 		$p =~ s/Q_DISABLE_COPY\((\w+)\)/$1(const $1 &);\n$1 &operator=(const $1 &);/;
 		$p =~ s/QWIDGETSIZE_MAX/32767/; # Qt/E uses this #define as an enum value - yuck!
 		$p =~ s/Q_SIGNALS/signals/;
+		$p =~ s/Q_SLOTS/slots/;
 		$p =~ s/ASYNC/void/;
 		$p =~ s/[A-Z_0-9]*_EXPORT_DEPRECATED//;
 		$p =~ s/[A-Z_0-9]*_EXPORT\s/ /;
@@ -512,7 +516,6 @@
 		next if ( $p =~ /^\s*Q_ENUMS/           # ignore Q_ENUMS
                         || $p =~ /^\s*Q_FLAGS/       # and Q_FLAGS
                         || $p =~ /^\s*Q_DECLARE_FLAGS/       # and Q_DECLARE_FLAGS
-                        || ( !$qt4 && $p =~ /^\s*Q_PROPERTY/ )      # and Q_PROPERTY
                         || $p =~ /^\s*QDOC_PROPERTY/
                         || $p =~ /^\s*Q_GADGET/
                         || $p =~ /^\s*Q_OVERRIDE/       # and Q_OVERRIDE
@@ -712,8 +715,10 @@
 	elsif ( $l =~ /Q_PROPERTY/ ) {	# property
 		do {
 			$decl .= $l;
-	
-			if ( $l =~ /[)]/ ) {
+			my $lparens = kdocUtil::countReg( $decl, '\(' );
+			my $rparens = kdocUtil::countReg( $decl, '\)' );
+
+			if ( $lparens == $rparens ) {
 				$decl =~ s/\n/ /gs;
 				return $decl;
 			}
@@ -803,8 +808,8 @@
     # properties
     elsif ( $decl =~ s/Q_PROPERTY// ) {
 		print "Property: <$1>\n" if $debug;
-
-		$newNode = newProperty( $decl );
+		
+		$newNode = newProperty( $decl ) if $properties;
 	}
 	# Typedef struct/class
 	elsif ( $decl =~ /^\s*typedef
@@ -1773,10 +1778,12 @@
     my @items = split(/ /,$property);
 
     do {
-	    my ( $node ) = Ast::New( $items[1] );
+	    my ( $node ) = Ast::New( "Q_PROPERTY_" . $items[1] );
 
 	    $node->AddProp( "NodeType", "property" );
-        $node->AddProp( "type", $items[0] );
+        my $type = $items[0];
+        $type =~ s/\(//g;
+        $node->AddProp( "Type", $type );
         $node->AddProp( "READ", $items[3] );
         $node->AddProp( "WRITE", $items[5] );
         $node->AddProp( "NOTIFY", $items[7] );

Deleted: trunk/kalyptus/kalyptus.spec.in
===================================================================
--- trunk/kalyptus/kalyptus.spec.in	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/kalyptus/kalyptus.spec.in	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,62 +0,0 @@
-# You might want to change the next 2 lines, the rest should be ok
-%define qtdir /usr/lib/qt-3.0.0
-Prefix: /opt/kde3
-
-Name: kalyptus
-Icon: kde-icon.xpm
-Summary: Bindings generation tools for the K Desktop Environment (KDE) 3.0.
-Version: @VERSION@
-Release: 1
-Epoch: 1
-#Source: ftp://ftp.kde.org/pub/kde/stable/%{version}/distribution/tar/generic/source/kdoc-%{version}.tar.bz2
-Group: Bindings
-BuildRoot: /var/tmp/%{name}-buildroot
-Copyright: GPL
-BuildArch: noarch
-
-%description
-Bindings generation tools for the K Desktop Environment 3.0.
-
-%prep
-rm -rf $RPM_BUILD_ROOT
-
-%setup -q -n %{name}
-make -f Makefile.cvs
-
-%build
-export KDEDIR=%{prefix} QTDIR=%{qtdir}
-CXXFLAGS="$RPM_OPT_FLAGS -I%{prefix}/include/kde" ./configure \
-	--prefix=%{prefix}
-make CXXFLAGS="$RPM_OPT_FLAGS -DNO_DEBUG -DNDEBUG"
-
-%install
-make install DESTDIR=$RPM_BUILD_ROOT
-
-cd $RPM_BUILD_ROOT
-find . -type d | sed '1,3d;s,^\.,\%attr(-\,root\,root) \%dir ,' > \
-	$RPM_BUILD_DIR/file.list.%{name}
-perl -pi -e "s|\%attr\(-,root,root\) \%dir %{prefix}/man/man1||" $RPM_BUILD_DIR/file.list.%{name}
-perl -pi -e "s|\%attr\(-,root,root\) \%dir %{prefix}/man||" $RPM_BUILD_DIR/file.list.%{name}
-perl -pi -e "s|\%attr\(-,root,root\) \%dir %{prefix}/bin||" $RPM_BUILD_DIR/file.list.%{name}
-perl -pi -e "s|\%attr\(-,root,root\) \%dir %{prefix}/lib$||" $RPM_BUILD_DIR/file.list.%{name}
-
-find . -type f | sed -e 's,^\.,\%attr(-\,root\,root) ,' \
-	-e '/\/config\//s|^|%config|' >> \
-	$RPM_BUILD_DIR/file.list.%{name}
-
-find . -type l | sed 's,^\.,\%attr(-\,root\,root) ,' >> \
-	$RPM_BUILD_DIR/file.list.%{name}
-
-sed -e "s,%{prefix}/man/.*,&*,g" $RPM_BUILD_DIR/file.list.%{name} >$RPM_BUILD_DIR/file.list.%{name}.new
-mv -f $RPM_BUILD_DIR/file.list.%{name}.new $RPM_BUILD_DIR/file.list.%{name}
-
-echo "%docdir %{prefix}/doc/kde" >> $RPM_BUILD_DIR/file.list.%{name}
-
-%clean
-rm -rf $RPM_BUILD_ROOT $RPM_BUILD_DIR/file.list.%{name}
-
-%files -f ../file.list.%{name}
-
-%changelog
-* Thu May 11 2000 Bernhard Rosenkraenzer <bero at redhat.com>
-- initial

Modified: trunk/kalyptus/kalyptusCxxToSmoke.pm
===================================================================
--- trunk/kalyptus/kalyptusCxxToSmoke.pm	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/kalyptus/kalyptusCxxToSmoke.pm	2007-02-19 21:34:59 UTC (rev 290)
@@ -78,6 +78,7 @@
      'quint64' => '$',
      'qint64' => '$',
      'long long' => '$',
+     'qlonglong' => '$',
      'qulonglong' => '$',
      'WId' => '$',
      'Q_PID' => '$',
@@ -257,7 +258,7 @@
    'ViewItemFeatures' => 'int',
 );
 
-$headerSubdirectories = "kio/|dnssd/|solid/|solid/ifaces/|phonon/|sonnet/|kdevelop/|kinterfacedesigner/|kontact/|kate/|kparts/|dom/|kabc/|ksettings/|kjs/|ktexteditor/|kdeprint/|kdesu/|knewstuff|dbus-1.0/dbus/"
+$headerSubdirectories = "kio/|phonon/ui/|kmediaplayer/|dnssd/|solid/|solid/ifaces/|phonon/|sonnet/|kdevelop/|kinterfacedesigner/|kontact/|kate/|kparts/|dom/|kabc/|ksettings/|kjs/|ktexteditor/|kdeprint/|kdesu/|knewstuff/|dbus-1.0/dbus/"
 
 }
 
@@ -339,7 +340,7 @@
 	    $classNode->{Access} eq "protected" || # e.g. QPixmap::QPixmapData
 	    exists $classNode->{Tmpl} ||
 	    # Don't generate standard bindings for QString, this class is handled as a native type
-#	    $className eq 'QString' ||
+	    $className eq 'QString' ||
 	    $className eq 'QStringData' ||
 	    $className eq 'QLatin1String' ||
 	    $className eq 'QTLWExtra' ||
@@ -383,14 +384,18 @@
 	    ($className eq 'QSysInfo' and $main::qt4) ||
 	    ($className eq 'QPNGImageWriter' and $main::qt4) ||
 	    ($className eq 'QPNGImagePacker' and $main::qt4) ||
+	    ($className eq 'QSqlRelationalDelegate' and $main::qt4) ||
 	    ($className eq 'QTextCodec::ConverterState' and $main::qt4) ||
 	    ($className eq 'QTextLayout::Selection' and $main::qt4) ||
 	    ($className eq 'QTextStreamManipulator' and $main::qt4) ||
 	    $className eq 'DCOPArg' ||
 	    $className eq 'DCOPReply' ||
 	    $className eq 'KBookmarkMenu::DynMenuInfo' ||
+	    $className eq 'KDateTime::Spec' ||
+	    $className eq 'KEncodingFileDialog::Result' ||
 	    $className eq 'KDE' ||
 	    $className eq 'KDEDesktopMimeType::Service' ||
+	    $className eq 'KDialogButtonBox' ||
 	    $className eq 'KEntry' ||
 	    $className eq 'KEntryKey' ||
 	    $className eq 'KGlobalSettings::KMouseSettings' ||
@@ -398,12 +403,15 @@
 	    $className eq 'KNotifyClient::Instance' ||
 	    $className eq 'KParts::ComponentFactory' ||
 	    $className eq 'KParts::Plugin::PluginInfo' ||
+	    $className eq 'KParts::MainWindow' ||
 	    $className eq 'KProtocolInfo::ExtraField' ||
 	    $className eq 'KXMLGUIClient::StateChange' ||
 	    $className eq 'KIconTheme' ||
 	    $className eq 'KEditListBox::CustomEditor' ||
 		$className eq 'KIO::KBookmarkMenuNSImporter' ||
+		$className eq 'KIO::NetRC' ||
 	    $className eq 'KExtendedSocket' ||
+	    $className eq 'KSettings::PluginPage' ||
 	    $className eq 'KSocket' ||
 	    $className eq 'KPerDomainSettings' ||
 	    $className eq 'KApplicationPropsPlugin' ||
@@ -417,6 +425,7 @@
 	    $className eq 'KDEDModule' ||
 	    $className eq 'KFileMetaInfoProvider' ||
 	    $className eq 'KFileMimeTypeInfo' ||
+	    $className eq 'KMimeTypeChooserDialog' ||
 	    $className eq 'KExecPropsPlugin' ||
 	    $className eq 'KFilePermissionsPropsPlugin' ||
 	    $className eq 'KImageFilePreview' ||
@@ -427,11 +436,14 @@
 	    $className eq 'KSharedPixmap' ||
 	    $className eq 'KLibrary' ||
 	    $className eq 'KScanDialogFactory' ||
+	    $className eq 'KTimeZone::Transition' ||
+	    $className eq 'KTipDatabase' ||
 	    $className eq 'KBufferedIO' ||
 	    $className eq 'KDictSpellingHighlighter' ||
 		$className eq 'KPropertiesDialog' ||
 	    $className eq 'ProgressItem' ||
 	    $className eq 'KIO::ChmodInfo' ||
+	    $className eq 'KUrl::List' ||
 	    $className eq 'khtml::DrawContentsEvent' || # the khtml:: classes build, but don't link
 	    $className eq 'khtml::MouseDoubleClickEvent' ||
 	    $className eq 'khtml::MouseMoveEvent' ||
@@ -489,7 +501,11 @@
 	    $className =~ /.*Impl$/ ||
 	    $className =~ /.*Internal.*/ ||
 	    $classNode->{Deprecated} ||
-	    $classNode->{NodeType} eq 'union'  # Skip unions for now, e.g. QPDevCmdParam
+	    $classNode->{NodeType} eq 'union' || # Skip unions for now, e.g. QPDevCmdParam
+	    $className eq 'KImportedBookmarkMenu' || # KDE4
+	    $className eq 'KUndoRedoAction' || # KDE4
+	    $className eq 'KTzfileTimeZoneData' || # KDE4
+	    $className eq 'KUndoRedoAction' # KDE4
 	  ) {
 	    print STDERR "Skipping $className\n" if ($debug);
 	    print STDERR "Skipping union $className\n" if ( $classNode->{NodeType} eq 'union');
@@ -573,10 +589,24 @@
 
 	    # All we want from private methods is to check for virtuals, nothing else
 	    next if ( $m->{Access} =~ /private/ );
-		
 		# Don't generate code for deprecated methods, 
 		# or where the code won't compile/link for obscure reasons. Or even obvious reasons..
 		if ( ($classNode->{astNodeName} eq 'KCharSelectTable' and $name eq 'paintCell')
+			# KDE4
+			|| ($name eq 'operator<<' and $m->{ParamList}[0]->{ArgType} =~ /QDataStream/ and $m->{ParamList}[1]->{ArgType} =~ /KDateTime::Spec/ )
+			|| ($name eq 'operator>>' and $m->{ParamList}[0]->{ArgType} =~ /QDataStream/ and $m->{ParamList}[1]->{ArgType} =~ /KDateTime::Spec/ )
+                        || ($name eq 'operator<<' and $m->{ParamList}[0]->{ArgType} =~ /QDataStream/ and $m->{ParamList}[1]->{ArgType} =~ /const KDateTime/ )
+                        || ($name eq 'operator>>' and $m->{ParamList}[0]->{ArgType} =~ /QDataStream/ and $m->{ParamList}[1]->{ArgType} =~ /KDateTime/ )
+			|| ($classNode->{astNodeName} eq 'TextEvent' and $name eq 'data')
+			|| ($classNode->{astNodeName} eq 'KApplication' and $name eq 'startKdeinit')
+			|| ($classNode->{astNodeName} eq 'Slave' and $name eq 'Slave')
+			|| ($classNode->{astNodeName} eq 'KIcon' and $name eq 'setOverlays')
+			|| ($classNode->{astNodeName} eq 'KResolver' and $name eq 'setError')
+			|| ($classNode->{astNodeName} eq 'Entry' and $name eq 'setCompatibility')
+			|| ($classNode->{astNodeName} eq 'KTimeZone' and $name eq 'source')
+			|| ($classNode->{astNodeName} eq 'KTzfileTimeZoneSource' and $name eq 'location')
+			|| ($classNode->{astNodeName} eq 'Wallet' and $name eq 'Wallet')
+			# end KDE4
 			|| ($classNode->{astNodeName} eq 'KAnimWidget' and $name eq 'KAnimWidget' and @{$m->{ParamList}} == 2)
 			|| ($classNode->{astNodeName} eq 'KCModuleLoader' and $name eq 'errorModule')
 			|| ($classNode->{astNodeName} eq 'KDCOPActionProxy' and $name eq 'actions')
@@ -595,13 +625,19 @@
 			|| ($classNode->{astNodeName} eq 'SlaveBase' and $name eq 'cacheAuthentication')
 			|| ($classNode->{astNodeName} eq 'KInputDialog' and $name eq 'getDouble')
 			|| ($classNode->{astNodeName} eq 'KToolBar' and $name eq 'enable')
+			|| ($classNode->{astNodeName} eq 'KToolBar' and $name eq 'changeEvent')
 			|| ($classNode->{astNodeName} eq 'KAccel' and $name eq 'insert' and @{$m->{ParamList}} == 2)
 			|| ($classNode->{astNodeName} eq 'KAccel' and $name eq 'autoupdate')
 			|| ($classNode->{astNodeName} eq 'KAccel' and $name eq 'getAutoUpdate')
+			|| ($classNode->{astNodeName} eq 'KAction' and $name eq 'activated')
+			|| ($classNode->{astNodeName} eq 'KAction' and $name eq 'actionOfType')
+			|| ($classNode->{astNodeName} eq 'KAction' and $name eq 'actionsOfType')
+			|| ($classNode->{astNodeName} eq 'KActionCollection' and $name eq 'add')
 			|| ($classNode->{astNodeName} eq 'KStdAccel' and $name eq 'insert')
 			|| ($classNode->{astNodeName} eq 'KBookmarkMenu' and $name eq 'invalid')
 			|| ($classNode->{astNodeName} eq 'KCharsets' and $name eq 'languages')
 			|| ($classNode->{astNodeName} eq 'KCombiView' and $name eq 'setDropOptions')
+			|| ($classNode->{astNodeName} eq 'KDialogButtonBox' and $name eq 'using')
 			|| ($classNode->{astNodeName} eq 'KFileMetaInfoItem' and $name eq 'unit')
 			|| ($classNode->{astNodeName} eq 'KInstance' and $name eq 'charsets')
 			|| ($classNode->{astNodeName} eq 'KInstance' and $name eq 'KInstance' and $m->{Access} =~ /protected/)
@@ -628,10 +664,12 @@
 			|| ($classNode->{astNodeName} eq 'KIO' and $name eq 'pasteData')
 			|| ($classNode->{astNodeName} eq 'KIO' and $name eq 'pasteDataAsync')
 			|| ($classNode->{astNodeName} eq 'KIO' and $name eq 'isClipboardEmpty')
+			|| ($classNode->{astNodeName} eq 'KIO::NetRC' and $name eq 'lookup')
 			|| ($classNode->{astNodeName} eq 'DCOPRef' and $name eq 'callExt')
 			|| ($classNode->{astNodeName} eq 'DCOPRef' and $name eq 'call')
 			|| ($classNode->{astNodeName} eq 'DCOPRef' and $name eq 'send')
 			|| ($classNode->{astNodeName} eq 'DOM' and $name eq 'operator<<') # Avoid kdbgstream debugging method
+			|| ($name eq 'initgroups')
 			|| ($name eq 'qInitJpegIO' and $main::qt4)
 			|| ($name eq 'qInitPngIO' and $main::qt4)
 			|| ($name eq 'qt_metacast' and $main::qt4)
@@ -716,6 +754,9 @@
 				|| ($classNode->{astNodeName} eq 'QUrl' and $name eq 'QUrl'
 					and $#{$m->{ParamList}} == 0 && $m->{ParamList}[0]->{ArgType} eq 'QUrlPrivate&')
 				|| ($classNode->{astNodeName} eq 'QGlobalSpace' and $name eq 'operator<<' and $m->{ParamList}[0]->{ArgType} =~ /QDebug/)
+				|| ($classNode->{astNodeName} eq 'QGlobalSpace' and $name eq 'qDebug')
+				|| ($classNode->{astNodeName} eq 'QGlobalSpace' and $name eq 'qWarning')
+				|| ($classNode->{astNodeName} eq 'QGlobalSpace' and $name eq 'qCritical')
 				|| ($classNode->{astNodeName} eq 'QGlobalSpace' and $#{$m->{ParamList}} > 0 and $name =~ /operator/ and $m->{ParamList}[1]->{ArgType} =~ /QVariant::Type/)
 				|| ($#{$m->{ParamList}} > 0 and $m->{ParamList}[0]->{ArgType} =~ /Private/)
 				|| ($classNode->{astNodeName} eq 'QScrollArea' and $name eq 'alignment')
@@ -726,7 +767,10 @@
 				|| ($classNode->{astNodeName} eq 'QDBusBusService' and $name eq 'requestName')
 				|| ($classNode->{astNodeName} eq 'QGLFormat' and $name eq 'openGLVersionFlags')
 				|| ($classNode->{astNodeName} eq 'QAbstractUndoItem' and $name eq '~QAbstractUndoItem')
+				|| ($classNode->{astNodeName} eq 'QApplication' and $name eq 'setKeypadNavigationEnabled')
+				|| ($classNode->{astNodeName} eq 'QApplication' and $name eq 'keypadNavigationEnabled')
 				|| ($name eq 'qDBusMetaTypeId')
+				|| ($m->{ReturnType} =~ /template/)
 				|| ($m->{ReturnType} =~ /QT3_SUPPORT/) ) )
 
 			|| $m->{Deprecated} ) {
@@ -752,6 +796,24 @@
 				$kledAmbiguousConstructor = $m;
 			}
 		}
+
+		# cut the last arguments in size(), boundingRect(), both methods was ambiguous
+		if ($classNode->{astNodeName} eq 'QFontMetrics' and $name eq 'boundingRect' && $#{$m->{ParamList}} == 7) {
+			if ($m->{ParamList}[7]->{ArgType} =~ /int/ && defined $m->{ParamList}[7]->{DefaultValue}) {
+			    pop(@{$m->{ParamList}});
+			    $#{$m->{ParamList}}--;
+			    $m->{Params} =~ s/int \*tabarray\=0//;
+			}
+		}
+
+		if ($classNode->{astNodeName} eq 'QFontMetrics' and $name eq 'size' && $#{$m->{ParamList}} == 3) {
+			if ($m->{ParamList}[3]->{ArgType} =~ /int/ && defined $m->{ParamList}[3]->{DefaultValue}) {
+			    pop(@{$m->{ParamList}});
+			    $#{$m->{ParamList}}--;
+			    $m->{Params} =~ s/int \*tabarray\=0//;
+			}
+		}
+
 		
 	    my $argId = 0;
 	    my $firstDefaultParam;
@@ -1302,7 +1364,13 @@
 		$sig = $class_name . "::" . $signature;
 		$idx = $allMethods{$sig};
 	}
-    die "generateVirtualMethod: $className: No method found for $sig\n" if !defined $idx;
+#    die "generateVirtualMethod: $className: No method found for $sig\n" if !defined $idx;
+
+if ( !defined $idx ) {
+    print "generateVirtualMethod: $className: No method found for $sig\n";
+    return ('', '');
+}
+
     if($flags =~ "p") { # pure virtual
 	$methodCode .= "\t${libname}_Smoke->binding->callMethod($idx, (void*)$this, x, true /*pure virtual*/);\n";
     } else {

Modified: trunk/kalyptus/kalyptusDataDict.pm
===================================================================
--- trunk/kalyptus/kalyptusDataDict.pm	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/kalyptus/kalyptusDataDict.pm	2007-02-19 21:34:59 UTC (rev 290)
@@ -51,6 +51,7 @@
 'DCOPObject' => 'DCOPObjectInterface',
 'KDevCore' => 'KDevCoreInterface',
 'QSqlQuery' => 'QSqlQueryInterface',
+'QGraphicsItem' => 'QGraphicsItemInterface',
 
 );
 
@@ -2366,7 +2367,6 @@
 'Section&'  =>  'kde_Section*' ,
 'Section*&'  =>  'kde_Section*' ,
 'Section*'  =>  'kde_Section*' ,
-'SegmentStyle' => 'int',
 'SelectionInterface*' => 'kde_SelectionInterface*',
 'Separator' => 'int',
 'Server&'  =>  'Server*' ,

Copied: trunk/php_qt (from rev 289, trunk/qt)

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/qt/php_qt.cpp	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/php_qt/php_qt.cpp	2007-02-19 21:34:59 UTC (rev 290)
@@ -25,6 +25,7 @@
 
 //#define DEBUG=0
 
+#include <QtCore/qglobal.h>
 #include <zend_interfaces.h>
 #include "php_qt.h"
 
@@ -93,7 +94,7 @@
 Smoke::Index qstring;
 Smoke::Index qobject;
 zend_class_entry* qobject_ce;
-zend_class_entry* qstring_ce;
+extern zend_class_entry* qstring_ce;
 
 /**
  *	proxy handler
@@ -322,7 +323,7 @@
 	// object list
 	le_php_qt_hashtype = zend_register_list_destructors_ex(phpqt_destroy_hashtable, NULL, "PHP-Qt object list", module_number);
 	// FIXME: 50 is fix
-	zend_hash_init_ex(&php_qt_objptr_hash, 50, NULL, NULL, 1, 0);
+	zend_hash_init_ex(&php_qt_objptr_hash, PHPQT_CLASS_COUNT, NULL, NULL, 1, 0);
 
 	// overwrite method handler
 	php_qt_handler = *zend_get_std_object_handlers();
@@ -335,7 +336,7 @@
 	smokephp_findConnect();
 
 	Smoke::Index qobject = smokephp_getClassId("QObject");
-	Smoke::Index qstring = smokephp_getClassId("QString");
+//	Smoke::Index qstring = smokephp_getClassId("QString");
 
     php_qt_static_methods = (zend_function_entry***) safe_emalloc((qt_Smoke->numClasses), sizeof(zend_function_entry **), 0);
 
@@ -435,7 +436,7 @@
 			zend_declare_class_constant_long(ce_ptr, "Bold", strlen("Bold"), QFont::Bold);
 		} 
 		
-	}
+	} // end for
 
     for(Smoke::Index i = 1; i <= qt_Smoke->numClasses; i++){
 		zend_class_entry *ce = zend_fetch_class((char*) qt_Smoke->classes[i].className, strlen(qt_Smoke->classes[i].className), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/qt/php_qt.h	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/php_qt/php_qt.h	2007-02-19 21:34:59 UTC (rev 290)
@@ -23,25 +23,28 @@
 #define debug
 #define MONITOR
 
+#define COMPILE_DL_PHP_QT
+#define PHPQT_CLASS_COUNT 50
+
 #include <iostream>
 using namespace std;
 
 #include <zend_interfaces.h>
 #include "smoke.h"
 
-#include <QTextStream>
-#include <QVariant>
-#include <QWidget>
-#include <QStack>
-#include <QString>
-#include <QMetaMethod>
-#include <QHash>
-#include <QCoreApplication>
-#include <QApplication>
+#include <QtCore/QTextStream>
+#include <QtCore/QVariant>
+#include <QtCore/QStack>
+#include <QtCore/QString>
+#include <QtCore/QMetaMethod>
+#include <QtCore/QHash>
+#include <QtCore/QCoreApplication>
 
-#include <QLayout>
-#include <QLCDNumber>
-#include <QFont>
+#include <QtGui/QWidget>
+#include <QtGui/QApplication>
+#include <QtGui/QLayout>
+#include <QtGui/QLCDNumber>
+#include <QtGui/QFont>
 
 // for older php versions
 #ifndef ZEND_MN
@@ -74,11 +77,6 @@
 
 #define PHP_QT_ME(classname, name, arg_info, flags)	PHP_QT_FENTRY(name, ZEND_MN(classname##_##name), arg_info, flags)
 
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
 #include "php.h"
 #include "php_ini.h"
 #include "ext/standard/info.h"

Added: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/qt/qstring.cpp	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/php_qt/qstring.cpp	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,2497 @@
+/*
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2005
+ * Thomas Moenicke <tm at ippfp.org>,
+ * Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * QString.cpp - QString PHP implementation.
+ * begin           : Wed Jan 18 23:31:01 2006
+ * generated by    : moni using kalyptus 0.9.
+ */
+
+#include <iostream>
+using namespace std;
+
+
+
+#include <QtCore/QString>
+#include <zend_interfaces.h>
+#include "php_qt.h"
+
+zend_class_entry* qstring_ce;
+
+ZEND_METHOD(QString,__toString){
+
+  QString *QString_ptr = (QString *) PHP_QT_FETCH();
+
+  int l = QString_ptr->size();
+
+  char* c = (char*) (QString_ptr->toUtf8()).constData();
+
+  RETURN_STRING(c,l);
+}
+
+
+/*		public enumSectionFlag:long {
+			SectionDefault = 0x00,
+			SectionSkipEmpty = 0x01,
+			SectionIncludeLeadingSep = 0x02,
+			SectionIncludeTrailingSep = 0x04,
+			SectionCaseInsensitiveSeps = 0x08
+		}
+*/
+
+/*		public enumSplitBehavior:long {
+			SplitBehavior = 0,
+			SplitBehavior = 1
+		}
+*/
+
+/*		public enumNormalizationForm:long {
+			NormalizationForm = 0,
+			NormalizationForm = 1,
+			NormalizationForm = 2,
+			NormalizationForm = 3
+		}
+*/
+/*********************************
+ *    class     QString */
+/*
+ *    function  compare
+ *    flags:    c
+ */
+ZEND_METHOD(QString, compare){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* o public*/
+
+		/* const QString& s,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* oo public*/
+
+		/* const QString& s1, const QString& s2,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  utf16
+ *    flags:    c
+ */
+ZEND_METHOD(QString, utf16){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				const ushort * return_object = (const ushort *) obj->utf16();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  constData
+ *    flags:    c
+ */
+ZEND_METHOD(QString, constData){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				const QChar * return_object = (const QChar *) obj->constData();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  insert
+ *    flags:    
+ */
+ZEND_METHOD(QString, insert){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int i, char c,  */
+		/* lo public*/
+
+		/* int i, const QString& s,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString & return_object = (QString &) obj->insert((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* lol public*/
+
+		/* int i, const QChar* uc, int len,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  clear
+ *    flags:    
+ */
+ZEND_METHOD(QString, clear){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			obj->clear();
+			RETURN_NULL();
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  setUtf16
+ *    flags:    
+ */
+ZEND_METHOD(QString, setUtf16){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const ushort* utf16, int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString & return_object = (QString &) obj->setUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  prepend
+ *    flags:    
+ */
+ZEND_METHOD(QString, prepend){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* char c,  */
+		/* s public*/
+
+		/* const char* s,  */
+		/* o public*/
+
+		/* const QString& s,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString & return_object = (QString &) obj->prepend((char) Z_LVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_STRING){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString & return_object = (QString &) obj->prepend( (const char*) Z_STRVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  trimmed
+ *    flags:    c
+ */
+ZEND_METHOD(QString, trimmed){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				QString return_object = (QString) obj->trimmed();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  chop
+ *    flags:    
+ */
+ZEND_METHOD(QString, chop){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int n,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj->chop((int) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  leftJustified
+ *    flags:    c
+ */
+ZEND_METHOD(QString, leftJustified){
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* lll public*/
+
+		/* int width, char fill, int trunc,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->leftJustified((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(bool) Z_LVAL_P(z_2));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  squeeze
+ *    flags:    
+ */
+ZEND_METHOD(QString, squeeze){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			obj->squeeze();
+			RETURN_NULL();
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  count
+ *    flags:    c
+ */
+ZEND_METHOD(QString, count){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_LONG(obj->count());
+	}
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* o public*/
+
+		/* const QRegExp& ,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QString& s, int cs,  */
+		/* ll public*/
+
+		/* char c, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj->count((char) Z_LVAL_P(z_0) ,(Qt::CaseSensitivity) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fromAscii
+ *    flags:    s
+ */
+ZEND_METHOD(QString, fromAscii){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* sl public*/
+
+		/* const char* , int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->fromAscii( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toLongLong
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toLongLong){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj->toLongLong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toUpper
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toUpper){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				QString return_object = (QString) obj->toUpper();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  QString
+ *    flags:    
+ */
+ZEND_METHOD(QString, __construct){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *QString_ptr = new QString();
+				PHP_QT_REGISTER(QString_ptr);
+				RETURN_NULL();
+	}
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* char c,  */
+		/* s public*/
+
+		/* const char* ch,  */
+		/* o public*/
+
+		/* const QLatin1String& latin1,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+
+
+			QString *QString_ptr = new QString((char) Z_LVAL_P(z_0));
+				PHP_QT_REGISTER(QString_ptr);
+				RETURN_NULL();
+			}
+			if(Z_TYPE_P(z_0) == IS_STRING){
+
+			QString *QString_ptr = new QString( (const char*) Z_STRVAL_P(z_0));
+
+				PHP_QT_REGISTER(QString_ptr);
+				RETURN_NULL();
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QChar* unicode, int size,  */
+		/* ll public*/
+
+		/* int size, char c,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+
+
+			QString *QString_ptr = new QString((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
+				PHP_QT_REGISTER(QString_ptr);
+				RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  normalized
+ *    flags:    c
+ */
+ZEND_METHOD(QString, normalized){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* o public*/
+
+		/* QString::NormalizationForm mode,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->normalized((QString::NormalizationForm) Z_LVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* QString::NormalizationForm mode, int version,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->normalized((QString::NormalizationForm) Z_LVAL_P(z_0) ,(QChar::UnicodeVersion) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fromUtf16
+ *    flags:    s
+ */
+ZEND_METHOD(QString, fromUtf16){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const ushort* , int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->fromUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  isRightToLeft
+ *    flags:    c
+ */
+ZEND_METHOD(QString, isRightToLeft){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_BOOL(obj->isRightToLeft());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  setNum
+ *    flags:    
+ */
+ZEND_METHOD(QString, setNum){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* short , int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString & return_object = (QString &) obj->setNum((short) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* oll public*/
+
+		/* float , char f, int prec,  */
+		/* lll public*/
+
+		/* double , char f, int prec,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString & return_object = (QString &) obj->setNum((float) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString & return_object = (QString &) obj->setNum((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  endsWith
+ *    flags:    c
+ */
+ZEND_METHOD(QString, endsWith){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QString& s, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  number
+ *    flags:    s
+ */
+ZEND_METHOD(QString, number){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* unsigned long , int base,  */
+		/* ll public*/
+
+		/* int , int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->number((ulong) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->number((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* lll public*/
+
+		/* double , char f, int prec,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->number((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  localeAwareCompare
+ *    flags:    c
+ */
+ZEND_METHOD(QString, localeAwareCompare){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* o public*/
+
+		/* const QString& s,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* oo public*/
+
+		/* const QString& s1, const QString& s2,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  section
+ *    flags:    c
+ */
+ZEND_METHOD(QString, section){
+
+	if (ZEND_NUM_ARGS() == 4){
+		/* lllo public*/
+
+		/* char sep, int start, int end, QString::SectionFlags flags,  */
+		/* ollo public*/
+
+		/* const QString& in_sep, int start, int end, QString::SectionFlags flags,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		zval *z_3; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->section((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(QString::SectionFlags) Z_LVAL_P(z_3));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  isSimpleText
+ *    flags:    c
+ */
+ZEND_METHOD(QString, isSimpleText){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_BOOL(obj->isSimpleText());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  size
+ *    flags:    c
+ */
+ZEND_METHOD(QString, size){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_LONG(obj->size());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  simplified
+ *    flags:    c
+ */
+ZEND_METHOD(QString, simplified){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				QString return_object = (QString) obj->simplified();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toUInt
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toUInt){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj->toUInt((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toUShort
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toUShort){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj->toUShort((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  truncate
+ *    flags:    
+ */
+ZEND_METHOD(QString, truncate){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int pos,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj->truncate((int) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toAscii
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toAscii){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_STRING((char*) obj->toAscii().constData(), 1);
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  length
+ *    flags:    c
+ */
+ZEND_METHOD(QString, length){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_LONG(obj->length());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  right
+ *    flags:    c
+ */
+ZEND_METHOD(QString, right){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int len,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->right((int) Z_LVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  push_front
+ *    flags:    
+ */
+ZEND_METHOD(QString, push_front){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* char c,  */
+		/* o public*/
+
+		/* const QString& s,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj->push_front((char) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toUtf8
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toUtf8){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_STRING((char*) obj->toUtf8().constData(), 1);
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toULongLong
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toULongLong){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj->toULongLong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  indexOf
+ *    flags:    c
+ */
+ZEND_METHOD(QString, indexOf){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QRegExp& , int from,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* oll public*/
+
+		/* const QString& s, int from, int cs,  */
+		/* lll public*/
+
+		/* char c, int from, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj->indexOf((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(Qt::CaseSensitivity) Z_LVAL_P(z_2)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fromRawData
+ *    flags:    s
+ */
+ZEND_METHOD(QString, fromRawData){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QChar* , int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  constEnd
+ *    flags:    c
+ */
+ZEND_METHOD(QString, constEnd){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			obj->constEnd();
+			RETURN_NULL();
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  left
+ *    flags:    c
+ */
+ZEND_METHOD(QString, left){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int len,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->left((int) Z_LVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fromLocal8Bit
+ *    flags:    s
+ */
+ZEND_METHOD(QString, fromLocal8Bit){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* sl public*/
+
+		/* const char* , int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->fromLocal8Bit( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  startsWith
+ *    flags:    c
+ */
+ZEND_METHOD(QString, startsWith){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QString& s, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  remove
+ *    flags:    
+ */
+ZEND_METHOD(QString, remove){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* o public*/
+
+		/* const QRegExp& rx,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QString& s, int cs,  */
+		/* ll public*/
+
+		/* int i, int len,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString & return_object = (QString &) obj->remove((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  isEmpty
+ *    flags:    c
+ */
+ZEND_METHOD(QString, isEmpty){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_BOOL(obj->isEmpty());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  arg
+ *    flags:    c
+ */
+ZEND_METHOD(QString, arg){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* oo public*/
+
+		/* const QString& a1, const QString& a2,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* ooo public*/
+
+		/* const QString& a1, const QString& a2, const QString& a3,  */
+		/* olo public*/
+
+		/* const QString& a, int fieldWidth, const QChar& fillChar,  */
+		/* llo public*/
+
+		/* char a, int fieldWidth, const QChar& fillChar,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 4){
+		/* lllo public*/
+
+		/* int a, int fieldWidth, int base, const QChar& fillChar,  */
+		/* ollo public*/
+
+		/* qlonglong a, int fieldwidth, int base, const QChar& fillChar,  */
+		/* oooo public*/
+
+		/* const QString& a1, const QString& a2, const QString& a3, const QString& a4,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		zval *z_3; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_3 = (QObject*) phpqt_fetch(z_3);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_3 = (QObject*) phpqt_fetch(z_3);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+			QObject* obj_z_3 = (QObject*) phpqt_fetch(z_3);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 5){
+		/* llllo public*/
+
+		/* double a, int fieldWidth, char fmt, int prec, const QChar& fillChar,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		zval *z_3; // define ZVAL
+		zval *z_4; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzz", &z_0, &z_1, &z_2, &z_3, &z_4) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_4 = (QObject*) phpqt_fetch(z_4);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  vsprintf
+ *    flags:    
+ */
+ZEND_METHOD(QString, vsprintf){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* so public*/
+
+		/* const char* format, va_list ap,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toFloat
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toFloat){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int* ok,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+//			RETURN_FLOAT(obj->toFloat((bool*) Z_LVAL_P(z_0)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  isDetached
+ *    flags:    c
+ */
+ZEND_METHOD(QString, isDetached){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_BOOL(obj->isDetached());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  reserve
+ *    flags:    
+ */
+ZEND_METHOD(QString, reserve){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int size,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj->reserve((int) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toULong
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toULong){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+//			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+//			RETURN_ULONG(obj->toULong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toShort
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toShort){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+//			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+//			RETURN_SHORT(obj->toShort((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  split
+ *    flags:    c
+ */
+ZEND_METHOD(QString, split){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* oo public*/
+
+		/* const QRegExp& sep, QString::SplitBehavior behavior,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* ool public*/
+
+		/* const QString& sep, QString::SplitBehavior behavior, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  setUnicode
+ *    flags:    
+ */
+ZEND_METHOD(QString, setUnicode){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QChar* unicode, int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fromLatin1
+ *    flags:    s
+ */
+ZEND_METHOD(QString, fromLatin1){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* sl public*/
+
+		/* const char* , int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->fromLatin1( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  data
+ *    flags:    
+ */
+ZEND_METHOD(QString, data){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				QChar * return_object = (QChar *) obj->data();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toLatin1
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toLatin1){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_STRING((char*) obj->toLatin1().constData(), 1);
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  end
+ *    flags:    
+ */
+ZEND_METHOD(QString, end){
+	if (ZEND_NUM_ARGS() == 0){
+//			QString *obj = (QString*) PHP_QT_FETCH();
+//			RETURN_INTPTR(obj->end());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  contains
+ *    flags:    c
+ */
+ZEND_METHOD(QString, contains){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* o public*/
+
+		/* const QRegExp& rx,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QString& s, int cs,  */
+		/* ll public*/
+
+		/* char c, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj->contains((char) Z_LVAL_P(z_0) ,(Qt::CaseSensitivity) Z_LVAL_P(z_1));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  resize
+ *    flags:    
+ */
+ZEND_METHOD(QString, resize){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int size,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj->resize((int) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  replace
+ *    flags:    
+ */
+ZEND_METHOD(QString, replace){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* oo public*/
+
+		/* const QRegExp& rx, const QString& after,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* ool public*/
+
+		/* const QString& before, const QString& after, int cs,  */
+		/* lol public*/
+
+		/* char c, const QString& after, int cs,  */
+		/* lll public*/
+
+		/* int i, int len, char after,  */
+		/* llo public*/
+
+		/* int i, int len, const QString& after,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString & return_object = (QString &) obj->replace((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(char) Z_LVAL_P(z_2));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 4){
+		/* llol public*/
+
+		/* int i, int len, const QChar* s, int slen,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		zval *z_3; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fromUtf8
+ *    flags:    s
+ */
+ZEND_METHOD(QString, fromUtf8){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* sl public*/
+
+		/* const char* , int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
+
+// wichtig: Speicher auf dem Heap alloziieren
+			  QString *return_object = new QString;
+  			  if(getThis() != NULL){
+		        QString *obj = (QString*) PHP_QT_FETCH();
+// hier einfach ?berschreiben
+      			*return_object = (QString) obj->fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+// static
+		      } else {
+		        *return_object = (QString) QString::fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+
+		      }		
+			  zend_class_entry *ce;                                   
+			  object_init_ex(return_value, qstring_ce);
+			  zend_rsrc_list_entry le;                            
+			  le.ptr = return_object;
+			  phpqt_register(return_value,le);
+			  return;
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toLong
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toLong){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj->toLong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  detach
+ *    flags:    
+ */
+ZEND_METHOD(QString, detach){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			obj->detach();
+			RETURN_NULL();
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  append
+ *    flags:    
+ */
+ZEND_METHOD(QString, append){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* char c,  */
+		/* s public*/
+
+		/* const char* s,  */
+		/* o public*/
+
+		/* const QString& s,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString & return_object = (QString &) obj->append((char) Z_LVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_STRING){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString & return_object = (QString &) obj->append( (const char*) Z_STRVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  mid
+ *    flags:    c
+ */
+ZEND_METHOD(QString, mid){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int i, int len,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->mid((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toDouble
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toDouble){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int* ok,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_DOUBLE(obj->toDouble((bool*) Z_LVAL_P(z_0)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fill
+ *    flags:    
+ */
+ZEND_METHOD(QString, fill){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* char c, int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString & return_object = (QString &) obj->fill((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  rightJustified
+ *    flags:    c
+ */
+ZEND_METHOD(QString, rightJustified){
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* lll public*/
+
+		/* int width, char fill, int trunc,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj->rightJustified((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(bool) Z_LVAL_P(z_2));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toLower
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toLower){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				QString return_object = (QString) obj->toLower();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  lastIndexOf
+ *    flags:    c
+ */
+ZEND_METHOD(QString, lastIndexOf){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QRegExp& , int from,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* oll public*/
+
+		/* const QString& s, int from, int cs,  */
+		/* lll public*/
+
+		/* char c, int from, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj->lastIndexOf((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(Qt::CaseSensitivity) Z_LVAL_P(z_2)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  unicode
+ *    flags:    c
+ */
+ZEND_METHOD(QString, unicode){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				const QChar * return_object = (const QChar *) obj->unicode();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  at
+ *    flags:    c
+ */
+ZEND_METHOD(QString, at){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int i,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj->at((int) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  begin
+ *    flags:    
+ */
+ZEND_METHOD(QString, begin){
+	if (ZEND_NUM_ARGS() == 0){
+//			QString *obj = (QString*) PHP_QT_FETCH();
+//			RETURN_INTPTR(obj->begin());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  push_back
+ *    flags:    
+ */
+ZEND_METHOD(QString, push_back){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* char c,  */
+		/* o public*/
+
+		/* const QString& s,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj->push_back((char) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  capacity
+ *    flags:    c
+ */
+ZEND_METHOD(QString, capacity){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_LONG(obj->capacity());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  constBegin
+ *    flags:    c
+ */
+ZEND_METHOD(QString, constBegin){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			obj->constBegin();
+			RETURN_NULL();
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toLocal8Bit
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toLocal8Bit){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_STRING((char*) obj->toLocal8Bit().constData(), 1);
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toInt
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toInt){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj->toInt((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  isNull
+ *    flags:    c
+ */
+ZEND_METHOD(QString, isNull){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_BOOL(obj->isNull());
+	}
+}
+
+# warning: implement me
+//PHP_QT_DESTRUCT(QString);
+

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/qt/smokephp.cpp	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/php_qt/smokephp.cpp	2007-02-19 21:34:59 UTC (rev 290)
@@ -22,10 +22,10 @@
 
 #include "php_qt.h"
 #include "smoke.h"
-#include <QMetaMethod>
-#include <QHash>
-#include <QCoreApplication>
-#include <QApplication>
+#include <QtCore/QMetaMethod>
+#include <QtCore/QHash>
+#include <QtCore/QCoreApplication>
+#include <QtGui/QApplication>
 
 extern Smoke *qt_Smoke;
 extern void init_qt_Smoke();
@@ -92,7 +92,7 @@
 smokephp_init() {
 
     if (qt_Smoke != 0L) {
-	php_error(E_ERROR,"could not initialize smoke");
+		php_error(E_ERROR,"could not initialize smoke");
     }
 
     init_qt_Smoke();

Added: trunk/smoke/CMakeLists.txt
===================================================================
--- trunk/smoke/CMakeLists.txt	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/CMakeLists.txt	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,18 @@
+
+#Laurent reuse configure.in.in
+#message(STATUS "${CMAKE_CURRENT_SOURCE_DIR}: skipped subdir $(kde_build_libsmoke)")
+
+add_subdirectory(qt)
+#add_subdirectory(kde)
+
+########### install files ###############
+
+#install( FILES  smoke.h DESTINATION ${INCLUDE_INSTALL_DIR} )
+
+
+
+#original Makefile.am contents follow:
+
+#SUBDIRS = $(kde_build_libsmoke)
+#
+#include_HEADERS = smoke.h

Added: trunk/smoke/kde/CMakeLists.txt
===================================================================
--- trunk/smoke/kde/CMakeLists.txt	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/kde/CMakeLists.txt	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,153 @@
+
+include_directories( ${CMAKE_SOURCE_DIR}/smoke ${INCLUDE_INSTALL_DIR}/khexedit/ )
+
+set(srcdir ${CMAKE_CURRENT_SOURCE_DIR})
+set(KDE_PREFIX ${CMAKE_INSTALL_PREFIX})
+set(qt_includes ${QT_INCLUDE_DIR})
+set(kde_includes ${KDE4_INCLUDE_DIR})
+if(OPENGL_FOUND AND OPENGL_GLU_FOUND)
+   set(KDE_HAVE_GL "yes")
+else(OPENGL_FOUND AND OPENGL_GLU_FOUND)
+   set(KDE_HAVE_GL "no")
+endif(OPENGL_FOUND AND OPENGL_GLU_FOUND)	
+
+# for qtguess.pl
+set(qt_test_threshold 10)
+set(qtflags "-lQtCore -lQtGui")
+FOREACH(filename ${QT_INCLUDES})
+    set(all_includes "-I${filename} ${all_includes}")
+ENDFOREACH(filename)
+
+configure_file(generate.pl.cmake ${CMAKE_CURRENT_BINARY_DIR}/generate.pl @ONLY )
+configure_file(qtguess.pl.cmake ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl @ONLY)
+
+# macro is defined in qt-copy/src/qbase.pri but couldn't be found by qtguess, so I append it manually
+file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/qtdefines "QT_NO_CAST_TO_ASCII\n")
+
+########### next target ###############
+
+add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_2.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_3.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_4.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_5.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_6.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_7.cpp 
+                ${CMAKE_CURRENT_BINARY_DIR}/x_8.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_9.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_10.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_11.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_12.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_13.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_14.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_15.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_16.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_17.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_18.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_19.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_20.cpp
+
+                  COMMAND ${PERL_EXECUTABLE} ARGS ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl
+                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl
+
+                  COMMAND ${PERL_EXECUTABLE} ARGS ${CMAKE_CURRENT_BINARY_DIR}/generate.pl
+                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/generate.pl
+                  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
+
+macro_add_file_dependencies( ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp ${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp )
+
+
+set(smokekde_LIB_SRCS ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp  
+		${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_2.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_3.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_4.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_5.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_6.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_7.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_8.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_9.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_10.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_11.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_12.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_13.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_14.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_15.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_16.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_17.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_18.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_19.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_20.cpp
+)
+
+kde4_add_library(smokekde SHARED ${smokekde_LIB_SRCS})
+
+target_link_libraries(smokekde 
+    ${QT_QTNETWORK_LIBRARY} 
+    ${QT_QTSQL_LIBRARY} 
+    ${QT_QTOPENGL_LIBRARY} 
+    ${QT_QTXML_LIBRARY} 
+    ${QT_QTSVG_LIBRARY} 
+    ${QT_QTUITOOLS_LIBRARY} 
+    ${QT_QT3SUPPORT_LIBRARY} 
+    ${KDE4_KDECORE_LIBS} 
+    ${KDE4_KDEUI_LIBS}
+    ${KDE4_KIO_LIBS} 
+    ${KDE4_KNOTIFYCONFIG_LIBS}
+    ${KDE4_SONNETUI_LIBS}
+    ${KDE4_KNEWSTUFF_LIBS}
+    ${KDE4_KDNSSD_LIBS}
+    ${KDE4_KHTML_LIBS}
+    ${KDE4_KDE3SUPPORT_LIBS}
+    kmediaplayer
+    kntlm )
+
+set_target_properties(smokekde PROPERTIES VERSION 2.0.0 SOVERSION 2 )
+install(TARGETS smokekde DESTINATION ${LIB_INSTALL_DIR} )
+
+
+########### install files ###############
+
+
+
+
+#original Makefile.am contents follow:
+
+#
+#
+#lib_LTLIBRARIES = libsmokekde.la
+#
+## set the include path for X, qt and KDE
+#INCLUDES         = -I$(srcdir)/.. $(all_includes) -I$(qt_includes)/QtUiTools \
+#                   -I$(qt_includes)/QtDBus
+#
+#EXTRA_DIST=generate.pl.in qtguess.pl.in qt_smoke.h Makefile.am
+#
+## the library search path. 
+#libsmokekde_la_LDFLAGS = -version-info 2:0:0 -no-undefined $(all_libraries) $(GLINC) $(KDE_RPATH)
+#
+## the libraries to link against.
+#libsmokekde_la_LIBADD   = $(LIB_QTCORE) $(LIB_QTGUI) $(LIB_QTNETWORK) \
+#						$(LIB_QTOPENGL) $(LIB_QTSQL) $(LIB_QTCORE) $(LIB_QTXML) $(LIB_QTSVG) \
+#						$(GLLIB) $(LIBQSCINTILLA) \
+#						-lQtSvg -lQtUiTools $(LIBQTDBUS) \
+#						$(LIB_KHTML) -lkjs -lfontconfig $(LIB_KMDI) $(LIB_KNS) $(LIB_KSPELL) \
+#						$(LIB_KUTILS) $(LIB_KDEPRINT)
+#
+#x_sources = x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+#   x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+#   x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp
+#
+## which sources should be compiled for perlqtkde
+#libsmokekde_la_SOURCES = smokedata.cpp $(x_sources)
+#
+#$(x_sources) smokedata.cpp:
+#	perl generate.pl
+#
+#CLEANFILES = $(libsmokekde_la_SOURCES)
+#
+#
+#
+#
+#

Added: trunk/smoke/kde/generate.pl.cmake
===================================================================
--- trunk/smoke/kde/generate.pl.cmake	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/kde/generate.pl.cmake	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,212 @@
+#!/usr/bin/perl -w
+
+## Run this first, to generate the x_*.cpp files from the Qt headers
+## using kalyptus
+
+my $kalyptusdir = "@srcdir@/../../kalyptus";
+
+use File::Basename;
+use File::Copy qw|cp|;
+use File::Compare;
+use File::Find;
+use Cwd;
+
+my $here = getcwd;
+my $outdir = $here . "/generate.pl.tmpdir";
+my $finaloutdir = $here;
+my $defines = "qtdefines";
+my $headerlist = "@srcdir@/header_list";
+my $kdeheaderlist = "@srcdir@/kde_header_list";
+my $definespath = "$here/$defines";
+my $headerlistpath = "$here/$headerlist";
+my $kdeheaderlistpath = "$here/$kdeheaderlist";
+
+# If srcdir != builddir, then srcdir is probvably an absolute
+# path, and it makes no sense to prepend $here.
+$definespath = $defines if $defines =~ /^\//;
+$headerlistpath = $headerlist if $headerlist =~ /^\//;
+$kdeheaderlistpath = $kdeheaderlist if $kdeheaderlist =~ /^\//;
+
+## Note: outdir and finaloutdir should NOT be the same dir!
+
+# Delete all x_*.cpp files under outdir (or create outdir if nonexistent)
+if (-d $outdir) { system "rm -f $outdir/x_*.cpp"; } else { mkdir $outdir; }
+
+mkdir $finaloutdir unless (-d $finaloutdir);
+
+#  Load the QT_NO_* macros found in "qtdefines". They'll be passed to kalyptus
+my $macros="";
+if ( -e $definespath ){
+    print "Found '$defines'. Reading preprocessor symbols from there...\n";
+    $macros = " --defines=$definespath ";
+}
+
+# Need to cd to kalyptus's directory so that perl finds Ast.pm etc.
+chdir "$kalyptusdir" or die "Couldn't go to $kalyptusdir (edit script to change dir)\n";
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %excludes = (
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %includes;
+open(HEADERS, $headerlistpath) or die "Couldn't open $headerlistpath: $!\n";
+map { chomp ; $includes{$_} = 1 unless /^\s*#/ } <HEADERS>;
+close HEADERS;
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %kdeexcludes = (
+#   These headers don't look suitable for inclusion:
+	'kallocator.h' => 1,
+	'kbookmarkimporter_crash.h' => 1,
+	'kbookmarkimporter_ie.h' => 1,
+	'kbookmarkimporter_opera.h' => 1,
+	'kbookmarkimporter_ns.h' => 1,
+	'kcrash.h' => 1,
+	'kdebug.h' => 1,
+	'kde_terminal_interface.h' => 1,
+
+#	These headers currently give problems
+	'kio/uiserver.h' => 1,
+	'kio/thumbcreator.h' => 1,
+	'kio/file.h' => 1,
+	'kio/chmodjob.h' => 1,
+	'kparts/genericfactory.h' => 1,
+	'kopenssl.h' => 1,
+	'kautomount.h' => 1,
+	'kimagefilepreview.h' => 1,
+	'kpropertiesdialog.h' => 1,
+	'knotifydialog.h' => 1,
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %kdeincludes;
+open(HEADERS, $kdeheaderlistpath) or die "Couldn't open $kdeheaderlistpath: $!\n";
+map { chomp ; $kdeincludes{$_} = 1 unless /^\s*#/ } <HEADERS>;
+close HEADERS;
+
+# Can we compile the OpenGl module ?
+if("@KDE_HAVE_GL@" eq "yes")
+{
+    open(DEFS, $definespath);
+    my @defs = <DEFS>;
+    close DEFS;
+    if(!grep(/QT_NO_OPENGL/, @defs))
+    {
+      $excludes{'qgl.h'} = undef;
+      $excludes{'qglcolormap.h'} = undef;
+    }
+    else
+    {
+      print STDERR "Qt was not compiled with OpenGL support...\n Skipping QGL Classes.\n";
+    }
+}
+
+# List Qt headers, and exclude the ones listed above
+my @headers = ();
+
+$qtinc= '@qt_includes@';
+
+find(
+    {   wanted => sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qtinc);
+                if( !defined $excludes{$f} # Not excluded
+                     && $includes{$f}        # Known header
+                     && /\.h$/)     # Not a backup file etc. Only headers.
+                {
+                    my $header = $_;
+                    open(FILE, $_);
+                    my @header_lines = <FILE>;
+                    if (@header_lines == 1) {
+                        $line = $header_lines[0];
+                        if ($line =~ /^#include "(.*)"/) {
+                            push ( @headers, $qtinc . substr($1, 2) );
+                        } else {
+                            push ( @headers, $header );
+                        }
+                    } else {
+                        push ( @headers, $header );
+                    }
+                }
+	    	undef $includes{$f}   
+	     };
+	},
+	follow_fast => 1,
+	follow_skip => 2,
+	no_chdir => 1
+    }, $qtinc
+ );
+
+my @kdeheaders = ();
+$kdeprefix = "@KDE_PREFIX@";
+$kdeinc= '@kde_includes@';
+$kdeinc =~ s/\${prefix}/$kdeprefix/; # Remove ${prefix} in src != build
+-d $kdeinc or die "Couldn't process $kdeinc: $!\n";
+
+find(
+    {   wanted => sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $kdeinc);
+                push ( @kdeheaders, $_ )
+	    	  if( !defined $kdeexcludes{$f} # Not excluded
+	    	     && $kdeincludes{$f}        # Known header
+	    	     && /\.h$/);     # Not a backup file etc. Only headers.
+	    	undef $kdeincludes{$f}   
+	     };
+	},
+	follow_fast => 1,
+	follow_skip => 2,
+	no_chdir => 1
+    }, $kdeinc
+ );
+
+# Launch kalyptus
+system "perl kalyptus @ARGV --qt4 --globspace -fsmoke --name=qt $macros --no-cache --allow_k_dcop_accessors --outputdir=$outdir @headers @kdeheaders";
+my $exit = $? >> 8;
+exit $exit if ($exit);
+
+# Generate diff for smokedata.cpp
+unless ( -e "$finaloutdir/smokedata.cpp" ) {
+    open( TOUCH, ">$finaloutdir/smokedata.cpp");
+    close TOUCH;
+}
+system "diff -u $finaloutdir/smokedata.cpp $outdir/smokedata.cpp > $outdir/smokedata.cpp.diff";
+
+# Copy changed or new files to finaloutdir
+opendir (OUT, $outdir) or die "Couldn't opendir $outdir";
+foreach $filename (readdir(OUT)) {
+    next if ( -d "$outdir/$filename" ); # only files, not dirs
+    my $docopy = 1;
+    if ( -f "$finaloutdir/$filename" ) {
+        $docopy = compare("$outdir/$filename", "$finaloutdir/$filename"); # 1 if files are differents
+    }
+    if ($docopy) {
+	#print STDERR "Updating $filename...\n";
+	cp("$outdir/$filename", "$finaloutdir/$filename");
+    }
+}
+closedir OUT;
+
+# Check for deleted files and warn
+my $deleted = 0;
+opendir(FINALOUT, $finaloutdir) or die "Couldn't opendir $finaloutdir";
+foreach $filename (readdir(FINALOUT)) {
+    next if ( -d "$finaloutdir/$filename" ); # only files, not dirs
+    if ( $filename =~ /.cpp$/ && ! ($filename =~ /_la_closure.cpp/) && ! -f "$outdir/$filename" ) {
+      print STDERR "Removing obsolete file $filename\n";
+      unlink "$finaloutdir/$filename";
+      $deleted = 1;
+    }
+}
+closedir FINALOUT;
+
+# Delete outdir
+system "rm -rf $outdir";
+

Modified: trunk/smoke/kde/header_list
===================================================================
--- trunk/smoke/kde/header_list	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/kde/header_list	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,351 +1,312 @@
-q1xcompatibility.h
-qabstractlayout.h
-qaccel.h
-qaccessible.h
-qaction.h
-qapp.h
-qapplication.h
-qarray.h
-qasciicache.h
-qasciidict.h
-qassistantclient.h
-qasyncimageio.h
-qasyncio.h
-qbig5codec.h
-qbitarray.h
-qbitarry.h
-qbitmap.h
-qbrush.h
-qbttngrp.h
-qbuffer.h
-qbuttongroup.h
-qbutton.h
-qcache.h
-qcanvas.h
-qcdestyle.h
-qcheckbox.h
-qchkbox.h
-qcleanuphandler.h
-qclipboard.h
-qclipbrd.h
-qcollect.h
-qcollection.h
-qcolordialog.h
-qcolor.h
-qcombobox.h
-qcombo.h
-qcommonstyle.h
-qcompactstyle.h
-qconfig-dist.h
-qconfig.h
-qconnect.h
-qconnection.h
-qcstring.h
-qcursor.h
-qdatabrowser.h
-qdatastream.h
-qdatatable.h
-qdataview.h
-qdatetimeedit.h
-qdatetime.h
-qdatetm.h
-qdeepcopy.h
-qdesktopwidget.h
-qdial.h
-qdialog.h
-qdict.h
-qdir.h
-qdns.h
-qdockarea.h
-qdockwindow.h
-qdom.h
-qdragobject.h
-qdrawutil.h
-qdrawutl.h
-qdropsite.h
-qdstream.h
-qeditorfactory.h
-qerrormessage.h
-qeucjpcodec.h
-qeuckrcodec.h
-qevent.h
-qeventloop.h
-qfeatures.h
-qfiledef.h
-qfiledialog.h
-qfiledlg.h
-qfile.h
-qfileinf.h
-qfileinfo.h
-qfocusdata.h
-qfontdatabase.h
-qfontdialog.h
-qfontdta.h
-qfont.h
-qfontinf.h
-qfontinfo.h
-qfontmet.h
-qfontmetrics.h
-qframe.h
-qftp.h
-qgarray.h
-qgb18030codec.h
-qgbkcodec.h
-qgcache.h
-qgdict.h
-qgeneric.h
-qgif.h
-qglcolormap.h
-qgl.h
-qglist.h
-qglobal.h
-qgplugin.h
-qgrid.h
-qgridview.h
-qgroupbox.h
-qgrpbox.h
-qguardedptr.h
-qgvector.h
-qhbox.h
-qhbuttongroup.h
-qheader.h
-qhgroupbox.h
-qhostaddress.h
-qhttp.h
-qiconset.h
-qiconview.h
-qimageformatplugin.h
-qimage.h
-qinputdialog.h
-qintcache.h
-qintcach.h
-qintdict.h
-qinterlacestyle.h
-qiodev.h
-qiodevice.h
-qjiscodec.h
-qjpunicode.h
-qkeycode.h
-qkeysequence.h
-qlabel.h
-qlayout.h
-qlcdnumber.h
-qlcdnum.h
-qlocale.h
-qlibrary.h
-qlined.h
-qlineedit.h
-qlistbox.h
-qlist.h
-qlistview.h
-qlocalfs.h
-qmainwindow.h
-qmap.h
-qmemarray.h
-qmenubar.h
-qmenudata.h
-qmenudta.h
-qmessagebox.h
-qmetaobject.h
-qmetaobj.h
-qmime.h
-qmlined.h
-qmodules.h
-qmotifdialog.h
-qmotif.h
-qmotifplusstyle.h
-qmotifstyle.h
-qmotifwidget.h
-qmovie.h
-qmsgbox.h
-qmultilinedit.h
-qmultilineedit.h
-qmutex.h
-qnamespace.h
-qnetwork.h
-qnetworkprotocol.h
-qobjcoll.h
-qobjdefs.h
-qobjectcleanuphandler.h
-qobjectdefs.h
-qobjectdict.h
-qobject.h
-qobjectlist.h
-qpaintdc.h
-qpaintdevicedefs.h
-qpaintdevice.h
-qpaintdevicemetrics.h
-qpaintd.h
-qpainter.h
-qpair.h
-qpalette.h
-qpdevmet.h
-qpen.h
-qpicture.h
-qpixmapcache.h
-qpixmap.h
-qplatinumstyle.h
-qpmcache.h
-qpntarry.h
-qpointarray.h
-qpoint.h
-qpolygonscanner.h
-qpopmenu.h
-qpopupmenu.h
-qprintdialog.h
-qprinter.h
-qprndlg.h
-qprocess.h
-qprogbar.h
-qprogdlg.h
-qprogressbar.h
-qprogressdialog.h
-qpsprn.h
-qptrcollection.h
-qptrdict.h
-qptrlist.h
-qptrqueue.h
-qptrstack.h
-qptrvector.h
-qpushbt.h
-qpushbutton.h
-qqueue.h
-qradiobt.h
-qradiobutton.h
-qrangecontrol.h
-qrangect.h
-qrect.h
-qregexp.h
-qregion.h
-qremotefactory.h
-qremoteplugin.h
-qrtlcodec.h
-qscopedptr.h
-qscrbar.h
-qscrollbar.h
-qscrollview.h
-qsemaphore.h
-qsemimodal.h
-qserversocket.h
-qsession.h
-qsessionmanager.h
-qsettings.h
-qsgistyle.h
-qshared.h
-qsignal.h
-qsignalmapper.h
-qsignalslotimp.h
-qsimplerichtext.h
-qsizegrip.h
-qsize.h
-qsizepolicy.h
-qsjiscodec.h
-qslider.h
-qsocketdevice.h
-qsocket.h
-qsocketnotifier.h
-qsocknot.h
-qsortedlist.h
-qsound.h
-qspinbox.h
-qsplashscreen.h
-qsplitter.h
-qsqlcursor.h
-qsqldatabase.h
-qsqldriver.h
-qsqldriverplugin.h
-qsqleditorfactory.h
-qsqlerror.h
-qsqlfield.h
-qsqlform.h
-qsql.h
-qsqlindex.h
-qsqlpropertymap.h
-qsqlquery.h
-qsqlrecord.h
-qsqlresult.h
-qsqlselectcursor.h
-qstack.h
-qstatusbar.h
-qstring.h
-qstringlist.h
-qstrlist.h
-qstrvec.h
-qstylefactory.h
-qstyle.h
-qstyleplugin.h
-qstylesheet.h
-qsyntaxhighlighter.h
-qtabbar.h
-qtabdialog.h
-qtabdlg.h
-qtable.h
-qtabwidget.h
-qtextbrowser.h
-qtextcodecfactory.h
-qtextcodec.h
-qtextcodecplugin.h
-qtextedit.h
-qtextstream.h
-qtextview.h
-qt.h
-qthread.h
-qtimer.h
-qtl.h
-qtmultilineedit.h
-qtoolbar.h
-qtoolbutton.h
-qtoolbox.h
-qtooltip.h
-qtranslator.h
-qtsciicodec.h
-qtstream.h
-qttableview.h
-qurl.h
-qurlinfo.h
-qurloperator.h
-qutfcodec.h
-quuid.h
-qvalidator.h
-qvaluelist.h
-qvaluestack.h
-qvaluevector.h
-qvariant.h
-qvbox.h
-qvbuttongroup.h
-qvector.h
-qvgroupbox.h
-qwaitcondition.h
-qwhatsthis.h
-qwidcoll.h
-qwidgetfactory.h
-qwidget.h
-qwidgetintdict.h
-qwidgetlist.h
-qwidgetplugin.h
-qwidgetstack.h
-qwindefs.h
-qwindowdefs.h
-qwindow.h
-qwindowsstyle.h
-qwizard.h
-qwmatrix.h
-qworkspace.h
-qwsbeosdecoration_qws.h
-qwscommand_qws.h
-qwscursor_qws.h
-qwsdecoration_qws.h
-qwsdefaultdecoration_qws.h
-qwsdisplay_qws.h
-qwsevent_qws.h
-qwshydrodecoration_qws.h
-qwskde2decoration_qws.h
-qwskdedecoration_qws.h
-qwsmanager_qws.h
-qwsmouse_qws.h
-qwsproperty_qws.h
-qwsregionmanager_qws.h
-qwssocket_qws.h
-qwsutils_qws.h
-qwswindowsdecoration_qws.h
-qxml.h
+QtCore/qabstracteventdispatcher.h
+QtCore/qabstractfileengine.h
+QtCore/qabstractitemmodel.h
+QtCore/qalgorithms.h
+QtCore/qbasictimer.h
+QtCore/qbitarray.h
+QtCore/qbuffer.h
+QtCore/qbytearray.h
+QtCore/qbytearraymatcher.h
+QtCore/qcache.h
+QtCore/qchar.h
+QtCore/qconfig-dist.h
+QtCore/qconfig.h
+QtCore/qconfig-large.h
+QtCore/qconfig-medium.h
+QtCore/qconfig-minimal.h
+QtCore/qconfig-small.h
+QtCore/qcoreapplication.h
+QtCore/qcoreevent.h
+QtCore/qdatastream.h
+QtCore/qdatetime.h
+QtCore/qdebug.h
+QtCore/qdir.h
+QtCore/qeventloop.h
+QtCore/qfactoryinterface.h
+QtCore/qfeatures.h
+QtCore/qfile.h
+QtCore/qfileinfo.h
+QtCore/qfilesystemwatcher.h
+QtCore/qfsfileengine.h
+QtCore/qglobal.h
+QtCore/qiodevice.h
+QtCore/qiterator.h
+QtCore/qlibrary.h
+QtCore/qlibraryinfo.h
+QtCore/qline.h
+QtCore/qlocale.h
+QtCore/qmap.h
+QtCore/qmetaobject.h
+QtCore/qmetatype.h
+QtCore/qmimedata.h
+QtCore/qmutex.h
+QtCore/qnamespace.h
+QtCore/qobjectcleanuphandler.h
+QtCore/qobjectdefs.h
+QtCore/qobject.h
+QtCore/qpair.h
+QtCore/qplugin.h
+QtCore/qpluginloader.h
+QtCore/qpointer.h
+QtCore/qpoint.h
+QtCore/qprocess.h
+QtCore/qqueue.h
+QtCore/qreadwritelock.h
+QtCore/qrect.h
+QtCore/qregexp.h
+QtCore/qsemaphore.h
+QtCore/qsettings.h
+QtCore/qshareddata.h
+QtCore/qsignalmapper.h
+QtCore/qsize.h
+QtCore/qsocketnotifier.h
+QtCore/qstack.h
+QtCore/qstring.h
+QtCore/qstringlist.h
+QtCore/qstringmatcher.h
+QtCore/qtemporaryfile.h
+QtCore/qtextcodec.h
+QtCore/qtextcodecplugin.h
+QtCore/qtextstream.h
+QtCore/qthread.h
+QtCore/qthreadstorage.h
+QtCore/qtimeline.h
+QtCore/qtimer.h
+QtCore/qtranslator.h
+QtCore/qurl.h
+QtCore/quuid.h
+QtCore/qvariant.h
+QtCore/qvarlengtharray.h
+QtCore/qvector.h
+QtCore/qwaitcondition.h
+QtDBus/qdbusabstractadaptor.h
+QtDBus/qdbusabstractinterface.h
+QtDBus/qdbusargument.h
+QtDBus/qdbusconnection.h
+QtDBus/qdbusconnectioninterface.h
+QtDBus/qdbuserror.h
+QtDBus/qdbusextratypes.h
+QtDBus/qdbusinterface.h
+QtDBus/qdbusmacros.h
+QtDBus/qdbusmessage.h
+QtDBus/qdbusmetatype.h
+QtDBus/qdbusreply.h
+QtDBus/qdbusserver.h
+QtGui/qabstractbutton.h
+QtGui/qabstractitemdelegate.h
+QtGui/qabstractitemview.h
+QtGui/qabstractpagesetupdialog.h
+QtGui/qabstractprintdialog.h
+QtGui/qabstractproxymodel.h
+QtGui/qabstractscrollarea.h
+QtGui/qabstractslider.h
+QtGui/qabstractspinbox.h
+QtGui/qabstracttextdocumentlayout.h
+QtGui/qaccessiblebridge.h
+QtGui/qaccessible.h
+QtGui/qaccessibleobject.h
+QtGui/qaccessibleplugin.h
+QtGui/qaccessiblewidget.h
+QtGui/qactiongroup.h
+QtGui/qaction.h
+QtGui/qapplication.h
+QtGui/qbitmap.h
+QtGui/qboxlayout.h
+QtGui/qbrush.h
+QtGui/qbuttongroup.h
+QtGui/qcalendarwidget.h
+QtGui/qcheckbox.h
+QtGui/qcleanlooksstyle.h
+QtGui/qclipboard.h
+QtGui/qcolordialog.h
+QtGui/qcolor.h
+QtGui/qcolormap.h
+QtGui/qcombobox.h
+QtGui/qcommonstyle.h
+QtGui/qcompleter.h
+QtGui/qcursor.h
+QtGui/qdatawidgetmapper.h
+QtGui/qdatetimeedit.h
+QtGui/qdesktopservices.h
+QtGui/qdesktopwidget.h
+QtGui/qdial.h
+QtGui/qdialogbuttonbox.h
+QtGui/qdialog.h
+QtGui/qdirmodel.h
+QtGui/qdockwidget.h
+QtGui/qdrag.h
+QtGui/qdrawutil.h
+QtGui/qerrormessage.h
+QtGui/qevent.h
+QtGui/qfiledialog.h
+QtGui/qfocusframe.h
+QtGui/qfontcombobox.h
+QtGui/qfontdatabase.h
+QtGui/qfontdialog.h
+QtGui/qfont.h
+QtGui/qfontinfo.h
+QtGui/qfontmetrics.h
+QtGui/qframe.h
+QtGui/qgraphicsitemanimation.h
+QtGui/qgraphicsitem.h
+QtGui/qgraphicssceneevent.h
+QtGui/qgraphicsscene.h
+QtGui/qgraphicsview.h
+QtGui/qgridlayout.h
+QtGui/qgroupbox.h
+QtGui/qhboxlayout.h
+QtGui/qheaderview.h
+QtGui/qiconengine.h
+QtGui/qiconengineplugin.h
+QtGui/qicon.h
+QtGui/qimage.h
+QtGui/qimageiohandler.h
+QtGui/qimagereader.h
+QtGui/qimagewriter.h
+QtGui/qinputcontextfactory.h
+QtGui/qinputcontext.h
+QtGui/qinputcontextplugin.h
+QtGui/qinputdialog.h
+QtGui/qitemdelegate.h
+QtGui/qitemeditorfactory.h
+QtGui/qitemselectionmodel.h
+QtGui/qkeysequence.h
+QtGui/qlabel.h
+QtGui/qlayout.h
+QtGui/qlayoutitem.h
+QtGui/qlcdnumber.h
+QtGui/qlineedit.h
+QtGui/qlistview.h
+QtGui/qlistwidget.h
+QtGui/qmacstyle.h
+QtGui/qmainwindow.h
+QtGui/qmatrix.h
+QtGui/qmenubar.h
+QtGui/qmenudata.h
+QtGui/qmenu.h
+QtGui/qmessageboxex.h
+QtGui/qmessagebox.h
+QtGui/qmime.h
+QtGui/qmovie.h
+QtGui/qpagesetupdialog.h
+QtGui/qpaintdevice.h
+QtGui/qpaintengine.h
+QtGui/qpainter.h
+QtGui/qpainterpath.h
+QtGui/qpalette.h
+QtGui/qpen.h
+QtGui/qpictureformatplugin.h
+QtGui/qpicture.h
+QtGui/qpixmapcache.h
+QtGui/qpixmap.h
+QtGui/qplastiquestyle.h
+QtGui/qpolygon.h
+QtGui/qprintdialog.h
+QtGui/qprintengine.h
+QtGui/qprinter.h
+QtGui/qprogressbar.h
+QtGui/qprogressdialog.h
+QtGui/qproxymodel.h
+QtGui/qpushbutton.h
+QtGui/qradiobutton.h
+QtGui/qregion.h
+QtGui/qrgb.h
+QtGui/qrubberband.h
+QtGui/qscrollarea.h
+QtGui/qscrollbar.h
+QtGui/qsessionmanager.h
+QtGui/qshortcut.h
+QtGui/qsizegrip.h
+QtGui/qsizepolicy.h
+QtGui/qslider.h
+QtGui/qsortfilterproxymodel.h
+QtGui/qsound.h
+QtGui/qspinbox.h
+QtGui/qsplashscreen.h
+QtGui/qsplitter.h
+QtGui/qstackedlayout.h
+QtGui/qstackedwidget.h
+QtGui/qstandarditemmodel.h
+QtGui/qstatusbar.h
+QtGui/qstringlistmodel.h
+QtGui/qstylefactory.h
+QtGui/qstyle.h
+QtGui/qstyleoption.h
+QtGui/qstylepainter.h
+QtGui/qstyleplugin.h
+QtGui/qsyntaxhighlighter.h
+QtGui/qsystemtrayicon.h
+QtGui/qtabbar.h
+QtGui/qtableview.h
+QtGui/qtablewidget.h
+QtGui/qtabwidget.h
+QtGui/qtextbrowser.h
+QtGui/qtextcursor.h
+QtGui/qtextdocumentfragment.h
+QtGui/qtextdocument.h
+QtGui/qtextedit.h
+QtGui/qtextformat.h
+QtGui/qtextlayout.h
+QtGui/qtextlist.h
+QtGui/qtextobject.h
+QtGui/qtextoption.h
+QtGui/qtexttable.h
+QtGui/qtoolbar.h
+QtGui/qtoolbox.h
+QtGui/qtoolbutton.h
+QtGui/qtooltip.h
+QtGui/qtreeview.h
+QtGui/qtreewidget.h
+QtGui/qtreewidgetitemiterator.h
+QtGui/qundogroup.h
+QtGui/qundostack.h
+QtGui/qundoview.h
+QtGui/qvalidator.h
+QtGui/qvboxlayout.h
+QtGui/qvfbhdr.h
+QtGui/qwhatsthis.h
+QtGui/qwidgetaction.h
+QtGui/qwidget.h
+QtGui/qwindowdefs.h
+QtGui/qwindowsstyle.h
+QtGui/qwindowsxpstyle.h
+QtGui/qwmatrix.h
+QtGui/qworkspace.h
+QtGui/qx11embed_x11.h
+QtGui/qx11info_x11.h
+QtNetwork/qabstractsocket.h
+QtNetwork/qftp.h
+QtNetwork/qhostaddress.h
+QtNetwork/qhostinfo.h
+QtNetwork/qhttp.h
+QtNetwork/qnetworkinterface.h
+QtNetwork/qnetworkproxy.h
+QtNetwork/qtcpserver.h
+QtNetwork/qtcpsocket.h
+QtNetwork/qudpsocket.h
+QtNetwork/qurlinfo.h
+QtOpenGL/qglcolormap.h
+QtOpenGL/qglframebufferobject.h
+QtOpenGL/qgl.h
+QtOpenGL/qglpixelbuffer.h
+Qt/qiconset.h
+QtSql/qsqldatabase.h
+QtSql/qsqldriver.h
+QtSql/qsqldriverplugin.h
+QtSql/qsqlerror.h
+QtSql/qsqlfield.h
+QtSql/qsql.h
+QtSql/qsqlindex.h
+QtSql/qsqlquery.h
+QtSql/qsqlquerymodel.h
+QtSql/qsqlrecord.h
+QtSql/qsqlrelationaldelegate.h
+QtSql/qsqlrelationaltablemodel.h
+QtSql/qsqlrelation.h
+QtSql/qsqlresult.h
+QtSql/qsqltablemodel.h
+QtSvg/qsvgrenderer.h
+QtSvg/qsvgwidget.h
+QtUiTools/quiloader.h
+QtXml/qdom.h
+QtXml/qxml.h

Modified: trunk/smoke/kde/kde_header_list
===================================================================
--- trunk/smoke/kde/kde_header_list	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/kde/kde_header_list	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,6 +1,10 @@
-dcopclient.h
-dcopobject.h
-dcopref.h
+dnssd/domainbrowser.h
+dnssd/publicservice.h
+dnssd/query.h
+dnssd/remoteservice.h
+dnssd/servicebase.h
+dnssd/servicebrowser.h
+dnssd/settings.h
 dom/css_rule.h
 dom/css_stylesheet.h
 dom/css_value.h
@@ -30,32 +34,34 @@
 dom/html_misc.h
 dom/html_object.h
 dom/html_table.h
+fixx11h.h
 kaboutapplication.h
 kaboutdata.h
 kaboutdialog.h
 kaboutkde.h
+kacceleratormanager.h
 kaccelgen.h
-kaccel.h
-kaccelmanager.h
-kactionclasses.h
+kacl.h
 kactioncollection.h
 kaction.h
-kactionshortcutlist.h
+kactionmenu.h
+kactionselector.h
 kactivelabel.h
 kallocator.h
 kanimwidget.h
-kapp.h
 kapplication.h
 karchive.h
 kar.h
 karrowbutton.h
+kascii.h
+kassistantdialog.h
 kasyncio.h
-kaudioplayer.h
-kauthicon.h
+kauthorized.h
 kautomount.h
+kautostart.h
+kcomponentdata.h
 kbookmarkbar.h
 kbookmarkdombuilder.h
-kbookmarkdrag.h
 kbookmarkexporter.h
 kbookmark.h
 kbookmarkimporter_crash.h
@@ -66,237 +72,304 @@
 kbookmarkimporter_opera.h
 kbookmarkmanager.h
 kbookmarkmenu.h
+kbookmarkmenu_p.h
 kbookmarknotifier.h
 kbufferedio.h
+kbufferedsocket.h
 kbugreport.h
+kbuildsycocaprogressdialog.h
 kbuttonbox.h
+kbuttongroup.h
 kcalendarsystemfactory.h
 kcalendarsystem.h
-kcatalogue.h
+kcatalog.h
 kcharselect.h
 kcharsets.h
+kclientsocketbase.h
 kclipboard.h
 kcmdlineargs.h
-kcmenumngr.h
-kcmodule.h
+kcmodulecontainer.h
 kcmoduleinfo.h
 kcmoduleloader.h
+kcmoduleproxy.h
 kcmultidialog.h
-kcolorbtn.h
+kcodecs.h
 kcolorbutton.h
 kcolorcombo.h
-kcolordialog.h
-kcolordlg.h
-kcolordrag.h
+kcolormimedata.h
+kcolorvalueselector.h
 kcombiview.h
 kcombobox.h
 kcommand.h
 kcompletionbox.h
 kcompletion.h
-kconfigdialog.h
-kconfigskeleton.h
+kcompositejob.h
 kconfigbackend.h
 kconfigbase.h
 kconfigdata.h
+kconfigdialog.h
+kconfigdialogmanager.h
 kconfig.h
+kconfigskeleton.h
 kcpuinfo.h
 kcrash.h
 kcursor.h
 kcustommenueditor.h
-kdatastream.h
+kdatagramsocket.h
 kdatatool.h
 kdatepicker.h
-kdatepik.h
-kdatetbl.h
+kdatetime.h
 kdatetimewidget.h
 kdatewidget.h
-kdcopactionproxy.h
-kdcoppropertyproxy.h
-kdcopservicestarter.h
-kdebugclasses.h
+kdbusservicestarter.h
 kdebug.h
+kdedesktopmimetype.h
 kdedmodule.h
+kdefakes.h
+kde_file.h
+kdelibs_export.h
+kdemacros.h
+kdeprint/kpreloadobject.h
+kdeprint/kprintdialogpage.h
 kdesktopfile.h
 kde_terminal_interface.h
 kdeversion.h
-kdialogbase.h
+kdialogbuttonbox.h
 kdialog.h
 kdirlister.h
+kdirmodel.h
 kdirnotify.h
-kdirnotify_stub.h
 kdiroperator.h
 kdirselectdialog.h
 kdirsize.h
 kdirwatch.h
 kdiskfreesp.h
-kdockwidget.h
-kdockwindow.h
 kdrawutil.h
-kdualcolorbtn.h
-kdualcolorbutton.h
-keditcl.h
 keditlistbox.h
 kedittoolbar.h
 kemailsettings.h
-kextendedsocket.h
-kextsock.h
-kfiledetailview.h
+kencodingfiledialog.h
 kfiledialog.h
 kfilefiltercombo.h
 kfilefilter.h
 kfile.h
-kfileiconview.h
 kfileitem.h
 kfilemetainfo.h
 kfilepreview.h
-kfilesharedlg.h
 kfileshare.h
 kfiletreebranch.h
-kfiletreeview.h
-kfiletreeviewitem.h
 kfileview.h
 kfilterbase.h
 kfilterdev.h
 kfinddialog.h
 kfind.h
-kfontcombo.h
+kfontaction.h
 kfontdialog.h
 kfontrequester.h
-kgenericfactory.h
+kfontsizeaction.h
 kglobalaccel.h
 kglobal.h
 kglobalsettings.h
 kguiitem.h
+khbox.h
 khelpmenu.h
 khtmldefaults.h
 khtml_events.h
 khtml_part.h
 khtml_settings.h
 khtmlview.h
-kicondialog.h
 kiconeffect.h
+kiconengine.h
+kicon.h
 kiconloader.h
 kicontheme.h
-kiconview.h
 kidna.h
 kimageeffect.h
 kimagefilepreview.h
 kimageio.h
 kinputdialog.h
 kinstance.h
+kio/authinfo.h
+kiobuffer.h
+kio/chmodjob.h
+kio/connection.h
+kio/copyjob.h
+kio/davjob.h
+kio/defaultprogress.h
+kio/deletejob.h
+kio/file.h
+kio/filejob.h
+kio/forwardingslavebase.h
+kio/global.h
+kio/http.h
+kio/http_slave_defaults.h
+kio/ioslave_defaults.h
+kio/jobclasses.h
+kio/job.h
+kio/jobuidelegate.h
+kio/kntlm.h
+kio/metainfojob.h
+kio/netaccess.h
+kio/observer.h
+kio/passdlg.h
+kio/paste.h
+kio/previewjob.h
+kio/progressbase.h
+kio/renamedlg.h
+kio/safesite.h
+kio/scheduler.h
+kio/sessiondata.h
+kio/skipdlg.h
+kio/slavebase.h
+kio/slaveconfig.h
+kio/slave.h
+kio/slaveinterface.h
+kio/statusbarprogress.h
+kio/tcpslavebase.h
+kio/thumbcreator.h
+kio/uiserver.h
 kipc.h
-kjanuswidget.h
+kjob.h
+kjobuidelegate.h
 kkeybutton.h
 kkeydialog.h
-kkeynative.h
-klargefile.h
+kkeyserver.h
+kkeyserver_x11.h
+klanguagebutton.h
+klauncher_iface.h
 kled.h
 klibloader.h
-klineeditdlg.h
 klineedit.h
-klistbox.h
-klistview.h
-klistviewsearchline.h
 klocale.h
+klocalizedstring.h
+klockfile.h
 kmacroexpander.h
 kmainwindow.h
-kmainwindowiface.h
 kmanagerselection.h
-kmdcodec.h
-kmdichildarea.h
-kmdichildfrmcaption.h
-kmdichildfrm.h
-kmdichildview.h
-kmdidefines.h
-kmdiiterator.h
-kmdilistiterator.h
-kmdimainfrm.h
-kmdinulliterator.h
-kmditaskbar.h
-kmditoolviewaccessor.h
+kmediaplayer/player.h
+kmediaplayer/view.h
 kmenubar.h
+kmenu.h
 kmessagebox.h
+kmessageboxmessagehandler.h
+kmessage.h
 kmimemagic.h
 kmimesourcefactory.h
+kmimetypechooser.h
 kmimetype.h
 kmimetyperesolver.h
+kmimetypetrader.h
 kmountpoint.h
-kmultipledrag.h
 kmultitabbar.h
+knetworkinterface.h
+knewstuff/downloaddialog.h
+knewstuff/engine.h
+knewstuff/entry.h
+knewstuff/knewstuffbutton.h
+knewstuff/knewstuffgeneric.h
+knewstuff/knewstuff.h
+knewstuff/knewstuffsecure.h
+knewstuff/providerdialog.h
+knewstuff/provider.h
+knfsshare.h
+knotification.h
+knotificationrestrictions.h
 knotifyclient.h
+knotifyconfigwidget.h
 knotifydialog.h
 knuminput.h
 knumvalidator.h
 kopenssl.h
 kopenwith.h
+kpagedialog.h
+kpagemodel.h
+kpageview.h
+kpagewidget.h
+kpagewidgetmodel.h
 kpalette.h
-kpanelapplet.h
-kpanelappmenu.h
-kpanelextension.h
-kpanelmenu.h
-kpassdlg.h
+kparts/browserextension.h
+kparts/browserinterface.h
+kparts/browserrun.h
+kparts/componentfactory.h
+kparts/event.h
+kparts/factory.h
+kparts/historyprovider.h
+kparts/mainwindow.h
+kparts/part.h
+kparts/partmanager.h
+kparts/plugin.h
+kparts/statusbarextension.h
 kpassivepopup.h
+kpassivepopupmessagehandler.h
+kpassworddialog.h
+kpastetextaction.h
 kpixmapeffect.h
-kpixmap.h
-kpixmapio.h
 kpixmapprovider.h
+kpixmapregionselectordialog.h
+kpixmapregionselectorwidget.h
 kpixmapsplitter.h
+kplugininfo.h
 kpluginselector.h
-kplugininfo.h
-kpopupmenu.h
-kpreferencesdialog.h
-kpreferencesmodule.h
 kpreviewwidgetbase.h
 kprintaction.h
 kprinter.h
-kdeprint/kpreloadobject.h
 kprocctrl.h
 kprocess.h
 kprocio.h
-kprogress.h
+kprogressbar.h
+kprogressdialog.h
 kpropertiesdialog.h
 kpropsdlg.h
 kprotocolinfo.h
 kprotocolmanager.h
 kpty.h
 kpushbutton.h
+krandom.h
 krandomsequence.h
 krecentdocument.h
+krecentfilesaction.h
 kregexpeditorinterface.h
-kregexp.h
+kremoteencoding.h
 kreplacedialog.h
 kreplace.h
+kresolver.h
 krestrictedline.h
+kreverseresolver.h
 krfcdate.h
-krootpixmap.h
-krootprop.h
 kruler.h
 krun.h
+ksambashare.h
 ksavefile.h
 kscan.h
-ksconfig.h
-kscreensaver.h
-kscreensaver_vroot.h
-kselect.h
+kselectaction.h
+kselector.h
+kseparatoraction.h
 kseparator.h
+kserversocket.h
 kservicegroup.h
 kservice.h
+kserviceoffer.h
 kservicetype.h
-ksharedpixmap.h
+kservicetypeprofile.h
+kservicetypetrader.h
+ksettings/componentsdialog.h
+ksettings/dialog.h
+ksettings/dispatcher.h
+ksettings/pluginpage.h
 ksharedptr.h
 kshellcompletion.h
 kshell.h
+kshortcutdialog.h
 kshortcut.h
-kshortcutlist.h
-kshred.h
 ksimpleconfig.h
 ksmimecrypto.h
-ksockaddr.h
-ksock.h
+ksocketaddress.h
+ksocketbase.h
+ksocketdevice.h
 ksocks.h
-ksortablevaluelist.h
-kspelldlg.h
-kspell.h
+ksockssocketdevice.h
+ksortablelist.h
+ksplashscreen.h
 ksqueezedtextlabel.h
 ksslall.h
 ksslcertchain.h
@@ -309,7 +382,6 @@
 ksslconnectioninfo.h
 kssl.h
 ksslinfodlg.h
-ksslkeygen.h
 ksslpeerinfo.h
 ksslpemcallback.h
 ksslpkcs12.h
@@ -326,114 +398,72 @@
 kstatusbar.h
 kstdaccel.h
 kstdaction.h
-kstddirs.h
 kstdguiitem.h
+kstreamsocket.h
 kstringhandler.h
 kstringvalidator.h
-kstyle.h
+ksvgrenderer.h
 ksycocaentry.h
 ksycoca.h
 ksycocatype.h
-ksyntaxhighlighter.h
-ksystemtray.h
+ksystemtrayicon.h
 ktabbar.h
 ktabctl.h
 ktabwidget.h
 ktar.h
 ktempdir.h
 ktempfile.h
+ktemporaryfile.h
 ktextbrowser.h
 ktextedit.h
-ktimewidget.h
+ktimezones.h
+ktimezonewidget.h
 ktip.h
-ktoolbarbutton.h
+ktoggleaction.h
+ktogglefullscreenaction.h
+ktoggletoolbaraction.h
 ktoolbar.h
-ktoolbarradiogroup.h
+ktoolbarlabelaction.h
+ktoolbarpopupaction.h
+ktoolbarspaceraction.h
+ktoolinvocation.h
 ktrader.h
+ktreewidgetsearchline.h
 ktypelist.h
-kuniqueapp.h
+ktzfiletimezone.h
 kuniqueapplication.h
-kunload.h
 kurifilter.h
-kurlbar.h
 kurlcombobox.h
 kurlcompletion.h
-kurldrag.h
 kurl.h
 kurllabel.h
 kurlpixmapprovider.h
 kurlrequesterdlg.h
 kurlrequester.h
-kuserprofile.h
+kuser.h
+kvbox.h
 kvmallocator.h
-kwindowinfo.h
+kwallet.h
 kwindowlistmenu.h
 kwin.h
 kwinmodule.h
-kwizard.h
 kwordwrap.h
+kxerrorhandler.h
 kxmessages.h
 kxmlguibuilder.h
 kxmlguiclient.h
 kxmlguifactory.h
-kxmlgui.h
+kxyselector.h
 kzip.h
-kparts/browserextension.h
-kparts/browserinterface.h
-kparts/browserrun.h
-kparts/componentfactory.h
-kparts/dockmainwindow.h
-kparts/event.h
-kparts/factory.h
-kparts/genericfactory.h
-kparts/historyprovider.h
-kparts/mainwindow.h
-kparts/part.h
-kparts/partmanager.h
-kparts/plugin.h
-kparts/pluginselectormodule.h
-kparts/statusbarextension.h
-kio/authinfo.h
-kio/chmodjob.h
-kio/connection.h
-kio/davjob.h
-kio/defaultprogress.h
-kio/file.h
-kio/global.h
-kio/http.h
-kio/http_slave_defaults.h
-kio/ioslave_defaults.h
-kio/jobclasses.h
-kio/job.h
-kio/kdesasl.h
-kio/kmdbase.h
-kio/kmdcodec.h
-kio/kpac.h
-kio/metainfojob.h
-kio/netaccess.h
-kio/observer.h
-kio/passdlg.h
-kio/paste.h
-kio/previewjob.h
-kio/progressbase.h
-kio/renamedlg.h
-kio/scheduler.h
-kio/sessiondata.h
-kio/skipdlg.h
-kio/slavebase.h
-kio/slaveconfig.h
-kio/slave.h
-kio/slaveinterface.h
-kio/statusbarprogress.h
-kio/tcpslavebase.h
-kio/thumbcreator.h
-kio/uiserver.h
-kio/uiserver_stub.h
-netwm_def.h
 netwm.h
-knewstuff/knewstuff.h
-knewstuff/knewstuffsecure.h
-knewstuff/engine.h
-knewstuff/entry.h
-knewstuff/provider.h
-
+renamedlgplugin.h
+sonnet/backgroundchecker.h
+sonnet/configdialog.h
+sonnet/configwidget.h
+sonnet/defaultdictionary.h
+sonnet/dialog.h
+sonnet/filter.h
+sonnet/highlighter.h
+sonnet/loader.h
+sonnet/settings.h
+sonnet/speller.h

Added: trunk/smoke/kde/qtguess.pl.cmake
===================================================================
--- trunk/smoke/kde/qtguess.pl.cmake	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/kde/qtguess.pl.cmake	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,422 @@
+#!/usr/bin/perl
+
+# qtguess.pl : check how Qt was compiled. Issue a list of all defined QT_NO_* macros, one per line.
+#
+# author:  germain Garand <germain at ebooksfrance.com>
+# licence: GPL v.2
+
+# options: -q: be quieter
+#	   -o file: redirect output to "file". (default: ./qtdefines)
+#	   -t [0..15]: set the testing threshold (see below)
+#	   -f "flags": additional compiler flags/parameters
+
+use Getopt::Std;
+
+use vars qw/$opt_f $opt_o $opt_p/;
+
+getopts('qo:f:t:');
+
+# Threshold :
+#	 0 - test basic Qt types/classes
+#	 5 - test higher level, non-gui classes
+#	 8 - test options of the above (ex: QT_NO_IMAGE_SMOOTHSCALE)
+#	10 - test basic widgets
+#	12 - test composite widgets
+#	13 - test widgets inheriting composite widgets
+#	15 - test goodies (default)
+
+my $default_threshold = @qt_test_threshold@;
+my $cc = "@CMAKE_CXX_COMPILER@";
+my $ccflags = $opt_f || "@CMAKE_CXX_FLAGS@";
+
+my $nspaces = 50;
+
+my %qtdefs=();
+my %qtundefs=();
+
+my $tmp = gettmpfile();
+my $qtinc = '@QT_INCLUDE_DIR@';
+my $allinc = '@all_includes@';
+my $alllib = '-L at QT_LIBRARY_DIR@';
+my $qtflags = '@qtflags@';
+#my %x;
+#$x{'LIBPNG'}  =   '@LIBPNG@';
+#$x{'LIBJPEG'} =   '@LIBJPEG@';
+#$x{'LIBSM'}   =   '@LIBSM@';
+#$x{'LIBSOCKET'} = '@LIBSOCKET@';
+#$x{'LIBDL'}      = '@LIBDL@';
+#$x{'LIBRESOLV'}  = '@LIBRESOLV@';
+#$x{'LIB_X11'} =   '@LIB_X11@';
+#$x{'X_PRE_LIBS'} = '@X_PRE_LIBS@';
+#$x{'LIB_X11'} =~ s/\$\((.*?)\)/$x{$1}/g;
+#
+#$qtflags =~ s/\$\((.*?)\)/$x{$1}/g;
+
+ -e "$qtinc/QtCore/qglobal.h" or die "Invalid Qt include directory.\n";
+
+my $ccmd = "$cc $ccflags $allinc $alllib -o $tmp $tmp.cpp $qtflags";
+
+my $threshold = defined($opt_t)?$opt_t : $default_threshold;
+$threshold >= 0 or die "invalid testing threshold: $threshold\n";
+
+print "Checking how Qt was built... \n";
+print "Threshold is set to $threshold\n" unless $opt_q;
+
+my($count, $used, $total);
+map{ $tests{$_}->[2]>=$threshold ? ($used++, $total++):$total++ } keys %tests;
+
+print "Number of defines to be tested : $used/$total\n\n" unless $opt_q;
+open( QTDEFS, ">>".($opt_o || "qtdefines") ) or die "Can't open output file: $!\n";
+
+grab_qglobal_symbols();
+preliminary_test();
+perform_all_tests();
+
+print +scalar(keys %qtdefs) . " defines found.\n";
+
+print QTDEFS join("\n", keys %qtdefs), "\n";
+close;
+
+#--------------------------------------------------------------#
+
+sub gettmpfile
+{
+	my $tmpdir = $ENV{'TMP'} || ".";
+	my $tmpname = $$."-qtguess";
+	while( -e "$tmpdir/$tmpname" || -e "$tmpdir/${tmpname}.cpp" )
+	{
+		$tmpname .= int (rand * 9);
+	}
+	return "$tmpdir/$tmpname";
+}
+
+#--------------------------------------------------------------#
+
+sub grab_qglobal_symbols
+{
+	my $cmd = "$cc -E -D__cplusplus -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2>/dev/null";
+	my $symbols = `$cmd`;
+        for(0..1)
+        {
+	    if( check_exit_status($?) )
+	    {
+		while( $symbols =~/^#\s*define\s*(QT_\S+)/gm )
+		{
+			$qtdefs{$1} = 1;
+		}
+		print "Found ". scalar( keys %qtdefs )." predefined symbol".((scalar( keys %qtdefs ) -1)?"s":"")." in qglobal.h\n" unless ($opt_q or !(keys %qtdefs));
+		while( $symbols =~/^#\s*define\s*QT_MODULE_(\S+)/gm )
+		{
+			$qtundefs{"QT_NO_$1"} = 1;
+		}
+		print "Found ". scalar( keys %qtundefs )." undefined symbol".((scalar( keys %qtundefs ) -1)?"s":"")." in qglobal.h\n" unless ($opt_q or !(keys %qtundefs));
+                last;
+	    }
+	    elsif(! $_) # first try
+	    {
+		print  "Failed to run $cmd.\nTrying without __cplusplus (might be already defined)\n";
+                $cmd = "$cc -E -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2>/dev/null";
+                $symbols = `$cmd`;
+                next;
+	    }
+        }
+}
+
+#--------------------------------------------------------------#
+
+sub preliminary_test
+{
+	my $msg = "Trying to compile and link a small program...";
+	print $msg, " " x ($nspaces - length($msg) + 8);
+	open( OUT, ">${tmp}.cpp" ) or die "Failed to open temp file ${tmp}.cpp: $!\n";
+	my $simple=q?
+		#include <QtGui/qapplication.h>
+		int main( int argc, char **argv )
+		{
+			QApplication foo( argc, argv );
+			return 0;
+		}
+	?;
+	print OUT $simple;
+	close OUT;
+        my $out = `$ccmd 2>&1`;
+	if( !check_exit_status($?) )
+	{
+		die <<"EOF";
+
+FAILED : check your configuration.
+Failed program was:
+$simple
+Compiled with:
+$ccmd
+Compiler output:
+$out
+EOF
+	}
+	else
+	{
+		print "OK\n";
+	}
+}
+
+#--------------------------------------------------------------#
+
+sub perform_all_tests
+{
+	foreach ( sort { $tests{$a}->[2] <=> $tests{$b}->[2]} keys %tests)
+	{
+		$tests{$_}->[2] < $threshold and next;
+		($qtdefs{$_} || $qtundefs{$_}) and do
+		{
+			print "\rSkipping $_ (in qglobal.h)".( " " x (($nspaces-16) - length($_)) ).($qtundefs{$_}?"*Undefined*":" [Defined]").($opt_q?"":"\n");
+			next
+		};
+		print "\rTesting $_".( " " x ($nspaces - length($_)) );
+		open( OUT, ">${tmp}.cpp" ) or die "Failed to open temp file ${tmp}.cpp: $!\n";
+		foreach $def(keys %qtdefs)
+		{
+			print OUT "#define $def\n";
+		}
+		foreach $inc(split /,\s*/, $tests{$_}->[0])
+		{
+			print OUT "#include <$inc>\n";
+		}
+		print OUT "#include <QtCore/qfeatures.h>\n";
+		print OUT $tests{$_}->[3] if $tests{$_}->[3]; # need to define some classes ?
+		print OUT qq?
+
+		int main( int argc, char ** argv)
+		{
+		$tests{$_}->[1]
+		return 0;
+		}
+
+		?;
+		close OUT;
+
+                my $out = `$ccmd 2>&1`;
+		my $ok = check_exit_status($?);
+		if( !$ok )
+		{
+			$qtdefs{$_} = 1;
+		}
+		print +$opt_q ? ++$count."/$used" : ( $ok ? "*Undefined*\n" : " [Defined]\n" );
+	}
+	$opt_q && print "\n";
+}
+
+#--------------------------------------------------------------#
+
+sub check_exit_status
+{
+	my $a = 0xFFFF & shift;
+	if( !$a )
+	{
+		return 1;
+	}
+	elsif( $a == 0xFF00 )
+	{
+		die "\nSystem call failed: $!\n";
+	}
+	elsif( $a > 0x80 )
+	{
+		# non-zero status.
+	}
+	else
+	{
+		if( $a & 0x80 )
+		{
+			die "\n$cc coredumped with signal ". ($a & ~0x80);
+		}
+		die "\n$cc interrupted by signal $a\n";
+	}
+	return 0;
+}
+
+#--------------------------------------------------------------#
+
+END
+{
+	unlink $tmp if -e $tmp;
+	unlink "${tmp}.cpp" if -e "${tmp}.cpp";
+}
+
+#--------------------------------------------------------------#
+
+BEGIN {
+
+# "DEFINE" => ["header-1.h,... header-n.h", "main() code", priority, "Definitions (if needed)"]
+
+our %tests = (
+	"QT_NO_ACCESSIBILITY" =>        ["QtGui/qaccessible.h", "QAccessibleEvent event(QEvent::AccessibilityHelp, 0);", 15],
+	"QT_NO_ACTION" =>		["QtGui/qaction.h", "QAction foo( (QObject*)NULL );", 5],
+	#QT_NO_BIG_CODECS
+ 	"QT_NO_BUTTONGROUP" =>		["QtGui/qbuttongroup.h", "QButtonGroup foo( (QObject*)NULL );", 12],
+ 	"QT_NO_CHECKBOX" =>		["QtGui/qcheckbox.h", "QCheckBox foo( (QWidget*)NULL );", 10],
+	"QT_NO_CLIPBOARD" => 		["QtGui/qapplication.h, QtGui/qclipboard.h", q?
+						QApplication foo( argc, argv );
+						QClipboard *baz= foo.clipboard();
+					?, 5],
+ 	"QT_NO_COLORDIALOG" =>		["QtGui/qcolordialog.h", "QColorDialog::customCount();", 12],
+	#QT_NO_COLORNAMES
+ 	"QT_NO_COMBOBOX" =>		["QtGui/qcombobox.h", "QComboBox foo( (QWidget*)NULL );", 10],
+	"QT_NO_COMPAT" =>		["QtGui/qfontmetrics.h", q?
+						QFontMetrics *foo= new QFontMetrics( QFont() );
+						int bar = foo->width( 'c' );
+					?, 0],
+	"QT_NO_COMPONENT" =>		["QtGui/qapplication.h", q?
+ 						QApplication foo( argc, argv );
+ 						foo.addLibraryPath( QString::null );
+					?, 5],
+	#QT_NO_COP
+ 	"QT_NO_CURSOR" =>		["QtGui/qcursor.h", "QCursor foo;", 5],
+ 	"QT_NO_DATASTREAM" =>		["QtCore/qdatastream.h", "QDataStream foo;", 5],
+ 	"QT_NO_DATETIMEEDIT" =>		["QtGui/qdatetimeedit.h", "QTimeEdit foo;", 12],
+	"QT_NO_DIAL" =>			["QtGui/qdial.h", "QDial foo;", 10],
+	"QT_NO_DIALOG" =>		["QtGui/qdialog.h", "QDialog foo;", 12],
+	"QT_NO_DIR" =>			["QtCore/qdir.h", "QDir foo;", 5],
+	#QT_NO_DIRECTPAINTER
+	"QT_NO_DOM" =>			["QtXml/qdom.h", "QDomDocumentType foo;", 5],
+	"QT_NO_DRAGANDDROP" =>		["QtGui/qevent.h", "QDropEvent foo( QDropEvent() );", 5],
+	"QT_NO_DRAWUTIL" =>		["QtGui/qdrawutil.h, QtGui/qcolor.h", "qDrawPlainRect( (QPainter *) NULL, 0, 0, 0, 0, QColor() );", 10],
+	#QT_NO_EFFECTS
+	"QT_NO_ERRORMESSAGE" => 	["QtGui/qerrormessage.h", "QErrorMessage foo( (QWidget*) NULL );", 13],
+	"QT_NO_FILEDIALOG" =>		["QtGui/qfiledialog.h", "QFileDialog foo();", 13],
+
+	"QT_NO_FONTDATABASE" =>		["QtGui/qfontdatabase.h", "QFontDatabase foo;", 5],
+	"QT_NO_FONTDIALOG" => 		["QtGui/qfontdialog.h",   "QFontDialog::getFont( (bool *)NULL );", 12],
+	"QT_NO_FRAME" => 		["QtGui/qframe.h", "QFrame foo;", 10],
+	#QT_NO_FREETYPE
+ 	"QT_NO_FTP" =>	["QtNetwork/qftp.h", "QFtp foo;", 9],
+	"QT_NO_GROUPBOX" =>		["QtGui/qgroupbox.h", "QGroupBox foo;", 12],
+	#QT_NO_IMAGEFORMAT_BMP
+	#QT_NO_IMAGEFORMAT_JPEG
+	#QT_NO_IMAGEFORMATPLUGIN
+	#QT_NO_IMAGEFORMAT_PNG
+	#QT_NO_IMAGEFORMAT_PPM
+	#QT_NO_IMAGEFORMAT_XBM
+ 	"QT_NO_IMAGE_HEURISTIC_MASK" =>	["QtGui/qimage.h", q?
+						QImage *foo = new QImage;
+						foo->createHeuristicMask();
+					?, 8],
+	#QT_NO_IMAGE_TEXT
+	"QT_NO_IMAGEIO" => 		["QtGui/qbitmap.h, QtCore/qstring.h", q?
+						QBitmap foo( QString::fromLatin1("foobar") );
+					?, 5],
+	"QT_NO_LABEL" =>		["QtGui/qlabel.h", "QLabel foo( (QWidget*) NULL );", 10],
+	"QT_NO_LAYOUT" =>		["QtGui/qlayout.h", "QFoo foo;", 10, q?
+ 						class QFoo: public QLayout
+ 						{
+ 						public:
+ 						    QFoo() {};
+ 						    ~QFoo() {};
+ 						    void addItem( QLayoutItem * ) { };
+						    QSize sizeHint() const { return QSize(); }
+						    void setGeometry( const QRect & ) { };
+                            QLayoutItem* itemAt(int) const {return (QLayoutItem*) NULL;}
+                            QLayoutItem* takeAt(int) {return (QLayoutItem*) NULL;}
+                            int QFoo::count() const {return 0;}
+
+ 						};
+ 					?],
+	"QT_NO_LCDNUMBER" =>		["QtGui/qlcdnumber.h", "QLCDNumber foo;", 12],
+	"QT_NO_LINEEDIT" =>		["QtGui/qlineedit.h", "QLineEdit foo( (QWidget *) NULL );", 12],
+	"QT_NO_LISTVIEW" =>		["QtGui/qlistview.h", "QListView foo;", 13],
+	"QT_NO_MAINWINDOW" =>		["QtGui/qmainwindow.h", "QMainWindow foo;", 13],
+	"QT_NO_MATRIX" =>		["QtGui/qmatrix.h", "QMatrix foo;", 0],
+	"QT_NO_MENUBAR" =>		["QtGui/qmenubar.h", "QMenuBar foo;", 13],
+	"QT_NO_MESSAGEBOX" =>		["QtGui/qmessagebox.h", "QMessageBox foo;", 13],
+	"QT_NO_MOVIE" =>		["QtGui/qmovie.h", "QMovie foo;", 5],
+	"QT_NO_NETWORK" =>		["QtNetwork/qnetworkproxy.h", "QNetworkProxy foo;", 5],
+	#QT_NO_NETWORKPROXY
+	"QT_NO_PALETTE" =>		["QtGui/qpalette.h", "QPalette foo;", 5],
+	"QT_NO_PICTURE" =>		["QtGui/qpicture.h", "QPicture foo;", 5],
+	"QT_NO_PRINTER" =>		["QtGui/qprinter.h", "QPrinter foo();", 5],
+	"QT_NO_PRINTDIALOG" =>		["QtGui/qprintdialog.h", "QPrintDialog foo( (QPrinter*) NULL );", 13],
+	"QT_NO_PROCESS" =>		["QtCore/qprocess.h", "QProcess foo;", 5],
+	"QT_NO_PROGRESSBAR" =>		["QtGui/qprogressbar.h", "QProgressBar foo;", 12],
+	"QT_NO_PROGRESSDIALOG" =>	["QtGui/qprogressdialog.h", "QProgressDialog foo;", 13],
+	"QT_NO_PROPERTIES" =>		["QtCore/qmetaobject.h", "QMetaProperty foo;", 0],
+	"QT_NO_PUSHBUTTON" =>		["QtGui/qpushbutton.h", "QPushButton foo( (QWidget *) NULL );", 12],
+	"QT_NO_QUUID_STRING" =>		["QtCore/quuid.h", "QUuid foo( QString() );", 8],
+	"QT_NO_RADIOBUTTON" =>		["QtGui/qradiobutton.h", "QRadioButton foo( (QWidget *) NULL );", 12],
+	#QT_NO_QWS_ALPHA_CURSOR
+	#QT_NO_QWS_DECORATION_DEFAULT
+	#QT_NO_QWS_INPUTMETHODS
+	#QT_NO_QWS_KEYBOARD
+	#QT_NO_QWS_MOUSE
+	#QT_NO_QWS_MOUSE_AUTO
+	#QT_NO_QWS_MOUSE_MANUAL
+	#QT_NO_QWS_MULTIPROCESS
+	#QT_NO_QWS_PROPERTIES
+	#QT_NO_QWS_QPF
+	#QT_NO_RESIZEHANDLER
+	#QT_NO_RUBBERBAND
+	"QT_NO_SCROLLBAR" =>		["QtGui/qscrollbar.h", "QScrollBar foo( (QWidget *) NULL );", 12],
+	"QT_NO_SESSIONMANAGER" =>	["QtGui/qapplication.h", q?
+  						QApplication foo( argc, argv );
+  						foo.sessionId();
+					?, 15],
+	"QT_NO_SETTINGS" =>		["QtCore/qsettings.h", "QSettings foo;", 5],
+	#QT_NO_SHORTCUT
+	"QT_NO_SIGNALMAPPER" =>		["QtCore/qsignalmapper.h", "QSignalMapper foo( (QObject *) NULL );", 0],
+	"QT_NO_SIZEGRIP" =>		["QtGui/qsizegrip.h", "QSizeGrip foo( (QWidget *) NULL );", 10],
+	"QT_NO_SLIDER" =>		["QtGui/qslider.h", "QSlider foo( (QWidget *) NULL );", 12],
+	"QT_NO_SOUND" =>		["QtGui/qsound.h", "QSound foo( QString::null );", 5],
+	#QT_NO_SPINWIDGET
+	#QT_NO_SPLASHSCREEN
+	#QT_NO_STACKEDWIDGET
+	#QT_NO_STATUSBAR
+	#QT_NO_STATUSTIP
+	#QT_NO_STL
+	"QT_NO_STRINGLIST" =>		["qstringlist.h", "QStringList foo;", 0],
+	"QT_NO_STYLE_PLASTIQUE" =>		["QtGui/qplastiquestyle.h", "QPlastiqueStyle foo;", 16],
+ 	"QT_NO_STYLE_WINDOWSXP" =>	["QtGui/qwindowsxpstyle.h", "QWindowsXPStyle foo;", 16],
+ 	"QT_NO_STYLE_WINDOWS" =>	["QtGui/qwindowsstyle.h", "QWindowsStyle foo;", 16],
+	"QT_NO_STYLE_MAC" =>	["QtGui/macstyle.h", "QMacStyle foo;", 16],
+	"QT_NO_STYLE_CLEANLOOKS" =>	["QtGui/qcleanlooksstyle.h", "QCleanlooksStyle foo;", 16],
+    "QT_NO_TABBAR" =>               ["QtGui/qtabbar.h", "QTabBar foo;", 10],
+	"QT_NO_TABLEVIEW" =>		["QtGui/qtableview.h", "QTableView foo;", 16],
+    "QT_NO_TABWIDGET" =>            ["QtGui/qtabwidget.h", "QTabWidget foo;", 10],
+    "QT_NO_TEXTBROWSER" =>          ["QtGui/qtextbrowser.h", "QTextBrowser foo;", 14],
+    "QT_NO_TEXTCODEC" =>            ["QtCore/qtextcodec.h", "QTextCodec::codecForMib(1);", 5],
+    "QT_NO_TEXTCODECPLUGIN" =>      ["QtCore/qtextcodecplugin.h, QtCore/qstringlist.h, QtCore/qlist.h, QtCore/qtextcodec.h", "QFoo foo;", 6, q? 
+						class QFoo: public QTextCodecPlugin
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            QList<QByteArray> names() const {return QList<QByteArray>();}
+                            QList<int>mibEnums() const {return QList<int>();}
+                            QTextCodec *createForName( const QByteArray & name ) {return (QTextCodec *)NULL;}
+                            QTextCodec *createForMib( int mib ) {return (QTextCodec *)NULL;}
+                            QList<QByteArray> aliases() const {return QList<QByteArray>();}
+						};
+						Q_EXPORT_PLUGIN2( "Foo", QFoo )
+					?],
+	#QT_NO_TEXTDATE
+ 	"QT_NO_TEXTEDIT" =>		["QtGui/qtextedit.h", "QTextEdit foo;", 13], 
+    "QT_NO_TEXTSTREAM" =>           ["qtextstream.h", "QTextStream foo;", 5],
+    "QT_NO_THREAD" =>           ["QtCore/qthread.h", "QFoo foo;", 5, q?
+						class QFoo: public QThread
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            void run() {}
+						};
+					?],
+    "QT_NO_TOOLBAR" =>              ["QtGui/qtoolbar.h", "QToolBar foo;", 10],
+    "QT_NO_TOOLBUTTON" =>           ["QtGui/qtoolbutton.h", "QToolButton foo((QWidget *) NULL );", 12],
+    "QT_NO_TOOLTIP" =>              ["QtGui/qtooltip.h", "QToolTip::palette();", 10],
+	#QT_NO_TRANSLATION
+	#QT_NO_UDPSOCKET
+	#QT_NO_URLINFO
+	#QT_NO_VALIDATOR
+    "QT_NO_VARIANT" =>              ["QtCore/qvariant.h", "QVariant foo;", 0],
+    "QT_NO_WHATSTHIS" =>            ["QtGui/qwhatsthis.h", "QWhatsThis::inWhatsThisMode();", 10],
+	"QT_NO_WHEELEVENT" =>		["QtGui/qevent.h", "QWheelEvent foo( QPoint(1,1), 1, (Qt::MouseButtons)1, 0 );", 5],
+	"QT_NO_XML" =>			["QtXml/qxml.h", "QXmlNamespaceSupport foo;", 5],
+	);
+
+}

Added: trunk/smoke/qt/CMakeLists.txt
===================================================================
--- trunk/smoke/qt/CMakeLists.txt	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/CMakeLists.txt	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,132 @@
+
+include(FindQScintilla)
+include(FindQwt)
+
+include_directories( ${QT_INCLUDES}  ${CMAKE_CURRENT_SOURCE_DIR}/../ ${CMAKE_CURRENT_SOURCE_DIR} )
+
+if(QSCINTILLA_FOUND)
+    include_directories( ${QSCINTILLA_INCLUDE_DIR} )
+endif(QSCINTILLA_FOUND)
+
+if(QWT_FOUND)
+    include_directories( ${QWT_INCLUDE_DIR} )
+endif(QWT_FOUND)
+
+IF(QT_QTDBUS_FOUND)
+    SET(QTDBUS_LIBRARY QtDBus)
+ENDIF(QT_QTDBUS_FOUND)
+
+# for qtguess.pl
+set(qt_test_threshold 10)
+set(qtflags "-lQtCore -lQtGui")
+FOREACH(filename ${QT_INCLUDES})
+    set(all_includes "-I${filename} ${all_includes}")
+ENDFOREACH(filename)
+
+configure_file(qtguess.pl.cmake ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl @ONLY)
+configure_file(generate.pl.cmake ${CMAKE_CURRENT_BINARY_DIR}/generate.pl @ONLY )
+
+# macro is defined in qt-copy/src/qbase.pri but couldn't be found by qtguess, so I append it manually
+file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/qtdefines "QT_NO_CAST_TO_ASCII\n")
+
+########### next target ###############
+
+add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_2.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_3.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_4.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_5.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_6.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_7.cpp 
+                ${CMAKE_CURRENT_BINARY_DIR}/x_8.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_9.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_10.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_11.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_12.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_13.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_14.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_15.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_16.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_17.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_18.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_19.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_20.cpp
+
+                  COMMAND ${PERL_EXECUTABLE} ARGS ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl
+                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl
+
+                  COMMAND ${PERL_EXECUTABLE} ARGS ${CMAKE_CURRENT_BINARY_DIR}/generate.pl
+                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/generate.pl
+
+                  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
+
+macro_add_file_dependencies( ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp ${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp )
+
+set(smokeqt_LIB_SRCS ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp  
+		${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_2.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_3.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_4.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_5.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_6.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_7.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_8.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_9.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_10.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_11.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_12.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_13.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_14.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_15.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_16.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_17.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_18.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_19.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_20.cpp
+)
+
+# kde4_add_library(smokeqt SHARED ${smokeqt_LIB_SRCS})
+add_library(smokeqt SHARED ${smokeqt_LIB_SRCS})
+
+target_link_libraries(smokeqt ${QT_QTCORE_LIBRARY} QtSvg QtGui QtNetwork QtSql QtOpenGL QtXml QtUiTools ${QTDBUS_LIBRARY} ${QSCINTILLA_LIBRARIES} ${QWT_LIBRARIES} )
+
+set_target_properties(smokeqt PROPERTIES VERSION 2.0.0 SOVERSION 2 )
+install(TARGETS smokeqt DESTINATION lib )
+
+
+########### install files ###############
+
+
+
+
+#original Makefile.am contents follow:
+
+#lib_LTLIBRARIES = libsmokeqt.la
+#
+## set the include path for X, qt and KDE
+#INCLUDES         = -I$(srcdir)/.. $(all_includes) -I$(qt_includes)/QtUiTools \
+#                   -I$(qt_includes)/QtDBus
+#
+#EXTRA_DIST=generate.pl.in qtguess.pl.in qt_smoke.h Makefile.am
+#
+## the library search path. 
+#libsmokeqt_la_LDFLAGS = -version-info 2:0:0 -no-undefined $(all_libraries) $(GLINC)
+#
+## the libraries to link against.
+#libsmokeqt_la_LIBADD   = $(LIB_QTCORE) $(LIB_QTGUI) $(LIB_QTNETWORK) \
+#						$(LIB_QTOPENGL) $(LIB_QTSQL) $(LIB_QTCORE) $(LIB_QTXML) $(LIB_QTSVG) \
+#						$(GLLIB) $(LIBQSCINTILLA) \
+#						-lQtSvg -lQtUiTools $(LIBQTDBUS) $(LIBQWT)
+#
+#x_sources = x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+#   x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+#   x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp
+#
+## which sources should be compiled for perlqtkde
+#libsmokeqt_la_SOURCES = smokedata.cpp $(x_sources)
+#
+#$(x_sources) smokedata.cpp:
+#	perl generate.pl
+#
+#CLEANFILES = $(libsmokeqt_la_SOURCES)

Added: trunk/smoke/qt/generate.pl.cmake
===================================================================
--- trunk/smoke/qt/generate.pl.cmake	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/generate.pl.cmake	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,254 @@
+#!/usr/bin/perl -w
+
+## Run this first, to generate the x_*.cpp files from the Qt headers
+## using kalyptus
+
+my $kalyptusdir = "@CMAKE_CURRENT_SOURCE_DIR@/../../kalyptus";
+
+use File::Basename;
+use File::Copy qw|cp|;
+use File::Compare;
+use File::Find;
+use Cwd;
+
+my $here = getcwd;
+my $outdir = $here . "/generate.pl.tmpdir";
+my $finaloutdir = $here;
+my $defines = "qtdefines";
+my $headerlist = "@CMAKE_CURRENT_SOURCE_DIR@/header_list";
+my $definespath = "$here/$defines";
+my $headerlistpath = "$headerlist";
+my $qscintilla_headerlist = "";
+my $qscintilla_headerlistpath = "";
+my $qtdbus_headerlist = "";
+my $qtdbus_headerlistpath = "";
+
+if("@QSCINTILLA_FOUND@" eq "YES")
+{
+ $qscintilla_headerlist = "@CMAKE_CURRENT_SOURCE_DIR@/qscintilla2_header_list";
+ $qscintilla_headerlistpath = "$here/$qscintilla_headerlist";
+}
+
+if("@QT_QTDBUS_FOUND@" eq "1")
+{
+ $qtdbus_headerlist = "@CMAKE_CURRENT_SOURCE_DIR@/qtdbus_header_list";
+ $qtdbus_headerlistpath = "$here/$qtdbus_headerlist";
+}
+
+if("@QWT_FOUND@" eq "YES")
+{
+ $qwt_headerlist = "@CMAKE_CURRENT_SOURCE_DIR@/qwt_header_list";
+ $qwt_headerlistpath = "$here/$qwt_headerlist";
+}
+
+## If srcdir != builddir, use headerlist from src
+$headerlistpath = $headerlist if ($headerlist =~ /^\//);
+if("@QSCINTILLA_FOUND@" eq "YES")
+{
+ $qscintilla_headerlistpath = $qscintilla_headerlist if ($qscintilla_headerlist =~ /^\//);
+}
+
+if("@QT_QTDBUS_FOUND@" eq "1")
+{
+ $qtdbus_headerlistpath = $qtdbus_headerlist if ($qtdbus_headerlist =~ /^\//);
+}
+
+if("@QWT_FOUND@" eq "YES")
+{
+ $qwt_headerlistpath = $qwt_headerlist if ($qwt_headerlist =~ /^\//);
+}
+## Note: outdir and finaloutdir should NOT be the same dir!
+
+# Delete all x_*.cpp files under outdir (or create outdir if nonexistent)
+if (-d $outdir) { system "rm -f $outdir/x_*.cpp"; } else { mkdir $outdir; }
+
+mkdir $finaloutdir unless (-d $finaloutdir);
+
+#  Load the QT_NO_* macros found in "qtdefines". They'll be passed to kalyptus
+my $macros="";
+if ( -e $definespath ){
+    print "Found '$defines'. Reading preprocessor symbols from there...\n";
+    $macros = " --defines=$definespath ";
+}
+
+mkdir $kalyptusdir, 0777;
+# Need to cd to kalyptus's directory so that perl finds Ast.pm etc.
+chdir "$kalyptusdir" or die "Couldn't go to $kalyptusdir (edit script to change dir)\n";
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %excludes = (
+    'qaccessible.h' => 1,  # Accessibility support is not compiled by defaut
+    'qassistantclient.h' => 1, # Not part of Qt (introduced in Qt-3.1)
+    'qmotif.h' => 1,       # 
+    'qmotifwidget.h' => 1, # Motif extension (introduced in Qt-3.1)
+    'qmotifdialog.h' => 1, #
+    'qxt.h' => 1, # Xt
+    'qxtwidget.h' => 1, # Xt
+    'qdns.h' => 1, # internal
+    'qgl.h' => 1, # OpenGL
+    'qglcolormap.h' => 1, # OpenGL
+    'qnp.h' => 1, # NSPlugin
+    'qttableview.h' => 1,  # Not in Qt anymore...
+    'qtmultilineedit.h' => 1,  # Not in Qt anymore...
+    'qwidgetfactory.h' => 1,  # Just an interface
+    'qsharedmemory.h' => 1, # "not part of the Qt API" they say
+    'qwindowsstyle.h' => 1, # Qt windowsstyle, plugin
+    'qmotifstyle.h' => 1,
+    'qcompactstyle.h' => 1,
+    'qinterlacestyle.h' => 1,
+    'qmotifplusstyle.h' => 1,
+    'qsgistyle.h' => 1,
+    'qplatinumstyle.h' => 1,
+    'qcdestyle.h' => 1,
+	 'qworkspace.h' => 1,
+    'qwindowsxpstyle.h' => 1 # play on the safe side 
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %includes;
+open(HEADERS, $headerlistpath) or die "Couldn't open $headerlistpath: $!\n";
+map { chomp ; $includes{$_} = 1 } <HEADERS>;
+close HEADERS;
+
+if("@QSCINTILLA_FOUND@" eq "YES")
+{
+ open(HEADERS, $qscintilla_headerlistpath) or die "Couldn't open $qscintilla_headerlistpath: $!\n";
+ map { chomp ; $includes{$_} = 1 } <HEADERS>;
+ close HEADERS;
+}
+
+if("@QT_QTDBUS_FOUND@" eq "1")
+{
+ open(HEADERS, $qtdbus_headerlistpath) or die "Couldn't open $qtdbus_headerlistpath: $!\n";
+ map { chomp ; $includes{$_} = 1 } <HEADERS>;
+ close HEADERS;
+}
+
+my %qwt_includes;
+if("@QWT_FOUND@" eq "YES")
+{
+ open(HEADERS, $qwt_headerlistpath) or die "Couldn't open $qwt_headerlistpath: $!\n";
+ map { chomp ; $qwt_includes{$_} = 1 } <HEADERS>;
+ close HEADERS;
+}
+ 
+# Can we compile the OpenGl module ?
+if("@QT_OPENGL_FOUND@" eq "YES")
+{
+    open(DEFS, $definespath);
+    my @defs = <DEFS>;
+    close DEFS;
+    if(!grep(/QT_NO_OPENGL/, @defs))
+    {
+      $excludes{'qgl.h'} = undef;
+      $excludes{'qglcolormap.h'} = undef;
+    }
+    else
+    {
+      print STDERR "Qt was not compiled with OpenGL support...\n Skipping QGL Classes.\n";
+    }
+}
+
+# List Qt headers, and exclude the ones listed above
+my @headers = ();
+
+$qtinc= '@QT_INCLUDE_DIR@';
+
+find(
+    {   wanted => sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qtinc);
+                if( !defined $excludes{$f} # Not excluded
+                     && $includes{$f}        # Known header
+                     && /\.h$/)     # Not a backup file etc. Only headers.
+                {
+                    my $header = $_;
+                    open(FILE, $_);
+                    my @header_lines = <FILE>;
+                    if (@header_lines == 1) {
+                        $line = $header_lines[0];
+                        if ($line =~ /^#include "(.*)"/) {
+                            push ( @headers, $qtinc . substr($1, 2) );
+                        } else {
+                            push ( @headers, $header );
+                        }
+                    } else {
+                        push ( @headers, $header );
+                    }
+                }
+	    	undef $includes{$f}   
+	     };
+	},
+	follow_fast => 1,
+	follow_skip => 2,
+	no_chdir => 1
+    }, $qtinc
+ );
+
+$qwtinc = '@QWT_INCLUDE_DIR@';
+
+find(
+    {   wanted => sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qwtinc);
+		push ( @headers, $_ )
+                if( !defined $excludes{$f} # Not excluded
+                     && $qwt_includes{$f}        # Known header
+                     && /\.h$/);     # Not a backup file etc. Only headers.
+	    	undef $qwt_includes{$f}   
+	     };
+	},
+	follow_fast => 1,
+	follow_skip => 2,
+	no_chdir => 1
+    }, $qwtinc
+ );
+ 
+# Launch kalyptus
+chdir "../smoke/qt";
+system "perl -I at kdebindings_SOURCE_DIR@/kalyptus @kdebindings_SOURCE_DIR@/kalyptus/kalyptus @ARGV --qt4 --globspace -fsmoke --name=qt $macros --no-cache --outputdir=$outdir @headers";
+my $exit = $? >> 8;
+exit $exit if ($exit);
+chdir "$kalyptusdir";
+
+# Generate diff for smokedata.cpp
+unless ( -e "$finaloutdir/smokedata.cpp" ) {
+    open( TOUCH, ">$finaloutdir/smokedata.cpp");
+    close TOUCH;
+}
+system "diff -u $finaloutdir/smokedata.cpp $outdir/smokedata.cpp > $outdir/smokedata.cpp.diff";
+
+# Copy changed or new files to finaloutdir
+opendir (OUT, $outdir) or die "Couldn't opendir $outdir";
+foreach $filename (readdir(OUT)) {
+    next if ( -d "$outdir/$filename" ); # only files, not dirs
+    my $docopy = 1;
+    if ( -f "$finaloutdir/$filename" ) {
+        $docopy = compare("$outdir/$filename", "$finaloutdir/$filename"); # 1 if files are differents
+    }
+    if ($docopy) {
+	#print STDERR "Updating $filename...\n";
+	cp("$outdir/$filename", "$finaloutdir/$filename");
+    }
+}
+closedir OUT;
+
+# Check for deleted files and warn
+my $deleted = 0;
+opendir(FINALOUT, $finaloutdir) or die "Couldn't opendir $finaloutdir";
+foreach $filename (readdir(FINALOUT)) {
+    next if ( -d "$finaloutdir/$filename" ); # only files, not dirs
+    if ( $filename =~ /.cpp$/ && ! ($filename =~ /_la_closure.cpp/) && ! -f "$outdir/$filename" ) {
+      print STDERR "Removing obsolete file $filename\n";
+      unlink "$finaloutdir/$filename";
+      $deleted = 1;
+    }
+}
+closedir FINALOUT;
+
+# Delete outdir
+system "rm -rf $outdir";
+

Modified: trunk/smoke/qt/header_list
===================================================================
--- trunk/smoke/qt/header_list	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/header_list	2007-02-19 21:34:59 UTC (rev 290)
@@ -26,6 +26,7 @@
 QtCore/qfeatures.h
 QtCore/qfile.h
 QtCore/qfileinfo.h
+QtCore/qfilesystemwatcher.h
 QtCore/qfsfileengine.h
 QtCore/qglobal.h
 QtCore/qiodevice.h
@@ -258,6 +259,7 @@
 QtGui/qwindowsxpstyle.h
 QtGui/qwmatrix.h
 QtGui/qworkspace.h
+QtGui/qx11embed_x11.h
 QtGui/qx11info_x11.h
 QtNetwork/qabstractsocket.h
 QtNetwork/qftp.h

Added: trunk/smoke/qt/qscintilla2_header_list
===================================================================
--- trunk/smoke/qt/qscintilla2_header_list	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/qscintilla2_header_list	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,30 @@
+Qsci/qsciapis.h
+Qsci/qscicommand.h
+Qsci/qscicommandset.h
+Qsci/qscidocument.h
+Qsci/qsciglobal.h
+Qsci/qscilexerbash.h
+Qsci/qscilexerbatch.h
+Qsci/qscilexercpp.h
+Qsci/qscilexercsharp.h
+Qsci/qscilexercss.h
+Qsci/qscilexerdiff.h
+Qsci/qscilexer.h
+Qsci/qscilexerhtml.h
+Qsci/qscilexeridl.h
+Qsci/qscilexerjava.h
+Qsci/qscilexerjavascript.h
+Qsci/qscilexerlua.h
+Qsci/qscilexermakefile.h
+Qsci/qscilexerperl.h
+Qsci/qscilexerpov.h
+Qsci/qscilexerproperties.h
+Qsci/qscilexerpython.h
+Qsci/qscilexerruby.h
+Qsci/qscilexersql.h
+Qsci/qscilexertex.h
+Qsci/qscimacro.h
+Qsci/qscintilla2_header_list
+Qsci/qsciprinter.h
+Qsci/qsciscintillabase.h
+Qsci/qsciscintilla.h

Modified: trunk/smoke/qt/qt_smoke.h
===================================================================
--- trunk/smoke/qt/qt_smoke.h	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/qt_smoke.h	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,8 +1,9 @@
 #ifndef QT_SMOKE_H
 #define QT_SMOKE_H
-
+#include <kdemacros.h>
 // Defined in smokedata.cpp, initialized by init_qt_Smoke(), used by all .cpp files
-extern Smoke* qt_Smoke;
+extern KDE_EXPORT Smoke* qt_Smoke;
+extern KDE_EXPORT void init_qt_Smoke();
 
 class QGlobalSpace { };
 

Modified: trunk/smoke/qt/qtdbus_header_list
===================================================================
--- trunk/smoke/qt/qtdbus_header_list	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/qtdbus_header_list	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,5 +1,6 @@
 QtDBus/qdbusabstractadaptor.h
 QtDBus/qdbusabstractinterface.h
+QtDBus/qdbusargument.h
 QtDBus/qdbusconnection.h
 QtDBus/qdbusconnectioninterface.h
 QtDBus/qdbuserror.h

Added: trunk/smoke/qt/qtguess.pl.cmake
===================================================================
--- trunk/smoke/qt/qtguess.pl.cmake	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/qtguess.pl.cmake	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,423 @@
+#!/usr/bin/perl
+
+# qtguess.pl : check how Qt was compiled. Issue a list of all defined QT_NO_* macros, one per line.
+#
+# author:  germain Garand <germain at ebooksfrance.com>
+# licence: GPL v.2
+
+# options: -q: be quieter
+#	   -o file: redirect output to "file". (default: ./qtdefines)
+#	   -t [0..15]: set the testing threshold (see below)
+#	   -f "flags": additional compiler flags/parameters
+
+use Getopt::Std;
+
+use vars qw/$opt_f $opt_o $opt_p/;
+
+getopts('qo:f:t:');
+
+# Threshold :
+#	 0 - test basic Qt types/classes
+#	 5 - test higher level, non-gui classes
+#	 8 - test options of the above (ex: QT_NO_IMAGE_SMOOTHSCALE)
+#	10 - test basic widgets
+#	12 - test composite widgets
+#	13 - test widgets inheriting composite widgets
+#	15 - test goodies (default)
+
+my $default_threshold = @qt_test_threshold@;
+my $cc = "@CMAKE_CXX_COMPILER@";
+my $ccflags = $opt_f || "@CMAKE_CXX_FLAGS@";
+
+my $nspaces = 50;
+
+my %qtdefs=();
+my %qtundefs=();
+
+my $tmp = gettmpfile();
+my $qtinc = '@QT_INCLUDE_DIR@';
+my $allinc = '@all_includes@';
+my $alllib = '-L at QT_LIBRARY_DIR@';
+my $qtflags = '@qtflags@';
+# my %x;
+# $x{'LIBPNG'}  =   '@LIBPNG@';
+# $x{'LIBJPEG'} =   '@LIBJPEG@';
+# $x{'LIBSM'}   =   '@LIBSM@';
+# $x{'LIBSOCKET'} = '@LIBSOCKET@';
+# $x{'LIBDL'}      = '@LIBDL@';
+# $x{'LIBRESOLV'}  = '@LIBRESOLV@';
+# $x{'LIB_X11'} =   '@LIB_X11@';
+# $x{'X_PRE_LIBS'} = '@X_PRE_LIBS@';
+# $x{'LIB_X11'} =~ s/\$\((.*?)\)/$x{$1}/g;
+# 
+# $qtflags =~ s/\$\((.*?)\)/$x{$1}/g;
+
+ -e "$qtinc/QtCore/qglobal.h" or die "Invalid Qt include directory.\n";
+
+my $ccmd = "$cc $ccflags $allinc $alllib -o $tmp $tmp.cpp $qtflags";
+
+my $threshold = defined($opt_t)?$opt_t : $default_threshold;
+$threshold >= 0 or die "invalid testing threshold: $threshold\n";
+
+print "Checking how Qt was built... \n";
+print "Threshold is set to $threshold\n" unless $opt_q;
+
+my($count, $used, $total);
+map{ $tests{$_}->[2]>=$threshold ? ($used++, $total++):$total++ } keys %tests;
+
+print "Number of defines to be tested : $used/$total\n\n" unless $opt_q;
+open( QTDEFS, ">>".($opt_o || "qtdefines") ) or die "Can't open output file: $!\n";
+
+grab_qglobal_symbols();
+preliminary_test();
+perform_all_tests();
+
+print +scalar(keys %qtdefs) . " defines found.\n";
+
+print QTDEFS join("\n", keys %qtdefs), "\n";
+close;
+
+#--------------------------------------------------------------#
+
+sub gettmpfile
+{
+	my $tmpdir = $ENV{'TMP'} || ".";
+	my $tmpname = $$."-qtguess";
+	while( -e "$tmpdir/$tmpname" || -e "$tmpdir/${tmpname}.cpp" )
+	{
+		$tmpname .= int (rand * 9);
+	}
+	return "$tmpdir/$tmpname";
+}
+
+#--------------------------------------------------------------#
+
+sub grab_qglobal_symbols
+{
+	my $cmd = "$cc -E -D__cplusplus -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2>/dev/null";
+	my $symbols = `$cmd`;
+        for(0..1)
+        {
+	    if( check_exit_status($?) )
+	    {
+		while( $symbols =~/^#\s*define\s*(QT_\S+)/gm )
+		{
+			$qtdefs{$1} = 1;
+		}
+		print "Found ". scalar( keys %qtdefs )." predefined symbol".((scalar( keys %qtdefs ) -1)?"s":"")." in qglobal.h\n" unless ($opt_q or !(keys %qtdefs));
+		while( $symbols =~/^#\s*define\s*QT_MODULE_(\S+)/gm )
+		{
+			$qtundefs{"QT_NO_$1"} = 1;
+		}
+		print "Found ". scalar( keys %qtundefs )." undefined symbol".((scalar( keys %qtundefs ) -1)?"s":"")." in qglobal.h\n" unless ($opt_q or !(keys %qtundefs));
+                last;
+	    }
+	    elsif(! $_) # first try
+	    {
+		print  "Failed to run $cmd.\nTrying without __cplusplus (might be already defined)\n";
+                $cmd = "$cc -E -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2>/dev/null";
+                $symbols = `$cmd`;
+                next;
+	    }
+        }
+}
+
+#--------------------------------------------------------------#
+
+sub preliminary_test
+{
+	my $msg = "Trying to compile and link a small program...";
+	print $msg, " " x ($nspaces - length($msg) + 8);
+	open( OUT, ">${tmp}.cpp" ) or die "Failed to open temp file ${tmp}.cpp: $!\n";
+	my $simple=q"
+		#include <QtGui/qapplication.h>
+		int main( int argc, char **argv )
+		{
+			QApplication foo( argc, argv );
+			return 0;
+		}
+	";
+	print OUT $simple;
+	close OUT;
+        my $out = `$ccmd 2>&1`;
+	if( !check_exit_status($?) )
+	{
+		die <<"EOF";
+
+FAILED : check your configuration.
+Failed program was:
+$simple
+Compiled with:
+$ccmd
+Compiler output:
+$out
+EOF
+	}
+	else
+	{
+		print "OK\n";
+	}
+}
+
+#--------------------------------------------------------------#
+
+sub perform_all_tests
+{
+	foreach ( sort { $tests{$a}->[2] <=> $tests{$b}->[2]} keys %tests)
+	{
+		$tests{$_}->[2] < $threshold and next;
+		($qtdefs{$_} || $qtundefs{$_}) and do
+		{
+			print "\rSkipping $_ (in qglobal.h)".( " " x (($nspaces-16) - length($_)) ).($qtundefs{$_}?"*Undefined*":" [Defined]").($opt_q?"":"\n");
+			next
+		};
+		print "\rTesting $_".( " " x ($nspaces - length($_)) );
+		open( OUT, ">${tmp}.cpp" ) or die "Failed to open temp file ${tmp}.cpp: $!\n";
+		foreach $def(keys %qtdefs)
+		{
+			print OUT "#define $def\n";
+		}
+		foreach $inc(split /,\s*/, $tests{$_}->[0])
+		{
+			print OUT "#include <$inc>\n";
+		}
+		print OUT "#include <QtCore/qfeatures.h>\n";
+		print OUT $tests{$_}->[3] if $tests{$_}->[3]; # need to define some classes ?
+		print OUT qq"
+
+		int main( int argc, char ** argv)
+		{
+		$tests{$_}->[1]
+		return 0;
+		}
+
+		";
+		close OUT;
+
+                my $out = `$ccmd 2>&1`;
+		my $ok = check_exit_status($?);
+		if( !$ok )
+		{
+			$qtdefs{$_} = 1;
+		}
+		print +$opt_q ? ++$count."/$used" : ( $ok ? "*Undefined*\n" : " [Defined]\n" );
+	}
+	$opt_q && print "\n";
+}
+
+#--------------------------------------------------------------#
+
+sub check_exit_status
+{
+	my $a = 0xFFFF & shift;
+	if( !$a )
+	{
+		return 1;
+	}
+	elsif( $a == 0xFF00 )
+	{
+		die "\nSystem call failed: $!\n";
+	}
+	elsif( $a > 0x80 )
+	{
+		# non-zero status.
+	}
+	else
+	{
+		if( $a & 0x80 )
+		{
+			die "\n$cc coredumped with signal ". ($a & ~0x80);
+		}
+		die "\n$cc interrupted by signal $a\n";
+	}
+	return 0;
+}
+
+#--------------------------------------------------------------#
+
+END
+{
+	unlink $tmp if -e $tmp;
+	unlink "${tmp}.cpp" if -e "${tmp}.cpp";
+}
+
+#--------------------------------------------------------------#
+
+BEGIN {
+
+# "DEFINE" => ["header-1.h,... header-n.h", "main() code", priority, "Definitions (if needed)"]
+
+our %tests = (
+	"QT_NO_ACCESSIBILITY" =>        ["QtGui/qaccessible.h", "QAccessibleEvent event(QEvent::AccessibilityHelp, 0);", 15],
+	"QT_NO_ACTION" =>		["QtGui/qaction.h", "QAction foo( (QObject*)NULL );", 5],
+	#QT_NO_BIG_CODECS
+ 	"QT_NO_BUTTONGROUP" =>		["QtGui/qbuttongroup.h", "QButtonGroup foo( (QObject*)NULL );", 12],
+ 	"QT_NO_CHECKBOX" =>		["QtGui/qcheckbox.h", "QCheckBox foo( (QWidget*)NULL );", 10],
+	"QT_NO_CLIPBOARD" => 		["QtGui/qapplication.h, QtGui/qclipboard.h", q"
+						QApplication foo( argc, argv );
+						QClipboard *baz= foo.clipboard();
+					", 5],
+ 	"QT_NO_COLORDIALOG" =>		["QtGui/qcolordialog.h", "QColorDialog::customCount();", 12],
+	#QT_NO_COLORNAMES
+ 	"QT_NO_COMBOBOX" =>		["QtGui/qcombobox.h", "QComboBox foo( (QWidget*)NULL );", 10],
+	"QT_NO_COMPAT" =>		["QtGui/qfontmetrics.h", q"
+						QFontMetrics *foo= new QFontMetrics( QFont() );
+						int bar = foo->width( 'c' );
+					", 0],
+	"QT_NO_COMPONENT" =>		["QtGui/qapplication.h", q"
+ 						QApplication foo( argc, argv );
+ 						foo.addLibraryPath( QString::null );
+					", 5],
+	#QT_NO_COP
+ 	"QT_NO_CURSOR" =>		["QtGui/qcursor.h", "QCursor foo;", 5],
+ 	"QT_NO_DATASTREAM" =>		["QtCore/qdatastream.h", "QDataStream foo;", 5],
+ 	"QT_NO_DATETIMEEDIT" =>		["QtGui/qdatetimeedit.h", "QTimeEdit foo;", 12],
+	"QT_NO_DIAL" =>			["QtGui/qdial.h", "QDial foo;", 10],
+	"QT_NO_DIALOG" =>		["QtGui/qdialog.h", "QDialog foo;", 12],
+	"QT_NO_DIR" =>			["QtCore/qdir.h", "QDir foo;", 5],
+	#QT_NO_DIRECTPAINTER
+	"QT_NO_DOM" =>			["QtXml/qdom.h", "QDomDocumentType foo;", 5],
+	"QT_NO_DRAGANDDROP" =>		["QtGui/qevent.h", "QDropEvent foo( QDropEvent() );", 5],
+	"QT_NO_DRAWUTIL" =>		["QtGui/qdrawutil.h, QtGui/qcolor.h", "qDrawPlainRect( (QPainter *) NULL, 0, 0, 0, 0, QColor() );", 10],
+	#QT_NO_EFFECTS
+	"QT_NO_ERRORMESSAGE" => 	["QtGui/qerrormessage.h", "QErrorMessage foo( (QWidget*) NULL );", 13],
+	"QT_NO_FILEDIALOG" =>		["QtGui/qfiledialog.h", "QFileDialog foo();", 13],
+
+	"QT_NO_FONTDATABASE" =>		["QtGui/qfontdatabase.h", "QFontDatabase foo;", 5],
+	"QT_NO_FONTDIALOG" => 		["QtGui/qfontdialog.h",   "QFontDialog::getFont( (bool *)NULL );", 12],
+	"QT_NO_FRAME" => 		["QtGui/qframe.h", "QFrame foo;", 10],
+	#QT_NO_FREETYPE
+ 	"QT_NO_FTP" =>	["QtNetwork/qftp.h", "QFtp foo;", 9],
+	"QT_NO_GROUPBOX" =>		["QtGui/qgroupbox.h", "QGroupBox foo;", 12],
+	#QT_NO_IMAGEFORMAT_BMP
+	#QT_NO_IMAGEFORMAT_JPEG
+	#QT_NO_IMAGEFORMATPLUGIN
+	#QT_NO_IMAGEFORMAT_PNG
+	#QT_NO_IMAGEFORMAT_PPM
+	#QT_NO_IMAGEFORMAT_XBM
+ 	"QT_NO_IMAGE_HEURISTIC_MASK" =>	["QtGui/qimage.h", q"
+						QImage *foo = new QImage;
+						foo->createHeuristicMask();
+					", 8],
+	#QT_NO_IMAGE_TEXT
+	"QT_NO_IMAGEIO" => 		["QtGui/qbitmap.h, QtCore/qstring.h", q"
+						QBitmap foo( QString::fromLatin1('foobar') );
+					", 5],
+	"QT_NO_LABEL" =>		["QtGui/qlabel.h", "QLabel foo( (QWidget*) NULL );", 10],
+	"QT_NO_LAYOUT" =>		["QtGui/qlayout.h", "QFoo foo;", 10, q"
+ 						class QFoo: public QLayout
+ 						{
+ 						public:
+ 						    QFoo() {};
+ 						    ~QFoo() {};
+ 						    void addItem( QLayoutItem * ) { };
+						    QSize sizeHint() const { return QSize(); }
+						    void setGeometry( const QRect & ) { };
+                            QLayoutItem* itemAt(int) const {return (QLayoutItem*) NULL;}
+                            QLayoutItem* takeAt(int) {return (QLayoutItem*) NULL;}
+                            int QFoo::count() const {return 0;}
+
+ 						};
+ 					"],
+	"QT_NO_LCDNUMBER" =>		["QtGui/qlcdnumber.h", "QLCDNumber foo;", 12],
+	"QT_NO_LINEEDIT" =>		["QtGui/qlineedit.h", "QLineEdit foo( (QWidget *) NULL );", 12],
+	"QT_NO_LISTVIEW" =>		["QtGui/qlistview.h", "QListView foo;", 13],
+	"QT_NO_MAINWINDOW" =>		["QtGui/qmainwindow.h", "QMainWindow foo;", 13],
+	"QT_NO_MATRIX" =>		["QtGui/qmatrix.h", "QMatrix foo;", 0],
+	"QT_NO_MENUBAR" =>		["QtGui/qmenubar.h", "QMenuBar foo;", 13],
+	"QT_NO_MESSAGEBOX" =>		["QtGui/qmessagebox.h", "QMessageBox foo;", 13],
+	"QT_NO_MOVIE" =>		["QtGui/qmovie.h", "QMovie foo;", 5],
+	"QT_NO_NETWORK" =>		["QtNetwork/qnetworkproxy.h", "QNetworkProxy foo;", 5],
+	#QT_NO_NETWORKPROXY
+	"QT_NO_PALETTE" =>		["QtGui/qpalette.h", "QPalette foo;", 5],
+	"QT_NO_PICTURE" =>		["QtGui/qpicture.h", "QPicture foo;", 5],
+	"QT_NO_PRINTER" =>		["QtGui/qprinter.h", "QPrinter foo();", 5],
+	"QT_NO_PRINTDIALOG" =>		["QtGui/qprintdialog.h", "QPrintDialog foo( (QPrinter*) NULL );", 13],
+	"QT_NO_PROCESS" =>		["QtCore/qprocess.h", "QProcess foo;", 5],
+	"QT_NO_PROGRESSBAR" =>		["QtGui/qprogressbar.h", "QProgressBar foo;", 12],
+	"QT_NO_PROGRESSDIALOG" =>	["QtGui/qprogressdialog.h", "QProgressDialog foo;", 13],
+	"QT_NO_PROPERTIES" =>		["QtCore/qmetaobject.h", "QMetaProperty foo;", 0],
+	"QT_NO_PUSHBUTTON" =>		["QtGui/qpushbutton.h", "QPushButton foo( (QWidget *) NULL );", 12],
+	"QT_NO_QUUID_STRING" =>		["QtCore/quuid.h", "QUuid foo( QString() );", 8],
+	"QT_NO_RADIOBUTTON" =>		["QtGui/qradiobutton.h", "QRadioButton foo( (QWidget *) NULL );", 12],
+	#QT_NO_QWS_ALPHA_CURSOR
+	#QT_NO_QWS_DECORATION_DEFAULT
+	#QT_NO_QWS_INPUTMETHODS
+	#QT_NO_QWS_KEYBOARD
+	#QT_NO_QWS_MOUSE
+	#QT_NO_QWS_MOUSE_AUTO
+	#QT_NO_QWS_MOUSE_MANUAL
+	#QT_NO_QWS_MULTIPROCESS
+	#QT_NO_QWS_PROPERTIES
+	#QT_NO_QWS_QPF
+	#QT_NO_RESIZEHANDLER
+	#QT_NO_RUBBERBAND
+	"QT_NO_SCROLLBAR" =>		["QtGui/qscrollbar.h", "QScrollBar foo( (QWidget *) NULL );", 12],
+	"QT_NO_SESSIONMANAGER" =>	["QtGui/qapplication.h", q"
+  						QApplication foo( argc, argv );
+  						foo.sessionId();
+					", 15],
+	"QT_NO_SETTINGS" =>		["QtCore/qsettings.h", "QSettings foo;", 5],
+	#QT_NO_SHORTCUT
+	"QT_NO_SIGNALMAPPER" =>		["QtCore/qsignalmapper.h", "QSignalMapper foo( (QObject *) NULL );", 0],
+	"QT_NO_SIZEGRIP" =>		["QtGui/qsizegrip.h", "QSizeGrip foo( (QWidget *) NULL );", 10],
+	"QT_NO_SLIDER" =>		["QtGui/qslider.h", "QSlider foo( (QWidget *) NULL );", 12],
+	"QT_NO_SOUND" =>		["QtGui/qsound.h", "QSound foo( QString::null );", 5],
+	#QT_NO_SPINWIDGET
+	#QT_NO_SPLASHSCREEN
+	#QT_NO_STACKEDWIDGET
+	#QT_NO_STATUSBAR
+	#QT_NO_STATUSTIP
+	#QT_NO_STL
+	"QT_NO_STRINGLIST" =>		["qstringlist.h", "QStringList foo;", 0],
+	"QT_NO_STYLE_PLASTIQUE" =>		["QtGui/qplastiquestyle.h", "QPlastiqueStyle foo;", 16],
+ 	"QT_NO_STYLE_WINDOWSXP" =>	["QtGui/qwindowsxpstyle.h", "QWindowsXPStyle foo;", 16],
+ 	"QT_NO_STYLE_WINDOWS" =>	["QtGui/qwindowsstyle.h", "QWindowsStyle foo;", 16],
+	"QT_NO_STYLE_MAC" =>	["QtGui/macstyle.h", "QMacStyle foo;", 16],
+	"QT_NO_STYLE_CLEANLOOKS" =>	["QtGui/qcleanlooksstyle.h", "QCleanlooksStyle foo;", 16],
+    "QT_NO_TABBAR" =>               ["QtGui/qtabbar.h", "QTabBar foo;", 10],
+	"QT_NO_TABLEVIEW" =>		["QtGui/qtableview.h", "QTableView foo;", 16],
+    "QT_NO_TABWIDGET" =>            ["QtGui/qtabwidget.h", "QTabWidget foo;", 10],
+    "QT_NO_TEXTBROWSER" =>          ["QtGui/qtextbrowser.h", "QTextBrowser foo;", 14],
+    "QT_NO_TEXTCODEC" =>            ["QtCore/qtextcodec.h", "QTextCodec::codecForMib(1);", 5],
+    "QT_NO_TEXTCODECPLUGIN" =>      ["QtCore/qtextcodecplugin.h, QtCore/qstringlist.h, QtCore/qlist.h, QtCore/qtextcodec.h", "QFoo foo;", 6, q"
+						class QFoo: public QTextCodecPlugin
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            QList<QByteArray> names() const {return QList<QByteArray>();}
+                            QList<int>mibEnums() const {return QList<int>();}
+                            QTextCodec *createForName( const QByteArray & name ) {return (QTextCodec *)NULL;}
+                            QTextCodec *createForMib( int mib ) {return (QTextCodec *)NULL;}
+                            QList<QByteArray> aliases() const {return QList<QByteArray>();}
+						};
+						Q_EXPORT_PLUGIN2( 'Foo', QFoo )
+					"],
+	#QT_NO_TEXTDATE
+ 	"QT_NO_TEXTEDIT" =>		["QtGui/qtextedit.h", "QTextEdit foo;", 13], 
+    "QT_NO_TEXTSTREAM" =>           ["qtextstream.h", "QTextStream foo;", 5],
+    "QT_NO_THREAD" =>           ["QtCore/qthread.h", "QFoo foo;", 5, q"
+						class QFoo: public QThread
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            void run() {}
+						};
+					"],
+    "QT_NO_TOOLBAR" =>              ["QtGui/qtoolbar.h", "QToolBar foo;", 10],
+    "QT_NO_TOOLBUTTON" =>           ["QtGui/qtoolbutton.h", "QToolButton foo((QWidget *) NULL );", 12],
+    "QT_NO_TOOLTIP" =>              ["QtGui/qtooltip.h", "QToolTip::palette();", 10],
+	#QT_NO_TRANSLATION
+	#QT_NO_UDPSOCKET
+	#QT_NO_URLINFO
+	#QT_NO_VALIDATOR
+    "QT_NO_VARIANT" =>              ["QtCore/qvariant.h", "QVariant foo;", 0],
+    "QT_NO_WHATSTHIS" =>            ["QtGui/qwhatsthis.h", "QWhatsThis::inWhatsThisMode();", 10],
+	"QT_NO_WHEELEVENT" =>		["QtGui/qevent.h", "QWheelEvent foo( QPoint(1,1), 1, (Qt::MouseButtons)1, 0 );", 5],
+	"QT_NO_XML" =>			["QtXml/qxml.h", "QXmlNamespaceSupport foo;", 5],
+
+	);
+
+}

Modified: trunk/smoke/qt/qtguess.pl.in
===================================================================
--- trunk/smoke/qt/qtguess.pl.in	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/qtguess.pl.in	2007-02-19 21:34:59 UTC (rev 290)
@@ -374,6 +374,7 @@
  	"QT_NO_STYLE_WINDOWSXP" =>	["QtGui/qwindowsxpstyle.h", "QWindowsXPStyle foo;", 16],
  	"QT_NO_STYLE_WINDOWS" =>	["QtGui/qwindowsstyle.h", "QWindowsStyle foo;", 16],
 	"QT_NO_STYLE_MAC" =>	["QtGui/macstyle.h", "QMacStyle foo;", 16],
+	"QT_NO_STYLE_CLEANLOOKS" =>	["QtGui/qcleanlooksstyle.h", "QCleanlooksStyle foo;", 16],
     "QT_NO_TABBAR" =>               ["QtGui/qtabbar.h", "QTabBar foo;", 10],
 	"QT_NO_TABLEVIEW" =>		["QtGui/qtableview.h", "QTableView foo;", 16],
     "QT_NO_TABWIDGET" =>            ["QtGui/qtabwidget.h", "QTabWidget foo;", 10],

Modified: trunk/smoke/qt/qwt_header_list
===================================================================
--- trunk/smoke/qt/qwt_header_list	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/qwt_header_list	2007-02-19 21:34:59 UTC (rev 290)
@@ -4,9 +4,11 @@
 qwt_analog_clock.h
 qwt_array.h
 qwt_arrow_button.h
+qwt_color_map.h
 qwt_compass.h
 qwt_compass_rose.h
 qwt_counter.h
+qwt_curve_fitter.h
 qwt_data.h
 qwt_dial.h
 qwt_dial_needle.h
@@ -25,6 +27,7 @@
 qwt_math.h
 qwt_paint_buffer.h
 qwt_painter.h
+qwt_panner.h
 qwt_picker.h
 qwt_picker_machine.h
 qwt_plot_canvas.h
@@ -34,10 +37,16 @@
 qwt_plot.h
 qwt_plot_item.h
 qwt_plot_layout.h
+qwt_plot_magnifier.h
 qwt_plot_marker.h
+qwt_plot_panner.h
 qwt_plot_picker.h
 qwt_plot_printfilter.h
+qwt_plot_rasteritem.h
+qwt_plot_spectrogram.h
 qwt_plot_zoomer.h
+qwt_polygon.h
+qwt_raster_data.h
 qwt_rect.h
 qwt_round_scale_draw.h
 qwt_scale_div.h
@@ -51,5 +60,7 @@
 qwt_text_engine.h
 qwt_text.h
 qwt_text_label.h
+qwt_text_plugin.h
 qwt_thermo.h
+qwt_valuelist.h
 qwt_wheel.h

Modified: trunk/smoke/qt/smokeqt.pro
===================================================================
--- trunk/smoke/qt/smokeqt.pro	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/smokeqt.pro	2007-02-19 21:34:59 UTC (rev 290)
@@ -2,13 +2,18 @@
 # Automatically generated by qmake (2.00a) lun 17. abr 22:10:08 2006
 ######################################################################
 
-QT += network xml sql opengl
+QT += network xml sql opengl svg uitools
 TEMPLATE = lib
 TARGET += 
 DEPENDPATH += .
 INCLUDEPATH += .
 INCLUDEPATH += ..
 
+# Add a 'qdbus' option if building with QtDBus:
+CONFIG += uitools
+
+DEFINES += QT_NO_DEBUG_STREAM
+
 # Input
 HEADERS += qt_smoke.h
 SOURCES += smokedata.cpp \

Deleted: trunk/smoke/qwidgetitemdata_p.h
===================================================================
--- trunk/smoke/qwidgetitemdata_p.h	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qwidgetitemdata_p.h	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,70 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 1992-2005 Trolltech AS. All rights reserved.
-**
-** This file is part of the item views module of the Qt Toolkit.
-**
-** This file may be distributed under the terms of the Q Public License
-** as defined by Trolltech AS of Norway and appearing in the file
-** LICENSE.QPL included in the packaging of this file.
-**
-** This file may be distributed and/or modified under the terms of the
-** GNU General Public License version 2 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.
-**
-** See http://www.trolltech.com/pricing.html or email sales at trolltech.com for
-**   information about Qt Commercial License Agreements.
-** See http://www.trolltech.com/qpl/ for QPL licensing information.
-** See http://www.trolltech.com/gpl/ for GPL licensing information.
-**
-** Contact info at trolltech.com if any conditions of this licensing are
-** not clear to you.
-**
-** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
-** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
-**
-****************************************************************************/
-
-#ifndef QWIDGETITEMDATA_P_H
-#define QWIDGETITEMDATA_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-class QWidgetItemData
-{
-public:
-    QWidgetItemData() : role(-1) {}
-    QWidgetItemData(int r, QVariant v) : role(r), value(v) {}
-    int role;
-    QVariant value;
-};
-
-#ifndef QT_NO_DATASTREAM
-
-inline QDataStream &operator>>(QDataStream &in, QWidgetItemData &data)
-{
-    in >> data.role;
-    in >> data.value;
-    return in;
-}
-
-inline QDataStream &operator<<(QDataStream &out, const QWidgetItemData &data)
-{
-    out << data.role;
-    out << data.value;
-    return out;
-}
-
-#endif
-
-#endif // QWIDGETITEMDATA_P_H



From tm243 at mail.berlios.de  Mon Feb 19 22:35:40 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Mon, 19 Feb 2007 22:35:40 +0100
Subject: [Php-qt-svn] r291 - in trunk: . cmake cmake/modules
Message-ID: <200702192135.l1JLZeMf027959@sheep.berlios.de>

Author: tm243
Date: 2007-02-19 22:35:39 +0100 (Mon, 19 Feb 2007)
New Revision: 291

Added:
   trunk/cmake/
   trunk/cmake/modules/
   trunk/cmake/modules/FindPHP5.cmake
   trunk/cmake/modules/FindQScintilla.cmake
   trunk/cmake/modules/FindQwt.cmake
Log:
added cmake modules.

Added: trunk/cmake/modules/FindPHP5.cmake
===================================================================
--- trunk/cmake/modules/FindPHP5.cmake	2007-02-19 21:34:59 UTC (rev 290)
+++ trunk/cmake/modules/FindPHP5.cmake	2007-02-19 21:35:39 UTC (rev 291)
@@ -0,0 +1,119 @@
+# - Find PHP5
+# This module finds if PHP5 is installed and determines where the include files
+# and libraries are. It also determines what the name of the library is. This
+# code sets the following variables:
+#
+#  PHP5_INCLUDE_PATH       = path to where php.h can be found
+#  PHP5_EXECUTABLE         = full path to the php4 binary
+#
+#  file is derived from FindPHP4.cmake
+#
+
+SET(PHP5_FOUND "NO")
+
+SET(PHP5_POSSIBLE_INCLUDE_PATHS
+  /usr/include/php5
+  /usr/local/include/php5
+  /usr/include/php
+  /usr/local/include/php
+  /usr/local/apache/php
+  )
+
+SET(PHP5_POSSIBLE_LIB_PATHS
+  /usr/lib
+  )
+
+#FIND_PATH(PHP5_FOUND_INCLUDE_PATH main/php.h
+#  ${PHP5_POSSIBLE_INCLUDE_PATHS})
+#
+#IF(PHP5_FOUND_INCLUDE_PATH)
+#  SET(php5_paths "${PHP5_POSSIBLE_INCLUDE_PATHS}")
+#  FOREACH(php5_path Zend main TSRM)
+#    SET(php5_paths ${php5_paths} "${PHP5_FOUND_INCLUDE_PATH}/${php5_path}")
+#  ENDFOREACH(php5_path Zend main TSRM)
+#  SET(PHP5_INCLUDE_PATH "${php5_paths}" INTERNAL "PHP5 include paths")
+#ENDIF(PHP5_FOUND_INCLUDE_PATH)
+
+FIND_PROGRAM(PHP5_EXECUTABLE
+  NAMES php5 php
+  PATHS
+  /usr/bin
+  /usr/local/bin
+  )
+
+MARK_AS_ADVANCED(
+  PHP5_EXECUTABLE
+  PHP5_FOUND_INCLUDE_PATH
+  )
+
+IF(APPLE)
+# this is a hack for now
+  SET(CMAKE_SHARED_MODULE_CREATE_C_FLAGS 
+   "${CMAKE_SHARED_MODULE_CREATE_C_FLAGS} -Wl,-flat_namespace")
+  FOREACH(symbol
+    __efree
+    __emalloc
+    __estrdup
+    __object_init_ex
+    __zend_get_parameters_array_ex
+    __zend_list_find
+    __zval_copy_ctor
+    _add_property_zval_ex
+    _alloc_globals
+    _compiler_globals
+    _convert_to_double
+    _convert_to_long
+    _zend_error
+    _zend_hash_find
+    _zend_register_internal_class_ex
+    _zend_register_list_destructors_ex
+    _zend_register_resource
+    _zend_rsrc_list_get_rsrc_type
+    _zend_wrong_param_count
+    _zval_used_for_init
+    )
+    SET(CMAKE_SHARED_MODULE_CREATE_C_FLAGS 
+      "${CMAKE_SHARED_MODULE_CREATE_C_FLAGS},-U,${symbol}")
+  ENDFOREACH(symbol)
+ENDIF(APPLE)
+
+
+FIND_PROGRAM(PHP5_CONFIG_EXECUTABLE
+  NAMES php5-config php-config
+  PATHS
+  /usr/bin
+  /usr/local/bin
+  )
+
+EXECUTE_PROCESS(COMMAND ${PHP5_CONFIG_EXECUTABLE} --version
+   OUTPUT_VARIABLE PHP5_VERSION)
+
+EXECUTE_PROCESS(COMMAND ${PHP5_CONFIG_EXECUTABLE} --extension-dir
+   OUTPUT_VARIABLE PHP5_EXTENSION_DIR)
+STRING(REPLACE "\n" "" PHP5_EXTENSION_DIR "${PHP5_EXTENSION_DIR}")
+
+EXECUTE_PROCESS(COMMAND ${PHP5_CONFIG_EXECUTABLE} --includes
+   OUTPUT_VARIABLE PHP5_INCLUDES)
+STRING(REPLACE "-I" ";" PHP5_INCLUDES "${PHP5_INCLUDES}")
+STRING(REPLACE " " "" PHP5_INCLUDES "${PHP5_INCLUDES}")
+LIST(GET PHP5_INCLUDES 0 PHP5_INCLUDE_DIR)
+
+set(PHP5_MAIN_INCLUDE_DIR ${PHP5_INCLUDE_DIR}/main)
+set(PHP5_TSRM_INCLUDE_DIR ${PHP5_INCLUDE_DIR}/TSRM)
+set(PHP5_ZEND_INCLUDE_DIR ${PHP5_INCLUDE_DIR}/Zend)
+set(PHP5_REGEX_INCLUDE_DIR ${PHP5_INCLUDE_DIR}/regex)
+set(PHP5_EXT_INCLUDE_DIR ${PHP5_INCLUDE_DIR}/ext)
+set(PHP5_DATE_INCLUDE_DIR ${PHP5_INCLUDE_DIR}/ext/date/lib)
+set(PHP5_STANDARD_INCLUDE_DIR ${PHP5_INCLUDE_DIR}/ext/standard)
+
+MESSAGE(STATUS ${PHP5_MAIN_INCLUDE_DIR})
+
+IF(PHP5_VERSION LESS 5)
+    MESSAGE(FATAL_ERROR "PHP version is not 5 or later")
+ENDIF(PHP5_VERSION LESS 5)
+
+IF(PHP5_EXECUTABLE AND PHP5_INCLUDES)
+    set(PHP5_FOUND "yes")
+    MESSAGE(STATUS "Found PHP5-Version ${PHP5_VERSION}")
+ENDIF(PHP5_EXECUTABLE AND PHP5_INCLUDES)
+

Added: trunk/cmake/modules/FindQScintilla.cmake
===================================================================
--- trunk/cmake/modules/FindQScintilla.cmake	2007-02-19 21:34:59 UTC (rev 290)
+++ trunk/cmake/modules/FindQScintilla.cmake	2007-02-19 21:35:39 UTC (rev 291)
@@ -0,0 +1,57 @@
+# - Try to find the QScintilla2 includes and library
+# which defines
+#
+# QSCINTILLA_FOUND - system has QScintilla2
+# QSCINTILLA_INCLUDE_DIR - where to find qextscintilla.h
+# QSCINTILLA_LIBRARIES - the libraries to link against to use QScintilla
+# QSCINTILLA_LIBRARY - where to find the QScintilla library (not for general use)
+
+# copyright (c) 2007 Thomas Moenicke thomas.moenicke at kdemail.net
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+
+IF(NOT QT4_FOUND)
+    INCLUDE(FindQt4)
+ENDIF(NOT QT4_FOUND)
+
+SET(QSCINTILLA_FOUND "NO")
+
+IF(QT4_FOUND)
+    FIND_PATH(QSCINTILLA_INCLUDE_DIR qsciglobal.h
+    "${QT_INCLUDE_DIR}/Qsci"
+    )
+
+    SET(QSCINTILLA_NAMES ${QSCINTILLA_NAMES} qscintilla2 libqscintilla2)
+    FIND_LIBRARY(QSCINTILLA_LIBRARY
+        NAMES ${QSCINTILLA_NAMES}
+        PATHS ${QT_LIBRARY_DIR}
+    )
+
+    IF (QSCINTILLA_LIBRARY)
+
+        SET(QSCINTILLA_LIBRARIES ${QSCINTILLA_LIBRARY})
+        SET(QSCINTILLA_FOUND "YES")
+
+        IF (CYGWIN)
+            IF(BUILD_SHARED_LIBS)
+            # No need to define QSCINTILLA_USE_DLL here, because it's default for Cygwin.
+            ELSE(BUILD_SHARED_LIBS)
+            SET (QSCINTILLA_DEFINITIONS -DQSCINTILLA_STATIC)
+            ENDIF(BUILD_SHARED_LIBS)
+        ENDIF (CYGWIN)
+
+    ENDIF (QSCINTILLA_LIBRARY)
+ENDIF(QT4_FOUND)
+
+IF (QSCINTILLA_FOUND)
+  IF (NOT QSCINTILLA_FIND_QUIETLY)
+    MESSAGE(STATUS "Found QScintilla2: ${QSCINTILLA_LIBRARY}")
+  ENDIF (NOT QSCINTILLA_FIND_QUIETLY)
+ELSE (QSCINTILLA_FOUND)
+  IF (QSCINTILLA_FIND_REQUIRED)
+    MESSAGE(FATAL_ERROR "Could not find QScintilla library")
+  ENDIF (QSCINTILLA_FIND_REQUIRED)
+ENDIF (QSCINTILLA_FOUND)
+
+MARK_AS_ADVANCED(QSCINTILLA_INCLUDE_DIR QSCINTILLA_LIBRARY)
+

Added: trunk/cmake/modules/FindQwt.cmake
===================================================================
--- trunk/cmake/modules/FindQwt.cmake	2007-02-19 21:34:59 UTC (rev 290)
+++ trunk/cmake/modules/FindQwt.cmake	2007-02-19 21:35:39 UTC (rev 291)
@@ -0,0 +1,60 @@
+# - Try to find the Qwt includes and library
+# which defines
+#
+# QWT_FOUND - system has Qwt
+# QWT_INCLUDE_DIR - where to find qwt.h
+# QWT_LIBRARIES - the libraries to link against to use Qwt
+# QWT_LIBRARY - where to find the Qwt library (not for general use)
+
+# copyright (c) 2006 Thomas Moenicke thomas.moenicke at kdemail.net
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+
+IF(NOT QT4_FOUND)
+    INCLUDE(FindQt4)
+ENDIF(NOT QT4_FOUND)
+
+SET(QWT_FOUND "NO")
+
+IF(QT4_FOUND)
+    FIND_PATH(QWT_INCLUDE_DIR qwt.h
+    /usr/local/qwt/include
+    /usr/local/include
+    /usr/include/qwt
+    /usr/include
+    )
+
+    SET(QWT_NAMES ${QWT_NAMES} qwt libqwt)
+    FIND_LIBRARY(QWT_LIBRARY
+        NAMES ${QWT_NAMES}
+        PATHS /usr/local/qwt/lib /usr/local/lib /usr/lib
+    )
+
+    IF (QWT_LIBRARY)
+
+        SET(QWT_LIBRARIES ${QWT_LIBRARY})
+        SET(QWT_FOUND "YES")
+
+        IF (CYGWIN)
+            IF(BUILD_SHARED_LIBS)
+            # No need to define QWT_USE_DLL here, because it's default for Cygwin.
+            ELSE(BUILD_SHARED_LIBS)
+            SET (QWT_DEFINITIONS -DQWT_STATIC)
+            ENDIF(BUILD_SHARED_LIBS)
+        ENDIF (CYGWIN)
+
+    ENDIF (QWT_LIBRARY)
+ENDIF(QT4_FOUND)
+
+IF (QWT_FOUND)
+  IF (NOT QWT_FIND_QUIETLY)
+    MESSAGE(STATUS "Found Qwt: ${QWT_LIBRARY}")
+  ENDIF (NOT QWT_FIND_QUIETLY)
+ELSE (QWT_FOUND)
+  IF (QWT_FIND_REQUIRED)
+    MESSAGE(FATAL_ERROR "Could not find Qwt library")
+  ENDIF (QWT_FIND_REQUIRED)
+ENDIF (QWT_FOUND)
+
+MARK_AS_ADVANCED(QWT_INCLUDE_DIR QWT_LIBRARY)
+



From tm243 at mail.berlios.de  Mon Feb 19 23:31:06 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Mon, 19 Feb 2007 23:31:06 +0100
Subject: [Php-qt-svn] r292 - trunk/smoke/qt
Message-ID: <200702192231.l1JMV6go000598@sheep.berlios.de>

Author: tm243
Date: 2007-02-19 23:31:05 +0100 (Mon, 19 Feb 2007)
New Revision: 292

Modified:
   trunk/smoke/qt/qt_smoke.h
Log:
removed KDE dependence from smokeqt

Modified: trunk/smoke/qt/qt_smoke.h
===================================================================
--- trunk/smoke/qt/qt_smoke.h	2007-02-19 21:35:39 UTC (rev 291)
+++ trunk/smoke/qt/qt_smoke.h	2007-02-19 22:31:05 UTC (rev 292)
@@ -1,9 +1,11 @@
 #ifndef QT_SMOKE_H
 #define QT_SMOKE_H
-#include <kdemacros.h>
+
+// Don't use kdemacros.h/KDE_EXPORT here as it needs to be free of KDE dependencies
+#include <QtCore/qglobal.h>
 // Defined in smokedata.cpp, initialized by init_qt_Smoke(), used by all .cpp files
-extern KDE_EXPORT Smoke* qt_Smoke;
-extern KDE_EXPORT void init_qt_Smoke();
+extern Q_DECL_EXPORT Smoke* qt_Smoke;
+extern Q_DECL_EXPORT void init_qt_Smoke();
 
 class QGlobalSpace { };
 



From tm243 at mail.berlios.de  Tue Feb 20 12:16:45 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Tue, 20 Feb 2007 12:16:45 +0100
Subject: [Php-qt-svn] r293 - trunk/cmake/modules
Message-ID: <200702201116.l1KBGjTZ006266@sheep.berlios.de>

Author: tm243
Date: 2007-02-20 12:16:43 +0100 (Tue, 20 Feb 2007)
New Revision: 293

Added:
   trunk/cmake/modules/FindQt4.cmake
Log:
added FindQt4 cmake module

Added: trunk/cmake/modules/FindQt4.cmake
===================================================================
--- trunk/cmake/modules/FindQt4.cmake	2007-02-19 22:31:05 UTC (rev 292)
+++ trunk/cmake/modules/FindQt4.cmake	2007-02-20 11:16:43 UTC (rev 293)
@@ -0,0 +1,1082 @@
+# - Find QT 4
+# This module can be used to find Qt4.
+# The most important issue is that the Qt4 qmake is available via the system path.
+# This qmake is then used to detect basically everything else.
+# This module defines a number of key variables and macros. First is 
+# QT_USE_FILE which is the path to a CMake file that can be included to compile
+# Qt 4 applications and libraries.  By default, the QtCore and QtGui 
+# libraries are loaded. This behavior can be changed by setting one or more 
+# of the following variables to true:
+#                    QT_DONT_USE_QTCORE
+#                    QT_DONT_USE_QTGUI
+#                    QT_USE_QT3SUPPORT
+#                    QT_USE_QTASSISTANT
+#                    QT_USE_QTDESIGNER
+#                    QT_USE_QTMOTIF
+#                    QT_USE_QTMAIN
+#                    QT_USE_QTNETWORK
+#                    QT_USE_QTNSPLUGIN
+#                    QT_USE_QTOPENGL
+#                    QT_USE_QTSQL
+#                    QT_USE_QTXML
+#                    QT_USE_QTSVG
+#                    QT_USE_QTTEST
+#                    QT_USE_QTUITOOLS
+#                    QT_USE_QTDBUS
+#
+# All the libraries required are stored in a variable called QT_LIBRARIES.  
+# Add this variable to your TARGET_LINK_LIBRARIES.
+#  
+#  macro QT4_WRAP_CPP(outfiles inputfile ... )
+#  macro QT4_WRAP_UI(outfiles inputfile ... )
+#  macro QT4_ADD_RESOURCE(outfiles inputfile ... )
+#  macro QT4_AUTOMOC(inputfile ... )
+#  macro QT4_GENERATE_MOC(inputfile outputfile )
+#
+#  macro QT4_ADD_DBUS_INTERFACE(outfiles interface basename)
+#        create a the interface header and implementation files with the 
+#        given basename from the given interface xml file and add it to 
+#        the list of sources
+#
+#  macro QT4_ADD_DBUS_INTERFACES(outfiles inputfile ... )
+#        create the interface header and implementation files 
+#        for all listed interface xml files
+#        the name will be automatically determined from the name of the xml file
+#
+#  macro QT4_ADD_DBUS_ADAPTOR(outfiles xmlfile parentheader parentclassname [basename] )
+#        create a dbus adaptor (header and implementation file) from the xml file
+#        describing the interface, and add it to the list of sources. The adaptor
+#        forwards the calls to a parent class, defined in parentheader and named
+#        parentclassname. The name of the generated files will be
+#        <basename>adaptor.{cpp,h} where basename is the basename of the xml file.
+#
+#  macro QT4_GENERATE_DBUS_INTERFACE( header [interfacename] )
+#        generate the xml interface file from the given header.
+#        If the optional argument interfacename is omitted, the name of the 
+#        interface file is constructed from the basename of the header with
+#        the suffix .xml appended.
+#
+#  QT_FOUND         If false, don't try to use Qt.
+#  QT4_FOUND        If false, don't try to use Qt 4.
+#
+#  QT_QTCORE_FOUND        True if QtCore was found.
+#  QT_QTGUI_FOUND         True if QtGui was found.
+#  QT_QT3SUPPORT_FOUND    True if Qt3Support was found.
+#  QT_QTASSISTANT_FOUND   True if QtAssistant was found.
+#  QT_QTDBUS_FOUND        True if QtDBus was found.
+#  QT_QTDESIGNER_FOUND    True if QtDesigner was found.
+#  QT_QTDESIGNERCOMPONENTS True if QtDesignerComponents was found.
+#  QT_QTMOTIF_FOUND       True if QtMotif was found.
+#  QT_QTNETWORK_FOUND     True if QtNetwork was found.
+#  QT_QTNSPLUGIN_FOUND    True if QtNsPlugin was found.
+#  QT_QTOPENGL_FOUND      True if QtOpenGL was found.
+#  QT_QTSQL_FOUND         True if QtSql was found.
+#  QT_QTXML_FOUND         True if QtXml was found.
+#  QT_QTSVG_FOUND         True if QtSvg was found.
+#  QT_QTTEST_FOUND        True if QtTest was found.
+#  QT_QTUITOOLS_FOUND     True if QtUiTools was found.
+#                      
+#  QT_DEFINITIONS   Definitions to use when compiling code that uses Qt.
+#                  
+#  QT_INCLUDES      List of paths to all include directories of 
+#                   Qt4 QT_INCLUDE_DIR and QT_QTCORE_INCLUDE_DIR are
+#                   always in this variable even if NOTFOUND,
+#                   all other INCLUDE_DIRS are
+#                   only added if they are found.
+#   
+#  QT_INCLUDE_DIR              Path to "include" of Qt4
+#  QT_QT_INCLUDE_DIR           Path to "include/Qt" 
+#  QT_QT3SUPPORT_INCLUDE_DIR   Path to "include/Qt3Support" 
+#  QT_QTASSISTANT_INCLUDE_DIR  Path to "include/QtAssistant" 
+#  QT_QTCORE_INCLUDE_DIR       Path to "include/QtCore"         
+#  QT_QTDESIGNER_INCLUDE_DIR   Path to "include/QtDesigner" 
+#  QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR   Path to "include/QtDesigner"
+#  QT_QTDBUS_INCLUDE_DIR       Path to "include/QtDBus" 
+#  QT_QTGUI_INCLUDE_DIR        Path to "include/QtGui" 
+#  QT_QTMOTIF_INCLUDE_DIR      Path to "include/QtMotif" 
+#  QT_QTNETWORK_INCLUDE_DIR    Path to "include/QtNetwork" 
+#  QT_QTNSPLUGIN_INCLUDE_DIR   Path to "include/QtNsPlugin" 
+#  QT_QTOPENGL_INCLUDE_DIR     Path to "include/QtOpenGL" 
+#  QT_QTSQL_INCLUDE_DIR        Path to "include/QtSql" 
+#  QT_QTXML_INCLUDE_DIR        Path to "include/QtXml" 
+#  QT_QTSVG_INCLUDE_DIR        Path to "include/QtSvg"
+#  QT_QTTEST_INCLUDE_DIR       Path to "include/QtTest"
+#                            
+#  QT_LIBRARY_DIR              Path to "lib" of Qt4
+# 
+#  QT_PLUGINS_DIR              Path to "plugins" for Qt4
+#                            
+# For every library of Qt, a QT_QTFOO_LIBRARY variable is defined, with the full path to the library.
+#
+# So there are the following variables:
+# The Qt3Support library:     QT_QT3SUPPORT_LIBRARY
+#
+# The QtAssistant library:    QT_QTASSISTANT_LIBRARY
+#
+# The QtCore library:         QT_QTCORE_LIBRARY
+#
+# The QtDBus library:         QT_QTDBUS_LIBRARY
+#
+# The QtDesigner library:     QT_QTDESIGNER_LIBRARY
+#
+# The QtDesignerComponents library:     QT_QTDESIGNERCOMPONENTS_LIBRARY
+#
+# The QtGui library:          QT_QTGUI_LIBRARY
+#
+# The QtMotif library:        QT_QTMOTIF_LIBRARY
+#
+# The QtNetwork library:      QT_QTNETWORK_LIBRARY
+#
+# The QtNsPLugin library:     QT_QTNSPLUGIN_LIBRARY
+#
+# The QtOpenGL library:       QT_QTOPENGL_LIBRARY
+#
+# The QtSql library:          QT_QTSQL_LIBRARY
+#
+# The QtXml library:          QT_QTXML_LIBRARY
+#
+# The QtSvg library:          QT_QTSVG_LIBRARY
+#
+# The QtTest library:         QT_QTTEST_LIBRARY
+#
+# The qtmain library for Windows QT_QTMAIN_LIBRARY
+#
+# The QtUiTools library:      QT_QTUITOOLS_LIBRARY
+#  
+# also defined, but NOT for general use are
+#  QT_MOC_EXECUTABLE          Where to find the moc tool.
+#  QT_UIC_EXECUTABLE          Where to find the uic tool.
+#  QT_UIC3_EXECUTABLE         Where to find the uic3 tool.
+#  QT_RCC_EXECUTABLE          Where to find the rcc tool
+#  QT_DBUSCPP2XML_EXECUTABLE  Where to find the qdbuscpp2xml tool.
+#  QT_DBUSXML2CPP_EXECUTABLE  Where to find the qdbusxml2cpp tool.
+#  
+#  QT_DOC_DIR                 Path to "doc" of Qt4
+#  QT_MKSPECS_DIR             Path to "mkspecs" of Qt4
+#
+#
+# These are around for backwards compatibility 
+# they will be set
+#  QT_WRAP_CPP  Set true if QT_MOC_EXECUTABLE is found
+#  QT_WRAP_UI   Set true if QT_UIC_EXECUTABLE is found
+#  
+# These variables do _NOT_ have any effect anymore (compared to FindQt.cmake)
+#  QT_MT_REQUIRED         Qt4 is now always multithreaded
+#  
+# These variables are set to "" Because Qt structure changed 
+# (They make no sense in Qt4)
+#  QT_QT_LIBRARY        Qt-Library is now split
+
+# Copyright (c) 2002 Kitware, Inc., Insight Consortium.  All rights reserved.
+# See Copyright.txt or http://www.cmake.org/HTML/Copyright.html for details.
+
+
+INCLUDE(CheckSymbolExists)
+INCLUDE(MacroAddFileDependencies)
+
+SET(QT_USE_FILE ${CMAKE_ROOT}/Modules/UseQt4.cmake)
+
+SET( QT_DEFINITIONS "")
+
+IF (WIN32)
+  SET(QT_DEFINITIONS -DQT_DLL)
+ENDIF(WIN32)
+
+SET(QT4_INSTALLED_VERSION_TOO_OLD FALSE)
+
+#  macro for asking qmake to process pro files
+MACRO(QT_QUERY_QMAKE outvar invar)
+  FILE(WRITE ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmpQmake/tmp.pro
+    "message(CMAKE_MESSAGE<$$${invar}>)")
+
+  EXECUTE_PROCESS(COMMAND ${QT_QMAKE_EXECUTABLE}
+    WORKING_DIRECTORY  
+    ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmpQmake
+    OUTPUT_VARIABLE _qmake_query_output
+    ERROR_VARIABLE _qmake_query_output )
+
+  FILE(REMOVE_RECURSE 
+    "${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmpQmake")
+
+  STRING(REGEX REPLACE ".*CMAKE_MESSAGE<([^>]*).*" "\\1" ${outvar} "${_qmake_query_output}")
+ENDMACRO(QT_QUERY_QMAKE)
+
+# check for qmake
+FIND_PROGRAM(QT_QMAKE_EXECUTABLE NAMES qmake qmake4 qmake-qt4 PATHS
+  "[HKEY_CURRENT_USER\\Software\\Trolltech\\Qt3Versions\\4.0.0;InstallDir]/bin"
+  "[HKEY_CURRENT_USER\\Software\\Trolltech\\Versions\\4.0.0;InstallDir]/bin"
+  $ENV{QTDIR}/bin
+)
+
+IF (QT_QMAKE_EXECUTABLE)
+
+  SET(QT4_QMAKE_FOUND FALSE)
+  
+  EXEC_PROGRAM(${QT_QMAKE_EXECUTABLE} ARGS "-query QT_VERSION" OUTPUT_VARIABLE QTVERSION)
+
+  # check for qt3 qmake and then try and find qmake4 or qmake-qt4 in the path
+  IF("${QTVERSION}" MATCHES "Unknown")
+    SET(QT_QMAKE_EXECUTABLE NOTFOUND CACHE FILEPATH "" FORCE)
+    FIND_PROGRAM(QT_QMAKE_EXECUTABLE NAMES qmake4 qmake-qt4 PATHS
+      "[HKEY_CURRENT_USER\\Software\\Trolltech\\Qt3Versions\\4.0.0;InstallDir]/bin"
+      "[HKEY_CURRENT_USER\\Software\\Trolltech\\Versions\\4.0.0;InstallDir]/bin"
+      $ENV{QTDIR}/bin
+      )
+    IF(QT_QMAKE_EXECUTABLE)
+      EXEC_PROGRAM(${QT_QMAKE_EXECUTABLE} 
+        ARGS "-query QT_VERSION" OUTPUT_VARIABLE QTVERSION)
+    ENDIF(QT_QMAKE_EXECUTABLE)
+  ENDIF("${QTVERSION}" MATCHES "Unknown")
+
+  # check that we found the Qt4 qmake, Qt3 qmake output won't match here
+  STRING(REGEX MATCH "^[0-9]+\\.[0-9]+\\.[0-9]+" qt_version_tmp "${QTVERSION}")
+  IF (qt_version_tmp)
+
+    # we need at least version 4.0.0
+    IF (NOT QT_MIN_VERSION)
+      SET(QT_MIN_VERSION "4.0.0")
+    ENDIF (NOT QT_MIN_VERSION)
+
+    #now parse the parts of the user given version string into variables
+    STRING(REGEX MATCH "^[0-9]+\\.[0-9]+\\.[0-9]+" req_qt_major_vers "${QT_MIN_VERSION}")
+    IF (NOT req_qt_major_vers)
+      MESSAGE( FATAL_ERROR "Invalid Qt version string given: \"${QT_MIN_VERSION}\", expected e.g. \"4.0.1\"")
+    ENDIF (NOT req_qt_major_vers)
+
+    # now parse the parts of the user given version string into variables
+    STRING(REGEX REPLACE "^([0-9]+)\\.[0-9]+\\.[0-9]+" "\\1" req_qt_major_vers "${QT_MIN_VERSION}")
+    STRING(REGEX REPLACE "^[0-9]+\\.([0-9])+\\.[0-9]+" "\\1" req_qt_minor_vers "${QT_MIN_VERSION}")
+    STRING(REGEX REPLACE "^[0-9]+\\.[0-9]+\\.([0-9]+)" "\\1" req_qt_patch_vers "${QT_MIN_VERSION}")
+
+    IF (NOT req_qt_major_vers EQUAL 4)
+      MESSAGE( FATAL_ERROR "Invalid Qt version string given: \"${QT_MIN_VERSION}\", major version 4 is required, e.g. \"4.0.1\"")
+    ENDIF (NOT req_qt_major_vers EQUAL 4)
+
+    # and now the version string given by qmake
+    STRING(REGEX REPLACE "^([0-9]+)\\.[0-9]+\\.[0-9]+.*" "\\1" found_qt_major_vers "${QTVERSION}")
+    STRING(REGEX REPLACE "^[0-9]+\\.([0-9])+\\.[0-9]+.*" "\\1" found_qt_minor_vers "${QTVERSION}")
+    STRING(REGEX REPLACE "^[0-9]+\\.[0-9]+\\.([0-9]+).*" "\\1" found_qt_patch_vers "${QTVERSION}")
+
+    # compute an overall version number which can be compared at once
+    MATH(EXPR req_vers "${req_qt_major_vers}*10000 + ${req_qt_minor_vers}*100 + ${req_qt_patch_vers}")
+    MATH(EXPR found_vers "${found_qt_major_vers}*10000 + ${found_qt_minor_vers}*100 + ${found_qt_patch_vers}")
+
+    IF (found_vers LESS req_vers)
+      SET(QT4_QMAKE_FOUND FALSE)
+      SET(QT4_INSTALLED_VERSION_TOO_OLD TRUE)
+    ELSE (found_vers LESS req_vers)
+      SET(QT4_QMAKE_FOUND TRUE)
+    ENDIF (found_vers LESS req_vers)
+  ENDIF (qt_version_tmp)
+
+ENDIF (QT_QMAKE_EXECUTABLE)
+
+IF (QT4_QMAKE_FOUND)
+
+  # ask qmake for the library dir
+  # Set QT_LIBRARY_DIR
+  IF (NOT QT_LIBRARY_DIR)
+    EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+      ARGS "-query QT_INSTALL_LIBS"
+      OUTPUT_VARIABLE QT_LIBRARY_DIR_TMP )
+    IF(EXISTS "${QT_LIBRARY_DIR_TMP}")
+      SET(QT_LIBRARY_DIR ${QT_LIBRARY_DIR_TMP} CACHE PATH "Qt library dir")
+    ELSE(EXISTS "${QT_LIBRARY_DIR_TMP}")
+      MESSAGE("Warning: QT_QMAKE_EXECUTABLE reported QT_INSTALL_LIBS as ${QT_LIBRARY_DIR_TMP}")
+      MESSAGE("Warning: ${QT_LIBRARY_DIR_TMP} does NOT exist, Qt must NOT be installed correctly.")
+    ENDIF(EXISTS "${QT_LIBRARY_DIR_TMP}")
+  ENDIF(NOT QT_LIBRARY_DIR)
+  
+  IF (APPLE)
+    IF (EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+      SET(QT_USE_FRAMEWORKS ON
+        CACHE BOOL "Set to ON if Qt build uses frameworks.")
+    ELSE (EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+      SET(QT_USE_FRAMEWORKS OFF
+        CACHE BOOL "Set to ON if Qt build uses frameworks.")
+    ENDIF (EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+    
+    MARK_AS_ADVANCED(QT_USE_FRAMEWORKS)
+  ENDIF (APPLE)
+  
+  # ask qmake for the binary dir
+  IF (NOT QT_BINARY_DIR)
+     EXEC_PROGRAM(${QT_QMAKE_EXECUTABLE}
+        ARGS "-query QT_INSTALL_BINS"
+        OUTPUT_VARIABLE qt_bins )
+     SET(QT_BINARY_DIR ${qt_bins} CACHE INTERNAL "")
+  ENDIF (NOT QT_BINARY_DIR)
+
+  # ask qmake for the include dir
+  IF (NOT QT_HEADERS_DIR)
+      EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+        ARGS "-query QT_INSTALL_HEADERS" 
+        OUTPUT_VARIABLE qt_headers )
+      SET(QT_HEADERS_DIR ${qt_headers} CACHE INTERNAL "")
+  ENDIF(NOT QT_HEADERS_DIR)
+
+
+  # ask qmake for the documentation directory
+  IF (NOT QT_DOC_DIR)
+    EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+      ARGS "-query QT_INSTALL_DOCS"
+      OUTPUT_VARIABLE qt_doc_dir )
+    SET(QT_DOC_DIR ${qt_doc_dir} CACHE PATH "The location of the Qt docs")
+  ENDIF (NOT QT_DOC_DIR)
+
+  # ask qmake for the mkspecs directory
+  IF (NOT QT_MKSPECS_DIR)
+    EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+      ARGS "-query QMAKE_MKSPECS"
+      OUTPUT_VARIABLE qt_mkspecs_dir )
+    SET(QT_MKSPECS_DIR ${qt_mkspecs_dir} CACHE PATH "The location of the Qt mkspecs")
+  ENDIF (NOT QT_MKSPECS_DIR)
+
+  # ask qmake for the plugins directory
+  IF (NOT QT_PLUGINS_DIR)
+    EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+      ARGS "-query QT_INSTALL_PLUGINS"
+      OUTPUT_VARIABLE qt_plugins_dir )
+    SET(QT_PLUGINS_DIR ${qt_plugins_dir} CACHE PATH "The location of the Qt plugins")
+  ENDIF (NOT QT_PLUGINS_DIR)
+  ########################################
+  #
+  #       Setting the INCLUDE-Variables
+  #
+  ########################################
+
+  FIND_PATH(QT_QTCORE_INCLUDE_DIR QtGlobal
+    ${QT_HEADERS_DIR}/QtCore
+    ${QT_LIBRARY_DIR}/QtCore.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_INCLUDE_DIR by removine "/QtCore" in the string ${QT_QTCORE_INCLUDE_DIR}
+  IF( QT_QTCORE_INCLUDE_DIR AND NOT QT_INCLUDE_DIR)
+    IF (QT_USE_FRAMEWORKS)
+      SET(QT_INCLUDE_DIR ${QT_HEADERS_DIR})
+    ELSE (QT_USE_FRAMEWORKS)
+      STRING( REGEX REPLACE "/QtCore$" "" qt4_include_dir ${QT_QTCORE_INCLUDE_DIR})
+      SET( QT_INCLUDE_DIR ${qt4_include_dir} CACHE PATH "")
+    ENDIF (QT_USE_FRAMEWORKS)
+  ENDIF( QT_QTCORE_INCLUDE_DIR AND NOT QT_INCLUDE_DIR)
+
+  IF( NOT QT_INCLUDE_DIR)
+    IF( NOT Qt4_FIND_QUIETLY AND Qt4_FIND_REQUIRED)
+      MESSAGE( FATAL_ERROR "Could NOT find QtGlobal header")
+    ENDIF( NOT Qt4_FIND_QUIETLY AND Qt4_FIND_REQUIRED)
+  ENDIF( NOT QT_INCLUDE_DIR)
+
+  #############################################
+  #
+  # Find out what window system we're using
+  #
+  #############################################
+  # Save required includes variable
+  SET(CMAKE_REQUIRED_INCLUDES_SAVE ${CMAKE_REQUIRED_INCLUDES})
+  # Add QT_INCLUDE_DIR to CMAKE_REQUIRED_INCLUDES
+  SET(CMAKE_REQUIRED_INCLUDES "${CMAKE_REQUIRED_INCLUDES};${QT_INCLUDE_DIR}")
+  # Check for Window system symbols (note: only one should end up being set)
+  CHECK_SYMBOL_EXISTS(Q_WS_X11 "QtCore/qglobal.h" Q_WS_X11)
+  CHECK_SYMBOL_EXISTS(Q_WS_MAC "QtCore/qglobal.h" Q_WS_MAC)
+  CHECK_SYMBOL_EXISTS(Q_WS_WIN "QtCore/qglobal.h" Q_WS_WIN)
+
+  IF (QT_QTCOPY_REQUIRED)
+     CHECK_SYMBOL_EXISTS(QT_IS_QTCOPY "QtCore/qglobal.h" QT_KDE_QT_COPY)
+     IF (NOT QT_IS_QTCOPY)
+        MESSAGE(FATAL_ERROR "qt-copy is required, but hasn't been found")
+     ENDIF (NOT QT_IS_QTCOPY)
+  ENDIF (QT_QTCOPY_REQUIRED)
+
+  # Restore CMAKE_REQUIRED_INCLUDES variable
+  SET(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES_SAVE})
+  #
+  #############################################
+
+  IF (QT_USE_FRAMEWORKS)
+    SET(QT_DEFINITIONS ${QT_DEFINITIONS} -F${QT_LIBRARY_DIR} -L${QT_LIBRARY_DIR} )
+  ENDIF (QT_USE_FRAMEWORKS)
+
+  # Set QT_QT3SUPPORT_INCLUDE_DIR
+  FIND_PATH(QT_QT3SUPPORT_INCLUDE_DIR Qt3Support
+    PATHS
+    ${QT_INCLUDE_DIR}/Qt3Support
+    ${QT_LIBRARY_DIR}/Qt3Support.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QT_INCLUDE_DIR
+  FIND_PATH(QT_QT_INCLUDE_DIR qglobal.h
+    PATHS
+    ${QT_INCLUDE_DIR}/Qt
+    ${QT_LIBRARY_DIR}/QtCore.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTGUI_INCLUDE_DIR
+  FIND_PATH(QT_QTGUI_INCLUDE_DIR QtGui
+    PATHS
+    ${QT_INCLUDE_DIR}/QtGui
+    ${QT_LIBRARY_DIR}/QtGui.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTSVG_INCLUDE_DIR
+  FIND_PATH(QT_QTSVG_INCLUDE_DIR QtSvg
+    PATHS
+    ${QT_INCLUDE_DIR}/QtSvg
+    ${QT_LIBRARY_DIR}/QtSvg.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTTEST_INCLUDE_DIR
+  FIND_PATH(QT_QTTEST_INCLUDE_DIR QtTest
+    PATHS
+    ${QT_INCLUDE_DIR}/QtTest
+    ${QT_LIBRARY_DIR}/QtTest.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTUITOOLS_INCLUDE_DIR
+  FIND_PATH(QT_QTUITOOLS_INCLUDE_DIR QtUiTools
+    PATHS
+    ${QT_INCLUDE_DIR}/QtUiTools
+    ${QT_LIBRARY_DIR}/QtUiTools.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+
+
+  # Set QT_QTMOTIF_INCLUDE_DIR
+  IF(Q_WS_X11)
+    FIND_PATH(QT_QTMOTIF_INCLUDE_DIR QtMotif PATHS ${QT_INCLUDE_DIR}/QtMotif NO_DEFAULT_PATH )
+  ENDIF(Q_WS_X11)
+
+  # Set QT_QTNETWORK_INCLUDE_DIR
+  FIND_PATH(QT_QTNETWORK_INCLUDE_DIR QtNetwork
+    PATHS
+    ${QT_INCLUDE_DIR}/QtNetwork
+    ${QT_LIBRARY_DIR}/QtNetwork.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTNSPLUGIN_INCLUDE_DIR
+  FIND_PATH(QT_QTNSPLUGIN_INCLUDE_DIR QtNsPlugin
+    PATHS
+    ${QT_INCLUDE_DIR}/QtNsPlugin
+    ${QT_LIBRARY_DIR}/QtNsPlugin.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTOPENGL_INCLUDE_DIR
+  FIND_PATH(QT_QTOPENGL_INCLUDE_DIR QtOpenGL
+    PATHS
+    ${QT_INCLUDE_DIR}/QtOpenGL
+    ${QT_LIBRARY_DIR}/QtOpenGL.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTSQL_INCLUDE_DIR
+  FIND_PATH(QT_QTSQL_INCLUDE_DIR QtSql
+    PATHS
+    ${QT_INCLUDE_DIR}/QtSql
+    ${QT_LIBRARY_DIR}/QtSql.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTXML_INCLUDE_DIR
+  FIND_PATH(QT_QTXML_INCLUDE_DIR QtXml
+    PATHS
+    ${QT_INCLUDE_DIR}/QtXml
+    ${QT_LIBRARY_DIR}/QtXml.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTASSISTANT_INCLUDE_DIR
+  FIND_PATH(QT_QTASSISTANT_INCLUDE_DIR QtAssistant
+    PATHS
+    ${QT_INCLUDE_DIR}/QtAssistant
+    ${QT_HEADERS_DIR}/QtAssistant
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTDESIGNER_INCLUDE_DIR
+  FIND_PATH(QT_QTDESIGNER_INCLUDE_DIR QDesignerComponents
+    PATHS
+    ${QT_INCLUDE_DIR}/QtDesigner
+    ${QT_HEADERS_DIR}/QtDesigner
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR
+  FIND_PATH(QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR QDesignerComponents
+    PATHS
+    ${QT_INCLUDE_DIR}/QtDesigner
+    ${QT_HEADERS_DIR}/QtDesigner
+    NO_DEFAULT_PATH
+    )
+
+
+  # Set QT_QTDBUS_INCLUDE_DIR
+  FIND_PATH(QT_QTDBUS_INCLUDE_DIR QtDBus
+    PATHS
+    ${QT_INCLUDE_DIR}/QtDBus
+    ${QT_HEADERS_DIR}/QtDBus
+    NO_DEFAULT_PATH
+    )
+
+  # Make variables changeble to the advanced user
+  MARK_AS_ADVANCED( QT_LIBRARY_DIR QT_INCLUDE_DIR QT_QT_INCLUDE_DIR QT_DOC_DIR QT_MKSPECS_DIR QT_PLUGINS_DIR)
+
+  # Set QT_INCLUDES
+  SET( QT_INCLUDES ${QT_INCLUDE_DIR} ${QT_QT_INCLUDE_DIR} ${QT_MKSPECS_DIR}/default )
+
+
+  ########################################
+  #
+  #       Setting the LIBRARY-Variables
+  #
+  ########################################
+
+  IF (QT_USE_FRAMEWORKS)
+    # If FIND_LIBRARY found libraries in Apple frameworks, we would NOT have
+    # to jump through these hoops.
+    SET(QT_QTCORE_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtCore" CACHE STRING "The QtCore library.")
+    SET(QT_QT3SUPPORT_LIBRARY "-framework Qt3Support" CACHE STRING "The Qt3Support library.")
+    SET(QT_QTGUI_LIBRARY      "-framework QtGui"      CACHE STRING "The QtGui library.")
+    SET(QT_QTNETWORK_LIBRARY  "-framework QtNetwork"  CACHE STRING "The QtNetwork library.")
+    SET(QT_QTOPENGL_LIBRARY   "-framework QtOpenGL"   CACHE STRING "The QtOpenGL library.")
+    SET(QT_QTSQL_LIBRARY      "-framework QtSql"      CACHE STRING "The QtSql library.")
+    SET(QT_QTXML_LIBRARY      "-framework QtXml"      CACHE STRING "The QtXml library.")
+    SET(QT_QTSVG_LIBRARY      "-framework QtSvg"      CACHE STRING "The QtSvg library.")
+    SET(QT_QTDBUS_LIBRARY     "-framework QtDBus"     CACHE STRING "The QtDBus library.")
+    SET(QT_QTTEST_LIBRARY     "-framework QtTest"     CACHE STRING "The QtTest library.")
+
+    # WTF?  why don't we have frameworks?  :P
+    SET(QT_QTUITOOLS_LIBRARY      "-L${QT_LIBRARY_DIR} -lQtUiTools"      CACHE STRING "The QtUiTools library.")
+
+  ELSE (QT_USE_FRAMEWORKS)
+    
+    # Set QT_QTCORE_LIBRARY by searching for a lib with "QtCore."  as part of the filename
+    FIND_LIBRARY(QT_QTCORE_LIBRARY NAMES QtCore QtCore4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH )
+
+    # Set QT_QT3SUPPORT_LIBRARY
+    FIND_LIBRARY(QT_QT3SUPPORT_LIBRARY NAMES Qt3Support Qt3Support4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+    # Set QT_QTGUI_LIBRARY
+    FIND_LIBRARY(QT_QTGUI_LIBRARY NAMES QtGui QtGui4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+    # Set QT_QTMOTIF_LIBRARY
+    IF(Q_WS_X11)
+      FIND_LIBRARY(QT_QTMOTIF_LIBRARY NAMES QtMotif PATHS ${QT_LIBRARY_DIR}       NO_DEFAULT_PATH)
+    ENDIF(Q_WS_X11)
+
+    # Set QT_QTNETWORK_LIBRARY
+    FIND_LIBRARY(QT_QTNETWORK_LIBRARY NAMES QtNetwork QtNetwork4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+    # Set QT_QTNSPLUGIN_LIBRARY
+    FIND_LIBRARY(QT_QTNSPLUGIN_LIBRARY NAMES QtNsPlugin PATHS ${QT_LIBRARY_DIR}       NO_DEFAULT_PATH)
+
+    # Set QT_QTOPENGL_LIBRARY
+    FIND_LIBRARY(QT_QTOPENGL_LIBRARY NAMES QtOpenGL QtOpenGL4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+    # Set QT_QTSQL_LIBRARY
+    FIND_LIBRARY(QT_QTSQL_LIBRARY NAMES QtSql QtSql4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+    # Set QT_QTXML_LIBRARY
+    FIND_LIBRARY(QT_QTXML_LIBRARY NAMES QtXml QtXml4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+    # Set QT_QTSVG_LIBRARY
+    FIND_LIBRARY(QT_QTSVG_LIBRARY NAMES QtSvg QtSvg4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+    # Set QT_QTUITOOLS_LIBRARY
+    FIND_LIBRARY(QT_QTUITOOLS_LIBRARY NAMES QtUiTools QtUiTools4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+    # Set QT_QTTEST_LIBRARY
+    FIND_LIBRARY(QT_QTTEST_LIBRARY NAMES QtTest QtTest4 PATHS ${QT_LIBRARY_DIR}                      NO_DEFAULT_PATH)
+
+    FIND_LIBRARY(QT_QTDBUS_LIBRARY NAMES QtDBus QtDBus4 PATHS ${QT_LIBRARY_DIR}                      NO_DEFAULT_PATH)
+
+    IF(MSVC)
+      FIND_LIBRARY(QT_QTCORE_LIBRARY_DEBUG      NAMES QtCored4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QT3SUPPORT_LIBRARY_DEBUG  NAMES Qt3Supportd4        PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTGUI_LIBRARY_DEBUG       NAMES QtGuid4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTNETWORK_LIBRARY_DEBUG   NAMES QtNetworkd4         PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTOPENGL_LIBRARY_DEBUG    NAMES QtOpenGLd4          PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTSQL_LIBRARY_DEBUG       NAMES QtSqld4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTXML_LIBRARY_DEBUG       NAMES QtXmld4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTSVG_LIBRARY_DEBUG       NAMES QtSvgd4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTUITOOLS_LIBRARY_DEBUG   NAMES QtUiToolsd QtUiToolsd4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTTEST_LIBRARY_DEBUG      NAMES QtTestd4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTDBUS_LIBRARY_DEBUG      NAMES QtDBusd4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTASSISTANT_LIBRARY_DEBUG NAMES QtAssistantClientd4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTMAIN_LIBRARY_DEBUG      NAMES qtmaind             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+    ENDIF(MSVC)
+
+  ENDIF (QT_USE_FRAMEWORKS)
+
+  IF( NOT QT_QTCORE_LIBRARY )
+    IF( NOT Qt4_FIND_QUIETLY AND Qt4_FIND_REQUIRED)
+      MESSAGE( FATAL_ERROR "Could NOT find QtCore. Check CMakeFiles/CMakeError.log for more details.")
+    ENDIF( NOT Qt4_FIND_QUIETLY AND Qt4_FIND_REQUIRED)
+  ENDIF( NOT QT_QTCORE_LIBRARY )
+
+  # Set QT_QTASSISTANT_LIBRARY
+  FIND_LIBRARY(QT_QTASSISTANT_LIBRARY NAMES QtAssistantClient QtAssistantClient4 QtAssistant QtAssistant4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+  # Set QT_QTDESIGNER_LIBRARY
+  FIND_LIBRARY(QT_QTDESIGNER_LIBRARY NAMES QtDesigner QtDesigner4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+  # Set QT_QTDESIGNERCOMPONENTS_LIBRARY
+  FIND_LIBRARY(QT_QTDESIGNERCOMPONENTS_LIBRARY NAMES QtDesignerComponents QtDesignerComponents4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+  # Set QT_QTMAIN_LIBRARY
+  IF(WIN32)
+    FIND_LIBRARY(QT_QTMAIN_LIBRARY NAMES qtmain PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+  ENDIF(WIN32)
+
+  ############################################
+  #
+  # Check the existence of the libraries.
+  #
+  ############################################
+
+  MACRO (_QT4_ADJUST_LIB_VARS basename)
+    IF (QT_${basename}_LIBRARY OR QT_${basename}_LIBRARY_DEBUG)
+
+      IF(MSVC)
+
+        # Both set
+        IF (QT_${basename}_LIBRARY AND QT_${basename}_LIBRARY_DEBUG)
+          SET(QT_${basename}_LIBRARY optimized ${QT_${basename}_LIBRARY} debug ${QT_${basename}_LIBRARY_DEBUG})
+        ENDIF (QT_${basename}_LIBRARY AND QT_${basename}_LIBRARY_DEBUG)
+
+        # Only debug was found
+        IF (NOT QT_${basename}_LIBRARY AND QT_${basename}_LIBRARY_DEBUG)
+          SET(QT_${basename}_LIBRARY ${QT_${basename}_LIBRARY_DEBUG})
+        ENDIF (NOT QT_${basename}_LIBRARY AND QT_${basename}_LIBRARY_DEBUG)
+
+        # Hmm, is this used anywhere ? Yes, in UseQt4.cmake. We are currently incompatible :-(
+        SET(QT_${basename}_LIBRARIES optimized ${QT_${basename}_LIBRARY} debug ${QT_${basename}_LIBRARY_DEBUG})
+
+      ENDIF(MSVC)
+
+      SET(QT_${basename}_LIBRARY ${QT_${basename}_LIBRARY} CACHE FILEPATH "The Qt ${basename} library")
+
+      IF (QT_${basename}_LIBRARY)
+        SET(QT_${basename}_FOUND 1)
+      ENDIF (QT_${basename}_LIBRARY)
+      
+    ENDIF (QT_${basename}_LIBRARY OR QT_${basename}_LIBRARY_DEBUG)
+    
+    IF (QT_${basename}_INCLUDE_DIR)
+      #add the include directory to QT_INCLUDES
+      SET(QT_INCLUDES ${QT_INCLUDES} "${QT_${basename}_INCLUDE_DIR}")
+    ENDIF (QT_${basename}_INCLUDE_DIR)
+
+    # Make variables changeble to the advanced user
+    MARK_AS_ADVANCED(QT_${basename}_LIBRARY QT_${basename}_INCLUDE_DIR)
+  ENDMACRO (_QT4_ADJUST_LIB_VARS)
+
+
+  # Set QT_xyz_LIBRARY variable and add 
+  # library include path to QT_INCLUDES
+  _QT4_ADJUST_LIB_VARS(QTCORE)
+  _QT4_ADJUST_LIB_VARS(QTGUI)
+  _QT4_ADJUST_LIB_VARS(QT3SUPPORT)
+  _QT4_ADJUST_LIB_VARS(QTASSISTANT)
+  _QT4_ADJUST_LIB_VARS(QTDESIGNER)
+  _QT4_ADJUST_LIB_VARS(QTDESIGNERCOMPONENTS)
+  _QT4_ADJUST_LIB_VARS(QTNETWORK)
+  _QT4_ADJUST_LIB_VARS(QTNSPLUGIN)
+  _QT4_ADJUST_LIB_VARS(QTOPENGL)
+  _QT4_ADJUST_LIB_VARS(QTSQL)
+  _QT4_ADJUST_LIB_VARS(QTXML)
+  _QT4_ADJUST_LIB_VARS(QTSVG)
+  _QT4_ADJUST_LIB_VARS(QTUITOOLS)
+  _QT4_ADJUST_LIB_VARS(QTTEST)
+  _QT4_ADJUST_LIB_VARS(QTDBUS)
+  
+  
+  # platform dependent libraries
+  IF(Q_WS_X11)
+    _QT4_ADJUST_LIB_VARS(QTMOTIF)
+  ENDIF(Q_WS_X11)
+  IF(WIN32)
+    _QT4_ADJUST_LIB_VARS(QTMAIN)
+  ENDIF(WIN32)
+  
+
+  #######################################
+  #
+  #       Check the executables of Qt 
+  #          ( moc, uic, rcc )
+  #
+  #######################################
+
+
+  # find moc and uic using qmake
+  QT_QUERY_QMAKE(QT_MOC_EXECUTABLE_INTERNAL "QMAKE_MOC")
+  QT_QUERY_QMAKE(QT_UIC_EXECUTABLE_INTERNAL "QMAKE_UIC")
+
+  FILE(TO_CMAKE_PATH 
+    "${QT_MOC_EXECUTABLE_INTERNAL}" QT_MOC_EXECUTABLE_INTERNAL)
+  FILE(TO_CMAKE_PATH 
+    "${QT_UIC_EXECUTABLE_INTERNAL}" QT_UIC_EXECUTABLE_INTERNAL)
+
+  SET(QT_MOC_EXECUTABLE 
+    ${QT_MOC_EXECUTABLE_INTERNAL} CACHE FILEPATH "The moc executable")
+  SET(QT_UIC_EXECUTABLE 
+    ${QT_UIC_EXECUTABLE_INTERNAL} CACHE FILEPATH "The uic executable")
+
+  FIND_PROGRAM(QT_UIC3_EXECUTABLE
+    NAMES uic3
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_RCC_EXECUTABLE 
+    NAMES rcc
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_DBUSCPP2XML_EXECUTABLE 
+    NAMES qdbuscpp2xml
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_DBUSXML2CPP_EXECUTABLE 
+    NAMES qdbusxml2cpp
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  IF (QT_MOC_EXECUTABLE)
+     SET(QT_WRAP_CPP "YES")
+  ENDIF (QT_MOC_EXECUTABLE)
+
+  IF (QT_UIC_EXECUTABLE)
+     SET(QT_WRAP_UI "YES")
+  ENDIF (QT_UIC_EXECUTABLE)
+
+
+
+  MARK_AS_ADVANCED( QT_UIC_EXECUTABLE QT_UIC3_EXECUTABLE QT_MOC_EXECUTABLE QT_RCC_EXECUTABLE QT_DBUSXML2CPP_EXECUTABLE QT_DBUSCPP2XML_EXECUTABLE)
+
+  ######################################
+  #
+  #       Macros for building Qt files
+  #
+  ######################################
+
+  MACRO (QT4_GET_MOC_INC_DIRS _moc_INC_DIRS)
+     SET(${_moc_INC_DIRS})
+     GET_DIRECTORY_PROPERTY(_inc_DIRS INCLUDE_DIRECTORIES)
+
+     FOREACH(_current ${_inc_DIRS})
+        SET(${_moc_INC_DIRS} ${${_moc_INC_DIRS}} "-I" ${_current})
+     ENDFOREACH(_current ${_inc_DIRS})
+  ENDMACRO(QT4_GET_MOC_INC_DIRS)
+
+
+  MACRO (QT4_GENERATE_MOC infile outfile )
+  # get include dirs
+     QT4_GET_MOC_INC_DIRS(moc_includes)
+
+     GET_FILENAME_COMPONENT(abs_infile ${infile} ABSOLUTE)
+
+     ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_MOC_EXECUTABLE}
+        ARGS ${moc_includes} -o ${outfile} ${abs_infile}
+        DEPENDS ${abs_infile})
+
+     SET_SOURCE_FILES_PROPERTIES(${outfile} PROPERTIES SKIP_AUTOMOC TRUE)  # dont run automoc on this file
+
+     MACRO_ADD_FILE_DEPENDENCIES(${abs_infile} ${outfile})
+  ENDMACRO (QT4_GENERATE_MOC)
+
+
+  # QT4_WRAP_CPP(outfiles inputfile ... )
+  # TODO  perhaps add support for -D, -U and other minor options
+
+  MACRO (QT4_WRAP_CPP outfiles )
+    # get include dirs
+    QT4_GET_MOC_INC_DIRS(moc_includes)
+
+    FOREACH (it ${ARGN})
+      GET_FILENAME_COMPONENT(it ${it} ABSOLUTE)
+      GET_FILENAME_COMPONENT(outfile ${it} NAME_WE)
+
+      SET(outfile ${CMAKE_CURRENT_BINARY_DIR}/moc_${outfile}.cxx)
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_MOC_EXECUTABLE}
+        ARGS ${moc_includes} -o ${outfile} ${it}
+        DEPENDS ${it})
+      SET(${outfiles} ${${outfiles}} ${outfile})
+    ENDFOREACH(it)
+
+  ENDMACRO (QT4_WRAP_CPP)
+
+
+  # QT4_WRAP_UI(outfiles inputfile ... )
+
+  MACRO (QT4_WRAP_UI outfiles )
+
+    FOREACH (it ${ARGN})
+      GET_FILENAME_COMPONENT(outfile ${it} NAME_WE)
+      GET_FILENAME_COMPONENT(infile ${it} ABSOLUTE)
+      SET(outfile ${CMAKE_CURRENT_BINARY_DIR}/ui_${outfile}.h)
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_UIC_EXECUTABLE}
+        ARGS -o ${outfile} ${infile}
+        MAIN_DEPENDENCY ${infile})
+      SET(${outfiles} ${${outfiles}} ${outfile})
+    ENDFOREACH (it)
+
+  ENDMACRO (QT4_WRAP_UI)
+
+
+  # QT4_ADD_RESOURCE(outfiles inputfile ... )
+  # TODO  perhaps consider adding support for compression and root options to rcc
+
+  MACRO (QT4_ADD_RESOURCES outfiles )
+
+    FOREACH (it ${ARGN})
+      GET_FILENAME_COMPONENT(outfilename ${it} NAME_WE)
+      GET_FILENAME_COMPONENT(infile ${it} ABSOLUTE)
+      GET_FILENAME_COMPONENT(rc_path ${infile} PATH)
+      SET(outfile ${CMAKE_CURRENT_BINARY_DIR}/qrc_${outfilename}.cxx)
+      #  parse file for dependencies
+      FILE(READ "${infile}" _RC_FILE_CONTENTS)
+      STRING(REGEX MATCHALL "<file[^<]+" _RC_FILES "${_RC_FILE_CONTENTS}")
+      
+      SET(_RC_DEPENDS)
+      FOREACH(_RC_FILE ${_RC_FILES})
+        STRING(REGEX REPLACE "^<file[^>]*>" "" _RC_FILE "${_RC_FILE}")
+        SET(_RC_DEPENDS ${_RC_DEPENDS} "${rc_path}/${_RC_FILE}")
+      ENDFOREACH(_RC_FILE)
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_RCC_EXECUTABLE}
+        ARGS -name ${outfilename} -o ${outfile} ${infile}
+        MAIN_DEPENDENCY ${infile}
+        DEPENDS ${_RC_DEPENDS})
+      SET(${outfiles} ${${outfiles}} ${outfile})
+    ENDFOREACH (it)
+
+  ENDMACRO (QT4_ADD_RESOURCES)
+
+  MACRO(QT4_ADD_DBUS_INTERFACE _sources _interface _basename)
+    GET_FILENAME_COMPONENT(_infile ${_interface} ABSOLUTE)
+    SET(_header ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.h)
+    SET(_impl   ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.cpp)
+    SET(_moc    ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc)
+  
+    ADD_CUSTOM_COMMAND(OUTPUT ${_impl} ${_header}
+        COMMAND ${QT_DBUSXML2CPP_EXECUTABLE} -m -p ${_basename} ${_infile}
+        DEPENDS ${_infile})
+  
+    SET_SOURCE_FILES_PROPERTIES(${_impl} PROPERTIES SKIP_AUTOMOC TRUE)
+    
+    QT4_GENERATE_MOC(${_header} ${_moc})
+  
+    SET(${_sources} ${${_sources}} ${_impl} ${_header} ${_moc})
+    MACRO_ADD_FILE_DEPENDENCIES(${_impl} ${_moc})
+  
+  ENDMACRO(QT4_ADD_DBUS_INTERFACE)
+  
+  
+  MACRO(QT4_ADD_DBUS_INTERFACES _sources)
+     FOREACH (_current_FILE ${ARGN})
+        GET_FILENAME_COMPONENT(_infile ${_current_FILE} ABSOLUTE)
+  
+  # get the part before the ".xml" suffix
+        STRING(REGEX REPLACE "(.*[/\\.])?([^\\.]+)\\.xml" "\\2" _basename ${_current_FILE})
+        STRING(TOLOWER ${_basename} _basename)
+  
+        QT4_ADD_DBUS_INTERFACE(${_sources} ${_infile} ${_basename}interface)
+     ENDFOREACH (_current_FILE)
+  ENDMACRO(QT4_ADD_DBUS_INTERFACES)
+  
+  
+  MACRO(QT4_GENERATE_DBUS_INTERFACE _header) # _customName )
+    SET(_customName "${ARGV1}")
+    GET_FILENAME_COMPONENT(_in_file ${_header} ABSOLUTE)
+    GET_FILENAME_COMPONENT(_basename ${_header} NAME_WE)
+    
+    IF (_customName)
+      SET(_target ${CMAKE_CURRENT_BINARY_DIR}/${_customName})
+    ELSE (_customName)
+      SET(_target ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.xml)
+    ENDIF (_customName)
+  
+    ADD_CUSTOM_COMMAND(OUTPUT ${_target}
+        COMMAND ${QT_DBUSCPP2XML_EXECUTABLE} ${_in_file} > ${_target}
+        DEPENDS ${_in_file}
+    )
+  ENDMACRO(QT4_GENERATE_DBUS_INTERFACE)
+  
+  
+  MACRO(QT4_ADD_DBUS_ADAPTOR _sources _xml_file _include _parentClass) # _optionalBasename )
+    GET_FILENAME_COMPONENT(_infile ${_xml_file} ABSOLUTE)
+    
+    SET(_optionalBasename "${ARGV4}")
+    IF (_optionalBasename)
+       SET(_basename ${_optionalBasename} )
+    ELSE (_optionalBasename)
+       STRING(REGEX REPLACE "(.*[/\\.])?([^\\.]+)\\.xml" "\\2adaptor" _basename ${_infile})
+       STRING(TOLOWER ${_basename} _basename)
+    ENDIF (_optionalBasename)
+
+    SET(_optionalClassName "${ARGV5}")
+    SET(_header ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.h)
+    SET(_impl   ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.cpp)
+    SET(_moc    ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc)
+
+    IF(_optionalClassName)
+       ADD_CUSTOM_COMMAND(OUTPUT ${_impl} ${_header}
+          COMMAND ${QT_DBUSXML2CPP_EXECUTABLE} -m -a ${_basename} -c ${_optionalClassName} -i ${_include} -l ${_parentClass} ${_infile}
+          DEPENDS ${_infile}
+        )
+    ELSE(_optionalClassName)
+       ADD_CUSTOM_COMMAND(OUTPUT ${_impl} ${_header}
+          COMMAND ${QT_DBUSXML2CPP_EXECUTABLE} -m -a ${_basename} -i ${_include} -l ${_parentClass} ${_infile}
+          DEPENDS ${_infile}
+        )
+    ENDIF(_optionalClassName)
+
+    QT4_GENERATE_MOC(${_header} ${_moc})
+    SET_SOURCE_FILES_PROPERTIES(${_impl} PROPERTIES SKIP_AUTOMOC TRUE)
+    MACRO_ADD_FILE_DEPENDENCIES(${_impl} ${_moc})
+
+    SET(${_sources} ${${_sources}} ${_impl} ${_header} ${_moc})
+  ENDMACRO(QT4_ADD_DBUS_ADAPTOR)
+
+   MACRO(QT4_AUTOMOC)
+      QT4_GET_MOC_INC_DIRS(_moc_INCS)
+
+      SET(_matching_FILES )
+      FOREACH (_current_FILE ${ARGN})
+
+         GET_FILENAME_COMPONENT(_abs_FILE ${_current_FILE} ABSOLUTE)
+         # if "SKIP_AUTOMOC" is set to true, we will not handle this file here.
+         # here. this is required to make bouic work correctly:
+         # we need to add generated .cpp files to the sources (to compile them),
+         # but we cannot let automoc handle them, as the .cpp files don't exist yet when
+         # cmake is run for the very first time on them -> however the .cpp files might
+         # exist at a later run. at that time we need to skip them, so that we don't add two
+         # different rules for the same moc file
+         GET_SOURCE_FILE_PROPERTY(_skip ${_abs_FILE} SKIP_AUTOMOC)
+
+         IF ( NOT _skip AND EXISTS ${_abs_FILE} )
+
+            FILE(READ ${_abs_FILE} _contents)
+
+            GET_FILENAME_COMPONENT(_abs_PATH ${_abs_FILE} PATH)
+
+            STRING(REGEX MATCHALL "#include +[^ ]+\\.moc[\">]" _match "${_contents}")
+            IF(_match)
+               FOREACH (_current_MOC_INC ${_match})
+                  STRING(REGEX MATCH "[^ <\"]+\\.moc" _current_MOC "${_current_MOC_INC}")
+
+                  GET_filename_component(_basename ${_current_MOC} NAME_WE)
+   #               SET(_header ${CMAKE_CURRENT_SOURCE_DIR}/${_basename}.h)
+                  SET(_header ${_abs_PATH}/${_basename}.h)
+                  SET(_moc    ${CMAKE_CURRENT_BINARY_DIR}/${_current_MOC})
+                  ADD_CUSTOM_COMMAND(OUTPUT ${_moc}
+                     COMMAND ${QT_MOC_EXECUTABLE}
+                     ARGS ${_moc_INCS} ${_header} -o ${_moc}
+                     DEPENDS ${_header}
+                  )
+
+                  MACRO_ADD_FILE_DEPENDENCIES(${_abs_FILE} ${_moc})
+               ENDFOREACH (_current_MOC_INC)
+            ENDIF(_match)
+         ENDIF ( NOT _skip AND EXISTS ${_abs_FILE} )
+      ENDFOREACH (_current_FILE)
+   ENDMACRO(QT4_AUTOMOC)
+
+
+
+  ######################################
+  #
+  #       decide if Qt got found
+  #
+  ######################################
+
+  # if the includes,libraries,moc,uic and rcc are found then we have it
+  IF( QT_LIBRARY_DIR AND QT_INCLUDE_DIR AND QT_MOC_EXECUTABLE AND QT_UIC_EXECUTABLE AND QT_RCC_EXECUTABLE)
+    SET( QT4_FOUND "YES" )
+    IF( NOT Qt4_FIND_QUIETLY)
+      MESSAGE(STATUS "Found Qt-Version ${QTVERSION}")
+    ENDIF( NOT Qt4_FIND_QUIETLY)
+  ELSE( QT_LIBRARY_DIR AND QT_INCLUDE_DIR AND QT_MOC_EXECUTABLE AND QT_UIC_EXECUTABLE AND QT_RCC_EXECUTABLE)
+    SET( QT4_FOUND "NO")
+    SET(QT_QMAKE_EXECUTABLE "${QT_QMAKE_EXECUTABLE}-NOTFOUND" CACHE FILEPATH "Invalid qmake found" FORCE)
+    IF( Qt4_FIND_REQUIRED)
+      IF ( NOT QT_LIBRARY_DIR )
+	MESSAGE(STATUS "Qt libraries NOT found!")
+      ENDIF(NOT QT_LIBRARY_DIR )
+      IF ( NOT QT_INCLUDE_DIR )
+	MESSAGE(STATUS "Qt includes NOT found!")
+      ENDIF( NOT QT_INCLUDE_DIR )
+      IF ( NOT QT_MOC_EXECUTABLE )
+        MESSAGE(STATUS "Qt's moc NOT found!")
+      ENDIF( NOT QT_MOC_EXECUTABLE )
+      IF ( NOT QT_UIC_EXECUTABLE )
+        MESSAGE(STATUS "Qt's uic NOT found!")
+      ENDIF( NOT QT_UIC_EXECUTABLE )
+      IF ( NOT QT_RCC_EXECUTABLE )
+        MESSAGE(STATUS "Qt's rcc NOT found!")
+      ENDIF( NOT QT_RCC_EXECUTABLE )
+      MESSAGE( FATAL_ERROR "Qt libraries, includes, moc, uic or/and rcc NOT found!")
+    ENDIF( Qt4_FIND_REQUIRED)
+  ENDIF( QT_LIBRARY_DIR AND QT_INCLUDE_DIR AND QT_MOC_EXECUTABLE AND QT_UIC_EXECUTABLE AND  QT_RCC_EXECUTABLE)
+  SET(QT_FOUND ${QT4_FOUND})
+
+
+  #######################################
+  #
+  #       System dependent settings  
+  #
+  #######################################
+  # for unix add X11 stuff
+  IF(UNIX)
+    # on OS X X11 may not be required
+    IF (Q_WS_X11)
+    FIND_PACKAGE(X11)
+    ENDIF (Q_WS_X11)
+    FIND_PACKAGE(Threads)
+    SET(QT_QTCORE_LIBRARY ${QT_QTCORE_LIBRARY} ${CMAKE_THREAD_LIBS_INIT})
+  ENDIF(UNIX)
+
+
+  #######################################
+  #
+  #       compatibility settings 
+  #
+  #######################################
+  # Backwards compatibility for CMake1.4 and 1.2
+  SET (QT_MOC_EXE ${QT_MOC_EXECUTABLE} )
+  SET (QT_UIC_EXE ${QT_UIC_EXECUTABLE} )
+
+  SET( QT_QT_LIBRARY "")
+
+ELSE(QT4_QMAKE_FOUND)
+   
+   SET(QT_QMAKE_EXECUTABLE "${QT_QMAKE_EXECUTABLE}-NOTFOUND" CACHE FILEPATH "Invalid qmake found" FORCE)
+   IF(Qt4_FIND_REQUIRED)
+      IF(QT4_INSTALLED_VERSION_TOO_OLD)
+         MESSAGE(FATAL_ERROR "The installed Qt version ${QTVERSION} is too old, at least version ${QT_MIN_VERSION} is required")
+      ELSE(QT4_INSTALLED_VERSION_TOO_OLD)
+         MESSAGE( FATAL_ERROR "Qt qmake not found!")
+      ENDIF(QT4_INSTALLED_VERSION_TOO_OLD)
+   ELSE(Qt4_FIND_REQUIRED)
+      IF(QT4_INSTALLED_VERSION_TOO_OLD AND NOT Qt4_FIND_QUIETLY)
+         MESSAGE(STATUS "The installed Qt version ${QTVERSION} is too old, at least version ${QT_MIN_VERSION} is required")
+      ENDIF(QT4_INSTALLED_VERSION_TOO_OLD AND NOT Qt4_FIND_QUIETLY)
+   ENDIF(Qt4_FIND_REQUIRED)
+ 
+ENDIF (QT4_QMAKE_FOUND)
+



From tm243 at mail.berlios.de  Tue Feb 20 18:27:28 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Tue, 20 Feb 2007 18:27:28 +0100
Subject: [Php-qt-svn] r294 - trunk/php_qt
Message-ID: <200702201727.l1KHRSOc008480@sheep.berlios.de>

Author: tm243
Date: 2007-02-20 18:27:28 +0100 (Tue, 20 Feb 2007)
New Revision: 294

Added:
   trunk/php_qt/CMakeLists.txt
Log:
added forgotten CMakefile to php_qt

Added: trunk/php_qt/CMakeLists.txt
===================================================================
--- trunk/php_qt/CMakeLists.txt	2007-02-20 11:16:43 UTC (rev 293)
+++ trunk/php_qt/CMakeLists.txt	2007-02-20 17:27:28 UTC (rev 294)
@@ -0,0 +1,28 @@
+
+include_directories( 
+    ${QT_INCLUDE_DIR} 
+    ${CMAKE_SOURCE_DIR}/smoke
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${PHP5_INCLUDE_DIR}
+    ${PHP5_MAIN_INCLUDE_DIR}
+    ${PHP5_TSRM_INCLUDE_DIR}
+    ${PHP5_ZEND_INCLUDE_DIR}
+    ${PHP5_REGEX_INCLUDE_DIR}
+    ${PHP5_EXT_INCLUDE_DIR}
+    ${PHP5_DATE_INCLUDE_DIR}
+    ${PHP5_STANDARD_INCLUDE_DIR}
+    )
+
+set(phpqt_LIB_SRCS
+    functions.cpp
+    php_qt.cpp
+    smokephp.cpp
+    qstring.cpp
+    )
+
+add_library(php_qt SHARED ${phpqt_LIB_SRCS})
+
+target_link_libraries(php_qt ${QT_QTCORE_LIBRARY} QtSvg QtGui QtNetwork QtSql QtOpenGL QtXml QtUiTools ${QTDBUS_LIBRARY} ${QSCINTILLA_LIBRARIES} ${QWT_LIBRARIES} smokeqt)
+set_target_properties(php_qt PROPERTIES PREFIX "")
+
+install(TARGETS php_qt DESTINATION ${PHP5_EXTENSION_DIR}/ )



From tm243 at mail.berlios.de  Sun Feb 25 12:46:02 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Sun, 25 Feb 2007 12:46:02 +0100
Subject: [Php-qt-svn] r295 - in trunk: . php_qt
Message-ID: <200702251146.l1PBk20N030122@sheep.berlios.de>

Author: tm243
Date: 2007-02-25 12:46:00 +0100 (Sun, 25 Feb 2007)
New Revision: 295

Modified:
   trunk/ChangeLog
   trunk/php_qt/php_qt.cpp
Log:
:: operator replaced, class_entry table cached

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2007-02-20 17:27:28 UTC (rev 294)
+++ trunk/ChangeLog	2007-02-25 11:46:00 UTC (rev 295)
@@ -1,3 +1,8 @@
+2007-002-25  Thomas Moenicke <thomas.moenicke at kdemail.net>
+
+		* replaced the :: operator
+		* cached the class_entry table
+
 2007-002-19  Thomas Moenicke <thomas.moenicke at kdemail.net>
 
 		* new cmake build system added

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-02-20 17:27:28 UTC (rev 294)
+++ trunk/php_qt/php_qt.cpp	2007-02-25 11:46:00 UTC (rev 295)
@@ -45,9 +45,54 @@
 int le_php_qt_hashtype;
 HashTable php_qt_objptr_hash;
 
+// object handler
 static zend_object_handlers php_qt_handler;
 static zend_object_handlers zend_orig_handler;
 
+// opcode handler
+#define PHPQT_OPHANDLER_COUNT				((25 * 151) + 1)
+#define EX__(element) execute_data->element
+#define EX_T(offset) (*(temp_variable *)((char *) EX__(Ts) + offset))
+static opcode_handler_t *phpqt_original_opcode_handlers;
+static opcode_handler_t phpqt_opcode_handlers[PHPQT_OPHANDLER_COUNT];
+
+static int phpqt_op_fetch_constant(ZEND_OPCODE_HANDLER_ARGS) {
+
+	zend_op *opline = EX__(opline);
+	zend_class_entry *ce = NULL;
+	zval **value;
+
+	if (IS_CONST == IS_UNUSED) {
+		if (!zend_get_constant(opline->op2.u.constant.value.str.val, opline->op2.u.constant.value.str.len, &EX_T(opline->result.u.var).tmp_var TSRMLS_CC)) {
+			cout << "not found" << endl;
+			zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'",
+						opline->op2.u.constant.value.str.val,
+						opline->op2.u.constant.value.str.val);
+			EX_T(opline->result.u.var).tmp_var = opline->op2.u.constant;
+			zval_copy_ctor(&EX_T(opline->result.u.var).tmp_var);
+		}
+		execute_data->opline++;
+	}
+
+	ce = EX_T(opline->op1.u.var).class_entry;
+
+	if (zend_hash_find(&ce->constants_table, opline->op2.u.constant.value.str.val, opline->op2.u.constant.value.str.len+1, (void **) &value) == SUCCESS) {
+		zval_update_constant(value, (void *) 1 TSRMLS_CC);
+		EX_T(opline->result.u.var).tmp_var = **value;
+		zval_copy_ctor(&EX_T(opline->result.u.var).tmp_var);
+	} else {
+		// try to get the Qt constant/enum
+		// opline->op2.u.constant.value.str.val
+		// ce->name
+		php_error(E_ERROR, "Undefined class constant '%s'", opline->op2.u.constant.value.str.val);
+	}
+
+	execute_data->opline++;
+	return 0;
+
+}
+
+
 /*! php_qt_functions[]
  *
  * Every user visible function must have an entry in php_qt_functions[].
@@ -330,6 +375,17 @@
 	zend_orig_handler = php_qt_handler;
 	php_qt_handler.get_method = proxyHandler;
 
+	// overwrite :: operator
+	memcpy(phpqt_opcode_handlers, zend_opcode_handlers, sizeof(phpqt_opcode_handlers));
+	phpqt_original_opcode_handlers = zend_opcode_handlers;
+	zend_opcode_handlers = phpqt_opcode_handlers;
+	{ 
+	int i; 
+	for(i = 0; i < 25; i++) 
+	    if (phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + i]) 
+		phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + i] = phpqt_op_fetch_constant; 
+	}
+
 	smokephp_init();
 
 // TODO		QObject Nummer suchen, nachher vergleichen
@@ -341,6 +397,8 @@
     php_qt_static_methods = (zend_function_entry***) safe_emalloc((qt_Smoke->numClasses), sizeof(zend_function_entry **), 0);
 
     int method_count;
+    // cache class entries
+    QHash<const char*, zend_class_entry*> tmpCeTable;
 	// loop for all classes, register them
 	for(Smoke::Index i = 1; i <= qt_Smoke->numClasses; i++){
 
@@ -350,7 +408,7 @@
         for(int j=0;j<qt_Smoke->numMethods;j++){
             if(qt_Smoke->methods[j].classId == i){
                 if(!(qt_Smoke->methods[j].flags & Smoke::mf_enum)){
-                    if((qt_Smoke->methods[j].flags & Smoke::mf_static) && (qt_Smoke->methods[j].classId == i)){
+                    if((qt_Smoke->methods[j].flags & Smoke::mf_static)){
                         // avoids overloaded methods
                         if(strcmp(qt_Smoke->methodNames[qt_Smoke->methods[j-1].name],qt_Smoke->methodNames[qt_Smoke->methods[j].name])){
                             method_count++;
@@ -368,7 +426,7 @@
         PHP_QT_ME(php_qt_generic_class,__toString,NULL,ZEND_ACC_PUBLIC);
         PHP_QT_ME(php_qt_generic_class,proxyMethod,NULL,ZEND_ACC_PUBLIC);
 
-		QHash<const char*, bool> tmpMethodList;	// avoids doubled method names
+	QHash<const char*, bool> tmpMethodList;	// avoids doubled method names
 
         for(int j=0;j<qt_Smoke->numMethods;j++){
             if(qt_Smoke->methods[j].classId == i){
@@ -398,58 +456,29 @@
         t->flags = NULL;
         t++;
 
-		// register class
-	    zend_class_entry ce;
-	    INIT_CLASS_ENTRY(ce, qt_Smoke->classes[i].className, p);
-	    ce.name_length = strlen(qt_Smoke->classes[i].className);
-	    zend_class_entry* ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);
-		if(qobject == i){
-			qobject_ce = ce_ptr;
-		}
-		else if(qstring == i){
-			qstring_ce = ce_ptr;
-		}
-
-        // register enums
-		if(!strcmp(qt_Smoke->classes[i].className, "Qt")){
-			zend_declare_class_constant_long(ce_ptr, "Horizontal", strlen("Horizontal"), Qt::Horizontal);
-			zend_declare_class_constant_long(ce_ptr, "Vertical", strlen("Vertical"), Qt::Vertical);
-			zend_declare_class_constant_long(ce_ptr, "AlignRight", strlen("AlignRight"), Qt::AlignRight);
-			zend_declare_class_constant_long(ce_ptr, "LeftButton", strlen("LeftButton"), Qt::LeftButton);
-		} else if(!strcmp(qt_Smoke->classes[i].className, "QPalette")){
-			zend_declare_class_constant_long(ce_ptr, "Button", strlen("Button"), QPalette::Button);
-			zend_declare_class_constant_long(ce_ptr, "Text", strlen("Text"), QPalette::Text);
-			zend_declare_class_constant_long(ce_ptr, "Base", strlen("Base"), QPalette::Base);
-		} else if(!strcmp(qt_Smoke->classes[i].className, "QSizePolicy")){
-			zend_declare_class_constant_long(ce_ptr, "Expanding", strlen("Expanding"), QSizePolicy::Expanding);
-			zend_declare_class_constant_long(ce_ptr, "Preferred", strlen("Preferred"), QSizePolicy::Preferred);
-		} else if(!strcmp(qt_Smoke->classes[i].className, "QLayout")){
-			zend_declare_class_constant_long(ce_ptr, "SetFixedSize", strlen("SetFixedSize"), QLayout::SetFixedSize);
-		} else if(!strcmp(qt_Smoke->classes[i].className, "QEvent")){
-			zend_declare_class_constant_long(ce_ptr, "MouseButtonPress", strlen("MouseButtonPress"), QEvent::MouseButtonPress);
-			zend_declare_class_constant_long(ce_ptr, "MouseButtonDblClick", strlen("MouseButtonDblClick"), QEvent::MouseButtonDblClick);
-			zend_declare_class_constant_long(ce_ptr, "MouseButtonRelease", strlen("MouseButtonRelease"), QEvent::MouseButtonRelease);
-			zend_declare_class_constant_long(ce_ptr, "ContextMenu", strlen("ContextMenu"), QEvent::ContextMenu);
-		} else if(!strcmp(qt_Smoke->classes[i].className, "QLCDNumber")){
-			zend_declare_class_constant_long(ce_ptr, "Filled", strlen("Filled"), QLCDNumber::Filled);
-		} else if(!strcmp(qt_Smoke->classes[i].className, "QFont")){
-			zend_declare_class_constant_long(ce_ptr, "Bold", strlen("Bold"), QFont::Bold);
-		} 
-		
+	// register zend class
+	zend_class_entry ce;
+	INIT_CLASS_ENTRY(ce, qt_Smoke->classes[i].className, p);
+	ce.name_length = strlen(qt_Smoke->classes[i].className);
+	zend_class_entry* ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);
+	tmpCeTable[qt_Smoke->classes[i].className] = ce_ptr;
+	// cache QObject
+	if(qobject == i){
+	    qobject_ce = ce_ptr;
+	}		
 	} // end for
 
+    // do inheritance
     for(Smoke::Index i = 1; i <= qt_Smoke->numClasses; i++){
-		zend_class_entry *ce = zend_fetch_class((char*) qt_Smoke->classes[i].className, strlen(qt_Smoke->classes[i].className), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
-
-        // inheritance
-	    for(Smoke::Index *p = qt_Smoke->inheritanceList + qt_Smoke->classes[i].parents; *p; p++) {
-		    zend_class_entry *parent_ce = zend_fetch_class((char*) qt_Smoke->classes[*p].className, strlen(qt_Smoke->classes[*p].className), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
-            zend_do_inheritance(ce, parent_ce TSRMLS_CC);
-        }
+	zend_class_entry* ce = tmpCeTable[qt_Smoke->classes[i].className];
+	for(Smoke::Index *p = qt_Smoke->inheritanceList + qt_Smoke->classes[i].parents; *p; p++) {
+	    zend_class_entry *parent_ce = tmpCeTable[qt_Smoke->classes[*p].className];
+    	    zend_do_inheritance(ce, parent_ce TSRMLS_CC);
+	}
     }
 
-	return SUCCESS;
-}
+    return SUCCESS;
+} // PHP_MINIT
 
 
 /* PHP_MSHUTDOWN_FUNCTION



From tm243 at mail.berlios.de  Sun Feb 25 13:32:50 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Sun, 25 Feb 2007 13:32:50 +0100
Subject: [Php-qt-svn] r296 - trunk/php_qt
Message-ID: <200702251232.l1PCWowG015910@sheep.berlios.de>

Author: tm243
Date: 2007-02-25 13:32:50 +0100 (Sun, 25 Feb 2007)
New Revision: 296

Modified:
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/smokephp.cpp
Log:
method naming convention

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-02-25 11:46:00 UTC (rev 295)
+++ trunk/php_qt/php_qt.cpp	2007-02-25 12:32:50 UTC (rev 296)
@@ -366,7 +366,7 @@
 {
 
 	// object list
-	le_php_qt_hashtype = zend_register_list_destructors_ex(phpqt_destroy_hashtable, NULL, "PHP-Qt object list", module_number);
+	le_php_qt_hashtype = zend_register_list_destructors_ex(phpqt_destroyHashtable, NULL, "PHP-Qt object list", module_number);
 	// FIXME: 50 is fix
 	zend_hash_init_ex(&php_qt_objptr_hash, PHPQT_CLASS_COUNT, NULL, NULL, 1, 0);
 
@@ -604,7 +604,7 @@
 
         }
 
-        phpqt_callmethod(so->zval_ptr, method_name, j, args);
+        phpqt_callMethod(so->zval_ptr, method_name, j, args);
 
     // is a signal
     } else {
@@ -669,7 +669,7 @@
 }
 
 static void 
-phpqt_destroy_hashtable(zend_rsrc_list_entry *rsrc TSRMLS_DC)
+phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc TSRMLS_DC)
 {
 #ifdef DEBUG
 	php_error(E_ERROR,"Hashtable destroyed. Shutdown PHP-Qt now.");
@@ -695,7 +695,7 @@
 }
 
 zval* 
-phpqt_callmethod(zval* this_ptr, char* methodname, zend_uint param_count, zval** args[])
+phpqt_callMethod(zval* this_ptr, char* methodname, zend_uint param_count, zval** args[])
 {
 
 	if(this_ptr == NULL){
@@ -828,7 +828,7 @@
  */
 
 zval* 
-phpqt_fetch_zend_ptr(const QObject *o){
+phpqt_fetchZendPtr(const QObject *o){
 	return zval_x_qt[(void*) o];
 }
 

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-02-25 11:46:00 UTC (rev 295)
+++ trunk/php_qt/php_qt.h	2007-02-25 12:32:50 UTC (rev 296)
@@ -108,13 +108,13 @@
 
 //zend_class_entry* php_qt_generic_class;
 
-static void 		phpqt_destroy_hashtable(zend_rsrc_list_entry *rsrc);
+static void 		phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc);
 smokephp_object* 	phpqt_fetch(zval* this_ptr);
 void 				phpqt_register(zval* this_ptr, zend_rsrc_list_entry le);
-zval* 				phpqt_callmethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params[]);
+zval* 				phpqt_callMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params[]);
 bool 				phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname);
 bool 				phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* metachar, QString* meta_stringdata, uint* signature);
-zval* 				phpqt_fetch_zend_ptr(const QObject *o);
+zval* 				phpqt_fetchZendPtr(const QObject *o);
 int					phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
 char*				phpqt_checkForOperator(const char* fname);
 bool				phpqt_zval2qtIsEnd(void *o);

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-02-25 11:46:00 UTC (rev 295)
+++ trunk/php_qt/smokephp.cpp	2007-02-25 12:32:50 UTC (rev 296)
@@ -469,7 +469,7 @@
 			// zval already exists
 //			if(zval_x_qt.find(o) != zval_x_qt.end()){
 			if(phpqt_zval2qtIsEnd(o)){
-				return_value = phpqt_fetch_zend_ptr((QObject*) o->ptr);
+				return_value = phpqt_fetchZendPtr((QObject*) o->ptr);
 			// create a new one
 			} else {
 				



From tm243 at mail.berlios.de  Sun Feb 25 13:47:49 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Sun, 25 Feb 2007 13:47:49 +0100
Subject: [Php-qt-svn] r297 - trunk/php_qt
Message-ID: <200702251247.l1PClnvd016724@sheep.berlios.de>

Author: tm243
Date: 2007-02-25 13:47:48 +0100 (Sun, 25 Feb 2007)
New Revision: 297

Modified:
   trunk/php_qt/php_qt.cpp
Log:
constant handler renamed

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-02-25 12:32:50 UTC (rev 296)
+++ trunk/php_qt/php_qt.cpp	2007-02-25 12:47:48 UTC (rev 297)
@@ -56,7 +56,7 @@
 static opcode_handler_t *phpqt_original_opcode_handlers;
 static opcode_handler_t phpqt_opcode_handlers[PHPQT_OPHANDLER_COUNT];
 
-static int phpqt_op_fetch_constant(ZEND_OPCODE_HANDLER_ARGS) {
+static int constantHandler(ZEND_OPCODE_HANDLER_ARGS) {
 
 	zend_op *opline = EX__(opline);
 	zend_class_entry *ce = NULL;
@@ -383,7 +383,7 @@
 	int i; 
 	for(i = 0; i < 25; i++) 
 	    if (phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + i]) 
-		phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + i] = phpqt_op_fetch_constant; 
+		phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + i] = constantHandler; 
 	}
 
 	smokephp_init();



From tm243 at mail.berlios.de  Tue Feb 27 16:25:57 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Tue, 27 Feb 2007 16:25:57 +0100
Subject: [Php-qt-svn] r298 - in trunk: . php_qt tests
Message-ID: <200702271525.l1RFPvCP017739@sheep.berlios.de>

Author: tm243
Date: 2007-02-27 16:25:56 +0100 (Tue, 27 Feb 2007)
New Revision: 298

Added:
   trunk/tests/QtBasicTestCase.php
   trunk/tests/QtLoadModuleTestCase.php
Modified:
   trunk/ChangeLog
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/qstring.cpp
   trunk/php_qt/smokephp.cpp
Log:
* implemented constant handler
* registered QString, improved inheritance
* added unittests



Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2007-02-25 12:47:48 UTC (rev 297)
+++ trunk/ChangeLog	2007-02-27 15:25:56 UTC (rev 298)
@@ -1,3 +1,10 @@
+2007-002-27  Thomas Moenicke <thomas.moenicke at kdemail.net>
+
+		* implemented constantHandler which fetchs constants from Qt
+		* registered QString
+		* improved inheritance
+		* added unittests
+
 2007-002-25  Thomas Moenicke <thomas.moenicke at kdemail.net>
 
 		* replaced the :: operator

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-02-25 12:47:48 UTC (rev 297)
+++ trunk/php_qt/php_qt.cpp	2007-02-27 15:25:56 UTC (rev 298)
@@ -81,10 +81,27 @@
 		EX_T(opline->result.u.var).tmp_var = **value;
 		zval_copy_ctor(&EX_T(opline->result.u.var).tmp_var);
 	} else {
-		// try to get the Qt constant/enum
-		// opline->op2.u.constant.value.str.val
-		// ce->name
-		php_error(E_ERROR, "Undefined class constant '%s'", opline->op2.u.constant.value.str.val);
+		// enums are methods here
+		Smoke::Index method = qt_Smoke->findMethod(ce->name, opline->op2.u.constant.value.str.val);
+		if(method <= 0) // smoke could not find one
+		    php_error(E_ERROR, "undefined class constant '%s'", opline->op2.u.constant.value.str.val);
+
+		method = qt_Smoke->methodMaps[method].method;
+
+		// get the Qt value
+		Smoke::Stack args = (Smoke::Stack) safe_emalloc(1, sizeof(Smoke::Stack), 0);
+		void* dummy; // dummy here
+		smokephp_callMethod(qt_Smoke, dummy, method, args);
+
+		// write the zend return value
+		zval* return_value;
+		MAKE_STD_ZVAL(return_value);
+		ZVAL_LONG(return_value, args[0].s_enum);
+		EX_T(opline->result.u.var).tmp_var = *return_value;
+		zval_copy_ctor(&EX_T(opline->result.u.var).tmp_var);
+
+		efree(args);
+
 	}
 
 	execute_data->opline++;
@@ -140,6 +157,7 @@
 Smoke::Index qobject;
 zend_class_entry* qobject_ce;
 extern zend_class_entry* qstring_ce;
+extern void 	_register_QString();
 
 /**
  *	proxy handler
@@ -379,12 +397,7 @@
 	memcpy(phpqt_opcode_handlers, zend_opcode_handlers, sizeof(phpqt_opcode_handlers));
 	phpqt_original_opcode_handlers = zend_opcode_handlers;
 	zend_opcode_handlers = phpqt_opcode_handlers;
-	{ 
-	int i; 
-	for(i = 0; i < 25; i++) 
-	    if (phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + i]) 
-		phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + i] = constantHandler; 
-	}
+	phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + 0] = constantHandler; 
 
 	smokephp_init();
 
@@ -392,15 +405,15 @@
 	smokephp_findConnect();
 
 	Smoke::Index qobject = smokephp_getClassId("QObject");
-//	Smoke::Index qstring = smokephp_getClassId("QString");
 
-    php_qt_static_methods = (zend_function_entry***) safe_emalloc((qt_Smoke->numClasses), sizeof(zend_function_entry **), 0);
+	php_qt_static_methods = (zend_function_entry***) safe_emalloc((qt_Smoke->numClasses), sizeof(zend_function_entry **), 0);
 
-    int method_count;
-    // cache class entries
-    QHash<const char*, zend_class_entry*> tmpCeTable;
+	int method_count;
+	// cache class entries
+	Smoke::Index i = 1;
+	QHash<const char*, zend_class_entry*> tmpCeTable;
 	// loop for all classes, register them
-	for(Smoke::Index i = 1; i <= qt_Smoke->numClasses; i++){
+	for(i = 1; i <= qt_Smoke->numClasses; i++){
 
         // statical methods, there is no method handler which can be overwritten
         // hope this will be better in future / see zend_std_get_static_method()
@@ -468,15 +481,20 @@
 	}		
 	} // end for
 
-    // do inheritance
-    for(Smoke::Index i = 1; i <= qt_Smoke->numClasses; i++){
-	zend_class_entry* ce = tmpCeTable[qt_Smoke->classes[i].className];
-	for(Smoke::Index *p = qt_Smoke->inheritanceList + qt_Smoke->classes[i].parents; *p; p++) {
-	    zend_class_entry *parent_ce = tmpCeTable[qt_Smoke->classes[*p].className];
-    	    zend_do_inheritance(ce, parent_ce TSRMLS_CC);
+	_register_QString();
+	tmpCeTable[qt_Smoke->classes[i].className] = qstring_ce;
+
+	// do inheritance, all classes must be defined before
+	for(Smoke::Index i = 1; i <= qt_Smoke->numClasses; i++){
+	    zend_class_entry* ce = tmpCeTable[qt_Smoke->classes[i].className];
+	    for(Smoke::Index *p = qt_Smoke->inheritanceList + qt_Smoke->classes[i].parents; *p; p++) {
+		zend_class_entry *parent_ce = tmpCeTable[qt_Smoke->classes[*p].className];
+    		zend_do_inheritance(ce, parent_ce TSRMLS_CC);
+	    }
 	}
-    }
 
+    tmpCeTable.~QHash();
+
     return SUCCESS;
 } // PHP_MINIT
 
@@ -485,8 +503,8 @@
  */
 PHP_MSHUTDOWN_FUNCTION(php_qt)
 {
-    methodNameStack.~QStack();
-	SmokeToPtr.~QHash();
+//	methodNameStack.~QStack();
+//	SmokeToPtr.~QHash();
 	return SUCCESS;
 }
 
@@ -840,17 +858,16 @@
 /**
  *	maps method names to the related names of operator-extension
  *	@param	const char*		fname		function name
- *  TODO: implement! ask in proxyHandler for it
  */
 
 char*
 phpqt_checkForOperator(const char* fname){
+#warning skip operator support
 	return (char*) fname;
 }
 
 smokephp_object*
 phpqt_getSmokePHPObject(void* ptr){
-	smokephp_object* a = (smokephp_object*) SmokeToPtr[ptr];
 	return (smokephp_object*) SmokeToPtr[ptr];
 }
 

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-02-25 12:47:48 UTC (rev 297)
+++ trunk/php_qt/php_qt.h	2007-02-27 15:25:56 UTC (rev 298)
@@ -136,3 +136,139 @@
 void				smokephp_init();
 Smoke::Index		smokephp_findConnect();
 bool				smokephp_isConnect(Smoke::Index method);
+
+
+class SmokeType {
+    Smoke::Type *_t;		// derived from _smoke and _id, but cached
+
+    Smoke *_smoke;
+    Smoke::Index _id;
+public:
+    SmokeType() : _t(0), _smoke(0), _id(0) {}
+    SmokeType(Smoke *s, Smoke::Index i) : _smoke(s), _id(i) {
+	if(_id < 0 || _id > _smoke->numTypes) _id = 0;
+	_t = _smoke->types + _id;
+    }
+    // default copy constructors are fine, this is a constant structure
+
+    // mutators
+    void set(Smoke *s, Smoke::Index i) {
+	_smoke = s;
+	_id = i;
+	_t = _smoke->types + _id;
+    }
+
+    // accessors
+    Smoke *smoke() const { return _smoke; }
+    Smoke::Index typeId() const { return _id; }
+    const Smoke::Type &type() const { return *_t; }
+    unsigned short flags() const { return _t->flags; }
+    unsigned short elem() const { return _t->flags & Smoke::tf_elem; }
+    const char *name() const { return _t->name; }
+    Smoke::Index classId() const { return _t->classId; }
+
+    // tests
+    bool isStack() const { return ((flags() & Smoke::tf_ref) == Smoke::tf_stack); }
+    bool isPtr() const { return ((flags() & Smoke::tf_ref) == Smoke::tf_ptr); }
+    bool isRef() const { return ((flags() & Smoke::tf_ref) == Smoke::tf_ref); }
+    bool isConst() const { return (flags() & Smoke::tf_const); }
+    bool isClass() const {
+	if(elem() == Smoke::t_class)
+	    return classId() ? true : false;
+	return false;
+    }
+
+    bool operator ==(const SmokeType &b) const {
+	const SmokeType &a = *this;
+	if(a.name() == b.name()) return true;
+	if(a.name() && b.name() && qstrcmp(a.name(), b.name()) == 0)
+	    return true;
+	return false;
+    }
+    bool operator !=(const SmokeType &b) const {
+	const SmokeType &a = *this;
+	return !(a == b);
+    }
+
+};
+
+ZEND_METHOD(QString, __toString);
+ZEND_METHOD(QString, compare);
+ZEND_METHOD(QString, utf16);
+ZEND_METHOD(QString, constData);
+ZEND_METHOD(QString, insert);
+ZEND_METHOD(QString, clear);
+ZEND_METHOD(QString, setUtf16);
+ZEND_METHOD(QString, prepend);
+ZEND_METHOD(QString, trimmed);
+ZEND_METHOD(QString, chop);
+ZEND_METHOD(QString, leftJustified);
+ZEND_METHOD(QString, squeeze);
+ZEND_METHOD(QString, count);
+ZEND_METHOD(QString, fromAscii);
+ZEND_METHOD(QString, toLongLong);
+ZEND_METHOD(QString, toUpper);
+ZEND_METHOD(QString, __construct);
+ZEND_METHOD(QString, normalized);
+ZEND_METHOD(QString, fromUtf16);
+ZEND_METHOD(QString, isRightToLeft);
+ZEND_METHOD(QString, setNum);
+ZEND_METHOD(QString, endsWith);
+ZEND_METHOD(QString, number);
+ZEND_METHOD(QString, localeAwareCompare);
+ZEND_METHOD(QString, section);
+ZEND_METHOD(QString, isSimpleText);
+ZEND_METHOD(QString, size);
+ZEND_METHOD(QString, simplified);
+ZEND_METHOD(QString, toUInt);
+ZEND_METHOD(QString, toUShort);
+ZEND_METHOD(QString, truncate);
+ZEND_METHOD(QString, toAscii);
+ZEND_METHOD(QString, length);
+ZEND_METHOD(QString, right);
+ZEND_METHOD(QString, push_front);
+ZEND_METHOD(QString, toUtf8);
+ZEND_METHOD(QString, toULongLong);
+ZEND_METHOD(QString, indexOf);
+ZEND_METHOD(QString, fromRawData);
+ZEND_METHOD(QString, constEnd);
+ZEND_METHOD(QString, left);
+ZEND_METHOD(QString, fromLocal8Bit);
+ZEND_METHOD(QString, startsWith);
+ZEND_METHOD(QString, remove);
+ZEND_METHOD(QString, isEmpty);
+ZEND_METHOD(QString, arg);
+ZEND_METHOD(QString, vsprintf);
+ZEND_METHOD(QString, toFloat);
+ZEND_METHOD(QString, isDetached);
+ZEND_METHOD(QString, reserve);
+ZEND_METHOD(QString, toULong);
+ZEND_METHOD(QString, toShort);
+ZEND_METHOD(QString, split);
+ZEND_METHOD(QString, setUnicode);
+ZEND_METHOD(QString, fromLatin1);
+ZEND_METHOD(QString, data);
+ZEND_METHOD(QString, toLatin1);
+ZEND_METHOD(QString, end);
+ZEND_METHOD(QString, contains);
+ZEND_METHOD(QString, resize);
+ZEND_METHOD(QString, replace);
+ZEND_METHOD(QString, fromUtf8);
+ZEND_METHOD(QString, toLong);
+ZEND_METHOD(QString, detach);
+ZEND_METHOD(QString, append);
+ZEND_METHOD(QString, mid);
+ZEND_METHOD(QString, toDouble);
+ZEND_METHOD(QString, fill);
+ZEND_METHOD(QString, rightJustified);
+ZEND_METHOD(QString, toLower);
+ZEND_METHOD(QString, lastIndexOf);
+ZEND_METHOD(QString, unicode);
+ZEND_METHOD(QString, at);
+ZEND_METHOD(QString, begin);
+ZEND_METHOD(QString, push_back);
+ZEND_METHOD(QString, capacity);
+ZEND_METHOD(QString, constBegin);
+ZEND_METHOD(QString, toLocal8Bit);
+ZEND_METHOD(QString, toInt);
+ZEND_METHOD(QString, isNull);

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-02-25 12:47:48 UTC (rev 297)
+++ trunk/php_qt/qstring.cpp	2007-02-27 15:25:56 UTC (rev 298)
@@ -35,6 +35,100 @@
 
 zend_class_entry* qstring_ce;
 
+static zend_function_entry QString_methods[] = {
+	ZEND_ME(QString,__toString,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,compare,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,utf16,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,constData,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,insert,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,clear,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,setUtf16,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,prepend,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,trimmed,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,chop,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,leftJustified,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,squeeze,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,count,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,fromAscii,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+	ZEND_ME(QString,toLongLong,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toUpper,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString, __construct,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,normalized,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,fromUtf16,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+	ZEND_ME(QString,isRightToLeft,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,setNum,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,endsWith,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,number,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+	ZEND_ME(QString,localeAwareCompare,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,section,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,isSimpleText,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,size,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,simplified,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toUInt,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toUShort,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,truncate,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toAscii,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,length,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,right,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,push_front,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toUtf8,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toULongLong,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,indexOf,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,fromRawData,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+	ZEND_ME(QString,constEnd,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,left,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,fromLocal8Bit,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+	ZEND_ME(QString,startsWith,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,remove,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,isEmpty,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,arg,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,vsprintf,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toFloat,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,isDetached,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,reserve,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toULong,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toShort,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,split,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,setUnicode,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,fromLatin1,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+	ZEND_ME(QString,data,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toLatin1,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,end,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,contains,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,resize,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,replace,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,fromUtf8,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
+	ZEND_ME(QString,toLong,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,detach,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,append,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,mid,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toDouble,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,fill,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,rightJustified,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toLower,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,lastIndexOf,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,unicode,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,at,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,begin,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,push_back,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,capacity,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,constBegin,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toLocal8Bit,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,toInt,NULL,ZEND_ACC_PUBLIC)
+	ZEND_ME(QString,isNull,NULL,ZEND_ACC_PUBLIC)
+
+    {NULL,NULL,NULL}
+};
+
+void _register_QString(TSRMLS_D)
+{
+    zend_class_entry ce;
+    INIT_CLASS_ENTRY(ce,"QString",QString_methods);
+    qstring_ce = zend_register_internal_class(&ce TSRMLS_CC);
+
+}
+
+
 ZEND_METHOD(QString,__toString){
 
   QString *QString_ptr = (QString *) PHP_QT_FETCH();
@@ -2103,8 +2197,6 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString & return_object = (QString &) obj->append((char) Z_LVAL_P(z_0));
 				zend_class_entry *ce;                                   
 				object_init_ex(return_value, qstring_ce);     
@@ -2492,6 +2584,5 @@
 	}
 }
 
-# warning: implement me
 //PHP_QT_DESTRUCT(QString);
 

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-02-25 12:47:48 UTC (rev 297)
+++ trunk/php_qt/smokephp.cpp	2007-02-27 15:25:56 UTC (rev 298)
@@ -91,14 +91,14 @@
 void 
 smokephp_init() {
 
-    if (qt_Smoke != 0L) {
-		php_error(E_ERROR,"could not initialize smoke");
+/*    if (qt_Smoke != 0L) {
+	php_error(E_ERROR,"could not initialize smoke");
     }
-
+*/
     init_qt_Smoke();
 
     if(qt_Smoke->numClasses <= 0){
-		php_error(E_ERROR,"could not initialize smoke");
+	php_error(E_ERROR,"could not initialize smoke (no class definitions)");
     }
 
     qt_Smoke->binding = new PHPQtSmokeBinding(qt_Smoke);

Added: trunk/tests/QtBasicTestCase.php
===================================================================
--- trunk/tests/QtBasicTestCase.php	2007-02-25 12:47:48 UTC (rev 297)
+++ trunk/tests/QtBasicTestCase.php	2007-02-27 15:25:56 UTC (rev 298)
@@ -0,0 +1,105 @@
+<?php
+
+    /**
+     *	This file contains a couple of basic tests
+     *
+     *	- test fetching constants, the opcode handler has been overwritten
+     *	- test __toString()
+     *	- test QString
+     *	- test returning values and objects
+     *  - test returning references
+     */
+
+    require_once('PHPUnit/Framework/TestCase.php');
+    require_once('PHPUnit/Framework/TestSuite.php');
+
+    /* 
+     * check if we can fetch constants
+     */
+
+    class foo {
+	const a = "a";
+	const b = 24;
+    }
+
+
+
+    class QtBasicTestCase extends PHPUnit_Framework_TestCase {
+    
+	private $argc = 1; 
+	private $argv = "init";
+	private $app;
+    
+	public function __construct($name) {
+	    parent::__construct($name);
+	}
+
+	// try to fetch a string constant
+	function testFetchStringConstant() {
+	    $this->assertEquals(foo::a, "a", "Could not fetch string constant!");
+	}
+
+	// try to fetch a numeric constant
+	function testFetchNumConstant() {
+	    $this->assertEquals(foo::b, 24, "Could not fetch numeric constant!");
+	}
+
+	// try to fetch a Qt constant
+	function testQtConstant() {
+	    $this->assertTrue(Qt::Horizontal == 1, "Could not fetch constant from Qt!");
+	}
+
+	// test the __toString() method
+	function testQString() {
+	    $s = new QString("hello");
+	    $this->assertEquals($s->__toString(), "hello", "Could not handle __toString()!");
+	}
+
+	// try to append a PHP string to a QString
+	function testQStringAppendString() {
+	    $s = new QString("hello");
+	    $s->append(" world");
+	    $this->assertEquals($s->__toString(), "hello world", "Could append simple string to QString!");
+	}
+
+	// try to create an instance of QApplication
+	function testQApplication() {
+	    $this->app = new QApplication(&$this->argc,$this->argv);
+	    $this->assertTrue(is_object($this->app), "Could not create an instance of QApplication!");
+	}
+
+	// try to get a QString as return value
+	function testReturnQString() {
+	    $object = new QObject();
+	    $object->setText("hello");
+	    $string = $object->getText();
+	    $this->assertTrue(is_object($string), "Value returned by getText() is not valid.");
+	    $this->assertEquals($string->__toString(), "hello", "Return object does not contain the same text!");
+	}
+
+	// try to give a QString as argument
+/*	function testAddQString() {
+	    $object = new QObject();
+	    $string = new QString("hello");
+//	    $object->setText($string);
+	    $s = $object->getText();
+	    $this->assertEquals($s->__toString(),"hello", "Return object does not contain the same text!");
+	}
+*/
+	// try to get an return Object
+	// try to give an object as argument
+	// try to give an object as argument, modify it, give it back and check if it is the same
+
+	// try to append a QString to a QString
+/*	function testQStringAppendObject() {
+	    $s = new QString("hello");
+	    $t = new QString(" world");
+	    $s->append($t);
+	    $this->assertEquals($s->__toString(), "hello world", "Could not append QString to QString!");
+	}
+*/
+    
+
+    }    
+    
+?>
\ No newline at end of file

Added: trunk/tests/QtLoadModuleTestCase.php
===================================================================
--- trunk/tests/QtLoadModuleTestCase.php	2007-02-25 12:47:48 UTC (rev 297)
+++ trunk/tests/QtLoadModuleTestCase.php	2007-02-27 15:25:56 UTC (rev 298)
@@ -0,0 +1,31 @@
+<?php
+
+    /**
+     *	This file tests if the module loads properly
+     */
+
+    require_once('PHPUnit/Framework/TestCase.php');
+    require_once('PHPUnit/Framework/TestSuite.php');
+
+
+    class QtLoadModuleTestCase extends PHPUnit_Framework_TestCase {
+    
+	public function __construct($name) {
+	    parent::__construct($name);
+	}
+    
+	function testModule() {
+	    $this->assertTrue(extension_loaded('php_qt'), "Module PHP-Qt is not loaded!");
+	}
+
+	function testClassQt() {
+	    $this->assertTrue(class_exists('Qt'), "class Qt not found!");
+	}
+
+	function testClassQString() {
+	    $this->assertTrue(class_exists('QString'), "class QString not found!");
+	}
+
+    }    
+    
+?>
\ No newline at end of file



From tm243 at mail.berlios.de  Tue Feb 27 19:49:49 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Tue, 27 Feb 2007 19:49:49 +0100
Subject: [Php-qt-svn] r299 - trunk/tests
Message-ID: <200702271849.l1RInno7026878@sheep.berlios.de>

Author: tm243
Date: 2007-02-27 19:49:49 +0100 (Tue, 27 Feb 2007)
New Revision: 299

Modified:
   trunk/tests/box2buttons.php
Log:
* repaired Box2Buttons test



Modified: trunk/tests/box2buttons.php
===================================================================
--- trunk/tests/box2buttons.php	2007-02-27 15:25:56 UTC (rev 298)
+++ trunk/tests/box2buttons.php	2007-02-27 18:49:49 UTC (rev 299)
@@ -11,7 +11,7 @@
 	
 		function __construct() {
 			$this->mainWidget = new QWidget();
-			parent::__construct(QBOXLAYOUT_DIRECTION_TOP_TO_BOTTOM,$this->mainWidget);
+			parent::__construct(QBoxLayout::TopToBottom,$this->mainWidget);
 			$this->button1 = new QPushButton("About Qt!");
 			$this->button2 = new QPushButton("Quit");
 			$this->addWidget($this->button1);
@@ -32,7 +32,7 @@
 	}
 	
 	
-	$app = new QApplication($argc,$argv);
+	$app = new QApplication(&$argc,$argv);
 
 	$box = new Box();
 	$box->show();



