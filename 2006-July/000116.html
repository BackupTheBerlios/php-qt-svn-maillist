<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Php-qt-svn] r272 - in trunk: . kalyptus smoke smoke/kde smoke/qt
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/php-qt-svn/2006-July/index.html" >
   <LINK REL="made" HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r272%20-%20in%20trunk%3A%20.%20kalyptus%20smoke%20smoke/kde%20smoke/qt&In-Reply-To=%3C200607231624.k6NGOKHt001093%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000115.html">
   <LINK REL="Next"  HREF="000117.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Php-qt-svn] r272 - in trunk: . kalyptus smoke smoke/kde smoke/qt</H1>
    <B>tm243 at BerliOS</B> 
    <A HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r272%20-%20in%20trunk%3A%20.%20kalyptus%20smoke%20smoke/kde%20smoke/qt&In-Reply-To=%3C200607231624.k6NGOKHt001093%40sheep.berlios.de%3E"
       TITLE="[Php-qt-svn] r272 - in trunk: . kalyptus smoke smoke/kde smoke/qt">tm243 at mail.berlios.de
       </A><BR>
    <I>Sun Jul 23 18:24:20 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000115.html">[Php-qt-svn] r271 - trunk/admin
</A></li>
        <LI>Next message: <A HREF="000117.html">[Php-qt-svn] r273 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#116">[ date ]</a>
              <a href="thread.html#116">[ thread ]</a>
              <a href="subject.html#116">[ subject ]</a>
              <a href="author.html#116">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tm243
Date: 2006-07-23 18:24:10 +0200 (Sun, 23 Jul 2006)
New Revision: 272

Added:
   trunk/kalyptus/
   trunk/kalyptus/Ast.pm
   trunk/kalyptus/ChangeLog
   trunk/kalyptus/Iter.pm
   trunk/kalyptus/Makefile.cvs
   trunk/kalyptus/Makefile.in
   trunk/kalyptus/README
   trunk/kalyptus/TODO
   trunk/kalyptus/Version
   trunk/kalyptus/configure.in
   trunk/kalyptus/dcopidlng
   trunk/kalyptus/findperl
   trunk/kalyptus/install-sh
   trunk/kalyptus/kalyptus
   trunk/kalyptus/kalyptus.spec.in
   trunk/kalyptus/kalyptusCxxToSmoke.pm
   trunk/kalyptus/kalyptusDataDict.pm
   trunk/kalyptus/kdocAstUtil.pm
   trunk/kalyptus/kdocLib.pm
   trunk/kalyptus/kdocParseDoc.pm
   trunk/kalyptus/kdocUtil.pm
   trunk/kalyptus/perlbin
   trunk/smoke/
   trunk/smoke/Makefile.am
   trunk/smoke/Makefile.in
   trunk/smoke/README
   trunk/smoke/configure.in.in
   trunk/smoke/kde/
   trunk/smoke/kde/Makefile.am
   trunk/smoke/kde/Makefile.in
   trunk/smoke/kde/configure.in.in
   trunk/smoke/kde/generate.pl.in
   trunk/smoke/kde/generate_makefile_am.pl
   trunk/smoke/kde/header_list
   trunk/smoke/kde/hint_header_list.pl
   trunk/smoke/kde/kde_header_list
   trunk/smoke/kde/qt_smoke.h
   trunk/smoke/kde/qtguess.pl.in
   trunk/smoke/qt/
   trunk/smoke/qt/Makefile.am
   trunk/smoke/qt/Makefile.in
   trunk/smoke/qt/configure.in.in
   trunk/smoke/qt/generate.pl.in
   trunk/smoke/qt/generate_makefile_am.pl
   trunk/smoke/qt/header_list
   trunk/smoke/qt/hint_header_list.pl
   trunk/smoke/qt/qscintilla_header_list
   trunk/smoke/qt/qt_smoke.h
   trunk/smoke/qt/qtdbus_header_list
   trunk/smoke/qt/qtguess.pl.in
   trunk/smoke/qt/qwt_header_list
   trunk/smoke/qt/smokeqt.pro
   trunk/smoke/qwidgetitemdata_p.h
   trunk/smoke/smoke.h
Modified:
   trunk/config.m4
Log:
smoke and kalyptus are integrated into the build system

Modified: trunk/config.m4
===================================================================
--- trunk/config.m4	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/config.m4	2006-07-23 16:24:10 UTC (rev 272)
@@ -22,13 +22,13 @@
 dnl FILE: ./smoke/configure.in.in
 dnl =======================================================
 
-#AC_ARG_WITH(
-#   smoke,
-#   [  --with-smoke@&lt;:@=qt|kde@:&gt;@   Smoke: build Smoke for qt+kde or qt only @&lt;:@default:qt@:&gt;@],
-#   [ kde_build_libsmoke=&quot;$withval&quot; ],
-#   [ kde_build_libsmoke=&quot;qt&quot; ]
-#)
-#AC_SUBST(kde_build_libsmoke)
+AC_ARG_WITH(
+   smoke,
+   [  --with-smoke@&lt;:@=qt|kde@:&gt;@   Smoke: build Smoke for qt+kde or qt only @&lt;:@default:qt@:&gt;@],
+   [ kde_build_libsmoke=&quot;$withval&quot; ],
+   [ kde_build_libsmoke=&quot;qt&quot; ]
+)
+AC_SUBST(kde_build_libsmoke)
 
 dnl =======================================================
 dnl FILE: ./smoke/kde/configure.in.in
@@ -81,21 +81,21 @@
 #)
 #AC_SUBST(qt_test_threshold)
 #
-#if test &quot;X$kde_build_libsmoke&quot; = &quot;Xqt&quot; -o &quot;X$kde_build_libsmoke&quot; = &quot;Xqt kde&quot;; then
-#
-#    AC_CONFIG_FILES([ smoke/qt/qtguess.pl ], [
-#        cd smoke/qt
-#        perl qtguess.pl
-#        cd ../..
-#    ])
-#    AC_CONFIG_FILES([ smoke/qt/generate.pl ], [
-#        cd smoke/qt
-#        perl generate.pl
-#        cd ../..
-#    ])
-#fi
+if test &quot;X$kde_build_libsmoke&quot; = &quot;Xqt&quot; -o &quot;X$kde_build_libsmoke&quot; = &quot;Xqt kde&quot;; then
 
+    AC_CONFIG_FILES([ smoke/qt/qtguess.pl ], [
+        cd smoke/qt
+        perl qtguess.pl
+        cd ../..
+    ])
+    AC_CONFIG_FILES([ smoke/qt/generate.pl ], [
+        cd smoke/qt
+        perl generate.pl
+        cd ../..
+    ])
+fi
 
+
 KDE_CREATE_SUBDIRSLIST
 #AM_CONDITIONAL(smoke_SUBDIR_included, test &quot;x$smoke_SUBDIR_included&quot; = xyes)
 
@@ -107,7 +107,19 @@
 if test &quot;$PHP_PHP_QT&quot; != &quot;no&quot;; then
 
   PHP_QT_DIR=&quot;$qt_incdir&quot;;
-  LDFLAGS=&quot;$LDFLAGS $all_libraries $USER_LDFLAGS $LIBQT&quot;
+  smoke_libraries=&quot;$LIB_QTCORE \
+		   $LIB_QTGUI \
+		   $LIB_QTNETWORK \
+		   $LIB_QTOPENGL \
+		   $LIB_QTSQL \
+		   $LIB_QTCORE \
+		   $LIB_QTXML \
+		   $GLLIB \
+		   $LIBQSCINTILLA \
+		    -lQtSvg \
+		    -lQtUiTools&quot;
+
+  LDFLAGS=&quot;$LDFLAGS $all_libraries $USER_LDFLAGS $LIBQT $smoke_libraries&quot;
   PHP_REQUIRE_CXX
 
   PHP_ADD_INCLUDE($PHP_QT_DIR/include)
@@ -124,7 +136,7 @@
   PHP_ADD_INCLUDE($PHP_QT_DIR/QtTest)
   PHP_ADD_INCLUDE($PHP_QT_DIR/QtUiTools)
   PHP_ADD_INCLUDE($PHP_QT_DIR/QtXml)  
-#  PHP_ADD_INCLUDE(smoke/)
+  PHP_ADD_INCLUDE(smoke/)
 
   PHP_NEW_EXTENSION(php_qt, \
   qt/object_model/qobject.cpp \
@@ -202,12 +214,12 @@
   ,$ext_shared,cli)
   PHP_ADD_BUILD_DIR($ext_builddir/qt)
 
-#  PHP_ADD_SOURCES_X(smoke/qt, \
-#    x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
-#    x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
-#    x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp \
-#    smokedata.cpp,,shared_objects_php_qt,yes)
-#  PHP_ADD_BUILD_DIR($ext_builddir/smoke)
+  PHP_ADD_SOURCES_X(smoke/qt, \
+    x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+    x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+    x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp \
+    smokedata.cpp,,shared_objects_php_qt,yes)
+  PHP_ADD_BUILD_DIR($ext_builddir/smoke)
 
 
 fi

Added: trunk/kalyptus/Ast.pm
===================================================================
--- trunk/kalyptus/Ast.pm	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/Ast.pm	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,91 @@
+package Ast;
+use strict;
+
+use vars qw/ $this $pack @endCodes /;
+
+#-----------------------------------------------------------------------------
+# This package is used  to create a simple Abstract Syntax tree. Each node
+# in the AST is an associative array and supports two kinds of properties -
+# scalars and lists of scalars.
+# See SchemParser.pm for an example of usage.
+#                                                               ... Sriram
+#-----------------------------------------------------------------------------
+
+# Constructor 
+# e.g AST::New (&quot;personnel&quot;)
+# Stores the argument in a property called astNodeName whose sole purpose
+# is to support Print()
+
+sub New {
+	my ($this) = {&quot;astNodeName&quot; =&gt; $_[0]};
+	bless ($this);
+	return $this;
+}
+
+# Add a property to this object
+# $astNode-&gt;AddProp(&quot;className&quot;, &quot;Employee&quot;);
+
+sub AddProp {
+	my ($this) = $_[0];
+	$this-&gt;{$_[1]} = $_[2];
+}
+
+# Equivalent to AddProp, except the property name is associated
+# with a list of values
+# $classAstNode-&gt;AddProp(&quot;attrList&quot;, $attrAstNode);
+
+sub AddPropList {
+	my ($this) = $_[0];
+	if (! exists $this-&gt;{$_[1]}) {
+		$this-&gt;{$_[1]} = [];
+	}
+	push (@{$this-&gt;{$_[1]}}, $_[2]);
+}
+
+# Returns a list of all the property names of this object
+sub GetProps {
+	my ($this) = $_[0];
+	return keys %{$this};
+}
+
+sub Visit {
+    # Converts each of this AstNode's properties into global variables.
+    # The global variables are introduced into package &quot;main&quot;
+    # At the same time, a piece of code is  formed to undo this work above -
+    # $endCode essentially contains the values of these global variables
+    # before  they are mangled. endCode gets pushed into a stack (endCodes),
+    # which is unwound by UnVisit().
+
+    local ($this, $pack) = @_;
+
+
+    my $code = &quot;&quot;; 
+    my $endCode = &quot;&quot;;
+
+
+    foreach my $k (keys %{$this}) {
+
+	my $glob = $pack.&quot;::&quot;.$k;
+
+	if ( defined $$glob ) {
+
+		if ( ${$glob} ne &quot;&quot; ) {
+			$$glob =~ s/\'/\\\'/g; 
+		}
+
+	    $endCode .= '$'.$pack.'::'.$k. &quot; = '&quot;.$$glob.&quot;';&quot;;
+	} else {
+	    $endCode .= '$'.$pack . &quot;::&quot;. $k . ' = &quot;&quot;;';
+	}
+	$code .= '$'.$pack . &quot;::&quot; . $k . &quot;= \$this-&gt;{\&quot;$k\&quot;};&quot;;
+    }
+    push (@endCodes, $endCode);
+    eval($code) if $code;
+}
+
+sub UnVisit {
+    my $code = pop(@endCodes);
+    eval($code) if ($code);
+}
+
+1;

Added: trunk/kalyptus/ChangeLog
===================================================================
--- trunk/kalyptus/ChangeLog	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/ChangeLog	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,389 @@
+2006-04-18  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">rdale at foton.es</A>&gt;
+
+	* The Smoke library generated code now builds on Windows
+
+2005-10-05  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* The QByteArray class is included in the Smoke lib
+	* Fixed bug where the definition of a Null struct on one line
+	  in QString confused the parser
+
+2005-02-17  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Added a '--qt4' option to parse Qt 4 headers
+
+2005-02-06  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* The KWin class was bracketed with '#ifdef Q_OS_UNIX.. #endif', and was being skipped
+	  by kalyptus. Fixes a problem reported by Ian Monroe.
+
+	CCMAIL: <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">ian.monroe at gmail.com</A>
+
+2004-10-02  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+ * Fixed problem where a call to super in java QWidet.polish() caused a loop
+ * DCOPArg and DCOPReply are ignored for java bindings generation
+
+2004-09-10  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+ * Fixed Smoke library generation for KDE 3.1
+
+2004-09-05  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+ * Removed forward declarations for classes embedded in method return types.
+   For instance:
+         virtual class View *createView ( QWidget *parent, const char *name = 0 ) = 0;
+         virtual QPtrList&lt;class View&gt; views () const = 0;
+ * Added kate as a KDE include header subdirectory
+
+
+2004-09-05  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+ * Added kontact to the expected KDE header subdirectory names
+ * Fixed a bug in the code generation for this method:
+
+     virtual QValueList&lt;Kontact::Plugin*&gt; pluginList() const = 0;
+
+   It was being incorrectly treated as a pointer type, because it contained as asterisk.
+
+2004-08-19  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+ * A namespace such as KIO:: can be spread over several header files, the source
+   names are now kept in a property list so that all the includes can be generated.
+
+2004-07-26  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+ * QMap and QPair template types such as 'QMap&lt;QCString, DCOPRef&gt;' with an 
+   embedded comma, were not being correctly normalised. A space was left in 
+   the smoke type.
+
+2004-07-25  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+ * When the Smoke code for accessing an enum was generated, it was assuming
+   that the enum was in the same source file as the class. This doesn't work
+   for namespaces like KIO:: where enums can be spread over several source
+   files.
+ * The solution is to add a source file property to each enum, and when the
+   accessor code for the enum is generated a suitable include can be added.
+ * Fixes problem reported by Luca Perossa
+
+	CCMAIL: <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">kde-bindings at kde.org</A>
+
+2004-07-07  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* After discussion with Germain Garand, QChars have been returned to 
+	  the Smoke runtime as first class members.
+
+2004-07-07  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* The QChar class is now treated as a primitive type just like QString.
+
+2004-06-30  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Added DCOPRef to the Smoke runtime. But the various template methods for send(), call() and callExt() 
+	  need to be reimplemented in the scripting language.
+
+2004-06-29  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Java methods now generated for qCompress and qUncompress methods - Michal Ceresna
+	  reported that the methods missing from the QtJava api.
+	  
+2004-06-25  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Reinstated the KMultiTabBarTab and KMultiTabBarButton classes in the Smoke runtime
+	* It makes more sense to fix the parser to handle arg types starting with
+	'class '. They are now stripped off and ignored.
+
+2004-06-24  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Removed KMultiTabBarTab and KMultiTabBarButton from the Smoke runtime
+	* Added an instance variable '_smokeObject' to generated C# Kimono classes
+
+2004-06-09  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* New flags were added for Smoke methods - mf_internal and mf_copyctor.
+	  This allows copy constructors which are only used internally by the ruby
+	  or perl runtime, to be excluded from the standard api.
+
+2004-06-07  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Added patch from Michal Ceresna to fix code generation for QImage.bits() and
+	  QImage.colorTable()
+	* Fixed bug reported by Maik Schulz caused by unwanted KListViewItem copy constructor.
+	  An 'enhancement' was added for KDE 3.2 - for any class which didn't have a copy 
+	  constructor, but which could still be copied, a copy constructor was generated.
+	  Unfortunately this had unforseen consequences, such as messing up KListView logic,
+	  hence they're no longer generated.
+
+2004-05-27  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* The methods QPainter::pos() and QFontInfo::font() are skipped for
+	  Qt2 embedded as they don't link to the ARM version of Qt/E
+	* Thanks to Fabien Renaud for testing QtJava/E on an ARM box
+
+2004-05-25  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Added the correct macro expansion for Q_OBJECT with Qt/E 2.3.x
+	* kalyptus can now generate the SMOKE library for Qt Embedded
+
+2004-05-22  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* More tweaks to the QtJava Embedded code generation.
+	  The code now compiles without error, links and runs..
+	* However, the Qt framebuffer emulator plasters the KDE desktop in
+	  lurid green and doesn't seem to have a way of accepting mouse
+	  input. How do you get mouse events into a named pipe that it reads?
+
+2004-05-21  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Added code generation for Qt/Embedded 2.3.4 with a '--qte' option to 
+	  be used in conjunction with the '-fjni' option.
+	* Example usage - this command will parse the Qt embedded headers in 
+	  directory 'test', and generate the .java and .cpp files in the same dir:
+	    $ kalyptus -fjni -dtest --globspace --qte test/*.h
+
+2004-05-20  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* The java '-fjni' option now generates correct java code with Qt/E 2.3.4
+	* KMainWindow.toolBar() and KMainWindow.menuBar() rename ktoolBar() and
+	  kmenuBar(). This is because java doesn't have covariant return types
+	  and the methods with the same names in QMainWindow return a QToolBar
+	  and QMenuBar, rather than their KDE equivalent subclasses.
+
+2004-05-19  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Namespaces were being omitted from the SMOKE runtime, and so methods
+	  such as the ones in KStdAction were missing. They are now included and
+	  appear to be ordinary classes containing static methods.
+	    For example, in ruby:
+		quit = KDE::StdAction.quit( self, SLOT(&quot;quit()&quot;), actionCollection() )
+
+2004-04-26  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Now only 55 Qt C# warnings, too much use of the 'new' inheritance directive
+	  though.
+
+2004-04-26  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Reduced the number of compiler warnings for C# Dispose() methods. Now down to
+	  'only' 130 warnings for the Qt classes
+
+2004-04-13  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* When a class includes equality operator overloading, an implementation of 
+	  GetHashCode() is generated (along with Equals() too) to avoid compiler warnings.
+	* If a method was originally inherited via C++ MI, but is now copied from the superclass
+	  to the current class in C# instead, then it isn't labelled with a 'new' modifier
+
+2004-04-12  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Kimono C# code generation improvements
+	    - Added the 'out' modifier for args which are references to mutable primitive types
+	    - Improved doc comment to C# xml comment translation, with &lt;remarks&gt; tags bracketing 
+	      the body of the comment
+	    - Enum types are only given a 'E_' prefix if they clash with a C# method name after
+	      the first character has been uppercased
+
+2004-03-26  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Removed quite a few compiler warnings from the C# code generated by -fkimono
+	  - A lot of warnings about virtual methods not needing the 'new' keyword fixed
+	  - If you define operator==, but not operator!= you get a warning. 
+	    A smarter compiler might be able to work one out from the other?
+	    But added a corresponding 'operator!=' always.
+	  - If you define operator== or operator!=, you get a warning for not defining 
+	    GetHashCode(). There must be some sort of logic in that, but not fixed yet.
+	 
+2004-03-25  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Removed obsolete C and Objective-C code generation options
+
+2004-03-19  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* 'KDE Integrates Mono'; added -fkimono option to generate C# bindings
+	* It doens't use the Qt C bindings, like Qt# but the Smoke lib instead
+	* To generate the code and review the api, edit kdebindings/smoke/kde/generate.pl.in
+	  and change '-fsmoke' to '-fkimono'. Then configure kdebindings with the
+	  '--with-smoke=kde' option. The sources will be generated in smoke/kde.
+	* It uses custom real proxies as AOP style interceptors, one per instance
+	  and a static interceptor per class.
+	  - Every method call in the api is forwarded to SmokeInvocation.Invoke()
+	    via the proxies, and is effectively a pointcut.
+	  - In Invoke() the method call will be looked up dynamically from the Smoke runtime
+	  - The arguments are marsalled from C# to C++ on the Smoke::Stack, and the method
+	    invoked.
+	* The KDE doc comments are converted to C# xml style tags (eg KApplication.cs)
+	* Problems
+	  - A small fix was need for RealProxies with Mono 0.30. DotGnu doesn't have
+	    RealProxies/remoting yet.
+	  - It should be possible to use ContextBoundObjects and custom ContextAttributes
+	    as described here, but they aren't implemented in Mono yet.
+		<A HREF="http://msdn.microsoft.com/msdnmag/issues/03/03/ContextsinNET/">http://msdn.microsoft.com/msdnmag/issues/03/03/ContextsinNET/</A>
+	  - In interfaces the 'ref' keyword can't be used
+	  - Doesn't use event handlers as delegates like Qt#, they are just overriden
+	    like normal virtual methods
+	  - Many compiler warnings about 'new virtual' not being needed. Some work needed
+	    to only add new to overriden ones.
+
+2004-02-17  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Aligned the forthcoming KDE 3.3 dynamic proxy/SMOKE library based java 
+	  code generation with the current 3.2 JNI based ones (-fjava vs. -fjni).
+
+2004-01-28  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* When two methods differed only in 'constness', it wasn't possible to
+	  resolve which to call from ruby. For example:
+		KProgress* progressBar();
+		const KProgress* progressBar() const;
+	  So only the const variant is generated in the Smoke runtime.
+
+2004-01-05  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* When a java method needed to be renamed, because in the type signature 
+	  only the return type differed in C++, when that isn't allowed in java,
+	  the JNI function name was not using the new name.
+	* Fixed error in JNI function names when the C++ method had an underscore.
+
+
+2003-12-29  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Fixed a problem with parsing one line namespace declarations
+	* Added support for the QT_WORKSPACE_WINDOWMODE macro, to solve build problem
+	* Added some more primitive type definitions such as KIO::filesize_t
+
+2003-12-23  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Added a '-fjni' option to generate code for the current KDE 3.2 JNI based java
+	  bindings The '-fjava' option generates code for the forthcoming Dynamic
+	  Proxy/Smoke library based java bindings in KDE 3.3.
+	* The Qt and KDE bindings just checked in were generated by changing the kalyptus 
+	  option '-fsmoke' to '-fjni' in kdebindings/smoke/kde/generate.pl.in. Then
+	  configure kdebindings with '--enable-smoke=kde' option to generate the .cpp
+	  and .java sources. The .h files are generated by using javah on the compiled
+	  java .class files.
+
+2003-11-29  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Fixed parsing of casts inside enums in kfileitem.h:
+	      enum { Unknown = (mode_t) - 1 };
+	  Hmm, not sure what that's up to anyway..
+	* Added a special Source property to method nodes in QGlobalSpace.
+	  In java, this allows Qt friend methods to be grouped under the
+	  Qt.java class, and KDE ones under KDE.java according to which 
+	  source file they originated from.
+
+2003-11-05  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Fixed parsing default argument values cast to a numeric literal, eg:
+	    mode_t mode = (mode_t)-1
+	* Excluded a couple of structs from kparts/browserextension
+
+2003-11-04  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* KDE MI has some diamond shaped cycles, such as for the children of
+	  KXMLGUIClient. When the code for casts to all the parents of a class
+	  was generated in the Smoke runtime, this meant there were some 
+	  duplicate entries in the switch statement. Duplicates now removed.
+
+
+2003-10-11  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Avoid generating wrappers for private classes with 'Private',
+	  'Impl' or 'Internal' in the name. Other unneeded classes also
+	  dropped. 
+
+2003-10-08  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Added SmokeKDE namespace class code generation
+	  - Fixed bug in kalyptus where it couldn't detect the end of a namespace
+	  - resolveType() in kalyptusDataDict.pm now looks in parent namespace for symbols
+	  - Namespace enclosed class code generation added to kalyptusCxxToSmoke.pm 
+
+2003-09-16  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Added various parser and code generation fixes so that a libsmokekde.so
+	  can be generated from the kdelibs headers.
+
+2003-08-30  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Applied Germain Garand's patch to no longer rename operator methods 
+	  in the QGlobalSpace pseudo class
+
+2003-08-21  Alexander Kellett  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">lypanov at kde.org</A>&gt;
+
+	* Added .kidl generation option (dcopidl replacement)
+	* Handled of several new constructs in the parsing:
+	*    k_dcop: / k_dcop_signals: / K_DCOP:
+	* Use STDERR not STDOUT thus removing need for temporary file
+
+2003-08-21  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Added missing getClassLoader() call to Proxy constructor
+
+2003-08-21  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Rewritten java code generation for a Dynamic Proxy based SMOKE adaptor version of QtJava.
+	* Based on David Faure's SMOKE generation code in the '-fsmoke' option.
+
+2003-08-11  Richard Dale  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>&gt;
+
+	* Removed old SWIG style ruby generation option
+
+2003-08-09  Alexander Kellett  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">lypanov at kde.org</A>&gt;
+
+	* Parse static friend operator methods and place into a pseudo class (for smoke)
+
+2002-06-03  David Faure  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">faure at kde.org</A>&gt;
+
+	* The Smoke generation is in good shape. Removed old PerlPig and PerlQK
+	modules.
+
+2002-04-23  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>&gt;
+
+	* Added patch from David Faure to correctly handle nested struct
+         or class names in perl .pig generation
+
+2002-03-15  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>&gt;
+	* Added C# P/Invoke bindings generation option from Adam Treat
+2002-02-10  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>&gt;
+	* Improved C destructor code generation
+	* QCanvasItemList mapped onto java.util.ArrayList
+	* 'bool *' type converted to java 'boolean[]' type.
+2002-02-03  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>&gt;
+ 	
+	* More fixes to .pig generation from Germain. Perl porting now 
+         motoring 24*7...
+2002-02-02  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>&gt;
+	* Various improvements to Perl .pig generation from Germain Garand
+2002-01-31  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>&gt;
+	* Fixed bug in code generation for NULL default arguments
+	* Added some new KDE 3 types
+2002-01-26  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>&gt;
+	* Perl .pig generation improved
+2002-01-25  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>&gt;
+	* Added '-fperl' option to autogenerate .pig (Perl Interface 
+         Generator) files, suitable for generating Ashley Winters' PerlQt/KDEQt 
+         bindings
+2002-01-23  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>&gt;
+	* Made dispose() public, added isDisposed() after SWT.
+2002-01-23  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>&gt;
+	* Added generation of dispose() methods, to allow large resources,
+         such as pixmaps, to be freed before finalize() is called.
+2002-01-20  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>&gt;
+	* Ruby bindings generation - initial checkin.
+2002-01-04  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>&gt;
+	* Fixed bug in parsing decimal point in default argument values
+2001-12-29  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>
+	* JNI event handling methods are now generated.
+	* Some additions for KDevelop types. 
+	* Removed assumption that a class ending in '..Interface' should always 
+         be a java interface.
+2001-12-17  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>
+	* Improved code generation for String f'ns with default arguments.
+	* An implementation is no longer generated for classes which are
+         just interfaces.
+2001-12-03  Richard Dale &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">duke at tipitina.demon.co.uk</A>
+	* Added new KDE 3 data types
+	* Improved code generation for classes defined within namespaces
+

Added: trunk/kalyptus/Iter.pm
===================================================================
--- trunk/kalyptus/Iter.pm	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/Iter.pm	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,532 @@
+package Iter;
+
+=head1 Iterator Module
+
+A set of iterator functions for traversing the various trees and indexes.
+Each iterator expects closures that operate on the elements in the iterated
+data structure.
+
+
+=head2 Generic
+
+	Params: $node, &amp;$loopsub, &amp;$skipsub, &amp;$applysub, &amp;$recursesub
+
+Iterate over $node\'s children. For each iteration:
+	
+If loopsub( $node, $kid ) returns false, the loop is terminated.
+If skipsub( $node, $kid )  returns true, the element is skipped.
+
+Applysub( $node, $kid ) is called
+If recursesub( $node, $kid ) returns true, the function recurses into
+the current node.
+
+=cut
+
+sub Generic
+{
+	my ( $root, $loopcond, $skipcond, $applysub, $recursecond ) = @_;
+
+	return sub {
+		foreach my $node ( @{$root-&gt;{Kids}} ) {
+
+			if ( defined  $loopcond ) {
+				return 0 unless $loopcond-&gt;( $root, $node );
+			}
+
+			if ( defined $skipcond ) {
+				next if $skipcond-&gt;( $root, $node );
+			}
+
+			my $ret = $applysub-&gt;( $root, $node );
+			return $ret if defined $ret &amp;&amp; $ret;
+
+			if ( defined $recursecond 
+					&amp;&amp; $recursecond-&gt;( $root, $node ) ) {
+				$ret = Generic( $node, $loopcond, $skipcond,
+						$applysub, $recursecond)-&gt;();
+				if ( $ret ) {
+					return $ret;
+				}
+			}
+		}
+
+		return 0;
+	};
+}
+
+sub Class
+{
+	my ( $root, $applysub, $recurse ) = @_;
+
+	return Generic( $root, undef,
+		sub {
+			return !( $node-&gt;{NodeType} eq &quot;class&quot; 
+				|| $node-&gt;{NodeType} eq &quot;struct&quot; );
+		}, 
+		$applysub, $recurse );
+}
+
+=head2 Tree
+
+	Params: $root, $recurse?, $commonsub, $compoundsub, $membersub,
+		$skipsub
+
+Traverse the ast tree starting at $root, skipping if skipsub returns true.
+
+Applying $commonsub( $node, $kid),
+then $compoundsub( $node, $kid ) or $membersub( $node, $kid ) depending on
+the Compound flag of the node.
+
+=cut
+
+sub Tree
+{
+	my ( $rootnode, $recurse, $commonsub, $compoundsub, $membersub, 
+		 $skipsub ) = @_;
+
+	my $recsub = $recurse ? sub { return 1 if $_[1]-&gt;{Compound}; } 
+				: undef;
+
+	Generic( $rootnode, undef, $skipsub,
+		sub { 					# apply
+			my ( $root, $node ) = @_;
+			my $ret;
+
+			if ( defined $commonsub ) {
+				$ret = $commonsub-&gt;( $root, $node );
+				return $ret if defined $ret;
+			}
+
+			if ( $node-&gt;{Compound} &amp;&amp; defined $compoundsub ) {
+				$ret = $compoundsub-&gt;( $root, $node );
+				return $ret if defined $ret;
+			}
+			
+			if( !$node-&gt;{Compound} &amp;&amp; defined $membersub ) {
+				$ret = $membersub-&gt;( $root, $node );
+				return $ret if defined $ret;
+			}
+			return;
+		},
+		$recsub 				# skip
+	)-&gt;();
+}
+
+=head2 LocalCompounds
+
+Apply $compoundsub( $node ) to all locally defined compound nodes
+(ie nodes that are not external to the library being processed).
+
+=cut
+
+sub LocalCompounds
+{
+		my ( $rootnode, $compoundsub ) = @_;
+
+		return unless defined $rootnode &amp;&amp; defined $rootnode-&gt;{Kids};
+
+		foreach my $kid ( sort { $a-&gt;{astNodeName} cmp $b-&gt;{astNodeName} }
+								 @{$rootnode-&gt;{Kids}} ) {
+				next if !defined $kid-&gt;{Compound};
+
+				$compoundsub-&gt;( $kid ) unless defined $kid-&gt;{ExtSource};
+				LocalCompounds( $kid, $compoundsub );
+		}
+}
+
+=head2 Hierarchy
+
+	Params: $node, $levelDownSub, $printSub, $levelUpSub
+
+This allows easy hierarchy traversal and printing.
+
+Traverses the inheritance hierarchy starting at $node, calling printsub
+for each node. When recursing downward into the tree, $levelDownSub($node) is
+called, the recursion takes place, and $levelUpSub is called when the
+recursion call is completed. 
+
+=cut
+
+sub Hierarchy
+{
+	my ( $node, $ldownsub, $printsub, $lupsub, $nokidssub ) = @_;
+
+	return if defined $node-&gt;{ExtSource}
+		&amp;&amp; (!defined $node-&gt;{InBy} 
+			|| !kdocAstUtil::hasLocalInheritor( $node ));
+
+	$printsub-&gt;( $node );
+
+	if ( defined $node-&gt;{InBy} ) {
+		$ldownsub-&gt;( $node );
+
+		foreach my $kid ( 
+				sort {$a-&gt;{astNodeName} cmp $b-&gt;{astNodeName}}
+				@{ $node-&gt;{InBy} } ) {
+			Hierarchy( $kid, $ldownsub, $printsub, $lupsub );
+		}
+
+		$lupsub-&gt;( $node );
+	}
+	elsif ( defined $nokidssub ) {
+		$nokidssub-&gt;( $node );
+	}
+
+	return;
+}
+
+=head2
+
+	Call $printsub for each *direct* ancestor of $node.
+	Only multiple inheritance can lead to $printsub being called more than once.
+
+=cut
+sub Ancestors
+{
+	my ( $node, $rootnode, $noancessub, $startsub, $printsub,
+		$endsub ) = @_;
+	my @anlist = ();
+
+	return if $node eq $rootnode;
+
+	if ( !exists $node-&gt;{InList} ) {
+		$noancessub-&gt;( $node ) unless !defined $noancessub;
+		return;
+	}
+	
+	foreach my $innode ( @{ $node-&gt;{InList} } ) {
+		my $nref = $innode-&gt;{Node};	# real ancestor
+		next if defined $nref &amp;&amp; $nref == $rootnode;
+
+		push @anlist, $innode;
+	}
+
+	if ( $#anlist &lt; 0 ) {
+		$noancessub-&gt;( $node ) unless !defined $noancessub;
+		return;
+	}
+
+	$startsub-&gt;( $node ) unless !defined $startsub;
+
+	foreach my $innode ( sort { $a-&gt;{astNodeName} cmp $b-&gt;{astNodeName} }
+				@anlist ) {
+
+		# print
+		$printsub-&gt;( $innode-&gt;{Node}, $innode-&gt;{astNodeName},
+			$innode-&gt;{Type}, $innode-&gt;{TmplType} ) 
+			unless !defined $printsub;
+	}
+
+	$endsub-&gt;( $node ) unless !defined $endsub;
+
+	return;
+
+}
+
+sub Descendants
+{
+	my ( $node, $nodescsub, $startsub, $printsub, $endsub ) = @_;
+
+	if ( !exists $node-&gt;{InBy} ) {
+		$nodescsub-&gt;( $node ) unless !defined $nodescsub;
+		return;
+	}
+
+	
+	my @desclist = ();
+	DescendantList( \@desclist, $node );
+	
+	if ( $#desclist &lt; 0 ) {
+		$nodescsub-&gt;( $node ) unless !defined $nodescsub;
+		return;
+	}
+
+	$startsub-&gt;( $node ) unless !defined $startsub;
+
+	foreach my $innode ( sort { $a-&gt;{astNodeName} cmp $b-&gt;{astNodeName} }
+				@desclist ) {
+
+		$printsub-&gt;( $innode) 
+			unless !defined $printsub;
+	}
+
+	$endsub-&gt;( $node ) unless !defined $endsub;
+
+	return;
+
+}
+
+sub DescendantList
+{
+	my ( $list, $node ) = @_;
+
+	return unless exists $node-&gt;{InBy};
+
+	foreach my $kid ( @{ $node-&gt;{InBy} } ) {
+		push @$list, $kid;
+		DescendantList( $list, $kid );
+	}
+}
+
+=head2 DocTree
+
+=cut
+
+sub DocTree
+{
+	my ( $rootnode, $allowforward, $recurse, 
+		$commonsub, $compoundsub, $membersub ) = @_;
+		
+	Generic( $rootnode, undef,
+		sub {				# skip
+			my( $node, $kid ) = @_;
+
+			unless (!(defined $kid-&gt;{ExtSource}) 
+					&amp;&amp; ($allowforward || $kid-&gt;{NodeType} ne &quot;Forward&quot;)
+					&amp;&amp; ($main::doPrivate || !($kid-&gt;{Access} =~ /private/))
+					&amp;&amp; exists $kid-&gt;{DocNode} ) {
+
+				return 1;
+			}
+
+			return;
+		},
+		sub { 				# apply
+			my ( $root, $node ) = @_;
+
+			my $ret;
+
+			if ( defined $commonsub ) {
+				$ret = $commonsub-&gt;( $root, $node );
+				return $ret if defined $ret;
+			}
+
+			if ( $node-&gt;{Compound} &amp;&amp; defined $compoundsub ) {
+				$ret = $compoundsub-&gt;( $root, $node );
+				return $ret if defined $ret;
+			}
+			elsif( defined $membersub ) {
+				$ret = $membersub-&gt;( $root, $node );
+				return $ret if defined $ret;
+			}
+
+			return;
+		},
+		sub { return 1 if $recurse; return; }	# recurse
+		)-&gt;();
+
+}
+
+sub MembersByType
+{
+	my ( $node, $startgrpsub, $methodsub, $endgrpsub, $nokidssub ) = @_;
+
+# public
+	# types
+	# data
+	# methods
+	# signals
+	# slots
+	# static
+# protected
+# private (if enabled)
+
+	if ( !defined $node-&gt;{Kids} ) {
+			$nokidssub-&gt;( $node ) if defined $nokidssub;
+			return;
+	}
+
+	foreach my $acc ( qw/public protected private/ ) {
+		next if $acc eq &quot;private&quot; &amp;&amp; !$main::doPrivate;
+		$access = $acc;
+
+		my @types = ();
+		my @data = ();
+		my @signals = ();
+		my @k_dcops = ();
+		my @k_dcop_signals = ();
+		my @k_dcop_hiddens = ();
+		my @slots =();
+		my @methods = ();
+		my @static = ();
+		my @modules = ();
+		my @interfaces = ();
+
+		# Build lists
+		foreach my $kid ( @{$node-&gt;{Kids}} ) {
+			next unless ( $kid-&gt;{Access} =~ /$access/
+			          &amp;&amp; !$kid-&gt;{ExtSource})
+			         || ( $access eq &quot;public&quot; 
+				    &amp;&amp; ( $kid-&gt;{Access} eq &quot;signals&quot; 
+				      || $kid-&gt;{Access} =~ &quot;k_dcop&quot; # note the =~ 
+                  || $kid-&gt;{Access} eq &quot;K_DCOP&quot;));
+
+			my $type = $kid-&gt;{NodeType};
+
+			if ( $type eq &quot;method&quot; ) {
+				if ( $kid-&gt;{Flags} =~ &quot;s&quot; ) {
+					push @static, $kid;
+				}
+				elsif ( $kid-&gt;{Flags} =~ &quot;l&quot; ) {
+					push @slots, $kid;
+				}
+				elsif ( $kid-&gt;{Flags} =~ &quot;n&quot; ) {
+					push @signals, $kid;
+				}
+				elsif ( $kid-&gt;{Flags} =~ &quot;d&quot; ) {
+					push @k_dcops, $kid;
+				}
+				elsif ( $kid-&gt;{Flags} =~ &quot;z&quot; ) {
+					push @k_dcop_signals, $kid;
+				}
+				elsif ( $kid-&gt;{Flags} =~ &quot;y&quot; ) {
+					push @k_dcop_hiddens, $kid;
+				}
+				else {
+					push @methods, $kid; }
+			}
+			elsif ( $kid-&gt;{Compound} ) {
+				if ( $type eq &quot;module&quot; ) {
+					push @modules, $kid;
+				}
+				elsif ( $type eq &quot;interface&quot; ) {
+					push @interfaces, $kid;
+				}
+				else {
+					push @types, $kid;
+				}
+			}
+			elsif ( $type eq &quot;typedef&quot; || $type eq &quot;enum&quot; ) {
+				push @types, $kid;
+			}
+			else {
+				push @data, $kid;
+			}
+		}
+
+		# apply
+		$uc_access = ucfirst( $access );
+		
+		doGroup( &quot;$uc_access Types&quot;, $node, \@types, $startgrpsub,
+			$methodsub, $endgrpsub);
+		doGroup( &quot;Modules&quot;, $node, \@modules, $startgrpsub,
+			$methodsub, $endgrpsub);
+		doGroup( &quot;Interfaces&quot;, $node, \@interfaces, $startgrpsub,
+			$methodsub, $endgrpsub);
+		doGroup( &quot;$uc_access Methods&quot;, $node, \@methods, $startgrpsub,
+			$methodsub, $endgrpsub);
+		doGroup( &quot;$uc_access Slots&quot;, $node, \@slots, $startgrpsub,
+			$methodsub, $endgrpsub);
+		doGroup( &quot;Signals&quot;, $node, \@signals, $startgrpsub,
+			$methodsub, $endgrpsub);
+		doGroup( &quot;k_dcop&quot;, $node, \@k_dcops, $startgrpsub,
+			$methodsub, $endgrpsub);
+		doGroup( &quot;k_dcop_signals&quot;, $node, \@k_dcop_signals, $startgrpsub,
+			$methodsub, $endgrpsub);
+		doGroup( &quot;k_dcop_hiddens&quot;, $node, \@k_dcop_hiddens, $startgrpsub,
+			$methodsub, $endgrpsub);
+		doGroup( &quot;$uc_access Static Methods&quot;, $node, \@static, 
+			$startgrpsub, $methodsub, $endgrpsub);
+		doGroup( &quot;$uc_access Members&quot;, $node, \@data, $startgrpsub,
+			$methodsub, $endgrpsub);
+	}
+}
+
+sub doGroup
+{
+	my ( $name, $node, $list, $startgrpsub, $methodsub, $endgrpsub ) = @_;
+
+        my ( $hasMembers ) = 0;
+        foreach my $kid ( @$list ) {
+                if ( !exists $kid-&gt;{DocNode}-&gt;{Reimplemented} ) {
+                        $hasMembers = 1;
+                        break;
+                }
+        }
+	return if !$hasMembers;
+	
+	if ( defined $methodsub ) {
+		foreach my $kid ( @$list ) {
+                        if ( !exists $kid-&gt;{DocNode}-&gt;{Reimplemented} ) {
+         		        $methodsub-&gt;( $node, $kid );
+                        }
+		}
+	}
+
+	$endgrpsub-&gt;( $name ) if defined $endgrpsub;
+}
+
+sub ByGroupLogical
+{
+	my ( $root, $startgrpsub, $itemsub, $endgrpsub ) = @_;
+
+	return 0 unless defined $root-&gt;{Groups};
+
+	foreach my $groupname ( sort keys %{$root-&gt;{Groups}} ) {
+		next if $groupname eq &quot;astNodeName&quot;||$groupname eq &quot;NodeType&quot;;
+
+		my $group = $root-&gt;{Groups}-&gt;{ $group };
+		next unless $group-&gt;{Kids};
+		
+		$startgrpsub-&gt;( $group-&gt;{astNodeName}, $group-&gt;{Desc} );
+
+		foreach my $kid (sort {$a-&gt;{astNodeName} cmp $b-&gt;{astNodeName}}
+					@group-&gt;{Kids} ) {
+			$itemsub-&gt;( $root, $kid );
+		}
+		$endgrpsub-&gt;( $group-&gt;{Desc} );	
+	}
+
+	return 1;
+}
+
+sub SeeAlso
+{
+	my ( $node, $nonesub, $startsub, $printsub, $endsub ) = @_;
+
+	if( !defined $node ) {
+		$nonesub-&gt;();
+		return;
+	}
+
+	my $doc = $node;
+
+	if ( $node-&gt;{NodeType} ne &quot;DocNode&quot; ) {
+		$doc = $node-&gt;{DocNode};
+		if ( !defined $doc ) {
+			$nonesub-&gt;() if defined $nonesub;
+			return;
+		}
+	}
+
+	if ( !defined $doc-&gt;{See} ) {
+		$nonesub-&gt;() if defined $nonesub;
+		return;
+	}
+
+	my $see = $doc-&gt;{See};
+	my $ref = $doc-&gt;{SeeRef};
+
+	if ( $#$see &lt; 1 ) {
+		$nonesub-&gt;() if defined $nonesub;
+		return;
+	}
+
+	$startsub-&gt;( $node ) if defined $startsub;
+
+	for my $i ( 0..$#$see ) {
+		my $seelabel = $see-&gt;[ $i ];
+		my $seenode = undef;
+		if ( defined $ref ) {
+			$seenode = $ref-&gt;[ $i ]; 
+		}
+
+		$printsub-&gt;( $seelabel, $seenode ) if defined $printsub;
+	}
+
+	$endsub-&gt;( $node ) if defined $endsub;
+
+	return;
+}
+
+1;

Added: trunk/kalyptus/Makefile.cvs
===================================================================
--- trunk/kalyptus/Makefile.cvs	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/Makefile.cvs	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,5 @@
+
+all: configure
+
+configure: configure.in
+	autoconf

Added: trunk/kalyptus/Makefile.in
===================================================================
--- trunk/kalyptus/Makefile.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/Makefile.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,53 @@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+perl = @perl@
+install = @INSTALL@
+bin = kalyptus
+pm = kdocUtil.pm kdocAstUtil.pm kdocParseDoc.pm kdocLib.pm \
+	Ast.pm kalyptusDataDict.pm kalyptusCxxToC.pm \
+	kalyptusCxxToObjc.pm kalyptusCxxToJava.pm \
+	kalyptusCxxToSmoke.pm kalyptusCxxToCSharp.pm \
+	Iter.pm
+pmextra =
+bindir = ${exec_prefix}/bin
+pmdir = ${prefix}/share/kalyptus
+srcdocdir= .
+VERSION=@Version@
+
+all: kalyptus.local
+
+kalyptus.local: @srcdir@/kalyptus
+	cp @srcdir@/kalyptus kalyptus.local
+	perl -npi -e 's%^#\!.*$$%#!'${perl}' -I'${pmdir}'%g;' kalyptus.local
+	perl -npi -e 's#\$$Version\\\$$#'&quot;${VERSION}&quot;'#g;' kalyptus.local
+
+install: all
+	${install} -d $(DESTDIR)${bindir}
+	${install} -m 755 kalyptus.local $(DESTDIR)${bindir}/kalyptus
+	${install} -d $(DESTDIR)${pmdir}
+	for file in ${pm} ${pmextra}; do \
+		${install} -m 644 @srcdir@/$$file $(DESTDIR)${pmdir}; \
+	done
+
+uninstall:
+	(cd $(DESTDIR)${bindir} &amp;&amp; rm -f ${bin})
+	(cd $(DESTDIR)${pmdir} &amp;&amp; rm -f ${pm})
+	-rmdir $(DESTDIR)${bindir}
+	-rmdir $(DESTDIR)${pmdir}
+
+clean:
+	rm -f kalyptus.local
+
+distclean: clean
+	rm -f Makefile config.status config.log config.cache perlbin
+
+srcdoc:
+	pod2html --flush --title KALYPTUS $(bin) $(pm) \
+		 --outfile $(srcdocdir)/kalyptus-doc.html
+tags:
+	perltags kalyptus *.pm
+
+check:
+	@for dir in $(bin) $(pm); do \
+		echo &quot;** Checking: $$dir&quot;; \
+		perl -wc $$dir; done

Added: trunk/kalyptus/README
===================================================================
--- trunk/kalyptus/README	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/README	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,92 @@
+
+KALYPTUS -- C, Objective-C and Java bindings generator
+
+Version 0.9
+
+KALYPTUS creates language bindings for Qt and KDE C++ libraries
+directly from the headers. Documentation embedded in special doc
+comments in the source is translated to an appropriate format for
+the target language.
+
+REQUIREMENTS
+
+You need perl 5.005 or greater to run kalyptus.
+
+HOWTO
+
+If you are running this straight from CVS, you will need to run 
+
+	make -f Makefile.cvs
+
+before building.
+
+This should install kalyptus:
+
+./configure; make; make install
+
+CREDITS
+-------
+
+Richard Dale - kdoc adaption, C/Objective-C/Java code generation.
+
+Sirtaj Singh Kang for writing the original kdoc utility (kalyptus was
+derived from kdoc).
+
+Copyright(C) 2001, Lost Highway Ltd
+
+------
+
+Copyright(C) 1999, Sirtaj Singh Kang &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">taj at kde.org</A>&gt;
+Distributed under the GPL.
+
+NOTES ON USING THE CONVERTER
+----------------------------
+
+JAVA
+----
+
+Here are some of the shell commands that were used in the conversion process:
+
+Remove any Q_OVERRIDE macros from the Qt headers, and remove EXPORT_DOCKCLASS from the
+KDE headers
+
+# Generate Java and C++ sources. Copy all the target headers to directory 'test/tmp'
+kalyptus -fjava test/tmp/*.h test/tmp/dom/*.h test/tmp/kio/*.h test/tmp/kdeprint/*.h \
+   test/tmp/kjs/*.h test/tmp/kparts/*.h test/tmp/kdesu/*.h test/ktextedit/*.h test/tmp/libkmid/*.h
+
+# Shorten generated filenames
+mv DOM__Node.cpp DOMNode.cpp
+mv DOM__Node.java DOMNode.java
+mv DOM__Document.cpp DOMDocument.cpp
+mv DOM__Document.java DOMDocument.java
+for FILE in *__* ; do
+ NAME=`echo $FILE | sed -e 's/^.*__//'`;
+ echo $NAME;
+ mv $FILE $NAME;
+done
+mv SlaveInterface.cpp Slave.cpp
+mv SlaveInterface.java Slave.java
+
+# Edit and Compile the generated java
+cd kdejava/koala/org/kde/koala
+make
+
+# Build C++ JNI .h header files
+cd qtjava/javalib/org/kde/qt
+for FILE in *.class ; do NAME=`echo $FILE | sed 's/.class//'`; echo $NAME; javah  -classpath '../../..' org.kde.qt.$NAME ; done
+for FILE in org_kde* ; do NAME=`echo $FILE | sed -e 's/org_kde_qt_//'`; echo $NAME; mv $FILE $NAME; done
+
+cd kdejava/koala/org/kde/koala
+for FILE in *.class ; do NAME=`echo $FILE | sed 's/.class//'`; echo $NAME; javah  -classpath '../../..:../../../../../qtjava/javalib/qtjava.jar' org.kde.koala.$NAME ; done
+for FILE in org_kde* ; do NAME=`echo $FILE | sed -e 's/org_kde_koala_//'`; echo $NAME; mv $FILE $NAME; done
+# Copy headers to kdejava/koala/kdejava
+
+# Check that  the JNI .h function names match the .cpp ones
+cd kdejava/koala/org/kde/koala
+grep ^Java_ *.cpp | sed -e 's/^[^:]*:\([^(]*\).*/\1/'  | grep -v '[/]' | sort | uniq &gt; cpp.fns
+grep Java_ *.h | awk '{ print $4 }' |  grep -v '[/]' | sort | uniq &gt; h.fns
+kompare h.fns cpp.fns
+# Reconcile and fix any differences
+
+# Edit and compile the generated .cpp and .h files with KDevelop
+

Added: trunk/kalyptus/TODO
===================================================================
--- trunk/kalyptus/TODO	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/TODO	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,7 @@
+Add more target languages, such as PHP and Pascal
+
+Use a perl parser generator to define the grammar for
+    C++ method arguments.
+
+Write documentation for a how to on bindings generation.
+

Added: trunk/kalyptus/Version
===================================================================
--- trunk/kalyptus/Version	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/Version	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1 @@
+0.91

Added: trunk/kalyptus/configure.in
===================================================================
--- trunk/kalyptus/configure.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/configure.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,28 @@
+AC_INIT(kalyptus)
+
+AC_DEFUN(AC_FIND_PERL,
+[
+AC_MSG_CHECKING(for perl 5 or greater)
+if $srcdir/findperl; then
+	$1=`cat perlbin`
+	echo $$1
+else
+	echo &quot;Couldn't find perl 5 or later. kdoc will not run.&quot;
+	exit 1
+fi	
+])
+
+AC_DEFUN(AC_KALYPTUS_VERSION,
+[
+AC_MSG_CHECKING(kalyptus version)
+$1=`cat $srcdir/Version | sed 's#Revision##g' | tr -d '\$:'`
+echo $$1
+])
+
+AC_PROG_INSTALL
+AC_FIND_PERL(perl)
+AC_SUBST(perl)
+AC_KALYPTUS_VERSION(Version)
+AC_SUBST(Version)
+
+AC_OUTPUT(Makefile)

Added: trunk/kalyptus/dcopidlng
===================================================================
--- trunk/kalyptus/dcopidlng	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/dcopidlng	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,12 @@
+#!/bin/sh
+if [[ -z $KALYPTUS || ! -d $KALYPTUS ]]
+then 
+   echo &quot;Please set enviroment variable KALYPTUS to point to your kdebindings/kaltyptus checkout directory&quot;
+   exit
+fi
+perl -I$KALYPTUS $KALYPTUS/kalyptus $2 --allow_k_dcop_accessors -f dcopidl $1 2&gt;/tmp/dcopidlng.stderr.$$
+if [[ $? -ne 0 ]]
+then
+   cat /tmp/dcopidlng.stderr.$$
+fi
+rm /tmp/dcopidlng.stderr.$$


Property changes on: trunk/kalyptus/dcopidlng
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/kalyptus/findperl
===================================================================
--- trunk/kalyptus/findperl	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/findperl	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+test -f perlbin &amp;&amp; rm perlbin
+
+for p in `echo $PATH | tr &quot;:&quot; &quot; &quot;`
+do
+	if [ -x $p/perl ]
+	then
+		if $p/perl -e 'require 5.000;' 
+		then
+			echo $p/perl &gt; perlbin
+			exit 0
+		fi
+	fi
+	
+done
+exit 1


Property changes on: trunk/kalyptus/findperl
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/kalyptus/install-sh
===================================================================
--- trunk/kalyptus/install-sh	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/install-sh	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,251 @@
+#!/bin/sh
+#
+# install - install a program, script, or datafile
+# This comes from X11R5 (mit/util/scripts/install.sh).
+#
+# Copyright 1991 by the Massachusetts Institute of Technology
+#
+# Permission to use, copy, modify, distribute, and sell this software and its
+# documentation for any purpose is hereby granted without fee, provided that
+# the above copyright notice appear in all copies and that both that
+# copyright notice and this permission notice appear in supporting
+# documentation, and that the name of M.I.T. not be used in advertising or
+# publicity pertaining to distribution of the software without specific,
+# written prior permission.  M.I.T. makes no representations about the
+# suitability of this software for any purpose.  It is provided &quot;as is&quot;
+# without express or implied warranty.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.  It can only install one file at a time, a restriction
+# shared with many OS's install programs.
+
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit=&quot;${DOITPROG-}&quot;
+
+
+# put in absolute paths if you don't have them in your path; or use env. vars.
+
+mvprog=&quot;${MVPROG-mv}&quot;
+cpprog=&quot;${CPPROG-cp}&quot;
+chmodprog=&quot;${CHMODPROG-chmod}&quot;
+chownprog=&quot;${CHOWNPROG-chown}&quot;
+chgrpprog=&quot;${CHGRPPROG-chgrp}&quot;
+stripprog=&quot;${STRIPPROG-strip}&quot;
+rmprog=&quot;${RMPROG-rm}&quot;
+mkdirprog=&quot;${MKDIRPROG-mkdir}&quot;
+
+transformbasename=&quot;&quot;
+transform_arg=&quot;&quot;
+instcmd=&quot;$mvprog&quot;
+chmodcmd=&quot;$chmodprog 0755&quot;
+chowncmd=&quot;&quot;
+chgrpcmd=&quot;&quot;
+stripcmd=&quot;&quot;
+rmcmd=&quot;$rmprog -f&quot;
+mvcmd=&quot;$mvprog&quot;
+src=&quot;&quot;
+dst=&quot;&quot;
+dir_arg=&quot;&quot;
+
+while [ x&quot;$1&quot; != x ]; do
+    case $1 in
+	-c) instcmd=&quot;$cpprog&quot;
+	    shift
+	    continue;;
+
+	-d) dir_arg=true
+	    shift
+	    continue;;
+
+	-m) chmodcmd=&quot;$chmodprog $2&quot;
+	    shift
+	    shift
+	    continue;;
+
+	-o) chowncmd=&quot;$chownprog $2&quot;
+	    shift
+	    shift
+	    continue;;
+
+	-g) chgrpcmd=&quot;$chgrpprog $2&quot;
+	    shift
+	    shift
+	    continue;;
+
+	-s) stripcmd=&quot;$stripprog&quot;
+	    shift
+	    continue;;
+
+	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
+	    shift
+	    continue;;
+
+	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
+	    shift
+	    continue;;
+
+	*)  if [ x&quot;$src&quot; = x ]
+	    then
+		src=$1
+	    else
+		# this colon is to work around a 386BSD /bin/sh bug
+		:
+		dst=$1
+	    fi
+	    shift
+	    continue;;
+    esac
+done
+
+if [ x&quot;$src&quot; = x ]
+then
+	echo &quot;install:	no input file specified&quot;
+	exit 1
+else
+	true
+fi
+
+if [ x&quot;$dir_arg&quot; != x ]; then
+	dst=$src
+	src=&quot;&quot;
+	
+	if [ -d $dst ]; then
+		instcmd=:
+		chmodcmd=&quot;&quot;
+	else
+		instcmd=mkdir
+	fi
+else
+
+# Waiting for this to be detected by the &quot;$instcmd $src $dsttmp&quot; command
+# might cause directories to be created, which would be especially bad 
+# if $src (and thus $dsttmp) contains '*'.
+
+	if [ -f $src -o -d $src ]
+	then
+		true
+	else
+		echo &quot;install:  $src does not exist&quot;
+		exit 1
+	fi
+	
+	if [ x&quot;$dst&quot; = x ]
+	then
+		echo &quot;install:	no destination specified&quot;
+		exit 1
+	else
+		true
+	fi
+
+# If destination is a directory, append the input filename; if your system
+# does not like double slashes in filenames, you may need to add some logic
+
+	if [ -d $dst ]
+	then
+		dst=&quot;$dst&quot;/`basename $src`
+	else
+		true
+	fi
+fi
+
+## this sed command emulates the dirname command
+dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
+
+# Make sure that the destination directory exists.
+#  this part is taken from Noah Friedman's mkinstalldirs script
+
+# Skip lots of stat calls in the usual case.
+if [ ! -d &quot;$dstdir&quot; ]; then
+defaultIFS='	
+'
+IFS=&quot;${IFS-${defaultIFS}}&quot;
+
+oIFS=&quot;${IFS}&quot;
+# Some sh's can't handle IFS=/ for some reason.
+IFS='%'
+set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
+IFS=&quot;${oIFS}&quot;
+
+pathcomp=''
+
+while [ $# -ne 0 ] ; do
+	pathcomp=&quot;${pathcomp}${1}&quot;
+	shift
+
+	if [ ! -d &quot;${pathcomp}&quot; ] ;
+        then
+		$mkdirprog &quot;${pathcomp}&quot;
+	else
+		true
+	fi
+
+	pathcomp=&quot;${pathcomp}/&quot;
+done
+fi
+
+if [ x&quot;$dir_arg&quot; != x ]
+then
+	$doit $instcmd $dst &amp;&amp;
+
+	if [ x&quot;$chowncmd&quot; != x ]; then $doit $chowncmd $dst; else true ; fi &amp;&amp;
+	if [ x&quot;$chgrpcmd&quot; != x ]; then $doit $chgrpcmd $dst; else true ; fi &amp;&amp;
+	if [ x&quot;$stripcmd&quot; != x ]; then $doit $stripcmd $dst; else true ; fi &amp;&amp;
+	if [ x&quot;$chmodcmd&quot; != x ]; then $doit $chmodcmd $dst; else true ; fi
+else
+
+# If we're going to rename the final executable, determine the name now.
+
+	if [ x&quot;$transformarg&quot; = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		dstfile=`basename $dst $transformbasename | 
+			sed $transformarg`$transformbasename
+	fi
+
+# don't allow the sed command to completely eliminate the filename
+
+	if [ x&quot;$dstfile&quot; = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		true
+	fi
+
+# Make a temp file name in the proper directory.
+
+	dsttmp=$dstdir/#inst.$$#
+
+# Move or copy the file name to the temp name
+
+	$doit $instcmd $src $dsttmp &amp;&amp;
+
+	trap &quot;rm -f ${dsttmp}&quot; 0 &amp;&amp;
+
+# and set any options; do chmod last to preserve setuid bits
+
+# If any of these fail, we abort the whole thing.  If we want to
+# ignore errors from any of these, just make sure not to ignore
+# errors from the above &quot;$doit $instcmd $src $dsttmp&quot; command.
+
+	if [ x&quot;$chowncmd&quot; != x ]; then $doit $chowncmd $dsttmp; else true;fi &amp;&amp;
+	if [ x&quot;$chgrpcmd&quot; != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &amp;&amp;
+	if [ x&quot;$stripcmd&quot; != x ]; then $doit $stripcmd $dsttmp; else true;fi &amp;&amp;
+	if [ x&quot;$chmodcmd&quot; != x ]; then $doit $chmodcmd $dsttmp; else true;fi &amp;&amp;
+
+# Now rename the file to the real destination.
+
+	$doit $rmcmd -f $dstdir/$dstfile &amp;&amp;
+	$doit $mvcmd $dsttmp $dstdir/$dstfile 
+
+fi &amp;&amp;
+
+
+exit 0

Added: trunk/kalyptus/kalyptus
===================================================================
--- trunk/kalyptus/kalyptus	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/kalyptus	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,1808 @@
+#!/usr/bin/perl
+
+# KDOC -- C++ and CORBA IDL interface documentation tool.
+# Sirtaj Singh Kang &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">taj at kde.org</A>&gt;, Jan 1999.
+# $Id: kalyptus 558420 2006-07-05 11:43:10Z rdale $
+
+# All files in this project are distributed under the GNU General
+# Public License. This is Free Software.
+
+require 5.000;
+
+use Carp;
+use Getopt::Long;
+use File::Basename;
+use strict;
+
+use Ast;
+
+use kdocUtil;
+use kdocAstUtil;
+use kdocParseDoc;
+
+use vars qw/ %rootNodes $declNodeType @includes_list %options @formats_wanted $allow_k_dcop_accessors
+        @includeclasses $includeclasses $skipInternal %defines $defines $match_qt_defines
+	$libdir $libname $outputdir @libs $parse_global_space $qt_embedded $qt4 $striphpath $doPrivate $readstdin
+	$Version $quiet $debug $debuggen $parseonly $currentfile $cSourceNode $exe
+	%formats %flagnames @allowed_k_dcop_accesors $allowed_k_dcop_accesors_re $rootNode 
+	@classStack $cNode $globalSpaceClassName
+	$lastLine $docNode @includes $cpp $defcppcmd $cppcmd $docincluded
+	$inExtern $inNamespace %stats @inputqueue @codeqobject @qt4_codeqobject @qte_codeqobject /;
+     
+## globals
+
+%rootNodes = ();			# root nodes for each file type
+$declNodeType = undef;			# last declaration type
+
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at includes_list</A> = ();			# list of files included from the parsed .h
+
+# All options
+
+%options = ();				# hash of options (set getopt below)
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at formats_wanted</A> = ();
+$libdir = $ENV{KDOCLIBS};
+$libname = &quot;&quot;;
+$outputdir = &quot;.&quot;;
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at libs</A> = ();				# list of includes
+$striphpath = 0;
+
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at includeclasses</A> = ();                     # names of classes to include
+$includeclasses = &quot;&quot;;
+
+$doPrivate = 0;
+$Version = &quot;0.9&quot;;
+
+$quiet = 0;
+$debug = 0;
+$debuggen = 0;
+$parseonly = 0;
+$globalSpaceClassName = &quot;QGlobalSpace&quot;;
+
+$currentfile = &quot;&quot;;
+
+$cpp = 0;
+$defcppcmd = &quot;g++ -Wp,-C -E&quot;;
+$cppcmd = &quot;&quot;;
+
+$exe = basename $0;
+
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at inputqueue</A> = ();
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at codeqobject</A> = split &quot;\n&quot;, &lt;&lt;CODE;
+public:
+    virtual QMetaObject *metaObject() const;
+    virtual const char *className() const;
+    virtual void* qt_cast( const char* );
+    virtual bool qt_invoke( int, QUObject* );
+    virtual bool qt_emit( int, QUObject* );
+    virtual bool qt_property( int, int, QVariant* );
+    static QMetaObject* staticMetaObject();
+    QObject* qObject();
+    static QString tr( const char *, const char * = 0 );
+    static QString trUtf8( const char *, const char * = 0 );
+private:
+CODE
+
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at qt4_codeqobject</A> = split &quot;\n&quot;, &lt;&lt;CODE;
+public:
+    static const QMetaObject staticMetaObject;
+    virtual const QMetaObject *metaObject() const;
+    virtual void *qt_metacast(const char *);
+    static inline QString tr(const char *s, const char *c = 0)
+        { return staticMetaObject.tr(s, c); }
+    virtual int qt_metacall(QMetaObject::Call, int, void **);
+private:
+CODE
+
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at qte_codeqobject</A> = split &quot;\n&quot;, &lt;&lt;CODE;
+public:
+    QMetaObject *metaObject() const {
+         return staticMetaObject();
+    }
+    const char *className() const;
+    static QMetaObject* staticMetaObject();
+    static QString tr( const char *, const char * = 0 );
+protected:
+    void initMetaObject();
+private:
+CODE
+
+# Supported formats
+%formats = ( &quot;java&quot; =&gt; &quot;kalyptusCxxToJava&quot;, &quot;jni&quot; =&gt; &quot;kalyptusCxxToJNI&quot;, 
+	&quot;dcopidl&quot; =&gt; &quot;kalyptusCxxToDcopIDL&quot;,
+	&quot;smoke&quot; =&gt; &quot;kalyptusCxxToSmoke&quot;, &quot;csharp&quot; =&gt; &quot;kalyptusCxxToCSharp&quot;, &quot;kimono&quot; =&gt; &quot;kalyptusCxxToKimono&quot;,
+        &quot;ECMA&quot; =&gt; &quot;kalyptusCxxToECMA&quot;, &quot;swig&quot; =&gt; &quot;kalyptusCxxToSwig&quot;,
+		&quot;KDOMECMA&quot; =&gt; &quot;kalyptusKDOMEcma&quot;);
+
+# these are for expansion of method flags
+%flagnames = ( v =&gt; 'virtual', 's' =&gt; 'static', p =&gt; 'pure',
+	c =&gt; 'const', l =&gt; 'slot', i =&gt; 'inline', n =&gt; 'signal',
+ 	d =&gt; 'k_dcop', z =&gt; 'k_dcop_signals', y =&gt; 'k_dcop_hidden' );
+
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at allowed_k_dcop_accesors</A> = qw(k_dcop k_dcop_hidden k_dcop_signals);
+$allowed_k_dcop_accesors_re = join(&quot;|&quot;, @allowed_k_dcop_accesors);
+        
+
+=head1 KDOC -- Source documentation tool
+
+	Sirtaj Singh Kang &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">taj at kde.org</A>&gt;, Dec 1998.
+
+=cut
+
+# read options
+
+Getopt::Long::config qw( no_ignore_case permute bundling auto_abbrev );
+
+GetOptions( \%options,
+	&quot;format|f=s&quot;, \@formats_wanted,
+	&quot;url|u=s&quot;,
+	&quot;skip-internal&quot;, \$skipInternal,
+	&quot;skip-deprecated|e&quot;,
+	&quot;document-all|a&quot;,
+	&quot;compress|z&quot;,
+        &quot;no-cache&quot;,      # do not create $HOME/.kalyptus cache
+	# HTML options
+	&quot;html-cols=i&quot;,
+	&quot;html-logo=s&quot;,
+
+	&quot;strip-h-path&quot;,	\$striphpath,
+	&quot;outputdir|d=s&quot;, \$outputdir,
+	&quot;stdin|i&quot;,	\$readstdin,
+	&quot;name|n=s&quot;,	\$libname,
+	&quot;help|h&quot;, 	\&amp;show_usage,
+	&quot;version|v|V&quot;, 	\&amp;show_version,
+	&quot;private|p&quot;,	\$doPrivate,
+	&quot;libdir|L=s&quot;,	\$libdir,
+	&quot;xref|l=s&quot;,	\@libs,
+	&quot;classes|c=s&quot;,    \@includeclasses,
+	&quot;globspace&quot;,	\$parse_global_space,
+	&quot;qte&quot;,	\$qt_embedded,
+	&quot;qt4&quot;,	\$qt4,
+	&quot;allow_k_dcop_accessors&quot;, \$allow_k_dcop_accessors,
+
+	&quot;cpp|P&quot;,	\$cpp,
+	&quot;docincluded&quot;,  \$docincluded,
+	&quot;cppcmd|C=s&quot;,	\$cppcmd,
+	&quot;includedir|I=s&quot;, \@includes,
+	&quot;define=s&quot;, \%defines, # define a single preprocessing symbol
+	&quot;defines=s&quot;, \$defines, # file containing preprocessing symbols, one per line
+
+	&quot;quiet|q&quot;,	\$quiet,
+	&quot;debug|D&quot;,	\$debug, # debug the parsing
+	&quot;debuggen&quot;,	\$debuggen, # debug the file generation
+	&quot;parse-only&quot;,	\$parseonly )
+		|| exit 1;
+
+$| = 1 if $debug or $debuggen;
+
+# preprocessor settings
+
+if ( $cppcmd eq &quot;&quot; ) {
+	$cppcmd = $defcppcmd;
+}
+else {
+	$cpp = 1;
+}
+
+if ($#includeclasses&gt;=0)
+{
+    $includeclasses = join (&quot; &quot;, @includeclasses);
+    print &quot;Using Classes: $includeclasses\n&quot; unless $quiet;
+}
+
+if ( $#includes &gt;= 0 &amp;&amp; !$cpp ) {
+	die &quot;$exe: --includedir requires --cpp\n&quot;;
+}
+
+# Check output formats. HTML is the default
+if( $#formats_wanted &lt; 0 ) {
+	push @formats_wanted, &quot;java&quot;;
+}
+
+foreach my $format ( @formats_wanted ) {
+	die &quot;$exe: unsupported format '$format'.\n&quot;
+		if !defined $formats{$format};
+}
+
+if( $defines )
+{
+    open( DEFS, $defines ) or die &quot;Couldn't open $defines: $!\n&quot;;
+    my @defs = &lt;DEFS&gt;;
+    chomp @defs;
+    close DEFS;
+    foreach (@defs)
+    {
+        $defines{ $_ } = 1 unless exists $defines{ $_ };
+    }
+}
+
+# Check the %defines hash for QT_* symbols and compile the corresponding RE
+# Otherwise, compile the default ones. Used for filtering in readCxxLine.
+if ( my @qt_defines = map { ($_=~m/^QT_(.*)/)[0] } keys %defines)
+{
+    my $regexp = &quot;m/^#\\s*if\\s*[n!]?\\s*def(ined\\()?\\s*QT_(?:&quot; . join('|', map { &quot;\$qt_defines[$_]&quot; } 0..$#qt_defines).&quot;)/o&quot;;
+    $match_qt_defines = eval &quot;sub { my \$s=shift;
+                                   \$s=~/^#\\s*if\\s*([n!])?\s*def(ined\\()?\\s*QT_/ || return 0;
+                                   if(!\$1) { return \$s=~$regexp ? 0:1 }
+                                   else { return \$s=~$regexp ? 1:0 }
+                                  }&quot;;
+
+    die if $@;
+}
+else
+{
+    $match_qt_defines = eval q{
+    sub
+    {
+        my $s = shift;
+        $s =~ m/^\#\s*ifndef\s+QT_NO_(?:REMOTE| # not in the default compile options
+                                        NIS|    #  ...
+                                        XINERAMA|
+                                        IMAGEIO_(?:MNG|JPEG)|
+                                        STYLE_(?:MAC|INTERLACE|COMPACT)
+                                     )/x;
+    }
+    };
+    die if $@;
+}
+# Check if there any files to process.
+# We do it here to prevent the libraries being loaded up first.
+
+checkFileArgs();
+
+# work out libdir. This is created by kdocLib:writeDoc when
+# required.
+$libdir = $ENV{HOME}.&quot;/.kalyptus&quot; unless $libdir ne &quot;&quot;;
+
+
+######
+###### main program
+######
+	readLibraries();
+	parseFiles();
+
+	if ( $parseonly ) {
+		print &quot;\n\tParse Tree\n\t------------\n\n&quot;;
+		kdocAstUtil::dumpAst( $rootNode );
+	}
+	else {
+		writeDocumentation();
+		writeLibrary() unless $libname eq &quot;&quot;;
+	}
+
+	kdocAstUtil::printDebugStats() if $debug;
+
+	exit 0;
+######
+
+sub checkFileArgs
+{
+	return unless $#ARGV &lt; 0;
+
+	die &quot;$exe: no input files.\n&quot; unless $readstdin;
+
+	# read filenames from standard input
+    	while (&lt;STDIN&gt;) {
+		chop;
+		$_ =~ s,\\,/,g;	# back to fwd slash (for Windows)
+		foreach my $file ( split( /\s+/, $_ ) ) {
+			push @ARGV, $file;
+		}
+	}
+}
+
+sub readLibraries
+{
+	return if $#libs &lt; 0;
+
+	require kdocLib;
+	foreach my $lib ( @libs ) {
+		print &quot;$exe: reading lib: $lib\n&quot; unless $quiet;
+
+		my $relpath = exists $options{url} ? 
+			$options{url} : $outputdir;
+		kdocLib::readLibrary( \&amp;getRoot, $lib, $libdir, $relpath );
+	}
+}
+
+sub parseFiles
+{
+	foreach $currentfile ( @ARGV ) {
+		my $lang = &quot;CXX&quot;;
+
+		if ( $currentfile =~ /\.idl\s*$/ ) {
+			# IDL file
+			$lang = &quot;IDL&quot;;
+		}
+
+		# assume cxx file
+		if( $cpp ) {
+			# pass through preprocessor
+			my $cmd = $cppcmd;
+			foreach my $dir ( @includes ) {
+				$cmd .= &quot; -I $dir &quot;;
+			}
+
+			$cmd .= &quot; -DQOBJECTDEFS_H $currentfile&quot;;
+
+			open( INPUT, &quot;$cmd |&quot; )
+				|| croak &quot;Can't preprocess $currentfile&quot;;
+		}
+		else {
+			open( INPUT, &quot;$currentfile&quot; ) 
+				|| croak &quot;Can't read from $currentfile&quot;;
+		}
+
+		print STDERR &quot;$exe: processing $currentfile\n&quot; unless $quiet;
+
+		# reset vars
+		$rootNode = getRoot( $lang );
+
+
+		# add to file lookup table
+		my $showname = $striphpath ? basename( $currentfile )
+						: $currentfile;
+		$cSourceNode = Ast::New( $showname );
+		$cSourceNode-&gt;AddProp( &quot;NodeType&quot;, &quot;source&quot; );
+		$cSourceNode-&gt;AddProp( &quot;Path&quot;, $currentfile );
+		$rootNode-&gt;AddPropList( &quot;Sources&quot;, $cSourceNode );
+
+		# reset state
+		@classStack = ();
+		$cNode = $rootNode;
+		$inExtern = 0;
+		$inNamespace = 0;
+
+		# parse
+		my $k = undef;
+		while ( defined ($k = readDecl()) ) {
+			print &quot;\nDecl: &lt;$k&gt;[$declNodeType]\n&quot; if $debug;
+			if( identifyDecl( $k ) &amp;&amp; $k =~ /{/ ) {
+				readCxxCodeBlock();
+			} 
+		}
+		close INPUT;
+	}
+}
+
+
+sub writeDocumentation
+{
+	foreach my $node ( values %rootNodes ) {
+		# postprocess
+		kdocAstUtil::linkNamespaces( $node );
+		kdocAstUtil::makeInherit( $node, $node );
+		kdocAstUtil::linkReferences( $node, $node );
+		kdocAstUtil::calcStats( \%stats, $node, $node );
+
+		# write
+		no strict &quot;refs&quot;;
+		foreach my $format ( @formats_wanted ) {
+			my $pack = $formats{ $format };
+			require $pack.&quot;.pm&quot;;
+
+			print STDERR &quot;Generating bindings for $format &quot;,
+				          &quot;language...\n&quot; unless $quiet;
+
+			my $f = &quot;$pack\::writeDoc&quot;;
+			&amp;$f( $libname, $node, $outputdir, \%options );
+		}
+	}
+}
+
+sub writeLibrary
+{
+	if( $libname ne &quot;&quot; and !exists $options{'no-cache'} ) {
+		require kdocLib;
+		foreach my $lang ( keys %rootNodes ) {
+			my $node = $rootNodes{ $lang };
+			kdocLib::writeDoc( $libname, $node, $lang, $libdir,
+					$outputdir, $options{url},
+					exists $options{compress} ? 1 : 0 );
+		}
+	}
+}
+
+###### Parser routines
+
+=head2 readSourceLine
+
+	Returns a raw line read from the current input file.
+	This is used by routines outside main, since I don t know
+	how to share fds.
+
+=cut
+
+sub readSourceLine
+{
+	return &lt;INPUT&gt;;
+}
+
+=head2 readCxxLine
+
+	Reads a C++ source line, skipping comments, blank lines,
+	preprocessor tokens and the Q_OBJECT macro
+
+=cut
+
+sub readCxxLine
+{
+	my( $p );
+	my( $l );
+	
+	while( 1 ) {
+		$p = shift @inputqueue || &lt;INPUT&gt;;
+		return undef if !defined ($p);
+
+		$p =~ s#//.*$##g;			# C++ comment
+		$p =~ s#/\*(?!\*).*?\*/##g;		# C comment
+
+		# join all multiline comments
+		if( $p =~ m#/\*(?!\*)#s ) {
+			# unterminated comment
+LOOP:
+			while( defined ($l = &lt;INPUT&gt;) ) {
+				$l =~ s#//.*$##g;		# C++ comment
+				$p .= $l;
+				$p =~ s#/\*(?!\*).*?\*/##sg;	# C comment
+				last LOOP unless $p =~ m#(/\*(?!\*))|(\*/)#sg;
+			}
+		}
+
+		if ( $p =~ /^\s*Q_OBJECT/ ) {
+			if ($qt_embedded) {
+				push @inputqueue, @qte_codeqobject;
+			} elsif ($qt4) {
+				push @inputqueue, @qt4_codeqobject;
+			} else {
+				push @inputqueue, @codeqobject;
+			}
+			next;
+		}
+		# Hack, waiting for real handling of preprocessor defines
+		$p =~ s/Q_REQUIRED_RESULT//;
+		$p =~ s/QT_ASCII_CAST_WARN//;
+		$p =~ s/QT_BEGIN_HEADER//;
+		$p =~ s/QT_END_HEADER//;
+		$p =~ s/QT_MODULE\(\w+\)//;
+		$p =~ s/QT_STATIC_CONST/static const/;
+		$p =~ s/QT_WEAK_SYMBOL//;
+		$p =~ s/QT_MOC_COMPAT//;
+		$p =~ s/Q_EXPORT_CODECS_BIG5//;
+		$p =~ s/Q_DECL_DEPRECATED//;
+		$p =~ s/QT_COMPAT / /;
+		$p =~ s/Q_DISABLE_COPY\((\w+)\)/$1(const $1 &amp;);\n$1 &amp;operator=(const $1 &amp;);/;
+		$p =~ s/QWIDGETSIZE_MAX/32767/; # Qt/E uses this #define as an enum value - yuck!
+		$p =~ s/Q_SIGNALS/signals/;
+		$p =~ s/ASYNC/void/;
+		$p =~ s/[A-Z_]*_EXPORT_DEPRECATED//;
+		$p =~ s/[A-Z_]*_EXPORT\s/ /;
+		$p =~ s/EXPORT_DOCKCLASS//;
+		$p =~ s/DLL_IMP_EXP_KMDICLASS//;
+		$p =~ s/KSVG_GET/KJS::Value get();/;
+		$p =~ s/KSVG_BASECLASS_GET/KJS::Value get();/;
+		$p =~ s/KSVG_BRIDGE/KJS::ObjectImp *bridge();/;
+		$p =~ s/KSVG_FORWARDGET/KJS::Value getforward();/;
+		$p =~ s/KSVG_PUT/bool put();/;
+		$p =~ s/KSVG_FORWARDPUT/bool putforward();/;
+		$p =~ s/KSVG_BASECLASS/virtual KJS::Value cache();/;
+		if ( $p =~ m/KSVG_DEFINE_PROTOTYPE\((\w+)\)/ ) {
+			push @inputqueue, split('\n',&quot;namespace KSVG {\nclass $1 {\n};\n};&quot;);
+		}
+		# Bother the same again for KDOM :/
+		$p =~ s/KDOM_GET/KJS::Value get();/;
+		$p =~ s/KDOM_BASECLASS_GET/KJS::Value get();/;
+		$p =~ s/KDOM_FORWARDGET/KJS::Value getforward();/;
+		$p =~ s/KDOM_PUT/bool put();/;
+		$p =~ s/KDOM_FORWARDPUT/bool putforward();/;
+		$p =~ s/KDOM_BASECLASS/virtual KJS::Value cache();/;
+		$p =~ s/KDOM_CAST/KJS::Value cast();/;
+		if ( $p =~ m/KDOM_DEFINE_PROTOTYPE\((\w+)\)/ ) {
+			push @inputqueue, split('\n',&quot;namespace KDOM {\nclass $1 {\n};\n};&quot;);
+		}
+
+
+		next if ( $p =~ /^\s*$/s ); 		# blank lines
+#			|| $p =~ /^\s*Q_OBJECT/		# QObject macro
+#			);
+#
+
+		next if ( $p =~ /^\s*Q_ENUMS/           # ignore Q_ENUMS
+                        || $p =~ /^\s*Q_FLAGS/       # and Q_FLAGS
+                        || $p =~ /^\s*Q_DECLARE_FLAGS/       # and Q_DECLARE_FLAGS
+                        || ( !$qt4 &amp;&amp; $p =~ /^\s*Q_PROPERTY/ )      # and Q_PROPERTY
+                        || $p =~ /^\s*QDOC_PROPERTY/
+                        || $p =~ /^\s*Q_GADGET/
+                        || $p =~ /^\s*Q_OVERRIDE/       # and Q_OVERRIDE
+                        || $p =~ /^\s*Q_SETS/
+                        || $p =~ /^\s*Q_DUMMY_COMPARISON_OPERATOR/
+                        || $p =~ /^\s*K_SYCOCATYPE/     # and K_SYCOCA stuff
+                        || $p =~ /^\s*K_SYCOCAFACTORY/  #
+                        || $p =~ /^\s*KSVG_/            # and KSVG stuff ;)
+						|| $p =~ /^\s*KDOM_/			# and KDOM stuff :(
+						|| $p =~ /^\s*Q_DECLARE_FLAGS/
+						|| $p =~ /^\s*Q_DECLARE_OPERATORS_FOR_FLAGS/
+						|| $p =~ /^\s*Q_DECLARE_PRIVATE/
+						|| $p =~ /^\s*Q_DECLARE_TYPEINFO/
+						|| $p =~ /^\s*Q_PRIVATE_SLOT/
+						|| $p =~ /^\s*Q_DECLARE_SHARED/
+						|| $p =~ /^\s*Q_DECLARE_INTERFACE/
+						|| $p =~ /^\s*Q_DECLARE_METATYPE/
+			);
+
+		push @includes_list, $1 if $p =~ /^#include\s+&lt;?(.*?)&gt;?\s*$/;
+
+		# remove all preprocessor macros
+		if( $p =~ /^\s*#\s*(\w+)/ ) {
+			# Handling of preprocessed sources: skip anything included from
+			# other files, unless --docincluded was passed.
+			if (!$docincluded &amp;&amp; $p =~ /^\s*#\s*[0-9]+\s*\&quot;.*$/ 
+					&amp;&amp; not($p =~ /\&quot;$currentfile\&quot;/)) {
+				# include file markers
+				while( &lt;INPUT&gt; ) {
+					last if(/\&quot;$currentfile\&quot;/);
+					print &quot;Overread $_&quot; if $debug;
+				};
+				print &quot;Cont: $_&quot; if $debug;
+			}
+			else {
+				# Skip platform-specific stuff, or #if 0 stuff
+				# or #else of something we parsed (e.g. for QKeySequence)
+				if ( $p =~ m/^#\s*ifdef\s*Q_WS_/ or
+				     $p =~ m/^#\s*if\s+defined\(Q_WS_/ or
+				     ($p =~ m/^#\s*ifdef\s+_WS_QWS_/ and $qt_embedded) or
+				     ($p =~ m/^#\s*ifndef\s+QT_NO_MIMECLIPBOARD/ and $qt_embedded) or
+				     ($p =~ m/^#\s*if\s+defined\(_WS_X11_/ and $qt_embedded) or
+				     ($p =~ m/^#\s*if\s+defined\(Q_WS_X11_/ and $qt_embedded) or
+				     ($p =~ m/^#\s*if\s+defined\(Q_WS_WIN_/ and $qt_embedded) or
+				     ($p =~ m/^#\s*if\s+defined\(_WS_MAC_/ and $qt_embedded) or
+				     ($p =~ m/^#\s*if\s+defined\(Q_INCOMPATIBLE_3_0_ADDONS/ and $qt_embedded) or
+				     $p =~ m/^#\s*ifndef\s+QT_NO_STL/ or
+				     $p =~ m/^#\s*if\s+defined\s*\(Q_OS_/ or
+				     $p =~ m/^#\s*if\s+defined\(Q_CC_/ or
+				     $p =~ m/^#\s*if\s+defined\(QT_THREAD_SUPPORT/ or
+				     $p =~ m/^#\s*else/ or
+				     $p =~ m/^#\s*if\s+defined\(Q_FULL_TEMPLATE_INSTANTIATION/ or
+				     $p =~ m/^#\s*ifdef\s+QT_WORKSPACE_WINDOWMODE/ or
+				     $p =~ m/^#\s*ifdef\s+QT_COMPAT/ or
+				     $p =~ m/^#\s*if\s+defined\s*\(?QT_COMPAT/ or
+				     $p =~ m/^#\s*ifdef\s+CONTAINER_CUSTOM_WIDGETS/ or
+				     $p =~ m/^#\s*ifdef\s+QT3_SUPPORT/ or
+				     $p =~ m/^#\s*ifdef\s+Q_WS_WIN/ or
+				     $p =~ m/^#if\s*!?defined\(Q_WS_WIN\)/ or
+				     $p =~ m/^#if\s*!?defined\(Q_OS_WIN32\)/ or
+				     $p =~ m/^#\s*ifdef\s+Q_OS_UNIX/ or
+				     $p =~ m/^#\s*ifdef\s+Q_MOC_RUN/ or
+				     $p =~ m/^#\s*if\s+defined\s*\(QT3_SUPPORT/ or
+				     $p =~ m/^#\s*if\s+defined\s*\(qdoc/ or
+				     $p =~ m/^#\s*ifndef\s+QT_NO_MEMBER_TEMPLATES/ or
+				     $p =~ m/^#if\s*!defined\(Q_NO_USING_KEYWORD\)/ or
+				     $p =~ m/^#if\s*defined\(Q_INTERNAL_QAPP_SRC\)/ or
+				     ($p =~ m/^#if\s*QT_VERSION\s*&lt;\s*0x040000/ and $qt4) or
+				     &amp;$match_qt_defines( $p ) or
+				     $p =~ m/^#\s*if\s+0\s+/ ) {
+				     my $if_depth = 1;
+				     while ( defined $p &amp;&amp; $if_depth &gt; 0 ) {
+					 $p = &lt;INPUT&gt;;
+					 last if !defined $p;
+					 $if_depth++ if $p =~ m/^#\s*if/;
+					 $if_depth-- if $p =~ m/^#\s*endif/;
+					 # Exit at #else in the #ifdef QT_NO_ACCEL/#else/#endif case
+					 last if $if_depth == 1 &amp;&amp; $p =~ m/^#\s*else\s/;
+					 #ignore elif for now
+					 print &quot;Skipping ifdef'ed line: $p&quot; if $debug;
+				     }
+				}
+
+				# multiline macros
+				while ( defined $p &amp;&amp; $p =~ m#\\\s*$# ) {
+					$p = &lt;INPUT&gt;;
+				}
+			}
+			next;
+		}
+
+		$lastLine = $p;
+		return $p;
+	}
+}
+
+=head2 readCxxCodeBlock
+
+	Reads a C++ code block (recursive curlies), returning the last line
+	or undef on error.
+
+	Parameters: none
+
+=cut
+
+sub readCxxCodeBlock
+{
+# Code: begins in a {, ends in }\s*;?
+# In between: cxx source, including {}
+	my ( $count ) = 0;
+	my $l = undef;
+	
+	if ( defined $lastLine ) {
+		print &quot;lastLine: '$lastLine'&quot; if $debug;
+
+		my $open = kdocUtil::countReg( $lastLine, &quot;{&quot; );
+		my $close = kdocUtil::countReg( $lastLine, &quot;}&quot; );
+		$count = $open - $close;
+
+		return $lastLine if ( $open || $close) &amp;&amp; $count == 0;
+	}
+
+	# find opening brace
+	if ( $count == 0 ) {
+		while( $count == 0 ) {
+			$l = readCxxLine();
+			return undef if !defined $l;
+			$l =~ s/\\.//g;
+			$l =~ s/'.?'//g;
+			$l =~ s/&quot;.*?&quot;//g;
+
+			$count += kdocUtil::countReg( $l, &quot;{&quot; );
+			print &quot;c &quot;, $count, &quot; at '$l'&quot; if $debug;
+		}
+		$count -= kdocUtil::countReg( $l, &quot;}&quot; );
+	}
+
+	# find associated closing brace
+	while ( $count &gt; 0 ) {
+		$l = readCxxLine();
+		croak &quot;Confused by unmatched braces&quot; if !defined $l;
+		$l =~ s/\\.//g;
+		$l =~ s/'.?'//g;
+		$l =~ s/&quot;.*?&quot;//g;
+
+		my $add = kdocUtil::countReg( $l, &quot;{&quot; );
+		my $sub = kdocUtil::countReg( $l, &quot;}&quot; );
+		$count += $add - $sub;
+
+		print &quot;o &quot;, $add, &quot; c &quot;, $sub, &quot; at '$l'&quot; if $debug;
+	}
+
+	undef $lastLine;
+	return $l;
+}
+
+=head2 readDecl
+
+	Returns a declaration and sets the $declNodeType variable.
+
+	A decl starts with a type or keyword and ends with [{};]
+	The entire decl is returned in a single line, sans newlines.
+
+	declNodeType values: undef for error, &quot;a&quot; for access specifier,
+	&quot;c&quot; for doc comment, &quot;d&quot; for other decls.
+
+	readCxxLine is used to read the declaration.
+
+=cut
+
+sub readDecl
+{
+	undef $declNodeType;
+	my $l = readCxxLine();
+	my ( $decl ) = &quot;&quot;;
+
+	my $allowed_accesors = &quot;private|public|protected|signals&quot;;
+	$allowed_accesors .= &quot;|$allowed_k_dcop_accesors_re&quot; if $allow_k_dcop_accessors;
+
+	if( !defined $l ) {
+		return undef;
+	}
+	elsif ( $l =~ /^\s*($allowed_accesors)
+		       (\s+\w+)?\s*:/x) { # access specifier
+		$declNodeType = &quot;a&quot;;
+		return $l;
+	}
+        elsif ( $l =~ /K_DCOP/ ) {
+		$declNodeType = &quot;k&quot;;
+		return $l;
+        }
+	elsif ( $l =~ m#^\s*/\*\*# ) {	# doc comment
+		$declNodeType = &quot;c&quot;;
+		return $l;
+	}
+	elsif ( $l =~ /Q_PROPERTY/ ) {	# property
+		return $l;
+	}
+
+	do {
+		$decl .= $l;
+
+		if ( $l =~ /[{};]/ ) {
+			$decl =~ s/\n/ /gs;
+			$declNodeType = &quot;d&quot;;
+			return $decl;
+		}
+		return undef if !defined ($l = readCxxLine());
+
+	} while ( 1 );
+}
+
+#### AST Generator Routines
+
+=head2 getRoot
+
+	Return a root node for the given type of input file.
+
+=cut
+
+sub getRoot
+{
+	my $type = shift;
+	carp &quot;getRoot called without type&quot; unless defined $type;
+
+	if ( !exists $rootNodes{ $type } ) {
+		my $node = Ast::New( &quot;Global&quot; );	# parent of all nodes
+		$node-&gt;AddProp( &quot;NodeType&quot;, &quot;root&quot; );
+		$node-&gt;AddProp( &quot;RootType&quot;, $type );
+		$node-&gt;AddProp( &quot;Compound&quot;, 1 );
+		$node-&gt;AddProp( &quot;KidAccess&quot;, &quot;public&quot; );
+
+		$rootNodes{ $type } = $node;
+	}
+	print &quot;getRoot: call for $type\n&quot; if $debug;
+
+	return $rootNodes{ $type };
+}
+
+=head2 identifyDecl
+
+	Parameters: decl
+
+	Identifies a declaration returned by readDecl. If a code block
+	needs to be skipped, this subroutine returns a 1, or 0 otherwise.
+
+=cut
+
+sub identifyDecl
+{
+	my( $decl ) = @_;
+
+	my $newNode = undef;
+	my $skipBlock = 0;
+	my $isDeprecated = 0;
+	
+	if ( $decl =~ s/KDE_DEPRECATED// ) {
+		$isDeprecated = 1;
+	}
+	# Doc comment
+	if ( $declNodeType eq &quot;c&quot; ) {
+		$docNode = kdocParseDoc::newDocComment( $decl );
+
+		# if it's the main doc, it is attached to the root node
+		if ( defined $docNode-&gt;{LibDoc} ) {
+			kdocParseDoc::attachDoc( $rootNode, $docNode,
+				$rootNode );
+			undef $docNode;
+		}
+
+	}
+	elsif ( $declNodeType eq &quot;a&quot; ) {
+		newAccess( $decl );
+	}
+        elsif ( $declNodeType eq &quot;k&quot; ) {
+	        $cNode-&gt;AddProp( &quot;DcopExported&quot;, 1 );
+        }
+    # properties
+    elsif ( $decl =~ s/Q_PROPERTY// ) {
+		print &quot;Property: &lt;$1&gt;\n&quot; if $debug;
+
+		$newNode = newProperty( $decl );
+	}
+	# Typedef struct/class
+	elsif ( $decl =~ /^\s*typedef
+			\s+(struct|union|class|enum)
+			\s*([_\w\:]*)
+			\s*([;{]) 
+			/xs ) {
+		my ($type, $name, $endtag, $rest ) = ($1, $2, $3, $' );
+		$name = &quot;--&quot; if $name eq &quot;&quot;;
+
+		warn &quot;typedef '$type' n:'$name'\n&quot; if $debug;
+
+		if ( $rest =~ /}\s*([\w_]+(?:::[\w_])*)\s*;/ ) {
+			# TODO: Doesn't parse members yet!
+			$endtag = &quot;;&quot;;
+			$name = $1;
+		}
+
+		$newNode = newTypedefComp( $type, $name, $endtag );
+	}
+
+	# Typedef
+	elsif ( $decl =~ /^\s*typedef\s+
+			(?:typename\s+)?        # `typename' keyword
+			(.*?\s*[\*&amp;&gt;]?)		# type
+			\s*([-\w_\:]+)		# name
+			\s*((?:\[[-\w_\:&lt;&gt;\s]*\])*)	# array
+			\s*[{;]\s*$/xs  ) {
+
+		print &quot;Typedef: &lt;$1 $3&gt; &lt;$2&gt;\n&quot; if $debug;
+		$newNode = newTypedef( $1.&quot; &quot;.$3, $2 );
+	}
+
+	# Enum
+	elsif ( $decl =~ /^\s*enum\s+([-\w_:]*)?\s*\{(.*)/s  ) {
+
+		print &quot;Enum: &lt;$1&gt;\n&quot; if $debug;
+		my $enumname = defined $2 ? $1 : &quot;&quot;;
+
+		$newNode = newEnum( $enumname );
+	}
+
+	# Class/Struct
+	elsif ( $decl =~ /^\s*((?:template\s*&lt;.*&gt;)?)      # 1 template
+					\s*(class|struct|union|namespace) # 2 struct type
+					(?:\s*Q[A-Z_]*EXPORT[A-Z_]*)?
+					(?:\s*Q_PACKED)?
+					(?:\s*Q_REFCOUNT)?
+					\s+([\w_]+                        # 3 name
+							(?:&lt;[\w_ :,]+?&gt;)?		  # maybe explicit template
+									#    (eat chars between &lt;&gt; non-hungry)
+							(?:::[\w_]+)*                 #   maybe nested
+					   )
+					([^\(]*?)                             # 4 inheritance
+					([;{])/xs ) {                     # 5 rest
+
+		print &quot;Class: [$1]\n\t[$2]\n\t[$3]\n\t[$4]\n\t[$5]\n&quot; if $debug;
+		my ( $tmpl, $ntype, $name, $rest, $endtag ) =
+			( $1, $2, $3, $4, $5 );
+
+		if ($includeclasses)
+		{
+		    if (! ($includeclasses =~ /$name/) )
+		    {
+			return 1;
+			
+		    }
+		}
+		if ($ntype eq 'namespace') {
+			if ($decl =~ /}/) {
+				return 0;
+			}
+			# Set a flag to indicate we're in a multi-line namespace declaration
+			$inNamespace = 1;
+		}
+		
+		my @inherits = ();
+
+		$tmpl =~ s/&lt;(.*)&gt;/$1/ if $tmpl ne &quot;&quot;;
+
+		if(  $rest =~ /^\s*:\s*/ ) {
+			# inheritance 
+			$rest = $';
+			@inherits = parseInheritance( $rest );
+		}
+
+		$newNode = newClass( $tmpl, $ntype, 
+			$name, $endtag, $isDeprecated, @inherits );
+
+		if ($decl =~ /};/) {
+			# If the declaration was all on one line ending with a '};', 
+			# then pop the new node
+			$cNode = pop @classStack;
+			print &quot;end decl: popped $cNode-&gt;{astNodeName}\n&quot; 
+				if $debug;
+		}
+	}
+	# IDL compound node
+	elsif( $decl =~ /^\s*(module|interface|exception) # struct type
+			\s+([-\w_]+)			# name
+			(.*?)				# inheritance?
+			([;{])/xs ) {
+		
+		my ( $type, $name, $rest, $fwd, $complete ) 
+			= ( $1, $2, $3, $4 eq &quot;;&quot; ? 1 : 0,
+				0 );
+		my @in = ();
+		print &quot;IDL: [$type] [$name] [$rest] [$fwd]\n&quot; if $debug;
+
+		if( $rest =~ /^\s*:\s*/ ) {
+			$rest = $';
+			$rest =~ s/\s+//g;
+			@in = split &quot;,&quot;, $rest;
+		}
+		if( $decl =~ /}\s*;/ ) {
+			$complete = 1;
+		}
+
+		$newNode = newIDLstruct( $type, $name, $fwd, $complete, @in );
+	}
+	# Method
+	elsif ( $decl =~ /^\s*(?:(?:class|struct)\s*)?([^=]+?(?:operator\s*(?:\(\)|.?=)\s*)?) # ret+nm
+		\( (.*?) \)		# parameters
+		\s*((?:const)?)\s*
+		(?:throw\s*\(.*?\))?
+		\s*((?:=\s*0(?:L?))?)\s*	# Pureness. is &quot;0L&quot; allowed?
+		\s*[;{]+/xs ) {	# rest
+
+		my $tpn = $1; # type + name
+		my $params = $2;
+		# Remove constructor initializer, that's not in the params
+		if ( $params =~ /\s*\)\s*:\s*/ ) {
+			# Hack: first .* made non-greedy for QSizePolicy using a?(b):c in ctor init
+			$params =~ s/(.*?)\s*\)\s*:\s*.*$/$1/;
+		}
+
+		my $const = $3 eq &quot;&quot; ? 0 : 1;
+		my $pure = $4 eq &quot;&quot; ? 0 : 1;
+		$tpn =~ s/\s+/ /g;
+		$tpn =~ s/operator\s+([^\w])/operator$1/g;
+		$params =~ s/\s+/ /g;
+
+		print &quot;Method: R+N:[$tpn]\n\tP:[$params]\n\t[$const]\n&quot; if $debug;
+
+		if ( $tpn =~ /((?:\w+\s*::\s*)?operator.*?)\s*$/	# operator
+					|| $tpn =~ /((?:\w*\s*::\s*~?)?[-\w:]+)\s*$/  ) { # normal
+				my $name = $1;
+				$tpn = $`;
+				$newNode = newMethod( $tpn, $name, 
+								$params, $const, $pure, $isDeprecated );
+		}
+
+		$skipBlock = 1; # FIXME check end token before doing this!
+	}
+	# Using: import namespace
+	elsif ( $decl =~ /^\s*using\s+namespace\s+(\w+)/ ) {
+		newNamespace( $1 );
+
+	}
+
+	# extern block
+	elsif ( $decl =~ /^\s*extern\s*&quot;(.*)&quot;\s*{/ ) {
+		$inExtern = 1 unless $decl =~ /}/;
+	}
+
+	# Single variable
+	elsif ( $decl =~ /^
+			\s*( (?:[\w_:]+(?:\s+[\w_:]+)*? )# type
+				\s*(?:&lt;.+&gt;)?		# template
+				\s*(?:[\&amp;\*])?		# ptr or ref
+				(?:\s*(?:const|volatile))* )
+			\s*([\w_:]+)			# name
+			\s*( (?:\[[^\[\]]*\] (?:\s*\[[^\[\]]*\])*)? ) # array
+			\s*((?:=.*)?)			# value
+			\s*([;{])\s*$/xs ) {
+		my $type = $1;
+		my $name = $2;
+		my $arr  = $3;
+		my $val	 = $4;
+		my $end	 = $5;
+
+		$type =~ s/\s+/ /g;
+
+		if ( $type !~ /^friend\s+class\s*/ &amp;&amp; $type.$name ne &quot;struct&quot; ) {
+			print &quot;Var: [$name] type: [$type$arr] val: [$val]\n&quot;
+				if $debug;
+
+			$newNode = newVar( $type.$arr, $name, $val );
+		}
+
+		$skipBlock = 1 if $end eq '{';
+	}
+
+	# Multi variables
+	elsif ( $decl =~ m/^
+		\s*( (?:[\w_:]+(?:\s+[\w_:]+)*? )	# type
+		\s*(?:&lt;.+&gt;)?)						# template
+
+		\s*( (?:\s*(?: [\&amp;\*][\&amp;\*\s]*)? 	# ptr or ref
+			[\w_:]+)						# name
+		\s*(?:\[[^\[\]]*\] (?:\s*\[[^\[\]]*\])*)? # array
+		\s*(?:,								# extra vars
+			\s*(?: [\&amp;\*][\&amp;\*\s]*)? 		# ptr or ref
+			\s*(?:[\w_:]+)					# name
+			\s*(?:\[[^\[\]]*\] (?:\s*\[[^\[\]]*\])*)? # array
+			)* 
+		\s*(?:=.*)?)						# value
+		\s*[;]/xs ) {
+
+		my $type = $1;
+		my $names = $2;
+		my $end = $3;
+		my $doc = $docNode;
+
+		print &quot;Multivar: type: [$type] names: [$names] \n&quot; if $debug;
+
+		foreach my $vardecl ( split( /\s*,\s*/, $names ) ) {
+			next unless $vardecl =~ m/
+			\s*((?: [\&amp;\*][\&amp;\*\s]*)?) 	# ptr or ref
+			\s*([\w_:]+)			# name
+			\s*( (?:\[[^\[\]]*\] (?:\s*\[[^\[\]]*\])*)? ) # array
+			\s*((?:=.*)?)			# value
+				/xs;
+			my ($ptr, $name, $arr, $val) = ($1, $2, $3, $4);
+
+			print &quot;Split: type: [$type$ptr$arr] &quot;,
+				&quot; name: [$name] val: [$val] \n&quot; if $debug;
+
+			my $node = newVar( $type.$ptr.$arr, $name, $val );
+
+			$docNode = $doc;	# reuse docNode for each
+			postInitNode( $node ) unless !defined $node;
+		}
+
+		$skipBlock = 1 if $end eq '{';
+	}
+	# end of an &quot;extern&quot; block
+	elsif ( $decl =~ /^\s*}\s*$/ &amp;&amp; $inExtern ) {
+		$inExtern = 0;
+	}
+	# end of an in-block declaration
+	elsif ( $decl =~ /^\s*}\s*(.*?)\s*;\s*$/ || ($decl =~ /^\s*}\s*$/ &amp;&amp; $inNamespace) ) {
+		if ( $cNode-&gt;{astNodeName} eq &quot;--&quot; ) {
+			# structure typedefs should have no name preassigned.
+			# If they do, then the name in 
+			# &quot;typedef struct &lt;name&gt; { ...&quot; is kept instead.
+			# TODO: Buglet. You should fix YOUR code dammit. ;)
+
+
+			$cNode-&gt;{astNodeName} = $1;
+			my $siblings = $cNode-&gt;{Parent}-&gt;{KidHash};
+			undef $siblings-&gt;{&quot;--&quot;};
+			$siblings-&gt;{ $1 } = $cNode;
+		}
+
+		# C++ namespaces end with a '}', and not '};' like classes
+		if ($decl =~ /^\s*}\s*$/ ) {
+			$inNamespace = 0;
+		}
+		
+		if ( $#classStack &lt; 0 ) {
+			confess &quot;close decl found, but no class in stack!&quot; ;
+			$cNode = $rootNode;
+		}
+		else {
+			$cNode = pop @classStack;
+			print &quot;end decl: popped $cNode-&gt;{astNodeName}\n&quot; 
+				if $debug;
+		}
+	}
+	# unidentified block start
+	elsif ( $decl =~ /{/ ) {
+		print &quot;Unidentified block start: $decl\n&quot; if $debug;
+		$skipBlock = 1;
+	}
+	# explicit template instantiation, or friend template
+	elsif ( $decl =~ /(template|friend)\s+class\s+(?:Q[A-Z_]*EXPORT[A-Z_]*\s*)?\w+\s*&lt;.*&gt;\s*;/x ) {
+		# Nothing to be done with those.
+	}
+	else {
+
+		## decl is unidentified.
+		warn &quot;Unidentified decl: $decl\n&quot;;
+	}
+
+	# once we get here, the last doc node is already used.
+	# postInitNode should NOT be called for forward decls
+	postInitNode( $newNode ) unless !defined $newNode;
+
+	return $skipBlock;
+}
+
+sub postInitNode
+{
+	my $newNode = shift;
+
+	carp &quot;Cannot postinit undef node.&quot; if !defined $newNode;
+
+	# The reasoning here:
+	# Forward decls never get a source node.
+	# Once a source node is defined, don't assign another one.
+
+	if ( $newNode-&gt;{NodeType} ne &quot;Forward&quot; &amp;&amp; !defined $newNode-&gt;{Source}) {
+		$newNode-&gt;AddProp( &quot;Source&quot;, $cSourceNode );
+	} elsif ( $newNode-&gt;{NodeType} eq &quot;Forward&quot; ) {
+		if ($debug) {
+			print &quot;postInit: skipping fwd: $newNode-&gt;{astNodeName}\n&quot;;
+		}
+		undef $docNode;
+		return;
+	}
+
+	if( defined $docNode ) {
+		kdocParseDoc::attachDoc( $newNode, $docNode, $rootNode );
+		undef $docNode;
+	}
+}
+
+
+##### Node generators
+
+=head2 newEnum
+
+	Reads the parameters of an enumeration.
+
+	Returns the parameters, or undef on error.
+
+=cut
+
+sub newEnum
+{
+	my ( $enum ) = @_;
+	my $k = undef;
+	my $params = &quot;&quot;;
+
+	$k = $lastLine if defined $lastLine;
+
+	if( defined $lastLine &amp;&amp; $lastLine =~ /{/ ) {
+		$params = $';
+		if ( $lastLine =~ /}(.*?);/ ) {
+			return initEnum( $enum, $1, $params );
+		}
+	}
+
+	while ( defined ( $k = readCxxLine() ) ) {
+		$params .= $k;
+
+		if ( $k =~ /}(.*?);/ ) {
+			return initEnum( $enum, $1, $params );
+		}
+	}
+
+	return undef;
+}
+
+=head2 initEnum
+
+	Parameters: name, (ref) params
+
+	Returns an initialized enum node.
+
+=cut
+
+sub initEnum
+{
+	my( $name, $end, $params ) = @_;
+
+	($name = $end) if $name eq &quot;&quot; &amp;&amp; $end ne &quot;&quot;;
+
+	$params =~ s#\s+# #sg; # no newlines
+	$params =~ s#\s*/\*([^\*]/|\*[^/]|[^\*/])*\*/##g; # strip out comments
+	$params = $1 if $params =~ /^\s*{?(.*)}/;
+	$params =~ s/,\s*$/ /;
+	print &quot;$name params: [$params]\n&quot; if $debug;
+
+	my ( $node ) = Ast::New( $name );
+	$node-&gt;AddProp( &quot;NodeType&quot;, &quot;enum&quot; );
+	$node-&gt;AddProp( &quot;Params&quot;, $params );
+	$node-&gt;AddProp( &quot;Source&quot;, $cSourceNode );
+	makeParamList( $node, $params, 1 ); # Adds the ParamList property containing the list of param nodes
+	kdocAstUtil::attachChild( $cNode, $node );
+
+	return $node;
+}
+
+=head2 newIDLstruct
+
+	Parameters: type, name, forward, complete, inherits...
+
+	Handles an IDL structure definition (ie module, interface,
+	exception).
+
+=cut
+
+sub newIDLstruct
+{
+	my ( $type, $name, $fwd, $complete ) = @_;
+
+	my $node = exists $cNode-&gt;{KidHash} ? 
+		$cNode-&gt;{KidHash}-&gt;{ $name } : undef;
+
+	if( !defined $node ) {
+		$node = Ast::New( $name );
+		$node-&gt;AddProp( &quot;NodeType&quot;, $fwd ? &quot;Forward&quot; : $type );
+		$node-&gt;AddProp( &quot;KidAccess&quot;, &quot;public&quot; );
+		$node-&gt;AddProp( &quot;Compound&quot;, 1 ) unless $fwd;
+		kdocAstUtil::attachChild( $cNode, $node );
+	}
+	elsif ( $fwd ) {
+		# If we have a node already, we ignore forwards.
+		return undef;
+	}
+	elsif ( $node-&gt;{NodeType} eq &quot;Forward&quot; ) {
+		# we are defining a previously forward node.
+		$node-&gt;AddProp( &quot;NodeType&quot;, $type );
+		$node-&gt;AddProp( &quot;Compound&quot;, 1 );
+		$node-&gt;AddProp( &quot;Source&quot;, $cSourceNode );
+	}
+
+	# register ancestors.
+	foreach my $ances ( splice ( @_, 4 ) ) {
+		my $n = kdocAstUtil::newInherit( $node, $ances );
+	}
+
+	if( !( $fwd || $complete) ) {
+		print &quot;newIDL: pushing $cNode-&gt;{astNodeName},&quot;,
+			&quot; new is $node-&gt;{astNodeName}\n&quot;
+				if $debug;
+		push @classStack, $cNode;
+		$cNode = $node;
+	}
+
+	return $node;
+}
+
+=head2 newClass
+
+	Parameters: tmplArgs, cNodeType, name, endTag, isDeprecated, @inheritlist
+
+	Handles a class declaration (also fwd decls).
+
+=cut
+
+sub newClass
+{
+	my( $tmplArgs, $cNodeType, $name, $endTag, $isDeprecated ) = @_;
+
+	my $access = &quot;private&quot;;
+	$access = &quot;public&quot; if $cNodeType ne &quot;class&quot;;
+
+	# try to find an exisiting node, or create a new one
+	my $oldnode = kdocAstUtil::findRef( $cNode, $name );
+	my $node = defined $oldnode ? $oldnode : Ast::New( $name );
+
+	if ( $endTag ne &quot;{&quot; ) {
+		# forward
+		if ( !defined $oldnode ) {
+			# new forward node
+			$node-&gt;AddProp( &quot;NodeType&quot;, &quot;Forward&quot; );
+			$node-&gt;AddProp( &quot;KidAccess&quot;, $access );
+			kdocAstUtil::attachChild( $cNode, $node );
+		}
+		# Discard any doc comment against a forward decl
+		undef $docNode;
+		return $node;
+	}
+
+	# this is a class declaration
+
+	print &quot;ClassName: $name\n&quot; if $debug;
+
+	$node-&gt;AddProp( &quot;NodeType&quot;, $cNodeType );
+	$node-&gt;AddProp( &quot;Compound&quot;, 1 );
+	$node-&gt;AddProp( &quot;Source&quot;, $cSourceNode );
+	
+	if ($cNodeType eq 'namespace') {
+		$node-&gt;AddPropList( &quot;Sources&quot;, $cSourceNode );
+	}
+
+	$node-&gt;AddProp( &quot;KidAccess&quot;, $access );
+	$node-&gt;AddProp( &quot;Tmpl&quot;, $tmplArgs ) unless $tmplArgs eq &quot;&quot;;
+
+	$node-&gt;AddProp( &quot;Deprecated&quot;, $isDeprecated );
+
+	if ( !defined $oldnode ) {
+		kdocAstUtil::attachChild( $cNode, $node );
+	}
+
+	# inheritance
+
+	foreach my $ances ( splice (@_, 5) ) {
+		my $type = &quot;&quot;;
+		my $name = $ances;
+		my $intmpl = undef;
+
+WORD:
+		foreach my $word ( split ( /([\w:]+(:?\s*&lt;.*&gt;)?)/, $ances ) ) {
+			next WORD unless $word =~ /^[\w:]/;
+			if ( $word =~ /(private|public|protected|virtual)/ ) {
+				$type .= &quot;$1 &quot;;
+			}
+			else {
+				
+				if ( $word =~ /&lt;(.*)&gt;/ ) {
+					# FIXME: Handle multiple tmpl args
+					$name = $`;
+					$intmpl = $1;
+				}
+				else {
+					$name = $word;
+				}
+
+				last WORD;
+			}
+		}
+
+		# set inheritance access specifier if none specified
+		if ( $type eq &quot;&quot; ) {
+			$type = $cNodeType eq &quot;class&quot; ? &quot;private &quot;:&quot;public &quot;;
+		}
+		chop $type;
+
+		# attach inheritance information
+		my $n = kdocAstUtil::newInherit( $node, $name );
+		$n-&gt;AddProp( &quot;Type&quot;, $type );
+
+		$n-&gt;AddProp( &quot;TmplType&quot;, $intmpl ) if defined $intmpl;
+
+		print &quot;In: $name type: $type, tmpl: $intmpl\n&quot; if $debug;
+	}
+
+	# new current node
+	print &quot;newClass: Pushing $cNode-&gt;{astNodeName}\n&quot; if $debug;
+	push ( @classStack, $cNode );
+	$cNode = $node;
+
+	return $node;
+}
+
+
+=head3 parseInheritance
+
+	Param: inheritance decl string
+	Returns: list of superclasses (template decls included)
+
+	This will fail if &lt; and &gt; appear in strings in the decl.
+
+=cut
+
+sub parseInheritance
+{
+	my $instring = shift;
+	my @inherits = ();
+
+	my $accum = &quot;&quot;;
+	foreach $instring ( split (/\s*,\s*/, $instring) ) {
+		$accum .= $instring.&quot;, &quot;;
+		next unless  (kdocUtil::countReg( $accum, &quot;&lt;&quot; )
+			- kdocUtil::countReg( $accum, &quot;&gt;&quot; ) ) == 0;
+
+		# matching no. of &lt; and &gt;, so assume the parent is
+		# complete
+		$accum =~ s/,\s*$//;
+		print &quot;Inherits: '$accum'\n&quot; if $debug;
+		push @inherits, $accum;
+		$accum = &quot;&quot;;
+	}
+
+	return @inherits;
+}
+
+
+=head2 newNamespace
+
+	Param: namespace name.
+	Returns nothing.
+
+	Imports a namespace into the current node, for ref searches etc.
+	Triggered by &quot;using namespace ...&quot;
+
+=cut
+
+sub newNamespace
+{
+	$cNode-&gt;AddPropList( &quot;ImpNames&quot;, shift );
+}
+
+
+
+=head2 newTypedef
+
+	Parameters: realtype, name
+
+	Handles a type definition.
+
+=cut
+
+sub newTypedef
+{
+	my ( $realtype, $name ) = @_;
+
+	my ( $node ) = Ast::New( $name );
+
+	$node-&gt;AddProp( &quot;NodeType&quot;, &quot;typedef&quot; );
+	$node-&gt;AddProp( &quot;Type&quot;, $realtype );
+
+	kdocAstUtil::attachChild( $cNode, $node );
+
+	return $node;
+}
+
+=head2 newTypedefComp
+
+	Params: realtype, name endtoken
+
+	Creates a new compound type definition.
+
+=cut
+
+sub newTypedefComp
+{
+	my ( $realtype, $name, $endtag ) = @_;
+
+	my ( $node ) = Ast::New( $name );
+
+	$node-&gt;AddProp( &quot;NodeType&quot;, &quot;typedef&quot; );
+	$node-&gt;AddProp( &quot;Type&quot;, $realtype );
+
+	kdocAstUtil::attachChild( $cNode, $node );
+
+	if ( $endtag eq '{' ) {
+		print &quot;newTypedefComp: Pushing $cNode-&gt;{astNodeName}\n&quot; 
+			if $debug;
+		push ( @classStack, $cNode );
+		$cNode = $node;
+	}
+
+	return $node;
+}
+
+
+=head2 newMethod
+
+	Parameters: retType, name, params, const, pure?, deprecated?
+
+	Handles a new method declaration or definition.
+
+=cut
+BEGIN {
+
+my $theSourceNode = $cSourceNode;
+
+sub newMethod
+{
+	my ( $retType, $name, $params, $const, $pure, $deprecated ) = @_;
+	my $parent = $cNode;
+	my $class;
+
+	print &quot;Cracked: [$retType] [$name]\n\t[$params]\n\t[$const]\n&quot; 
+		if $debug;
+
+	if ( $retType =~ /([\w\s_&lt;&gt;,]+)\s*::\s*$/ ) {
+		# check if stuff before :: got into rettype by mistake.
+		$retType = $`;
+		($name = $1.&quot;::&quot;.$name);
+		$name =~ s/\s+/ /g;
+		print &quot;New name = \&quot;$name\&quot; and type = '$retType'\n&quot; if $debug;
+	}
+
+	# A 'friend method' declaration isn't a real method declaration
+	return undef if ( $retType =~ /^friend\s+/ || $retType =~ /^friend\s+class\s+/ );
+
+	my $isGlobalSpace = 0;
+
+	if( $name =~ /^\s*(.*?)\s*::\s*(.*?)\s*$/ ) {
+		# Fully qualified method name.
+		$name = $2;
+		$class = $1;
+
+		if( $class =~ /^\s*$/ ) {
+			$parent = $rootNode;
+		}
+		elsif ( $class eq $cNode-&gt;{astNodeName} ) {
+			$parent = $cNode;
+		}
+		else {
+			# ALWAYS IGNORE...
+			return undef;
+			
+			my $node = kdocAstUtil::findRef( $cNode, $class );
+			
+			if ( !defined $node ) {
+				# if we couldn't find the name, try again with
+				# all template parameters stripped off:
+				my $strippedClass = $class;
+				$strippedClass =~ s/&lt;[^&lt;&gt;]*&gt;//g;
+
+				$node = kdocAstUtil::findRef( $cNode, $strippedClass );
+
+				# if still not found: give up
+				if ( !defined $node ) {
+						warn &quot;$exe: Unidentified class: $class &quot;.
+								&quot;in $currentfile\:$.\n&quot;;
+						return undef;
+				}
+			}
+
+			$parent = $node;
+		}
+	}
+	# TODO  fix for $retType =~ /template&lt;.*?&gt;/
+	elsif( $parse_global_space &amp;&amp; $parent-&gt;{NodeType} eq &quot;root&quot; &amp;&amp; $name !~ /\s*qt_/ &amp;&amp; $retType !~ /template\s*&lt;.*?&gt;/ ) {
+	    $class = $globalSpaceClassName; # FIXME - sanitize the naming system?
+	    $isGlobalSpace = 1;
+
+	    my $opsNode = kdocAstUtil::findRef( $cNode, $class );
+	    if (!$opsNode) {
+		# manually create a &quot;GlobalSpace&quot; class
+		$opsNode = Ast::New( $class );
+		$opsNode-&gt;AddProp( &quot;NodeType&quot;, &quot;class&quot; );
+		$opsNode-&gt;AddProp( &quot;Compound&quot;, 1 );
+		$opsNode-&gt;AddProp( &quot;Source&quot;, $cSourceNode ); # dummy
+		$opsNode-&gt;AddProp( &quot;KidAccess&quot;, &quot;public&quot; );
+		kdocAstUtil::attachChild( $cNode, $opsNode );
+	    }
+		# Add a special 'Source' property for methods in global space
+		$cNode-&gt;AddProp( &quot;Source&quot;, $theSourceNode ); 
+		
+            unless( $theSourceNode == $cSourceNode ) {
+                $theSourceNode = $cSourceNode;
+                $opsNode-&gt;AddPropList( &quot;Sources&quot;, $theSourceNode ); # sources are scattered across Qt
+            }
+	    $parent = $opsNode;
+	} 
+
+	# flags
+
+	my $flags = &quot;&quot;;
+
+	if( $retType =~ /static/ || $isGlobalSpace ) {
+		$flags .= &quot;s&quot;;
+		$retType =~ s/static//g;
+	}
+
+	if( $const &amp;&amp; !$isGlobalSpace ) {
+		$flags .= &quot;c&quot;;
+	}
+
+	if( $pure ) {
+		$flags .= &quot;p&quot;;
+	}
+
+	if( $retType =~ /virtual/ ) {
+		$flags .= &quot;v&quot;;
+		$retType =~ s/virtual//g;
+	}
+
+	if( $retType =~ /explicit\s*/ ) {
+		$flags .= &quot;t&quot;;
+		$retType =~ s/explicit\s*//g;
+	}
+
+	print &quot;\n&quot; if $flags ne &quot;&quot; &amp;&amp; $debug;
+
+	if ( !defined $parent-&gt;{KidAccess} ) {
+		warn &quot;'&quot;, $parent-&gt;{astNodeName}, &quot;' has no KidAccess &quot;,
+		exists $parent-&gt;{Forward} ? &quot;(forward)\n&quot; :&quot;\n&quot;;
+	}
+
+        # NB, these are =~, so make sure they are listed in correct order
+	if ( $parent-&gt;{KidAccess} =~ /slot/ ) {
+		$flags .= &quot;l&quot;;
+	}
+	elsif ( $parent-&gt;{KidAccess} =~ /k_dcop_signals/ ) {
+		$flags .= &quot;z&quot;;
+	}
+	elsif ( $parent-&gt;{KidAccess} =~ /k_dcop_hidden/ ) {
+		$flags .= &quot;y&quot;;
+	}
+	elsif ( $parent-&gt;{KidAccess} =~ /k_dcop/ ) {
+		$flags .= &quot;d&quot;;
+	}
+	elsif ( $parent-&gt;{KidAccess} =~ /signal/ ) {
+		$flags .= &quot;n&quot;;
+	}
+
+	$retType =~ s/QM?_EXPORT[_A-Z]*\s*//;
+	$retType =~ s/inline\s+//;
+	$retType =~ s/extern\s+//;
+	$retType =~ s/^\s*//g;
+	$retType =~ s/\s*$//g;
+	$retType =~ s/^class\s/ /;  # Remove redundant class forward decln's
+	$retType =~ s/&lt;class\s/&lt;/;
+
+	# node
+	
+	my $node = Ast::New( $name );
+	$node-&gt;AddProp( &quot;NodeType&quot;, &quot;method&quot; );
+	$node-&gt;AddProp( &quot;Flags&quot;, $flags );
+	$node-&gt;AddProp( &quot;ReturnType&quot;, $retType );
+	$node-&gt;AddProp( &quot;Params&quot;, $params ); # The raw string with the whole param list
+	makeParamList( $node, $params, 0 ); # Adds the ParamList property containing the list of param nodes
+	
+	$node-&gt;AddProp( &quot;Deprecated&quot;, $deprecated );
+
+	$parent-&gt;AddProp( &quot;Pure&quot;, 1 ) if $pure;
+
+	kdocAstUtil::attachChild( $parent, $node );
+
+	return $node;
+}
+
+}
+
+=head2 makeParamList
+
+	Parameters:
+	* method (or enum) node
+	* string containing the whole param list
+	* 1 for enums
+
+	Adds a property &quot;ParamList&quot; to the method node.
+	This property contains a list of nodes, one for each parameter.
+
+	Each parameter node has the following properties:
+	* ArgType the type of the argument, e.g. const QString&amp;
+	* ArgName the name of the argument - optionnal
+	* DefaultValue the default value of the argument - optionnal
+
+	For enum values, ArgType is unset, ArgName is the name, DefaultValue its value.
+
+	Author: David Faure &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">david at mandrakesoft.com</A>&gt;
+=cut
+
+sub makeParamList($$$)
+{
+	my ( $methodNode, $params, $isEnum ) = @_;
+	$params =~ s/\s+/ /g; # normalize multiple spaces/tabs into a single one
+	$params =~ s/\s*([\*\&amp;])\s*/$1 /g; # normalize spaces before and after *, &amp;
+	$params =~ s/\s*(,)([^'\s])\s*/$1 $2/g; # And after ',', but not if inside single quotes 
+	$params =~ s/^\s*void\s*$//; # foo(void) ==&gt; foo()
+	$params =~ s/^\s*$//;
+	# Make sure the property always exists, makes iteration over it easier
+        $methodNode-&gt;AddProp( &quot;ParamList&quot;, [] );
+
+	my @args = kdocUtil::splitUnnested( ',', $params);
+
+    	my $argId = 0;
+	foreach my $arg ( @args ) {
+		my $argType;
+		my $argName;
+		my $defaultparam;
+		$arg =~ s/\s*([^\s].*[^\s])\s*/$1/; # stripWhiteSpace
+		$arg =~ s/(\w+)\[\]/\* $1/; # Turn [] array into *
+		$arg =~ s/^class //; # Remove any redundant 'class' forward decln's
+
+		# The RE below reads as: = ( string constant or char or cast to numeric literal
+		# or some word/number, with optional bitwise shifts, OR'ed or +'ed flags, and/or function call ).
+		if ( $arg =~ s/\s*=\s*((&quot;[^\&quot;]*&quot;)|\([^)]*\)\s*[\+-]?\s*[0-9]+|(\'.\')|(([-\w:~]*)\s*([&lt;&gt;\|\+-]*\s*[\w:._]*\s*)*(\([^(]*\))?))// ) {
+			$defaultparam = $1;
+		}
+		
+		if (defined $defaultparam &amp;&amp; $isEnum) {
+			# Remove any casts in enum values, for example this in kfileitem.h:
+			#  'enum { Unknown = (mode_t) - 1 };'
+			$defaultparam =~ s/\([^\)]+\)(.*[0-9].*)/$1/;
+		}
+
+		# Separate arg type from arg name, if the latter is specified
+		if ( $arg =~ /(.*)\s+([\w_]+)\s*$/ || $arg =~ /(.*)\(\s*\*\s([\w_]+)\)\s*\((.*)\)\s*$/ ) {
+                    if ( defined $3 ) { # function pointer
+                        $argType = $1.&quot;(*)($3)&quot;;
+                        $argName = $2;
+                    } else {
+		        $argType = $1;
+		        $argName = $2;
+                    }
+		} else { # unnamed arg - or enum value
+		    $argType = $arg if (!$isEnum);
+		    $argName = $arg if ($isEnum);
+		}
+		$argId++;
+		
+		my $node = Ast::New( $argId ); # let's make the arg index the node &quot;name&quot;
+		$node-&gt;AddProp( &quot;NodeType&quot;, &quot;param&quot; );
+		$node-&gt;AddProp( &quot;ArgType&quot;, $argType );
+		$node-&gt;AddProp( &quot;ArgName&quot;, $argName ) if (defined $argName);
+		$node-&gt;AddProp( &quot;DefaultValue&quot;, $defaultparam ) if (defined $defaultparam);
+		$methodNode-&gt;AddPropList( &quot;ParamList&quot;, $node );
+		print STDERR &quot;ArgType: $argType ArgName: $argName\n&quot; if ($debug);
+	}
+}
+
+=head2 newAccess
+
+	Parameters: access
+
+	Sets the default &quot;Access&quot; specifier for the current class node. If
+	the access is a &quot;slot&quot; type, &quot;_slots&quot; is appended to the access
+	string.
+
+=cut
+
+sub newAccess
+{
+	my ( $access ) = @_;
+
+	return undef unless ($access =~ /^\s*(\w+)\s*(slots|$allowed_k_dcop_accesors_re)?/);
+
+	print &quot;Access: [$1] [$2]\n&quot; if $debug;
+
+	$access = $1;
+
+	if ( defined $2 &amp;&amp; $2 ne &quot;&quot; ) {
+		$access .= &quot;_&quot; . $2;
+	}
+
+	$cNode-&gt;AddProp( &quot;KidAccess&quot;, $access );
+
+	return $cNode;
+}
+
+
+=head2 newVar
+
+	Parameters: type, name, value
+
+	New variable. Value is ignored if undef
+
+=cut
+
+sub newVar
+{
+	my ( $type, $name, $val ) = @_;
+
+	my $node = Ast::New( $name );
+	$node-&gt;AddProp( &quot;NodeType&quot;, &quot;var&quot; );
+
+	my $static = 0;
+	if ( $type =~ /static/ ) {
+	#	$type =~ s/static//;
+		$static = 1;
+	}
+
+	$node-&gt;AddProp( &quot;Type&quot;, $type );
+	$node-&gt;AddProp( &quot;Flags&quot;, 's' ) if $static;
+	$node-&gt;AddProp( &quot;Value&quot;, $val ) if defined $val;
+	kdocAstUtil::attachChild( $cNode, $node );
+
+	return $node;
+}
+
+=head2 newProperty
+
+	Parameters: property
+
+	Handles a property
+
+=cut
+
+sub newProperty
+{
+	my ( $property ) = @_;
+
+    $property =~ s/^\s+|\s+$//g;  
+    my @items = split(/ /,$property);
+
+    do {
+	    my ( $node ) = Ast::New( $items[1] );
+
+	    $node-&gt;AddProp( &quot;NodeType&quot;, &quot;property&quot; );
+        $node-&gt;AddProp( &quot;type&quot;, $items[0] );
+        $node-&gt;AddProp( &quot;READ&quot;, $items[3] );
+        $node-&gt;AddProp( &quot;WRITE&quot;, $items[5] );
+        $node-&gt;AddProp( &quot;NOTIFY&quot;, $items[7] );
+
+        $cNode-&gt;{KidAccess} = &quot;public&quot;;
+	    kdocAstUtil::attachChild( $cNode, $node );
+        return $node;
+
+    } if defined $items[1];
+}
+
+
+=head2 show_usage
+
+	Display usage information and quit.
+
+=cut
+
+sub show_usage
+{
+print&lt;&lt;EOF;
+usage:
+	$exe [options] [-f format] [-d outdir] [-n name] files... [-llib..]
+
+See the man page kdoc[1] for more info.
+EOF
+	exit 1;
+}
+
+
+=head2 show_version
+
+	Display short version information and quit.
+
+=cut
+
+sub show_version
+{
+	die &quot;$exe: $Version (c) Sirtaj S. Kang &lt;taj\@kde.org&gt;\n&quot;;
+}
+
+

Added: trunk/kalyptus/kalyptus.spec.in
===================================================================
--- trunk/kalyptus/kalyptus.spec.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/kalyptus.spec.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,62 @@
+# You might want to change the next 2 lines, the rest should be ok
+%define qtdir /usr/lib/qt-3.0.0
+Prefix: /opt/kde3
+
+Name: kalyptus
+Icon: kde-icon.xpm
+Summary: Bindings generation tools for the K Desktop Environment (KDE) 3.0.
+Version: @VERSION@
+Release: 1
+Epoch: 1
+#Source: <A HREF="ftp://ftp.kde.org/pub/kde/stable/%{version">ftp://ftp.kde.org/pub/kde/stable/%{version</A>}/distribution/tar/generic/source/kdoc-%{version}.tar.bz2
+Group: Bindings
+BuildRoot: /var/tmp/%{name}-buildroot
+Copyright: GPL
+BuildArch: noarch
+
+%description
+Bindings generation tools for the K Desktop Environment 3.0.
+
+%prep
+rm -rf $RPM_BUILD_ROOT
+
+%setup -q -n %{name}
+make -f Makefile.cvs
+
+%build
+export KDEDIR=%{prefix} QTDIR=%{qtdir}
+CXXFLAGS=&quot;$RPM_OPT_FLAGS -I%{prefix}/include/kde&quot; ./configure \
+	--prefix=%{prefix}
+make CXXFLAGS=&quot;$RPM_OPT_FLAGS -DNO_DEBUG -DNDEBUG&quot;
+
+%install
+make install DESTDIR=$RPM_BUILD_ROOT
+
+cd $RPM_BUILD_ROOT
+find . -type d | sed '1,3d;s,^\.,\%attr(-\,root\,root) \%dir ,' &gt; \
+	$RPM_BUILD_DIR/file.list.%{name}
+perl -pi -e &quot;s|\%attr\(-,root,root\) \%dir %{prefix}/man/man1||&quot; $RPM_BUILD_DIR/file.list.%{name}
+perl -pi -e &quot;s|\%attr\(-,root,root\) \%dir %{prefix}/man||&quot; $RPM_BUILD_DIR/file.list.%{name}
+perl -pi -e &quot;s|\%attr\(-,root,root\) \%dir %{prefix}/bin||&quot; $RPM_BUILD_DIR/file.list.%{name}
+perl -pi -e &quot;s|\%attr\(-,root,root\) \%dir %{prefix}/lib$||&quot; $RPM_BUILD_DIR/file.list.%{name}
+
+find . -type f | sed -e 's,^\.,\%attr(-\,root\,root) ,' \
+	-e '/\/config\//s|^|%config|' &gt;&gt; \
+	$RPM_BUILD_DIR/file.list.%{name}
+
+find . -type l | sed 's,^\.,\%attr(-\,root\,root) ,' &gt;&gt; \
+	$RPM_BUILD_DIR/file.list.%{name}
+
+sed -e &quot;s,%{prefix}/man/.*,&amp;*,g&quot; $RPM_BUILD_DIR/file.list.%{name} &gt;$RPM_BUILD_DIR/file.list.%{name}.new
+mv -f $RPM_BUILD_DIR/file.list.%{name}.new $RPM_BUILD_DIR/file.list.%{name}
+
+echo &quot;%docdir %{prefix}/doc/kde&quot; &gt;&gt; $RPM_BUILD_DIR/file.list.%{name}
+
+%clean
+rm -rf $RPM_BUILD_ROOT $RPM_BUILD_DIR/file.list.%{name}
+
+%files -f ../file.list.%{name}
+
+%changelog
+* Thu May 11 2000 Bernhard Rosenkraenzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">bero at redhat.com</A>&gt;
+- initial

Added: trunk/kalyptus/kalyptusCxxToSmoke.pm
===================================================================
--- trunk/kalyptus/kalyptusCxxToSmoke.pm	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/kalyptusCxxToSmoke.pm	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,2794 @@
+#***************************************************************************
+#            kalyptusCxxToSmoke.pm -  Generates x_*.cpp files for smoke
+#                             -------------------
+#    begin                : Fri Jan 25 12:00:00 2000
+#    copyright            : (C) 2002 Lost Highway Ltd. All Rights Reserved.
+#    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">david at mandrakesoft.com</A>
+#    author               : David Faure.
+#***************************************************************************/
+
+#/***************************************************************************
+# *                                                                         *
+# *   This program is free software; you can redistribute it and/or modify  *
+# *   it under the terms of the GNU General Public License as published by  *
+# *   the Free Software Foundation; either version 2 of the License, or     *
+# *   (at your option) any later version.                                   *
+# *                                                                         *
+#***************************************************************************/
+
+package kalyptusCxxToSmoke;
+
+use File::Path;
+use File::Basename;
+use constant numSourceFiles =&gt; 20; # Total number of generated source files.
+                                   # All classes will be distributed across those.
+
+use Carp;
+use Ast;
+use kdocAstUtil;
+use kdocUtil;
+use Iter;
+use kalyptusDataDict;
+
+use strict;
+no strict &quot;subs&quot;;
+
+use vars qw/
+	$libname $rootnode $outputdir $opt $debug
+	$methodNumber $headerSubdirectories
+	%builtins %typeunion %allMethods %allTypes %enumValueToType %typedeflist %mungedTypeMap
+	%skippedClasses /;
+
+BEGIN
+{
+
+# Types supported by the StackItem union
+# Key: C++ type  Value: Union field of that type
+%typeunion = (
+    'void*' =&gt; 's_voidp',
+    'bool' =&gt; 's_bool',
+    'char' =&gt; 's_char',
+    'uchar' =&gt; 's_uchar',
+    'short' =&gt; 's_short',
+    'ushort' =&gt; 's_ushort',
+    'int' =&gt; 's_int',
+    'uint' =&gt; 's_uint',
+    'long' =&gt; 's_long',
+    'ulong' =&gt; 's_ulong',
+    'float' =&gt; 's_float',
+    'double' =&gt; 's_double',
+    'enum' =&gt; 's_enum',
+    'class' =&gt; 's_class'
+);
+
+# Mapping for iterproto, when making up the munged method names
+%mungedTypeMap = (
+     'QString' =&gt; '$',
+     'QString*' =&gt; '$',
+     'QString&amp;' =&gt; '$',
+     'QCString' =&gt; '$',
+     'QCString*' =&gt; '$',
+     'QCString&amp;' =&gt; '$',
+     'char*' =&gt; '$',
+     'QCOORD*' =&gt; '?',
+     'QRgb*' =&gt; '?',
+     'Q_UINT64' =&gt; '$',
+     'Q_INT64' =&gt; '$',
+     'Q_LLONG' =&gt; '$',
+     'quint64' =&gt; '$',
+     'qint64' =&gt; '$',
+     'long long' =&gt; '$',
+     'qulonglong' =&gt; '$',
+     'WId' =&gt; '$',
+     'Q_PID' =&gt; '$',
+);
+
+# Yes some of this is in kalyptusDataDict's ctypemap
+# but that one would need to be separated (builtins vs normal classes)
+%typedeflist =
+(
+   'signed char' =&gt; 'char',
+   'unsigned char' =&gt; 'uchar',
+   'signed short' =&gt; 'short',
+   'unsigned short' =&gt; 'ushort',
+   'signed' =&gt; 'int',
+   'signed int' =&gt; 'int',
+   'unsigned' =&gt; 'uint',
+   'unsigned int' =&gt; 'uint',
+   'signed long' =&gt; 'long',
+   'unsigned long' =&gt; 'ulong',
+
+# Anything that is not known is mapped to void*, so no need for those here anymore
+#   'QWSEvent*'  =&gt;  'void*',
+#   'QDiskFont*'  =&gt;  'void*',
+#   'XEvent*'  =&gt;  'void*',
+#   'QStyleHintReturn*'  =&gt;  'void*',
+#   'FILE*'  =&gt;  'void*',
+#   'QUnknownInterface*'  =&gt;  'void*',
+#   'GDHandle'  =&gt;  'void*',
+#   '_NPStream*'  =&gt;  'void*',
+#   'QTextFormat*'  =&gt;  'void*',
+#   'QTextDocument*'  =&gt;  'void*',
+#   'QTextCursor*'  =&gt;  'void*',
+#   'QTextParag**'  =&gt;  'void*',
+#   'QTextParag*'  =&gt;  'void*',
+#   'QRemoteInterface*'  =&gt;  'void*',
+#   'QSqlRecordPrivate*'  =&gt;  'void*',
+#   'QTSMFI'  =&gt;  'void*', # QTextStream's QTSManip
+#   'const GUID&amp;'  =&gt;  'void*',
+#   'QWidgetMapper*'  =&gt;  'void*',
+   'MSG*'  =&gt;  'void*',
+#   'const QSqlFieldInfoList&amp;'  =&gt;  'void*', # QSqlRecordInfo - TODO (templates)
+
+   'QPtrCollection::Item'  =&gt;  'void*', # to avoid a warning
+
+   'void(* )()'  =&gt;  'void*',
+   'void (*)(void* )'  =&gt;  'void*',
+   'mode_t'  =&gt;  'long',
+   'QProcess::PID'  =&gt;  'long',
+   'size_type'  =&gt;  'int', # QSqlRecordInfo
+   'Qt::ComparisonFlags'  =&gt;  'uint',
+   'Qt::ToolBarDock'  =&gt;  'int', # compat thing, Qt shouldn't use it
+   'QIODevice::Offset'  =&gt;  'ulong',
+   'WState'  =&gt;  'int',
+   'QRgb'  =&gt;  'uint',
+   'ksocklen_t' =&gt; 'uint',
+   'QCOORD'  =&gt;  'int',
+   'QTSMFI'  =&gt;  'int',
+   'Qt::WState'  =&gt;  'int',
+   'Qt::WFlags'  =&gt;  'int',
+   'Qt::HANDLE' =&gt; 'uint',
+   'QEventLoop::ProcessEventsFlags' =&gt; 'uint',
+   'QStyle::SCFlags' =&gt; 'int',
+   'QStyle::SFlags' =&gt; 'int',
+   'Q_INT16' =&gt; 'short',
+   'qint16' =&gt; 'short',
+   'Q_INT32' =&gt; 'int',
+   'qint32' =&gt; 'int',
+   'qint32&amp;' =&gt; 'int&amp;',
+   'Q_INT8' =&gt; 'char',
+   'qint8' =&gt; 'char',
+   'Q_LONG' =&gt; 'long',
+   'Q_UINT16' =&gt; 'ushort',
+   'quint16' =&gt; 'ushort',
+   'Q_UINT32' =&gt; 'uint',
+   'quint32' =&gt; 'uint',
+   'Q_UINT8' =&gt; 'uchar',
+   'quint8' =&gt; 'uchar',
+   'Q_ULONG' =&gt; 'long',
+   'qreal' =&gt; 'double',
+   'pid_t' =&gt; 'int',
+   'size_t' =&gt; 'int',
+   'pid_t' =&gt; 'int',
+   'time_t' =&gt; 'int',
+   'short int' =&gt; 'short',
+   'signed long int' =&gt; 'long',
+   'unsigned long int' =&gt; 'ulong',
+   'unsigned short int' =&gt; 'ushort',
+   'Qt::Alignment' =&gt; 'int',
+   'Qt::Orientations' =&gt; 'int',
+   'Qt::DockWidgetAreas' =&gt; 'int',
+   'Qt::DropActions' =&gt; 'int',
+   'Qt::ImageConversionFlags' =&gt; 'int',
+   'Qt::ItemFlags' =&gt; 'int',
+   'Qt::KeyboardModifiers' =&gt; 'int',
+   'Qt::MatchFlags' =&gt; 'int',
+   'Qt::MouseButtons' =&gt; 'int',
+   'Qt::ToolBarAreas' =&gt; 'int',
+   'Qt::WindowFlags' =&gt; 'int',
+   'Qt::WindowStates' =&gt; 'int',
+   'AutoFormatting' =&gt; 'int',
+   'DirtyFlags' =&gt; 'int',
+   'EditTriggers' =&gt; 'int',
+   'FindFlags' =&gt; 'int',
+   'Flags' =&gt; 'int',
+   'FormattingOptions' =&gt; 'int',
+   'GLenum' =&gt; 'int',
+   'GLint' =&gt; 'int',
+   'GLuint' =&gt; 'uint',
+   'LoadOperator' =&gt; 'int',
+   'NumberFlags' =&gt; 'int',
+   'OpenMode' =&gt; 'int',
+   'Options' =&gt; 'int',
+   'PaintEngineFeatures' =&gt; 'int',
+   'Permissions' =&gt; 'int',
+   'PrintDialogOptions' =&gt; 'int',
+   'ProcessEventsFlags' =&gt; 'int',
+   'QDir::Filters' =&gt; 'int',
+   'QDir::SortFlags' =&gt; 'int',
+   'QFile::Permissions' =&gt; 'int',
+   'QGL::FormatOptions' =&gt; 'int',
+   'QIODevice::OpenMode' =&gt; 'int',
+   'QImageReader::ImageReaderError' =&gt; 'int',
+   'QItemSelectionModel::SelectionFlags' =&gt; 'int',
+   'QPaintEngine::DirtyFlags' =&gt; 'int',
+   'QPainter::RenderHints' =&gt; 'int',
+   'QSql::ParamType' =&gt; 'int',
+   'QTextDocument::FindFlags' =&gt; 'int',
+   'Qt::DropActions' =&gt; 'int',
+   'Qt::ImageConversionFlags' =&gt; 'int',
+   'Qt::ItemFlags' =&gt; 'int',
+   'Qt::KeyboardModifiers' =&gt; 'int',
+   'Qt::MatchFlags' =&gt; 'int',
+   'Qt::MouseButtons' =&gt; 'int',
+   'Qt::ToolBarAreas' =&gt; 'int',
+   'Qt::WindowFlags' =&gt; 'int',
+   'Qt::WindowStates' =&gt; 'int',
+   'RenderFlags' =&gt; 'int',
+   'RenderHints' =&gt; 'int',
+   'SortFlags' =&gt; 'int',
+   'StepEnabled' =&gt; 'int',
+   'Sections' =&gt; 'int',
+   'Filters' =&gt; 'int',
+   'SortFlags' =&gt; 'int',
+   'QDir::Filters' =&gt; 'int',
+   'QDir::SortFlags' =&gt; 'int',
+   'QStyle::State' =&gt; 'int',
+   'QValidator::State' =&gt; 'int',
+   'QAbstractSpinBox::StepEnabled' =&gt; 'int',
+   'QDockWidget::DockWidgetFeatures' =&gt; 'int',
+   'QStyle::SubControls' =&gt; 'int',
+   'RegisterOptions' =&gt; 'int',
+);
+
+$headerSubdirectories = &quot;kio/|kdevelop/|kinterfacedesigner/|kontact/|kate/|kparts/|dom/|kabc/|ksettings/|kjs/|ktexteditor/|kdeprint/|kdesu/|knewstuff|dbus-1.0/dbus/&quot;
+
+}
+
+sub writeDoc
+{
+	( $libname, $rootnode, $outputdir, $opt ) = @_;
+
+	print STDERR &quot;Starting writeDoc for $libname...\n&quot;;
+
+	$debug = $main::debuggen;
+
+	mkpath( $outputdir ) unless -f $outputdir;
+
+	# Define QPtrCollection::Item, for resolveType
+	unless ( kdocAstUtil::findRef( $rootnode, &quot;QPtrCollection::Item&quot; ) || $main::qt4 ) {
+		my $cNode = kdocAstUtil::findRef( $rootnode, &quot;QPtrCollection&quot; );
+		warn &quot;QPtrCollection not found&quot; if (!$cNode);
+		my $node = Ast::New( 'Item' );
+		$node-&gt;AddProp( &quot;NodeType&quot;, &quot;Forward&quot; );
+		$node-&gt;AddProp( &quot;Source&quot;, $cNode-&gt;{Source} ) if ($cNode);
+		kdocAstUtil::attachChild( $cNode, $node ) if ($cNode);
+		$node-&gt;AddProp( &quot;Access&quot;, &quot;public&quot; );
+	}
+	
+	print STDERR &quot;Preparsing...\n&quot;;
+
+	# Preparse everything, to prepare some additional data in the classes and methods
+	Iter::LocalCompounds( $rootnode, sub { preParseClass( shift ); } );
+
+	# Have a look at each class again, to propagate CanBeCopied
+	Iter::LocalCompounds( $rootnode, sub { propagateCanBeCopied( shift ); } );
+
+	print STDERR &quot;Writing smokedata.cpp...\n&quot;;
+
+	# Write out smokedata.cpp
+	writeSmokeDataFile($rootnode);
+
+	print STDERR &quot;Writing x_*.cpp...\n&quot;;
+
+	# Generate x_*cpp file for each class
+
+        my $numclasses;
+        Iter::LocalCompounds( $rootnode, sub { $numclasses++ } );
+        my $classperfile = int($numclasses/numSourceFiles);
+        print STDERR &quot;Total number of classes: &quot;. $numclasses .&quot;\n&quot; if $debug;
+        my $nodelist = [];
+        my $currentfile = 1;
+        my $currentclass = 1;
+        Iter::LocalCompounds( $rootnode, sub { 
+                   push @$nodelist, shift;
+                   if(@$nodelist == $classperfile and $currentfile != numSourceFiles)
+                   {
+                       print STDERR &quot;Calling writeClassDoc for &quot;. (scalar @$nodelist) . &quot; classes\n&quot; if $debug;
+                       writeClassDoc( $nodelist );
+                       $currentfile++;
+                       $nodelist = []     
+                   }
+                   if(@$nodelist and $currentclass == $numclasses)
+                   {    
+                       print STDERR &quot;Calling writeClassDoc for remaining &quot;. (scalar @$nodelist) . &quot; classes\n&quot; if $debug;
+                       writeClassDoc( $nodelist )
+                   }
+                   $currentclass++
+        });
+
+	print STDERR &quot;Done.\n&quot;;
+}
+
+=head2 preParseClass
+	Called for each class
+=cut
+sub preParseClass
+{
+	my( $classNode ) = @_;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+
+	if( $#{$classNode-&gt;{Kids}} &lt; 0 ||
+	    $classNode-&gt;{Access} eq &quot;private&quot; ||
+	    $classNode-&gt;{Access} eq &quot;protected&quot; || # e.g. QPixmap::QPixmapData
+	    exists $classNode-&gt;{Tmpl} ||
+	    # Don't generate standard bindings for QString, this class is handled as a native type
+	    $className eq 'QString' ||
+	    $className eq 'QStringData' ||
+	    $className eq 'QLatin1String' ||
+	    $className eq 'QTLWExtra' ||
+	    $className eq 'QWExtra' ||
+	    $className eq 'QBig5Codec' ||
+	    $className eq 'QBig5hkscsCodec' ||
+	    $className eq 'QPtrCollection' ||
+	    $className eq 'QGCache' ||
+	    $className eq 'QConstString' ||
+	    $className eq 'QCString' ||
+	    # Don't map classes which are really arrays
+	    $className eq 'QStringList' ||
+            $className eq 'QCanvasItemList' ||
+            $className eq 'QWidgetList' ||
+            $className eq 'QObjectList' ||
+	    $className eq 'QStrList' ||
+	    $className eq 'KCmdLineOptions' ||
+	    # Those are template related
+            $className eq 'QTSManip' || # cause compiler errors with several gcc versions
+	    $className eq 'QGDict' ||
+	    $className eq 'QGList' ||
+	    $className eq 'QGArray' ||
+	    $className eq 'QGVector' ||
+	    $className eq 'QStrIList' ||
+	    $className eq 'QStrIVec' ||
+	    $className eq 'QBitArray' ||
+	    $className eq 'QMapData' ||
+	    $className eq 'QMetaEnum::Item' ||
+	    $className eq 'QWidgetContainerPlugin' ||
+	    $className eq 'QGArray::array_data' ||
+	    ($className eq 'QMenuItem' and $main::qt_embedded) ||
+	    ($className eq 'QSignal' and $main::qt_embedded) ||
+	    ($className eq 'QWSEvent' and $main::qt_embedded) ||
+	    ($className eq 'QMetaObjectInit' and $main::qt_embedded) ||
+	    ($className eq 'QKoi8Codec' and $main::qt_embedded) ||
+	    $className eq 'KAccelGen' ||
+	    ($className eq 'QAbstractUndoItem' and $main::qt4) ||
+	    ($className eq 'QDebug' and $main::qt4) ||
+	    ($className eq 'QNoDebug' and $main::qt4) ||
+	    ($className eq 'QObjectData' and $main::qt4) ||
+	    ($className eq 'QSysInfo' and $main::qt4) ||
+	    ($className eq 'QPNGImageWriter' and $main::qt4) ||
+	    ($className eq 'QPNGImagePacker' and $main::qt4) ||
+	    ($className eq 'QTextCodec::ConverterState' and $main::qt4) ||
+	    ($className eq 'QTextLayout::Selection' and $main::qt4) ||
+	    ($className eq 'QTextStreamManipulator' and $main::qt4) ||
+	    $className eq 'DCOPArg' ||
+	    $className eq 'DCOPReply' ||
+	    $className eq 'KBookmarkMenu::DynMenuInfo' ||
+	    $className eq 'KDE' ||
+	    $className eq 'KDEDesktopMimeType::Service' ||
+	    $className eq 'KEntry' ||
+	    $className eq 'KEntryKey' ||
+	    $className eq 'KGlobalSettings::KMouseSettings' ||
+	    $className eq 'KMimeType::Format' ||
+	    $className eq 'KNotifyClient::Instance' ||
+	    $className eq 'KParts::ComponentFactory' ||
+	    $className eq 'KParts::Plugin::PluginInfo' ||
+	    $className eq 'KProtocolInfo::ExtraField' ||
+	    $className eq 'KXMLGUIClient::StateChange' ||
+	    $className eq 'KIconTheme' ||
+	    $className eq 'KEditListBox::CustomEditor' ||
+		$className eq 'KIO::KBookmarkMenuNSImporter' ||
+	    $className eq 'KExtendedSocket' ||
+	    $className eq 'KSocket' ||
+	    $className eq 'KPerDomainSettings' ||
+	    $className eq 'KApplicationPropsPlugin' ||
+	    $className eq 'KOpenWithHandler' ||
+	    $className eq 'KFileOpenWithHandler' ||
+	    $className eq 'KBindingPropsPlugin' ||
+	    $className eq 'KPropsDlgPlugin' ||
+	    $className eq 'KFileSharePropsPlugin' ||
+	    $className eq 'KBookmarkMenuNSImporter' ||
+	    $className eq 'KDevicePropsPlugin' ||
+	    $className eq 'KDEDModule' ||
+	    $className eq 'KFileMetaInfoProvider' ||
+	    $className eq 'KFileMimeTypeInfo' ||
+	    $className eq 'KExecPropsPlugin' ||
+	    $className eq 'KFilePermissionsPropsPlugin' ||
+	    $className eq 'KImageFilePreview' ||
+	    $className eq 'KBookmarkManager' ||
+	    $className eq 'KBookmarkNotifier' ||
+	    $className eq 'KOCRDialogFactory' ||
+	    $className eq 'KExtendedBookmarkOwner' ||
+	    $className eq 'KSharedPixmap' ||
+	    $className eq 'KLibrary' ||
+	    $className eq 'KScanDialogFactory' ||
+	    $className eq 'KBufferedIO' ||
+	    $className eq 'KDictSpellingHighlighter' ||
+		$className eq 'KPropertiesDialog' ||
+	    $className eq 'ProgressItem' ||
+	    $className eq 'KIO::ChmodInfo' ||
+	    $className eq 'khtml::DrawContentsEvent' || # the khtml:: classes build, but don't link
+	    $className eq 'khtml::MouseDoubleClickEvent' ||
+	    $className eq 'khtml::MouseMoveEvent' ||
+	    $className eq 'khtml::MousePressEvent' ||
+	    $className eq 'khtml::MouseReleaseEvent' ||
+	    $className eq 'khtml::MouseEvent' ||
+	    $className eq 'khtml' ||
+	    $className eq 'KURL::List' ||
+	    $className eq 'KWin::Info' ||
+	    $className eq 'TerminalInterface' ||
+	    $className eq 'QForeachContainerBase' || # Qt4
+	    $className eq 'QInputMethodEvent::Attribute' || # Qt4
+	    $className eq 'QAbstractTextDocumentLayout::PaintContext' || # Qt4
+	    $className eq 'QAbstractTextDocumentLayout::Selection' || # Qt4
+	    $className eq 'QBrushData' || # Qt4
+	    $className eq 'QIPv6Address' || # Qt4
+	    $className eq 'QImageTextKeyLang' || # Qt4
+	    $className eq 'QMap' || # Qt4
+	    $className eq 'QMap::const_iterator' || # Qt4
+	    $className eq 'QMap::iterator' || # Qt4
+	    $className eq 'QMapData' || # Qt4
+	    $className eq 'QMapData::Node' || # Qt4
+	    $className eq 'QProxyModel' || # Obsolete Qt4
+	    $className eq 'QSharedData' || # Qt4
+	    $className eq 'QPainterPath::Element' || # Qt4
+	    $className eq 'QThreadStorageData' || # Qt4
+	    $className eq 'QVFbHeader' || # Qt4
+	    $className eq 'QStyleOptionQ3DockWindow' || # Qt4
+	    $className eq 'QStyleOptionQ3ListView' || # Qt4
+	    $className eq 'QStyleOptionQ3ListViewItem' || # Qt4
+	    $className eq 'QStyleOptionQ3ListView' || # Qt4
+	    $className eq 'QUpdateLaterEvent' || # Qt4
+	    $className eq 'QVFbKeyData' || # Qt4
+	    $className eq 'QVariant::Handler' || # Qt4
+	    $className eq 'QVariant::PrivateShared' || # Qt4
+	    $className eq 'QVectorData' || # Qt4
+	    $className eq 'QWidgetData' || # Qt4
+	    $className eq 'QThread' || # Qt4
+		$className eq 'QThreadStorage' || # Qt4
+		$className eq 'QMutex' || # Qt4
+		$className eq 'QMutexLocker' || # Qt4
+		$className eq 'QSemaphore' || # Qt4
+		$className eq 'QWaitCondition' || # Qt4
+		$className eq 'QReadWriteLock' || # Qt4
+		$className eq 'QReadLocker' || # Qt4
+		$className eq 'QX11Info' || # Qt4
+		$className eq 'QWriteLocker' || 
+	    $className =~ /.*Private$/ || # Ignore any classes which aren't for public consumption
+	    $className =~ /.*Impl$/ ||
+	    $className =~ /.*Internal.*/ ||
+	    $classNode-&gt;{Deprecated} ||
+	    $classNode-&gt;{NodeType} eq 'union'  # Skip unions for now, e.g. QPDevCmdParam
+	  ) {
+	    print STDERR &quot;Skipping $className\n&quot; if ($debug);
+	    print STDERR &quot;Skipping union $className\n&quot; if ( $classNode-&gt;{NodeType} eq 'union');
+	    $skippedClasses{$className} = 1;
+	    delete $classNode-&gt;{Compound}; # Cheat, to get it excluded from Iter::LocalCompounds
+	    return;
+	}
+	
+	my $signalCount = 0;
+	my $eventHandlerCount = 0;
+	my $defaultConstructor = 'none'; #  none, public, protected or private. 'none' will become 'public'.
+	my $constructorCount = 0; # total count of _all_ ctors
+	# If there are ctors, we need at least one public/protected one to instanciate the class
+	my $hasPublicProtectedConstructor = 0;
+	# We need a public dtor to destroy the object --- ### aren't protected dtors ok too ??
+	my $hasPublicDestructor = 1; # by default all classes have a public dtor!
+	#my $hasVirtualDestructor = 0;
+	my $hasDestructor = 0;
+	my $hasPrivatePureVirtual = 0;
+	my $hasCopyConstructor = 0;
+	my $hasPrivateCopyConstructor = 0;
+	# Note: no need for hasPureVirtuals. $classNode{Pure} has that.
+	
+	# Hack to fix up KLed constructors in KDE 3.1
+	my $kledAmbiguousConstructor = undef;
+
+        my $doPrivate = $main::doPrivate;
+	$main::doPrivate = 1;
+	# Look at each class member (looking for methods and enums in particular)
+	Iter::MembersByType ( $classNode, undef,
+		sub {
+
+	my( $classNode, $m ) = @_;
+	my $name = $m-&gt;{astNodeName};
+
+	if( $m-&gt;{NodeType} eq &quot;method&quot; ) {
+	    if ( $m-&gt;{ReturnType} eq 'typedef' # QFile's EncoderFn/DecoderFn callback, very badly parsed
+	       ) {
+		$m-&gt;{NodeType} = 'deleted';
+		next;
+	    }
+
+	    print STDERR &quot;preParseClass: looking at $className\::$name  $m-&gt;{Params}\n&quot; if ($debug);
+	    
+		if ( $name eq $classNode-&gt;{astNodeName} ) {
+		if ( $m-&gt;{ReturnType} =~ /~/  ) {
+		    # A destructor
+		    $hasPublicDestructor = 0 if $m-&gt;{Access} ne 'public';
+		    #$hasVirtualDestructor = 1 if ( $m-&gt;{Flags} =~ &quot;v&quot; &amp;&amp; $m-&gt;{Access} ne 'private' );
+		    $hasDestructor = 1;
+		} else {
+		    # A constructor
+		    $constructorCount++;
+		    $defaultConstructor = $m-&gt;{Access} if ( $m-&gt;{Params} eq '' );
+		    $hasPublicProtectedConstructor = 1 if ( $m-&gt;{Access} ne 'private' );
+
+		    # Copy constructor?
+		    if ( $#{$m-&gt;{ParamList}} == 0 ) {
+			my $theArgType = @{$m-&gt;{ParamList}}[0]-&gt;{ArgType};
+                        (my $classNameWithoutNS = $className) =~ s/^.*:://;
+			if ($theArgType =~ /$classNameWithoutNS\s*\&amp;/) {
+			    $hasCopyConstructor = 1;
+				$m-&gt;{Flags} .= &quot;x&quot;;
+			    $hasPrivateCopyConstructor = 1 if ( $m-&gt;{Access} eq 'private' );
+			}
+		    }
+		    # Hack the return type for constructors, since constructors return an object pointer
+		    $m-&gt;{ReturnType} = $className.&quot;*&quot;;
+		}
+	    }
+
+	    if ( $name =~ /~$classNode-&gt;{astNodeName}/ &amp;&amp; $m-&gt;{Access} ne &quot;private&quot; ) { # not used
+		$hasPublicDestructor = 0 if $m-&gt;{Access} ne 'public';
+		#$hasVirtualDestructor = 1 if ( $m-&gt;{Flags} =~ &quot;v&quot; );
+		$hasDestructor = 1;
+	    }
+
+	    if ( $m-&gt;{Flags} =~ &quot;p&quot; &amp;&amp; $m-&gt;{Access} =~ /private/ ) {
+                $hasPrivatePureVirtual = 1; # ouch, can't inherit from that one
+	    }
+
+	    # All we want from private methods is to check for virtuals, nothing else
+	    next if ( $m-&gt;{Access} =~ /private/ );
+		
+		# Don't generate code for deprecated methods, 
+		# or where the code won't compile/link for obscure reasons. Or even obvious reasons..
+		if ( ($classNode-&gt;{astNodeName} eq 'KCharSelectTable' and $name eq 'paintCell')
+			|| ($classNode-&gt;{astNodeName} eq 'KAnimWidget' and $name eq 'KAnimWidget' and @{$m-&gt;{ParamList}} == 2)
+			|| ($classNode-&gt;{astNodeName} eq 'KCModuleLoader' and $name eq 'errorModule')
+			|| ($classNode-&gt;{astNodeName} eq 'KDCOPActionProxy' and $name eq 'actions')
+			|| ($classNode-&gt;{astNodeName} eq 'KEditToolbarWidget' and $name eq 'insertActive')
+			|| ($classNode-&gt;{astNodeName} eq 'KEditToolbarWidget' and $name eq 'removeActive')
+			|| ($classNode-&gt;{astNodeName} eq 'KEditToolbarWidget' and $name eq 'moveActive')
+			|| ($classNode-&gt;{astNodeName} eq 'KFileDialog' and $name eq 'addDirEntry')
+			|| ($classNode-&gt;{astNodeName} eq 'KFileDialog' and $name eq 'getDirEntry')
+			|| ($classNode-&gt;{astNodeName} eq 'KFileItem' and $name eq 'extraData')
+			|| ($classNode-&gt;{astNodeName} eq 'KFileView' and $name eq 'selectionMode')
+			|| ($classNode-&gt;{astNodeName} eq 'KFind' and $name eq 'KFind' and @{$m-&gt;{ParamList}} == 4)
+			|| ($classNode-&gt;{astNodeName} eq 'KGlobalAccel' and $name eq 'setEnabled')
+			|| ($classNode-&gt;{astNodeName} eq 'KCharsets' and $name eq 'encodingsForLanguage')
+			|| ($classNode-&gt;{astNodeName} eq 'KInputDialog' and $name eq 'getInteger')
+			|| ($classNode-&gt;{astNodeName} eq 'SlaveBase' and $name eq 'checkCachedAuthentication')
+			|| ($classNode-&gt;{astNodeName} eq 'SlaveBase' and $name eq 'cacheAuthentication')
+			|| ($classNode-&gt;{astNodeName} eq 'KInputDialog' and $name eq 'getDouble')
+			|| ($classNode-&gt;{astNodeName} eq 'KToolBar' and $name eq 'enable')
+			|| ($classNode-&gt;{astNodeName} eq 'KAccel' and $name eq 'insert' and @{$m-&gt;{ParamList}} == 2)
+			|| ($classNode-&gt;{astNodeName} eq 'KAccel' and $name eq 'autoupdate')
+			|| ($classNode-&gt;{astNodeName} eq 'KAccel' and $name eq 'getAutoUpdate')
+			|| ($classNode-&gt;{astNodeName} eq 'KStdAccel' and $name eq 'insert')
+			|| ($classNode-&gt;{astNodeName} eq 'KBookmarkMenu' and $name eq 'invalid')
+			|| ($classNode-&gt;{astNodeName} eq 'KCharsets' and $name eq 'languages')
+			|| ($classNode-&gt;{astNodeName} eq 'KCombiView' and $name eq 'setDropOptions')
+			|| ($classNode-&gt;{astNodeName} eq 'KFileMetaInfoItem' and $name eq 'unit')
+			|| ($classNode-&gt;{astNodeName} eq 'KInstance' and $name eq 'charsets')
+			|| ($classNode-&gt;{astNodeName} eq 'KInstance' and $name eq 'KInstance' and $m-&gt;{Access} =~ /protected/)
+			|| ($classNode-&gt;{astNodeName} eq 'KKey' and $name eq 'isValidQt')
+			|| ($classNode-&gt;{astNodeName} eq 'KKey' and $name eq 'isValidNative')
+			|| ($classNode-&gt;{astNodeName} eq 'KKeySequence' and $name eq 'init')
+			|| ($classNode-&gt;{astNodeName} eq 'KKeySequence' and $name eq 'setTriggerOnRelease')
+			|| ($classNode-&gt;{astNodeName} eq 'KEMailSettings' and $name eq 'getExtendedSetting')
+			|| ($classNode-&gt;{astNodeName} eq 'KEMailSettings' and $name eq 'setExtendedSetting')
+			|| ($classNode-&gt;{astNodeName} eq 'KProtocolManager' and $name eq 'defaultConnectTimeout')
+			|| ($classNode-&gt;{astNodeName} eq 'KMD4' and $name eq 'transform')
+			|| ($classNode-&gt;{astNodeName} eq 'KMD5' and $name eq 'transform')
+			|| ($classNode-&gt;{astNodeName} eq 'KSSLCertificate' and $name eq 'operator!=')
+			|| ($classNode-&gt;{astNodeName} eq 'KSSLPKCS7' and $name eq 'validate')
+			|| ($classNode-&gt;{astNodeName} eq 'KSSLPKCS7' and $name eq 'revalidate')
+			|| ($classNode-&gt;{astNodeName} eq 'KSSLSession' and $name eq 'KSSLSession' and @{$m-&gt;{ParamList}} == 1)
+			|| ($classNode-&gt;{astNodeName} eq 'KSimpleFileFilter' and $name eq 'nameFilters')
+			|| ($classNode-&gt;{astNodeName} eq 'KTabWidget' and $name eq 'isTabReorderingEnabled')
+			|| ($classNode-&gt;{astNodeName} eq 'KTabWidget' and $name eq 'hoverCloseButton')
+			|| ($classNode-&gt;{astNodeName} eq 'KTabWidget' and $name eq 'hoverCloseButtonDelayed')
+			|| ($classNode-&gt;{astNodeName} eq 'KTar' and $name eq 'writeFile_impl')
+			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'buildHTMLErrorString')
+			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'pasteClipboard')
+			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'pasteData')
+			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'pasteDataAsync')
+			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'isClipboardEmpty')
+			|| ($classNode-&gt;{astNodeName} eq 'DCOPRef' and $name eq 'callExt')
+			|| ($classNode-&gt;{astNodeName} eq 'DCOPRef' and $name eq 'call')
+			|| ($classNode-&gt;{astNodeName} eq 'DCOPRef' and $name eq 'send')
+			|| ($classNode-&gt;{astNodeName} eq 'DOM' and $name eq 'operator&lt;&lt;') # Avoid kdbgstream debugging method
+			|| ($name eq 'qInitJpegIO' and $main::qt4)
+			|| ($name eq 'qInitPngIO' and $main::qt4)
+			|| ($name eq 'qt_metacast' and $main::qt4)
+			|| ($name eq 'virtual_hook')
+			|| ($name eq 'handle')
+			|| ($name eq 'qHash')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'setFillBrush')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'fillBrush')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'setFillColor')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'fillColor')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'setAlarmBrush')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'alarmBrush')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'setAlarmColor')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtThermo' and $name eq 'alarmColor')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtWheel' and $name eq 'getScrollMode')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtPlot' and $name eq 'setCanvasBackground')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtPlot' and $name eq 'canvasBackground')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtPlotLayout' and $name eq 'expandLineBreaks')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtPlotLayout' and $name eq 'alignScales')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtData' and $name eq 'operator=')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtScaleTransformation' and $name eq 'double')
+			|| ($classNode-&gt;{astNodeName} eq 'QwtScaleDiv' and $name eq 'QwtScaleDiv' and @{$m-&gt;{ParamList}} &gt; 0)
+			# Obsolete
+			|| ($classNode-&gt;{astNodeName} eq 'QTextStream' and $name eq 'QTextStream'
+					and @{$m-&gt;{ParamList}} == 2 and $m-&gt;{ParamList}[0]-&gt;{ArgType} eq 'QString&amp;')
+			
+			# Various methods to skip in Qt/E (Qt 2.3.x)
+			|| ($main::qt_embedded
+				&amp;&amp; ( ($classNode-&gt;{astNodeName} eq 'QUriDrag' and $name =~ /^decode$|decodeLocalFiles|decodeToUnicodeUris/)
+				|| ($classNode-&gt;{astNodeName} eq 'QApplication' and $name =~ /^qwsSetCustomColors|^setArgs$|^winMouseButtonUp|^winFocus|^winMouseButtonUP$|^winVersion$/)
+				|| ($classNode-&gt;{astNodeName} eq 'QPrinter' and $name =~ /^setIdle$|^setActive$/)
+				|| ($classNode-&gt;{astNodeName} eq 'QDragObject' and $name eq 'dragLink')
+				|| ($classNode-&gt;{astNodeName} eq 'QFont' and $name eq 'qwsRenderToDisk')
+				|| ($classNode-&gt;{astNodeName} eq 'QFontInfo' and $name eq 'font')
+				|| ($classNode-&gt;{astNodeName} eq 'QLineEdit' and $name eq 'getSelection')
+				|| ($classNode-&gt;{astNodeName} eq 'QMainWindow' and $name eq 'toolBars')
+				|| ($classNode-&gt;{astNodeName} eq 'QMovie' and $name eq 'setDisplayWidget')
+				|| ($classNode-&gt;{astNodeName} eq 'QMetaObject' and $name =~ /^new_metaenum_item$|^new_metaaccess$/)
+				|| ($classNode-&gt;{astNodeName} eq 'QPainter' and $name eq 'pos')
+				|| ($classNode-&gt;{astNodeName} eq 'QPixmap' and $name =~ /^allocCell$|^clut$|^freeCell|^hbm|^isMultiCellPixmap|^multiCellPixmap|^multiCellBitmap|^multiCellHandle|^multiCellOffset|^numCols/)
+				|| ($name eq 'handle')
+				|| ($name eq 'resetInputContext')
+				|| ($name eq 'propagateUpdates')
+				|| ($name eq 'bytesPerLine')
+				|| ($name eq 'scanLine')
+				|| ($name eq 'hPal')
+				|| ($name eq 'copyX11Data')
+				|| ($name eq 'getX11Data')
+				|| ($name eq 'setX11Data')
+				|| ($name eq 'realizePal')
+				|| ($name eq 'qwsDisplay')
+				|| ($name eq 'fixport')
+				|| ($name eq 'hack_strrchr')
+				|| ($name eq 'hack_strchr')
+				|| ($name eq 'hack_strstr') ) )
+						
+			# Assume only Qt classes have tr() and trUtf8() in their Q_OBJECT macro
+			|| ($classNode-&gt;{astNodeName} !~ /^Q/ and $name eq 'tr')
+			|| ($classNode-&gt;{astNodeName} !~ /^Q/ and $name eq 'trUtf8')
+
+			|| ($main::qt4
+				&amp;&amp; ( ($classNode-&gt;{astNodeName} eq 'QWidgetListItem' and $name eq 'operator=')
+				|| ($classNode-&gt;{astNodeName} eq 'QColormap' and $name eq 'operator=')
+				|| ($classNode-&gt;{astNodeName} eq 'QListWidget' and $name eq 'setItemPosition')
+				|| ($classNode-&gt;{astNodeName} eq 'QFontMetricsF' and $name eq 'operator=')
+				|| ($classNode-&gt;{astNodeName} eq 'QFontMetricsF' and $name eq 'QFontMetricsF' 
+					and $#{$m-&gt;{ParamList}} == 0 &amp;&amp; $m-&gt;{ParamList}[0]-&gt;{ArgType} eq 'const QFontMetrics&amp;')
+				|| ($classNode-&gt;{astNodeName} eq 'QAbstractItemDelegate' and $name eq 'QAbstractItemDelegate' 
+					and $#{$m-&gt;{ParamList}} == 0 &amp;&amp; $m-&gt;{ParamList}[0]-&gt;{ArgType} eq 'const QAbstractItemDelegate&amp;')
+				|| ($classNode-&gt;{astNodeName} eq 'QHttp' and $name eq 'supportedOperations')
+				|| ($classNode-&gt;{astNodeName} eq 'QPrinter' and $name eq 'printRange')
+				|| ($classNode-&gt;{astNodeName} eq 'QPrinter' and $name eq 'setPrintRange')
+				|| ($classNode-&gt;{astNodeName} eq 'QRectF' and $name eq 'setX')
+				|| ($classNode-&gt;{astNodeName} eq 'QRectF' and $name eq 'setY')
+				|| ($classNode-&gt;{astNodeName} eq 'QTextObject' and $name eq 'formatType')
+				|| ($classNode-&gt;{astNodeName} eq 'QUrl' and $name eq 'QUrl'
+					and $#{$m-&gt;{ParamList}} == 0 &amp;&amp; $m-&gt;{ParamList}[0]-&gt;{ArgType} eq 'QUrlPrivate&amp;')
+				|| ($classNode-&gt;{astNodeName} eq 'QGlobalSpace' and $name eq 'operator&lt;&lt;' and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QDebug/)
+				|| ($classNode-&gt;{astNodeName} eq 'QGlobalSpace' and $#{$m-&gt;{ParamList}} &gt; 0 and $name =~ /operator/ and $m-&gt;{ParamList}[1]-&gt;{ArgType} =~ /QVariant::Type/)
+				|| ($#{$m-&gt;{ParamList}} &gt; 0 and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /Private/)
+				|| ($classNode-&gt;{astNodeName} eq 'QScrollArea' and $name eq 'alignment')
+				|| ($classNode-&gt;{astNodeName} eq 'QScrollArea' and $name eq 'setAlignment')
+				|| ($classNode-&gt;{astNodeName} eq 'QDBusConnection' and $name eq 'findInterface' and 
+					$m-&gt;{ReturnType} =~ /&lt;/ )
+				|| ($classNode-&gt;{astNodeName} eq 'QDBusBusService' and $name eq 'RequestName')
+				|| ($classNode-&gt;{astNodeName} eq 'QDBusBusService' and $name eq 'requestName')
+				|| ($name eq 'qDBusMetaTypeId')
+				|| ($m-&gt;{ReturnType} =~ /QT3_SUPPORT/) ) )
+
+			|| $m-&gt;{Deprecated} ) {
+		    $m-&gt;{NodeType} = 'deleted';
+			next;
+		}
+
+		# QLayout::setGeometry() is marked as pure virtual in the header, but actually has
+		# an implementation, so special case it.
+		if ($main::qt4 and $classNode-&gt;{astNodeName} eq 'QLayout' and $name eq 'setGeometry') {
+			$m-&gt;{Flags} =~ s/p//;
+		}
+
+		# Hack for fixing up KDE 3.1 KLed where the no arg constructor was ambiguous
+		if ($classNode-&gt;{astNodeName} eq 'KLed' and $name eq 'KLed' &amp;&amp; $#{$m-&gt;{ParamList}} &gt; 0) {
+			if ($m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QColor/ &amp;&amp; defined $m-&gt;{ParamList}[0]-&gt;{DefaultValue}) {
+				$m-&gt;{ParamList}[0]-&gt;{DefaultValue} = undef;
+				if (defined $kledAmbiguousConstructor) {
+					$kledAmbiguousConstructor-&gt;{ParamList}[0]-&gt;{DefaultValue} = undef;
+					$kledAmbiguousConstructor-&gt;{FirstDefaultParam} = 1;
+				}
+			} else {
+				$kledAmbiguousConstructor = $m;
+			}
+		}
+		
+	    my $argId = 0;
+	    my $firstDefaultParam;
+	    foreach my $arg ( @{$m-&gt;{ParamList}} ) {
+		# Look for first param with a default value
+		if ( defined $arg-&gt;{DefaultValue} &amp;&amp; !defined $firstDefaultParam ) {
+		    $firstDefaultParam = $argId;
+		}
+
+		if ( $arg-&gt;{ArgType} eq '...' # refuse a method with variable arguments
+		     or $arg-&gt;{ArgType} eq 'image_io_handler' # QImage's callback
+		     or $arg-&gt;{ArgType} eq 'DecoderFn' # QFile's callback
+		     or $arg-&gt;{ArgType} eq 'EncoderFn' # QFile's callback
+		     or $arg-&gt;{ArgType} =~ /bool \(\*\)\(QObject/ # QMetaObject's ctor
+		     or $arg-&gt;{ArgType} eq 'QtStaticMetaObjectFunction' # QMetaObjectCleanUp's ctor with func pointer
+		     or $arg-&gt;{ArgType} eq 'const QTextItem&amp;' # ref to a private class in 3.2.0b1
+		     or $arg-&gt;{ArgType} eq 'FILE*' # won't be able to handle that I think
+		     or $arg-&gt;{ArgType} eq 'const KKeyNative&amp;' #
+		     or $arg-&gt;{ArgType} =~ /Node\s*\*/ #
+		) {
+		    $m-&gt;{NodeType} = 'deleted';
+		}
+		else
+		{
+		    # Resolve type in full, e.g. for QSessionManager::RestartHint
+		    # (x_QSessionManager doesn't inherit QSessionManager)
+		    $arg-&gt;{ArgType} = kalyptusDataDict::resolveType($arg-&gt;{ArgType}, $classNode, $rootnode);
+		    registerType( $arg-&gt;{ArgType} );
+		    $argId++;
+		}
+	    }
+	    $m-&gt;AddProp( &quot;FirstDefaultParam&quot;, $firstDefaultParam );
+	    $m-&gt;{ReturnType} = kalyptusDataDict::resolveType($m-&gt;{ReturnType}, $classNode, $rootnode) if ($m-&gt;{ReturnType});
+	    registerType( $m-&gt;{ReturnType} );
+	}
+	elsif( $m-&gt;{NodeType} eq &quot;enum&quot; ) {
+	    my $fullEnumName = $className.&quot;::&quot;.$m-&gt;{astNodeName};
+		
+		if ( ($fullEnumName eq 'KMimeType::Format' and $name eq 'compression')
+				|| $m-&gt;{Deprecated} ) {
+		    $m-&gt;{NodeType} = 'deleted';
+			next;
+		}
+	    
+		$classNode-&gt;{enumerations}{$m-&gt;{astNodeName}} = $fullEnumName
+		if $m-&gt;{astNodeName} and $m-&gt;{Access} ne 'private';
+
+	    # Define a type for this enum
+	    registerType( $fullEnumName );
+
+	    # Remember that it's an enum
+	    findTypeEntry( $fullEnumName )-&gt;{isEnum} = 1;
+
+	    #print STDERR &quot;$fullEnumName is an enum\n&quot;;
+ 	}
+	elsif( $m-&gt;{NodeType} eq 'var' ) {
+		if (	($classNode-&gt;{astNodeName} eq 'QUuid' and $name eq 'data4')
+				|| ($name eq 'd')
+				|| ($classNode-&gt;{astNodeName} eq 'QObject' and $name eq 'staticMetaObject')
+				|| ($classNode-&gt;{astNodeName} eq 'SlaveBase' and $name eq 'mIncomingMetaData')
+				|| ($classNode-&gt;{astNodeName} eq 'SlaveBase' and $name eq 'mOutgoingMetaData') ) 
+		{
+			$m-&gt;{NodeType} = 'deleted';
+			next;
+		}
+
+	    my $varType = $m-&gt;{Type};
+		$varType =~ s/const\s+(.*)\s*&amp;/$1/;
+		$varType =~ s/^\s*//;
+		$varType =~ s/\s*$//;
+		$varType =~ s/static\s+//;
+
+		if ( $m-&gt;{Flags} =~ &quot;s&quot; ) {
+			# We are interested in public static vars, like QColor::blue
+			if ( $m-&gt;{Access} ne 'private'
+				&amp;&amp; $className.&quot;::&quot;.$m-&gt;{astNodeName} ne &quot;KSpell::modalListText&quot; )
+			{
+				print STDERR &quot;var: $m-&gt;{astNodeName} '$varType'\n&quot; if ($debug);
+
+				# Register the type
+				registerType( $varType );
+			} else {
+				$m-&gt;{NodeType} = 'deleted';
+			}
+		} elsif ($m-&gt;{Access} eq 'public') {
+			# Add a setter method for a public instance variable
+			my $setMethod = $name;
+			if ($setMethod =~ /^(\w)(.*)/) {
+				my $ch = $1;
+				$ch =~ tr/a-z/A-Z/;
+				$setMethod = &quot;set$ch$2&quot;;
+			}
+			my $node = Ast::New( $setMethod );
+			$node-&gt;AddProp( &quot;NodeType&quot;, &quot;method&quot; );
+			# Flags of &quot;=&quot; for a setter method
+			$node-&gt;AddProp( &quot;Flags&quot;, &quot;=&quot; );
+			$node-&gt;AddProp( &quot;ReturnType&quot;, &quot;void&quot; );
+			$node-&gt;AddProp( &quot;Params&quot;, $varType );
+
+			my $param = Ast::New( 1 );
+			$param-&gt;AddProp( &quot;NodeType&quot;, &quot;param&quot; );
+			$param-&gt;AddProp( &quot;ArgType&quot;, $varType );
+			$node-&gt;AddPropList( &quot;ParamList&quot;, $param );
+
+			kdocAstUtil::attachChild( $classNode, $node );
+
+			# Register the type
+			registerType( $varType );
+		} else {
+			$m-&gt;{NodeType} = 'deleted';
+		}
+	}
+		},
+		undef
+	);
+	$main::doPrivate = $doPrivate;
+
+	print STDERR &quot;$className: ctor count: $constructorCount, hasPublicProtectedConstructor: $hasPublicProtectedConstructor, hasCopyConstructor: $hasCopyConstructor:, defaultConstructor: $defaultConstructor, hasPublicDestructor: $hasPublicDestructor, hasPrivatePureVirtual:$hasPrivatePureVirtual\n&quot; if ($debug);
+
+	my $isGlobalSpace = ($className eq $main::globalSpaceClassName);
+
+	# Note that if the class has _no_ constructor, the default ctor applies. Let's even generate it.
+	if ( !$constructorCount &amp;&amp; $defaultConstructor eq 'none' 
+		&amp;&amp; !$hasPrivatePureVirtual &amp;&amp; !$isGlobalSpace &amp;&amp; $classNode-&gt;{NodeType} ne 'namespace' ) {
+	    # Create a method node for the constructor
+	    my $methodNode = Ast::New( $classNode-&gt;{astNodeName} );
+	    $methodNode-&gt;AddProp( &quot;NodeType&quot;, &quot;method&quot; );
+	    $methodNode-&gt;AddProp( &quot;Flags&quot;, &quot;&quot; );
+	    $methodNode-&gt;AddProp( &quot;Params&quot;, &quot;&quot; );
+            $methodNode-&gt;AddProp( &quot;ParamList&quot;, [] );
+	    kdocAstUtil::attachChild( $classNode, $methodNode );
+
+	    # Hack the return type for constructors, since constructors return an object pointer
+	    $methodNode-&gt;AddProp( &quot;ReturnType&quot;, $className.&quot;*&quot; );
+	    registerType( $className.&quot;*&quot; );
+	    $methodNode-&gt;AddProp( &quot;Access&quot;, &quot;public&quot; ); # after attachChild
+	    $defaultConstructor = 'public';
+	    $hasPublicProtectedConstructor = 1;
+	}
+
+	# Also, if the class has no explicit destructor, generate a default one.
+	if ( !$hasDestructor &amp;&amp; !$hasPrivatePureVirtual &amp;&amp; !$isGlobalSpace &amp;&amp; $classNode-&gt;{NodeType} ne 'namespace' ) {
+	    my $methodNode = Ast::New( &quot;$classNode-&gt;{astNodeName}&quot; );
+	    $methodNode-&gt;AddProp( &quot;NodeType&quot;, &quot;method&quot; );
+	    $methodNode-&gt;AddProp( &quot;Flags&quot;, &quot;&quot; );
+	    $methodNode-&gt;AddProp( &quot;Params&quot;, &quot;&quot; );
+	    $methodNode-&gt;AddProp( &quot;ParamList&quot;, [] );
+	    kdocAstUtil::attachChild( $classNode, $methodNode );
+
+	    $methodNode-&gt;AddProp( &quot;ReturnType&quot;, &quot;~&quot; );
+	    $methodNode-&gt;AddProp( &quot;Access&quot;, &quot;public&quot; );
+	}
+
+	# If we have a private pure virtual, then the class can't be instanciated (e.g. QCanvasItem)
+	# Same if the class has only private constructors (e.g. QInputDialog)
+	$classNode-&gt;AddProp( &quot;CanBeInstanciated&quot;, $hasPublicProtectedConstructor &amp;&amp; !$hasPrivatePureVirtual );
+
+	# We will derive from the class only if it has public or protected constructors.
+	# (_Even_ if it has pure virtuals. But in that case the x_ class can't be instantiated either.)
+	$classNode-&gt;AddProp( &quot;BindingDerives&quot;, $hasPublicProtectedConstructor );
+
+	# We need a public dtor to destroy the object --- ### aren't protected dtors ok too ??
+	$classNode-&gt;AddProp( &quot;HasPublicDestructor&quot;, $hasPublicDestructor );
+
+	# Hack for QAsyncIO. We don't implement the &quot;if a class has no explicit copy ctor,
+	# then all of its member variables must be copiable, otherwise the class isn't copiable&quot;.
+	$hasPrivateCopyConstructor = 1 if ( $className eq 'QAsyncIO' );
+
+	# Remember if this class can't be copied - it means all its descendants can't either
+	$classNode-&gt;AddProp( &quot;CanBeCopied&quot;, !$hasPrivateCopyConstructor );
+	$classNode-&gt;AddProp( &quot;HasCopyConstructor&quot;, $hasCopyConstructor );
+}
+
+
+sub propagateCanBeCopied($)
+{
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	my @super = superclass_list($classNode);
+	# A class can only be copied if none of its ancestors have a private copy ctor.
+	for my $s (@super) {
+	    if (!$s-&gt;{CanBeCopied}) {
+		$classNode-&gt;{CanBeCopied} = 0;
+		print STDERR &quot;$classNode-&gt;{astNodeName} cannot be copied\n&quot; if ($debug);
+		last;
+	    }
+	}
+	# If the class has no explicit copy constructor, and it can be copied,
+	# generate the copy constructor.
+	if ( !$classNode-&gt;{HasCopyConstructor} &amp;&amp; $classNode-&gt;{CanBeCopied} &amp;&amp; $classNode-&gt;{CanBeInstanciated} ) {
+	    my $methodNode = Ast::New( &quot;$classNode-&gt;{astNodeName}&quot; );
+	    $methodNode-&gt;AddProp( &quot;NodeType&quot;, &quot;method&quot; );
+	    $methodNode-&gt;AddProp( &quot;Flags&quot;, &quot;ix&quot; ); # Only for internal use in marshallers
+	    my $argType = &quot;const &quot;.$className.&quot;&amp;&quot;;
+	    registerType( $argType );
+	    $methodNode-&gt;AddProp( &quot;Params&quot;, $argType );
+	    # The param node
+		my $node = Ast::New( 1 ); # let's make the arg index the node &quot;name&quot;
+		$node-&gt;AddProp( &quot;NodeType&quot;, &quot;param&quot; );
+		$node-&gt;AddProp( &quot;ArgType&quot;, $argType );
+		$methodNode-&gt;AddPropList( &quot;ParamList&quot;, $node );
+	    kdocAstUtil::attachChild( $classNode, $methodNode );
+
+	    # Hack the return type for constructors, since constructors return an object pointer
+	    $methodNode-&gt;AddProp( &quot;ReturnType&quot;, $className.&quot;*&quot; );
+	    registerType( $className.&quot;*&quot; );
+	    $methodNode-&gt;AddProp( &quot;Access&quot;, &quot;public&quot; ); # after attachChild
+	}
+
+	# Prepare the {case} dict for the class
+	prepareCaseDict( $classNode );
+}
+
+=head2 writeClassDoc
+
+	Called by writeDoc for each series of classes to be written out
+
+=cut
+
+BEGIN {
+
+my $fhn =1; # static
+
+  sub writeClassDoc
+  {
+	my $nodelist = shift;
+        my $file = &quot;$outputdir/x_${fhn}.cpp&quot;;
+        open( my $fh, &quot;&gt;$file&quot; ) || die &quot;Couldn't create $file\n&quot;;
+
+	print $fh &quot;//Auto-generated by $0. DO NOT EDIT.\n&quot;;
+ 	print $fh &quot;#include &lt;smoke.h&gt;\n&quot;;
+ 	print $fh &quot;#include &lt;${libname}_smoke.h&gt;\n&quot;;
+	
+        my @code;
+        for my $node ( @$nodelist )
+        {
+            push @code, [generateAllMethods( $node )]
+        }
+        my %includes;
+        map { for my $incl (keys %{$_-&gt;[2]}){ $includes{$incl}++ } } @code;
+
+	# Hack - some Qt/KDE headers need other headers included, but omit suitable #includes
+	if (defined $includes{&quot;qregexp.h&quot;} || defined $includes{&quot;qcstring.h&quot;}) {
+	    print $fh &quot;#include &lt;qregexp.h&gt;\n&quot;;
+		delete $includes{&quot;qregexp.h&quot;};
+	}
+	if (defined $includes{&quot;qmime.h&quot;} || defined $includes{&quot;qmimedata.h&quot;}) {
+	    print $fh &quot;#include &lt;qurl.h&gt;\n&quot;;
+		delete $includes{&quot;qurl.h&quot;};
+	}
+	if (defined $includes{&quot;kshortcut.h&quot;}) {
+	    print $fh &quot;#include &lt;kshortcut.h&gt;\n&quot;;
+		delete $includes{&quot;kshortcut.h&quot;};
+	} 
+	if (defined $includes{&quot;kshortcutlist.h&quot;}) {
+	    print $fh &quot;#include &lt;kconfigbase.h&gt;\n&quot;;
+	    print $fh &quot;#include &lt;kshortcutlist.h&gt;\n&quot;;
+		delete $includes{&quot;kconfigbase.h&quot;};
+		delete $includes{&quot;kshortcutlist.h&quot;};
+	}
+	if (defined $includes{&quot;kaction.h&quot;}) {
+	    print $fh &quot;#include &lt;kaction.h&gt;\n&quot;;
+		delete $includes{&quot;kaction.h&quot;};
+	}
+	foreach my $incl (keys %includes) {
+	    die if $incl eq '';
+	    print $fh &quot;#include &lt;$incl&gt;\n&quot;;
+	}	
+	if (	$main::qt4
+			and (	defined $includes{&quot;qtreewidget.h&quot;} 
+					or defined $includes{&quot;qlistwidget.h&quot;} 
+					or defined $includes{&quot;qtablewidget.h&quot;} ) ) 
+	{
+	    print $fh &quot;#include \&quot;qwidgetitemdata_p.h\&quot;\n&quot;;
+	}
+	print $fh &quot;\n&quot;;
+        for my $c( 0..$#code )
+        {
+           my ($methodCode, $switchCode, $incl) = @{ $code[$c] };
+           my $node = $$nodelist[$c];
+           my $className = join( &quot;::&quot;, kdocAstUtil::heritage($node) );
+           my $legacyClassName = join( &quot;__&quot;, kdocAstUtil::heritage($node) );
+           print $fh &quot;class x_$legacyClassName &quot;;
+           print $fh &quot;: public $className &quot; if $node-&gt;{BindingDerives};
+           print $fh &quot;{\n&quot;;
+           print $fh $methodCode;
+           print $fh &quot;};\n&quot;;
+	   if(keys %{$node-&gt;{enumerations}}) {
+	        print $fh &quot;void xenum_${legacyClassName}(Smoke::EnumOperation xop, Smoke::Index xtype, void *&amp;xdata, long &amp;xvalue) {\n&quot;;
+	        print $fh &quot;    x_${legacyClassName}\::xenum_operation(xop, xtype, xdata, xvalue);\n&quot;;
+	        print $fh &quot;}\n&quot;;
+	   }
+	   print $fh &quot;void xcall_${legacyClassName}(Smoke::Index xi, void *obj, Smoke::Stack args) {\n&quot;;
+	   print $fh $switchCode;
+	   print $fh &quot;}\n\n&quot;;
+        }
+	#if ( $className =~ /^(QBrush|QColor|QCursor|QFont|QImage|QPalette|QPixmap|QPoint|QPointArray|QRect|QRegion|QSize|QWMatrix)$/ ) {
+	#	print XCPPFILE &quot;    const char *{serial} operator &lt;&lt; () const : pig_serialize(\$this);\n&quot;;
+	#	print XCPPFILE &quot;    void operator &gt;&gt; (const char *{serial}) : pig_deserialize(\$this, \$1);\n&quot;;
+	#}
+
+	close $fh;
+        $fhn++
+  }
+
+}
+
+# Generate the prototypes for a method (one per arg with a default value)
+# Helper for makeprotos
+sub iterproto($$$$$) {
+    my $classidx = shift; # to check if a class exists
+    my $method = shift;
+    my $proto = shift;
+    my $idx = shift;
+    my $protolist = shift;
+
+    my $argcnt = scalar @{ $method-&gt;{ParamList} } - 1;
+    if($idx &gt; $argcnt) {
+	push @$protolist, $proto;
+	return;
+    }
+    if(defined $method-&gt;{FirstDefaultParam} and $method-&gt;{FirstDefaultParam} &lt;= $idx) {
+	push @$protolist, $proto;
+    }
+
+    my $arg = $method-&gt;{ParamList}[$idx]-&gt;{ArgType};
+
+    my $typeEntry = findTypeEntry( $arg );
+    my $realType = $typeEntry-&gt;{realType};
+
+    # A scalar ?
+    $arg =~ s/\bconst\b//g;
+    $arg =~ s/\s+//g;
+    if($typeEntry-&gt;{isEnum} || $allTypes{$realType}{isEnum} || exists $typeunion{$realType} || exists $mungedTypeMap{$arg})
+    {
+	my $id = '$'; # a 'scalar
+	$id = '?' if $arg =~ /[*&amp;]{2}/;
+	$id = $mungedTypeMap{$arg} if exists $mungedTypeMap{$arg};
+	iterproto($classidx, $method, $proto . $id, $idx + 1, $protolist);
+	return;
+    }
+
+    # A class ?
+    if(exists $classidx-&gt;{$realType}) {
+	iterproto($classidx, $method, $proto . '#', $idx + 1, $protolist);
+	return;
+    }
+
+    # A non-scalar (reference to array or hash, undef)
+    iterproto($classidx, $method, $proto . '?', $idx + 1, $protolist);
+    return;
+}
+
+# Generate the prototypes for a method (one per arg with a default value)
+sub makeprotos($$$) {
+    my $classidx = shift;
+    my $method = shift;
+    my $protolist = shift;
+    iterproto($classidx, $method, $method-&gt;{astNodeName}, 0, $protolist);
+}
+
+# Return the string containing the signature for this method (without return type).
+# If the 2nd arg is not the size of $m-&gt;{ParamList}, this method returns a
+# partial signature (this is used to handle default values).
+sub methodSignature($$) {
+    my $method = shift;
+    my $last = shift;
+    my $sig = $method-&gt;{astNodeName};
+    my @argTypeList;
+    my $argId = 0;
+    foreach my $arg ( @{$method-&gt;{ParamList}} ) {
+	last if $argId &gt; $last;
+	push @argTypeList, $arg-&gt;{ArgType};
+	$argId++;
+    }
+    $sig .= &quot;(&quot;. join(&quot;, &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">, at argTypeList</A>) .&quot;)&quot;;
+    $sig .= &quot; const&quot; if $method-&gt;{Flags} =~ &quot;c&quot;;
+    return $sig;
+}
+
+sub coerce_type($$$$) {
+    #my $m = shift;
+    my $union = shift;
+    my $var = shift;
+    my $type = shift;
+    my $new = shift; # 1 if this is a return value, 0 for a normal param
+
+    my $typeEntry = findTypeEntry( $type );
+    my $realType = $typeEntry-&gt;{realType};
+
+    my $unionfield = $typeEntry-&gt;{typeId};
+    die &quot;$type&quot; unless defined( $unionfield );
+    $unionfield =~ s/t_/s_/;
+
+    $type =~ s/\s+const$//; # for 'char* const'
+    $type =~ s/\s+const\s*\*$/\*/; # for 'char* const*'
+
+    my $code = &quot;$union.$unionfield = &quot;;
+    if($type =~ /&amp;$/) {
+	$code .= &quot;(void*)&amp;$var;\n&quot;;
+    } elsif($type =~ /\*$/) {
+	$code .= &quot;(void*)$var;\n&quot;;
+    } else {
+	if ( $unionfield eq 's_class' 
+		or ( $unionfield eq 's_voidp' and $type ne 'void*' )
+		or $type eq 'QString' ) { # hack
+	    $type =~ s/^const\s+//;
+	    if($new) {
+	        $code .= &quot;(void*)new $type($var);\n&quot;;
+	    } else {
+	        $code .= &quot;(void*)&amp;$var;\n&quot;;
+	    }
+	} else {
+	    $code .= &quot;$var;\n&quot;;
+	}
+    }
+
+    return $code;
+}
+
+# Generate the list of args casted to their real type, e.g.
+# (QObject*)x[1].s_class,(QEvent*)x[2].s_class,x[3].s_int
+sub makeCastedArgList
+{
+    my @castedList;
+    my $i = 1; # The args start at x[1]. x[0] is the return value
+    my $arg;
+    foreach $arg (@_) {
+	my $type = $arg;
+	my $cast;
+
+	my $typeEntry = findTypeEntry( $type );
+	my $unionfield = $typeEntry-&gt;{typeId};
+	die &quot;$type&quot; unless defined( $unionfield );
+	$unionfield =~ s/t_/s_/;
+
+	$type =~ s/\s+const$//; # for 'char* const'
+	$type =~ s/\s+const\s*\*$/\*/; # for 'char* const*'
+
+	my $v .= &quot;x[$i].$unionfield&quot;;
+	if($type =~ s/&amp;$//) {
+	    $cast = &quot;*($type *)&quot;;
+	} elsif($type =~ /\*$/) {
+	    $cast = &quot;($type)&quot;;
+        } elsif($type =~ /\(\*\)\s*\(/) { # function pointer ... (*)(...)
+            $cast = &quot;($type)&quot;;
+	} else {
+	    if ( $unionfield eq 's_class'
+		or ( $unionfield eq 's_voidp' and $type ne 'void*' )
+		or $type eq 'QString' ) { # hack
+	        $cast = &quot;*($type *)&quot;;
+	    } else {
+	        $cast = &quot;($type)&quot;;
+	    }
+	}
+	push @castedList, &quot;$cast$v&quot;;
+	$i++;
+    }
+    return @castedList;
+}
+
+# Adds the header for node $1 to be included in $2 if not already there
+# Prints out debug stuff if $3
+sub addIncludeForClass($$$)
+{
+    my ( $node, $addInclude, $debugMe ) = @_;
+    my $sourcename = $node-&gt;{Source}-&gt;{astNodeName};
+    if ( $sourcename !~ s!.*($headerSubdirectories)(.*)!$1$2!m ) {
+    	$sourcename =~ s!.*/(.*)!$1!m;
+	}
+#    die &quot;Empty source name for $node-&gt;{astNodeName}&quot; if ( $sourcename eq '' );
+    return if ( $sourcename eq '' );
+    unless ( defined $addInclude-&gt;{$sourcename} ) {
+	print &quot;  Including $sourcename\n&quot; if ($debugMe);
+	$addInclude-&gt;{$sourcename} = 1;
+    }
+    else { print &quot;  $sourcename already included.\n&quot; if ($debugMe); }
+}
+
+sub checkIncludesForObject($$)
+{
+    my $type = shift;
+    my $addInclude = shift;
+
+    my $debugCI = 0; #$debug
+    #print &quot;checkIncludesForObject $type\n&quot;;
+    $type =~ s/const\s+//;
+    my $it = $type;
+    if (!($it and exists $typeunion{$it}) and $type !~ /\*/
+         #and $type !~ /&amp;/  # in fact we also want refs, due to the generated code
+        ) {
+	$type =~ s/&amp;//;
+	print &quot;  Detecting an object by value/ref: $type\n&quot; if ($debugCI);
+	my $node = kdocAstUtil::findRef( $rootnode, $type );
+	if ($node) {
+	    addIncludeForClass( $node, $addInclude, $debugCI );
+	}
+	else { print &quot; No header found for $type\n&quot; if ($debugCI); }
+    }
+}
+
+sub generateVirtualMethod($$$$$)
+{
+    # Generating methods for $class.
+    # $m: method node. $methodClass: the node of the class in which the method is really declared
+    # (can be different from $class when the method comes from a super class)
+    # This is important because of $allMethods, which has no entry for class::method in that case.
+
+    my( $classNode, $signature, $m, $methodClass, $addInclude ) = @_;
+    my $methodCode = '';                    # output
+    my $returnType = $m-&gt;{ReturnType};
+    return ('', '') if $returnType eq '~'; # skip destructors
+
+    my $className = $classNode-&gt;{astNodeName};
+    my $flags = $m-&gt;{Flags};
+    my @argList = @{$m-&gt;{ParamList}};
+
+    print &quot;generateVirtualMethod $className: $signature  ($m-&gt;{Access})\n&quot; if ($debug);
+
+    # Detect objects returned by value
+    checkIncludesForObject( $returnType, $addInclude ) if ($returnType ne 'void');
+
+    # Generate a matching virtual method in the x_ class
+    $methodCode .= &quot;    virtual $returnType $m-&gt;{astNodeName}(&quot;;
+    my $i = 0;
+    foreach my $arg ( @argList ) {
+        $methodCode .= &quot;, &quot; if $i++;
+        $methodCode .= $arg-&gt;{ArgType};
+        $methodCode .= &quot; x$i&quot;;
+
+	# Detect objects passed by value
+	checkIncludesForObject( $arg-&gt;{ArgType}, $addInclude );
+    }
+    $methodCode .= &quot;) &quot;;
+    $methodCode .= &quot;const &quot; if ($flags =~ &quot;c&quot;);
+    $methodCode .= &quot;\{\n&quot;;
+
+    # Now the code of the method
+    my $this = $classNode-&gt;{BindingDerives} &gt; 0 ? &quot;this&quot; : &quot;xthis&quot;;
+
+    $i++; # Now the number of args
+    $methodCode .= &quot;\tSmoke::StackItem x[$i];\n&quot;;
+    $i = 1;
+    for my $arg (@argList) {
+	$methodCode .= &quot;\t&quot;;
+	$methodCode .= coerce_type(&quot;x[$i]&quot;, &quot;x$i&quot;, $arg-&gt;{ArgType}, 0);
+	$i++;
+    }
+
+    my $sig = $methodClass-&gt;{astNodeName} . &quot;::&quot; . $signature;
+    my $idx = $allMethods{$sig};
+    
+	if ( ! defined $idx ) {
+		my $class_name = join( &quot;::&quot;, kdocAstUtil::heritage($methodClass) );
+		$sig = $class_name . &quot;::&quot; . $signature;
+		$idx = $allMethods{$sig};
+	}
+    die &quot;generateVirtualMethod: $className: No method found for $sig\n&quot; if !defined $idx;
+    if($flags =~ &quot;p&quot;) { # pure virtual
+	$methodCode .= &quot;\t${libname}_Smoke-&gt;binding-&gt;callMethod($idx, (void*)$this, x, true /*pure virtual*/);\n&quot;;
+    } else {
+	$methodCode .= &quot;\tif(${libname}_Smoke-&gt;binding-&gt;callMethod($idx, (void*)$this, x)) &quot;;
+    }
+
+    $returnType = undef if ($returnType eq 'void');
+    if($returnType) {
+	my $arg = $returnType;
+	my $it = applyTypeDef( $arg );
+	my $cast;
+	my $v = &quot;x[0]&quot;;
+	my $indent = ($flags =~ &quot;p&quot;) ? &quot;\t&quot; : &quot;&quot;;
+	if($it and exists $typeunion{$it}) {
+	    $v .= &quot;.$typeunion{$it}&quot;;
+	    $cast = &quot;($arg)&quot;;
+	    $methodCode .= &quot;${indent}return $cast$v;\n&quot;;
+	} else {
+	    $v .= &quot;.s_class&quot;;
+	    if($arg =~ s/&amp;//) {
+		$cast = &quot;*($arg *)&quot;;
+		$methodCode .= &quot;${indent}return $cast$v;\n&quot;;
+	    } elsif($arg !~ /\*$/) {
+		unless($flags =~ &quot;p&quot;) {
+		    $indent = &quot;\t    &quot;;
+		    $methodCode .= &quot;{\n&quot;;
+		}
+		# we assume it's a new thing, and handle it
+		$methodCode .= &quot;${indent}$arg *xptr = ($arg *)$v;\n&quot;;
+		$methodCode .= &quot;${indent}$arg xret(*xptr);\n&quot;;
+		$methodCode .= &quot;${indent}delete xptr;\n&quot;;
+		$methodCode .= &quot;${indent}return xret;\n&quot;;
+		$methodCode .= &quot;\t}\n&quot; unless $flags =~ &quot;p&quot;;
+	    } else {
+		$cast = &quot;($arg)&quot;;
+		$methodCode .= &quot;${indent}return $cast$v;\n&quot;;
+	    }
+	}
+    } else {
+	$methodCode .= &quot;\t&quot; if $flags =~ &quot;p&quot;;
+	$methodCode .= &quot;return;\n&quot;;
+    }
+    if($flags =~ &quot;p&quot;) {
+	$methodCode .= &quot;\t// ABSTRACT\n&quot;;
+	$methodCode .= &quot;    }\n&quot;;
+	return ( $methodCode );
+    }
+    $methodCode .= &quot;\t&quot;;
+    if($returnType) {
+	$methodCode .= &quot;return &quot;;
+    }
+    $methodCode .= &quot;$this\-&gt;$methodClass-&gt;{astNodeName}\::$m-&gt;{astNodeName}(&quot;;
+    $i = 0;
+    for my $arg (@argList) {
+	$methodCode .= &quot;, &quot; if $i++;
+	$methodCode .= &quot;x$i&quot;;
+    }
+    $methodCode .= &quot;);\n&quot;;
+    $methodCode .= &quot;    }\n&quot;;
+    return ( $methodCode );
+}
+
+sub generateMethod($$$)
+{
+    my( $classNode, $m, $addInclude ) = @_;	# input
+    my $methodCode = '';	# output
+    my $switchCode = '';	# output
+
+    my $name = $m-&gt;{astNodeName}; # method name
+    my @heritage = kdocAstUtil::heritage($classNode);
+    my $className  = join( &quot;::&quot;, @heritage );
+    my $xClassName  = &quot;x_&quot; . join( &quot;__&quot;, @heritage );
+
+    # Check some method flags: constructor, destructor etc.
+    my $flags = $m-&gt;{Flags};
+
+    if ( !defined $flags ) {
+	warn &quot;Method &quot;.$name.  &quot; has no flags\n&quot;;
+    }
+
+    my $returnType = $m-&gt;{ReturnType};
+
+    $returnType = undef if ($returnType eq 'void');
+
+    # Don't use $className here, it's never the fully qualified (A::B) name for a ctor.
+    my $isConstructor = ($name eq $classNode-&gt;{astNodeName} );
+    my $isDestructor = ($returnType eq '~');
+
+    if ($debug) {
+        print STDERR &quot; Method $name&quot;;
+	print STDERR &quot;, is DTOR&quot; if $isDestructor;
+	print STDERR &quot;, returns $returnType&quot; if $returnType;
+	#print STDERR &quot; ($m-&gt;{Access})&quot;;
+	print STDERR &quot;\n&quot;;
+    }
+
+    # Don't generate anything for destructors
+    return if $isDestructor;
+
+    return if ( $m-&gt;{SkipFromSwitch} ); # pure virtuals, etc.
+
+#    # Skip internal methods, which return unknown types
+#    # Hmm, the C# bindings have a list of those too.
+#    return if ( $returnType =~ m/QGfx\s*\*/ );
+#    return if ( $returnType eq 'CGContextRef' );
+#    return if ( $returnType eq 'QWSDisplay *' );
+#    # This stuff needs callback, or **
+#    return if ( $name eq 'defineIOHandler' or $name eq 'qt_init_internal' );
+#    # Skip casting operators, but not == &lt; etc.
+#    return if ( $name =~ /operator \w+/ );
+#    # QFile's EncoderFn/DecoderFn
+#    return if ( $name =~ /set[ED][ne]codingFunction/ );
+#    # How to implement this? (QXmlDefaultHandler/QXmlEntityResolver::resolveEntity, needs A*&amp;)
+#    return if ( $name eq 'resolveEntity' and $className =~ /^QXml/ );
+#    return if ( $className eq 'QBitArray' &amp;&amp; $m-&gt;{Access} eq 'protected' );
+
+    #print STDERR &quot;Tests passed, generating.\n&quot;;
+
+    # Detect objects returned by value
+    checkIncludesForObject( $returnType, $addInclude ) if ($returnType);
+
+    my $argId = 0;
+
+    my @argTypeList=();
+
+    foreach my $arg ( @{$m-&gt;{ParamList}} ) {
+
+	print STDERR &quot;  Param &quot;.$arg-&gt;{astNodeName}.&quot; type: &quot;.$arg-&gt;{ArgType}.&quot; name:&quot;.$arg-&gt;{ArgName}.&quot; default: &quot;.$arg-&gt;{DefaultValue}.&quot;\n&quot; if ($debug);
+
+	my $argType = $arg-&gt;{ArgType};
+	push @argTypeList, $argType;
+		
+	# Detect objects passed by value
+	checkIncludesForObject( $argType, $addInclude );
+	}    
+
+    my @castedArgList = makeCastedArgList( @argTypeList );
+
+    my $isStatic = $flags =~ &quot;s&quot;;
+
+    my $extra = &quot;&quot;;
+    $extra .= &quot;static &quot; if $isStatic || $isConstructor || $classNode-&gt;{NodeType} eq 'namespace';
+
+    my $attr = &quot;&quot;;
+    $attr .= &quot;const &quot; if $flags =~ &quot;c&quot;;
+
+    my $this = $classNode-&gt;{BindingDerives} &gt; 0 ? &quot;this&quot; : &quot;xthis&quot;;
+
+    # We iterate as many times as we have default params
+    my $firstDefaultParam = $m-&gt;{FirstDefaultParam};
+    $firstDefaultParam = scalar(@argTypeList) unless defined $firstDefaultParam;
+    my $iterationCount = scalar(@argTypeList) - $firstDefaultParam;
+
+    my $xretCode = '';
+    if($returnType) {
+	$xretCode .= coerce_type('x[0]', 'xret', $returnType, 1);
+    }
+
+    print STDERR &quot;  &quot;. ($iterationCount+1). &quot; iterations for $name\n&quot; if ($debug);
+
+    while($iterationCount &gt;= 0) {
+
+	local($&quot;) = &quot;,&quot;;
+	# Handle case of a class with constructors, but with a private pure virtual
+	# so we can't create an instance of it
+	if($isConstructor and !$classNode-&gt;{CanBeInstanciated}) {
+
+	    # We still generate &quot;forwarder constructors&quot; for x_className though
+	    $methodCode .= &quot;    $xClassName(&quot;;
+	    my $i = 0;
+	    for my $arg (@argTypeList) {
+		$methodCode .= &quot;, &quot; if $i++;
+		$methodCode .= &quot;$arg x$i&quot;;
+	    }
+	    $methodCode .= &quot;) : $className(&quot;;
+	    $i = 0;
+	    for my $arg (@argTypeList) {
+		$methodCode .= &quot;, &quot; if $i++;
+		$methodCode .= &quot;x$i&quot;;
+	    }
+	    $methodCode .= &quot;) {}\n&quot;;
+
+	} else {
+
+	    $switchCode .= &quot;\tcase $methodNumber: &quot;;
+	    if ($flags =~ &quot;s&quot; || $isConstructor || $classNode-&gt;{NodeType} eq 'namespace') { # static, namespace or constructor
+	        $switchCode .= &quot;$xClassName\::&quot;;
+	    } else {
+	        $switchCode .= &quot;xself-&gt;&quot;
+	    }
+	    $switchCode .= &quot;x_$methodNumber(args);&quot;;
+	    $switchCode .= &quot;\tbreak;\n&quot;;
+
+	    $methodCode .= &quot;    ${extra}void x_$methodNumber\(Smoke::Stack x) $attr\{\n&quot;;
+	    my $cplusplusparams = join( &quot;, &quot;, @argTypeList );
+	    $methodCode .= &quot;\t// $name($cplusplusparams)\n&quot;;
+	    $methodCode .= &quot;\t&quot;;
+	
+	    if ($isConstructor) {
+
+	        $methodCode .= &quot;$xClassName* xret = new $xClassName(@castedArgList[0..$#argTypeList]);\n&quot;;
+	        #$m-&gt;{retnew} = 1;
+	        $methodCode .= &quot;\tx[0].s_class = (void*)xret;\n&quot;; # the return value, containing the new object
+	        $methodCode .= &quot;    }\n&quot;;
+
+	        # Now generate the actual constructor for x_className
+	        # (Simply a forwarder to the className constructor with the same args
+			if ( $flags =~ &quot;t&quot; ) {
+	        	$methodCode .= &quot;    explicit $xClassName(&quot;;
+			} else {
+	        	$methodCode .= &quot;    $xClassName(&quot;;
+			}
+	        my $i = 0;
+	        for my $arg (@argTypeList) {
+		    $methodCode .= &quot;, &quot; if $i++;
+                    if ($arg =~ s/\(\*\)/(* x$i)/) { # function pointer... need to insert argname inside
+                        $methodCode .= $arg;
+                    } else {
+		    $methodCode .= &quot;$arg x$i&quot;;
+                    }
+	        }
+	        $methodCode .= &quot;) : $className(&quot;;
+	        $i = 0;
+	        for my $arg (@argTypeList) {
+		    $methodCode .= &quot;, &quot; if $i++;
+		    $methodCode .= &quot;x$i&quot;;
+	        }
+	        $methodCode .= &quot;) {\n&quot;;
+
+	    } else {
+	        $methodCode .= $returnType . &quot; xret = &quot; if $returnType;
+	        $methodCode .= &quot;$this\-&gt;&quot; unless $isStatic || $classNode-&gt;{NodeType} eq 'namespace';
+		if ($className ne $main::globalSpaceClassName) {
+			if ($flags =~ &quot;=&quot;) {
+				# Setter method for a public instance variable
+				my $varName = $name;
+				$varName =~ /^set(\w)(.*)/;
+				my $ch = $1;
+				$ch =~ tr/A-Z/a-z/;
+				$varName = $ch . $2;
+				$methodCode .= &quot;$varName = @castedArgList[0..$#argTypeList];\n&quot;;
+			} else {
+		    	$methodCode .= &quot;$className\::$name(@castedArgList[0..$#argTypeList]);\n&quot;;
+			}
+		} elsif ($name =~ /^operator\s?\W+/) {
+		    ( my $op = $name ) =~ s/^operator(.*)$/$1/;
+		    if (scalar(@argTypeList) == 2) {
+                        if( $name =~ /^operator(?:\+\+|--)/ ) { # postfix increment/decrement
+                            $methodCode .= &quot;(@castedArgList[0])$op;\n&quot;;
+                        } else {
+			    $methodCode .= &quot;(@castedArgList[0] $op @castedArgList[1]);\n&quot;; # a + b
+                        }
+		    } elsif (scalar(@argTypeList) == 1) {
+			$methodCode .= &quot;$op(@castedArgList[0]);\n&quot;; # -a
+		    } else {
+			die &quot;shouldn't reach here!&quot;;
+		    }
+		} else {
+		    $methodCode .= &quot;$name(@castedArgList[0..$#argTypeList]);\n&quot;;
+		}
+	        $methodCode .= &quot;\t&quot; . $xretCode if $returnType;
+		# To avoid unused parameter warning, add this to void methods:
+		$methodCode .= &quot;\t(void)x; // noop (for compiler warning)\n&quot; unless $returnType;
+	    }
+	    $methodCode .= &quot;    }\n&quot;;
+    }
+
+
+	pop @argTypeList;
+	$methodNumber++;
+	$iterationCount--;
+    } # Iteration loop
+
+    return ( $methodCode, $switchCode );
+}
+
+
+sub generateEnum($$$)
+{
+    my( $classNode, $m, $addInclude ) = @_;	# input
+    my $methodCode = '';	# output
+    my $switchCode = '';	# output
+
+    my @heritage = kdocAstUtil::heritage($classNode);
+    my $className  = join( &quot;::&quot;, @heritage );
+    my $xClassName  = &quot;x_&quot; . join( &quot;__&quot;, @heritage );
+    
+	my $fullEnumType = &quot;$className\::&quot;. $m-&gt;{astNodeName};
+	checkIncludesForObject( $fullEnumType, $addInclude );
+
+    foreach my $enum ( @{$m-&gt;{ParamList}} ) {
+	my $enumName = $enum-&gt;{ArgName};
+	my $fullEnumName = &quot;$className\::$enumName&quot;;
+        die &quot;Invalid index for $fullEnumName: $classNode-&gt;{case}{$fullEnumName} instead of $methodNumber&quot; if $classNode-&gt;{case}{$fullEnumName} != $methodNumber;
+	$methodCode .= &quot;    static void x_$methodNumber(Smoke::Stack x) {\n&quot;;
+	$methodCode .= &quot;\tx[0].s_enum = (long)$fullEnumName;\n&quot;;
+        $methodCode .= &quot;    }\n&quot;;
+        $switchCode .= &quot;\tcase $methodNumber: $xClassName\::x_$methodNumber(args);\tbreak;\n&quot;;
+        $methodNumber++;
+    }
+
+    return ( $methodCode, $switchCode );
+}
+
+sub generateVar($$$)
+{
+    my( $classNode, $m, $addInclude ) = @_;	# input
+    my $methodCode = '';	# output
+    my $switchCode = '';	# output
+
+    my @heritage = kdocAstUtil::heritage($classNode);
+    my $className  = join( &quot;::&quot;, @heritage );
+    my $xClassName  = &quot;x_&quot; . join( &quot;__&quot;, @heritage );
+
+    my $name = $m-&gt;{astNodeName};
+    my $varType = $m-&gt;{Type};
+    $varType =~ s/static\s//;
+    $varType =~ s/const\s+(.*)\s*&amp;/$1/;
+    $varType =~ s/\s*$//;
+    my $fullName = &quot;$className\::$name&quot;;
+    my $this = $classNode-&gt;{BindingDerives} &gt; 0 ? &quot;this&quot; : &quot;xthis&quot;;
+
+    checkIncludesForObject( $varType, $addInclude );
+
+    die &quot;Invalid index for $fullName: $classNode-&gt;{case}{$fullName} instead of $methodNumber&quot; if $classNode-&gt;{case}{$fullName} != $methodNumber;
+	if ( $m-&gt;{Flags} =~ &quot;s&quot; ) {	
+    	$methodCode .= &quot;    static void x_$methodNumber(Smoke::Stack x) {\n        &quot;;
+    	$methodCode .= coerce_type('x[0]', $fullName, $varType, 1);
+    	$methodCode .= &quot;    }\n&quot;;
+    	$switchCode .= &quot;\tcase $methodNumber: $xClassName\::x_$methodNumber(args);\tbreak;\n&quot;;
+	} else {
+    	$methodCode .= &quot;    void x_$methodNumber(Smoke::Stack x) {\n        &quot;;
+    	$methodCode .= coerce_type('x[0]', &quot;$this-&gt;$name&quot;, $varType, 1);
+    	$methodCode .= &quot;    }\n&quot;;
+    	$switchCode .= &quot;\tcase $methodNumber: xself-&gt;x_$methodNumber(args);\tbreak;\n&quot;;
+	}
+
+    $methodNumber++;
+
+    return ( $methodCode, $switchCode );
+}
+
+sub generateEnumCast($)
+{
+    my( $classNode ) = @_;
+    my $methodCode = '';
+    return unless keys %{$classNode-&gt;{enumerations}};
+    $methodCode .= &quot;    static void xenum_operation(Smoke::EnumOperation xop, Smoke::Index xtype, void *&amp;xdata, long &amp;xvalue) {\n&quot;;
+    $methodCode .= &quot;\tswitch(xtype) {\n&quot;;
+    for my $enum (values %{$classNode-&gt;{enumerations}}) {
+	
+	# Hack - this shouldn't be needed here - deprecated enums
+	next if ($enum eq 'KStatusBar::BarStatus' 
+				or $enum eq 'KMdi::AddWindowFlags' 
+				or $enum eq 'KToolBar::BarStatus' 
+				or $enum eq 'KMimeType::Format:: compression : 4');
+	
+	my $type = findTypeEntry($enum);
+	$methodCode .= &quot;\t  case $type-&gt;{index}: //$enum\n&quot;;
+	$methodCode .= &quot;\t    switch(xop) {\n&quot;;
+	$methodCode .= &quot;\t      case Smoke::EnumNew:\n&quot;;
+	$methodCode .= &quot;\t\txdata = (void*)new $enum;\n&quot;;
+	$methodCode .= &quot;\t\tbreak;\n&quot;;
+	$methodCode .= &quot;\t      case Smoke::EnumDelete:\n&quot;;	# unnecessary
+	$methodCode .= &quot;\t\tdelete ($enum*)xdata;\n&quot;;
+	$methodCode .= &quot;\t\tbreak;\n&quot;;
+	$methodCode .= &quot;\t      case Smoke::EnumFromLong:\n&quot;;
+	$methodCode .= &quot;\t\t*($enum*)xdata = ($enum)xvalue;\n&quot;;
+	$methodCode .= &quot;\t\tbreak;\n&quot;;
+	$methodCode .= &quot;\t      case Smoke::EnumToLong:\n&quot;;
+	$methodCode .= &quot;\t\txvalue = (long)*($enum*)xdata;\n&quot;;
+	$methodCode .= &quot;\t\tbreak;\n&quot;;
+	$methodCode .= &quot;\t    }\n&quot;;
+	$methodCode .= &quot;\t    break;\n&quot;;
+    }
+    $methodCode .= &quot;\t}\n&quot;;
+    $methodCode .= &quot;    }\n&quot;;
+
+    return $methodCode;
+} 
+
+## Called by writeClassDoc
+sub generateAllMethods
+{
+    my ($classNode) = @_;
+    my $methodCode = '';
+    my $switchCode = '';
+    $methodNumber = 0;
+
+    #my $className = $classNode-&gt;{astNodeName};
+    my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+    my $xClassName = &quot;x_&quot; . join( &quot;__&quot;, kdocAstUtil::heritage($classNode) );
+    my $isGlobalSpace = ($xClassName eq (&quot;x_&quot;.$main::globalSpaceClassName));
+    my $sourcename = $classNode-&gt;{Source}-&gt;{astNodeName};
+   
+    if ( $sourcename !~ s!.*($headerSubdirectories)(.*)!$1$2!m ) {
+    	$sourcename =~ s!.*/(.*)!$1!m;
+	}
+    die &quot;Empty source name for $classNode-&gt;{astNodeName}&quot; if ( $sourcename eq '' );
+
+    my %addInclude = ( $sourcename =&gt; 1 );
+
+    if (!$isGlobalSpace) {
+        if($classNode-&gt;{NodeType} eq 'namespace') {
+           $switchCode .= &quot;    (void)obj;\n&quot;;
+            $methodCode .= &quot;public:\n&quot;;
+        	my $s;
+        	for my $sn( @{$classNode-&gt;{Sources}} ) {
+    		if ( ($s = $sn-&gt;{astNodeName}) !~ s!.*($headerSubdirectories)(.*)!$1$2!m ) {
+    			$s =~ s!.*/(.*)!$1!m;
+			}
+			$addInclude{ $s } = 1;
+        	}
+         } elsif(! $classNode-&gt;{BindingDerives}) {
+            $methodCode .= &quot;private:\n&quot;;
+            $methodCode .= &quot;    $className *xthis;\n&quot;;
+            $methodCode .= &quot;public:\n&quot;;
+            $methodCode .= &quot;    $xClassName\(void *x) : xthis(($className*)x) {}\n&quot;;
+            $switchCode .= &quot;    $xClassName xtmp(obj), *xself = &xtmp;\n&quot;;
+        } else {
+            $switchCode .= &quot;    $xClassName *xself = ($xClassName*)obj;\n&quot;;
+            $methodCode .= &quot;public:\n&quot;;
+        }
+    } else {
+        my $s;
+        for my $sn( @{$classNode-&gt;{Sources}} ) {
+    	if ( ($s = $sn-&gt;{astNodeName}) !~ s!.*($headerSubdirectories)(.*)!$1$2!m ) {
+    		$s =~ s!.*/(.*)!$1!m;
+		}
+		$addInclude{ $s } = 1;
+        }
+	$methodCode .= &quot;public:\n&quot;;
+	$switchCode .= &quot;    (void) obj;\n&quot;;
+    }
+    $switchCode .= &quot;    switch(xi) {\n&quot;;
+
+    # Do all enums first
+    Iter::MembersByType ( $classNode, undef,
+			  sub {	my ($classNode, $methodNode ) = @_;
+				
+	if ( $methodNode-&gt;{NodeType} eq 'enum' ) {
+	    my ($meth, $swit) = generateEnum( $classNode, $methodNode, \%addInclude );
+	    $methodCode .= $meth;
+	    $switchCode .= $swit;
+	}
+				}, undef );
+
+    # Then all static vars
+    Iter::MembersByType ( $classNode, undef,
+			  sub {	my ($classNode, $methodNode ) = @_;
+				
+	if ( $methodNode-&gt;{NodeType} eq 'var' ) {
+	    my ($meth, $swit) = generateVar( $classNode, $methodNode, \%addInclude );
+	    $methodCode .= $meth;
+	    $switchCode .= $swit;
+	}
+				}, undef );
+
+    # Then all methods
+    Iter::MembersByType ( $classNode, undef,
+			  sub {	my ($classNode, $methodNode ) = @_;
+
+        if ( $methodNode-&gt;{NodeType} eq 'method' ) {
+	    my ($meth, $swit) = generateMethod( $classNode, $methodNode, \%addInclude );
+	    $methodCode .= $meth;
+	    $switchCode .= $swit;
+	}
+			      }, undef );
+
+    # Virtual methods
+    if ($classNode-&gt;{BindingDerives}) {
+	my %virtualMethods;
+	allVirtualMethods( $classNode, \%virtualMethods );
+
+	for my $sig (sort keys %virtualMethods) {
+            my ($meth) = generateVirtualMethod( $classNode, $sig, $virtualMethods{$sig}{method}, $virtualMethods{$sig}{class}, \%addInclude );
+	    $methodCode .= $meth;
+	}
+    }
+
+    $methodCode .= generateEnumCast( $classNode );
+
+    # Destructor
+    # &quot;virtual&quot; is useless, if the base class has a virtual destructor then the x_* class too.
+    #if($classNode-&gt;{HasVirtualDestructor} and $classNode-&gt;{HasDestructor}) {
+    #	$methodCode .= &quot;    virtual ~$xClassName() {}\n&quot;;
+    #}
+    # We generate a dtor though, because we might want to add stuff into it
+    if ( !$isGlobalSpace &amp;&amp; $classNode-&gt;{NodeType} ne 'namespace' ) {
+        $methodCode .= &quot;    ~$xClassName() { ${libname}_Smoke-&gt;binding-&gt;deleted($classNode-&gt;{ClassIndex}, (void*)this); }\n&quot;;
+    }
+
+    if ($classNode-&gt;{CanBeInstanciated} and $classNode-&gt;{HasPublicDestructor}) {
+	die &quot;$className destructor: methodNumber=$methodNumber != case entry=&quot;.$classNode-&gt;{case}{&quot;~$className()&quot;}.&quot;\n&quot;
+	     if $methodNumber != $classNode-&gt;{case}{&quot;~$className()&quot;};
+	$switchCode .= &quot;\tcase $methodNumber: delete ($className*)xself;\tbreak;\n&quot;;
+	$methodNumber++;
+    }
+
+    $switchCode .= &quot;    }\n&quot;;
+    return ( $methodCode, $switchCode, \%addInclude );
+}
+
+# Return 0 if the class has no virtual dtor, 1 if it has, 2 if it's private
+sub hasVirtualDestructor($)
+{
+    my ( $classNode ) = @_;
+    my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+    return if ( $skippedClasses{$className} );
+
+    my $parentHasIt;
+    # Look at ancestors, and (recursively) call hasVirtualDestructor for each
+    # It's enough to have one parent with a prot/public virtual dtor
+    Iter::Ancestors( $classNode, $rootnode, undef, undef, sub {
+                     my $vd = hasVirtualDestructor( $_[0] );
+                     $parentHasIt = $vd unless $parentHasIt &gt; $vd;
+                    } );
+    return $parentHasIt if $parentHasIt; # 1 or 2
+
+    # Now look in $classNode - including private methods
+    my $doPrivate = $main::doPrivate;
+    $main::doPrivate = 1;
+    my $result;
+    Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+			return unless( $m-&gt;{NodeType} eq &quot;method&quot; &amp;&amp; $m-&gt;{ReturnType} eq '~' );
+
+			if ( $m-&gt;{Flags} =~ /[vp]/ ) {
+			    if ( $m-&gt;{Access} =~ /private/ ) {
+				$result=2; # private virtual
+			    } else {
+				$result=1; # [protected or public] virtual
+			    }
+			}
+		},
+		undef
+	);
+    $main::doPrivate = $doPrivate;
+    $result=0 if (!defined $result);
+    return $result;
+}
+
+=head2 allVirtualMethods
+
+	Parameters: class node, dict
+
+	Adds to the dict, for all method nodes that are virtual, in this class and in parent classes :
+        {method} the method node, {class} the class node (the one where the virtual is implemented)
+
+=cut
+
+sub allVirtualMethods($$)
+{
+    my ( $classNode, $virtualMethods ) = @_;
+    my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+    return if ( $skippedClasses{$className} );
+
+    # Look at ancestors, and (recursively) call allVirtualMethods for each
+    # This is done first, so that virtual methods that are reimplemented as 'private'
+    # can be removed from the list afterwards (below)
+    Iter::Ancestors( $classNode, $rootnode, undef, undef, sub {
+			 allVirtualMethods( @_[0], $virtualMethods );
+		     }, undef
+		   );
+
+    # Now look for virtual methods in $classNode - including private ones
+    my $doPrivate = $main::doPrivate;
+    $main::doPrivate = 1;
+    Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+			# Only interested in methods, and skip destructors
+			return unless( $m-&gt;{NodeType} eq &quot;method&quot; &amp;&amp; $m-&gt;{ReturnType} ne '~' );
+
+			my $signature = methodSignature( $m, $#{$m-&gt;{ParamList}} );
+			print STDERR $signature . &quot; ($m-&gt;{Access})\n&quot; if ($debug);
+
+			# A method is virtual if marked as such (v=virtual p=pure virtual)
+			# or if a parent method with same signature was virtual
+			if ( $m-&gt;{Flags} =~ /[vp]/ or defined $virtualMethods-&gt;{$signature} ) {
+			    if ( $m-&gt;{Access} =~ /private/ ) {
+				if ( defined $virtualMethods-&gt;{$signature} ) { # remove previously defined
+				    delete $virtualMethods-&gt;{$signature};
+				}
+				# else, nothing, just ignore private virtual method
+			    } else {
+				$virtualMethods-&gt;{$signature}{method} = $m;
+				$virtualMethods-&gt;{$signature}{class} = $classNode;
+			    }
+			}
+		},
+		undef
+	);
+    $main::doPrivate = $doPrivate;
+}
+
+# Known typedef? If so, apply it.
+sub applyTypeDef($)
+{
+    my $type = shift;
+    # Parse 'const' in front of it, and '*' or '&amp;' after it
+    my $prefix = $type =~ s/^const\s+// ? 'const ' : '';
+    my $suffix = $type =~ s/\s*([\&amp;\*]+)$// ? $1 : '';
+
+    if (exists $typedeflist{$type}) {
+	return $prefix.$typedeflist{$type}.$suffix;
+    }
+    return $prefix.$type.$suffix;
+}
+
+# Register type ($1) into %allTypes if not already there
+sub registerType($$) {
+    my $type = shift;
+    #print &quot;registerType: $type\n&quot; if ($debug);
+
+    $type =~ s/\s+const$//; # for 'char* const'
+    $type =~ s/\s+const\s*\*$/\*/; # for 'char* const*'
+	
+	$type =~ s/(&lt;[^&gt;]*)\s+([^&gt;]*&gt;)/$1$2/; # Remove embedded space from template types, such as
+										  # 'QMap&lt;QCString, DCOPRef&gt;'
+
+    return if ( $type eq 'void' or $type eq '' or $type eq '~' );
+    die if ( $type eq '...' );     # ouch
+
+    # Let's register the real type, not its known equivalent
+    #$type = applyTypeDef($type);
+
+    # Enum _value_ -&gt; get corresponding type
+    if (exists $enumValueToType{$type}) {
+	$type = $enumValueToType{$type};
+    }
+
+    # Already in allTypes
+    if(exists $allTypes{$type}) {
+        return;
+    }
+
+    die if $type eq 'QTextEdit::UndoRedoInfo::Type';
+    die if $type eq '';
+
+    my $realType = $type;
+
+    # Look for references (&amp;) and pointers (* or **)  - this will not handle *&amp; correctly.
+    # We do this parsing here because both the type list and iterproto need it
+    if($realType =~ s/&amp;$//) {
+	$allTypes{$type}{typeFlags} = 'Smoke::tf_ref';
+    }
+    elsif($realType ne 'void*' &amp;&amp; $realType =~ s/\*$//) {
+	$allTypes{$type}{typeFlags} = 'Smoke::tf_ptr';
+    }
+    else {
+	$allTypes{$type}{typeFlags} = 'Smoke::tf_stack';
+    }
+
+    if ( $realType =~ s/^const\s+// ) { # Remove 'const'
+	$allTypes{$type}{typeFlags} .= ' | Smoke::tf_const';
+    }
+
+    # Apply typedefs, and store the resulting type.
+    # For instance, if $type was Q_UINT16&amp;, realType will be ushort
+    $allTypes{$type}{realType} = applyTypeDef( $realType );
+
+    # In the first phase we only create entries into allTypes.
+    # The values (indexes) are calculated afterwards, once the list is full.
+    $allTypes{$type}{index} = -1;
+    #print STDERR &quot;Register $type. Realtype: $realType\n&quot; if($debug);
+}
+
+# Get type from %allTypes
+# This returns a hash with {index}, {isEnum}, {typeFlags}, {realType}
+# (and {typeId} after the types array is written by writeSmokeDataFile)
+sub findTypeEntry($) {
+    my $type = shift;
+    my $typeIndex = -1;
+    $type =~ s/\s+const$//; # for 'char* const'
+    $type =~ s/\s+const\s*\*$/\*/; # for 'char* const*'
+
+	$type =~ s/(&lt;[^&gt;]*)\s+([^&gt;]*&gt;)/$1$2/; # Remove embedded space from template types, such as
+										  # 'QMap&lt;QCString, DCOPRef&gt;'
+
+    return undef if ( $type =~ '~' or $type eq 'void' or $type eq '' );
+
+    # Enum _value_ -&gt; get corresponding type
+    if (exists $enumValueToType{$type}) {
+	$type = $enumValueToType{$type};
+    }
+
+    die &quot;type not known: $type&quot; unless defined $allTypes{$type};
+    return $allTypes{ $type };
+}
+
+# List of all super-classes for a given class
+sub superclass_list($)
+{
+    my $classNode = shift;
+    my @super;
+    Iter::Ancestors( $classNode, $rootnode, undef, undef, sub {
+			push @super, @_[0];
+			push @super, superclass_list( @_[0] );
+		     }, undef );
+    return @super;
+}
+
+# Store the {case} dict in the class Node (method signature -&gt; index in the &quot;case&quot; switch)
+# This also determines which methods should NOT be in the switch, and sets {SkipFromSwitch} for them
+sub prepareCaseDict($) {
+
+     my $classNode = shift;
+     my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+     $classNode-&gt;AddProp(&quot;case&quot;, {});
+     my $methodNumber = 0;
+
+     # First look at all enums for this class
+     Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	next unless $m-&gt;{NodeType} eq 'enum';
+	foreach my $val ( @{$m-&gt;{ParamList}} ) {
+	    my $fullEnumName = &quot;$className\::&quot;.$val-&gt;{ArgName};
+	    print STDERR &quot;Enum: $fullEnumName -&gt; case $methodNumber\n&quot; if ($debug);
+	    $classNode-&gt;{case}{$fullEnumName} = $methodNumber;
+	    $enumValueToType{$fullEnumName} = &quot;$className\::$m-&gt;{astNodeName}&quot;;
+	    $methodNumber++;
+	}
+		      }, undef );
+
+     # Check for vars
+     Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	    next unless $m-&gt;{NodeType} eq 'var';
+	    my $name = &quot;$className\::&quot;.$m-&gt;{astNodeName};			
+	    print STDERR &quot;Var: $name -&gt; case $methodNumber\n&quot; if ($debug);
+	    $classNode-&gt;{case}{$name} = $methodNumber;
+	    $methodNumber++;
+
+		      }, undef );
+
+	 my %const_methods = ();
+     # Now look at all const methods for this class, in order to use
+	 # them in preference to any otherwise identical non-const method
+     Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+	
+		next unless $m-&gt;{NodeType} eq 'method';
+		my @args = @{ $m-&gt;{ParamList} };
+	    my $sig = methodSignature( $m, $#args );
+		if ( $sig =~ /(.*) const$/ ) {
+			$const_methods{$1} = 1;
+		}
+		
+		      }, undef );
+
+     # Now look at all methods for this class
+     Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	next unless $m-&gt;{NodeType} eq 'method';
+	my $name = $m-&gt;{astNodeName};
+        my $isConstructor = ($name eq $classNode-&gt;{astNodeName} );
+	if ($isConstructor and ($m-&gt;{ReturnType} eq '~')) # destructor
+	{
+	    # Remember whether we'll generate a switch entry for the destructor
+	    $m-&gt;{SkipFromSwitch} = 1 unless ($classNode-&gt;{CanBeInstanciated} and $classNode-&gt;{HasPublicDestructor});
+	    next;
+	}
+
+        # Don't generate bindings for protected methods (incl. signals) if
+        # we're not deriving from the C++ class. Only take public and public_slots
+        my $ok = ( $classNode-&gt;{BindingDerives} or $m-&gt;{Access} =~ /public/ ) ? 1 : 0;
+
+        # Don't generate bindings for pure virtuals - we can't call them ;)
+        $ok = 0 if ( $ok &amp;&amp; $m-&gt;{Flags} =~ &quot;p&quot; );
+
+        # Bugfix for Qt-3.0.4: those methods are NOT implemented (report sent).
+        $ok = 0 if ( $ok &amp;&amp; $className eq 'QLineEdit' &amp;&amp; ( $name eq 'setPasswordChar' || $name eq 'passwordChar' ) );
+        $ok = 0 if ( $ok &amp;&amp; $className eq 'QWidgetItem' &amp;&amp; $name eq 'widgetSizeHint' );
+
+        if ( !$ok )
+        {
+	    #print STDERR &quot;Skipping $className\::$name\n&quot; if ($debug);
+	    $m-&gt;{SkipFromSwitch} = 1;
+	    next;
+	}
+
+	my @args = @{ $m-&gt;{ParamList} };
+	my $sig = methodSignature( $m, $#args );
+	if ( $const_methods{$sig} &amp;&amp; $m-&gt;{Flags} !~ &quot;v&quot; ) {
+		# If there is a method which just differs from another by 'constness',
+		# then ignore the non-const version
+	    $m-&gt;{SkipFromSwitch} = 1;
+	    next;
+	}
+	my $last = $m-&gt;{FirstDefaultParam};
+	$last = scalar @args unless defined $last;
+	my $iterationCount = scalar(@args) - $last;
+	while($iterationCount &gt;= 0) {
+	    $sig = methodSignature( $m, $#args );
+	    $classNode-&gt;{case}{$sig} = $methodNumber;
+	    #print STDERR &quot;prepareCaseDict: registered case number $methodNumber for $sig in $className()\n&quot; if ($debug);
+	    pop @args;
+	    $iterationCount--;
+	    $methodNumber++;
+	}
+		    }, undef );
+
+    # Add the destructor, at the end
+    if ($classNode-&gt;{CanBeInstanciated} and $classNode-&gt;{HasPublicDestructor}) {
+        $classNode-&gt;{case}{&quot;~$className()&quot;} = $methodNumber;
+	# workaround for ~Sub::Class() being seen as Sub::~Class()
+	$classNode-&gt;{case}{&quot;~$classNode-&gt;{astNodeName}()&quot;} = $methodNumber;
+	#print STDERR &quot;prepareCaseDict: registered case number $methodNumber for ~$className()\n&quot; if ($debug);
+    }
+}
+
+=head2
+	Write out the smokedata.cpp file containing all the arrays.
+=cut
+
+sub writeSmokeDataFile($) {
+    my $rootnode = shift;
+
+    # Make list of classes
+    my %allIncludes; # list of all header files for all classes
+    my @classlist;
+    push @classlist, &quot;&quot;; # Prepend empty item for &quot;no class&quot;
+    my %enumclasslist;
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = $_[0];
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	
+	push @classlist, $className;
+	$enumclasslist{$className}++ if keys %{$classNode-&gt;{enumerations}};
+	$classNode-&gt;{ClassIndex} = $#classlist;
+	addIncludeForClass( $classNode, \%allIncludes, undef );
+    } );
+
+    my %classidx = do { my $i = 0; map { $_ =&gt; $i++ } @classlist };
+
+    my $file = &quot;$outputdir/smokedata.cpp&quot;;
+    open OUT, &quot;&gt;$file&quot; or die &quot;Couldn't create $file\n&quot;;
+
+    foreach my $incl (sort{ 
+                           return 1 if $a=~/qmotif/;  # move qmotif* at bottom (they include dirty X11 headers)
+                           return -1 if $b=~/qmotif/;
+			   return -1 if substr($a,0,1) eq 'q' and substr($b,0,1) ne 'q'; # move Qt headers on top
+			   return 1 if substr($a,0,1) ne 'q' and substr($b,0,1) eq 'q';			   
+                           $a cmp $b
+                          } keys %allIncludes) {
+	die if $incl eq '';
+        if( $incl eq &quot;kxmlguifactory.h&quot; ) {
+            print OUT &quot;#include &lt;kxmlguiclient.h&gt;\n&quot;;
+        }
+	print OUT &quot;#include &lt;$incl&gt;\n&quot;;
+    }	
+
+    print OUT &quot;\n&quot;;
+    print OUT &quot;#include &lt;smoke.h&gt;\n\n&quot;;
+    print OUT &quot;#include &lt;qt_smoke.h&gt;\n\n&quot;;
+
+    # gcc optimizes this method like crazy. switch() is godly
+    print OUT &quot;static void *${libname}_cast(void *xptr, Smoke::Index from, Smoke::Index to) {\n&quot;;
+    print OUT &quot;    switch(from) {\n&quot;;
+
+    print STDERR &quot;Writing ${libname}_cast function\n&quot; if ($debug);
+
+    # Prepare descendants information for each class
+    my %descendants; # classname -&gt; list of descendant nodes
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	# Get _all_ superclasses (up any number of levels)
+	# and store that $classNode is a descendant of $s
+	my @super = superclass_list($classNode);
+	for my $s (@super) {
+	    my $superClassName = join( &quot;::&quot;, kdocAstUtil::heritage($s) );
+	    Ast::AddPropList( \%descendants, $superClassName, $classNode );
+	}
+    } );
+
+    # Iterate over all classes, to write the xtypecast function
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	# @super will contain superclasses, the class itself, and all descendants
+	my @super = superclass_list($classNode);
+	push @super, $classNode;
+        if ( defined $descendants{$className} ) {
+	    push @super, @{$descendants{$className}};
+	}
+	my $cur = $classidx{$className};
+	
+	return if $classNode-&gt;{NodeType} eq 'namespace';
+
+	print OUT &quot;      case $cur:\t//$className\n&quot;;
+	print OUT &quot;\tswitch(to) {\n&quot;;
+	$cur = -1;
+	my %casevalues;
+	for my $s (@super) {
+		my $superClassName = join( &quot;::&quot;, kdocAstUtil::heritage($s) );
+		next if !defined $classidx{$superClassName}; # inherits from unknown class, see below
+		next if $classidx{$superClassName} == $cur;    # shouldn't happen in Qt
+		if (!defined $s) {
+			die &quot;problem with $className missing parent&quot;
+		}
+		next if $s-&gt;kdocAstUtil::inheritsAsVirtual($classNode); # can't cast from a virtual base class
+		$cur = $classidx{$superClassName}; # KDE has MI with diamond shaped cycles (cf. KXMLGUIClient)
+		next if $casevalues{$cur};         # ..so skip any duplicate parents
+		print OUT &quot;\t  case $cur: return (void*)($superClassName*)($className*)xptr;\n&quot;;
+		$casevalues{$cur} = 1;
+	}
+	print OUT &quot;\t  default: return xptr;\n&quot;;
+	print OUT &quot;\t}\n&quot;;
+    } );
+    print OUT &quot;      default: return xptr;\n&quot;;
+    print OUT &quot;    }\n&quot;;
+    print OUT &quot;}\n\n&quot;;
+
+
+    # Write inheritance array
+    # Imagine you have &quot;Class : public super1, super2&quot;
+    # The inheritlist array will get 3 new items: super1, super2, 0
+    my %inheritfinder;  # key = (super1, super2) -&gt; data = (index in @inheritlist). This one allows reuse.
+    my %classinherit;   # we store that index in %classinherit{className}
+    # We don't actually need to store inheritlist in memory, we write it
+    # directly to the file. We only need to remember its current size.
+    my $inheritlistsize = 1;
+
+    print OUT &quot;// Group of class IDs (0 separated) used as super class lists.\n&quot;;
+    print OUT &quot;// Classes with super classes have an index into this array.\n&quot;;
+    print OUT &quot;static short ${libname}_inheritanceList[] = {\n&quot;;
+    print OUT &quot;\t0,\t// 0: (no super class)\n&quot;;
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	
+	print STDERR &quot;inheritanceList: looking at $className\n&quot; if ($debug);
+
+	# Make list of direct ancestors
+	my @super;
+	Iter::Ancestors( $classNode, $rootnode, undef, undef, sub {
+			     my $superClassName = join( &quot;::&quot;, kdocAstUtil::heritage($_[0]) );
+			     push @super, $superClassName;
+		    }, undef );
+	# Turn that into a list of class indexes
+	my $key = '';
+	foreach my $superClass( @super ) {
+	    if (defined $classidx{$superClass}) {
+		$key .= ', ' if ( length $key &gt; 0 );
+		$key .= $classidx{$superClass};
+	    }
+	}
+	if ( $key ne '' ) {
+	    if ( !defined $inheritfinder{$key} ) {
+		print OUT &quot;\t&quot;;
+		my $index = $inheritlistsize; # Index of first entry (for this group) in inheritlist
+		foreach my $superClass( @super ) {
+		    if (defined $classidx{$superClass}) {
+			print OUT &quot;$classidx{$superClass}, &quot;;
+			$inheritlistsize++;
+		    }
+		}
+		$inheritlistsize++;
+		my $comment = join( &quot;, &quot;, @super );
+		print OUT &quot;0,\t// $index: $comment\n&quot;;
+		$inheritfinder{$key} = $index;
+	    }
+	    $classinherit{$className} = $inheritfinder{$key};
+	} else { # No superclass
+	    $classinherit{$className} = 0;
+	}
+    } );
+    print OUT &quot;};\n\n&quot;;
+
+
+    print OUT &quot;// These are the xenum functions for manipulating enum pointers\n&quot;;
+    for my $className (keys %enumclasslist) {
+	my $c = $className;
+	$c =~ s/::/__/g;
+	print OUT &quot;void xenum_$c\(Smoke::EnumOperation, Smoke::Index, void*&amp;, long&amp;);\n&quot;;
+    }
+    print OUT &quot;\n&quot;;
+    print OUT &quot;// Those are the xcall functions defined in each x_*.cpp file, for dispatching method calls\n&quot;;
+    my $firstClass = 1;
+    for my $className (@classlist) {
+	if ($firstClass) {
+	    $firstClass = 0;
+	    next;
+	}
+	my $c = $className;   # make a copy
+	$c =~ s/::/__/g;
+	print OUT &quot;void xcall_$c\(Smoke::Index, void*, Smoke::Stack);\n&quot;;
+    }
+    print OUT &quot;\n&quot;;
+
+    # Write class list afterwards because it needs offsets to the inheritance array.
+    print OUT &quot;// List of all classes\n&quot;;
+    print OUT &quot;// Name, index into inheritanceList, method dispatcher, enum dispatcher, class flags\n&quot;;
+    print OUT &quot;static Smoke::Class ${libname}_classes[] = {\n&quot;;
+    my $firstClass = 1;
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+
+	if ($firstClass) {
+	    $firstClass = 0;
+	    print OUT &quot;\t{ 0L, 0, 0, 0, 0 }, \t// 0 (no class)\n&quot;;
+	}
+	my $c = $className;
+	$c =~ s/::/__/g;
+	my $xcallFunc = &quot;xcall_$c&quot;;
+	my $xenumFunc = &quot;0&quot;;
+	$xenumFunc = &quot;xenum_$c&quot; if exists $enumclasslist{$className};
+	die &quot;problem with $className&quot; unless defined $classinherit{$className};
+
+	my $xClassFlags = 0;
+	$xClassFlags .= &quot;|Smoke::cf_constructor&quot; if $classNode-&gt;{CanBeInstanciated}; # correct?
+	$xClassFlags .= &quot;|Smoke::cf_deepcopy&quot; if $classNode-&gt;{CanBeCopied}; # HasCopyConstructor would be wrong (when it's private)
+	$xClassFlags .= &quot;|Smoke::cf_virtual&quot; if hasVirtualDestructor($classNode) == 1;
+	# $xClassFlags .= &quot;|Smoke::cf_undefined&quot; if ...;
+	$xClassFlags =~ s/0\|//; # beautify
+	print OUT &quot;\t{ \&quot;$className\&quot;, $classinherit{$className}, $xcallFunc, $xenumFunc, $xClassFlags }, \t//$classidx{$className}\n&quot;;
+    } );
+    print OUT &quot;};\n\n&quot;;
+
+
+    print OUT &quot;// List of all types needed by the methods (arguments and return values)\n&quot;;
+    print OUT &quot;// Name, class ID if arg is a class, and TypeId\n&quot;;
+    print OUT &quot;static Smoke::Type ${libname}_types[] = {\n&quot;;
+    my $typeCount = 0;
+    $allTypes{''}{index} = 0; # We need an &quot;item 0&quot;
+    for my $type (sort keys %allTypes) {
+	$allTypes{$type}{index} = $typeCount;      # Register proper index in allTypes
+	if ( $typeCount == 0 ) {
+	    print OUT &quot;\t{ 0, 0, 0 },\t//0 (no type)\n&quot;;
+	    $typeCount++;
+	    next;
+	}
+	my $isEnum = $allTypes{$type}{isEnum};
+	my $typeId;
+	my $typeFlags = $allTypes{$type}{typeFlags};
+	my $realType = $allTypes{$type}{realType};
+	die &quot;$type&quot; if !defined $typeFlags;
+#	die &quot;$realType&quot; if $realType =~ /\(/;
+	if ($realType =~ /\(/) {
+		print &quot;FATAL ERROR $type $realType\n&quot;;
+	}
+	# First write the name
+	print OUT &quot;\t{ \&quot;$type\&quot;, &quot;;
+	# Then write the classId (and find out the typeid at the same time)
+	if(exists $classidx{$realType}) { # this one first, we want t_class for QBlah*
+	    $typeId = 't_class';
+	    print OUT &quot;$classidx{$realType}, &quot;;
+	}
+	elsif($type =~ /&amp;$/ || $type =~ /\*$/) {
+	    $typeId = 't_voidp';
+	    print OUT &quot;0, &quot;; # no classId
+	}
+	elsif($isEnum || $allTypes{$realType}{isEnum}) {
+	    $typeId = 't_enum';
+	    if($realType =~ /(.*)::/) {
+		my $c = $1;
+		if($classidx{$c}) {
+		    print OUT &quot;$classidx{$c}, &quot;;
+		} else {
+		    print OUT &quot;0 /* unknown class $c */, &quot;;
+		}
+	    } else {
+		print OUT &quot;0 /* unknown $realType */, &quot;; # no classId
+	    }
+	}
+	else {
+	    $typeId = $typeunion{$realType};
+	    if (defined $typeId) {
+		$typeId =~ s/s_/t_/; # from s_short to t_short for instance
+	    }
+	    else {
+		# Not a known class - ouch, this happens quite a lot
+		# (private classes, typedefs, template-based types, etc)
+		if ( $skippedClasses{$realType} ) {
+#		    print STDERR &quot;$realType has been skipped, using t_voidp for it\n&quot;;
+		} else {
+		    unless( $realType =~ /&lt;/ ) { # Don't warn for template stuff...
+			print STDERR &quot;$realType isn't a known type (type=$type)\n&quot;;
+		    }
+		}
+		$typeId = 't_voidp'; # Unknown -&gt; map to a void *
+	    }
+	    print OUT &quot;0, &quot;; # no classId
+	}
+	# Then write the flags
+	die &quot;$type&quot; if !defined $typeId;
+	print OUT &quot;Smoke::$typeId | $typeFlags },&quot;;
+	print OUT &quot;\t//$typeCount\n&quot;;
+	$typeCount++;
+	# Remember it for coerce_type
+	$allTypes{$type}{typeId} = $typeId;
+    }
+    print OUT &quot;};\n\n&quot;;
+
+
+    my %arglist; # registers the needs for argumentList (groups of type ids)
+    my %methods;
+    # Look for all methods and all enums, in all classes
+    # And fill in methods and arglist. This loop writes nothing to OUT.
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	print STDERR &quot;writeSmokeDataFile: arglist: looking at $className\n&quot; if ($debug);
+
+	Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	my $methName = $m-&gt;{astNodeName};
+	# For destructors, get a proper signature that includes the '~'
+	if ( $m-&gt;{ReturnType} eq '~' )
+	{
+	    $methName = '~' . $methName ;
+	    # Let's even store that change, otherwise we have to do it many times
+	    $m-&gt;{astNodeName} = $methName;
+	}
+	
+	if( $m-&gt;{NodeType} eq &quot;enum&quot; ) {
+
+	    foreach my $enum ( @{$m-&gt;{ParamList}} ) {
+		my $enumName = $enum-&gt;{ArgName};
+	        $methods{$enumName}++;
+	    }
+
+	} elsif ( $m-&gt;{NodeType} eq 'var' ) {
+		$methods{$m-&gt;{astNodeName}}++;
+	} elsif( $m-&gt;{NodeType} eq &quot;method&quot; ) {
+
+	    $methods{$methName}++;
+	    my @protos;
+	    makeprotos(\%classidx, $m, \@protos);
+
+	    #print &quot;made @protos from $className $methName $m-&gt;{Signature})\n&quot; if ($debug);
+	    for my $p (@protos) {
+		$methods{$p}++;
+		my $argcnt = 0;
+		$argcnt = length($1) if $p =~ /([\$\#\?]+)/;
+		my $sig = methodSignature($m, $argcnt-1);
+		# Store in a class hash named &quot;proto&quot;, a proto+signature =&gt; method association
+		$classNode-&gt;{proto}{$p}{$sig} = $m;
+		#$classNode-&gt;{signature}{$sig} = $p;
+		# There's probably a way to do this better, but this is the fastest way
+		# to get the old code going: store classname into method
+		$m-&gt;{class} = $className;
+	    }
+
+	    my $firstDefaultParam = $m-&gt;{FirstDefaultParam};
+	    $firstDefaultParam = scalar(@{ $m-&gt;{ParamList} }) unless defined $firstDefaultParam;
+	    my $argNames = '';
+	    my $args = '';
+	    for(my $i = 0; $i &lt; @{ $m-&gt;{ParamList} }; $i++) {
+		$args .= ', ' if $i;
+		$argNames .= ', ' if $i;
+		my $argType = $m-&gt;{ParamList}[$i]{ArgType};
+		my $typeEntry = findTypeEntry( $argType );
+		$args .= defined $typeEntry ? $typeEntry-&gt;{index} : 0;
+		$argNames .= $argType;
+
+		if($i &gt;= ($firstDefaultParam - 1)) {
+		    #print &quot;arglist entry: $args\n&quot;;
+		    $arglist{$args} = $argNames;
+		}
+		
+	    }
+	    # create an entry for e.g. &quot;arg0,arg1,arg2&quot; where argN is index in allTypes of type for argN
+	    # The value, $argNames, is temporarily stored, to be written out as comment
+	    # It gets replaced with the index in the next loop.
+	    #print &quot;arglist entry : $args\n&quot;;
+	    $arglist{$args} = $argNames;
+	}
+		    }, # end of sub
+	undef
+       );
+    });
+
+
+    $arglist{''} = 0;
+    # Print arguments array
+    print OUT &quot;static Smoke::Index ${libname}_argumentList[] = {\n&quot;;
+    my $argListCount = 0;
+    for my $args (sort keys %arglist) {
+	my $numTypes = scalar(split ',', $args);
+	if ($args eq '') {
+	    print OUT &quot;\t0,\t//0  (void)\n&quot;;
+	} else {
+	    # This is a nice trick : args can be written in one go ;)
+	    print OUT &quot;\t$args, 0,\t//$argListCount  $arglist{$args}  \n&quot;;
+	}
+	$arglist{$args} = $argListCount;      # Register proper index in argList
+	$argListCount += $numTypes + 1;       # Move forward by as much as we wrote out
+    }
+    print OUT &quot;};\n\n&quot;;
+
+    $methods{''} = 0;
+    my @methodlist = sort keys %methods;
+    my %methodidx = do { my $i = 0; map { $_ =&gt; $i++ } @methodlist };
+
+    print OUT &quot;// Raw list of all methods, using munged names\n&quot;;
+    print OUT &quot;static const char *${libname}_methodNames[] = {\n&quot;;
+    my $methodNameCount = $#methodlist;
+    for my $m (@methodlist) {
+	print OUT qq(    &quot;$m&quot;,\t//$methodidx{$m}\n);
+    }
+    print OUT &quot;};\n\n&quot;;
+
+    print OUT &quot;// (classId, name (index in methodNames), argumentList index, number of args, method flags, return type (index in types), xcall() index)\n&quot;;
+    print OUT &quot;static Smoke::Method ${libname}_methods[] = {\n&quot;;
+    my @methods;
+    %allMethods = ();
+    my $methodCount = 0;
+    # Look at all classes and all enums again
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	
+	my $classIndex = $classidx{$className};
+	print STDERR &quot;writeSmokeDataFile: methods: looking at $className\n&quot; if ($debug);
+
+	Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	if( $m-&gt;{NodeType} eq &quot;enum&quot; ) {
+
+	    foreach my $enum ( @{$m-&gt;{ParamList}} ) {
+		my $enumName = $enum-&gt;{ArgName};
+		my $fullEnumName = &quot;$className\::$enumName&quot;;
+		my $sig = &quot;$className\::$enumName\()&quot;;
+		my $xmethIndex = $methodidx{$enumName};
+		die &quot;'Method index' for enum $sig not found&quot; unless defined $xmethIndex;
+		my $typeId = findTypeEntry( $fullEnumName )-&gt;{index};
+		die &quot;enum has no {case} value in $className: $fullEnumName&quot; unless defined $classNode-&gt;{case}{$fullEnumName};
+		print OUT &quot;\t{$classIndex, $xmethIndex, 0, 0, Smoke::mf_static|Smoke::mf_enum, $typeId, $classNode-&gt;{case}{$fullEnumName}},\t//$methodCount $fullEnumName (enum)\n&quot;;
+		$allMethods{$sig} = $methodCount;
+		print STDERR &quot;Added entry for &quot; . $sig . &quot; into \$allMethods\n&quot; if ($debug);
+		$methods[$methodCount] = {
+				c =&gt; $classIndex,
+				methIndex =&gt; $xmethIndex,
+				argcnt =&gt; '0',
+				args =&gt; 0,
+				retTypeIndex =&gt; 0,
+				idx =&gt; $classNode-&gt;{case}{$fullEnumName}
+			       };
+		$methodCount++;
+	    }
+
+	} elsif( $m-&gt;{NodeType} eq 'var' ) {
+
+	    my $name = $m-&gt;{astNodeName};
+	    my $fullName = &quot;$className\::$name&quot;;
+	    my $sig = &quot;$fullName\()&quot;;
+	    my $xmethIndex = $methodidx{$name};
+	    die &quot;'Method index' for var $sig not found&quot; unless defined $xmethIndex;
+	    my $varType = $m-&gt;{Type};
+	    $varType =~ s/static\s//;
+	    $varType =~ s/const\s+(.*)\s*&amp;/$1/;
+	    $varType =~ s/\s*$//;
+	    my $typeId = findTypeEntry( $varType )-&gt;{index};
+	    die &quot;var has no {case} value in $className: $fullName&quot; unless defined $classNode-&gt;{case}{$fullName};
+		if ( $m-&gt;{Flags} =~ &quot;s&quot; ) {
+	    	print OUT &quot;\t{$classIndex, $xmethIndex, 0, 0, Smoke::mf_static, $typeId, $classNode-&gt;{case}{$fullName}},\t//$methodCount $fullName (static var)\n&quot;;
+		} else {
+	    	print OUT &quot;\t{$classIndex, $xmethIndex, 0, 0, 0, $typeId, $classNode-&gt;{case}{$fullName}},\t//$methodCount $fullName (var)\n&quot;;
+		}
+        $allMethods{$sig} = $methodCount;
+	    print STDERR &quot;Added entry for &quot; . $sig . &quot; into \$allMethods\n&quot; if ($debug);
+	    $methods[$methodCount] = {
+				c =&gt; $classIndex,
+				methIndex =&gt; $xmethIndex,
+				argcnt =&gt; '0',
+				args =&gt; 0,
+				retTypeIndex =&gt; 0,
+				idx =&gt; $classNode-&gt;{case}{$fullName}
+			       };
+	    $methodCount++;
+
+
+	} elsif( $m-&gt;{NodeType} eq &quot;method&quot; ) {
+
+	    # We generate a method entry only if the method is in the switch() code
+	    # BUT: for pure virtuals, they need to have a method entry, even though they
+	    # do NOT have a switch code.
+	    return if ( $m-&gt;{SkipFromSwitch} &amp;&amp; $m-&gt;{Flags} !~ &quot;p&quot; );
+
+	    # No switch code for destructors if we didn't derive from the class (e.g. it has private ctors only)
+    	    return if ( $m-&gt;{ReturnType} eq '~' &amp;&amp; ! ( $classNode-&gt;{BindingDerives} and $classNode-&gt;{HasPublicDestructor}) );
+
+            # Is this sorting really important?
+	    #for my $m (sort {$a-&gt;{name} cmp $b-&gt;{name}} @{ $self-&gt;{$c}{method} }) {
+
+	    my $methName = $m-&gt;{astNodeName};
+	    my $def = $m-&gt;{FirstDefaultParam};
+	    $def = scalar(@{ $m-&gt;{ParamList} }) unless defined $def;
+	    my $last = scalar(@{ $m-&gt;{ParamList} }) - 1;
+	    #print STDERR &quot;writeSmokeDataFile: methods: generating for method $methName, def=$def last=$last\n&quot; if ($debug);
+
+	    while($last &gt;= ($def-1)) {
+		last if $last &lt; -1;
+		my $args = [ @{ $m-&gt;{ParamList} }[0..$last] ];
+		my $sig = methodSignature($m, $last);
+		#my $methodSig = $classNode-&gt;{signature}{$sig}; # Munged signature
+		#print STDERR &quot;writeSmokeDataFile: methods: sig=$className\::$sig methodSig=$methodSig\n&quot; if ($debug);
+		#my $methodIndex = $methodidx{$methodSig};
+		#die &quot;$methodSig&quot; if !defined $methodIndex;
+
+		my $methodIndex = $methodidx{$methName};
+		die &quot;$methName&quot; if !defined $methodIndex;
+		my $case = $classNode-&gt;{case}{$sig};
+		my $typeEntry = findTypeEntry( $m-&gt;{ReturnType} );
+		my $retTypeIndex = defined $typeEntry ? $typeEntry-&gt;{index} : 0;
+
+		my $i = 0;
+		my $t = '';
+		for my $arg (@$args) {
+		    $t .= ', ' if $i++;
+		    my $typeEntry = findTypeEntry( $arg-&gt;{ArgType} );
+		    $t .= defined $typeEntry ? $typeEntry-&gt;{index} : 0;
+		}
+		my $arglist = $t eq '' ? 0 : $arglist{$t};
+		die &quot;arglist for $t not found&quot; unless defined $arglist;
+		if ( $m-&gt;{Flags} =~ &quot;p&quot; ) {
+		    # Pure virtuals don't have a {case} number, that's normal
+		    die if defined $case;
+		    $case = -1; # This remains -1, not 0 !
+		} else {
+		    die &quot;$className\::$methName has no case number for sig=$sig&quot; unless defined $case;
+		}
+		my $argcnt = $last + 1;
+		my $methodFlags = '0';
+		# Make no distinction between a static method in an ordinary class, or a method in a namespace
+		$methodFlags .= &quot;|Smoke::mf_static&quot; if $m-&gt;{Flags} =~ &quot;s&quot; or $classNode-&gt;{NodeType} eq 'namespace';
+		$methodFlags .= &quot;|Smoke::mf_const&quot; if $m-&gt;{Flags} =~ &quot;c&quot;; # useful?? probably not
+		$methodFlags .= &quot;|Smoke::mf_copyctor&quot; if $m-&gt;{Flags} =~ &quot;x&quot;;
+		$methodFlags .= &quot;|Smoke::mf_internal&quot; if $m-&gt;{Flags} =~ &quot;i&quot;;
+		$methodFlags .= &quot;|Smoke::mf_ctor&quot; if $methName eq $className;
+		$methodFlags .= &quot;|Smoke::mf_dtor&quot; if $m-&gt;{ReturnType} eq '~';
+		$methodFlags .= &quot;|Smoke::mf_protected&quot; if $m-&gt;{Access} =~ /protected/;
+		$methodFlags =~ s/0\|//; # beautify
+		
+		print OUT &quot;\t{$classIndex, $methodIndex, $arglist, $argcnt, $methodFlags, $retTypeIndex, $case},\t//$methodCount $className\::$sig&quot;;
+		print OUT &quot; [pure virtual]&quot; if ( $m-&gt;{Flags} =~ &quot;p&quot; ); # explain why $case = -1 ;)
+		print OUT &quot;\n&quot;;
+		
+		$allMethods{$className . &quot;::&quot; . $sig} = $methodCount;
+		$methods[$methodCount] = {
+					  c =&gt; $classIndex,
+					  methIndex =&gt; $methodIndex,
+					  argcnt =&gt; $argcnt,
+					  args =&gt; $arglist,
+					  retTypeIndex =&gt; $retTypeIndex,
+					  idx =&gt; $case
+					 };
+		$methodCount++;
+		$last--;
+	    } # while
+	} # if method
+      } ); # Method Iter
+    } ); # Class Iter
+    print OUT &quot;};\n\n&quot;;
+
+    my @protos;
+    Iter::LocalCompounds( $rootnode, sub {
+	my $classNode = shift;
+	my $className = join( &quot;::&quot;, kdocAstUtil::heritage($classNode) );
+	
+	my $classIndex = $classidx{$className};
+	print STDERR &quot;writeSmokeDataFile: protos: looking at $className\n&quot; if ($debug);
+
+	Iter::MembersByType ( $classNode, undef,
+		sub {	my ($classNode, $m ) = @_;
+
+	if( $m-&gt;{NodeType} eq &quot;enum&quot; ) {
+	    foreach my $enum ( @{$m-&gt;{ParamList}} ) {
+		my $enumName = $enum-&gt;{ArgName};
+		my $sig = &quot;$className\::$enumName\()&quot;;
+		my $xmeth = $allMethods{$sig};
+		die &quot;'Method' for enum $sig not found&quot; unless defined $xmeth;
+		my $xmethIndex = $methodidx{$enumName};
+		die &quot;'Method index' for enum $enumName not found&quot; unless defined $xmethIndex;
+		push @protos, {
+			       methIndex =&gt; $xmethIndex,
+			       c =&gt; $classIndex,
+			       over =&gt; {
+					$sig =&gt; {
+						 sig =&gt; $sig,
+						}
+				       },
+			       meth =&gt; $xmeth
+			      };
+	    }
+
+	} elsif( $m-&gt;{NodeType} eq 'var' ) {
+
+	    my $name = $m-&gt;{astNodeName};
+	    my $fullName = &quot;$className\::$name&quot;;
+	    my $sig = &quot;$fullName\()&quot;;
+	    my $xmeth = $allMethods{$sig};
+	    die &quot;'Method' for var $sig not found&quot; unless defined $xmeth;
+	    my $xmethIndex = $methodidx{$name};
+	    die &quot;'Method index' for var $name not found&quot; unless defined $xmethIndex;
+	    push @protos, {
+			       methIndex =&gt; $xmethIndex,
+			       c =&gt; $classIndex,
+			       over =&gt; {
+					$sig =&gt; {
+						 sig =&gt; $sig,
+						}
+				       },
+			       meth =&gt; $xmeth
+			  };
+
+	}
+		    });
+
+	for my $p (keys %{ $classNode-&gt;{proto} }) {
+	    # For each prototype
+	    my $scratch = { %{ $classNode-&gt;{proto}{$p} } }; # sig-&gt;method association
+	    # first, grab all the superclass voodoo
+	    for my $supNode (superclass_list($classNode)) {
+		my $i = $supNode-&gt;{proto}{$p};
+		next unless $i;
+		for my $k (keys %$i) {
+		    $scratch-&gt;{$k} = $i-&gt;{$k} unless exists $scratch-&gt;{$k};
+		}
+	    }
+
+	    # Ok, now we have a full list
+	    #if(scalar keys %$scratch &gt; 1) {
+		#print STDERR &quot;Overload: $p (@{[keys %$scratch]})\n&quot; if ($debug);
+	    #}
+	    my $xmethIndex = $methodidx{$p};
+	    my $classIndex = $classidx{$className};
+	    for my $sig (keys %$scratch) {
+		#my $xsig = $scratch-&gt;{$sig}{class} . &quot;::&quot; . $sig;
+		my $xsig = $className . &quot;::&quot; . $sig;
+		$scratch-&gt;{$sig}{sig} = $xsig;
+		delete $scratch-&gt;{$sig}
+		    if $scratch-&gt;{$sig}{Flags} =~ &quot;p&quot; # pure virtual
+			or not exists $allMethods{$xsig};
+	    }
+	    push @protos, {
+		methIndex =&gt; $xmethIndex,
+		c =&gt; $classIndex,
+		over =&gt; $scratch
+	    } if scalar keys %$scratch;
+	}
+    });
+
+    my @protolist = sort { $a-&gt;{c} &lt;=&gt; $b-&gt;{c} || $a-&gt;{methIndex} &lt;=&gt; $b-&gt;{methIndex} } @protos;
+#for my $abc (@protos) {
+#print &quot;$abc-&gt;{methIndex}.$abc-&gt;{c}\n&quot;;
+#}
+
+    print STDERR &quot;Writing methodmap table\n&quot; if ($debug);
+    my @resolve = ();
+    print OUT &quot;// Class ID, munged name ID (index into methodNames), method def (see methods) if &gt;0 or number of overloads if &lt;0\n&quot;;
+    my $methodMapCount = 1;
+    print OUT &quot;static Smoke::MethodMap ${libname}_methodMaps[] = {\n&quot;;
+    print OUT &quot;\t{ 0, 0, 0 },\t//0 (no method)\n&quot;;
+    for my $cur (@protolist) {
+	if(scalar keys %{ $cur-&gt;{over} } &gt; 1) {
+	    print OUT &quot;\t{$cur-&gt;{c}, $cur-&gt;{methIndex}, -@{[1+scalar @resolve]}},\t//$methodMapCount $classlist[$cur-&gt;{c}]\::$methodlist[$cur-&gt;{methIndex}]\n&quot;;
+	    $methodMapCount++;
+	    for my $k (keys %{ $cur-&gt;{over} }) {
+	        my $p = $cur-&gt;{over}{$k};
+	        my $xsig = $p-&gt;{class} ? &quot;$p-&gt;{class}\::$k&quot; : $p-&gt;{sig};
+	        push @resolve, { k =&gt; $k, p =&gt; $p, cur =&gt; $cur, id =&gt; $allMethods{$xsig} };
+	    }
+	    push @resolve, 0;
+	} else {
+	    for my $k (keys %{ $cur-&gt;{over} }) {
+	        my $p = $cur-&gt;{over}{$k};
+	        my $xsig = $p-&gt;{class} ? &quot;$p-&gt;{class}\::$k&quot; : $p-&gt;{sig};
+	        print OUT &quot;\t{$cur-&gt;{c}, $cur-&gt;{methIndex}, $allMethods{$xsig}},\t//$methodMapCount $classlist[$cur-&gt;{c}]\::$methodlist[$cur-&gt;{methIndex}]\n&quot;;
+	        $methodMapCount++;
+	    }
+	}
+    }
+    print OUT &quot;};\n\n&quot;;
+
+
+    print STDERR &quot;Writing ambiguousMethodList\n&quot; if ($debug);
+    print OUT &quot;static Smoke::Index ${libname}_ambiguousMethodList[] = {\n&quot;;
+    print OUT &quot;    0,\n&quot;;
+    for my $r (@resolve) {
+	unless($r) {
+	    print OUT &quot;    0,\n&quot;;
+	    next;
+	}
+	my $xsig = $r-&gt;{p}{class} ? &quot;$r-&gt;{p}{class}\::$r-&gt;{k}&quot; : $r-&gt;{p}{sig};
+	die &quot;ambiguousMethodList: no method found for $xsig\n&quot; if !defined $allMethods{$xsig};
+	print OUT &quot;    $allMethods{$xsig},  // $xsig\n&quot;;
+    }
+    print OUT &quot;};\n\n&quot;;
+
+#    print OUT &quot;extern \&quot;C\&quot; { // needed?\n&quot;;
+#    print OUT &quot;    void init_${libname}_Smoke();\n&quot;;
+#    print OUT &quot;}\n&quot;;
+    print OUT &quot;\n&quot;;
+    print OUT &quot;Smoke* qt_Smoke = 0L;\n&quot;;
+    print OUT &quot;\n&quot;;
+    print OUT &quot;// Create the Smoke instance encapsulating all the above.\n&quot;;
+    print OUT &quot;void init_${libname}_Smoke() {\n&quot;;
+    print OUT &quot;    qt_Smoke = new Smoke(\n&quot;;
+    print OUT &quot;        ${libname}_classes, &quot;.$#classlist.&quot;,\n&quot;;
+    print OUT &quot;        ${libname}_methods, $methodCount,\n&quot;;
+    print OUT &quot;        ${libname}_methodMaps, $methodMapCount,\n&quot;;
+    print OUT &quot;        ${libname}_methodNames, $methodNameCount,\n&quot;;
+    print OUT &quot;        ${libname}_types, $typeCount,\n&quot;;
+    print OUT &quot;        ${libname}_inheritanceList,\n&quot;;
+    print OUT &quot;        ${libname}_argumentList,\n&quot;;
+    print OUT &quot;        ${libname}_ambiguousMethodList,\n&quot;;
+    print OUT &quot;        ${libname}_cast );\n&quot;;
+    print OUT &quot;}\n&quot;;
+    close OUT;
+
+#print &quot;@{[keys %allMethods ]}\n&quot;;
+}
+
+1;

Added: trunk/kalyptus/kalyptusDataDict.pm
===================================================================
--- trunk/kalyptus/kalyptusDataDict.pm	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/kalyptusDataDict.pm	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,2980 @@
+#***************************************************************************
+#                            kalyptusDataDict.pm -  A Qt/KDE types data dictionary
+#                             -------------------
+#    begin                : Fri Oct 20 12:00:00 2000
+#    copyright            : (C) 2000-2001 Lost Highway Ltd. All Rights Reserved.
+#    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">Richard_Dale at tipitina.demon.co.uk</A>
+#    author               : Richard Dale.
+#***************************************************************************/
+
+#/***************************************************************************
+# *                                                                         *
+# *   This program is free software; you can redistribute it and/or modify  *
+# *   it under the terms of the GNU General Public License as published by  *
+# *   the Free Software Foundation; either version 2 of the License, or     *
+# *   (at your option) any later version.                                   *
+# *                                                                         *
+#***************************************************************************/
+
+package kalyptusDataDict;
+
+use strict;
+no strict &quot;subs&quot;;
+
+use vars qw/ %interfacemap %ctypemap %builtins /;
+
+BEGIN
+{
+
+%interfacemap = (
+'QPaintDevice' =&gt; 'QPaintDeviceInterface',
+'QMenuData' =&gt; 'QMenuDataInterface',
+'QRangeControl' =&gt; 'QRangeControlInterface',
+'QMimeSource' =&gt; 'QMimeSourceInterface',
+'QLayoutItem' =&gt; 'QLayoutItemInterface',
+'QUrl' =&gt; 'QUrlInterface',
+'QIODevice' =&gt; 'QIODeviceInterface',
+'QXmlContentHandler' =&gt; 'QXmlContentHandlerInterface',
+'QXmlErrorHandler' =&gt; 'QXmlErrorHandlerInterface',
+'QXmlDTDHandler' =&gt; 'QXmlDTDHandlerInterface',
+'QXmlEntityResolver' =&gt; 'QXmlEntityResolverInterface',
+'QXmlLexicalHandler' =&gt; 'QXmlLexicalHandlerInterface',
+'QXmlDeclHandler' =&gt; 'QXmlDeclHandlerInterface',
+'KInstance' =&gt; 'KInstanceInterface',
+'QwAbsSpriteFieldView' =&gt; 'QwAbsSpriteFieldViewInterface',
+'PartBase' =&gt; 'PartBaseInterface',
+'KCompletionBase' =&gt; 'KCompletionBaseInterface',
+'KDirNotify' =&gt; 'KDirNotifyInterface',
+'KXMLGUIClient' =&gt; 'KXMLGUIClientInterface',
+'KFileView' =&gt; 'KFileViewInterface',
+'KXMLGUIBuilder' =&gt; 'KXMLGUIBuilderInterface',
+'DCOPObject' =&gt; 'DCOPObjectInterface',
+'KDevCore' =&gt; 'KDevCoreInterface',
+'QSqlQuery' =&gt; 'QSqlQueryInterface',
+
+);
+
+# A hard coded type translation table (the idea from the Roberto Alsina's Qtc
+# python conversion scripts). The particular format used here makes it possible to use
+# the same table with three different kdoc based Qt/KDE language binding generators;
+# C, Objective-C and Java.
+%ctypemap = (
+
+'ASConsumer*' =&gt; 'kde_ASConsumer*',
+'ASProducer*' =&gt; 'kde_ASProducer*',
+'ASYNC'  =&gt;  'void' ,
+'Address&amp;'  =&gt;  'kde_Address*' ,
+'Address*' =&gt; 'kde_Address*',
+'AddressBook*' =&gt; 'kde_AddressBook*',
+'AddressBook::Entry&amp;'  =&gt;  'kde_Entry*' ,
+'Addressee&amp;' =&gt; 'kde_Addressee*',
+'Addressee*' =&gt; 'kde_Addressee*',
+'AddresseeData*' =&gt; 'kde_AddresseeData*',
+'AddresseeDialog*' =&gt; 'kde_AddresseeDialog*',
+'AddresseeItem*' =&gt; 'kde_AddresseeItem*',
+'AlsaOut*' =&gt; 'kde_AlsaOut*',
+'AnyConstRef&amp;' =&gt; 'kde_AnyConstRef*',
+'AnyConstRef*' =&gt; 'kde_AnyConstRef*',
+'AnyRef&amp;' =&gt; 'kde_AnyRef*',
+'AnyRef*' =&gt; 'kde_AnyRef*',
+'AnyRefBase&amp;' =&gt; 'kde_AnyRefBase*',
+'AnyRefBase*' =&gt; 'kde_AnyRefBase*',
+'ArgList'  =&gt;  'int' ,
+'ArrowType'  =&gt;  'int' ,
+'Arts*' =&gt; 'kde_Arts*',
+'Arts::AudioManagerClient' =&gt; 'int',
+'Arts::Buffer&amp;' =&gt; 'kde_Arts_Buffer*',
+'Arts::Buffer*' =&gt; 'kde_Arts_Buffer*',
+'Arts::ByteSoundProducer' =&gt; 'kde_Arts_ByteSoundProducer*',
+'Arts::Connection*' =&gt; 'kde_Arts_Connection*',
+'Arts::DynamicCast&amp;' =&gt; 'kde_Arts_DynamicCast*',
+'Arts::FlowSystemReceiver' =&gt; 'kde_Arts_FlowSystemReceiver*',
+'Arts::FlowSystemSender' =&gt; 'kde_Arts_FlowSystemSender*',
+'Arts::Format&amp;' =&gt; 'kde_Arts_Format*',
+'Arts::Format' =&gt; 'kde_Arts_Format',
+'Arts::GenericAsyncStream*' =&gt; 'kde_Arts_GenericAsyncStream*',
+'Arts::GenericDataChannel*' =&gt; 'kde_Arts_GenericDataChannel*',
+'Arts::InterfaceDef' =&gt; 'kde_Arts_InterfaceDef*',
+'Arts::MethodDef&amp;' =&gt; 'kde_Arts_MethodDef*',
+'Arts::ModuleDef&amp;' =&gt; 'kde_Arts_ModuleDef*',
+'Arts::Notification&amp;' =&gt; 'kde_Arts_Notification*',
+'Arts::Object' =&gt; 'kde_Arts_Object*',
+'Arts::Object::Pool&amp;' =&gt; 'kde_Arts_Object_Pool*',
+'Arts::ObjectReference' =&gt; 'kde_Arts_ObjectReference*',
+'Arts::PlayObject' =&gt; 'kde_Arts_PlayObject*',
+'Arts::Reference&amp;' =&gt; 'kde_Arts_Reference*',
+'Arts::StereoEffect' =&gt; 'kde_Arts_StereoEffect*',
+'Arts::StereoEffectStack' =&gt; 'kde_Arts_StereoEffectStack*',
+'Arts::SubClass&amp;' =&gt; 'kde_Arts_SubClass*',
+'Arts::TypeDef' =&gt; 'kde_Arts_TypeDef*',
+'Arts::poTime&amp;' =&gt; 'kde_Arts_poTime*',
+'Arts::poTime' =&gt; 'kde_Arts_poTime',
+'AsyncStream*' =&gt; 'kde_AsyncStream*',
+'Attr&amp;' =&gt; 'kde_Attr*',
+'Attr' =&gt; 'kde_Attr*',
+'Attr*' =&gt; 'kde_Attr*',
+'AttrImpl*' =&gt; 'kde_AttrImpl*',
+'AttributeDef&amp;' =&gt; 'kde_AttributeDef*',
+'AttributeDef*' =&gt; 'kde_AttributeDef*',
+'AudioManager&amp;' =&gt; 'kde_AudioManager*',
+'AudioManager' =&gt; 'kde_AudioManager*',
+'AudioManager*' =&gt; 'kde_AudioManager*',
+'AudioManagerClient&amp;' =&gt; 'kde_AudioManagerClient*',
+'AudioManagerClient' =&gt; 'kde_AudioManagerClient*',
+'AudioManagerClient*' =&gt; 'kde_AudioManagerClient*',
+'AudioManagerClient_base*' =&gt; 'kde_AudioManagerClient_base*',
+'AudioManagerClient_skel*' =&gt; 'kde_AudioManagerClient_skel*',
+'AudioManagerClient_stub*' =&gt; 'kde_AudioManagerClient_stub*',
+'AudioManagerInfo&amp;' =&gt; 'kde_AudioManagerInfo*',
+'AudioManagerInfo*' =&gt; 'kde_AudioManagerInfo*',
+'AudioManager_base*' =&gt; 'kde_AudioManager_base*',
+'AudioManager_skel*' =&gt; 'kde_AudioManager_skel*',
+'AudioManager_stub*' =&gt; 'kde_AudioManager_stub*',
+'AudioPort*' =&gt; 'kde_AudioPort*',
+'AudioSubSystem*' =&gt; 'kde_AudioSubSystem*',
+'AudioSubSystemStart*' =&gt; 'kde_AudioSubSystemStart*',
+'AuthAccept&amp;' =&gt; 'kde_AuthAccept*',
+'AuthAccept*' =&gt; 'kde_AuthAccept*',
+'BGMode' =&gt; 'int',
+'BMToken*' =&gt; 'kde_BMToken*',
+'BackgroundMode' =&gt; 'int',
+'BlockSelectionInterface*' =&gt; 'kde_BlockSelectionInterface*',
+'BookmarkTokenizer*' =&gt; 'kde_BookmarkTokenizer*',
+'Bool'  =&gt;  'int' ,
+'Boolean&amp;' =&gt; 'kde_Boolean*',
+'Boolean*' =&gt; 'kde_Boolean*',
+'BrowserExtension*' =&gt; 'kde_BrowserExtension*',
+'BrowserHostExtension*' =&gt; 'kde_BrowserHostExtension*',
+'BrowserInterface*' =&gt; 'kde_BrowserInterface*',
+'BrushStyle' =&gt; 'int',
+'Buffer&amp;' =&gt; 'kde_Buffer*',
+'Buffer*' =&gt; 'kde_Buffer*',
+'ButtonCode'  =&gt;  'int' ,
+'ButtonState'  =&gt;  'int' ,
+'ByteAsyncStream*' =&gt; 'kde_ByteAsyncStream*',
+'ByteDataPacket*' =&gt; 'kde_ByteDataPacket*',
+'ByteSoundProducer&amp;' =&gt; 'kde_ByteSoundProducer*',
+'ByteSoundProducer' =&gt; 'kde_ByteSoundProducer*',
+'ByteSoundProducer*' =&gt; 'kde_ByteSoundProducer*',
+'ByteSoundProducer_base*' =&gt; 'kde_ByteSoundProducer_base*',
+'ByteSoundProducer_skel*' =&gt; 'kde_ByteSoundProducer_skel*',
+'ByteSoundProducer_stub*' =&gt; 'kde_ByteSoundProducer_stub*',
+'ByteStreamToAudio&amp;' =&gt; 'kde_ByteStreamToAudio*',
+'ByteStreamToAudio' =&gt; 'kde_ByteStreamToAudio*',
+'ByteStreamToAudio*' =&gt; 'kde_ByteStreamToAudio*',
+'ByteStreamToAudio_base*' =&gt; 'kde_ByteStreamToAudio_base*',
+'ByteStreamToAudio_skel*' =&gt; 'kde_ByteStreamToAudio_skel*',
+'ByteStreamToAudio_stub*' =&gt; 'kde_ByteStreamToAudio_stub*',
+'CDATASection&amp;' =&gt; 'kde_CDATASection*',
+'CDATASection' =&gt; 'kde_CDATASection*',
+'CDATASection*' =&gt; 'kde_CDATASection*',
+'CFlags' =&gt; 'int',
+'COORD'  =&gt;  'short' ,
+'CSSCharsetRule&amp;' =&gt; 'kde_CSSCharsetRule*',
+'CSSCharsetRule*' =&gt; 'kde_CSSCharsetRule*',
+'CSSCharsetRuleImpl*' =&gt; 'kde_CSSCharsetRuleImpl*',
+'CSSException&amp;' =&gt; 'kde_CSSException*',
+'CSSException*' =&gt; 'kde_CSSException*',
+'CSSFontFaceRule&amp;' =&gt; 'kde_CSSFontFaceRule*',
+'CSSFontFaceRule*' =&gt; 'kde_CSSFontFaceRule*',
+'CSSFontFaceRuleImpl*' =&gt; 'kde_CSSFontFaceRuleImpl*',
+'CSSImportRule&amp;' =&gt; 'kde_CSSImportRule*',
+'CSSImportRule*' =&gt; 'kde_CSSImportRule*',
+'CSSImportRuleImpl*' =&gt; 'kde_CSSImportRuleImpl*',
+'CSSMediaRule&amp;' =&gt; 'kde_CSSMediaRule*',
+'CSSMediaRule*' =&gt; 'kde_CSSMediaRule*',
+'CSSMediaRuleImpl*' =&gt; 'kde_CSSMediaRuleImpl*',
+'CSSPageRule&amp;' =&gt; 'kde_CSSPageRule*',
+'CSSPageRule*' =&gt; 'kde_CSSPageRule*',
+'CSSPageRuleImpl*' =&gt; 'kde_CSSPageRuleImpl*',
+'CSSPrimitiveValue&amp;' =&gt; 'kde_CSSPrimitiveValue*',
+'CSSPrimitiveValue' =&gt; 'kde_CSSPrimitiveValue*',
+'CSSPrimitiveValue*' =&gt; 'kde_CSSPrimitiveValue*',
+'CSSPrimitiveValueImpl*' =&gt; 'kde_CSSPrimitiveValueImpl*',
+'CSSRule&amp;' =&gt; 'kde_CSSRule*',
+'CSSRule' =&gt; 'kde_CSSRule*',
+'CSSRule*' =&gt; 'kde_CSSRule*',
+'CSSRuleImpl*' =&gt; 'kde_CSSRuleImpl*',
+'CSSRuleList&amp;' =&gt; 'kde_CSSRuleList*',
+'CSSRuleList' =&gt; 'kde_CSSRuleList*',
+'CSSRuleList*' =&gt; 'kde_CSSRuleList*',
+'CSSRuleListImpl*' =&gt; 'kde_CSSRuleListImpl*',
+'CSSStyleDeclaration&amp;' =&gt; 'kde_CSSStyleDeclaration*',
+'CSSStyleDeclaration' =&gt; 'kde_CSSStyleDeclaration*',
+'CSSStyleDeclaration*' =&gt; 'kde_CSSStyleDeclaration*',
+'CSSStyleDeclarationImpl*' =&gt; 'kde_CSSStyleDeclarationImpl*',
+'CSSStyleRule&amp;' =&gt; 'kde_CSSStyleRule*',
+'CSSStyleRule*' =&gt; 'kde_CSSStyleRule*',
+'CSSStyleRuleImpl*' =&gt; 'kde_CSSStyleRuleImpl*',
+'CSSStyleSheet&amp;' =&gt; 'kde_CSSStyleSheet*',
+'CSSStyleSheet' =&gt; 'kde_CSSStyleSheet*',
+'CSSStyleSheet*' =&gt; 'kde_CSSStyleSheet*',
+'CSSStyleSheetImpl*' =&gt; 'kde_CSSStyleSheetImpl*',
+'CSSUnknownRule&amp;' =&gt; 'kde_CSSUnknownRule*',
+'CSSUnknownRule*' =&gt; 'kde_CSSUnknownRule*',
+'CSSUnknownRuleImpl*' =&gt; 'kde_CSSUnknownRuleImpl*',
+'CSSValue&amp;' =&gt; 'kde_CSSValue*',
+'CSSValue' =&gt; 'kde_CSSValue*',
+'CSSValue*' =&gt; 'kde_CSSValue*',
+'CSSValueImpl*' =&gt; 'kde_CSSValueImpl*',
+'CSSValueList&amp;' =&gt; 'kde_CSSValueList*',
+'CSSValueList*' =&gt; 'kde_CSSValueList*',
+'CSSValueListImpl*' =&gt; 'kde_CSSValueListImpl*',
+'CString&amp;' =&gt; 'kde_CString*',
+'CString' =&gt; 'kde_CString*',
+'CString*' =&gt; 'kde_CString*',
+'Cache*' =&gt; 'kde_Cache*',
+'CacheInfo*' =&gt; 'kde_CacheInfo*',
+'CachedObject*' =&gt; 'kde_CachedObject*',
+'CachedWav*' =&gt; 'kde_CachedWav*',
+'Cardinal'  =&gt;  'int' ,
+'CharSet' =&gt; 'int',
+'CharacterData&amp;' =&gt; 'kde_CharacterData*',
+'CharacterData*' =&gt; 'kde_CharacterData*',
+'CharacterDataImpl*' =&gt; 'kde_CharacterDataImpl*',
+'ChmodJob*' =&gt; 'kde_ChmodJob*',
+'ClassInfo*' =&gt; 'kde_ClassInfo*',
+'ClassStore*' =&gt; 'kde_ClassStore*',
+'ClassTreeNode*' =&gt; 'kde_ClassTreeNode*',
+'ClientHello&amp;' =&gt; 'kde_ClientHello*',
+'ClientHello*' =&gt; 'kde_ClientHello*',
+'ClipboardInterface*' =&gt; 'kde_ClipboardInterface*',
+'CodeCompletionInterface*' =&gt; 'kde_CodeCompletionInterface*',
+'ColorMode' =&gt; 'int',
+'Comment&amp;' =&gt; 'kde_Comment*',
+'Comment' =&gt; 'kde_Comment*',
+'Comment*' =&gt; 'kde_Comment*',
+'CommentImpl*' =&gt; 'kde_CommentImpl*',
+'ComparisonFlags' =&gt; 'int',
+'Compl' =&gt; 'kde_Compl',
+'Completion&amp;' =&gt; 'kde_Completion*',
+'Completion*' =&gt; 'kde_Completion*',
+'CompletionEntry&amp;' =&gt; 'kde_CompletionEntry*',
+'CompletionEntry*' =&gt; 'kde_CompletionEntry*',
+'ComplexControl' =&gt; 'int',
+'ComponentFactory*' =&gt; 'kde_ComponentFactory*',
+'ConfigInterface*' =&gt; 'kde_ConfigInterface*',
+'Connection*' =&gt; 'kde_Connection*',
+'ConstIterator'  =&gt;  'int' ,
+'Constructor' =&gt; 'kde_Constructor*',
+'Constructor*' =&gt; 'kde_Constructor*',
+'ConstructorImp*' =&gt; 'kde_ConstructorImp*',
+'ContentsType' =&gt; 'int',
+'Context&amp;' =&gt; 'kde_Context*',
+'Context*' =&gt; 'kde_Context*',
+'ControlElement' =&gt; 'int',
+'CopyInfo*' =&gt; 'kde_CopyInfo*',
+'CopyJob*' =&gt; 'kde_CopyJob*',
+'Core*' =&gt; 'kde_Core*',
+'Counter&amp;' =&gt; 'kde_Counter*',
+'Counter' =&gt; 'kde_Counter*',
+'Counter*' =&gt; 'kde_Counter*',
+'Cursor*' =&gt; 'kde_Cursor*',
+'CursorInterface*' =&gt; 'kde_CursorInterface*',
+'DCOPClient*' =&gt; 'kde_DCOPClient*',
+'DCOPObject*' =&gt; 'kde_DCOPObject*',
+'DCOPObjectProxy*' =&gt; 'kde_DCOPObjectProxy*',
+'DCOPRef&amp;'  =&gt;  'kde_DCOPRef*' ,
+'DCOPRef*' =&gt; 'kde_DCOPRef*',
+'DCOPStub*' =&gt; 'kde_DCOPStub*',
+'DOM*' =&gt; 'kde_DOM*',
+'DOM::CSSProperty*'  =&gt;  'kde_CSSProperty*' ,
+'DOM::DOMString&amp;'  =&gt;  'kde_DOMString*' ,
+'DOM::DOMString'  =&gt;  'kde_DOMString*' ,
+'DOM::Document&amp;'  =&gt;  'kde_Document*' ,
+'DOM::Document'  =&gt;  'kde_Document*' ,
+'DOM::Document*'  =&gt;  'kde_Document*' ,
+'DOM::HTMLDocument'  =&gt;  'kde_HTMLDocument*' ,
+'DOM::MediaList&amp;' =&gt; 'kde_MediaList*',
+'DOM::MediaList' =&gt; 'kde_MediaList*',
+'DOM::MediaList*' =&gt; 'kde_MediaList*',
+'DOM::Node&amp;'  =&gt;  'kde_Node*' ,
+'DOM::Node'  =&gt;  'kde_Node*' ,
+'DOM::NodeList&amp;' =&gt; 'kde_DOMNodeList*',
+'DOM::NodeList' =&gt; 'kde_DOMNodeList*',
+'DOM::NodeList*' =&gt; 'kde_DOMNodeList*',
+'DOM::Range'  =&gt;  'kde_Range*' ,
+'DOM::StyleSheetList&amp;' =&gt; 'kde_StyleSheetList*',
+'DOM::StyleSheetList' =&gt; 'kde_StyleSheetList*',
+'DOM::StyleSheetList*' =&gt; 'kde_StyleSheetList*',
+'StyleSheetList&amp;' =&gt; 'kde_StyleSheetList*',
+'StyleSheetList' =&gt; 'kde_StyleSheetList*',
+'StyleSheetList*' =&gt; 'kde_StyleSheetList*',
+'DOMException&amp;' =&gt; 'kde_DOMException*',
+'DOMException*' =&gt; 'kde_DOMException*',
+'DOMImplementation&amp;' =&gt; 'kde_DOMImplementation*',
+'DOMImplementation' =&gt; 'kde_DOMImplementation*',
+'DOMImplementation*' =&gt; 'kde_DOMImplementation*',
+'DOMImplementationImpl*' =&gt; 'kde_DOMImplementationImpl*',
+'DOMString&amp;' =&gt; 'kde_DOMString*',
+'DOMString' =&gt; 'kde_DOMString*',
+'DOMString*' =&gt; 'kde_DOMString*',
+'DOMStringImpl*' =&gt; 'kde_DOMStringImpl*',
+'DW_EXPORT*' =&gt; 'void*',
+'DataPacket*' =&gt; 'kde_DataPacket*',
+'DateFormat' =&gt; 'int',
+'Debug*' =&gt; 'kde_Debug*',
+'DecoderFn'  =&gt;  'int' ,
+'DefaultProgress*' =&gt; 'kde_DefaultProgress*',
+'DeleteJob*' =&gt; 'kde_DeleteJob*',
+'DeviceManager*' =&gt; 'kde_DeviceManager*',
+'Direction' =&gt; 'int',
+'DispatchFunction' =&gt; 'kde_DispatchFunction*',
+'Dispatcher*' =&gt; 'kde_Dispatcher*',
+'DistributionList*' =&gt; 'kde_DistributionList*',
+'DistributionListEditor*' =&gt; 'kde_DistributionListEditor*',
+'DistributionListManager*' =&gt; 'kde_DistributionListManager*',
+'Dock&amp;' =&gt; 'int',
+'Dock' =&gt; 'int',
+'DockMainWindow*' =&gt; 'kde_DockMainWindow*',
+'DockPosData&amp;'  =&gt;  'kde_DockPosData*' ,
+'DockPosData*' =&gt; 'kde_DockPosData*',
+'DockWindowData*' =&gt; 'long',
+'Document&amp;' =&gt; 'kde_Document*',
+'Document' =&gt; 'kde_Document*',
+'Document*' =&gt; 'kde_Document*',
+'DocumentFragment&amp;' =&gt; 'kde_DocumentFragment*',
+'DocumentFragment' =&gt; 'kde_DocumentFragment*',
+'DocumentFragment*' =&gt; 'kde_DocumentFragment*',
+'DocumentFragmentImpl*' =&gt; 'kde_DocumentFragmentImpl*',
+'DocumentImpl*' =&gt; 'kde_DocumentImpl*',
+'DocumentStyle&amp;' =&gt; 'kde_DocumentStyle*',
+'DocumentStyle*' =&gt; 'kde_DocumentStyle*',
+'DocumentType&amp;' =&gt; 'kde_DocumentType*',
+'DocumentType' =&gt; 'kde_DocumentType*',
+'DocumentType*' =&gt; 'kde_DocumentType*',
+'DocumentationContext*' =&gt; 'kde_DocumentationContext*',
+'DomShared*' =&gt; 'kde_DomShared*',
+'DrageMode' =&gt; 'int',
+'DrawContentsEvent*' =&gt; 'kde_DrawContentsEvent*',
+'DwAddress&amp;' =&gt; 'kde_DwAddress*',
+'DwAddress*' =&gt; 'kde_DwAddress*',
+'DwAddressList&amp;' =&gt; 'kde_DwAddressList*',
+'DwAddressList*' =&gt; 'kde_DwAddressList*',
+'DwBody&amp;' =&gt; 'kde_DwBody*',
+'DwBody*' =&gt; 'kde_DwBody*',
+'DwBodyPart&amp;' =&gt; 'kde_DwBodyPart*',
+'DwBodyPart*' =&gt; 'kde_DwBodyPart*',
+'DwBool' =&gt; 'int',
+'DwDateTime&amp;' =&gt; 'kde_DwDateTime*',
+'DwDateTime*' =&gt; 'kde_DwDateTime*',
+'DwDispositionType&amp;' =&gt; 'kde_DwDispositionType*',
+'DwDispositionType*' =&gt; 'kde_DwDispositionType*',
+'DwEntity&amp;' =&gt; 'kde_DwEntity*',
+'DwField&amp;' =&gt; 'kde_DwField*',
+'DwField*' =&gt; 'kde_DwField*',
+'DwFieldBody&amp;' =&gt; 'kde_DwFieldBody*',
+'DwFieldBody*' =&gt; 'kde_DwFieldBody*',
+'DwGroup&amp;' =&gt; 'kde_DwGroup*',
+'DwGroup*' =&gt; 'kde_DwGroup*',
+'DwHeaders&amp;' =&gt; 'kde_DwHeaders*',
+'DwHeaders*' =&gt; 'kde_DwHeaders*',
+'DwInt32' =&gt; 'int',
+'DwMailbox&amp;' =&gt; 'kde_DwMailbox*',
+'DwMailbox*' =&gt; 'kde_DwMailbox*',
+'DwMailboxList&amp;' =&gt; 'kde_DwMailboxList*',
+'DwMailboxList*' =&gt; 'kde_DwMailboxList*',
+'DwMechanism&amp;' =&gt; 'kde_DwMechanism*',
+'DwMechanism*' =&gt; 'kde_DwMechanism*',
+'DwMediaType&amp;' =&gt; 'kde_DwMediaType*',
+'DwMediaType*' =&gt; 'kde_DwMediaType*',
+'DwMessage&amp;' =&gt; 'kde_DwMessage*',
+'DwMessage*' =&gt; 'kde_DwMessage*',
+'DwMessageComponent&amp;' =&gt; 'kde_DwMessageComponent*',
+'DwMessageComponent*' =&gt; 'kde_DwMessageComponent*',
+'DwMime*' =&gt; 'kde_DwMime*',
+'DwMsgId&amp;' =&gt; 'kde_DwMsgId*',
+'DwMsgId*' =&gt; 'kde_DwMsgId*',
+'DwObserver*' =&gt; 'kde_DwObserver*',
+'DwParameter&amp;' =&gt; 'kde_DwParameter*',
+'DwParameter*' =&gt; 'kde_DwParameter*',
+'DwProtocolClient*' =&gt; 'kde_DwProtocolClient*',
+'DwString&amp;' =&gt; 'kde_DwString*',
+'DwString' =&gt; 'kde_DwString',
+'DwString*' =&gt; 'kde_DwString*',
+'DwText&amp;' =&gt; 'kde_DwText*',
+'DwText*' =&gt; 'kde_DwText*',
+'DwTokenizer&amp;' =&gt; 'kde_DwTokenizer*',
+'DwUint16' =&gt; 'unsigned short',
+'DwUint32' =&gt; 'unsigned int',
+'DwUint8' =&gt; 'unsigned char',
+'DynamicCast*' =&gt; 'kde_DynamicCast*',
+'DynamicRequest&amp;' =&gt; 'kde_DynamicRequest*',
+'DynamicRequest*' =&gt; 'kde_DynamicRequest*',
+'EXPORT_DOCKCLASS*' =&gt; 'kde_EXPORT_DOCKCLASS*',
+'EchoMode' =&gt; 'int',
+'EditInterface*' =&gt; 'kde_EditInterface*',
+'Editor*' =&gt; 'kde_Editor*',
+'EditorContext*' =&gt; 'kde_EditorContext*',
+'Element&amp;' =&gt; 'kde_Element*',
+'Element' =&gt; 'kde_Element*',
+'Element*' =&gt; 'kde_Element*',
+'EmailSelectDialog*' =&gt; 'kde_EmailSelectDialog*',
+'EncoderFn'  =&gt;  'int' ,
+'Endian' =&gt; 'int',
+'Entity&amp;' =&gt; 'kde_Entity*',
+'Entity*' =&gt; 'kde_Entity*',
+'EntityReference&amp;' =&gt; 'kde_EntityReference*',
+'EntityReference' =&gt; 'kde_EntityReference*',
+'EntityReference*' =&gt; 'kde_EntityReference*',
+'Entry&amp;'  =&gt;  'kde_Entry*' ,
+'Entry*' =&gt; 'kde_Entry*',
+'Entry::Address&amp;'  =&gt;  'kde_EntryAddress' ,
+'EnumComponent&amp;' =&gt; 'kde_EnumComponent*',
+'EnumComponent*' =&gt; 'kde_EnumComponent*',
+'EnumDef&amp;' =&gt; 'kde_EnumDef*',
+'EnumDef*' =&gt; 'kde_EnumDef*',
+'EnumEntry*' =&gt; 'kde_EnumEntry*',
+'Error*' =&gt; 'kde_Error*',
+'Event*' =&gt; 'kde_Event*',
+'ExecState*' =&gt; 'kde_ExecState*',
+'ExtensionLoader*' =&gt; 'kde_ExtensionLoader*',
+'FALSE' =&gt; '0',
+'FMOut*' =&gt; 'kde_FMOut*',
+'Factory*' =&gt; 'kde_Factory*',
+'False' =&gt; '0',
+'FileCopyJob*' =&gt; 'kde_FileCopyJob*',
+'FileProtocol*' =&gt; 'kde_FileProtocol*',
+'FileView&amp;'  =&gt;  'int' ,
+'FloatAsyncStream*' =&gt; 'kde_FloatAsyncStream*',
+'FloatDataPacket*' =&gt; 'kde_FloatDataPacket*',
+'FlowSystem&amp;' =&gt; 'kde_FlowSystem*',
+'FlowSystem' =&gt; 'kde_FlowSystem*',
+'FlowSystem*' =&gt; 'kde_FlowSystem*',
+'FlowSystemReceiver&amp;' =&gt; 'kde_FlowSystemReceiver*',
+'FlowSystemReceiver' =&gt; 'kde_FlowSystemReceiver*',
+'FlowSystemReceiver*' =&gt; 'kde_FlowSystemReceiver*',
+'FlowSystemReceiver_base*' =&gt; 'kde_FlowSystemReceiver_base*',
+'FlowSystemReceiver_skel*' =&gt; 'kde_FlowSystemReceiver_skel*',
+'FlowSystemReceiver_stub*' =&gt; 'kde_FlowSystemReceiver_stub*',
+'FlowSystemSender&amp;' =&gt; 'kde_FlowSystemSender*',
+'FlowSystemSender' =&gt; 'kde_FlowSystemSender*',
+'FlowSystemSender*' =&gt; 'kde_FlowSystemSender*',
+'FlowSystemSender_base*' =&gt; 'kde_FlowSystemSender_base*',
+'FlowSystemSender_skel*' =&gt; 'kde_FlowSystemSender_skel*',
+'FlowSystemSender_stub*' =&gt; 'kde_FlowSystemSender_stub*',
+'FlowSystem_base*' =&gt; 'kde_FlowSystem_base*',
+'FlowSystem_impl*' =&gt; 'kde_FlowSystem_impl*',
+'FlowSystem_skel*' =&gt; 'kde_FlowSystem_skel*',
+'FlowSystem_stub*' =&gt; 'kde_FlowSystem_stub*',
+'FocusPolicy' =&gt; 'int',
+'Format&amp;' =&gt; 'kde_Format*',
+'Format*' =&gt; 'kde_Format*',
+'Function*' =&gt; 'kde_Function*',
+'FunctionImp*' =&gt; 'kde_FunctionImp*',
+'GCI&amp;'  =&gt;  'GCI*' ,
+'GCI'  =&gt;  'GCI*' ,
+'GCI*'  =&gt;  'GCI*' ,
+'GUIActivateEvent*' =&gt; 'kde_GUIActivateEvent*',
+'GUIStyle' =&gt; 'int',
+'GUSOut*' =&gt; 'kde_GUSOut*',
+'GenericAsyncStream*' =&gt; 'kde_GenericAsyncStream*',
+'GenericDataChannel*' =&gt; 'kde_GenericDataChannel*',
+'GenericDataPacket*' =&gt; 'kde_GenericDataPacket*',
+'GenericFactory*' =&gt; 'kde_GenericFactory*',
+'GenericFactoryBase*' =&gt; 'kde_GenericFactoryBase*',
+'Global*' =&gt; 'kde_Global*',
+'GlobalComm&amp;' =&gt; 'kde_GlobalComm*',
+'GlobalComm' =&gt; 'kde_GlobalComm*',
+'GlobalComm*' =&gt; 'kde_GlobalComm*',
+'GlobalComm_base*' =&gt; 'kde_GlobalComm_base*',
+'GlobalComm_skel*' =&gt; 'kde_GlobalComm_skel*',
+'GlobalComm_stub*' =&gt; 'kde_GlobalComm_stub*',
+'HANDLE' =&gt; 'unsigned int',
+'HBITMAP'  =&gt;  'void*' ,
+'HCURSOR'  =&gt;  'void*' ,
+'HDC'  =&gt;  'void*' ,
+'HFONT'  =&gt;  'void*' ,
+'HPALETTE'  =&gt;  'void*' ,
+'HRGN'  =&gt;  'void*' ,
+'HTMLAnchorElement&amp;' =&gt; 'kde_HTMLAnchorElement*',
+'HTMLAnchorElement*' =&gt; 'kde_HTMLAnchorElement*',
+'HTMLAnchorElementImpl*' =&gt; 'kde_HTMLAnchorElementImpl*',
+'HTMLAppletElement&amp;' =&gt; 'kde_HTMLAppletElement*',
+'HTMLAppletElement*' =&gt; 'kde_HTMLAppletElement*',
+'HTMLAppletElementImpl*' =&gt; 'kde_HTMLAppletElementImpl*',
+'HTMLAreaElement&amp;' =&gt; 'kde_HTMLAreaElement*',
+'HTMLAreaElement*' =&gt; 'kde_HTMLAreaElement*',
+'HTMLAreaElementImpl*' =&gt; 'kde_HTMLAreaElementImpl*',
+'HTMLBRElement&amp;' =&gt; 'kde_HTMLBRElement*',
+'HTMLBRElement*' =&gt; 'kde_HTMLBRElement*',
+'HTMLBRElementImpl*' =&gt; 'kde_HTMLBRElementImpl*',
+'HTMLBaseElement&amp;' =&gt; 'kde_HTMLBaseElement*',
+'HTMLBaseElement*' =&gt; 'kde_HTMLBaseElement*',
+'HTMLBaseElementImpl*' =&gt; 'kde_HTMLBaseElementImpl*',
+'HTMLBaseFontElement&amp;' =&gt; 'kde_HTMLBaseFontElement*',
+'HTMLBaseFontElement*' =&gt; 'kde_HTMLBaseFontElement*',
+'HTMLBaseFontElementImpl*' =&gt; 'kde_HTMLBaseFontElementImpl*',
+'HTMLBlockquoteElement&amp;' =&gt; 'kde_HTMLBlockquoteElement*',
+'HTMLBlockquoteElement*' =&gt; 'kde_HTMLBlockquoteElement*',
+'HTMLBlockquoteElementImpl*' =&gt; 'kde_HTMLBlockquoteElementImpl*',
+'HTMLBodyElement&amp;' =&gt; 'kde_HTMLBodyElement*',
+'HTMLBodyElement*' =&gt; 'kde_HTMLBodyElement*',
+'HTMLBodyElementImpl*' =&gt; 'kde_HTMLBodyElementImpl*',
+'HTMLButtonElement&amp;' =&gt; 'kde_HTMLButtonElement*',
+'HTMLButtonElement*' =&gt; 'kde_HTMLButtonElement*',
+'HTMLButtonElementImpl*' =&gt; 'kde_HTMLButtonElementImpl*',
+'HTMLCollection&amp;' =&gt; 'kde_HTMLCollection*',
+'HTMLCollection' =&gt; 'kde_HTMLCollection*',
+'HTMLCollection*' =&gt; 'kde_HTMLCollection*',
+'HTMLCollectionImpl*' =&gt; 'kde_HTMLCollectionImpl*',
+'HTMLDListElement&amp;' =&gt; 'kde_HTMLDListElement*',
+'HTMLDListElement*' =&gt; 'kde_HTMLDListElement*',
+'HTMLDListElementImpl*' =&gt; 'kde_HTMLDListElementImpl*',
+'HTMLDirectoryElement&amp;' =&gt; 'kde_HTMLDirectoryElement*',
+'HTMLDirectoryElement*' =&gt; 'kde_HTMLDirectoryElement*',
+'HTMLDirectoryElementImpl*' =&gt; 'kde_HTMLDirectoryElementImpl*',
+'HTMLDivElement&amp;' =&gt; 'kde_HTMLDivElement*',
+'HTMLDivElement*' =&gt; 'kde_HTMLDivElement*',
+'HTMLDivElementImpl*' =&gt; 'kde_HTMLDivElementImpl*',
+'HTMLDocument&amp;' =&gt; 'kde_HTMLDocument*',
+'HTMLDocument*' =&gt; 'kde_HTMLDocument*',
+'HTMLDocumentImpl*' =&gt; 'kde_HTMLDocumentImpl*',
+'HTMLElement&amp;' =&gt; 'kde_HTMLElement*',
+'HTMLElement' =&gt; 'kde_HTMLElement*',
+'HTMLElement*' =&gt; 'kde_HTMLElement*',
+'HTMLElementImpl*' =&gt; 'kde_HTMLElementImpl*',
+'HTMLFieldSetElement&amp;' =&gt; 'kde_HTMLFieldSetElement*',
+'HTMLFieldSetElement*' =&gt; 'kde_HTMLFieldSetElement*',
+'HTMLFieldSetElementImpl*' =&gt; 'kde_HTMLFieldSetElementImpl*',
+'HTMLFontElement&amp;' =&gt; 'kde_HTMLFontElement*',
+'HTMLFontElement*' =&gt; 'kde_HTMLFontElement*',
+'HTMLFontElementImpl*' =&gt; 'kde_HTMLFontElementImpl*',
+'HTMLFormElement&amp;' =&gt; 'kde_HTMLFormElement*',
+'HTMLFormElement' =&gt; 'kde_HTMLFormElement*',
+'HTMLFormElement*' =&gt; 'kde_HTMLFormElement*',
+'HTMLFormElementImpl*' =&gt; 'kde_HTMLFormElementImpl*',
+'HTMLFrameElement&amp;' =&gt; 'kde_HTMLFrameElement*',
+'HTMLFrameElement*' =&gt; 'kde_HTMLFrameElement*',
+'HTMLFrameElementImpl*' =&gt; 'kde_HTMLFrameElementImpl*',
+'HTMLFrameSetElement&amp;' =&gt; 'kde_HTMLFrameSetElement*',
+'HTMLFrameSetElement*' =&gt; 'kde_HTMLFrameSetElement*',
+'HTMLFrameSetElementImpl*' =&gt; 'kde_HTMLFrameSetElementImpl*',
+'HTMLHRElement&amp;' =&gt; 'kde_HTMLHRElement*',
+'HTMLHRElement*' =&gt; 'kde_HTMLHRElement*',
+'HTMLHRElementImpl*' =&gt; 'kde_HTMLHRElementImpl*',
+'HTMLHeadElement&amp;' =&gt; 'kde_HTMLHeadElement*',
+'HTMLHeadElement*' =&gt; 'kde_HTMLHeadElement*',
+'HTMLHeadElementImpl*' =&gt; 'kde_HTMLHeadElementImpl*',
+'HTMLHeadingElement&amp;' =&gt; 'kde_HTMLHeadingElement*',
+'HTMLHeadingElement*' =&gt; 'kde_HTMLHeadingElement*',
+'HTMLHeadingElementImpl*' =&gt; 'kde_HTMLHeadingElementImpl*',
+'HTMLHtmlElement&amp;' =&gt; 'kde_HTMLHtmlElement*',
+'HTMLHtmlElement*' =&gt; 'kde_HTMLHtmlElement*',
+'HTMLHtmlElementImpl*' =&gt; 'kde_HTMLHtmlElementImpl*',
+'HTMLIFrameElement&amp;' =&gt; 'kde_HTMLIFrameElement*',
+'HTMLIFrameElement*' =&gt; 'kde_HTMLIFrameElement*',
+'HTMLIFrameElementImpl*' =&gt; 'kde_HTMLIFrameElementImpl*',
+'HTMLImageElement&amp;' =&gt; 'kde_HTMLImageElement*',
+'HTMLImageElement*' =&gt; 'kde_HTMLImageElement*',
+'HTMLImageElementImpl*' =&gt; 'kde_HTMLImageElementImpl*',
+'HTMLInputElement&amp;' =&gt; 'kde_HTMLInputElement*',
+'HTMLInputElement*' =&gt; 'kde_HTMLInputElement*',
+'HTMLInputElementImpl*' =&gt; 'kde_HTMLInputElementImpl*',
+'HTMLIsIndexElement&amp;' =&gt; 'kde_HTMLIsIndexElement*',
+'HTMLIsIndexElement*' =&gt; 'kde_HTMLIsIndexElement*',
+'HTMLIsIndexElementImpl*' =&gt; 'kde_HTMLIsIndexElementImpl*',
+'HTMLLIElement&amp;' =&gt; 'kde_HTMLLIElement*',
+'HTMLLIElement*' =&gt; 'kde_HTMLLIElement*',
+'HTMLLIElementImpl*' =&gt; 'kde_HTMLLIElementImpl*',
+'HTMLLabelElement&amp;' =&gt; 'kde_HTMLLabelElement*',
+'HTMLLabelElement*' =&gt; 'kde_HTMLLabelElement*',
+'HTMLLabelElementImpl*' =&gt; 'kde_HTMLLabelElementImpl*',
+'HTMLLegendElement&amp;' =&gt; 'kde_HTMLLegendElement*',
+'HTMLLegendElement*' =&gt; 'kde_HTMLLegendElement*',
+'HTMLLegendElementImpl*' =&gt; 'kde_HTMLLegendElementImpl*',
+'HTMLLinkElement&amp;' =&gt; 'kde_HTMLLinkElement*',
+'HTMLLinkElement*' =&gt; 'kde_HTMLLinkElement*',
+'HTMLLinkElementImpl*' =&gt; 'kde_HTMLLinkElementImpl*',
+'HTMLMapElement&amp;' =&gt; 'kde_HTMLMapElement*',
+'HTMLMapElement*' =&gt; 'kde_HTMLMapElement*',
+'HTMLMapElementImpl*' =&gt; 'kde_HTMLMapElementImpl*',
+'HTMLMenuElement&amp;' =&gt; 'kde_HTMLMenuElement*',
+'HTMLMenuElement*' =&gt; 'kde_HTMLMenuElement*',
+'HTMLMenuElementImpl*' =&gt; 'kde_HTMLMenuElementImpl*',
+'HTMLMetaElement&amp;' =&gt; 'kde_HTMLMetaElement*',
+'HTMLMetaElement*' =&gt; 'kde_HTMLMetaElement*',
+'HTMLMetaElementImpl*' =&gt; 'kde_HTMLMetaElementImpl*',
+'HTMLModElement&amp;' =&gt; 'kde_HTMLModElement*',
+'HTMLModElement*' =&gt; 'kde_HTMLModElement*',
+'HTMLModElementImpl*' =&gt; 'kde_HTMLModElementImpl*',
+'HTMLOListElement&amp;' =&gt; 'kde_HTMLOListElement*',
+'HTMLOListElement*' =&gt; 'kde_HTMLOListElement*',
+'HTMLOListElementImpl*' =&gt; 'kde_HTMLOListElementImpl*',
+'HTMLObjectElement&amp;' =&gt; 'kde_HTMLObjectElement*',
+'HTMLObjectElement*' =&gt; 'kde_HTMLObjectElement*',
+'HTMLObjectElementImpl*' =&gt; 'kde_HTMLObjectElementImpl*',
+'HTMLOptGroupElement&amp;' =&gt; 'kde_HTMLOptGroupElement*',
+'HTMLOptGroupElement*' =&gt; 'kde_HTMLOptGroupElement*',
+'HTMLOptGroupElementImpl*' =&gt; 'kde_HTMLOptGroupElementImpl*',
+'HTMLOptionElement&amp;' =&gt; 'kde_HTMLOptionElement*',
+'HTMLOptionElement*' =&gt; 'kde_HTMLOptionElement*',
+'HTMLOptionElementImpl*' =&gt; 'kde_HTMLOptionElementImpl*',
+'HTMLParagraphElement&amp;' =&gt; 'kde_HTMLParagraphElement*',
+'HTMLParagraphElement*' =&gt; 'kde_HTMLParagraphElement*',
+'HTMLParagraphElementImpl*' =&gt; 'kde_HTMLParagraphElementImpl*',
+'HTMLParamElement&amp;' =&gt; 'kde_HTMLParamElement*',
+'HTMLParamElement*' =&gt; 'kde_HTMLParamElement*',
+'HTMLParamElementImpl*' =&gt; 'kde_HTMLParamElementImpl*',
+'HTMLPreElement&amp;' =&gt; 'kde_HTMLPreElement*',
+'HTMLPreElement*' =&gt; 'kde_HTMLPreElement*',
+'HTMLPreElementImpl*' =&gt; 'kde_HTMLPreElementImpl*',
+'HTMLQuoteElement&amp;' =&gt; 'kde_HTMLQuoteElement*',
+'HTMLQuoteElement*' =&gt; 'kde_HTMLQuoteElement*',
+'HTMLQuoteElementImpl*' =&gt; 'kde_HTMLQuoteElementImpl*',
+'HTMLScriptElement&amp;' =&gt; 'kde_HTMLScriptElement*',
+'HTMLScriptElement*' =&gt; 'kde_HTMLScriptElement*',
+'HTMLScriptElementImpl*' =&gt; 'kde_HTMLScriptElementImpl*',
+'HTMLSelectElement&amp;' =&gt; 'kde_HTMLSelectElement*',
+'HTMLSelectElement*' =&gt; 'kde_HTMLSelectElement*',
+'HTMLSelectElementImpl*' =&gt; 'kde_HTMLSelectElementImpl*',
+'HTMLStyleElement&amp;' =&gt; 'kde_HTMLStyleElement*',
+'HTMLStyleElement*' =&gt; 'kde_HTMLStyleElement*',
+'HTMLStyleElementImpl*' =&gt; 'kde_HTMLStyleElementImpl*',
+'HTMLTableCaptionElement&amp;' =&gt; 'kde_HTMLTableCaptionElement*',
+'HTMLTableCaptionElement' =&gt; 'kde_HTMLTableCaptionElement*',
+'HTMLTableCaptionElement*' =&gt; 'kde_HTMLTableCaptionElement*',
+'HTMLTableCaptionElementImpl*' =&gt; 'kde_HTMLTableCaptionElementImpl*',
+'HTMLTableCellElement&amp;' =&gt; 'kde_HTMLTableCellElement*',
+'HTMLTableCellElement*' =&gt; 'kde_HTMLTableCellElement*',
+'HTMLTableCellElementImpl*' =&gt; 'kde_HTMLTableCellElementImpl*',
+'HTMLTableColElement&amp;' =&gt; 'kde_HTMLTableColElement*',
+'HTMLTableColElement*' =&gt; 'kde_HTMLTableColElement*',
+'HTMLTableColElementImpl*' =&gt; 'kde_HTMLTableColElementImpl*',
+'HTMLTableElement&amp;' =&gt; 'kde_HTMLTableElement*',
+'HTMLTableElement*' =&gt; 'kde_HTMLTableElement*',
+'HTMLTableElementImpl*' =&gt; 'kde_HTMLTableElementImpl*',
+'HTMLTableRowElement&amp;' =&gt; 'kde_HTMLTableRowElement*',
+'HTMLTableRowElement*' =&gt; 'kde_HTMLTableRowElement*',
+'HTMLTableRowElementImpl*' =&gt; 'kde_HTMLTableRowElementImpl*',
+'HTMLTableSectionElement&amp;' =&gt; 'kde_HTMLTableSectionElement*',
+'HTMLTableSectionElement' =&gt; 'kde_HTMLTableSectionElement*',
+'HTMLTableSectionElement*' =&gt; 'kde_HTMLTableSectionElement*',
+'HTMLTableSectionElementImpl*' =&gt; 'kde_HTMLTableSectionElementImpl*',
+'HTMLTextAreaElement&amp;' =&gt; 'kde_HTMLTextAreaElement*',
+'HTMLTextAreaElement*' =&gt; 'kde_HTMLTextAreaElement*',
+'HTMLTextAreaElementImpl*' =&gt; 'kde_HTMLTextAreaElementImpl*',
+'HTMLTitleElement&amp;' =&gt; 'kde_HTMLTitleElement*',
+'HTMLTitleElement*' =&gt; 'kde_HTMLTitleElement*',
+'HTMLTitleElementImpl*' =&gt; 'kde_HTMLTitleElementImpl*',
+'HTMLUListElement&amp;' =&gt; 'kde_HTMLUListElement*',
+'HTMLUListElement*' =&gt; 'kde_HTMLUListElement*',
+'HTMLUListElementImpl*' =&gt; 'kde_HTMLUListElementImpl*',
+'HandlerType'  =&gt;  'qt_HandlerType*' ,
+'HashEntry*' =&gt; 'kde_HashEntry*',
+'HashTable*' =&gt; 'kde_HashTable*',
+'Header&amp;' =&gt; 'kde_Header*',
+'Header*' =&gt; 'kde_Header*',
+'HighlightingInterface*' =&gt; 'kde_HighlightingInterface*',
+'HistoryProvider*' =&gt; 'kde_HistoryProvider*',
+'HostImp*' =&gt; 'kde_HostImp*',
+'IDLFileReg*' =&gt; 'kde_IDLFileReg*',
+'IOManager*' =&gt; 'kde_IOManager*',
+'IONotify*' =&gt; 'kde_IONotify*',
+'IOType*' =&gt; 'kde_IOType*',
+'IOWatchFD*' =&gt; 'kde_IOWatchFD*',
+'Icon' =&gt; 'int',
+'IconListBox*' =&gt; 'kde_IconListBox*',
+'Imp*' =&gt; 'void*',
+'Info*' =&gt; 'kde_Info*',
+'InterfaceDef&amp;' =&gt; 'kde_InterfaceDef*',
+'InterfaceDef' =&gt; 'kde_InterfaceDef*',
+'InterfaceDef*' =&gt; 'kde_InterfaceDef*',
+'InterfaceEntry*' =&gt; 'kde_InterfaceEntry*',
+'InterfaceRepo&amp;' =&gt; 'kde_InterfaceRepo*',
+'InterfaceRepo' =&gt; 'kde_InterfaceRepo*',
+'InterfaceRepo*' =&gt; 'kde_InterfaceRepo*',
+'InterfaceRepo_base*' =&gt; 'kde_InterfaceRepo_base*',
+'InterfaceRepo_impl*' =&gt; 'kde_InterfaceRepo_impl*',
+'InterfaceRepo_skel*' =&gt; 'kde_InterfaceRepo_skel*',
+'InterfaceRepo_stub*' =&gt; 'kde_InterfaceRepo_stub*',
+'InternalFunctionImp*' =&gt; 'kde_InternalFunctionImp*',
+'Interpreter*' =&gt; 'kde_Interpreter*',
+'Invocation&amp;' =&gt; 'kde_Invocation*',
+'Invocation*' =&gt; 'kde_Invocation*',
+'Iterator'  =&gt;  'Iterator*' ,
+'Job*' =&gt; 'void*',
+'K&amp;'  =&gt;  'K*' ,
+'KAboutApplication*' =&gt; 'kde_KAboutApplication*',
+'KAboutContainer*'  =&gt;  'kde_KAboutContainer*' ,
+'KAboutContributor*' =&gt; 'kde_KAboutContributor*',
+'KAboutData*'  =&gt;  'kde_KAboutData*' ,
+'KAboutDialog*' =&gt; 'kde_KAboutDialog*',
+'KAboutKDE*' =&gt; 'kde_KAboutKDE*',
+'KAboutPerson*' =&gt; 'kde_KAboutPerson*',
+'KAboutTranslator*' =&gt; 'kde_KAboutTranslator*',
+'KAboutWidget*' =&gt; 'kde_KAboutWidget*',
+'KAccel*'  =&gt;  'kde_KAccel*' ,
+'KAccelAction&amp;' =&gt; 'kde_KAccelAction*',
+'KAccelAction*' =&gt; 'kde_KAccelAction*',
+'KAccelActions&amp;' =&gt; 'kde_KAccelActions*',
+'KAccelActions*' =&gt; 'kde_KAccelActions*',
+'KAccelBase*' =&gt; 'kde_KAccelBase*',
+'KAccelGen*' =&gt; 'kde_KAccelGen*',
+'KAccelMenu*' =&gt; 'kde_KAccelMenu*',
+'KAccelSequence&amp;' =&gt; 'kde_KAccelSequence*',
+'KAccelSequence' =&gt; 'kde_KAccelSequence*',
+'KAccelSequence*' =&gt; 'kde_KAccelSequence*',
+'KAccelShortcut&amp;' =&gt; 'kde_KAccelShortcut*',
+'KAccelShortcut' =&gt; 'kde_KAccelShortcut*',
+'KAccelShortcut*' =&gt; 'kde_KAccelShortcut*',
+'KAccelShortcuts&amp;' =&gt; 'kde_KAccelShortcuts*',
+'KAccelShortcuts*' =&gt; 'kde_KAccelShortcuts*',
+'KAction*'  =&gt;  'kde_KAction*' ,
+'KActionCollection&amp;'  =&gt; 'kde_KActionCollection*' ,
+'KActionCollection'  =&gt; 'kde_KActionCollection*' ,
+'KActionCollection*'  =&gt; 'kde_KActionCollection*' ,
+'KActionMenu*' =&gt; 'kde_KActionMenu*',
+'KActionSeparator*' =&gt; 'kde_KActionSeparator*',
+'KAddressInfo*' =&gt; 'kde_KAddressInfo*',
+'KAlphaPainter*' =&gt; 'kde_KAlphaPainter*',
+'KAnimWidget*'  =&gt;  'kde_KAnimWidget*' ,
+'KAppTreeListItem*'  =&gt;  'kde_KAppTreeListItem*' ,
+'KApplication*'  =&gt;  'kde_KApplication*' ,
+'KApplicationPropsPlugin*' =&gt; 'kde_KApplicationPropsPlugin*',
+'KApplicationTree*' =&gt; 'kde_KApplicationTree*',
+'KArchive*' =&gt; 'kde_KArchive*',
+'KArchiveDirectory*' =&gt; 'kde_KArchiveDirectory*',
+'KArchiveEntry*' =&gt; 'kde_KArchiveEntry*',
+'KArchiveFile*' =&gt; 'kde_KArchiveFile*',
+'KArrowButton*' =&gt; 'kde_KArrowButton*',
+'KArtsDispatcher*' =&gt; 'kde_KArtsDispatcher*',
+'KArtsFloatWatch*' =&gt; 'kde_KArtsFloatWatch*',
+'KAsyncIO*' =&gt; 'kde_KAsyncIO*',
+'KAudioPlayer*' =&gt; 'kde_KAudioPlayer*',
+'KAuthIcon*' =&gt; 'kde_KAuthIcon*',
+'KAutoMount*' =&gt; 'kde_KAutoMount*',
+'KAutoUnmount*' =&gt; 'kde_KAutoUnmount*',
+'KBindingPropsPlugin*' =&gt; 'kde_KBindingPropsPlugin*',
+'KBlankEffect*' =&gt; 'kde_KBlankEffect*',
+'KBufferedIO*' =&gt; 'kde_KBufferedIO*',
+'KBugReport*' =&gt; 'kde_KBugReport*',
+'KButtonBox*' =&gt; 'kde_KButtonBox*',
+'KCModule*'  =&gt;  'kde_KCModule*' ,
+'KCatalogue&amp;' =&gt; 'kde_KCatalogue*',
+'KCatalogue*' =&gt; 'kde_KCatalogue*',
+'KCharSelect*' =&gt; 'kde_KCharSelect*',
+'KCharSelectTable*' =&gt; 'kde_KCharSelectTable*',
+'KCharsets*'  =&gt;  'kde_KCharsets*' ,
+'KCmdLineArgs*'  =&gt;  'kde_KCmdLineArgs*' ,
+'KCodecs*' =&gt; 'kde_KCodecs*',
+'KColor&amp;'  =&gt; 'kde_KColor*' ,
+'KColor*' =&gt; 'kde_KColor*',
+'KColorButton*' =&gt; 'kde_KColorButton*',
+'KColorCells*' =&gt; 'kde_KColorCells*',
+'KColorCombo*' =&gt; 'kde_KColorCombo*',
+'KColorDialog*' =&gt; 'kde_KColorDialog*',
+'KColorDrag*'  =&gt;  'kde_KColorDrag*' ,
+'KColorPatch*' =&gt; 'kde_KColorPatch*',
+'KCombiView*' =&gt; 'kde_KCombiView*',
+'KComboBox*'  =&gt;  'kde_KComboBox*' ,
+'KCommand*' =&gt; 'kde_KCommand*',
+'KCommandHistory*' =&gt; 'kde_KCommandHistory*',
+'KCompletion*'  =&gt;  'kde_KCompletion*' ,
+'KCompletionBase*' =&gt; 'kde_KCompletionBase*',
+'KCompletionBox*' =&gt; 'kde_KCompletionBox*',
+'KConfig*'  =&gt; 'kde_KConfig*' ,
+'KConfigBackEnd*' =&gt; 'kde_KConfigBackEnd*',
+'KConfigBase&amp;' =&gt; 'kde_KConfigBase*',
+'KConfigBase*'  =&gt; 'kde_KConfigBase*' ,
+'KConfigGroup*' =&gt; 'kde_KConfigGroup*',
+'KConfigGroupSaver*' =&gt; 'kde_KConfigGroupSaver*',
+'KConfigINIBackEnd*' =&gt; 'kde_KConfigINIBackEnd*',
+'KContainerLayout*' =&gt; 'kde_KContainerLayout*',
+'KContainerLayoutItem*'  =&gt; 'kde_KContainerLayoutItem*' ,
+'KContextMenuManager*' =&gt; 'kde_KContextMenuManager*',
+'KCookie*' =&gt; 'kde_KCookie*',
+'KCrash*' =&gt; 'kde_KCrash*',
+'KCursor*' =&gt; 'kde_KCursor*',
+'KDBGFUNC'  =&gt; 'void*' ,
+'KDCOPActionProxy*' =&gt; 'kde_KDCOPActionProxy*',
+'KDCOPPropertyProxy*' =&gt; 'kde_KDCOPPropertyProxy*',
+'KDEAniMenu*' =&gt; 'kde_KDEAniMenu*',
+'KDEDModule*' =&gt; 'kde_KDEDModule*',
+'KDEDesktopMimeType*' =&gt; 'kde_KDEDesktopMimeType*',
+'KDESasl*' =&gt; 'kde_KDESasl*',
+'KDEStyle*' =&gt; 'kde_KDEStyle*',
+'KDEsuClient*' =&gt; 'kde_KDEsuClient*',
+'KDataTool*' =&gt; 'kde_KDataTool*',
+'KDataToolAction*' =&gt; 'kde_KDataToolAction*',
+'KDataToolInfo&amp;' =&gt; 'kde_KDataToolInfo*',
+'KDataToolInfo*' =&gt; 'kde_KDataToolInfo*',
+'KDateInternalMonthPicker*' =&gt; 'kde_KDateInternalMonthPicker*',
+'KDateInternalYearSelector*' =&gt; 'kde_KDateInternalYearSelector*',
+'KDatePicker*' =&gt; 'kde_KDatePicker*',
+'KDateTable*' =&gt; 'kde_KDateTable*',
+'KDateValidator*' =&gt; 'kde_KDateValidator*',
+'KDateWidget*' =&gt; 'kde_KDateWidget*',
+'KDesktopFile*'  =&gt; 'kde_KDesktopFile*' ,
+'KDevApi*' =&gt; 'kde_KDevApi*',
+'KDevAppFrontend*' =&gt; 'kde_KDevAppFrontend*',
+'KDevCompilerOptions*' =&gt; 'kde_KDevCompilerOptions*',
+'KDevCore*' =&gt; 'kde_KDevCore*',
+'KDevFactory*' =&gt; 'kde_KDevFactory*',
+'KDevLanguageSupport*' =&gt; 'kde_KDevLanguageSupport*',
+'KDevMakeFrontend*' =&gt; 'kde_KDevMakeFrontend*',
+'KDevPart*' =&gt; 'kde_KDevPart*',
+'KDevProject*' =&gt; 'kde_KDevProject*',
+'KDevVersionControl*' =&gt; 'kde_KDevVersionControl*',
+'KDevicePropsPlugin*' =&gt; 'kde_KDevicePropsPlugin*',
+'KDialog*' =&gt; 'kde_KDialog*',
+'KDialogBase*'  =&gt;  'kde_KDialogBase*' ,
+'KDialogBaseTile*' =&gt; 'kde_KDialogBaseTile*',
+'KDialogQueue*' =&gt; 'kde_KDialogQueue*',
+'KDirNotify*' =&gt; 'kde_KDirNotify*',
+'KDirNotify_stub*' =&gt; 'kde_KDirNotify_stub*',
+'KDirOperator*' =&gt; 'kde_KDirOperator*',
+'KDirSelectDialog*' =&gt; 'kde_KDirSelectDialog*',
+'KDirSize*'  =&gt;  'kde_KDirSize*' ,
+'KDirWatch*'  =&gt;  'kde_KDirWatch*' ,
+'KDirectionButton*' =&gt; 'kde_KDirectionButton*',
+'KDockArea*' =&gt; 'kde_KDockArea*',
+'KDockMainWindow*' =&gt; 'kde_KDockMainWindow*',
+'KDockManager*'  =&gt; 'kde_KDockManager*' ,
+'KDockTabBar*' =&gt; 'kde_KDockTabBar*',
+'KDockTabBar::TabPos' =&gt; 'int',
+'KDockTabBarPainter*' =&gt; 'kde_KDockTabBarPainter*',
+'KDockTabCtl*' =&gt; 'kde_KDockTabCtl*',
+'KDockTabCtl_PrivateStruct*'  =&gt;  'kde_KDockTabCtl_PrivateStruct*' ,
+'KDockTabGroup*'  =&gt;  'kde_KDockTabGroup*' ,
+'KDockWidget*'  =&gt; 'kde_KDockWidget*' ,
+'KDockWidgetAbstractHeader*'  =&gt; 'kde_KDockWidgetAbstractHeader*' ,
+'KDockWidgetAbstractHeaderDrag*' =&gt; 'kde_KDockWidgetAbstractHeaderDrag*',
+'KDockWidgetHeader*' =&gt; 'kde_KDockWidgetHeader*',
+'KDockWidgetHeaderDrag*' =&gt; 'kde_KDockWidgetHeaderDrag*',
+'KDockWindow*' =&gt; 'kde_KDockWindow*',
+'KDoubleNumInput*' =&gt; 'kde_KDoubleNumInput*',
+'KDualColorButton*' =&gt; 'kde_KDualColorButton*',
+'KEMailSettings*' =&gt; 'kde_KEMailSettings*',
+'KEdFind*' =&gt; 'kde_KEdFind*',
+'KEdGotoLine*' =&gt; 'kde_KEdGotoLine*',
+'KEdReplace*' =&gt; 'kde_KEdReplace*',
+'KEdit*' =&gt; 'kde_KEdit*',
+'KEditListBox*' =&gt; 'kde_KEditListBox*',
+'KEditToolbar*' =&gt; 'kde_KEditToolbar*',
+'KEditToolbarWidget*' =&gt; 'kde_KEditToolbarWidget*',
+'KEntry&amp;'  =&gt; 'kde_KEntry*' ,
+'KEntry'  =&gt; 'kde_KEntry*' ,
+'KEntry*' =&gt; 'kde_KEntry*',
+'KEntryKey&amp;'  =&gt; 'kde_KEntryKey*' ,
+'KEntryKey*' =&gt; 'kde_KEntryKey*',
+'KExecMimeType*' =&gt; 'kde_KExecMimeType*',
+'KExecPropsPlugin*' =&gt; 'kde_KExecPropsPlugin*',
+'KFile*' =&gt; 'kde_KFile*',
+'KFile::FileView'  =&gt; 'int' ,
+'KFile::Mode'  =&gt; 'int' ,
+'KFile::SelectionMode'  =&gt; 'int' ,
+'KFileBookmark*'  =&gt;  'kde_KFileBookmark*' ,
+'KFileBookmarkManager*' =&gt; 'kde_KFileBookmarkManager*',
+'KFileComboBox*' =&gt; 'kde_KFileComboBox*',
+'KFileDetailView*' =&gt; 'kde_KFileDetailView*',
+'KFileDialog*'  =&gt;  'kde_KFileDialog*' ,
+'KFileFilter*' =&gt; 'kde_KFileFilter*',
+'KFileFilterCombo*' =&gt; 'kde_KFileFilterCombo*',
+'KFileIconView*' =&gt; 'kde_KFileIconView*',
+'KFileIconViewItem*' =&gt; 'kde_KFileIconViewItem*',
+'KFileItemList&amp;'  =&gt; 'kde_KFileItemList*' ,
+'KFileItemList'  =&gt; 'kde_KFileItemList*' ,
+'KFileItemList*'  =&gt; 'kde_KFileItemList*' ,
+'KFileListViewItem*' =&gt; 'kde_KFileListViewItem*',
+'KFileMetaInfo*' =&gt; 'kde_KFileMetaInfo*',
+'KFileMetaInfoItem*' =&gt; 'kde_KFileMetaInfoItem*',
+'KFileMetaInfoProvider*' =&gt; 'kde_KFileMetaInfoProvider*',
+'KFileOpenWithHandler*' =&gt; 'kde_KFileOpenWithHandler*',
+'KFilePermissionsPropsPlugin*' =&gt; 'kde_KFilePermissionsPropsPlugin*',
+'KFilePlugin*' =&gt; 'kde_KFilePlugin*',
+'KFilePreview*' =&gt; 'kde_KFilePreview*',
+'KFilePropsPlugin*' =&gt; 'kde_KFilePropsPlugin*',
+'KFileReader*'  =&gt; 'kde_KFileReader*' ,
+'KFileTreeBranch*' =&gt; 'kde_KFileTreeBranch*',
+'KFileTreeView*' =&gt; 'kde_KFileTreeView*',
+'KFileTreeViewItem*' =&gt; 'kde_KFileTreeViewItem*',
+'KFileTreeViewToolTip*' =&gt; 'kde_KFileTreeViewToolTip*',
+'KFileView*'  =&gt; 'kde_KFileView*' ,
+'KFileView::FileView' =&gt; 'int',
+'KFileViewItem&amp;' =&gt; 'kde_KFileViewItem*',
+'KFileViewItem*'  =&gt; 'kde_KFileViewItem*' ,
+'KFileViewItem**'  =&gt; 'kde_KFileViewItem**' ,
+'KFileViewItemList&amp;'  =&gt; 'kde_KFileViewItemList*' ,
+'KFileViewItemList*'  =&gt; 'kde_KFileViewItemList*' ,
+'KFileViewSignaler*' =&gt; 'kde_KFileViewSignaler*',
+'KFilterBase*' =&gt; 'kde_KFilterBase*',
+'KFilterDev*' =&gt; 'kde_KFilterDev*',
+'KFloatValidator*' =&gt; 'kde_KFloatValidator*',
+'KFloatWatchProxy&amp;' =&gt; 'kde_KFloatWatchProxy*',
+'KFloatWatchProxy' =&gt; 'kde_KFloatWatchProxy*',
+'KFloatWatchProxy*' =&gt; 'kde_KFloatWatchProxy*',
+'KFolderType*' =&gt; 'kde_KFolderType*',
+'KFontAction*' =&gt; 'kde_KFontAction*',
+'KFontChooser*' =&gt; 'kde_KFontChooser*',
+'KFontCombo*' =&gt; 'kde_KFontCombo*',
+'KFontDialog*' =&gt; 'kde_KFontDialog*',
+'KFontSizeAction*' =&gt; 'kde_KFontSizeAction*',
+'KGenericFactory*' =&gt; 'kde_KGenericFactory*',
+'KGenericFactoryBase*' =&gt; 'kde_KGenericFactoryBase*',
+'KGlobal*' =&gt; 'kde_KGlobal*',
+'KGlobalAccel*'  =&gt;  'kde_KGlobalAccel*' ,
+'KGlobalSettings*' =&gt; 'kde_KGlobalSettings*',
+'KGlobalSettings::Completion'  =&gt; 'int' ,
+'KGradientSelector*' =&gt; 'kde_KGradientSelector*',
+'KGuiItem&amp;' =&gt; 'kde_KGuiItem*',
+'KGuiItem' =&gt; 'kde_KGuiItem*',
+'KGuiItem*' =&gt; 'kde_KGuiItem*',
+'KHSSelector*' =&gt; 'kde_KHSSelector*',
+'KHTMLPart*'  =&gt;  'kde_KHTMLPart*' ,
+'KHTMLSettings&amp;' =&gt; 'kde_KHTMLSettings*',
+'KHTMLSettings*'  =&gt; 'kde_KHTMLSettings*' ,
+'KHTMLView*'  =&gt; 'kde_KHTMLView*' ,
+'KHelpMenu*' =&gt; 'kde_KHelpMenu*',
+'KHistoryCombo*' =&gt; 'kde_KHistoryCombo*',
+'KIO*' =&gt; 'kde_KIO*',
+'KIO::CopyJob*'  =&gt; 'kde_CopyJob*' ,
+'KIO::DeleteJob*'  =&gt; 'kde_DeleteJob*' ,
+'KIO::Job*'  =&gt; 'kde_Job*' ,
+'KIO::ListJob*'  =&gt; 'kde_ListJob*' ,
+'KIO::RenameDlg_Mode' =&gt; 'int',
+'KIO::RenameDlg_Result' =&gt; 'int',
+'KIO::SimpleJob*' =&gt; 'kde_SimpleJob*',
+'KIO::SkipDlg_Result' =&gt; 'int',
+'KIO::Slave*' =&gt; 'kde_Slave*',
+'KIOInputStream&amp;' =&gt; 'kde_KIOInputStream*',
+'KIOInputStream*' =&gt; 'kde_KIOInputStream*',
+'KIOTestSlow&amp;' =&gt; 'kde_KIOTestSlow*',
+'KIOTestSlow' =&gt; 'kde_KIOTestSlow*',
+'KIOTestSlow*' =&gt; 'kde_KIOTestSlow*',
+'KIPC*' =&gt; 'kde_KIPC*',
+'KIcon'  =&gt; 'kde_KIcon*' ,
+'KIcon*' =&gt; 'kde_KIcon*',
+'KIconButton*' =&gt; 'kde_KIconButton*',
+'KIconCanvas*' =&gt; 'kde_KIconCanvas*',
+'KIconDialog*' =&gt; 'kde_KIconDialog*',
+'KIconEffect*'  =&gt;  'kde_KIconEffect*' ,
+'KIconLoader*'  =&gt; 'kde_KIconLoader*' ,
+'KIconSelectAction*' =&gt; 'kde_KIconSelectAction*',
+'KIconView*' =&gt; 'kde_KIconView*',
+'KIconViewItem*' =&gt; 'kde_KIconViewItem*',
+'KImageEffect*' =&gt; 'kde_KImageEffect*',
+'KImageFilePreview*' =&gt; 'kde_KImageFilePreview*',
+'KImageIO*' =&gt; 'kde_KImageIO*',
+'KInstance&amp;'  =&gt; 'kde_KInstance*' ,
+'KInstance'  =&gt; 'kde_KInstance*' ,
+'KInstance*'  =&gt; 'kde_KInstance*' ,
+'KIntNumInput*' =&gt; 'kde_KIntNumInput*',
+'KIntSpinBox*' =&gt; 'kde_KIntSpinBox*',
+'KIntValidator*' =&gt; 'kde_KIntValidator*',
+'KJS*' =&gt; 'kde_KJS*',
+'KJS::KJSO&amp;' =&gt; 'kde_KJS_KJSO*',
+'KJS::UString&amp;' =&gt; 'kde_KJS_UString*',
+'KJSO&amp;' =&gt; 'kde_KJSO*',
+'KJSO' =&gt; 'kde_KJSO*',
+'KJSO*' =&gt; 'kde_KJSO*',
+'KJScript*' =&gt; 'kde_KJScript*',
+'KJanusWidget*' =&gt; 'kde_KJanusWidget*',
+'KKeyChooser*' =&gt; 'kde_KKeyChooser*',
+'KKeyDialog*' =&gt; 'kde_KKeyDialog*',
+'KKeyEntry&amp;'  =&gt; 'kde_KKeyEntry*' ,
+'KKeyEntry*' =&gt; 'kde_KKeyEntry*',
+'KKeyEntryMap&amp;'  =&gt; 'kde_KKeyEntryMap*' ,
+'KKeyEntryMap'  =&gt; 'kde_KKeyEntryMap*' ,
+'KKeyEntryMap*'  =&gt; 'kde_KKeyEntryMap*' ,
+'KKeySequence&amp;' =&gt; 'kde_KKeySequence*',
+'KKeySequence' =&gt; 'kde_KKeySequence*',
+'KKeySequence*' =&gt; 'kde_KKeySequence*',
+'KKeySequence::I18N' =&gt; 'int',
+'KKeySequences&amp;' =&gt; 'kde_KKeySequences*',
+'KKeySequences' =&gt; 'kde_KKeySequences*',
+'KKeySequences*' =&gt; 'kde_KKeySequences*',
+'KLed*' =&gt; 'kde_KLed*',
+'KLibFactory*'  =&gt;  'kde_KLibFactory*' ,
+'KLibLoader*'  =&gt;  'kde_KLibLoader*' ,
+'KLineEdit*'  =&gt;  'kde_KLineEdit*' ,
+'KLineEditDlg*' =&gt; 'kde_KLineEditDlg*',
+'KListBox*' =&gt; 'kde_KListBox*',
+'KListView*'  =&gt; 'kde_KListView*' ,
+'KListViewItem*' =&gt; 'kde_KListViewItem*',
+'KLocale&amp;'  =&gt; 'kde_KLocale*' ,
+'KLocale*'  =&gt; 'kde_KLocale*' ,
+'KMJobViewer*' =&gt; 'kde_KMJobViewer*',
+'KMMainView*' =&gt; 'kde_KMMainView*',
+'KMManager*' =&gt; 'kde_KMManager*',
+'KMObject*' =&gt; 'kde_KMObject*',
+'KMPrinter&amp;' =&gt; 'kde_KMPrinter*',
+'KMPrinter*' =&gt; 'kde_KMPrinter*',
+'KMPrinterList*' =&gt; 'kde_KMPrinterList*',
+'KMPrinterPage*' =&gt; 'kde_KMPrinterPage*',
+'KMainWindow*' =&gt; 'kde_KMainWindow*',
+'KMainWindowInterface*' =&gt; 'kde_KMainWindowInterface*',
+'KMenuBar*'  =&gt; 'kde_KMenuBar*' ,
+'KMessageBox*' =&gt; 'kde_KMessageBox*',
+'KMidSimpleAPI*' =&gt; 'kde_KMidSimpleAPI*',
+'KMimeMagic*'  =&gt;  'kde_KMimeMagic*' ,
+'KMimeMagicResult*'  =&gt; 'kde_KMimeMagicResult*' ,
+'KMimeSourceFactory*'  =&gt; 'kde_KMimeSourceFactory*' ,
+'KMimeType::List&amp;'  =&gt; 'kde_KMimeType_List*' ,
+'KMouseSettings*' =&gt; 'kde_KMouseSettings*',
+'KMultipleDrag*' =&gt; 'kde_KMultipleDrag*',
+'KNDBGFUNC'  =&gt; 'void*' ,
+'KNotifyClient*' =&gt; 'kde_KNotifyClient*',
+'KNumInput*'  =&gt; 'kde_KNumInput*' ,
+'KOCRDialog*' =&gt; 'kde_KOCRDialog*',
+'KOCRDialogFactory*' =&gt; 'kde_KOCRDialogFactory*',
+'KOpenSSLProxy*' =&gt; 'kde_KOpenSSLProxy*',
+'KOpenWithDlg*' =&gt; 'kde_KOpenWithDlg*',
+'KOpenWithHandler*'  =&gt;  'kde_KOpenWithHandler*' ,
+'KPAC*' =&gt; 'kde_KPAC*',
+'KPReloadObject*' =&gt; 'kde_KPReloadObject*',
+'KPalette&amp;'  =&gt; 'kde_KPalette*' ,
+'KPalette*' =&gt; 'kde_KPalette*',
+'KPaletteTable*' =&gt; 'kde_KPaletteTable*',
+'KPanelAppMenu*' =&gt; 'kde_KPanelAppMenu*',
+'KPanelApplet*' =&gt; 'kde_KPanelApplet*',
+'KPanelExtension*' =&gt; 'kde_KPanelExtension*',
+'KPanelMenu*'  =&gt;  'kde_KPanelMenu*' ,
+'KParts*' =&gt; 'kde_KParts*',
+'KParts::BrowserExtension*'  =&gt; 'kde_BrowserExtension*' ,
+'KParts::GUIActivateEvent*'  =&gt; 'kde_GUIActivateEvent*' ,
+'KParts::Part*' =&gt; 'kde_Part*',
+'KParts::ReadOnlyPart*'  =&gt; 'kde_ReadOnlyPart*' ,
+'KPasswordDialog*' =&gt; 'kde_KPasswordDialog*',
+'KPasswordEdit*' =&gt; 'kde_KPasswordEdit*',
+'KPixmap&amp;'  =&gt; 'kde_KPixmap*' ,
+'KPixmap'  =&gt; 'kde_KPixmap*' ,
+'KPixmap*' =&gt; 'kde_KPixmap*',
+'KPixmapEffect*' =&gt; 'kde_KPixmapEffect*',
+'KPixmapIO*' =&gt; 'kde_KPixmapIO*',
+'KPixmapProvider*'  =&gt; 'kde_KPixmapProvider*' ,
+'KPixmapSplitter*' =&gt; 'kde_KPixmapSplitter*',
+'KPlayObject*' =&gt; 'kde_KPlayObject*',
+'KPlayObjectFactory*' =&gt; 'kde_KPlayObjectFactory*',
+'KPopupFrame*' =&gt; 'kde_KPopupFrame*',
+'KPopupMenu*'  =&gt; 'kde_KPopupMenu*' ,
+'KPopupTitle*' =&gt; 'kde_KPopupTitle*',
+'KPreviewWidgetBase*' =&gt; 'kde_KPreviewWidgetBase*',
+'KPrintAction*' =&gt; 'kde_KPrintAction*',
+'KPrintDialogPage*' =&gt; 'kde_KPrintDialogPage*',
+'KPrinter*' =&gt; 'kde_KPrinter*',
+'KPrinterWrapper*' =&gt; 'kde_KPrinterWrapper*',
+'KProcIO*'  =&gt;  'kde_KProcIO*' ,
+'KProcess&amp;'  =&gt; 'kde_KProcess*' ,
+'KProcess*'  =&gt; 'kde_KProcess*' ,
+'KProcessController*' =&gt; 'kde_KProcessController*',
+'KProcessRunner*' =&gt; 'kde_KProcessRunner*',
+'KProgress*' =&gt; 'kde_KProgress*',
+'KPropertiesDialog*'  =&gt; 'kde_KPropertiesDialog*' ,
+'KPropsDlgPlugin*'  =&gt; 'kde_KPropsDlgPlugin*' ,
+'KProtocolInfo*' =&gt; 'kde_KProtocolInfo*',
+'KProtocolManager*' =&gt; 'kde_KProtocolManager*',
+'KPushButton*' =&gt; 'kde_KPushButton*',
+'KRFCDate*' =&gt; 'kde_KRFCDate*',
+'KRadioAction*' =&gt; 'kde_KRadioAction*',
+'KRandomSequence*' =&gt; 'kde_KRandomSequence*',
+'KRecentDocument*' =&gt; 'kde_KRecentDocument*',
+'KRegExp*' =&gt; 'kde_KRegExp*',
+'KRegExpEditor*' =&gt; 'kde_KRegExpEditor*',
+'KRegExpEditorInterface*' =&gt; 'kde_KRegExpEditorInterface*',
+'KRestrictedLine*' =&gt; 'kde_KRestrictedLine*',
+'KRootPermsIcon*' =&gt; 'kde_KRootPermsIcon*',
+'KRootPixmap*' =&gt; 'kde_KRootPixmap*',
+'KRootProp*' =&gt; 'kde_KRootProp*',
+'KRuler*' =&gt; 'kde_KRuler*',
+'KRun*' =&gt; 'kde_KRun*',
+'KSSL&amp;' =&gt; 'kde_KSSL*',
+'KSSL*' =&gt; 'kde_KSSL*',
+'KSSLAuthAction' =&gt; 'int',
+'KSSLAuthAction*' =&gt; 'int*',
+'KSSLCertBox*' =&gt; 'kde_KSSLCertBox*',
+'KSSLCertChain&amp;' =&gt; 'kde_KSSLCertChain*',
+'KSSLCertChain*' =&gt; 'kde_KSSLCertChain*',
+'KSSLCertDlg*' =&gt; 'kde_KSSLCertDlg*',
+'KSSLCertDlgRet' =&gt; 'kde_KSSLCertDlgRet*',
+'KSSLCertDlgRet*' =&gt; 'kde_KSSLCertDlgRet*',
+'KSSLCertificate&amp;' =&gt; 'kde_KSSLCertificate*',
+'KSSLCertificate*' =&gt; 'kde_KSSLCertificate*',
+'KSSLCertificateCache*' =&gt; 'kde_KSSLCertificateCache*',
+'KSSLCertificateFactory*' =&gt; 'kde_KSSLCertificateFactory*',
+'KSSLCertificateHome*' =&gt; 'kde_KSSLCertificateHome*',
+'KSSLConnectionInfo&amp;' =&gt; 'kde_KSSLConnectionInfo*',
+'KSSLConnectionInfo*' =&gt; 'kde_KSSLConnectionInfo*',
+'KSSLInfoDlg*' =&gt; 'kde_KSSLInfoDlg*',
+'KSSLKeyGen*' =&gt; 'kde_KSSLKeyGen*',
+'KSSLKeyType' =&gt; 'int',
+'KSSLPKCS12*' =&gt; 'kde_KSSLPKCS12*',
+'KSSLPKCS7*' =&gt; 'kde_KSSLPKCS7*',
+'KSSLPeerInfo&amp;' =&gt; 'kde_KSSLPeerInfo*',
+'KSSLPeerInfo*' =&gt; 'kde_KSSLPeerInfo*',
+'KSSLSettings*' =&gt; 'kde_KSSLSettings*',
+'KSSLSigners*' =&gt; 'kde_KSSLSigners*',
+'KSSLX509Map*' =&gt; 'kde_KSSLX509Map*',
+'KSSLX509V3&amp;' =&gt; 'kde_KSSLX509V3*',
+'KSSLX509V3*' =&gt; 'kde_KSSLX509V3*',
+'KSaveFile*' =&gt; 'kde_KSaveFile*',
+'KScanDialog*' =&gt; 'kde_KScanDialog*',
+'KScanDialogFactory*' =&gt; 'kde_KScanDialogFactory*',
+'KScreenSaver*' =&gt; 'kde_KScreenSaver*',
+'KScriptClientInterface*' =&gt; 'kde_KScriptClientInterface*',
+'KScriptClientInterface::Result' =&gt; 'int',
+'KScriptInterface*' =&gt; 'kde_KScriptInterface*',
+'KScriptManager*' =&gt; 'kde_KScriptManager*',
+'KSelectAction*' =&gt; 'kde_KSelectAction*',
+'KSelector*' =&gt; 'kde_KSelector*',
+'KSeparator*' =&gt; 'kde_KSeparator*',
+'KService&amp;'  =&gt; 'kde_KService*' ,
+'KService*' =&gt; 'kde_KService*',
+'KServiceGroup*' =&gt; 'kde_KServiceGroup*',
+'KServiceOffer&amp;'  =&gt; 'kde_KServiceOffer*' ,
+'KServiceOffer*' =&gt; 'kde_KServiceOffer*',
+'KServiceType*' =&gt; 'kde_KServiceType*',
+'KServiceTypeProfile*'  =&gt;  'kde_KServiceTypeProfile*' ,
+'KSessionManaged*' =&gt; 'kde_KSessionManaged*',
+'KShared&amp;'  =&gt; 'kde_KShared*' ,
+'KShared*' =&gt; 'kde_KShared*',
+'KSharedPtr&amp;'  =&gt; 'kde_KSharedPtr*' ,
+'KSharedPtr*' =&gt; 'kde_KSharedPtr*',
+'KShellCompletion*' =&gt; 'kde_KShellCompletion*',
+'KShellProcess*' =&gt; 'kde_KShellProcess*',
+'KShortcuts&amp;' =&gt; 'kde_KShortcuts*',
+'KShortcuts' =&gt; 'kde_KShortcuts*',
+'KShortcuts*' =&gt; 'kde_KShortcuts*',
+'KShred*' =&gt; 'kde_KShred*',
+'KSimpleConfig&amp;'  =&gt; 'kde_KSimpleConfig*' ,
+'KSimpleConfig*' =&gt; 'kde_KSimpleConfig*',
+'KSimpleFileFilter*' =&gt; 'kde_KSimpleFileFilter*',
+'KSpell*' =&gt; 'kde_KSpell*',
+'KSpellConfig&amp;'  =&gt; 'kde_KSpellConfig*' ,
+'KSpellConfig'  =&gt; 'kde_KSpellConfig*' ,
+'KSpellConfig*'  =&gt; 'kde_KSpellConfig*' ,
+'KSpellDlg*' =&gt; 'kde_KSpellDlg*',
+'KSqueezedTextLabel*' =&gt; 'kde_KSqueezedTextLabel*',
+'KStandardDirs*'  =&gt; 'kde_KStandardDirs*' ,
+'KStartupInfo*' =&gt; 'kde_KStartupInfo*',
+'KStartupInfoData&amp;' =&gt; 'kde_KStartupInfoData*',
+'KStartupInfoData*' =&gt; 'kde_KStartupInfoData*',
+'KStartupInfoId&amp;' =&gt; 'kde_KStartupInfoId*',
+'KStartupInfoId' =&gt; 'kde_KStartupInfoId*',
+'KStartupInfoId*' =&gt; 'kde_KStartupInfoId*',
+'KStaticDeleter*' =&gt; 'kde_KStaticDeleter*',
+'KStaticDeleterBase*'  =&gt; 'kde_KStaticDeleterBase*' ,
+'KStatusBar*'  =&gt; 'kde_KStatusBar*' ,
+'KStatusBar::BarStatusstat::Toggle'  =&gt;  'int' ,
+'KStatusBarLabel*' =&gt; 'kde_KStatusBarLabel*',
+'KStdAccel*' =&gt; 'kde_KStdAccel*',
+'KStdAccel::StdAccel'  =&gt; 'int' ,
+'KStdAction*' =&gt; 'kde_KStdAction*',
+'KStdGuiItem*' =&gt; 'kde_KStdGuiItem*',
+'KStringHandler*' =&gt; 'kde_KStringHandler*',
+'KStyle*'  =&gt; 'kde_KStyle*' ,
+'KSycoca*'  =&gt;  'kde_KSycoca*' ,
+'KSycocaEntry*'  =&gt; 'kde_KSycocaEntry*' ,
+'KSycocaFactoryId'  =&gt; 'int' ,
+'KSycocaType&amp;'  =&gt; 'int' ,
+'KSycocaType'  =&gt; 'int' ,
+'KSystemTray*' =&gt; 'kde_KSystemTray*',
+'KTMainWindow*' =&gt; 'kde_KTMainWindow*',
+'KTabButton*' =&gt; 'kde_KTabButton*',
+'KTabCtl*' =&gt; 'kde_KTabCtl*',
+'KTar*' =&gt; 'kde_KTar*',
+'KTarBase*'  =&gt;  'kde_KTarBase*' ,
+'KTarData*' =&gt; 'kde_KTarData*',
+'KTarDirectory*'  =&gt; 'kde_KTarDirectory*' ,
+'KTarEntry*'  =&gt; 'kde_KTarEntry*' ,
+'KTarFile*' =&gt; 'kde_KTarFile*',
+'KTarGz*' =&gt; 'kde_KTarGz*',
+'KTempFile*' =&gt; 'kde_KTempFile*',
+'KTextBrowser*' =&gt; 'kde_KTextBrowser*',
+'KTextEditor*' =&gt; 'kde_KTextEditor*',
+'KTextEditor__View&amp;'  =&gt;  'kde_KTextEditor__View*',
+'KTextEditor__View'  =&gt;  'kde_KTextEditor__View*',
+'KTextEditor__View*'  =&gt;  'kde_KTextEditor__View*',
+'KThemeBase*'  =&gt;  'kde_KThemeBase*', ,
+'KThemeCache*'  =&gt;  'kde_KThemeCache*',
+'KThemePixmap&amp;'  =&gt; 'kde_KThemePixmap*' ,
+'KThemePixmap*'  =&gt; 'kde_KThemePixmap*' ,
+'KThemeStyle*' =&gt; 'kde_KThemeStyle*',
+'KTipDatabase*' =&gt; 'kde_KTipDatabase*',
+'KTipDialog*' =&gt; 'kde_KTipDialog*',
+'KToggleAction*'  =&gt; 'kde_KToggleAction*' ,
+'KToolBar*'  =&gt; 'kde_KToolBar*' ,
+'KToolBar::BarStatus' =&gt; 'int',
+'KToolBar::BarStatusstat::Toggle'  =&gt;  'int' ,
+'KToolBarButton*'  =&gt; 'kde_KToolBarButton*' ,
+'KToolBarButtonList*' =&gt; 'kde_KToolBarButtonList*',
+'KToolBarPopupAction*' =&gt; 'kde_KToolBarPopupAction*',
+'KToolBarPos'  =&gt; 'int' ,
+'KToolBarRadioGroup*' =&gt; 'kde_KToolBarRadioGroup*',
+'KToolBarSeparator*' =&gt; 'kde_KToolBarSeparator*',
+'KToolButtonType'  =&gt; 'int' ,
+'KTrader*'  =&gt;  'kde_KTrader*' ,
+'KTypeList*' =&gt; 'kde_KTypeList*',
+'KURIFilter*'  =&gt;  'kde_KURIFilter*' ,
+'KURIFilterData&amp;'  =&gt; 'kde_KURIFilterData*' ,
+'KURIFilterData*' =&gt; 'kde_KURIFilterData*',
+'KURIFilterPlugin*' =&gt; 'kde_KURIFilterPlugin*',
+'KURIFilterPluginList*' =&gt; 'kde_KURIFilterPluginList*',
+'KURL&amp; url ()' =&gt; 'kde_KURL*',
+'KURL&amp; urlName ()' =&gt; 'kde_KURL*',
+'KURL&amp;'  =&gt; 'kde_KURL*' ,
+'KURL'  =&gt; 'kde_KURL*' ,
+'KURL*' =&gt; 'kde_KURL*',
+'KURL::List&amp;'  =&gt; 'kde_KURLList*' ,
+'KURL::List'  =&gt; 'kde_KURLList*' ,
+'KURL::List*'  =&gt; 'kde_KURLList*' ,
+'List&amp;'  =&gt; 'kde_KURLList*' ,
+'List'  =&gt; 'kde_KURLList*' ,
+'List*'  =&gt; 'kde_KURLList*' ,
+'KURLComboBox*' =&gt; 'kde_KURLComboBox*',
+'KURLComboItem*'  =&gt; 'kde_KURLComboItem*' ,
+'KURLCompletion*' =&gt; 'kde_KURLCompletion*',
+'KURLDrag*' =&gt; 'kde_KURLDrag*',
+'KURLLabel*' =&gt; 'kde_KURLLabel*',
+'KURLPixmapProvider*' =&gt; 'kde_KURLPixmapProvider*',
+'KURLPropsPlugin*' =&gt; 'kde_KURLPropsPlugin*',
+'KURLRequester*' =&gt; 'kde_KURLRequester*',
+'KURLRequesterDlg*' =&gt; 'kde_KURLRequesterDlg*',
+'KUniqueApplication*' =&gt; 'kde_KUniqueApplication*',
+'KUnixSocketAddress*' =&gt; 'kde_KUnixSocketAddress*',
+'KValueSelector*' =&gt; 'kde_KValueSelector*',
+'KWin*' =&gt; 'kde_KWin*',
+'KWinModule*' =&gt; 'kde_KWinModule*',
+'KWindowListMenu*' =&gt; 'kde_KWindowListMenu*',
+'KWizard*' =&gt; 'kde_KWizard*',
+'KWordWrap*' =&gt; 'kde_KWordWrap*',
+'KWritePermsIcon*' =&gt; 'kde_KWritePermsIcon*',
+'KXMLGUIBuilder*'  =&gt;  'kde_KXMLGUIBuilder*' ,
+'KXMLGUIClient*'  =&gt; 'kde_KXMLGUIClient*' ,
+'KXMLGUIFactory*'  =&gt; 'kde_KXMLGUIFactory*' ,
+'KXMessages*' =&gt; 'kde_KXMessages*',
+'KXYSelector*' =&gt; 'kde_KXYSelector*',
+'KZoneAllocator*' =&gt; 'kde_KZoneAllocator*',
+'KabAPI*' =&gt; 'kde_KabAPI*',
+'KabKey&amp;'  =&gt; 'kde_KabKey*' ,
+'KabKey'  =&gt; 'kde_KabKey*' ,
+'KabKey*' =&gt; 'kde_KabKey*',
+'Key&amp;'  =&gt;  'Key*' ,
+'KeyBindingMap'  =&gt; 'kde_KeyBindingMap*' ,
+'KeyValueMap&amp;'  =&gt; 'kde_KeyValueMap*' ,
+'KeyValueMap*&amp;'  =&gt; 'kde_KeyValueMap*' ,
+'KeyValueMap*'  =&gt; 'kde_KeyValueMap*' ,
+'Keymap*' =&gt; 'kde_Keymap*',
+'LinkStyle&amp;' =&gt; 'kde_LinkStyle*',
+'LinkStyle*' =&gt; 'kde_LinkStyle*',
+'ListIterator&amp;' =&gt; 'kde_ListIterator*',
+'ListIterator' =&gt; 'kde_ListIterator',
+'ListIterator*' =&gt; 'kde_ListIterator*',
+'ListJob*' =&gt; 'kde_ListJob*',
+'ListNode*' =&gt; 'kde_ListNode*',
+'ListProgress*' =&gt; 'kde_ListProgress*',
+'Lookup*' =&gt; 'kde_Lookup*',
+'MCOPConfig*' =&gt; 'kde_MCOPConfig*',
+'MCOPUtils*' =&gt; 'kde_MCOPUtils*',
+'MailServer&amp;'  =&gt;  'MailServer*' ,
+'MailServer*' =&gt; 'kde_MailServer*',
+'MainWindow*' =&gt; 'kde_MainWindow*',
+'Mark*' =&gt; 'kde_Mark*',
+'MarkInterface*' =&gt; 'kde_MarkInterface*',
+'MediaAsyncStream*' =&gt; 'kde_MediaAsyncStream*',
+'MediaDataPacket*' =&gt; 'kde_MediaDataPacket*',
+'MediaFrame*' =&gt; 'kde_MediaFrame*',
+'MediaList&amp;' =&gt; 'kde_MediaList*',
+'MediaList' =&gt; 'kde_MediaList*',
+'MediaList*' =&gt; 'kde_MediaList*',
+'MediaListImpl*' =&gt; 'kde_MediaListImpl*',
+'MediaModule&amp;' =&gt; 'kde_MediaModule*',
+'MediaModule' =&gt; 'kde_MediaModule*',
+'MediaModule*' =&gt; 'kde_MediaModule*',
+'MediaModule_base*' =&gt; 'kde_MediaModule_base*',
+'MediaModule_skel*' =&gt; 'kde_MediaModule_skel*',
+'MediaModule_stub*' =&gt; 'kde_MediaModule_stub*',
+'MenuDockData*' =&gt; 'kde_MenuDockData*',
+'MethodDef&amp;' =&gt; 'kde_MethodDef*',
+'MethodDef*' =&gt; 'kde_MethodDef*',
+'MidiEvent*' =&gt; 'kde_MidiEvent*',
+'MidiFileInfo*' =&gt; 'kde_MidiFileInfo*',
+'MidiMapper*' =&gt; 'kde_MidiMapper*',
+'MidiOut*' =&gt; 'kde_MidiOut*',
+'MidiPlayer*' =&gt; 'kde_MidiPlayer*',
+'MidiStatus*' =&gt; 'kde_MidiStatus*',
+'MidiTrack*' =&gt; 'kde_MidiTrack*',
+'MimetypeJob*' =&gt; 'kde_MimetypeJob*',
+'Mode' =&gt; 'int',
+'ModuleDef&amp;' =&gt; 'kde_ModuleDef*',
+'ModuleDef*' =&gt; 'kde_ModuleDef*',
+'MouseDoubleClickEvent*' =&gt; 'kde_MouseDoubleClickEvent*',
+'MouseEvent*' =&gt; 'kde_MouseEvent*',
+'MouseMoveEvent*' =&gt; 'kde_MouseMoveEvent*',
+'MousePressEvent*' =&gt; 'kde_MousePressEvent*',
+'MouseReleaseEvent*' =&gt; 'kde_MouseReleaseEvent*',
+'MultiGetJob*' =&gt; 'kde_MultiGetJob*',
+'MultiPort*' =&gt; 'kde_MultiPort*',
+'NET*' =&gt; 'kde_NET*',
+'NET::WindowType'  =&gt;  'int' ,
+'NETIcon'  =&gt;  'kdeNETIcon*' ,
+'NETIcon*' =&gt; 'kde_NETIcon*',
+'NETPoint&amp;'  =&gt;  'kde_NETPoint*' ,
+'NETPoint'  =&gt;  'kde_NETPoint*' ,
+'NETPoint*' =&gt; 'kde_NETPoint*',
+'NETRect&amp;'  =&gt;  'kde_NETRect*' ,
+'NETRect'  =&gt;  'kde_NETRect*' ,
+'NETRect*' =&gt; 'kde_NETRect*',
+'NETRootInfo&amp;'  =&gt;  'kde_NETRootInfo*' ,
+'NETRootInfo*' =&gt; 'kde_NETRootInfo*',
+'NETRootInfoPrivate*' =&gt; 'kde_NETRootInfoPrivate*',
+'NETSize&amp;'  =&gt;  'kde_NETSize*' ,
+'NETSize'  =&gt;  'kde_NETSize*' ,
+'NETSize*' =&gt; 'kde_NETSize*',
+'NETStrut'  =&gt;  'kde_NETStrut*' ,
+'NETStrut*' =&gt; 'kde_NETStrut*',
+'NETWinInfo&amp;'  =&gt;  'kde_NETWinInfo*' ,
+'NETWinInfo*' =&gt; 'kde_NETWinInfo*',
+'NETWinInfoPrivate*' =&gt; 'kde_NETWinInfoPrivate*',
+'NamedNodeMap&amp;' =&gt; 'kde_NamedNodeMap*',
+'NamedNodeMap' =&gt; 'kde_NamedNodeMap*',
+'NamedNodeMap*' =&gt; 'kde_NamedNodeMap*',
+'NamedNodeMapImpl*' =&gt; 'kde_NamedNodeMapImpl*',
+'NetAccess*' =&gt; 'kde_NetAccess*',
+'NetRC*' =&gt; 'kde_NetRC*',
+'Node&amp;' =&gt; 'kde_Node*',
+'Node' =&gt; 'kde_Node*',
+'Node*' =&gt; 'kde_Node*',
+'NodeFilter&amp;' =&gt; 'kde_NodeFilter*',
+'NodeFilter' =&gt; 'kde_NodeFilter*',
+'NodeFilter*' =&gt; 'kde_NodeFilter*',
+'NodeFilterImpl*' =&gt; 'kde_NodeFilterImpl*',
+'NodeImpl*' =&gt; 'kde_NodeImpl*',
+'NodeIterator&amp;' =&gt; 'kde_NodeIterator*',
+'NodeIterator' =&gt; 'kde_NodeIterator*',
+'NodeIterator*' =&gt; 'kde_NodeIterator*',
+'NodeIteratorImpl*' =&gt; 'kde_NodeIteratorImpl*',
+'NodeList&amp;' =&gt; 'kde_DOMNodeList*',
+'NodeList' =&gt; 'kde_DOMNodeList*',
+'NodeList*' =&gt; 'kde_DOMNodeList*',
+'NodeListImpl*' =&gt; 'kde_NodeListImpl*',
+'NodePtr'  =&gt;  'int' ,
+'NodeType'  =&gt;  'int' ,
+'Notation&amp;' =&gt; 'kde_Notation*',
+'Notation*' =&gt; 'kde_Notation*',
+'NoteArray*' =&gt; 'kde_NoteArray*',
+'Notification&amp;' =&gt; 'kde_Notification*',
+'Notification' =&gt; 'kde_Notification*',
+'Notification*' =&gt; 'kde_Notification*',
+'NotificationClient*' =&gt; 'kde_NotificationClient*',
+'NotificationManager*' =&gt; 'kde_NotificationManager*',
+'Null*' =&gt; 'null',
+'Number&amp;' =&gt; 'kde_Number*',
+'Number*' =&gt; 'kde_Number*',
+'Object&amp;' =&gt; 'kde_Object*',
+'Object' =&gt; 'kde_Object*',
+'Object*' =&gt; 'kde_Object*',
+'ObjectImp*' =&gt; 'kde_ObjectImp*',
+'ObjectManager*' =&gt; 'kde_ObjectManager*',
+'ObjectReference&amp;' =&gt; 'kde_ObjectReference*',
+'ObjectReference*' =&gt; 'kde_ObjectReference*',
+'Object_base*' =&gt; 'kde_Object_base*',
+'Object_skel*' =&gt; 'kde_Object_skel*',
+'Object_stub*' =&gt; 'kde_Object_stub*',
+'Observer*' =&gt; 'kde_Observer*',
+'OfferList'  =&gt;  'kde_OfferList*' ,
+'KTrader::OfferList'  =&gt;  'kde_OfferList*' ,
+'Offset' =&gt; 'int',
+'OnewayDispatchFunction' =&gt; 'kde_OnewayDispatchFunction*',
+'OnewayInvocation&amp;' =&gt; 'kde_OnewayInvocation*',
+'OnewayInvocation*' =&gt; 'kde_OnewayInvocation*',
+'OpenURLEvent*' =&gt; 'kde_OpenURLEvent*',
+'Orientation' =&gt; 'int',
+'PFlags' =&gt; 'int',
+'PIAccess' =&gt; 'int',
+'PID' =&gt; 'long',
+'PIType' =&gt; 'int',
+'PTY*' =&gt; 'kde_PTY*',
+'PageSize' =&gt; 'int',
+'ParamDef&amp;' =&gt; 'kde_ParamDef*',
+'ParamDef*' =&gt; 'kde_ParamDef*',
+'ParsedArgument*' =&gt; 'kde_ParsedArgument*',
+'ParsedAttribute*' =&gt; 'kde_ParsedAttribute*',
+'ParsedClass&amp;' =&gt; 'kde_ParsedClass&amp;',
+'ParsedClass*' =&gt; 'kde_ParsedClass*',
+'ParsedClassContainer*' =&gt; 'kde_ParsedClassContainer*',
+'ParsedContainer*' =&gt; 'kde_ParsedContainer*',
+'ParsedItem*' =&gt; 'kde_ParsedItem*',
+'ParsedMethod*' =&gt; 'kde_ParsedMethod*',
+'ParsedParent*' =&gt; 'kde_ParsedParent*',
+'ParsedScopeContainer*' =&gt; 'kde_ParsedScopeContainer*',
+'ParsedSignalSlot*' =&gt; 'kde_ParsedSignalSlot*',
+'ParsedStruct*' =&gt; 'kde_ParsedStruct*',
+'Part*' =&gt; 'kde_Part*',
+'PartActivateEvent*' =&gt; 'kde_PartActivateEvent*',
+'PartBase*' =&gt; 'kde_PartBase*',
+'PartSelectEvent*' =&gt; 'kde_PartSelectEvent*',
+'PassDlg*' =&gt; 'kde_PassDlg*',
+'PasswordDialog*' =&gt; 'kde_PasswordDialog*',
+'PenCapStyle'  =&gt;  'int' ,
+'PenJoinStyle'  =&gt;  'int' ,
+'PenStyle' =&gt; 'int',
+'PersistantClassStore*' =&gt; 'kde_PersistantClassStore*',
+'PhoneNumber&amp;' =&gt; 'kde_PhoneNumber*',
+'PhoneNumber*' =&gt; 'kde_PhoneNumber*',
+'PipeBuffer*' =&gt; 'kde_PipeBuffer*',
+'PipeSegment*' =&gt; 'kde_PipeSegment*',
+'Pix&amp;'  =&gt;  'kde_Pix*' ,
+'Pix'  =&gt;  'kde_Pix*' ,
+'PixelMetric' =&gt; 'int',
+'PlayObject&amp;' =&gt; 'kde_PlayObject*',
+'PlayObject' =&gt; 'kde_PlayObject*',
+'PlayObject*' =&gt; 'kde_PlayObject*',
+'PlayObjectFactory&amp;' =&gt; 'kde_PlayObjectFactory*',
+'PlayObjectFactory' =&gt; 'kde_PlayObjectFactory',
+'PlayObjectFactory*' =&gt; 'kde_PlayObjectFactory*',
+'PlayObjectFactory_base*' =&gt; 'kde_PlayObjectFactory_base*',
+'PlayObjectFactory_skel*' =&gt; 'kde_PlayObjectFactory_skel*',
+'PlayObjectFactory_stub*' =&gt; 'kde_PlayObjectFactory_stub*',
+'PlayObject_base*' =&gt; 'kde_PlayObject_base*',
+'PlayObject_private&amp;' =&gt; 'kde_PlayObject_private*',
+'PlayObject_private' =&gt; 'kde_PlayObject_private',
+'PlayObject_private*' =&gt; 'kde_PlayObject_private*',
+'PlayObject_private_base*' =&gt; 'kde_PlayObject_private_base*',
+'PlayObject_private_skel*' =&gt; 'kde_PlayObject_private_skel*',
+'PlayObject_private_stub*' =&gt; 'kde_PlayObject_private_stub*',
+'PlayObject_skel*' =&gt; 'kde_PlayObject_skel*',
+'PlayObject_stub*' =&gt; 'kde_PlayObject_stub*',
+'PlayerController*' =&gt; 'kde_PlayerController*',
+'Plugin*' =&gt; 'kde_Plugin*',
+'PluginInfo*' =&gt; 'kde_PluginInfo*',
+'Policy' =&gt; 'int',
+'Pool&amp;' =&gt; 'kde_Pool*',
+'Pool*' =&gt; 'kde_Pool*',
+'PopupMenuInterface*' =&gt; 'kde_PopupMenuInterface*',
+'Port*' =&gt; 'kde_Port*',
+'PreviewJob*' =&gt; 'kde_PreviewJob*',
+'PrimitiveElement' =&gt; 'int',
+'PrintInterface*' =&gt; 'kde_PrintInterface*',
+'PrinterMode' =&gt; 'int',
+'ProcessingInstruction&amp;' =&gt; 'kde_ProcessingInstruction*',
+'ProcessingInstruction' =&gt; 'kde_ProcessingInstruction*',
+'ProcessingInstruction*' =&gt; 'kde_ProcessingInstruction*',
+'ProgressBase*' =&gt; 'kde_ProgressBase*',
+'ProgressItem*' =&gt; 'kde_ProgressItem*',
+'PropagationMode' =&gt; 'int',
+'ProtocolInfo*' =&gt; 'kde_ProtocolInfo*',
+'Ptr' =&gt; 'void*',
+'PtyProcess*' =&gt; 'kde_PtyProcess*',
+'QAccel*' =&gt; 'qt_QAccel*',
+'QAccessible*' =&gt; 'qt_QAccessible*',
+'QAccessibleFactoryInterface*' =&gt; 'qt_QAccessibleFactoryInterface*',
+'QAccessibleInterface*' =&gt; 'qt_QAccessibleInterface*',
+'QAccessibleInterface**' =&gt; 'qt_QAccessibleInterface**',
+'QAccessibleObject*' =&gt; 'qt_QAccessibleObject*',
+'QAction*'  =&gt;  'qt_QAction*' ,
+'QActionGroup*' =&gt; 'qt_QActionGroup*',
+'QApplication*'  =&gt; 'qt_QApplication*' ,
+'QArabicCodec*' =&gt; 'qt_QArabicCodec*',
+'QArray*' =&gt; 'qt_QArray*',
+'QAsciiBucket*' =&gt; 'qt_QAsciiBucket*',
+'QAsciiCache*' =&gt; 'qt_QAsciiCache*',
+'QAsciiCacheIterator*' =&gt; 'qt_QAsciiCacheIterator*',
+'QAsciiDict*' =&gt; 'qt_QAsciiDict*',
+'QAsciiDictIterator*' =&gt; 'qt_QAsciiDictIterator*',
+'QAsyncIO*' =&gt; 'qt_QAsyncIO*',
+'QAuBucket*'  =&gt;  'qt_QAuBucket*' ,
+'QAuServer*' =&gt; 'qt_QAuServer*',
+'QBaseBucket*'  =&gt;  'qt_QBaseBucket*' ,
+'QBig5Codec*' =&gt; 'qt_QBig5Codec*',
+'QBitArray&amp;'  =&gt; 'qt_QBitArray*' ,
+'QBitArray'  =&gt; 'qt_QBitArray*' ,
+'QBitArray*'  =&gt;  'qt_QBitArray*' ,
+'QBitVal&amp;'  =&gt; 'qt_QBitVal*' ,
+'QBitVal'  =&gt; 'qt_QBitVal*' ,
+'QBitVal*' =&gt; 'qt_QBitVal*',
+'QBitmap&amp;' =&gt; 'qt_QBitmap*',
+'QBitmap' =&gt; 'qt_QBitmap*',
+'QBitmap*' =&gt; 'qt_QBitmap*',
+'QBoxLayout*' =&gt; 'qt_QBoxLayout*',
+'QBrush&amp;' =&gt; 'qt_QBrush*',
+'QBrush'  =&gt;  'qt_QBrush*' ,
+'QBrush*'  =&gt; 'qt_QBrush*' ,
+'QBrushData*' =&gt; 'qt_QBrushData*',
+'QBuffer*' =&gt; 'qt_QBuffer*',
+'QButton*' =&gt; 'qt_QButton*',
+'QButtonGroup*'  =&gt;  'qt_QButtonGroup*' ,
+'QByteArray&amp; arr ()' =&gt; 'qt_QByteArray*',
+'QByteArray&amp;'  =&gt; 'qt_QByteArray*' ,
+'QByteArray' =&gt; 'qt_QByteArray*',
+'QByteArray*' =&gt; 'qt_QByteArray*',
+'QCDEStyle*' =&gt; 'qt_QCDEStyle*',
+'QCOORD&amp;' =&gt; 'short',
+'QCOORD' =&gt; 'short',
+'QCOORD*' =&gt; 'short*',
+'QCString&amp;'  =&gt;  'qt_QCString*' ,
+'QCString'  =&gt;  'qt_QCString*' ,
+'QCString*'  =&gt;  'qt_QCString*' ,
+'QCStringLess*'  =&gt;  'qt_QCStringLess*' ,
+'QCStringList'  =&gt; 'kde_QCStringList*' ,
+'QCache*' =&gt; 'qt_QCache*',
+'QCacheIterator*' =&gt; 'qt_QCacheIterator*',
+'QCanvas*'  =&gt;  'qt_QCanvas*' ,
+'QCanvasEllipse*' =&gt; 'qt_QCanvasEllipse*',
+'QCanvasItem*'  =&gt;  'qt_QCanvasItem*' ,
+'QCanvasItemList'  =&gt;  'qt_QCanvasItemList*' ,
+'QCanvasItemList*' =&gt; 'qt_QCanvasItemList*',
+'QCanvasLine*' =&gt; 'qt_QCanvasLine*',
+'QCanvasPixmap*'  =&gt;  'qt_QCanvasPixmap*' ,
+'QCanvasPixmapArray*'  =&gt;  'qt_QCanvasPixmapArray*' ,
+'QCanvasPolygon*' =&gt; 'qt_QCanvasPolygon*',
+'QCanvasPolygonalItem*' =&gt; 'qt_QCanvasPolygonalItem*',
+'QCanvasRectangle*' =&gt; 'qt_QCanvasRectangle*',
+'QCanvasSpline*' =&gt; 'qt_QCanvasSpline*',
+'QCanvasSprite*' =&gt; 'qt_QCanvasSprite*',
+'QCanvasText*' =&gt; 'qt_QCanvasText*',
+'QCanvasView*'  =&gt;  'qt_QCanvasView*' ,
+'QChain*'  =&gt; 'qt_QChain*' ,
+'QChar::Category'  =&gt;  'int' ,
+'QChar::Decomposition'  =&gt;  'int' ,
+'QChar::Direction'  =&gt;  'int' ,
+'QChar::Joining'  =&gt;  'int' ,
+'QCharRef&amp;'  =&gt;  'qt_QCharRef*' ,
+'QCharRef'  =&gt;  'qt_QCharRef*' ,
+'QCharRef*' =&gt; 'qt_QCharRef*',
+'QCheckBox*' =&gt; 'qt_QCheckBox*',
+'QCheckListItem*' =&gt; 'qt_QCheckListItem*',
+'QCheckTableItem*' =&gt; 'qt_QCheckTableItem*',
+'QChildEvent*'  =&gt; 'qt_QChildEvent*' ,
+'QClassInfo*'  =&gt;  'qt_QClassInfo*' ,
+'QCleanupHandler*' =&gt; 'qt_QCleanupHandler*',
+'QClipboard*' =&gt; 'qt_QClipboard*',
+'QCloseEvent*'  =&gt; 'qt_QCloseEvent*' ,
+'QCollection&amp;'  =&gt; 'qt_QCollection*' ,
+'QCollection*' =&gt; 'qt_QCollection*',
+'QCollection::Item&amp;'  =&gt;  'void*' ,
+'QCollection::Item'  =&gt;  'void*' ,
+'QColor &amp;' =&gt; 'qt_QColor*',
+'QColor&amp;' =&gt; 'qt_QColor*',
+'QColor&amp;fillColor::white'  =&gt;  'int' ,
+'QColor&amp;linkColor::blue'  =&gt;  'int' ,
+'QColor' =&gt; 'qt_QColor*',
+'QColor*'  =&gt; 'qt_QColor*' ,
+'QColorDialog*' =&gt; 'qt_QColorDialog*',
+'QColorDrag*' =&gt; 'qt_QColorDrag*',
+'QColorGroup&amp;' =&gt; 'qt_QColorGroup*',
+'QColorGroup'  =&gt;  'qt_QColorGroup*' ,
+'QColorGroup*'  =&gt; 'qt_QColorGroup*' ,
+'QColorGroup::ColorRole'  =&gt; 'int' ,
+'QComboBox*'  =&gt;  'qt_QComboBox*' ,
+'QComboBox::Policy'  =&gt; 'int' ,
+'QComboBox::Policypolicy::AtBottom'  =&gt; 'int' ,
+'QComboTableItem*' =&gt; 'qt_QComboTableItem*',
+'QCommonStyle*' =&gt; 'qt_QCommonStyle*',
+'QCompactStyle*' =&gt; 'qt_QCompactStyle*',
+'QComponentFactory*' =&gt; 'qt_QComponentFactory*',
+'QComponentFactoryInterface*' =&gt; 'qt_QComponentFactoryInterface*',
+'QComponentInterface*' =&gt; 'qt_QComponentInterface*',
+'QComponentRegistration*' =&gt; 'qt_QComponentRegistration*',
+'QComponentServerInterface*' =&gt; 'qt_QComponentServerInterface*',
+'QConfigDB*'  =&gt;  'qt_QConfigDB*' ,
+'QConfigDB*'  =&gt; 'qt_QConfigDB*' ,
+'QConnection*' =&gt; 'qt_QConnection*',
+'QConnectionList&amp;'  =&gt; 'qt_QConnectionList*' ,
+'QConnectionList*'  =&gt;  'qt_QConnectionList*' ,
+'QConnectionListIt&amp;'  =&gt; 'qt_QConnectionListIt*' ,
+'QConnectionListIt*' =&gt; 'qt_QConnectionListIt*',
+'QConstString' =&gt; 'qt_QConstString*',
+'QConstString*' =&gt; 'qt_QConstString*',
+'QContextMenuEvent*' =&gt; 'qt_QContextMenuEvent*',
+'QCursor&amp;' =&gt; 'qt_QCursor*',
+'QCursor'  =&gt;  'qt_QCursor*' ,
+'QCursor*' =&gt; 'qt_QCursor*',
+'QCustomEvent*'  =&gt;  'qt_QCustomEvent*' ,
+'QCustomMenuItem*'  =&gt;  'qt_QCustomMenuItem*' ,
+'QDOM_NodeListPrivate*'  =&gt;  'void*' ,
+'QDOM_NodePrivate*'  =&gt;  'void*' ,
+'QDataBrowser*' =&gt; 'qt_QDataBrowser*',
+'QDataPump*' =&gt; 'qt_QDataPump*',
+'QDataSink*'  =&gt; 'qt_QDataSink*' ,
+'QDataSource*'  =&gt; 'qt_QDataSource*' ,
+'QDataStream&amp;' =&gt; 'qt_QDataStream*',
+'QDataStream*'  =&gt; 'qt_QDataStream*' ,
+'QDataTable*' =&gt; 'qt_QDataTable*',
+'QDataView*' =&gt; 'qt_QDataView*',
+'QDate &amp;' =&gt; 'qt_QDate*',
+'QDate date()' =&gt; 'qt_QDate*',
+'QDate&amp;' =&gt; 'qt_QDate*',
+'QDate' =&gt; 'qt_QDate*',
+'QDate*' =&gt; 'qt_QDate*',
+'QDateEdit*' =&gt; 'qt_QDateEdit*',
+'QDateTime&amp;' =&gt; 'qt_QDateTime*',
+'QDateTime' =&gt; 'qt_QDateTime*',
+'QDateTime*'  =&gt; 'qt_QDateTime*' ,
+'QDateTimeEdit*' =&gt; 'qt_QDateTimeEdit*',
+'QDateTimeEditBase*' =&gt; 'qt_QDateTimeEditBase*',
+'QDesktopWidget*' =&gt; 'qt_QDesktopWidget*',
+'QDial*' =&gt; 'qt_QDial*',
+'QDialog*' =&gt; 'qt_QDialog*',
+'QDict*' =&gt; 'qt_QDict*',
+'QDictIterator*' =&gt; 'qt_QDictIterator*',
+'QDir&amp;' =&gt; 'qt_QDir*',
+'QDir' =&gt; 'qt_QDir*',
+'QDir*' =&gt; 'qt_QDir*',
+'QDir::SortSpec&amp;'  =&gt; 'int' ,
+'QDir::SortSpec'  =&gt; 'int' ,
+'QDirSortItem*' =&gt; 'qt_QDirSortItem*',
+'QDiskFont*' =&gt; 'qt_QDiskFont*',
+'QDispatchInterface*' =&gt; 'qt_QDispatchInterface*',
+'QDns*' =&gt; 'qt_QDns*',
+'QDnsSocket*' =&gt; 'qt_QDnsSocket*',
+'QDockArea*' =&gt; 'qt_QDockArea*',
+'QDockAreaLayout*' =&gt; 'qt_QDockAreaLayout*',
+'QDockWindow*' =&gt; 'qt_QDockWindow*',
+'QDomAttr&amp;'  =&gt;  'qt_QDomAttr*' ,
+'QDomAttr'  =&gt;  'qt_QDomAttr*' ,
+'QDomAttr*' =&gt; 'qt_QDomAttr*',
+'QDomCDATASection&amp;'  =&gt;  'qt_QDomCDATASection*' ,
+'QDomCDATASection'  =&gt;  'qt_QDomCDATASection*' ,
+'QDomCDATASection*' =&gt; 'qt_QDomCDATASection*',
+'QDomCharacterData&amp;'  =&gt;  'qt_QDomCharacterData*' ,
+'QDomCharacterData'  =&gt;  'qt_QDomCharacterData*' ,
+'QDomCharacterData*' =&gt; 'qt_QDomCharacterData*',
+'QDomComment&amp;'  =&gt;  'qt_QDomComment*' ,
+'QDomComment'  =&gt;  'qt_QDomComment*' ,
+'QDomComment*' =&gt; 'qt_QDomComment*',
+'QDomDocument&amp;'  =&gt;  'qt_QDomDocument*' ,
+'QDomDocument'  =&gt;  'qt_QDomDocument*' ,
+'QDomDocument*' =&gt; 'qt_QDomDocument*',
+'QDomDocumentFragment&amp;'  =&gt;  'qt_QDomDocumentFragment*' ,
+'QDomDocumentFragment'  =&gt;  'qt_QDomDocumentFragment*' ,
+'QDomDocumentFragment*' =&gt; 'qt_QDomDocumentFragment*',
+'QDomDocumentType&amp;'  =&gt;  'qt_QDomDocumentType*' ,
+'QDomDocumentType'  =&gt;  'qt_QDomDocumentType*' ,
+'QDomDocumentType*' =&gt; 'qt_QDomDocumentType*',
+'QDomElement&amp;'  =&gt;  'qt_QDomElement*' ,
+'QDomElement'  =&gt;  'qt_QDomElement*' ,
+'QDomElement*' =&gt; 'qt_QDomElement*',
+'QDomEntity&amp;'  =&gt;  'qt_QDomEntity*' ,
+'QDomEntity'  =&gt;  'qt_QDomEntity*' ,
+'QDomEntity*' =&gt; 'qt_QDomEntity*',
+'QDomEntityReference&amp;'  =&gt;  'qt_QDomEntityReference*' ,
+'QDomEntityReference'  =&gt;  'qt_QDomEntityReference*' ,
+'QDomEntityReference*' =&gt; 'qt_QDomEntityReference*',
+'QDomImplementation&amp;'  =&gt;  'qt_QDomImplementation*' ,
+'QDomImplementation'  =&gt;  'qt_QDomImplementation*' ,
+'QDomImplementation*' =&gt; 'qt_QDomImplementation*',
+'QDomNamedNodeMap&amp;'  =&gt;  'qt_QDomNamedNodeMap*' ,
+'QDomNamedNodeMap'  =&gt;  'qt_QDomNamedNodeMap*' ,
+'QDomNamedNodeMap*' =&gt; 'qt_QDomNamedNodeMap*',
+'QDomNode&amp;'  =&gt;  'qt_QDomNode*' ,
+'QDomNode'  =&gt;  'qt_QDomNode*' ,
+'QDomNode*' =&gt; 'qt_QDomNode*',
+'QDomNode::NodeType' =&gt; 'int',
+'QDomNodeList&amp;'  =&gt;  'qt_QDomNodeList*' ,
+'QDomNodeList'  =&gt;  'qt_QDomNodeList*' ,
+'QDomNodeList*' =&gt; 'qt_QDomNodeList*',
+'QDomNodePrivate*' =&gt; 'qt_QDomNodePrivate*',
+'QDomNotation&amp;'  =&gt;  'qt_QDomNotation*' ,
+'QDomNotation'  =&gt;  'qt_QDomNotation*' ,
+'QDomNotation*' =&gt; 'qt_QDomNotation*',
+'QDomProcessingInstruction&amp;'  =&gt;  'qt_QDomProcessingInstruction*' ,
+'QDomProcessingInstruction'  =&gt;  'qt_QDomProcessingInstruction*' ,
+'QDomProcessingInstruction*' =&gt; 'qt_QDomProcessingInstruction*',
+'QDomText&amp;'  =&gt;  'qt_QDomText*' ,
+'QDomText'  =&gt;  'qt_QDomText*' ,
+'QDomText*' =&gt; 'qt_QDomText*',
+'QDoubleValidator*' =&gt; 'qt_QDoubleValidator*',
+'QDragEnterEvent*'  =&gt; 'qt_QDragEnterEvent*' ,
+'QDragLeaveEvent*'  =&gt; 'qt_QDragLeaveEvent*' ,
+'QDragManager*' =&gt; 'qt_QDragManager*',
+'QDragMoveEvent*'  =&gt; 'qt_QDragMoveEvent*' ,
+'QDragObject*'  =&gt; 'qt_QDragObject*' ,
+'QDragResponseEvent*' =&gt; 'qt_QDragResponseEvent*',
+'QDropEvent*'  =&gt; 'qt_QDropEvent*' ,
+'QDropSite*' =&gt; 'qt_QDropSite*',
+'QEditorFactory*' =&gt; 'qt_QEditorFactory*',
+'QErrorMessage*' =&gt; 'qt_QErrorMessage*',
+'QEucJpCodec*' =&gt; 'qt_QEucJpCodec*',
+'QEucKrCodec*' =&gt; 'qt_QEucKrCodec*',
+'QEvent*' =&gt; 'qt_QEvent*',
+'QEventLoop::ProcessEventsFlags' =&gt; 'uint',
+'QFeatureListInterface*' =&gt; 'qt_QFeatureListInterface*',
+'QFile&amp;' =&gt; 'qt_QFile*',
+'QFile*'  =&gt; 'qt_QFile*' ,
+'QFileDialog*' =&gt; 'qt_QFileDialog*',
+'QFileIconProvider*'  =&gt; 'qt_QFileIconProvider*' ,
+'QFileInfo&amp;' =&gt; 'qt_QFileInfo*',
+'QFileInfo*' =&gt; 'qt_QFileInfo*',
+'QFileInfoList*'  =&gt; 'qt_QFileInfoList*' ,
+'QFilePreview*'  =&gt;  'qt_QFilePreview*' ,
+'QFocusData*'  =&gt;  'qt_QFocusData*' ,
+'QFocusEvent*'  =&gt; 'qt_QFocusEvent*' ,
+'QFont&amp;' =&gt; 'qt_QFont*',
+'QFont' =&gt; 'qt_QFont*',
+'QFont*' =&gt; 'qt_QFont*',
+'QFont::CharSet' =&gt; 'int',
+'QFont::CharSetcharset::Unicode'  =&gt; 'int' ,
+'QFont::StyleHint' =&gt; 'int',
+'QFontData&amp;'  =&gt; 'qt_QFontData*' ,
+'QFontDatabase*' =&gt; 'qt_QFontDatabase*',
+'QFontDialog*' =&gt; 'qt_QFontDialog*',
+'QFontInfo&amp;' =&gt; 'qt_QFontInfo*',
+'QFontInfo' =&gt; 'qt_QFontInfo*',
+'QFontInfo*' =&gt; 'qt_QFontInfo*',
+'QFontMetrics&amp;' =&gt; 'qt_QFontMetrics*',
+'QFontMetrics' =&gt; 'qt_QFontMetrics*',
+'QFontMetrics*' =&gt; 'qt_QFontMetrics*',
+'QFrame*'  =&gt; 'qt_QFrame*' ,
+'QFtp*' =&gt; 'qt_QFtp*',
+'QGArray&amp;'  =&gt; 'qt_QGArray*' ,
+'QGArray*' =&gt; 'qt_QGArray*',
+'QGCache&amp;'  =&gt; 'qt_QGCache*' ,
+'QGCache*' =&gt; 'qt_QGCache*',
+'QGCacheIterator&amp;'  =&gt; 'qt_QGCacheIterator*' ,
+'QGCacheIterator*' =&gt; 'qt_QGCacheIterator*',
+'QGDict&amp;'  =&gt; 'qt_QGDict*' ,
+'QGDict*' =&gt; 'qt_QGDict*',
+'QGDictIterator&amp;'  =&gt; 'qt_QGDictIterator*' ,
+'QGDictIterator*' =&gt; 'qt_QGDictIterator*',
+'QGL*' =&gt; 'qt_QGL*',
+'QGLColormap&amp;' =&gt; 'qt_QGLColormap*',
+'QGLColormap*' =&gt; 'qt_QGLColormap*',
+'QGLContext*'  =&gt;  'qt_QGLContext*' ,
+'QGLFormat&amp;'  =&gt;  'qt_QGLFormat*' ,
+'QGLFormat'  =&gt;  'qt_QGLFormat*' ,
+'QGLFormat*' =&gt; 'qt_QGLFormat*',
+'QGLWidget*'  =&gt;  'qt_QGLWidget*' ,
+'QGLayoutIterator*'  =&gt;  'qt_QGLayoutIterator*' ,
+'QGListIterator&amp;'  =&gt; 'qt_QGListIterator*' ,
+'QGListIterator*' =&gt; 'qt_QGListIterator*',
+'QGPlugin*' =&gt; 'qt_QGPlugin*',
+'QGPluginManager*' =&gt; 'qt_QGPluginManager*',
+'QGbkCodec*' =&gt; 'qt_QGbkCodec*',
+'QGfx*'  =&gt;  'qt_QGfx*' ,
+'QGrid*'  =&gt; 'qt_QGrid*' ,
+'QGrid::Direction'  =&gt; 'int' ,
+'QGridLayout*' =&gt; 'qt_QGridLayout*',
+'QGridView*' =&gt; 'qt_QGridView*',
+'QGroupBox*' =&gt; 'qt_QGroupBox*',
+'QGuardedPtr*' =&gt; 'qt_QGuardedPtr*',
+'QGuardedPtrPrivate*' =&gt; 'qt_QGuardedPtrPrivate*',
+'QHBox*'  =&gt; 'qt_QHBox*' ,
+'QHBoxLayout*'  =&gt;  'qt_QHBoxLayout*' ,
+'QHButtonGroup*' =&gt; 'qt_QHButtonGroup*',
+'QHGroupBox*' =&gt; 'qt_QHGroupBox*',
+'QHeader*' =&gt; 'qt_QHeader*',
+'QHebrewCodec*' =&gt; 'qt_QHebrewCodec*',
+'QHideEvent*'  =&gt; 'qt_QHideEvent*' ,
+'QHostAddress&amp;'  =&gt;  'qt_QHostAddress*' ,
+'QHostAddress'  =&gt;  'qt_QHostAddress*' ,
+'QHostAddress*'  =&gt;  'qt_QHostAddress*' ,
+'QHttp*' =&gt; 'qt_QHttp*',
+'QIMEvent*' =&gt; 'qt_QIMEvent*',
+'QIODevice*' =&gt; 'qt_QIODevice*',
+'QIODevice::Offset' =&gt; 'int',
+'QIODeviceSource*' =&gt; 'qt_QIODeviceSource*',
+'QIOManager*' =&gt; 'qt_QIOManager*',
+'QIOWatch*' =&gt; 'qt_QIOWatch*',
+'QIconDrag*' =&gt; 'qt_QIconDrag*',
+'QIconDragItem&amp;'  =&gt;  'qt_QIconDragItem*' ,
+'QIconDragItem*' =&gt; 'qt_QIconDragItem*',
+'QIconSet&amp;'  =&gt; 'qt_QIconSet*' ,
+'QIconSet'  =&gt; 'qt_QIconSet*' ,
+'QIconSet*'  =&gt;  'qt_QIconSet*' ,
+'QIconView*'  =&gt; 'qt_QIconView*' ,
+'QIconViewItem*'  =&gt;  'qt_QIconViewItem*' ,
+'QImage&amp;' =&gt; 'qt_QImage*',
+'QImage' =&gt; 'qt_QImage*',
+'QImage*'  =&gt; 'qt_QImage*' ,
+'QImageConsumer*'  =&gt;  'qt_QImageConsumer*' ,
+'QImageData*' =&gt; 'qt_QImageData*',
+'QImageDecoder*' =&gt; 'qt_QImageDecoder*',
+'QImageDrag*' =&gt; 'qt_QImageDrag*',
+'QImageFormat*'  =&gt;  'qt_QImageFormat*' ,
+'QImageFormatInterface*' =&gt; 'qt_QImageFormatInterface*',
+'QImageFormatPlugin*' =&gt; 'qt_QImageFormatPlugin*',
+'QImageFormatType*'  =&gt; 'qt_QImageFormatType*' ,
+'QImageIO*' =&gt; 'qt_QImageIO*',
+'QImageTextKeyLang&amp;'  =&gt;  'qt_QImageTextKeyLang*' ,
+'QImageTextKeyLang*' =&gt; 'qt_QImageTextKeyLang*',
+'QInputDialog*' =&gt; 'qt_QInputDialog*',
+'QIntBucket*' =&gt; 'qt_QIntBucket*',
+'QIntCache*' =&gt; 'qt_QIntCache*',
+'QIntCacheIterator*' =&gt; 'qt_QIntCacheIterator*',
+'QIntDict*' =&gt; 'qt_QIntDict*',
+'QIntDictIterator*' =&gt; 'qt_QIntDictIterator*',
+'QIntValidator*' =&gt; 'qt_QIntValidator*',
+'QInterfaceListInterface*' =&gt; 'qt_QInterfaceListInterface*',
+'QInterfacePtr*' =&gt; 'qt_QInterfacePtr*',
+'QInterlaceStyle*' =&gt; 'qt_QInterlaceStyle*',
+'QInternal*' =&gt; 'qt_QInternal*',
+'QJisCodec*' =&gt; 'qt_QJisCodec*',
+'QJpUnicodeConv*'  =&gt;  'qt_QJpUnicodeConv*' ,
+'QKeyEvent*'  =&gt; 'qt_QKeyEvent*' ,
+'QKeySequence&amp;' =&gt; 'qt_QKeySequence*',
+'QKeySequence' =&gt; 'qt_QKeySequence*',
+'QKeySequence*' =&gt; 'qt_QKeySequence*',
+'QKoi8Codec*' =&gt; 'qt_QKoi8Codec*',
+'QLCDNumber*' =&gt; 'qt_QLCDNumber*',
+'QLNode*'  =&gt; 'qt_QLNode*' ,
+'QLabel*' =&gt; 'qt_QLabel*',
+'QLayout*' =&gt; 'qt_QLayout*',
+'QLayoutItem*'  =&gt;  'qt_QLayoutItem*' ,
+'QLayoutIterator&amp;'  =&gt;  'qt_QLayoutIterator*' ,
+'QLayoutIterator'  =&gt;  'qt_QLayoutIterator*' ,
+'QLayoutIterator*' =&gt; 'qt_QLayoutIterator*',
+'QLibrary*' =&gt; 'qt_QLibrary*',
+'QLibrary::Policy' =&gt; 'int',
+'QLibraryInterface*' =&gt; 'qt_QLibraryInterface*',
+'QLineEdit*'  =&gt;  'qt_QLineEdit*' ,
+'QLineEdit::EchoMode'  =&gt;  'int' ,
+'QList*' =&gt; 'qt_QList*',
+'QListBox*' =&gt; 'qt_QListBox*',
+'QListBoxItem*' =&gt; 'qt_QListBoxItem*',
+'QListBoxPixmap*' =&gt; 'qt_QListBoxPixmap*',
+'QListBoxText*' =&gt; 'qt_QListBoxText*',
+'QListIterator*' =&gt; 'qt_QListIterator*',
+'QListView*' =&gt; 'qt_QListView*',
+'QListViewItem*&amp;' =&gt; 'qt_QListViewItem*',
+'QListViewItem*' =&gt; 'qt_QListViewItem*',
+'QListViewItemIterator&amp;'  =&gt;  'qt_QListViewItemIterator*' ,
+'QListViewItemIterator'  =&gt;  'qt_QListViewItemIterator*' ,
+'QListViewItemIterator*' =&gt; 'qt_QListViewItemIterator*',
+'QLocalFs*' =&gt; 'qt_QLocalFs*',
+'QMCPI*' =&gt; 'qt_QMCPI*',
+'QMainWindow*'  =&gt;  'qt_QMainWindow*' ,
+'QMainWindow::ToolBarDock' =&gt; 'int',
+'QMainWindow::ToolBarDock::Top'  =&gt;  'int' ,
+'QMap&amp;'  =&gt;  'qt_QMap*' ,
+'QMap*' =&gt; 'qt_QMap*',
+'QMapConstIterator*' =&gt; 'qt_QMapConstIterator*',
+'QMapIterator*' =&gt; 'qt_QMapIterator*',
+'QMapNode*' =&gt; 'qt_QMapNode*',
+'QMapNodeBase*&amp;'  =&gt;  'qt_QMapNodeBase*' ,
+'QMapNodeBase*'  =&gt;  'qt_QMapNodeBase*' ,
+'QMapPrivate*' =&gt; 'qt_QMapPrivate*',
+'QMapPrivateBase*'  =&gt;  'qt_QMapPrivateBase*' ,
+'QMemArray*' =&gt; 'qt_QMemArray*',
+'QMember'  =&gt; 'qt_QMember*' ,
+'QMember*'  =&gt; 'qt_QMember*' ,
+'QMenuBar*' =&gt; 'qt_QMenuBar*',
+'QMenuData*' =&gt; 'qt_QMenuData*',
+'QMenuItem*' =&gt; 'qt_QMenuItem*',
+'QMessageBox*' =&gt; 'qt_QMessageBox*',
+'QMetaData*'  =&gt;  'qt_QMetaData*' ,
+'QMetaData::Access*'  =&gt;  'int*' ,
+'QMetaEnum*'  =&gt;  'qt_QMetaEnum*' ,
+'QMetaEnum::Item*'  =&gt;  'int*' ,
+'QMetaObject*&amp;' =&gt; 'qt_QMetaObject*',
+'QMetaObject*' =&gt; 'qt_QMetaObject*',
+'QMetaObjectCleanUp*' =&gt; 'qt_QMetaObjectCleanUp*',
+'QMetaObjectInit*' =&gt; 'qt_QMetaObjectInit*',
+'QMetaProperty*'  =&gt;  'qt_QMetaProperty*' ,
+'QMimeSource*'  =&gt;  'qt_QMimeSource*' ,
+'QMimeSourceFactory*'  =&gt;  'qt_QMimeSourceFactory*' ,
+'QMotifPlusStyle*' =&gt; 'qt_QMotifPlusStyle*',
+'QMotifStyle*' =&gt; 'qt_QMotifStyle*',
+'QMouseEvent*'  =&gt; 'qt_QMouseEvent*' ,
+'QMoveEvent*'  =&gt;  'qt_QMoveEvent*' ,
+'QMovie&amp;' =&gt; 'qt_QMovie*',
+'QMovie*' =&gt; 'qt_QMovie*',
+'QMultiLineEdit*' =&gt; 'qt_QMultiLineEdit*',
+'QMultiLineEditRow*' =&gt; 'qt_QMultiLineEditRow*',
+'QMutex*' =&gt; 'qt_QMutex*',
+'QNPInstance*' =&gt; 'qt_QNPInstance*',
+'QNPStream*' =&gt; 'qt_QNPStream*',
+'QNPWidget*' =&gt; 'qt_QNPWidget*',
+'QNPlugin*' =&gt; 'qt_QNPlugin*',
+'QNetworkOperation*'  =&gt;  'qt_QNetworkOperation*' ,
+'QNetworkProtocol*'  =&gt;  'qt_QNetworkProtocol*' ,
+'QNetworkProtocol::Operation'  =&gt;  'int' ,
+'QNetworkProtocol::State'  =&gt;  'int' ,
+'QNetworkProtocolFactory*' =&gt; 'qt_QNetworkProtocolFactory*',
+'QNetworkProtocolFactoryBase*'  =&gt;  'qt_QNetworkProtocolFactoryBase*' ,
+'QObject*' =&gt; 'qt_QObject*',
+'QObjectCleanupHandler*' =&gt; 'qt_QObjectCleanupHandler*',
+'QObjectDictionary&amp;'  =&gt; 'qt_QObjectDictionary*' ,
+'QObjectDictionary*' =&gt; 'qt_QObjectDictionary*',
+'QObjectInterface*' =&gt; 'qt_QObjectInterface*',
+'QObjectList&amp;'  =&gt; 'qt_QObjectList*' ,
+'QObjectList*' =&gt; 'qt_QObjectList*',
+'QObjectListIt&amp;'  =&gt; 'qt_QObjectListIt*' ,
+'QObjectListIt*' =&gt; 'qt_QObjectListIt*',
+'QPNGImagePacker*' =&gt; 'qt_QPNGImagePacker*',
+'QPNGImageWriter*' =&gt; 'qt_QPNGImageWriter*',
+'QPaintDevice*' =&gt; 'qt_QPaintDevice*',
+'QPaintDeviceMetrics*' =&gt; 'qt_QPaintDeviceMetrics*',
+'QPaintDeviceX11Data*'  =&gt;  'qt_QPaintDeviceX11Data*' ,
+'QPaintEvent*'  =&gt; 'qt_QPaintEvent*' ,
+'QPainter&amp;'  =&gt;  'qt_QPainter*' ,
+'QPainter*' =&gt; 'qt_QPainter*',
+'QPair*' =&gt; 'qt_QPair*',
+'QPalData*' =&gt; 'qt_QPalData*',
+'QPalette&amp;' =&gt; 'qt_QPalette*',
+'QPalette' =&gt; 'qt_QPalette*',
+'QPalette*' =&gt; 'qt_QPalette*',
+'QPen&amp;' =&gt; 'qt_QPen*',
+'QPen'  =&gt;  'qt_QPen*' ,
+'QPen*' =&gt; 'qt_QPen*',
+'QPenData*' =&gt; 'qt_QPenData*',
+'QPicture&amp;' =&gt; 'qt_QPicture*',
+'QPicture' =&gt; 'qt_QPicture*',
+'QPicture*' =&gt; 'qt_QPicture*',
+'QPicturePrivate*' =&gt; 'qt_QPicturePrivate*',
+'QPixmap&amp; pixmap()' =&gt; 'kde_QPixmap*',
+'QPixmap&amp;' =&gt; 'qt_QPixmap*',
+'QPixmap' =&gt; 'qt_QPixmap*',
+'QPixmap*' =&gt; 'qt_QPixmap*',
+'QPixmap::Optimization'  =&gt;  'int' ,
+'QPixmap::Optimization' =&gt; 'int',
+'QPixmap::Optimization::DefaultOptim'  =&gt;  'int' ,
+'QPixmapCache*' =&gt; 'qt_QPixmapCache*',
+'QPixmapData*' =&gt; 'qt_QPixmapData*',
+'QPlatinumStyle*' =&gt; 'qt_QPlatinumStyle*',
+'QPluginManager*' =&gt; 'qt_QPluginManager*',
+'QPoint&amp;' =&gt; 'qt_QPoint*',
+'QPoint&amp;pos()'  =&gt;  'int' ,
+'QPoint&amp;pos::pos()'  =&gt;  'int' ,
+'QPoint' =&gt; 'qt_QPoint*',
+'QPoint*'  =&gt; 'qt_QPoint*' ,
+'QPointArray&amp;' =&gt; 'qt_QPointArray*',
+'QPointArray' =&gt; 'qt_QPointArray*',
+'QPointArray*' =&gt; 'qt_QPointArray*',
+'QPointVal&amp;'  =&gt; 'qt_QPointVal*' ,
+'QPointVal'  =&gt; 'qt_QPointVal*' ,
+'QPolygonScanner*' =&gt; 'qt_QPolygonScanner*',
+'QPopupMenu*' =&gt; 'qt_QPopupMenu*',
+'QPrintDialog*' =&gt; 'qt_QPrintDialog*',
+'QPrinter*'  =&gt; 'qt_QPrinter*' ,
+'QPrinter::PrinterMode' =&gt; 'int',
+'QProcess*' =&gt; 'qt_QProcess*',
+'QProgressBar*' =&gt; 'qt_QProgressBar*',
+'QProgressDialog*' =&gt; 'qt_QProgressDialog*',
+'QPtrBucket*' =&gt; 'qt_QPtrBucket*',
+'QPtrCollection&amp;' =&gt; 'qt_QPtrCollection*',
+'QPtrCollection*' =&gt; 'qt_QPtrCollection*',
+'QPtrDict*' =&gt; 'qt_QPtrDict*',
+'QPtrDictIterator*' =&gt; 'qt_QPtrDictIterator*',
+'QPtrList*' =&gt; 'qt_QPtrList*',
+'QPtrListIterator*' =&gt; 'qt_QPtrListIterator*',
+'QPtrQueue*' =&gt; 'qt_QPtrQueue*',
+'QPtrStack*' =&gt; 'qt_QPtrStack*',
+'QPtrVector*' =&gt; 'qt_QPtrVector*',
+'QPushButton*' =&gt; 'qt_QPushButton*',
+'QQueue*' =&gt; 'qt_QQueue*',
+'QRESULT' =&gt; 'long',
+'QRadioButton*' =&gt; 'qt_QRadioButton*',
+'QRangeControl*' =&gt; 'qt_QRangeControl*',
+'QRect&amp;' =&gt; 'qt_QRect*',
+'QRect' =&gt; 'qt_QRect*',
+'QRect*' =&gt; 'qt_QRect*',
+'QRegExp&amp;' =&gt; 'qt_QRegExp*',
+'QRegExp*' =&gt; 'qt_QRegExp*',
+'QRegExpValidator*' =&gt; 'qt_QRegExpValidator*',
+'QRegion&amp;' =&gt; 'qt_QRegion*',
+'QRegion' =&gt; 'qt_QRegion*',
+'QRegion*' =&gt; 'qt_QRegion*',
+'QRegionData*' =&gt; 'qt_QRegionData*',
+'QRemoteFactory*' =&gt; 'qt_QRemoteFactory*',
+'QRemotePlugin*' =&gt; 'qt_QRemotePlugin*',
+'QResizeEvent*'  =&gt; 'qt_QResizeEvent*' ,
+'QRgb' =&gt; 'unsigned int',
+'QRgb*' =&gt; 'int*',
+'QRichText&amp;'  =&gt;  'qt_QRichText*' ,
+'QSGIStyle*' =&gt; 'qt_QSGIStyle*',
+'QScrollBar&amp;'  =&gt;  'qt_QScrollBar*' ,
+'QScrollBar*'  =&gt;  'qt_QScrollBar*' ,
+'QScrollView*' =&gt; 'qt_QScrollView*',
+'QSemaphore*' =&gt; 'qt_QSemaphore*',
+'QSemiModal*' =&gt; 'qt_QSemiModal*',
+'QSenderObject*' =&gt; 'qt_QSenderObject*',
+'QServerSocket*' =&gt; 'qt_QServerSocket*',
+'QSessionManager&amp;'  =&gt;  'qt_QSessionManager*' ,
+'QSessionManager*' =&gt; 'qt_QSessionManager*',
+'QSettings*' =&gt; 'qt_QSettings*',
+'QShared*' =&gt; 'qt_QShared*',
+'QShowEvent*'  =&gt;  'qt_QShowEvent*' ,
+'QSignal*' =&gt; 'qt_QSignal*',
+'QSignalDict&amp;'  =&gt; 'qt_QSignalDict*' ,
+'QSignalDict*' =&gt; 'qt_QSignalDict*',
+'QSignalDictIt&amp;'  =&gt; 'qt_QSignalDictIt*' ,
+'QSignalDictIt*' =&gt; 'qt_QSignalDictIt*',
+'QSignalMapper*' =&gt; 'qt_QSignalMapper*',
+'QSignalVec&amp;' =&gt; 'qt_QSignalVec*',
+'QSignalVec*' =&gt; 'qt_QSignalVec*',
+'QSimpleRichText*' =&gt; 'qt_QSimpleRichText*',
+'QSize&amp;' =&gt; 'qt_QSize*',
+'QSize' =&gt; 'qt_QSize*',
+'QSize*'  =&gt; 'qt_QSize*' ,
+'QSizeGrip*' =&gt; 'qt_QSizeGrip*',
+'QSizePolicy&amp;'  =&gt;  'qt_QSizePolicy*' ,
+'QSizePolicy'  =&gt;  'qt_QSizePolicy*' ,
+'QSizePolicy*' =&gt; 'qt_QSizePolicy*',
+'QSizePolicy::ExpandData'  =&gt;  'int' ,
+'QSizePolicy::SizeTypehData::Minimum'  =&gt;  'int' ,
+'QSizePolicy::SizeTypevData::Minimum'  =&gt;  'int' ,
+'QSjisCodec*' =&gt; 'qt_QSjisCodec*',
+'QSlider*' =&gt; 'qt_QSlider*',
+'QSmartPtr&amp;'  =&gt;  'qt_QSmartPtr*' ,
+'QSmartPtr*' =&gt; 'qt_QSmartPtr*',
+'QSmartPtrPrivate*' =&gt; 'qt_QSmartPtrPrivate*',
+'QSocket*' =&gt; 'qt_QSocket*',
+'QSocketDevice*'  =&gt;  'qt_QSocketDevice*' ,
+'QSocketNotifier*' =&gt; 'qt_QSocketNotifier*',
+'QSocketNotifier::Type' =&gt; 'int',
+'QSortedList*' =&gt; 'qt_QSortedList*',
+'QSound*' =&gt; 'qt_QSound*',
+'QSpacerItem*'  =&gt;  'qt_QSpacerItem*' ,
+'QSpinBox*' =&gt; 'qt_QSpinBox*',
+'QSpinWidget*' =&gt; 'qt_QSpinWidget*',
+'QSplitter*' =&gt; 'qt_QSplitter*',
+'QSql*' =&gt; 'qt_QSql*',
+'QSql::Confirm' =&gt; 'int',
+'QSql::Op' =&gt; 'int',
+'QSqlCursor&amp;' =&gt; 'qt_QSqlCursor*',
+'QSqlCursor' =&gt; 'qt_QSqlCursor*',
+'QSqlCursor*' =&gt; 'qt_QSqlCursor*',
+'QSqlDatabase*' =&gt; 'qt_QSqlDatabase*',
+'QSqlDriver*' =&gt; 'qt_QSqlDriver*',
+'QSqlDriverCreator*' =&gt; 'qt_QSqlDriverCreator*',
+'QSqlDriverCreatorBase*' =&gt; 'qt_QSqlDriverCreatorBase*',
+'QSqlDriverFactoryInterface*' =&gt; 'qt_QSqlDriverFactoryInterface*',
+'QSqlDriverPlugin*' =&gt; 'qt_QSqlDriverPlugin*',
+'QSqlEditorFactory*' =&gt; 'qt_QSqlEditorFactory*',
+'QSqlError&amp;' =&gt; 'qt_QSqlError*',
+'QSqlError' =&gt; 'qt_QSqlError*',
+'QSqlError*' =&gt; 'qt_QSqlError*',
+'QSqlField&amp;' =&gt; 'qt_QSqlField*',
+'QSqlField' =&gt; 'qt_QSqlField*',
+'QSqlField*' =&gt; 'qt_QSqlField*',
+'QSqlFieldInfo&amp;' =&gt; 'qt_QSqlFieldInfo*',
+'QSqlFieldInfo*' =&gt; 'qt_QSqlFieldInfo*',
+'QSqlForm' =&gt; 'qt_QSqlForm*',
+'QSqlForm*' =&gt; 'qt_QSqlForm*',
+'QSqlIndex&amp;' =&gt; 'qt_QSqlIndex*',
+'QSqlIndex' =&gt; 'qt_QSqlIndex*',
+'QSqlIndex*' =&gt; 'qt_QSqlIndex*',
+'QSqlPropertyMap*' =&gt; 'qt_QSqlPropertyMap*',
+'QSqlQuery&amp;' =&gt; 'qt_QSqlQuery*',
+'QSqlQuery' =&gt; 'qt_QSqlQuery*',
+'QSqlQuery*' =&gt; 'qt_QSqlQuery*',
+'QSqlRecord&amp;' =&gt; 'qt_QSqlRecord*',
+'QSqlRecord' =&gt; 'qt_QSqlRecord*',
+'QSqlRecord*' =&gt; 'qt_QSqlRecord*',
+'QSqlRecordInfo&amp;' =&gt; 'qt_QSqlRecordInfo*',
+'QSqlRecordInfo' =&gt; 'qt_QSqlRecordInfo*',
+'QSqlRecordInfo*' =&gt; 'qt_QSqlRecordInfo*',
+'QSqlRecordPrivate*' =&gt; 'qt_QSqlRecordPrivate*',
+'QSqlRecordShared*' =&gt; 'qt_QSqlRecordShared*',
+'QSqlResult' =&gt; 'qt_QSqlResult*',
+'QSqlResult*' =&gt; 'qt_QSqlResult*',
+'QSqlResultShared*' =&gt; 'qt_QSqlResultShared*',
+'QStack*' =&gt; 'qt_QStack*',
+'QStatusBar*'  =&gt; 'qt_QStatusBar*' ,
+'QStoredDrag*' =&gt; 'qt_QStoredDrag*',
+'QStrIList' =&gt; 'kde_QStrIList',
+'QStrIList*' =&gt; 'qt_QStrIList*',
+'QStrIVec*' =&gt; 'qt_QStrIVec*',
+'QStrList&amp;' =&gt; 'qt_QStrList*',
+'QStrList' =&gt; 'qt_QStrList*',
+'QStrList*' =&gt; 'qt_QStrList*',
+'QStrListIterator*' =&gt; 'qt_QStrListIterator*',
+'QStrVec*' =&gt; 'qt_QStrVec*',
+'QString&amp;' =&gt; 'qt_QString*',
+'QString&amp;::null'  =&gt;  'qt_QString*' ,
+'QString&amp;button0Text::null'  =&gt;  'qt_QString*' ,
+'QString&amp;button1Text::null'  =&gt;  'qt_QString*' ,
+'QString&amp;button2Text::null'  =&gt;  'qt_QString*' ,
+'QString&amp;buttonText::null'  =&gt;  'qt_QString*' ,
+'QString&amp;caption::null'  =&gt;  'qt_QString*' ,
+'QString&amp;charSet::null'  =&gt;  'qt_QString*' ,
+'QString&amp;context::null'  =&gt;  'qt_QString*' ,
+'QString&amp;defValue::null'  =&gt;  'qt_QString*' ,
+'QString&amp;dir::null'  =&gt;  'qt_QString*' ,
+'QString&amp;directory::null'  =&gt;  'qt_QString*' ,
+'QString&amp;filter::null'  =&gt;  'qt_QString*' ,
+'QString&amp;initially::null'  =&gt;  'qt_QString*' ,
+'QString&amp;location::null'  =&gt;  'qt_QString*' ,
+'QString&amp;n::null'  =&gt;  'qt_QString*' ,
+'QString&amp;nameFilter::null'  =&gt;  'qt_QString*' ,
+'QString&amp;noButtonText::null'  =&gt;  'qt_QString*' ,
+'QString&amp;search_delimiters::null'  =&gt;  'qt_QString*' ,
+'QString&amp;style::null'  =&gt;  'qt_QString*' ,
+'QString&amp;suffix::null'  =&gt;  'qt_QString*' ,
+'QString&amp;text::null'  =&gt;  'qt_QString*' ,
+'QString&amp;text_::null'  =&gt;  'qt_QString*' ,
+'QString&amp;translation::null'  =&gt;  'qt_QString*' ,
+'QString&amp;yesButtonText::null'  =&gt;  'qt_QString*' ,
+'QString' =&gt; 'qt_QString*',
+'QString*'  =&gt; 'qt_QString*' ,
+'QString::null'  =&gt;  'qt_QString_null()' ,
+'QStringBucket*' =&gt; 'qt_QStringBucket*',
+'QStringData*' =&gt; 'qt_QStringData*',
+'QStringList&amp;'  =&gt;  'qt_QStringList*' ,
+'QStringList'  =&gt;  'qt_QStringList*' ,
+'QStringList*'  =&gt; 'qt_QStringList*' ,
+'QStringcharSetName::null'  =&gt;  'qt_QStringcharSetName*' ,
+'QStyle&amp;'  =&gt;  'qt_QStyle*' ,
+'QStyle*'  =&gt;  'qt_QStyle*' ,
+'QStyle::ScrollControl'  =&gt; 'int' ,
+'QStyle::StylePixmap' =&gt; 'int',
+'QStyle::SubControl' =&gt; 'int',
+'QStyle::SubRect' =&gt; 'int',
+'QStyleFactory*' =&gt; 'qt_QStyleFactory*',
+'QStyleFactoryInterface*' =&gt; 'qt_QStyleFactoryInterface*',
+'QStyleOption&amp;' =&gt; 'int',
+'QStyleOption' =&gt; 'int',
+'QStyleOption*' =&gt; 'int*',
+'QStylePlugin*' =&gt; 'qt_QStylePlugin*',
+'QStyleSheet*'  =&gt;  'qt_QStyleSheet*' ,
+'QStyleSheetItem&amp;'  =&gt;  'qt_QStyleSheetItem*' ,
+'QStyleSheetItem*'  =&gt;  'qt_QStyleSheetItem*' ,
+'QStyleSheetItem::DisplayMode*' =&gt; 'int',
+'QStyleSheetItem::ListStyle*' =&gt; 'int',
+'QStyleSheetItem::WhiteSpaceMode' =&gt; 'int',
+'QTSCIICodec*' =&gt; 'qt_QTSCIICodec*',
+'QTSMFI'  =&gt;  'int' ,
+'QTab*' =&gt; 'qt_QTab*',
+'QTabBar*'  =&gt;  'qt_QTabBar*' ,
+'QTabBar::Shape'  =&gt; 'int' ,
+'QTabDialog*' =&gt; 'qt_QTabDialog*',
+'QTabWidget*' =&gt; 'qt_QTabWidget*',
+'QTable*'  =&gt;  'qt_QTable*' ,
+'QTableHeader*' =&gt; 'qt_QTableHeader*',
+'QTableItem*'  =&gt;  'qt_QTableItem*' ,
+'QTableSelection&amp;'  =&gt;  'qt_QTableSelection*' ,
+'QTableSelection'  =&gt;  'qt_QTableSelection*' ,
+'QTableSelection*' =&gt; 'qt_QTableSelection*',
+'QTableView*' =&gt; 'qt_QTableView*',
+'QTabletEvent*' =&gt; 'qt_QTabletEvent*',
+'QTextBrowser*' =&gt; 'qt_QTextBrowser*',
+'QTextCodec*'  =&gt;  'qt_QTextCodec*' ,
+'QTextCodecFactory*' =&gt; 'qt_QTextCodecFactory*',
+'QTextCodecFactoryInterface*' =&gt; 'qt_QTextCodecFactoryInterface*',
+'QTextCodecPlugin*' =&gt; 'qt_QTextCodecPlugin*',
+'QTextCursor*' =&gt; 'qt_QTextCursor*',
+'QTextDecoder*'  =&gt;  'qt_QTextDecoder*' ,
+'QTextDocument*' =&gt; 'qt_QTextDocument*',
+'QTextDrag*' =&gt; 'qt_QTextDrag*',
+'QTextEdit*' =&gt; 'qt_QTextEdit*',
+'QTextEncoder*'  =&gt;  'qt_QTextEncoder*' ,
+'QTextFormat*' =&gt; 'qt_QTextFormat*',
+'QTextIStream*' =&gt; 'qt_QTextIStream*',
+'QTextOStream&amp;'  =&gt;  'qt_QTextOStream*' ,
+'QTextOStream*' =&gt; 'qt_QTextOStream*',
+'QTextOStreamIterator*' =&gt; 'qt_QTextOStreamIterator*',
+'QTextParag**' =&gt; 'qt_QTextParag**',
+'QTextStream&amp;'  =&gt; 'qt_QTextStream*' ,
+'QTextStream*'  =&gt; 'qt_QTextStream*' ,
+'QTextView*' =&gt; 'qt_QTextView*',
+'QThread*' =&gt; 'qt_QThread*',
+'QThreadData*' =&gt; 'qt_QThreadData*',
+'QThreadEvent*' =&gt; 'qt_QThreadEvent*',
+'QTime&amp;' =&gt; 'qt_QTime*',
+'QTime' =&gt; 'qt_QTime*',
+'QTime*' =&gt; 'qt_QTime*',
+'QTimeEdit*' =&gt; 'qt_QTimeEdit*',
+'QTimeWatch*' =&gt; 'qt_QTimeWatch*',
+'QTimer*' =&gt; 'qt_QTimer*',
+'QTimerEvent*'  =&gt; 'qt_QTimerEvent*' ,
+'QToolBar*'  =&gt; 'qt_QToolBar*' ,
+'QToolButton*'  =&gt;  'qt_QToolButton*' ,
+'QToolTip*' =&gt; 'qt_QToolTip*',
+'QToolTipGroup*' =&gt; 'qt_QToolTipGroup*',
+'QTranslator*'  =&gt;  'qt_QTranslator*' ,
+'QTranslatorMessage&amp;'  =&gt;  'qt_QTranslatorMessage*' ,
+'QTranslatorMessage'  =&gt;  'qt_QTranslatorMessage*' ,
+'QTranslatorMessage*' =&gt; 'qt_QTranslatorMessage*',
+'QTsciiCodec*' =&gt; 'qt_QTsciiCodec*',
+'QUObject*' =&gt; 'qt_QUObject*',
+'QUnknownInterface*' =&gt; 'qt_QUnknownInterface*',
+'QUnknownInterface**' =&gt; 'qt_QUnknownInterface**',
+'QUriDrag*' =&gt; 'qt_QUriDrag*',
+'QUrl&amp;'  =&gt;  'qt_QUrl*' ,
+'QUrl'  =&gt;  'qt_QUrl*' ,
+'QUrl*' =&gt; 'qt_QUrl*',
+'QUrlInfo&amp;'  =&gt;  'qt_QUrlInfo*' ,
+'QUrlInfo'  =&gt;  'qt_QUrlInfo*' ,
+'QUrlInfo*' =&gt; 'qt_QUrlInfo*',
+'QUrlOperator&amp;'  =&gt;  'qt_QUrlOperator*' ,
+'QUrlOperator*'  =&gt;  'qt_QUrlOperator*' ,
+'QUtf16Codec*' =&gt; 'qt_QUtf16Codec*',
+'QUtf8Codec*' =&gt; 'qt_QUtf8Codec*',
+'QUuid&amp;' =&gt; 'qt_QUuid*',
+'QUuid*' =&gt; 'qt_QUuid*',
+'QVBox*'  =&gt; 'qt_QVBox*' ,
+'QVBoxLayout*' =&gt; 'qt_QVBoxLayout*',
+'QVButtonGroup*' =&gt; 'qt_QVButtonGroup*',
+'QVFbHeader*' =&gt; 'qt_QVFbHeader*',
+'QVFbKeyData*' =&gt; 'qt_QVFbKeyData*',
+'QVGroupBox*' =&gt; 'qt_QVGroupBox*',
+'QValidator*' =&gt; 'qt_QValidator*',
+'QValidator::State' =&gt; 'int',
+'QValueList*' =&gt; 'qt_QValueList*',
+'QValueListConstIterator*' =&gt; 'qt_QValueListConstIterator*',
+'QValueListIterator*' =&gt; 'qt_QValueListIterator*',
+'QValueListNode*' =&gt; 'qt_QValueListNode*',
+'QValueListPrivate*' =&gt; 'qt_QValueListPrivate*',
+'QValueStack*' =&gt; 'qt_QValueStack*',
+'QValueVector*' =&gt; 'qt_QValueVector*',
+'QValueVectorPrivate*' =&gt; 'qt_QValueVectorPrivate*',
+'QVariant&amp;' =&gt; 'qt_QVariant*',
+'QVariant' =&gt; 'qt_QVariant*',
+'QVariant*' =&gt; 'qt_QVariant*',
+'QVariant::Type'  =&gt; 'int' ,
+'QVariantPrivate*'  =&gt;  'qt_QVariantPrivate*' ,
+'QVector*' =&gt; 'qt_QVector*',
+'QWMatrix&amp;' =&gt; 'qt_QWMatrix*',
+'QWMatrix' =&gt; 'qt_QWMatrix*',
+'QWMatrix*' =&gt; 'qt_QWMatrix*',
+'QWSDecoration&amp;'  =&gt;  'qt_QWSDecoration*' ,
+'QWSDecoration*'  =&gt;  'qt_QWSDecoration*' ,
+'QWSDisplay*'  =&gt;  'qt_QWSDisplay*' ,
+'QWSEvent*'  =&gt;  'qt_QWSEvent*' ,
+'QWaitCondition*' =&gt; 'qt_QWaitCondition*',
+'QWhatsThis*' =&gt; 'qt_QWhatsThis*',
+'QWheelEvent*'  =&gt;  'qt_QWheelEvent*' ,
+'QWidget*' =&gt; 'qt_QWidget*',
+'QWidget' =&gt; 'qt_QWidget*',
+'QWidget*' =&gt; 'qt_QWidget*',
+'QWidgetFactory*' =&gt; 'qt_QWidgetFactory*',
+'QWidgetIntDict&amp;'  =&gt; 'qt_QWidgetIntDict*' ,
+'QWidgetIntDict*' =&gt; 'qt_QWidgetIntDict*',
+'QWidgetIntDictIt&amp;'  =&gt; 'qt_QWidgetIntDictIt*' ,
+'QWidgetIntDictIt*' =&gt; 'qt_QWidgetIntDictIt*',
+'QWidgetItem*' =&gt; 'qt_QWidgetItem*',
+'QWidgetList&amp;'  =&gt; 'qt_QWidgetList*' ,
+'QWidgetList&amp;'  =&gt; 'qt_QWidgetList*' ,
+'QWidgetList'  =&gt;  'qt_QWidgetList*' ,
+'QWidgetList'  =&gt;  'qt_QWidgetList*' ,
+'QWidgetList*' =&gt; 'qt_QWidgetList*',
+'QWidgetList*' =&gt; 'qt_QWidgetList*',
+'QWidgetListIt&amp;'  =&gt; 'qt_QWidgetListIt*' ,
+'QWidgetListIt*' =&gt; 'qt_QWidgetListIt*',
+'QWidgetMapper*' =&gt; 'qt_QWidgetMapper*',
+'QWidgetPlugin*' =&gt; 'qt_QWidgetPlugin*',
+'QWidgetStack*' =&gt; 'qt_QWidgetStack*',
+'QWindowsMime*'  =&gt;  'qt_QWindowsMime*' ,
+'QWindowsStyle*' =&gt; 'qt_QWindowsStyle*',
+'QWizard*' =&gt; 'qt_QWizard*',
+'QWorkspace*' =&gt; 'qt_QWorkspace*',
+'QXEmbed*'  =&gt;  'qt_QXEmbed*' ,
+'QXmlAttributes&amp;'  =&gt;  'qt_QXmlAttributes*' ,
+'QXmlAttributes*' =&gt; 'qt_QXmlAttributes*',
+'QXmlContentHandler*'  =&gt;  'qt_QXmlContentHandler*' ,
+'QXmlDTDHandler*'  =&gt;  'qt_QXmlDTDHandler*' ,
+'QXmlDeclHandler*'  =&gt;  'qt_QXmlDeclHandler*' ,
+'QXmlDefaultHandler*' =&gt; 'qt_QXmlDefaultHandler*',
+'QXmlEntityResolver*'  =&gt;  'qt_QXmlEntityResolver*' ,
+'QXmlErrorHandler*'  =&gt;  'qt_QXmlErrorHandler*' ,
+'QXmlInputSource&amp;'  =&gt;  'qt_QXmlInputSource*' ,
+'QXmlInputSource*&amp;' =&gt; 'qt_QXmlInputSource*',
+'QXmlInputSource*'  =&gt;  'qt_QXmlInputSource*' ,
+'QXmlLexicalHandler*'  =&gt;  'qt_QXmlLexicalHandler*' ,
+'QXmlLocator*'  =&gt;  'qt_QXmlLocator*' ,
+'QXmlNamespaceSupport*' =&gt; 'qt_QXmlNamespaceSupport*',
+'QXmlParseException&amp;'  =&gt;  'qt_QXmlParseException*' ,
+'QXmlParseException*' =&gt; 'qt_QXmlParseException*',
+'QXmlReader*' =&gt; 'qt_QXmlReader*',
+'QXmlSimpleReader*'  =&gt;  'qt_QXmlSimpleReader*' ,
+'QXtApplication*' =&gt; 'qt_QXtApplication*',
+'QXtWidget*' =&gt; 'qt_QXtWidget*',
+'Q_INT16&amp;' =&gt; 'short',
+'Q_INT16' =&gt; 'short',
+'Q_INT32&amp;' =&gt; 'int',
+'Q_INT32' =&gt; 'int',
+'Q_INT8&amp;' =&gt; 'char',
+'Q_INT8' =&gt; 'char',
+'Q_LONG&amp;' =&gt; 'long',
+'Q_LONG' =&gt; 'long',
+'Q_PACKED*' =&gt; 'void*',
+'Q_UINT16&amp;' =&gt; 'unsigned short',
+'Q_UINT16' =&gt; 'unsigned short',
+'Q_UINT32&amp;' =&gt; 'unsigned int',
+'Q_UINT32' =&gt; 'unsigned int',
+'Q_UINT8&amp;' =&gt; 'unsigned char',
+'Q_UINT8' =&gt; 'unsigned char',
+'Q_UINT8*'  =&gt;  'unsigned char*' ,
+'Q_ULONG&amp;' =&gt; 'long',
+'Q_ULONG' =&gt; 'long',
+'Qt*'  =&gt;  'qt_Qt*' ,
+'Qt::ArrowType'  =&gt;  'int' ,
+'Qt::BackgroundMode' =&gt; 'int',
+'Qt::DateFormat' =&gt; 'int',
+'Qt::GUIStyle'  =&gt; 'int' ,
+'Qt::GUIStylecolorStyle::WindowsStyle'  =&gt; 'int' ,
+'Qt::GUIStylestyle::WindowsStyle'  =&gt; 'int' ,
+'Qt::Orientation'  =&gt;  'int' ,
+'Qt::RasterOp'  =&gt;  'int' ,
+'Qt::UIEffect'  =&gt;  'int' ,
+'Qt::WFlags'  =&gt;  'int' ,
+'QtMultiLineEdit*' =&gt; 'qt_QtMultiLineEdit*',
+'QtMultiLineEditRow*' =&gt; 'qt_QtMultiLineEditRow*',
+'QtTableView*' =&gt; 'qt_QtTableView*',
+'QwAbsSpriteFieldView*'  =&gt;  'qt_QwAbsSpriteFieldView*' ,
+'QwClusterizer*'  =&gt;  'qt_QwClusterizer*' ,
+'QwEllipse*' =&gt; 'qt_QwEllipse*',
+'QwImageSpriteField*' =&gt; 'qt_QwImageSpriteField*',
+'QwMobilePositionedSprite*' =&gt; 'qt_QwMobilePositionedSprite*',
+'QwMobileSprite*' =&gt; 'qt_QwMobileSprite*',
+'QwPolygon*' =&gt; 'qt_QwPolygon*',
+'QwPolygonalGraphic*' =&gt; 'qt_QwPolygonalGraphic*',
+'QwPositionedSprite*' =&gt; 'qt_QwPositionedSprite*',
+'QwPublicList*'  =&gt;  'qt_QwPublicList*' ,
+'QwRealMobileSprite*' =&gt; 'qt_QwRealMobileSprite*',
+'QwRealSprite*' =&gt; 'qt_QwRealSprite*',
+'QwRectangle*' =&gt; 'qt_QwRectangle*',
+'QwScrollingSpriteFieldView*' =&gt; 'qt_QwScrollingSpriteFieldView*',
+'QwSprite*' =&gt; 'qt_QwSprite*',
+'QwSpriteField*'  =&gt;  'qt_QwSpriteField*' ,
+'QwSpriteField*'  =&gt; 'qt_QwSpriteField*' ,
+'QwSpriteFieldGraphic&amp;'  =&gt; 'qt_QwSpriteFieldGraphic*' ,
+'QwSpriteFieldGraphic*'  =&gt;  'qt_QwSpriteFieldGraphic*' ,
+'QwSpriteFieldView*' =&gt; 'qt_QwSpriteFieldView*',
+'QwSpritePixmap*'  =&gt;  'qt_QwSpritePixmap*' ,
+'QwSpritePixmapSequence*'  =&gt; 'qt_QwSpritePixmapSequence*' ,
+'QwTextSprite*' =&gt; 'qt_QwTextSprite*',
+'QwTiledSpriteField*' =&gt; 'qt_QwTiledSpriteField*',
+'QwVirtualSprite*' =&gt; 'qt_QwVirtualSprite*',
+'RArray*' =&gt; 'kde_RArray*',
+'RGBColor&amp;' =&gt; 'kde_RGBColor*',
+'RGBColor' =&gt; 'kde_RGBColor*',
+'RGBColor*' =&gt; 'kde_RGBColor*',
+'Range&amp;' =&gt; 'kde_Range*',
+'Range' =&gt; 'kde_Range*',
+'Range*' =&gt; 'kde_Range*',
+'RangeException&amp;' =&gt; 'kde_RangeException*',
+'RangeException*' =&gt; 'kde_RangeException*',
+'RangeImpl*' =&gt; 'kde_RangeImpl*',
+'RasterOp' =&gt; 'int',
+'RawDataPacket*' =&gt; 'kde_RawDataPacket*',
+'ReadOnlyPart*' =&gt; 'kde_ReadOnlyPart*',
+'ReadWritePart*' =&gt; 'kde_ReadWritePart*',
+'Rect&amp;' =&gt; 'kde_Rect*',
+'Rect' =&gt; 'kde_Rect*',
+'Rect*' =&gt; 'kde_Rect*',
+'Reference&amp;' =&gt; 'kde_Reference*',
+'Reference*' =&gt; 'kde_Reference*',
+'ReferenceClean*' =&gt; 'kde_ReferenceClean*',
+'ReferenceHelper*' =&gt; 'kde_ReferenceHelper*',
+'Region' =&gt; 'int',
+'RegionType' =&gt; 'int',
+'RemoteScheduleNode*' =&gt; 'kde_RemoteScheduleNode*',
+'RenameDlg*' =&gt; 'kde_RenameDlg*',
+'RenderStyle*'  =&gt;  'kde_RenderStyle*' ,
+'Rep*' =&gt; 'kde_Rep*',
+'RunMode'  =&gt;  'int' ,
+'SButton*' =&gt; 'kde_SButton*',
+'SCFlags' =&gt; 'int',
+'SFlags' =&gt; 'int',
+'ScheduleNode*' =&gt; 'kde_ScheduleNode*',
+'Scheduler*' =&gt; 'kde_Scheduler*',
+'ScrollBarMode' =&gt; 'int',
+'ScrollControl'  =&gt;  'int' ,
+'SearchInterface*' =&gt; 'kde_SearchInterface*',
+'Section&amp;'  =&gt;  'kde_Section*' ,
+'Section*&amp;'  =&gt;  'kde_Section*' ,
+'Section*'  =&gt;  'kde_Section*' ,
+'SegmentStyle' =&gt; 'int',
+'SelectionInterface*' =&gt; 'kde_SelectionInterface*',
+'Separator' =&gt; 'int',
+'Server&amp;'  =&gt;  'Server*' ,
+'Server*' =&gt; 'kde_Server*',
+'ServerHello&amp;' =&gt; 'kde_ServerHello*',
+'ServerHello*' =&gt; 'kde_ServerHello*',
+'Service*' =&gt; 'kde_Service*',
+'SessionData*' =&gt; 'kde_SessionData*',
+'SimpleFormat*' =&gt; 'kde_SimpleFormat*',
+'SimpleJob*' =&gt; 'kde_SimpleJob*',
+'SimpleSoundServer&amp;' =&gt; 'kde_SimpleSoundServer*',
+'SimpleSoundServer' =&gt; 'kde_SimpleSoundServer*',
+'SimpleSoundServer*' =&gt; 'kde_SimpleSoundServer*',
+'SimpleSoundServer_base*' =&gt; 'kde_SimpleSoundServer_base*',
+'SimpleSoundServer_skel*' =&gt; 'kde_SimpleSoundServer_skel*',
+'SimpleSoundServer_stub*' =&gt; 'kde_SimpleSoundServer_stub*',
+'SkipDlg*' =&gt; 'kde_SkipDlg*',
+'Slave*' =&gt; 'kde_Slave*',
+'SlaveBase*' =&gt; 'kde_SlaveBase*',
+'SlaveBasePrivate*' =&gt; 'kde_SlaveBasePrivate*',
+'SlaveConfig*' =&gt; 'kde_SlaveConfig*',
+'SlaveInterface*' =&gt; 'kde_SlaveInterface*',
+'SocketConnection*' =&gt; 'kde_SocketConnection*',
+'Spec' =&gt; 'int',
+'SpecialEvent*' =&gt; 'kde_SpecialEvent*',
+'SshProcess*' =&gt; 'kde_SshProcess*',
+'SshProcessPrivate*' =&gt; 'kde_SshProcessPrivate*',
+'StartupClass*' =&gt; 'kde_StartupClass*',
+'StartupManager*' =&gt; 'kde_StartupManager*',
+'StatJob*' =&gt; 'kde_StatJob*',
+'State' =&gt; 'int',
+'QSocket::State' =&gt; 'int',
+'StatusbarProgress*' =&gt; 'kde_StatusbarProgress*',
+'StdAddressBook*' =&gt; 'kde_StdAddressBook*',
+'StdFlowSystem*' =&gt; 'kde_StdFlowSystem*',
+'StdIOManager*' =&gt; 'kde_StdIOManager*',
+'StdScheduleNode*' =&gt; 'kde_StdScheduleNode*',
+'StdSynthModule*' =&gt; 'kde_StdSynthModule*',
+'StereoEffect&amp;' =&gt; 'kde_StereoEffect*',
+'StereoEffect' =&gt; 'kde_StereoEffect*',
+'StereoEffect*' =&gt; 'kde_StereoEffect*',
+'StereoEffectStack&amp;' =&gt; 'kde_StereoEffectStack*',
+'StereoEffectStack' =&gt; 'kde_StereoEffectStack*',
+'StereoEffectStack*' =&gt; 'kde_StereoEffectStack*',
+'StereoEffectStack_base*' =&gt; 'kde_StereoEffectStack_base*',
+'StereoEffectStack_skel*' =&gt; 'kde_StereoEffectStack_skel*',
+'StereoEffectStack_stub*' =&gt; 'kde_StereoEffectStack_stub*',
+'StereoEffect_base*' =&gt; 'kde_StereoEffect_base*',
+'StereoEffect_skel*' =&gt; 'kde_StereoEffect_skel*',
+'StereoEffect_stub*' =&gt; 'kde_StereoEffect_stub*',
+'StereoFFTScope&amp;' =&gt; 'kde_StereoFFTScope*',
+'StereoFFTScope' =&gt; 'kde_StereoFFTScope*',
+'StereoFFTScope*' =&gt; 'kde_StereoFFTScope*',
+'StereoFFTScope_base*' =&gt; 'kde_StereoFFTScope_base*',
+'StereoFFTScope_skel*' =&gt; 'kde_StereoFFTScope_skel*',
+'StereoFFTScope_stub*' =&gt; 'kde_StereoFFTScope_stub*',
+'StereoVolumeControl&amp;' =&gt; 'kde_StereoVolumeControl*',
+'StereoVolumeControl' =&gt; 'kde_StereoVolumeControl*',
+'StereoVolumeControl*' =&gt; 'kde_StereoVolumeControl*',
+'StereoVolumeControl_base*' =&gt; 'kde_StereoVolumeControl_base*',
+'StereoVolumeControl_skel*' =&gt; 'kde_StereoVolumeControl_skel*',
+'StereoVolumeControl_stub*' =&gt; 'kde_StereoVolumeControl_stub*',
+'StreamMode&amp;' =&gt; 'int',
+'String*' =&gt; 'kde_String*',
+'StringSectionMap::iterator&amp;'  =&gt;  'kde_StringSectionMap*' ,
+'StringSectionMap::iterator'  =&gt;  'kde_StringSectionMap*r' ,
+'StubProcess*' =&gt; 'kde_StubProcess*',
+'StyleHint' =&gt; 'int',
+'StyleListImpl*' =&gt; 'kde_StyleListImpl*',
+'StylePixmap' =&gt; 'int',
+'StyleSheet&amp;' =&gt; 'kde_StyleSheet*',
+'StyleSheet' =&gt; 'kde_StyleSheet*',
+'StyleSheet*' =&gt; 'kde_StyleSheet*',
+'StyleSheetImpl*' =&gt; 'kde_StyleSheetImpl*',
+'StyleSheetList&amp;' =&gt; 'kde_StyleSheetList*',
+'StyleSheetList' =&gt; 'kde_StyleSheetList',
+'StyleSheetList*' =&gt; 'kde_StyleSheetList*',
+'StyleSheetListImpl*' =&gt; 'kde_StyleSheetListImpl*',
+'StyleStrategy' =&gt; 'int',
+'SuProcess*' =&gt; 'kde_SuProcess*',
+'SubClass&amp;' =&gt; 'kde_SubClass*',
+'SubClass*' =&gt; 'kde_SubClass*',
+'SubControl' =&gt; 'int',
+'SubRect' =&gt; 'int',
+'SynthBuffer*' =&gt; 'kde_SynthBuffer*',
+'SynthModule&amp;' =&gt; 'kde_SynthModule*',
+'SynthModule' =&gt; 'kde_SynthModule*',
+'SynthModule*' =&gt; 'kde_SynthModule*',
+'SynthModule_base*' =&gt; 'kde_SynthModule_base*',
+'SynthModule_skel*' =&gt; 'kde_SynthModule_skel*',
+'SynthModule_stub*' =&gt; 'kde_SynthModule_stub*',
+'SynthOut*' =&gt; 'kde_SynthOut*',
+'Synth_ADD&amp;' =&gt; 'kde_Synth_ADD*',
+'Synth_ADD' =&gt; 'kde_Synth_ADD*',
+'Synth_ADD*' =&gt; 'kde_Synth_ADD*',
+'Synth_ADD_base*' =&gt; 'kde_Synth_ADD_base*',
+'Synth_ADD_skel*' =&gt; 'kde_Synth_ADD_skel*',
+'Synth_ADD_stub*' =&gt; 'kde_Synth_ADD_stub*',
+'Synth_AMAN_PLAY&amp;' =&gt; 'kde_Synth_AMAN_PLAY*',
+'Synth_AMAN_PLAY' =&gt; 'kde_Synth_AMAN_PLAY*',
+'Synth_AMAN_PLAY*' =&gt; 'kde_Synth_AMAN_PLAY*',
+'Synth_AMAN_PLAY_base*' =&gt; 'kde_Synth_AMAN_PLAY_base*',
+'Synth_AMAN_PLAY_skel*' =&gt; 'kde_Synth_AMAN_PLAY_skel*',
+'Synth_AMAN_PLAY_stub*' =&gt; 'kde_Synth_AMAN_PLAY_stub*',
+'Synth_AMAN_RECORD&amp;' =&gt; 'kde_Synth_AMAN_RECORD*',
+'Synth_AMAN_RECORD' =&gt; 'kde_Synth_AMAN_RECORD*',
+'Synth_AMAN_RECORD*' =&gt; 'kde_Synth_AMAN_RECORD*',
+'Synth_AMAN_RECORD_base*' =&gt; 'kde_Synth_AMAN_RECORD_base*',
+'Synth_AMAN_RECORD_skel*' =&gt; 'kde_Synth_AMAN_RECORD_skel*',
+'Synth_AMAN_RECORD_stub*' =&gt; 'kde_Synth_AMAN_RECORD_stub*',
+'Synth_BUS_DOWNLINK&amp;' =&gt; 'kde_Synth_BUS_DOWNLINK*',
+'Synth_BUS_DOWNLINK' =&gt; 'kde_Synth_BUS_DOWNLINK*',
+'Synth_BUS_DOWNLINK*' =&gt; 'kde_Synth_BUS_DOWNLINK*',
+'Synth_BUS_DOWNLINK_base*' =&gt; 'kde_Synth_BUS_DOWNLINK_base*',
+'Synth_BUS_DOWNLINK_skel*' =&gt; 'kde_Synth_BUS_DOWNLINK_skel*',
+'Synth_BUS_DOWNLINK_stub*' =&gt; 'kde_Synth_BUS_DOWNLINK_stub*',
+'Synth_BUS_UPLINK&amp;' =&gt; 'kde_Synth_BUS_UPLINK*',
+'Synth_BUS_UPLINK' =&gt; 'kde_Synth_BUS_UPLINK*',
+'Synth_BUS_UPLINK*' =&gt; 'kde_Synth_BUS_UPLINK*',
+'Synth_BUS_UPLINK_base*' =&gt; 'kde_Synth_BUS_UPLINK_base*',
+'Synth_BUS_UPLINK_skel*' =&gt; 'kde_Synth_BUS_UPLINK_skel*',
+'Synth_BUS_UPLINK_stub*' =&gt; 'kde_Synth_BUS_UPLINK_stub*',
+'Synth_FREQUENCY&amp;' =&gt; 'kde_Synth_FREQUENCY*',
+'Synth_FREQUENCY' =&gt; 'kde_Synth_FREQUENCY*',
+'Synth_FREQUENCY*' =&gt; 'kde_Synth_FREQUENCY*',
+'Synth_FREQUENCY_base*' =&gt; 'kde_Synth_FREQUENCY_base*',
+'Synth_FREQUENCY_skel*' =&gt; 'kde_Synth_FREQUENCY_skel*',
+'Synth_FREQUENCY_stub*' =&gt; 'kde_Synth_FREQUENCY_stub*',
+'Synth_MUL&amp;' =&gt; 'kde_Synth_MUL*',
+'Synth_MUL' =&gt; 'kde_Synth_MUL*',
+'Synth_MUL*' =&gt; 'kde_Synth_MUL*',
+'Synth_MULTI_ADD&amp;' =&gt; 'kde_Synth_MULTI_ADD*',
+'Synth_MULTI_ADD' =&gt; 'kde_Synth_MULTI_ADD*',
+'Synth_MULTI_ADD*' =&gt; 'kde_Synth_MULTI_ADD*',
+'Synth_MULTI_ADD_base*' =&gt; 'kde_Synth_MULTI_ADD_base*',
+'Synth_MULTI_ADD_skel*' =&gt; 'kde_Synth_MULTI_ADD_skel*',
+'Synth_MULTI_ADD_stub*' =&gt; 'kde_Synth_MULTI_ADD_stub*',
+'Synth_MUL_base*' =&gt; 'kde_Synth_MUL_base*',
+'Synth_MUL_skel*' =&gt; 'kde_Synth_MUL_skel*',
+'Synth_MUL_stub*' =&gt; 'kde_Synth_MUL_stub*',
+'Synth_PLAY&amp;' =&gt; 'kde_Synth_PLAY*',
+'Synth_PLAY' =&gt; 'kde_Synth_PLAY*',
+'Synth_PLAY*' =&gt; 'kde_Synth_PLAY*',
+'Synth_PLAY_WAV&amp;' =&gt; 'kde_Synth_PLAY_WAV*',
+'Synth_PLAY_WAV' =&gt; 'kde_Synth_PLAY_WAV*',
+'Synth_PLAY_WAV*' =&gt; 'kde_Synth_PLAY_WAV*',
+'Synth_PLAY_WAV_base*' =&gt; 'kde_Synth_PLAY_WAV_base*',
+'Synth_PLAY_WAV_skel*' =&gt; 'kde_Synth_PLAY_WAV_skel*',
+'Synth_PLAY_WAV_stub*' =&gt; 'kde_Synth_PLAY_WAV_stub*',
+'Synth_PLAY_base*' =&gt; 'kde_Synth_PLAY_base*',
+'Synth_PLAY_skel*' =&gt; 'kde_Synth_PLAY_skel*',
+'Synth_PLAY_stub*' =&gt; 'kde_Synth_PLAY_stub*',
+'Synth_RECORD&amp;' =&gt; 'kde_Synth_RECORD*',
+'Synth_RECORD' =&gt; 'kde_Synth_RECORD*',
+'Synth_RECORD*' =&gt; 'kde_Synth_RECORD*',
+'Synth_RECORD_base*' =&gt; 'kde_Synth_RECORD_base*',
+'Synth_RECORD_skel*' =&gt; 'kde_Synth_RECORD_skel*',
+'Synth_RECORD_stub*' =&gt; 'kde_Synth_RECORD_stub*',
+'Synth_WAVE_SIN&amp;' =&gt; 'kde_Synth_WAVE_SIN*',
+'Synth_WAVE_SIN' =&gt; 'kde_Synth_WAVE_SIN*',
+'Synth_WAVE_SIN*' =&gt; 'kde_Synth_WAVE_SIN*',
+'Synth_WAVE_SIN_base*' =&gt; 'kde_Synth_WAVE_SIN_base*',
+'Synth_WAVE_SIN_skel*' =&gt; 'kde_Synth_WAVE_SIN_skel*',
+'Synth_WAVE_SIN_stub*' =&gt; 'kde_Synth_WAVE_SIN_stub*',
+'T&amp;'  =&gt;  'T*' ,
+'T'  =&gt;  'T*' ,
+'T*'  =&gt;  'T*' ,
+'TCPConnection*' =&gt; 'kde_TCPConnection*',
+'TCPServer*' =&gt; 'kde_TCPServer*',
+'TCPSlaveBase*' =&gt; 'kde_TCPSlaveBase*',
+'TRUE' =&gt; '1',
+'Task*' =&gt; 'kde_Task*',
+'Text&amp;' =&gt; 'kde_Text*',
+'Text' =&gt; 'kde_Text*',
+'Text*' =&gt; 'kde_Text*',
+'TextFormat'  =&gt;  'int' ,
+'TextImpl*' =&gt; 'kde_TextImpl*',
+'ThumbCreator*' =&gt; 'kde_ThumbCreator*',
+'TickSetting' =&gt; 'int',
+'Ticket*' =&gt; 'kde_Ticket*',
+'TimeNotify*' =&gt; 'kde_TimeNotify*',
+'TimeWatcher*' =&gt; 'kde_TimeWatcher*',
+'TimeZone&amp;' =&gt; 'kde_TimeZone*',
+'TimeZone*' =&gt; 'kde_TimeZone*',
+'TmpGlobalComm&amp;' =&gt; 'kde_TmpGlobalComm*',
+'TmpGlobalComm' =&gt; 'kde_TmpGlobalComm*',
+'TmpGlobalComm*' =&gt; 'kde_TmpGlobalComm*',
+'TmpGlobalComm_base*' =&gt; 'kde_TmpGlobalComm_base*',
+'TmpGlobalComm_skel*' =&gt; 'kde_TmpGlobalComm_skel*',
+'TmpGlobalComm_stub*' =&gt; 'kde_TmpGlobalComm_stub*',
+'ToolBarDock&amp;'  =&gt;  'int' ,
+'ToolBarDock' =&gt; 'int',
+'TraderOffer&amp;' =&gt; 'kde_TraderOffer*',
+'TraderOffer' =&gt; 'kde_TraderOffer*',
+'TraderOffer*' =&gt; 'kde_TraderOffer*',
+'TraderOffer_base*' =&gt; 'kde_TraderOffer_base*',
+'TraderOffer_skel*' =&gt; 'kde_TraderOffer_skel*',
+'TraderOffer_stub*' =&gt; 'kde_TraderOffer_stub*',
+'TraderQuery&amp;' =&gt; 'kde_TraderQuery*',
+'TraderQuery' =&gt; 'kde_TraderQuery*',
+'TraderQuery*' =&gt; 'kde_TraderQuery*',
+'TraderQuery_base*' =&gt; 'kde_TraderQuery_base*',
+'TraderQuery_skel*' =&gt; 'kde_TraderQuery_skel*',
+'TraderQuery_stub*' =&gt; 'kde_TraderQuery_stub*',
+'TransferJob*' =&gt; 'kde_TransferJob*',
+'TreeWalker&amp;' =&gt; 'kde_TreeWalker*',
+'TreeWalker' =&gt; 'kde_TreeWalker*',
+'TreeWalker*' =&gt; 'kde_TreeWalker*',
+'TreeWalkerImpl*' =&gt; 'kde_TreeWalkerImpl*',
+'True' =&gt; '1',
+'Type&amp;' =&gt; 'kde_Type*',
+'Type' =&gt; 'int',
+'Type*' =&gt; 'kde_Type*',
+'TypeComponent&amp;' =&gt; 'kde_TypeComponent*',
+'TypeComponent*' =&gt; 'kde_TypeComponent*',
+'TypeDef&amp;' =&gt; 'kde_TypeDef*',
+'TypeDef' =&gt; 'kde_TypeDef*',
+'TypeDef*' =&gt; 'kde_TypeDef*',
+'TypeEntry*' =&gt; 'kde_TypeEntry*',
+'TypeInfo*' =&gt; 'kde_TypeInfo*',
+'UChar&amp;' =&gt; 'kde_UChar*',
+'UChar' =&gt; 'kde_UChar*',
+'UChar*' =&gt; 'kde_UChar*',
+'UCharReference&amp;' =&gt; 'kde_UCharReference*',
+'UCharReference' =&gt; 'kde_UCharReference*',
+'UCharReference*' =&gt; 'kde_UCharReference*',
+'UDSAtom*' =&gt; 'kde_UDSAtom*',
+'UIServer*' =&gt; 'kde_UIServer*',
+'UIServer_stub*' =&gt; 'kde_UIServer_stub*',
+'ULONG_MAX' =&gt; 'ULONG_MAX',
+'UString&amp;' =&gt; 'kde_UString*',
+'UString' =&gt; 'kde_UString*',
+'UString*' =&gt; 'kde_UString*',
+'Undefined*' =&gt; 'kde_Undefined*',
+'UndoInterface*' =&gt; 'kde_UndoInterface*',
+'UndoRedoInfo*' =&gt; 'int*',
+'UnixConnection*' =&gt; 'kde_UnixConnection*',
+'UnixServer*' =&gt; 'kde_UnixServer*',
+'VCardFormat*' =&gt; 'kde_VCardFormat*',
+'VPort*' =&gt; 'kde_VPort*',
+'Value&amp;' =&gt; 'kde_Value*',
+'Value' =&gt; 'kde_Value*',
+'Value*' =&gt; 'kde_Value*',
+'VerticalAlignment*' =&gt; 'int*',
+'View*'  =&gt;  'kde_View*' ,
+'ViewCursorInterface*' =&gt; 'kde_ViewCursorInterface*',
+'VoiceManager*' =&gt; 'kde_VoiceManager*',
+'WFlags' =&gt; 'int',
+'WId' =&gt; 'unsigned int',
+'WState' =&gt; 'int',
+'WavPlayObject&amp;' =&gt; 'kde_WavPlayObject*',
+'WavPlayObject' =&gt; 'kde_WavPlayObject*',
+'WavPlayObject*' =&gt; 'kde_WavPlayObject*',
+'WavPlayObject_base*' =&gt; 'kde_WavPlayObject_base*',
+'WavPlayObject_skel*' =&gt; 'kde_WavPlayObject_skel*',
+'WavPlayObject_stub*' =&gt; 'kde_WavPlayObject_stub*',
+'WeakReference*' =&gt; 'kde_WeakReference*',
+'WeakReferenceBase*' =&gt; 'kde_WeakReferenceBase*',
+'Widget'  =&gt;  'int' ,
+'WidgetClass'  =&gt;  'int' ,
+'WidthMode' =&gt; 'int',
+'Window' =&gt; 'kde_Window*',
+'Window*' =&gt; 'kde_Window*',
+'WindowArgs&amp;' =&gt; 'kde_WindowArgs*',
+'WindowArgs*' =&gt; 'kde_WindowArgs*',
+'WindowsVersion'  =&gt;  'int' ,
+'XrmOptionDescRec*'  =&gt;  'XrmOptionDescRec*' ,
+'array_data*'  =&gt;  'void*' ,
+'bitarr_data*' =&gt; 'void*',
+'bool&amp;'  =&gt;  'int' ,
+'bool' =&gt; 'int',
+'bool*' =&gt; 'int*',
+'char*' =&gt; 'char*',
+'char&amp;'  =&gt;  'char' ,
+'char' =&gt; 'char',
+'char* bugsEmailAddress @bugs.kde.org&quot;' =&gt; 'String',
+'char*&amp;' =&gt; 'char*',
+'char*' =&gt; 'char*',
+'char**' =&gt; 'char**',
+'char*xpm[]'  =&gt;  'char**' ,
+'classConnection*' =&gt; 'kde_classConnection*',
+'classDeviceManager*' =&gt; 'kde_classDeviceManager*',
+'classExtensionLoader*' =&gt; 'kde_classExtensionLoader*',
+'classMidiStatus*' =&gt; 'kde_classMidiStatus*',
+'classObjectReference' =&gt; 'kde_classObjectReference*',
+'classQPainter*' =&gt; 'kde_classQPainter*',
+'classStartupClass*' =&gt; 'kde_classStartupClass*',
+'double d .0' =&gt; 'double',
+'double nDefault .0' =&gt; 'double',
+'double pri .0' =&gt; 'double',
+'double&amp;'  =&gt;  'double' ,
+'double' =&gt; 'double',
+'double*'  =&gt;  'double*' ,
+'false' =&gt; '0',
+'float desat .3' =&gt; 'float',
+'float&amp;'  =&gt;  'float' ,
+'float' =&gt; 'float',
+'float*' =&gt; 'float*',
+'image_io_handler'  =&gt;  'int' ,
+'int a  |' =&gt; 'int',
+'int buttonMask|Apply|Cancel' =&gt; 'int',
+'int buttonMask|No|Cancel' =&gt; 'int',
+'int desktop' =&gt; 'int',
+'int&amp;' =&gt; 'int',
+'int' =&gt; 'int',
+'int*' =&gt; 'int*',
+'int short' =&gt; 'short',
+'kdbgstream&amp;'  =&gt; 'kde_Kdbgstream*' ,
+'kdbgstream*'  =&gt;  'kde_kdbgstream*',
+'kndbgstream&amp;'  =&gt; 'void**' ,
+'kndbgstream*'  =&gt;  'kde_kndbgstream*',
+'ksockaddr_in*'  =&gt; 'void*' ,
+'long _blockSize*' =&gt; 'long*',
+'long int' =&gt; 'long',
+'long unsigned int' =&gt; 'long',
+'long&amp;'  =&gt;  'long' ,
+'long' =&gt; 'long',
+'long_blockSize*'  =&gt;  'long_blockSize*' ,
+'longint' =&gt; 'long',
+'longunsigned int' =&gt; 'unsigned long',
+'lt_dlhandle'  =&gt;  'void*' ,
+'lt_user_dlloader*'  =&gt;  'kde_lt_user_dlloader*',
+'mcopbyte&amp;' =&gt; 'void*',
+'mcopbyte' =&gt; 'unsigned char',
+'mode_t _mode (mode_t) -1' =&gt; 'int',
+'mode_t'  =&gt;  'long' ,
+'noteCmd' =&gt; 'kde_noteCmd*',
+'noteCmd*' =&gt; 'kde_noteCmd*',
+'ostream&amp;' =&gt; 'int',
+'ostream*' =&gt; 'int',
+'pid_t'  =&gt;  'long' ,
+'poTime&amp;' =&gt; 'kde_poTime*',
+'poTime*' =&gt; 'kde_poTime*',
+'short unsigned' =&gt; 'short',
+'short' =&gt; 'short',
+'short*' =&gt; 'short*',
+'shortunsigned' =&gt; 'unsigned short',
+'signed int&amp;'  =&gt;  'signed int' ,
+'signed long&amp;'  =&gt;  'signed long' ,
+'signed short&amp;'  =&gt;  'signed short' ,
+'signed'  =&gt;  'signed' ,
+'size_t'  =&gt;  'int' ,
+'size_t*' =&gt; 'int*',
+'size_type'  =&gt;  'int' ,
+'snd_seq_event_t*' =&gt; 'int*',
+'ssize_t' =&gt; 'int',
+'std*' =&gt; 'kde_std*',
+'std::string&amp;'  =&gt;  'char*' ,
+'std::string'  =&gt;  'char*' ,
+'time_t'  =&gt;  'long' ,
+'timeval&amp;' =&gt; 'int',
+'true' =&gt; '1',
+'type&amp;'  =&gt;  'int' ,
+'type*'  =&gt;  'int*' ,
+'type**'  =&gt;  'int**' ,
+'uchar&amp;'  =&gt;  'unsigned char' ,
+'uchar'  =&gt;  'unsigned char' ,
+'uchar*' =&gt; 'unsigned char*',
+'uchar**' =&gt; 'unsigned char**',
+'uint&amp;' =&gt; 'unsigned int',
+'uint' =&gt; 'unsigned int',
+'uint*'  =&gt;  'unsigned int*' ,
+'uintf~0'  =&gt;  'unsigned int' ,
+'ulong' =&gt; 'unsigned long',
+'unsigned char&amp;' =&gt; 'unsigned char',
+'unsigned char'  =&gt;  'unsigned char' ,
+'unsigned char*'  =&gt;  'unsigned char*' ,
+'unsigned int&amp;'  =&gt;  'unsigned int' ,
+'unsigned int'  =&gt;  'unsigned int' ,
+'unsigned int*'  =&gt;  'int*' ,
+'unsigned long int' =&gt; 'long',
+'unsigned long&amp;'  =&gt;  'unsigned long' ,
+'unsigned long'  =&gt;  'unsigned long' ,
+'unsigned short int'  =&gt;  'unsigned short' ,
+'unsigned short&amp;'  =&gt;  'unsigned short' ,
+'unsigned short'  =&gt;  'unsigned short' ,
+'unsigned short*'  =&gt;  'short*' ,
+'unsigned shortint'  =&gt;  'unsigned short' ,
+'unsigned'  =&gt;  'unsigned int' ,
+'ushort' =&gt; 'unsigned short',
+'ushort*'  =&gt;  'short*' ,
+'voice*' =&gt; 'int',
+'void' =&gt; 'void',
+'void(*)()'  =&gt;  'void(*)()' ,
+'void*' =&gt; 'void*',
+'~' =&gt; '~',
+'QValueList&lt;int&gt;' =&gt; 'qt_QIntValueList*',
+'QValueList&lt;int&gt;&amp;' =&gt; 'qt_QIntValueList*',
+'QValueList&lt;QIconDragItem&gt;' =&gt; 'qt_QIconDragItemValueList*',
+'QValueList&lt;QIconDragItem&gt;&amp;' =&gt; 'qt_QIconDragItemValueList*',
+'QValueList&lt;QPixmap&gt;' =&gt; 'qt_QPixmapValueList*',
+'QValueList&lt;QString&gt;&amp;' =&gt; 'qt_QStringValueList*',
+'QValueList&lt;QVariant&gt;&amp;' =&gt; 'qt_QVariantValueList*',
+'QValueList&lt;QUrlInfo&gt;*' =&gt; 'qt_QUrlInfoValueList*',
+'QValueList&lt;KDataToolInfo&gt;&amp;' =&gt; 'kde_KDataToolInfoValueList*',
+'QPtrList&lt;QDockWindow&gt;*' =&gt; 'qt_QDockWindowPtrList*',
+'QPtrList&lt;QPixmap&gt;' =&gt; 'qt_QPixmapPtrList*',
+'QPtrList&lt;QPoint&gt;' =&gt; 'qt_QPointPtrList*',
+'ClassContext*' =&gt; 'kde_ClassContext*',
+'ClassStoreIface*' =&gt; 'kde_ClassStoreIface*',
+'ClipboardDocumentIface*' =&gt; 'kde_ClipboardDocumentIface*',
+'CodeCompletionDocumentIface*' =&gt; 'kde_CodeCompletionDocumentIface*',
+'CursorDocumentIface*' =&gt; 'kde_CursorDocumentIface*',
+'DebugDocumentIface*' =&gt; 'kde_DebugDocumentIface*',
+'DocumentInterface*' =&gt; 'kde_DocumentInterface*',
+'EditDocumentIface*' =&gt; 'kde_EditDocumentIface*',
+'EditorInterface*' =&gt; 'kde_EditorInterface*',
+'FileContext*' =&gt; 'kde_FileContext*',
+'KDevAppFrontendIface*' =&gt; 'kde_KDevAppFrontendIface*',
+'KDevCoreIface*' =&gt; 'kde_KDevCoreIface*',
+'KDevMakeFrontendIface*' =&gt; 'kde_KDevMakeFrontendIface*',
+'KEditor*' =&gt; 'kde_KEditor*',
+'KEditor::Document*' =&gt; 'kde_Document*',
+'ParsedClassContainer&amp;' =&gt; 'kde_ParsedClassContainer*',
+'ParsedContainer&amp;' =&gt; 'kde_ParsedContainer*',
+'ParsedScopeContainer&amp;' =&gt; 'kde_ParsedScopeContainer*',
+'QValueList&lt;ParsedMethod&gt;*' =&gt; 'kde_ParsedMethodList*',
+'QValueList&lt;CompletionEntry&gt;' =&gt; 'kde_CompletionEntryValueList*',
+'StatusDocumentIface*' =&gt; 'kde_StatusDocumentIface*',
+'UndoDocumentIface*' =&gt; 'kde_UndoDocumentIface*',
+'KShortcut&amp;' =&gt; 'kde_KShortcut*',
+'KShortcut' =&gt; 'kde_KShortcut*',
+'KShortcut*' =&gt; 'kde_KShortcut*',
+'KKey&amp;' =&gt; 'kde_KKey*',
+'KKey*' =&gt; 'kde_KKey*',
+'KKeyNative&amp;' =&gt; 'kde_KKeyNative*',
+'KKeyNative*' =&gt; 'kde_KKeyNative*',
+'KKeyVariations&amp;' =&gt; 'kde_KKeyVariations*',
+'KKeyVariations*' =&gt; 'kde_KKeyVariations*',
+'KKeyX11&amp;' =&gt; 'kde_KKeyX11*',
+'KKeyX11' =&gt; 'kde_KKeyX11*',
+'KKeyX11*' =&gt; 'kde_KKeyX11*',
+'KAccelActions' =&gt; 'kde_KAccelActions*',
+'KRandomSequence&amp;' =&gt; 'kde_KRandomSequence*',
+'KIcon::Context' =&gt; 'int',
+'KIcon::Group' =&gt; 'int',
+);
+
+
+  # Initialize %builtins, used by resolveType
+  my @noreflist = qw( const int char long double template 
+		    unsigned signed float void bool true false uint 
+		    uint32 uint64 extern static inline virtual operator );
+  foreach my $r ( @noreflist ) {
+     $builtins{ $r } = $r;
+  }
+
+}
+
+sub interfacemap
+{
+	my ( $interfaceType )  = @_;
+	return $interfacemap{$interfaceType};
+}
+
+sub ctypemap
+{
+	my ( $cType )  = @_;
+	return $ctypemap{$cType};
+}
+
+sub setctypemap
+{
+	my ( $cType, $cValue )  = @_;
+
+	$ctypemap{$cType} = $cValue;
+	return;
+}
+
+sub addNamespace
+{
+	my ( $className )  = @_;
+
+	if ( $className =~ /Bridge$/ ) {
+		return $className;
+	}
+
+	if ( $className =~ /^(AbstractView|Attr|CDATASection|CSSCharsetRule|CSSException|CSSFontFaceRule|CSSImportRule|CSSMediaRule|CSSPageRule|CSSPrimitiveValue|CSSRule|CSSRuleList|CSSStyleDeclaration|CSSStyleRule|CSSStyleSheet|CSSUnknownRule|CSSValue|CSSValueList|CharacterData|Comment|Counter|CustomNodeFilter|DOMException|DOMImplementation|DOMString|Document|DocumentFragment|DocumentStyle|DocumentType|DomShared|Element|Entity|EntityReference|EventException|EventListener|LinkStyle|MediaList|MutationEvent|NamedNodeMap|Node|NodeFilter|NodeIterator|NodeList|Notation|ProcessingInstruction|RGBColor|Range|RangeException|Rect|StyleSheet|StyleSheetList|Text|TreeWalker|UIEvent|HTML.*)/ )
+	{
+		return &quot;DOM::&quot;.$className;
+	}
+
+	if ( $className =~ /^(BrowserExtension|BrowserHostExtensionBrowserInterface|ComponentFactory|DockMainWindow|Event|Factory|GUIActivateEvent|HistoryProvider|MainWindow|OpenURLEvent|Part|PartActivateEvent|PartBase|PartManager|PartSelectEvent|Plugin|PluginInfo|ReadOnlyPart|ReadWritePart|URLArgs|WindowArgs)/ )
+	{
+		return &quot;KParts::&quot;.$className;
+	}
+
+	if ( $className =~ /^(AuthInfo|AutoLogin|CacheInfo|ChmodJob|Connection|CopyInfo|CopyJob|DefaultProgress|DeleteJob|FileCopyJob|Job|ListJob|MetaData|MimetypeJob|MultiGetJob|NetAccess|NetRC|PasswordDialog|PreviewJob|ProgressBase|RenameDlg|Scheduler|SessionData|SimpleJob|SkipDlg|Slave|SlaveBase|SlaveConfig|SlaveInterface|StatJob|StatusbarProgress|TCPSlaveBase|Task|TransferJob|UDSAtom)/ )
+	{
+		return &quot;KIO::&quot;.$className;
+	}
+
+	if ( $className =~ /^(DrawContentsEvent|MouseDoubleClickEvent|MouseEvent|MouseMoveEvent|MousePressEvent|MouseReleaseEvent)/ )
+	{
+		return &quot;khtml::&quot;.$className;
+	}
+
+	if ( $className =~ /^(OfferList)/ )
+	{
+		return &quot;KTrader::&quot;.$className;
+	}
+
+	if ( $className =~ /^(BlockSelectionInterface|ClipboardInterface|CodeCompletionInterface|CompletionEntry|ConfigInterface|Cursor|CursorInterface|Document|EditInterface|Editor|HighlightingInterface|Mark|MarkInterface|PopupMenuInterface|PrintInterface|SearchInterface|SelectionInterface|UndoInterface|View|ViewCursorInterface)/ )
+	{
+		return &quot;KTextEditor::&quot;.$className;
+	}
+
+
+	return $className;
+}
+
+
+# Helper for resolveType. This one is recursive and returns undef if not found.
+sub resolveTypeInternal($$$)
+{
+	my ( $argType, $contextClass, $rootnode ) = @_;
+
+	#print &quot;resolveTypeInternal type:'$argType' context:'$contextClass-&gt;{astNodeName}' ($contextClass)\n&quot;;
+
+	my $contextClassName = join( &quot;::&quot;, kdocAstUtil::heritage($contextClass) );
+
+	# 'A' resolves to 'A' in context 'A' ;)  (i.e. classname itself)
+	return $contextClassName if ( $argType eq $contextClass-&gt;{astNodeName} );
+
+	# Try as an identifier of contextClass
+	#print &quot;Trying as &quot;.$contextClassName.&quot;::&quot;.$argType.&quot;\n&quot;;
+
+	my $node = kdocAstUtil::findRef( $rootnode, $contextClassName.&quot;::&quot;.$argType );
+
+	#print &quot;Found as $node-&gt;{NodeType}\n&quot; if $node;
+
+	return $contextClassName.&quot;::&quot;.$argType if ( $node
+		 &amp;&amp; $node-&gt;{NodeType} ne 'method'
+		 &amp;&amp; $node-&gt;{NodeType} ne 'deleted'
+	         &amp;&amp; $node-&gt;{NodeType} ne 'var' );
+
+	my $found;
+
+	# Then look at ancestors, and try for each one
+	Iter::Ancestors( $contextClass, $rootnode, undef, undef,
+		   sub {
+		     my ( $ances, $name, $type, $template ) = @_;
+		     unless ($found) {
+			$found = resolveTypeInternal( $argType, $ances, $rootnode );
+		     }
+		   },
+		   undef
+		 );
+
+	return $found;
+}
+
+=head2
+
+  Look up a type, following the class hierarchy.
+  e.g. &quot;Mode&quot;, if ContextClassName is A, will be looked as A::Mode,
+  then as B::Mode (if B is a parent class of A), then as Qt::Mode,
+  then as just Mode.
+
+=cut
+
+sub resolveType($$$)
+{
+	my ( $argType, $contextClass, $rootnode ) = @_;
+	$argType =~ s/\s*(\*)\s*$/$1/g; # remove space before *
+	#print &quot;resolveType: '$argType'\n&quot;;
+
+	# Look for builtin words (int etc.)
+	return $builtins{ $argType } if exists $builtins{ $argType };
+
+        # take recursive care of templated types
+	if($argType =~ /([\w_]+\s*)&lt;(.*)&gt;/) {
+	    my $tmpl = $2;
+            my $before = $`.$1;
+            my $after = $';
+            my @args = kdocUtil::splitUnnested( ',', $tmpl);
+            grep s/^\s+//, @args;
+            grep s/\s+$//, @args;
+            for my $a(@args) {
+		$a = resolveType( $a, $contextClass, $rootnode );
+            }
+            # normalize
+	    $argType = $before.&quot;&lt;&quot;.join( &quot;, &quot;, @args).&quot;&gt;&quot;.$after;
+		$argType =~ s/&gt;&gt;/&gt; &gt;/g;  # Nested template types must have a space
+        }
+
+	# Parse 'const' in front of it, and '*' or '&amp;' after it
+	my $prefix = $argType =~ s/^const\s+// ? 'const ' : '';
+	my $suffix = $argType =~ s/\s*([\&amp;\*]+)$// ? $1 : '';
+	#print &quot;resolveType: prefix:$prefix, '$argType', suffix:$suffix\n&quot;;
+
+	# Launch the (possibly recursive) resolveTypeInternal
+	my $result = resolveTypeInternal( $argType, $contextClass, $rootnode );
+	return $prefix.$result.$suffix if $result;
+
+	# If the parent is a namespace, have a look there
+	if ($contextClass-&gt;{Parent} &amp;&amp; $contextClass-&gt;{Parent}-&gt;{NodeType} eq 'namespace') {
+		$result = resolveTypeInternal( $argType, $contextClass-&gt;{Parent}, $rootnode );
+		return $prefix.$result.$suffix if $result;
+	}
+	
+	# Not found, so look as a toplevel class
+	#print &quot;Checking that &quot;.$argType.&quot; exists.\n&quot;;
+	return $prefix.$argType.$suffix if ( kdocAstUtil::findRef( $rootnode, $argType ) );
+
+	#print &quot;resolveType: $argType not found (context $contextClass-&gt;{astNodeName})\n\n&quot;;
+
+	return $prefix.$argType.$suffix;
+}
+
+1;

Added: trunk/kalyptus/kdocAstUtil.pm
===================================================================
--- trunk/kalyptus/kdocAstUtil.pm	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/kdocAstUtil.pm	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,789 @@
+=head1 kdocAstUtil
+
+	Utilities for syntax trees.
+
+=cut
+
+
+package kdocAstUtil;
+
+use Ast;
+use Carp;
+use File::Basename;
+use kdocUtil;
+use Iter;
+use strict;
+
+use vars qw/ $depth $refcalls $refiters @noreflist %noref /;
+
+sub BEGIN {
+# statistics for findRef
+
+	$depth = 0;
+	$refcalls = 0;
+	$refiters = 0;
+
+# findRef will ignore these words
+
+	@noreflist = qw( const int char long double template 
+		unsigned signed float void bool true false uint 
+		uint32 uint64 extern static inline virtual operator );
+
+	foreach my $r ( @noreflist ) {
+		$noref{ $r } = 1;
+	}
+}
+
+
+=head2 findNodes
+
+	Parameters: outlist ref, full list ref, key, value
+
+	Find all nodes in full list that have property &quot;key=value&quot;.
+	All resulting nodes are stored in outlist.
+
+=cut
+
+sub findNodes
+{
+	my( $rOutList, $rInList, $key, $value ) = @_;
+
+	my $node;
+
+	foreach $node ( @{$rInList} ) {
+		next if !exists $node-&gt;{ $key };
+		if ( $node-&gt;{ $key } eq $value ) {
+			push @$rOutList, $node;
+		}
+	}
+}
+
+=head2 allTypes
+
+	Parameters: node list ref
+	returns: list
+
+	Returns a sorted list of all distinct &quot;NodeType&quot;s in the nodes 
+	in the list.
+
+=cut
+
+sub allTypes
+{
+	my ( $lref ) = @_;
+
+	my %types = ();
+	foreach my $node ( @{$lref} ) {
+		$types{ $node-&gt;{NodeType} } = 1;
+	}
+
+	return sort keys %types;
+}
+
+
+
+
+=head2 findRef
+
+	Parameters: root, ident, report-on-fail
+	Returns: node, or undef
+
+	Given a root node and a fully qualified identifier (:: separated),
+	this function will try to find a child of the root node that matches
+	the identifier.
+
+=cut
+
+sub findRef
+{
+	my( $root, $name, $r ) = @_;
+
+	confess &quot;findRef: no name&quot; if !defined $name || $name eq &quot;&quot;;
+
+	$name =~ s/\s+//g;	
+	return undef if exists $noref{ $name };
+
+	$name =~ s/^#//g;
+
+	my ($iter, @tree) = split /(?:\:\:|#)/, $name;
+	my $kid;
+
+	$refcalls++;
+
+	# Upward search for the first token
+	return undef if !defined $iter;
+
+	while ( !defined findIn( $root, $iter ) ) {
+		return undef if !defined $root-&gt;{Parent};
+		$root = $root-&gt;{Parent};
+	}
+	$root = $root-&gt;{KidHash}-&gt;{$iter};
+	carp if !defined $root;
+
+	# first token found, resolve the rest of the tree downwards
+	foreach $iter ( @tree ) {
+		confess &quot;iter in $name is undefined\n&quot; if !defined $iter;
+		next if $iter =~ /^\s*$/;
+
+		unless ( defined findIn( $root, $iter ) ) {
+			confess &quot;findRef: failed on '$name' at '$iter'\n&quot;
+				if defined $r;
+			return undef;
+		}
+
+		$root = $root-&gt;{KidHash}-&gt;{ $iter };	
+		carp if !defined $root;
+	}
+
+	return $root;
+}
+
+=head2 findIn
+
+	node, name: search for a child
+
+=cut
+
+sub findIn
+{
+	return undef unless defined $_[0]-&gt;{KidHash};
+
+	my $ret =  $_[0]-&gt;{KidHash}-&gt;{ $_[1] };
+
+	return $ret;
+}
+
+=head2 linkReferences
+
+	Parameters: root, node
+
+	Recursively links references in the documentation for each node
+	to real nodes if they can be found.  This should be called once
+	the entire parse tree is filled.
+
+=cut
+
+sub linkReferences
+{
+	my( $root, $node ) = @_;
+
+	if ( exists $node-&gt;{DocNode} ) {
+		linkDocRefs( $root, $node, $node-&gt;{DocNode} );
+
+		if( exists $node-&gt;{Compound} ) {
+			linkSee( $root, $node, $node-&gt;{DocNode} );
+		}
+	}
+
+	my $kids = $node-&gt;{Kids};
+	return unless defined $kids;
+
+	foreach my $kid ( @$kids ) {
+		# only continue in a leaf node if it has documentation.
+		next if !exists $kid-&gt;{Kids} &amp;&amp; !exists $kid-&gt;{DocNode};
+		if( !exists $kid-&gt;{Compound} ) {
+			linkSee( $root, $node, $kid-&gt;{DocNode} );
+		}
+		linkReferences( $root, $kid );
+	}
+}
+
+sub linkNamespaces
+{
+	my ( $node ) = @_;
+
+	if ( defined $node-&gt;{ImpNames} ) {
+		foreach my $space ( @{$node-&gt;{ImpNames}} ) {
+			my $spnode = findRef( $node, $space );
+
+			if( defined $spnode ) {
+				$node-&gt;AddPropList( &quot;ExtNames&quot;, $spnode );
+			}
+			else {
+				warn &quot;namespace not found: $space\n&quot;;
+			}
+		}
+	}
+
+	return unless defined $node-&gt;{Compound} || !defined $node-&gt;{Kids};
+
+
+	foreach my $kid ( @{$node-&gt;{Kids}} ) {
+		next unless localComp( $kid );
+
+		linkNamespaces( $kid );
+	}
+}
+
+sub calcStats
+{
+		my ( $stats, $root, $node ) = @_;
+# stats:
+# num types
+# num nested
+# num global funcs
+# num methods
+
+
+		my $type = $node-&gt;{NodeType};
+
+		if ( $node eq $root ) {
+			# global methods
+			if ( defined $node-&gt;{Kids} ) {
+				foreach my $kid ( @{$node-&gt;{Kids}} ) {
+						$stats-&gt;{Global}++ if $kid-&gt;{NodeType} eq &quot;method&quot;;
+				}
+			}
+
+			$node-&gt;AddProp( &quot;Stats&quot;, $stats );
+		}
+		elsif ( kdocAstUtil::localComp( $node ) 
+					|| $type eq &quot;enum&quot; || $type eq &quot;typedef&quot; ) {
+				$stats-&gt;{Types}++;
+				$stats-&gt;{Nested}++ if $node-&gt;{Parent} ne $root;
+		}
+		elsif( $type eq &quot;method&quot; ) {
+				$stats-&gt;{Methods}++;
+		}
+
+		return unless defined $node-&gt;{Compound} || !defined $node-&gt;{Kids};
+
+		foreach my $kid ( @{$node-&gt;{Kids}} ) {
+				next if defined $kid-&gt;{ExtSource};
+				calcStats( $stats, $root, $kid );
+		}
+}
+
+=head2 linkDocRefs
+
+	Parameters: root, node, docnode
+
+	Link references in the docs if they can be found.  This should
+	be called once the entire parse tree is filled.
+
+=cut
+
+sub linkDocRefs
+{
+	my ( $root, $node, $docNode ) = @_;
+	return unless exists $docNode-&gt;{Text};
+
+	my ($text, $ref, $item, $tosearch);
+
+	foreach $item ( @{$docNode-&gt;{Text}} ) {
+		next if $item-&gt;{NodeType} ne 'Ref';
+
+		$text = $item-&gt;{astNodeName};
+
+		if ( $text =~ /^(?:#|::)/ ) {
+			$text = $';
+			$tosearch = $node;
+		}
+		else {
+			$tosearch = $root;
+		}
+
+		$ref = findRef( $tosearch, $text );
+		$item-&gt;AddProp( 'Ref', $ref ) if defined $ref;
+
+		confess &quot;Ref failed for &quot;, $item-&gt;{astNodeName},
+		&quot;\n&quot; unless defined $ref;
+	}
+}
+
+sub linkSee
+{
+	my ( $root, $node, $docNode ) = @_;
+	return unless exists $docNode-&gt;{See};
+
+	my ( $text, $tosearch, $ref );
+
+	foreach $text ( @{$docNode-&gt;{See}} ) {
+		if ( $text =~ /^\s*(?:#|::)/ ) {
+			$text = $';
+			$tosearch = $node;
+		}
+		else {
+			$tosearch = $root;
+		}
+
+		$ref = findRef( $tosearch, $text );
+		$docNode-&gt;AddPropList( 'SeeRef', $ref )
+			if defined $ref;
+	}
+}
+
+
+
+#
+# Inheritance utilities
+#
+
+=head2 makeInherit
+
+	Parameter: $rootnode, $parentnode
+
+	Make an inheritance graph from the parse tree that begins
+	at rootnode. parentnode is the node that is the parent of
+	all base class nodes.
+
+=cut
+
+sub makeInherit
+{
+	my( $rnode, $parent ) = @_;
+
+	foreach my $node ( @{ $rnode-&gt;{Kids} } ) {
+		next if !defined $node-&gt;{Compound};
+
+		# set parent to root if no inheritance
+
+		if ( !exists $node-&gt;{InList} ) {
+			newInherit( $node, &quot;Global&quot;, $parent );
+			$parent-&gt;AddPropList( 'InBy', $node );
+
+			makeInherit( $node, $parent );
+			next;
+		}
+
+		# link each ancestor
+		my $acount = 0;
+ANITER:
+		foreach my $in ( @{ $node-&gt;{InList} } ) {
+			unless ( defined $in ) {
+				Carp::cluck &quot;warning: $node-&gt;{astNodeName} &quot;
+					.&quot; has undef in InList.&quot;;
+				next ANITER;
+			}
+
+			my $ref = kdocAstUtil::findRef( $rnode, 
+					$in-&gt;{astNodeName} );
+
+			if( !defined $ref ) {
+				# ancestor undefined
+				warn &quot;warning: &quot;, $node-&gt;{astNodeName},
+					&quot; inherits unknown class '&quot;,
+						$in-&gt;{astNodeName},&quot;'\n&quot;;
+
+				$parent-&gt;AddPropList( 'InBy', $node );
+			}
+			else {
+				# found ancestor
+				$in-&gt;AddProp( &quot;Node&quot;, $ref );
+				$ref-&gt;AddPropList( 'InBy', $node );
+				$acount++;
+			}
+		}
+
+		if ( $acount == 0 ) {
+			# inherits no known class: just parent it to global
+			newInherit( $node, &quot;Global&quot;, $parent );
+			$parent-&gt;AddPropList( 'InBy', $node );
+		}
+		makeInherit( $node, $parent );
+	}
+}
+
+=head2 newInherit
+
+	p: $node, $name, $lnode?
+
+	Add a new ancestor to $node with raw name = $name and
+	node = lnode.
+=cut
+
+sub newInherit
+{
+	my ( $node, $name, $link ) = @_;
+
+	my $n = Ast::New( $name );
+	$n-&gt;AddProp( &quot;Node&quot;, $link ) unless !defined $link;
+
+	$node-&gt;AddPropList( &quot;InList&quot;, $n );
+	return $n;
+}
+
+=head2 inheritName
+
+	pr: $inheritance node.
+
+	Returns the name of the inherited node. This checks for existence
+	of a linked node and will use the &quot;raw&quot; name if it is not found.
+
+=cut
+
+sub inheritName
+{
+	my ( $innode ) = @_;
+
+	return defined $innode-&gt;{Node} ? 
+		$innode-&gt;{Node}-&gt;{astNodeName}
+		: $innode-&gt;{astNodeName};
+}
+
+=head2 inheritedBy
+
+	Parameters: out listref, node
+
+	Recursively searches for nodes that inherit from this one, returning
+	a list of inheriting nodes in the list ref.
+
+=cut
+
+sub inheritedBy
+{
+	my ( $list, $node ) = @_;
+
+	return unless exists $node-&gt;{InBy};
+
+	foreach my $kid ( @{ $node-&gt;{InBy} } ) {
+		push @$list, $kid;
+		inheritedBy( $list, $kid );
+	}
+}
+
+=head2 inheritsAsVirtual
+
+	Parameters: (selfNode) classNode
+
+	Tells if C&lt;classNode&gt; is a virtual ancestor of C&lt;selfNode&gt;
+	e.g: $self-&gt;kdocAstUtil::inheritsAsVirtual($other)
+
+=cut
+
+sub inheritsAsVirtual
+{
+	my ( $self, $node ) = @_;
+
+	return 0 unless exists $self-&gt;{InList};
+
+	for my $in( @{ $self-&gt;{InList} } )
+	{
+	    return 1 if 
+		inheritName($in) eq $node-&gt;{astNodeName} and
+		$in-&gt;{Type} =~ /virtual/;
+	    return 1 if $in-&gt;{Node} &amp;&amp; 
+                    $in-&gt;{Node}-&gt;kdocAstUtil::inheritsAsVirtual( $node );
+	}
+	return 0
+}
+
+
+=head2 hasLocalInheritor
+
+	Parameter: node
+	Returns: 0 on fail
+
+	Checks if the node has an inheritor that is defined within the
+	current library. This is useful for drawing the class hierarchy,
+	since you don't want to display classes that have no relationship
+	with classes within this library.
+
+	NOTE: perhaps we should cache the value to reduce recursion on 
+	subsequent calls.
+
+=cut
+
+sub hasLocalInheritor
+{
+	my $node = shift;
+
+	return 0 if !exists $node-&gt;{InBy};
+
+	my $in;
+	foreach $in ( @{$node-&gt;{InBy}} ) {
+		return 1 if !exists $in-&gt;{ExtSource}
+			|| hasLocalInheritor( $in );
+	}
+
+	return 0;
+}
+
+
+
+=head2 allMembers
+
+	Parameters: hashref outlist, node, $type
+
+	Fills the outlist hashref with all the methods of outlist,
+	recursively traversing the inheritance tree.
+
+	If type is not specified, it is assumed to be &quot;method&quot;
+
+=cut
+
+sub allMembers
+{
+	my ( $outlist, $n, $type ) = @_;
+	my $in;
+	$type = &quot;method&quot; if !defined $type;
+
+	if ( exists $n-&gt;{InList} ) {
+
+		foreach $in ( @{$n-&gt;{InList}} ) {
+			next if !defined $in-&gt;{Node};
+			my $i = $in-&gt;{Node};
+
+			allMembers( $outlist, $i ) 
+				unless $i == $main::rootNode;
+		}
+	}
+
+	return unless exists $n-&gt;{Kids};
+
+	foreach $in ( @{$n-&gt;{Kids}} ) {
+		next if $in-&gt;{NodeType} ne $type;
+
+		$outlist-&gt;{ $in-&gt;{astNodeName} } = $in;
+	}
+}
+
+=head2 findOverride
+
+	Parameters: root, node, name
+
+	Looks for nodes of the same name as the parameter, in its parent
+	and the parent's ancestors. It returns a node if it finds one.
+
+=cut
+
+sub findOverride
+{
+	my ( $root, $node, $name ) = @_;
+	return undef if !exists $node-&gt;{InList};
+
+	foreach my $in ( @{$node-&gt;{InList}} ) {
+		my $n = $in-&gt;{Node};
+		next unless defined $n &amp;&amp; $n != $root &amp;&amp; exists $n-&gt;{KidHash};
+
+		my $ref  = $n-&gt;{KidHash}-&gt;{ $name };
+		
+		return $n if defined $ref &amp;&amp; $ref-&gt;{NodeType} eq &quot;method&quot;;
+
+		if ( exists $n-&gt;{InList} ) {
+			$ref = findOverride( $root, $n, $name );
+			return $ref if defined $ref;
+		}
+	}
+
+	return undef;
+}
+
+=head2 attachChild
+
+	Parameters: parent, child
+
+	Attaches child to the parent, setting Access, Kids
+	and KidHash of respective nodes.
+
+=cut
+
+sub attachChild
+{
+	my ( $parent, $child ) = @_;
+	confess &quot;Attempt to attach &quot;.$child-&gt;{astNodeName}.&quot; to an &quot;.
+		&quot;undefined parent\n&quot; if !defined $parent;
+
+	$child-&gt;AddProp( &quot;Access&quot;, $parent-&gt;{KidAccess} );
+	$child-&gt;AddProp( &quot;Parent&quot;, $parent );
+
+	$parent-&gt;AddPropList( &quot;Kids&quot;, $child );
+
+	if( !exists $parent-&gt;{KidHash} ) {
+		my $kh = Ast::New( &quot;LookupTable&quot; );
+		$parent-&gt;AddProp( &quot;KidHash&quot;, $kh );
+	}
+
+	$parent-&gt;{KidHash}-&gt;AddProp( $child-&gt;{astNodeName},
+		$child );
+}
+
+=head2 makeClassList
+
+	Parameters: node, outlist ref
+
+	fills outlist with a sorted list of all direct, non-external
+	compound children of node.
+
+=cut
+
+sub makeClassList
+{
+	my ( $rootnode, $list ) = @_;
+
+	@$list = ();
+
+	Iter::LocalCompounds( $rootnode,
+		sub { 
+				my $node = shift;
+
+				my $her = join ( &quot;::&quot;, heritage( $node ) );
+				$node-&gt;AddProp( &quot;FullName&quot;, $her );
+
+				if ( !exists $node-&gt;{DocNode}-&gt;{Internal} ||
+				     !$main::skipInternal ) {
+					push @$list, $node;
+				}
+	} );
+
+	@$list = sort { $a-&gt;{FullName} cmp $b-&gt;{FullName} } @$list;
+}
+
+#
+# Debugging utilities
+#
+
+=head2 dumpAst
+
+	Parameters: node, deep
+	Returns: none
+
+	Does a recursive dump of the node and its children.
+	If deep is set, it is used as the recursion property, otherwise
+	&quot;Kids&quot; is used.
+
+=cut
+
+sub dumpAst
+{
+	my ( $node, $deep ) = @_;
+
+	$deep = &quot;Kids&quot; if !defined $deep;
+
+	print &quot;\t&quot; x $depth, $node-&gt;{astNodeName}, 
+		&quot; (&quot;, $node-&gt;{NodeType}, &quot;)\n&quot;;
+
+	my $kid;
+
+	foreach $kid ( $node-&gt;GetProps() ) {
+		print &quot;\t&quot; x $depth, &quot;  -\t&quot;, $kid, &quot; -&gt; &quot;, $node-&gt;{$kid},&quot;\n&quot;
+			unless $kid =~ /^(astNodeName|NodeType|$deep)$/;
+	}
+	if ( exists  $node-&gt;{InList} ) {
+		print &quot;\t&quot; x $depth, &quot;  -\tAncestors -&gt; &quot;;
+		foreach my $innode ( @{$node-&gt;{InList}} ) {
+			print $innode-&gt;{astNodeName} . &quot;,&quot;;
+		}
+		print &quot;\n&quot;;
+	}
+
+	print &quot;\t&quot; x $depth, &quot;  -\n&quot; if (defined $node-&gt;{ $deep } &amp;&amp; scalar(@{$node-&gt;{ $deep }}) != 0);
+
+	$depth++;
+	foreach $kid ( @{$node-&gt;{ $deep }} ) {
+		dumpAst( $kid );
+	}
+
+	print &quot;\t&quot; x $depth, &quot;Documentation nodes:\n&quot; if defined 
+		@{ $node-&gt;{Doc}-&gt;{ &quot;Text&quot; }};
+
+	foreach $kid ( @{ $node-&gt;{Doc}-&gt;{ &quot;Text&quot; }} ) {
+		dumpAst( $kid );
+	}
+
+	$depth--;
+}
+
+=head2 testRef
+
+	Parameters: rootnode
+
+	Interactive testing of referencing system. Calling this
+	will use the readline library to allow interactive entering of
+	identifiers. If a matching node is found, its node name will be
+	printed.
+
+=cut
+
+sub testRef {
+	require Term::ReadLine;
+
+	my $rootNode = $_[ 0 ];
+
+	my $term = new Term::ReadLine 'Testing findRef';
+
+	my $OUT = $term-&gt;OUT || *STDOUT{IO};
+	my $prompt = &quot;Identifier: &quot;;
+
+	while( defined ($_ = $term-&gt;readline($prompt)) ) {
+
+		my $node = kdocAstUtil::findRef( $rootNode, $_ );
+
+		if( defined $node ) {
+			print $OUT &quot;Reference: '&quot;, $node-&gt;{astNodeName}, 
+			&quot;', Type: '&quot;, $node-&gt;{NodeType},&quot;'\n&quot;;
+		}
+		else {
+			print $OUT &quot;No reference found.\n&quot;;
+		}
+
+		$term-&gt;addhistory( $_ ) if /\S/;
+	}
+}
+
+sub printDebugStats
+{
+	print &quot;findRef: &quot;, $refcalls, &quot; calls, &quot;, 
+		$refiters, &quot; iterations.\n&quot;;
+}
+
+sub External
+{
+	return defined $_[0]-&gt;{ExtSource};
+}
+
+sub Compound
+{
+	return defined $_[0]-&gt;{Compound};
+}
+
+sub localComp
+{
+	my ( $node ) = $_[0];
+	return defined $node-&gt;{Compound} 
+		&amp;&amp; !defined $node-&gt;{ExtSource} 
+		&amp;&amp; $node-&gt;{NodeType} ne &quot;Forward&quot;;
+}
+
+sub hasDoc
+{
+	return defined $_[0]-&gt;{DocNode};
+}
+
+### Warning: this returns the list of parents, e.g. the 3 words in KParts::ReadOnlyPart::SomeEnum
+### It has nothing do to with inheritance.
+sub heritage
+{
+		my $node = shift;
+		my @heritage;
+
+		while( 1 ) {
+				push @heritage, $node-&gt;{astNodeName};
+
+				last unless defined $node-&gt;{Parent};
+				$node = $node-&gt;{Parent};
+				last unless defined $node-&gt;{Parent};
+		}
+
+		return reverse @heritage;
+}
+
+sub refHeritage
+{
+		my $node = shift;
+		my @heritage;
+
+		while( 1 ) {
+				push @heritage, $node;
+
+				last unless defined $node-&gt;{Parent};
+				$node = $node-&gt;{Parent};
+				last unless defined $node-&gt;{Parent};
+		}
+
+		return reverse @heritage;
+
+}
+
+
+1;

Added: trunk/kalyptus/kdocLib.pm
===================================================================
--- trunk/kalyptus/kdocLib.pm	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/kdocLib.pm	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,245 @@
+
+=head1 kdocLib
+
+Writes out a library file.
+
+NOTES ON THE NEW FORMAT
+
+	Stores: class name, members, hierarchy
+	node types are not stored
+
+
+	File Format Spec
+	----------------
+
+	header
+	zero or more members, each of
+		method
+		member
+		class, each of
+			inheritance
+			zero or more members
+
+
+
+	Unrecognized lines  ignored.
+
+	Sample
+	------
+
+	&lt;! KDOC Library HTML Reference File&gt;
+	&lt;VERSION=&quot;2.0&quot;&gt;
+	&lt;BASE URL=&quot;<A HREF="http://www.kde.org/API/kdecore/">http://www.kde.org/API/kdecore/</A>&quot;&gt;
+
+	&lt;C NAME=&quot;KApplication&quot; REF=&quot;KApplication.html&quot;&gt;
+		&lt;IN NAME=&quot;QObject&quot;&gt;
+		&lt;ME NAME=&quot;getConfig&quot; REF=&quot;KApplication.html#getConfig&quot;&gt;
+		&lt;M NAME=&quot;&quot; REF=&quot;&quot;&gt;
+	&lt;/C&gt;
+
+=cut
+
+package kdocLib;
+use strict;
+
+use Carp;
+use File::Path;
+use File::Basename;
+
+use Ast;
+use kdocAstUtil;
+use kdocUtil;
+
+
+use vars qw/ $exe $lib $root $plang $outputdir $docpath $url $compress /;
+
+BEGIN {
+	$exe = basename $0;
+}
+
+sub writeDoc
+{
+	( $lib, $root, $plang, $outputdir, $docpath, $url, 
+		$compress ) = @_;
+	my $outfile = &quot;$outputdir/$lib.kalyptus&quot;;
+	$url = $docpath unless defined $url;
+
+	mkpath( $outputdir ) unless -f $outputdir;
+
+	if( $compress ) {
+		open( LIB, &quot;| gzip -9 &gt; \&quot;$outfile.gz\&quot;&quot; ) 
+			|| die &quot;$exe: couldn't write to $outfile.gz\n&quot;;
+
+	}
+	else {
+		open( LIB, &quot;&gt;$outfile&quot; ) 
+			|| die &quot;$exe: couldn't write to $outfile\n&quot;;
+	}
+
+	my $libdesc = &quot;&quot;;
+	if ( defined $root-&gt;{LibDoc} ) {
+			$libdesc=&quot;&lt;LIBDESC&gt;&quot;.$root-&gt;{LibDoc}-&gt;{astNodeName}.&quot;&lt;/LIBDESC&gt;&quot;;
+	}
+	
+	print LIB&lt;&lt;LTEXT;
+&lt;! KDOC Library HTML Reference File&gt;
+&lt;VERSION=&quot;$main::Version&quot;&gt;
+&lt;BASE URL=&quot;$url&quot;&gt;
+&lt;PLANG=&quot;$plang&quot;&gt;
+&lt;LIBNAME&gt;$lib&lt;/LIBNAME&gt;
+$libdesc
+
+LTEXT
+
+	writeNode( $root, &quot;&quot; );
+	close LIB;
+}
+
+sub writeNode
+{
+	my ( $n, $prefix ) = @_;
+	return if !exists $n-&gt;{Compound};
+	return if exists $n-&gt;{Forward} &amp;&amp; !exists $n-&gt;{KidAccess};
+
+	if( $n != $root ) {
+		$prefix .= $n-&gt;{astNodeName};
+		print LIB &quot;&lt;C NAME=\&quot;&quot;, $n-&gt;{astNodeName},
+			&quot;\&quot; REF=\&quot;$prefix.html\&quot;&gt;\n&quot;;
+	}
+	else {
+		print LIB &quot;&lt;STATS&gt;\n&quot;;
+		my $stats = $root-&gt;{Stats};
+		foreach my $stat ( keys %$stats ) {
+			print LIB &quot;&lt;STAT NAME=\&quot;$stat\&quot;&gt;&quot;,
+				$stats-&gt;{$stat},&quot;&lt;/STAT&gt;\n&quot;;
+		}
+		print LIB &quot;&lt;/STATS&gt;\n&quot;;
+	}
+
+	if( exists $n-&gt;{Ancestors} ) {
+		my $in;
+		foreach $in ( @{$n-&gt;{Ancestors}} ) {
+			$in =~ s/\s+//g;
+			print LIB &quot;&lt;IN NAME=\&quot;&quot;,$in,&quot;\&quot;&gt;\n&quot;;
+		}
+	}
+
+	return if !exists $n-&gt;{Kids};
+	my $kid;
+	my $type;
+
+	foreach $kid ( @{$n-&gt;{Kids}} ) {
+		next if exists $kid-&gt;{ExtSource}
+			|| $kid-&gt;{Access} eq &quot;private&quot;;
+
+		if ( exists $kid-&gt;{Compound} ) {
+			if( $n != $root ) {
+				writeNode( $kid, $prefix.&quot;::&quot; );
+			}
+			else {
+				writeNode( $kid, &quot;&quot; );
+			}
+			next;
+		}
+
+		$type = $kid-&gt;{NodeType} eq &quot;method&quot; ? 
+			&quot;ME&quot; : &quot;M&quot;;
+
+		print LIB &quot;&lt;$type NAME=\&quot;&quot;, $kid-&gt;{astNodeName},
+			&quot;\&quot; REF=\&quot;$prefix.html#&quot;, $kid-&gt;{astNodeName}, &quot;\&quot;&gt;\n&quot;;
+	}
+
+	if( $n != $root ) {
+		print LIB &quot;&lt;/C&gt;\n&quot;;
+	}
+}
+
+sub readLibrary
+{
+	my( $rootsub, $name, $path, $relurl ) = @_;
+	$path = &quot;.&quot; unless defined $path;
+	my $real = $path.&quot;/&quot;.$name.&quot;.kalyptus&quot;;
+	my $url = &quot;.&quot;;
+	my @stack = ();
+	my $version = &quot;2.0&quot;;
+	my $new;
+	my $root = undef;
+	my $n = undef;
+	my $havecomp = -r &quot;$real.gz&quot;;
+	my $haveuncomp = -r &quot;$real&quot;;
+	
+	if ( $haveuncomp ) {
+		open( LIB, &quot;$real&quot; ) || die &quot;Can't read lib $real\n&quot;;
+	}
+
+	if( $havecomp ) {
+		if ( $haveuncomp ) {
+			warn &quot;$exe: two libs exist: $real and $real.gz. &quot;
+				.&quot;Using $real\n&quot;;
+		}
+		else {
+			open( LIB, &quot;gunzip &lt; \&quot;$real.gz\&quot;|&quot; ) 
+			|| die &quot;Can't read pipe gunzip &lt; \&quot;$real.gz\&quot;: $?\n&quot;;
+		}
+	}
+
+	while( &lt;LIB&gt; ) {
+		next if /^\s*$/;
+		if ( !/^\s*&lt;/ ) {
+			close LIB;
+			#readOldLibrary( $root, $name, $path );
+			return;
+		}
+
+		if( /&lt;VER\w+\s+([\d\.]+)&gt;/ ) {
+			# TODO: what do we do with the version number?
+			$version = $1;
+		}
+		elsif ( /&lt;BASE\s*URL\s*=\s*&quot;(.*?)&quot;/ ) {
+			$url = $1;
+			$url .= &quot;/&quot; unless $url =~ m:/$:;
+
+			my $test = kdocUtil::makeRelativePath( $relurl, $url );
+			$url = $test;
+		}
+		elsif( /&lt;PLANG\s*=\s*&quot;(.*?)&quot;&gt;/ ) {
+			$root = $rootsub-&gt;( $1 );
+			$n = $root;
+		}
+		elsif ( /&lt;C\s*NAME=&quot;(.*?)&quot;\s*REF=&quot;(.*?)&quot;\s*&gt;/  ) {
+			# class
+			$new = Ast::New( $1 );
+			$new-&gt;AddProp( &quot;NodeType&quot;, &quot;class&quot; );
+			$new-&gt;AddProp( &quot;Compound&quot;, 1 );
+			$new-&gt;AddProp( &quot;ExtSource&quot;, $name );
+
+			# already escaped at this point!
+			$new-&gt;AddProp( &quot;Ref&quot;, $url.$2 );
+
+			$root = $n = $rootsub-&gt;( &quot;CXX&quot; ) unless defined $root;
+			kdocAstUtil::attachChild( $n, $new );
+			push @stack, $n;
+			$n = $new;
+		}
+		elsif ( m#&lt;IN\s*NAME\s*=\s*&quot;(.*?)&quot;\s*&gt;# ) {
+			# ancestor
+			kdocAstUtil::newInherit( $n, $1 );
+		}
+		elsif ( m#&lt;/C&gt;# ) {
+			# end class
+			$n = pop @stack;
+		}
+		elsif ( m#&lt;(M\w*)\s+NAME=&quot;(.*?)&quot;\s+REF=&quot;(.*?)&quot;\s*&gt;# ) {
+			# member
+			$new = Ast::New( $2 );
+			$new-&gt;AddProp( &quot;NodeType&quot;, $1 eq &quot;ME&quot; ? &quot;method&quot; : &quot;var&quot; );
+			$new-&gt;AddProp( &quot;ExtSource&quot;, $name );
+			$new-&gt;AddProp( &quot;Flags&quot;, &quot;&quot; );
+			$new-&gt;AddProp( &quot;Ref&quot;, $url.$3 );
+
+			kdocAstUtil::attachChild( $n, $new );
+		}
+	}
+}
+
+1;

Added: trunk/kalyptus/kdocParseDoc.pm
===================================================================
--- trunk/kalyptus/kdocParseDoc.pm	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/kdocParseDoc.pm	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,422 @@
+package kdocParseDoc;
+
+use Ast;
+use strict;
+
+use vars qw/ $buffer $docNode %extraprops $currentProp $propType /;
+
+=head1 kdocParseDoc
+
+	Routines for parsing of javadoc comments.
+
+=head2 newDocComment
+
+	Parameters: begin (starting line of declaration)
+
+	Reads a doc comment to the end and creates a new doc node.
+
+	Read a line
+	check if it changes the current context
+		yes
+			flush old context
+			check if it is a non-text tag 
+						(ie internal/deprecated etc)
+				yes
+					reset context to text
+					set associated property
+				no
+					set the new context
+					assign text to new buffer
+		no	add to text buffer
+			continue
+	at end
+		flush anything pending.
+
+=cut
+
+sub newDocComment
+{
+	my( $text ) = @_;
+	return undef unless $text =~ m#/\*\*+#;
+
+	setType( &quot;DocText&quot;, 2 );
+	$text =~ m#/\*#; # need to do the match again, otherwise /***/ doesn't parse
+	### TODO update this method from kdoc
+	$buffer = $'; # everything after the first \*
+	$docNode = undef;
+	%extraprops = ();	# used for textprops when flushing.
+	my $finished = 0;
+	my $inbounded = 0;
+
+	if ( $buffer =~ m#\*/# ) {
+		$buffer = $`;
+		$finished = 1;
+	}
+
+PARSELOOP:
+	while ( defined $text &amp;&amp; !$finished ) {
+		# read text and remove leading junk
+		$text = main::readSourceLine();
+		next if !defined $text;
+		$text =~ s#^\s*\*(?!\/)##;
+
+#		if ( $text =~ /^\s*&lt;\/pre&gt;/i ) {
+#			flushProp();
+#			$inbounded = 0;
+#		}
+		if( $inbounded ) {
+			if ( $text =~ m#\*/# ) {
+				$finished = 1;
+				$text = $`;
+			}
+			$buffer .= $text;
+			next PARSELOOP;
+		}
+#		elsif ( $text =~ /^\s*&lt;pre&gt;/i ) {
+#			textProp( &quot;Pre&quot; );
+#			$inbounded = 1;
+#		}
+		elsif ( $text =~ /^\s*$/ ) {
+			textProp( &quot;ParaBreak&quot;, &quot;\n&quot; );
+		}
+		elsif ( $text =~ /^\s*\@internal\s*/ ) {
+			codeProp( &quot;Internal&quot;, 1 );
+		}
+		elsif ( $text =~ /^\s*\@deprecated\s*/ ) {
+			codeProp( &quot;Deprecated&quot;, 1 );
+		}
+		elsif ( $text =~ /^\s*\@obsolete\s*/ ) {
+			codeProp( &quot;Deprecated&quot;, 1 );
+		}
+		elsif ( $text =~ /^\s*\@reimplemented\s*/ ) {
+			codeProp( &quot;Reimplemented&quot;, 1 );
+		}
+		elsif ( $text =~ /^\s*\@group\s*/ ) {
+			# logical group tag in which this node belongs
+			# multiples allowed
+
+			my $groups = $';
+			$groups =~ s/^\s*(.*?)\s*$/$1/;
+
+			if ( $groups ne &quot;&quot; ) {
+				foreach my $g ( split( /[^_\w]+/, $groups) ) {
+
+					codeProp( &quot;InGroup&quot;, $g );
+				}
+			}
+		}
+		elsif ( $text =~ /^\s*\@defgroup\s+(\w+)\s*/ ) {
+			# parse group tag and description
+			my $grptag = $1;
+			my $grpdesc = $' eq &quot;&quot; ? $grptag : $';
+			
+			# create group node
+			my $grpnode = Ast::New( $grptag );
+			$grpnode-&gt;AddProp( &quot;Desc&quot;, $grpdesc );
+			$grpnode-&gt;AddProp( &quot;NodeType&quot;, &quot;GroupDef&quot; );
+
+			# attach
+			codeProp( &quot;Groups&quot;, $grpnode );
+		}
+		elsif ( $text =~ /^\s*\@see\s*/ ) {
+			docListProp( &quot;See&quot; );
+		}
+		elsif( $text =~ /^\s*\@short\s*/ ) {
+			docProp( &quot;ClassShort&quot; );
+		}
+		elsif( $text =~ /^\s*\@author\s*/ ) {
+			docProp( &quot;Author&quot; );
+
+		}
+		elsif( $text =~ /^\s*\@version\s*/ ) {
+			docProp( &quot;Version&quot; );
+		}
+		elsif( $text =~ /^\s*\@id\s*/ ) {
+
+			docProp( &quot;Id&quot; );
+		}
+		elsif( $text =~ /^\s*\@since\s*/ ) {
+			docProp( &quot;Since&quot; );
+		}
+		elsif( $text =~ /^\s*\@returns?\s*/ ) {
+			docProp( &quot;Returns&quot; );
+		}
+		elsif( $text =~ /^\s*\@(?:throws|exception|raises)\s*/ ) {
+			docListProp( &quot;Throws&quot; );
+		}
+		elsif( $text =~ /^\s*\@image\s+([^\s]+)\s*/ ) {
+			textProp( &quot;Image&quot; );
+			$extraprops{ &quot;Path&quot; } = $1;
+		}
+		elsif( $text =~ /^\s*\@param\s+(\w+)\s*/ ) {
+			textProp( &quot;Param&quot; );
+			$extraprops{ &quot;Name&quot; } = $1;
+		}
+		elsif( $text =~ /^\s*\@sect\s+/ ) {
+
+			textProp( &quot;DocSection&quot; );
+		}
+		elsif( $text =~ /^\s*\@li\s+/ ) {
+
+			textProp( &quot;ListItem&quot; );
+		}
+		elsif ( $text =~ /^\s*\@libdoc\s+/ ) {
+			# Defines the text for the entire library
+			docProp( &quot;LibDoc&quot; );
+		}
+		else {
+			if ( $text =~ m#\*/# ) {
+				$finished = 1;
+				$text = $`;
+			}
+			$buffer .= $text;
+		}
+	}
+
+	flushProp();
+
+
+	return undef if !defined $docNode;
+
+# postprocess docnode
+
+	# add a . to the end of the short if required.
+	my $short = $docNode-&gt;{ClassShort};
+
+	if ( defined $short ) {
+		if ( !($short =~ /\.\s*$/) ) {
+			$docNode-&gt;{ClassShort} =~ s/\s*$/./;
+		}
+	}
+	else {
+		# use first line of normal text as short name.
+		if ( defined $docNode-&gt;{Text} ) {
+			my $node;
+			foreach $node ( @{$docNode-&gt;{Text}} ) {
+				next if $node-&gt;{NodeType} ne &quot;DocText&quot;;
+				$short = $node-&gt;{astNodeName};
+				$short = $`.&quot;.&quot; if $short =~ /\./;
+				$docNode-&gt;{ClassShort} = $short;
+				goto shortdone;
+			}
+		}
+	}
+shortdone:
+
+# Join and break all word list props so that they are one string per list 
+# node, ie remove all commas and spaces.
+
+	recombineOnWords( $docNode, &quot;See&quot; );
+	recombineOnWords( $docNode, &quot;Throws&quot; );
+
+	return $docNode;
+}
+
+=head3 setType
+
+	Parameters: propname, proptype ( 0 = single, 1 = list, 2 = text )
+
+	Set the name and type of the pending property.
+
+=cut
+
+sub setType
+{
+	( $currentProp, $propType ) = @_;
+}
+
+=head3 flushProp
+
+	Flush any pending item and reset the buffer. type is set to DocText.
+
+=cut
+
+sub flushProp
+{
+	return if $buffer eq &quot;&quot;;
+	initDocNode() unless defined $docNode;
+
+	if( $propType == 1 ) {
+		# list prop
+		$docNode-&gt;AddPropList( $currentProp, $buffer );
+	}
+	elsif ( $propType == 2 ) {
+		# text prop
+		my $textnode = Ast::New( $buffer );
+		$textnode-&gt;AddProp( 'NodeType', $currentProp );
+		$docNode-&gt;AddPropList( 'Text', $textnode );
+		
+		foreach my $prop ( keys %extraprops ) {
+			$textnode-&gt;AddProp( $prop, 
+				$extraprops{ $prop } );
+		}
+
+		%extraprops = ();
+	}
+	else {
+		# one-off prop
+		$docNode-&gt;AddProp( $currentProp, $buffer );
+	}
+
+	# reset buffer
+	$buffer = &quot;&quot;;
+	setType( &quot;DocText&quot;, 2 );
+}
+
+=head3 codeProp
+
+	Flush the last node, add a new property and reset type to DocText.
+
+=cut
+
+sub codeProp
+{
+	my( $prop, $val ) = @_;
+
+	flushProp();
+
+	initDocNode() unless defined $docNode;
+	$docNode-&gt;AddPropList( $prop, $val );
+	
+	setType( &quot;DocText&quot;, 2 );
+
+}
+
+=head3 docListProp
+
+	The next item is a list property of docNode.
+
+=cut
+
+sub docListProp
+{
+	my( $prop ) = @_;
+
+	flushProp();
+
+	$buffer = $';
+	setType( $prop, 1 );
+}
+
+=head3 docProp
+
+	The next item is a simple property of docNode.
+
+=cut
+
+sub docProp
+{
+	my( $prop ) = @_;
+	
+	flushProp();
+
+	$buffer = $';
+	setType( $prop, 0 );
+}
+
+=head3 textProp
+
+	Parameters: prop, val
+
+	Set next item to be a 'Text' list node. if val is assigned, the
+	new node is assigned that text and flushed immediately. If this
+	is the case, the next item is given the 'DocText' text property.
+
+=cut
+
+sub textProp
+{
+	my( $prop, $val ) = @_;
+
+	flushProp();
+
+	if ( defined $val ) {
+		$buffer = $val;
+		setType( $prop, 2 );
+		flushProp();
+		$prop = &quot;DocText&quot;;
+	}
+
+	setType( $prop, 2 );
+	$buffer = $';
+}
+
+
+=head3 initDocNode
+
+	Creates docNode if it is not defined.
+
+=cut
+
+sub initDocNode
+{
+	$docNode = Ast::New( &quot;Doc&quot; );
+	$docNode-&gt;AddProp( &quot;NodeType&quot;, &quot;DocNode&quot; );
+}
+
+sub recombineOnWords
+{
+	my ( $docNode, $prop ) = @_;
+
+	if ( exists $docNode-&gt;{$prop} ) {
+		my @oldsee = @{$docNode-&gt;{$prop}};
+		@{$docNode-&gt;{$prop}} = split (/[\s,]+/, join( &quot; &quot;, @oldsee ));
+	}
+}
+
+###############
+
+=head2 attachDoc
+
+Connects a docnode to a code node, setting any other properties
+if required, such as groups, internal/deprecated flags etc.
+
+=cut
+
+sub attachDoc
+{
+	my ( $node, $doc, $rootnode ) = @_;
+
+	$node-&gt;AddProp( &quot;DocNode&quot;, $doc );
+	$node-&gt;AddProp( &quot;Internal&quot;, 1 ) if defined $doc-&gt;{Internal};
+	$node-&gt;AddProp( &quot;Deprecated&quot;, 1 ) if defined $doc-&gt;{Deprecated};
+
+	# attach group definitions if they exist
+	if ( defined $doc-&gt;{Groups} ) {
+		my $groupdef = $rootnode-&gt;{Groups};
+		if( !defined $groupdef ) {
+			$groupdef = Ast::New( &quot;Groups&quot; );
+			$rootnode-&gt;AddProp( &quot;Groups&quot;, $groupdef );
+		}
+
+		foreach my $grp ( @{$doc-&gt;{Groups}} ) {
+			if ( defined $groupdef-&gt;{ $grp-&gt;{astNodeName} } ) {
+				$groupdef-&gt;{ $grp-&gt;{ astNodeName}
+				}-&gt;AddProp( &quot;Desc&quot;, $grp-&gt;{Desc} );
+			}
+			else {
+				$groupdef-&gt;AddProp( $grp-&gt;{astNodeName}, $grp );
+			}
+		}
+	}
+
+	# attach node to group index(es)
+	# create groups if not found, they may be parsed later.
+
+	if ( defined $doc-&gt;{InGroup} ) {
+		my $groupdef = $rootnode-&gt;{Groups};
+
+		foreach my $grp ( @{$doc-&gt;{InGroup}} ) {
+			if ( !exists $groupdef-&gt;{$grp} ) {
+				my $newgrp = Ast::New( $grp );
+				$newgrp-&gt;AddProp( &quot;Desc&quot;, $grp );
+				$newgrp-&gt;AddProp( &quot;NodeType&quot;, &quot;GroupDef&quot; );
+				$groupdef-&gt;AddProp( $grp, $newgrp );
+			}
+
+			$groupdef-&gt;{$grp}-&gt;AddPropList( &quot;Kids&quot;, $node );
+		}
+	}
+}
+
+1;

Added: trunk/kalyptus/kdocUtil.pm
===================================================================
--- trunk/kalyptus/kdocUtil.pm	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/kdocUtil.pm	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,194 @@
+
+package kdocUtil;
+
+use strict;
+
+
+=head1 kdocUtil
+
+	General utilities.
+
+=head2 countReg
+
+	Parameters: string, regexp
+
+	Returns the number of times of regexp occurs in string.
+
+=cut
+
+sub countReg
+{
+	my( $str, $regexp ) = @_;
+	my( $count ) = 0;
+
+	while( $str =~ /$regexp/s ) {
+		$count++;
+		
+		$str =~ s/$regexp//s;
+	}
+
+	return $count;
+}
+
+=head2 findCommonPrefix
+
+	Parameters: string, string
+
+	Returns the prefix common to both strings. An empty string
+	is returned if the strings have no common prefix.
+
+=cut
+
+sub findCommonPrefix
+{
+	my @s1 = split( &quot;/&quot;, $_[0] );
+	my @s2 = split( &quot;/&quot;, $_[1] );
+	my $accum = &quot;&quot;;
+	my $len = ($#s2 &gt; $#s1 ) ? $#s1 : $#s2;
+
+	for my $i ( 0..$len ) {
+#		print &quot;Compare: $i '$s1[$i]', '$s2[$i]'\n&quot;;
+		last if $s1[ $i ] ne $s2[ $i ];
+		$accum .= $s1[ $i ].&quot;/&quot;;
+	}
+
+	return $accum;
+}
+
+=head2 makeRelativePath
+
+	Parameters: localpath, destpath
+	
+	Returns a relative path to the destination from the local path,
+	after removal of any common prefix.
+
+=cut
+
+sub makeRelativePath
+{
+	my ( $from, $to ) = @_;
+
+	# remove prefix
+	$from .= '/' unless $from =~ m#/$#;
+	$to .= '/' unless $to =~ m#/$#;
+
+	my $pfx = findCommonPrefix( $from, $to );
+
+	if ( $pfx ne &quot;&quot; ) {
+		$from =~ s/^$pfx//g;
+		$to =~ s/^$pfx//g;
+	}
+#	print &quot;Prefix is '$pfx'\n&quot;;
+	
+	$from =~ s#/+#/#g;
+	$to =~ s#/+#/#g;
+	$pfx = countReg( $from, '\/' );
+
+	my $rel = &quot;../&quot; x $pfx;
+	$rel .= $to;
+
+	return $rel;
+}
+
+sub hostName
+{
+	my $host = &quot;&quot;;
+	my @hostenvs = qw( HOST HOSTNAME COMPUTERNAME );
+
+	# Host name
+	foreach my $evar ( @hostenvs ) {
+			next unless defined $ENV{ $evar };
+
+			$host = $ENV{ $evar };
+			last;
+	}
+
+	if( $host eq &quot;&quot; ) {
+			$host = `uname -n`;
+			chop $host;
+	}
+
+	return $host;
+}
+
+sub userName
+{
+	my $who = &quot;&quot;;
+	my @userenvs = qw( USERNAME USER LOGNAME );
+
+	# User name
+	foreach my $evar ( @userenvs ) {
+			next unless defined $ENV{ $evar };
+
+			$who = $ENV{ $evar };
+			last;
+	}
+
+	if( $who eq &quot;&quot; ) {
+		if ( $who = `whoami` ) {
+				chop $who;
+		}
+		elsif ( $who - `who am i` ) {
+				$who = ( split (/ /, $who ) )[0];
+		}
+	}
+
+	return $who;
+}
+
+=head2 splitUnnested
+	Helper to split a list using a delimiter, but looking for
+	nesting with (), {}, [] and &lt;&gt;.
+        Example: splitting   int a, QPair&lt;c,b&gt; d, e=&quot;,&quot;
+	on ',' will give 3 items in the list.
+
+	Parameter: delimiter, string
+	Returns: array, after splitting the string
+
+	Thanks to Ashley Winters
+=cut
+sub splitUnnested($$) {
+    my $delim = shift;
+    my $string = shift;
+    my(%open) = (
+        '[' =&gt; ']',
+        '(' =&gt; ')',
+        '&lt;' =&gt; '&gt;',
+        '{' =&gt; '}',
+    );
+    my(%close) = reverse %open;
+    my @ret;
+    my $depth = 0;
+    my $start = 0;
+    my $indoublequotes = 0;
+    my $insinglequotes = 0;
+    while($string =~ /($delim|&lt;&lt;|&gt;&gt;|[][}{)(&gt;&lt;\&quot;\'])/g) {
+        my $c = $1;
+	if(!$insinglequotes and !$indoublequotes) {
+            if(!$depth and $c eq $delim) {
+                my $len = pos($string) - $start - 1;
+                push @ret, substr($string, $start, $len);
+                $start = pos($string);
+	    } elsif( $c eq &quot;'&quot;) {
+		$insinglequotes = 1;
+            } elsif( $c eq '&quot;') {
+		$indoublequotes = 1;
+            } elsif($open{$c}) {
+                $depth++;
+            } elsif($close{$c}) {
+                $depth--;
+            }
+	} elsif($c eq '&quot;' and $indoublequotes) {
+		$indoublequotes = 0;
+	} elsif ($c eq &quot;'&quot; and $insinglequotes) {
+		$insinglequotes = 0;
+	} 
+    }
+
+    my $subs = substr($string, $start);
+    push @ret, $subs if ($subs);
+    return @ret;
+}
+
+1;
+

Added: trunk/kalyptus/perlbin
===================================================================
--- trunk/kalyptus/perlbin	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/kalyptus/perlbin	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1 @@
+/usr/bin/perl

Added: trunk/smoke/Makefile.am
===================================================================
--- trunk/smoke/Makefile.am	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/Makefile.am	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,3 @@
+SUBDIRS = $(kde_build_libsmoke)
+
+include_HEADERS = smoke.h

Added: trunk/smoke/Makefile.in
===================================================================
--- trunk/smoke/Makefile.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/Makefile.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,45 @@
+# Makefile.in generated by unsermake
+####################################
+
+top_builddir = ..
+top_srcdir = @top_srcdir@
+srcdir = @srcdir@
+.FORWARDS: all install install-data install-exec clean check force-reedit
+
+all:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake all
+
+install:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake install
+
+install-data:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake install-data
+
+install-exec:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake install-exec
+
+clean:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake clean
+
+check:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake check
+
+force-reedit:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake force-reedit
+
+$(top_builddir)/smoke/Makefile: $(top_builddir)/config.status $(top_srcdir)/smoke/Makefile.in
+	cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status smoke/Makefile
+
+all: $(top_builddir)/smoke/Makefile
+final: 
+	@echo no programs available to recreate as final. Call in subdirs
+
+__um_includes_string.h = smoke.h
+.PHONY: all final

Added: trunk/smoke/README
===================================================================
--- trunk/smoke/README	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/README	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,21 @@
+SMOKE stands for &quot;Scripting Meta Object Kompiler Engine&quot; - for instance ;)
+
+This directory compiles a smokeqt (and later a smokekde) library, which
+contain interfaces to (almost) all Qt and KDE classes.
+The next PerlQt/PerlKDE will be based on SMOKE.
+However SMOKE is language-independent enough for other bindings (e.g. to
+other scripting languages) to be based on it.
+
+Note that the .cpp source files are auto-generated by kalyptus, from reading
+the Qt/KDE headers.
+
+
+Regenerating
+============
+
+For SmokeQt:
+ cd qt
+ ./qtguess.pl
+ ./generate.pl
+ make
+

Added: trunk/smoke/configure.in.in
===================================================================
--- trunk/smoke/configure.in.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/configure.in.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,9 @@
+AC_ARG_WITH(
+   smoke,
+   [  --with-smoke@&lt;:@=qt|kde@:&gt;@   Smoke: build Smoke for qt+kde or qt only @&lt;:@default:qt kde@:&gt;@],
+   [ kde_build_libsmoke=&quot;$withval&quot; ],
+   [ kde_build_libsmoke=&quot;qt kde&quot; ]
+)
+AC_SUBST(kde_build_libsmoke)
+
+

Added: trunk/smoke/kde/Makefile.am
===================================================================
--- trunk/smoke/kde/Makefile.am	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/kde/Makefile.am	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,24 @@
+lib_LTLIBRARIES = libsmokekde.la
+
+# set the include path for X, qt and KDE
+INCLUDES         = -I$(srcdir)/.. $(all_includes)
+
+EXTRA_DIST=generate.pl.in qtguess.pl.in qt_smoke.h Makefile.am
+
+# the library search path. 
+libsmokekde_la_LDFLAGS = -version-info 3:3:2 -no-undefined $(all_libraries) $(GLINC) $(KDE_RPATH)
+
+# the libraries to link against.
+libsmokekde_la_LIBADD   = $(LIB_KHTML) -lkjs -lfontconfig $(LIB_KMDI) $(LIB_KNS) $(LIB_KSPELL) $(LIB_KUTILS) $(LIB_KDEPRINT) $(GLLIB)
+
+x_sources =  x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+   x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+   x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp
+
+# which sources should be compiled for perlqtkde
+libsmokekde_la_SOURCES = smokedata.cpp $(x_sources)
+
+$(x_sources): smokedata.cpp
+
+smokedata.cpp:
+	perl generate.pl

Added: trunk/smoke/kde/Makefile.in
===================================================================
--- trunk/smoke/kde/Makefile.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/kde/Makefile.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,51 @@
+# Makefile.in generated by unsermake
+####################################
+
+top_builddir = ../..
+top_srcdir = @top_srcdir@
+srcdir = @srcdir@
+.FORWARDS: all install install-data install-exec clean check force-reedit
+
+all:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake all
+
+install:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake install
+
+install-data:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake install-data
+
+install-exec:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake install-exec
+
+clean:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake clean
+
+check:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake check
+
+force-reedit:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake force-reedit
+
+$(top_builddir)/smoke/kde/Makefile: $(top_builddir)/config.status $(top_srcdir)/smoke/kde/Makefile.in
+	cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status smoke/kde/Makefile
+
+$(top_builddir)/smoke/kde/generate.pl: $(top_builddir)/config.status $(srcdir)/generate.pl.in
+		cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status smoke/kde/generate.pl
+
+$(top_builddir)/smoke/kde/qtguess.pl: $(top_builddir)/config.status $(srcdir)/qtguess.pl.in
+		cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status smoke/kde/qtguess.pl
+
+all: $(top_builddir)/smoke/kde/Makefile
+final: 
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake -C $(top_builddir)/smoke/kde UNSERMAKE_FORCE_FINAL=1 libsmokekde.la
+
+INCLUDES = -I$(top_srcdir)/smoke/kde/.. $(all_includes)
+.PHONY: all final

Added: trunk/smoke/kde/configure.in.in
===================================================================
--- trunk/smoke/kde/configure.in.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/kde/configure.in.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,23 @@
+
+AC_HAVE_GL
+KDE_HAVE_GL=yes;
+if test &quot;X$GLLIB&quot; = &quot;X&quot;; then
+    KDE_HAVE_GL=no
+fi
+
+AC_SUBST(KDE_HAVE_GL)   
+
+KDE_PREFIX=`$KDECONFIG --prefix --expandvars`
+AC_SUBST(KDE_PREFIX)
+
+if test &quot;X$kde_build_libsmoke&quot; = &quot;Xkde&quot; -o &quot;X$kde_build_libsmoke&quot; = &quot;Xqt kde&quot;; then
+
+    AC_CONFIG_FILES([ smoke/kde/qtguess.pl ], [
+        cd smoke/kde
+        perl qtguess.pl
+        cd ../..
+    ])
+    AC_CONFIG_FILES([ smoke/kde/generate.pl ], [
+    ])
+fi
+

Added: trunk/smoke/kde/generate.pl.in
===================================================================
--- trunk/smoke/kde/generate.pl.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/kde/generate.pl.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,229 @@
+#!/usr/bin/perl -w
+
+## Run this first, to generate the x_*.cpp files from the Qt headers
+## using kalyptus
+
+my $kalyptusdir = &quot;@srcdir@/../../kalyptus&quot;;
+
+use File::Basename;
+use File::Copy qw|cp|;
+use File::Compare;
+use File::Find;
+use Cwd;
+
+my $here = getcwd;
+my $outdir = $here . &quot;/generate.pl.tmpdir&quot;;
+my $finaloutdir = $here;
+my $defines = &quot;qtdefines&quot;;
+my $headerlist = &quot;@srcdir@/header_list&quot;;
+my $kdeheaderlist = &quot;@srcdir@/kde_header_list&quot;;
+my $definespath = &quot;$here/$defines&quot;;
+my $headerlistpath = &quot;$here/$headerlist&quot;;
+my $kdeheaderlistpath = &quot;$here/$kdeheaderlist&quot;;
+
+# If srcdir != builddir, then srcdir is probvably an absolute
+# path, and it makes no sense to prepend $here.
+$definespath = $defines if $defines =~ /^\//;
+$headerlistpath = $headerlist if $headerlist =~ /^\//;
+$kdeheaderlistpath = $kdeheaderlist if $kdeheaderlist =~ /^\//;
+
+## Note: outdir and finaloutdir should NOT be the same dir!
+
+# Delete all x_*.cpp files under outdir (or create outdir if nonexistent)
+if (-d $outdir) { system &quot;rm -f $outdir/x_*.cpp&quot;; } else { mkdir $outdir; }
+
+mkdir $finaloutdir unless (-d $finaloutdir);
+
+#  Load the QT_NO_* macros found in &quot;qtdefines&quot;. They'll be passed to kalyptus
+my $macros=&quot;&quot;;
+if ( -e $definespath ){
+    print &quot;Found '$defines'. Reading preprocessor symbols from there...\n&quot;;
+    $macros = &quot; --defines=$definespath &quot;;
+}
+
+# Need to cd to kalyptus's directory so that perl finds Ast.pm etc.
+chdir &quot;$kalyptusdir&quot; or die &quot;Couldn't go to $kalyptusdir (edit script to change dir)\n&quot;;
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %excludes = (
+    'qaccessible.h' =&gt; 1,  # Accessibility support is not compiled by defaut
+    'qassistantclient.h' =&gt; 1, # Not part of Qt (introduced in Qt-3.1)
+    'qmotif.h' =&gt; 1,       # 
+    'qmotifwidget.h' =&gt; 1, # Motif extension (introduced in Qt-3.1)
+    'qmotifdialog.h' =&gt; 1, #
+    'qxt.h' =&gt; 1, # Xt
+    'qxtwidget.h' =&gt; 1, # Xt
+    'qdns.h' =&gt; 1, # internal
+    'qgl.h' =&gt; 1, # OpenGL
+    'qglcolormap.h' =&gt; 1, # OpenGL
+    'qnp.h' =&gt; 1, # NSPlugin
+    'qttableview.h' =&gt; 1,  # Not in Qt anymore...
+    'qtmultilineedit.h' =&gt; 1,  # Not in Qt anymore...
+    'qwidgetfactory.h' =&gt; 1,  # Just an interface
+    'qsharedmemory.h' =&gt; 1, # &quot;not part of the Qt API&quot; they say
+    'qwindowsstyle.h' =&gt; 1, # Qt windowsstyle, plugin
+    'qmotifstyle.h' =&gt; 1,
+    'qcompactstyle.h' =&gt; 1,
+    'qinterlacestyle.h' =&gt; 1,
+    'qmotifplusstyle.h' =&gt; 1,
+    'qsgistyle.h' =&gt; 1,
+    'qplatinumstyle.h' =&gt; 1,
+    'qcdestyle.h' =&gt; 1,
+    'qwindowsxpstyle.h' =&gt; 1 # play on the safe side 
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %includes;
+open(HEADERS, $headerlistpath) or die &quot;Couldn't open $headerlistpath: $!\n&quot;;
+map { chomp ; $includes{$_} = 1 unless /^\s*#/ } &lt;HEADERS&gt;;
+close HEADERS;
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %kdeexcludes = (
+#   These headers don't look suitable for inclusion:
+	'kallocator.h' =&gt; 1,
+	'kbookmarkimporter_crash.h' =&gt; 1,
+	'kbookmarkimporter_ie.h' =&gt; 1,
+	'kbookmarkimporter_opera.h' =&gt; 1,
+	'kbookmarkimporter_ns.h' =&gt; 1,
+	'kcrash.h' =&gt; 1,
+	'kdebug.h' =&gt; 1,
+	'kdebugclasses.h' =&gt; 1,
+	'kde_terminal_interface.h' =&gt; 1,
+	'kdirnotify_stub.h' =&gt; 1,
+
+#	These headers currently give problems
+	'kscreensaver.h' =&gt; 1,
+	'kdirnotify_stub.h' =&gt; 1,
+	'kio/uiserver_stub.h' =&gt; 1,
+	'kio/uiserver.h' =&gt; 1,
+	'kio/kdesasl.h' =&gt; 1,
+	'kio/kpac.h' =&gt; 1,
+	'kio/thumbcreator.h' =&gt; 1,
+	'kio/file.h' =&gt; 1,
+	'kio/chmodjob.h' =&gt; 1,
+	'kparts/genericfactory.h' =&gt; 1,
+	'kparts/pluginselectormodule.h' =&gt; 1,
+	'kopenssl.h' =&gt; 1,
+	'kautomount.h' =&gt; 1,
+	'kimagefilepreview.h' =&gt; 1,
+	'kpropertiesdialog.h' =&gt; 1,
+	'knotifydialog.h' =&gt; 1,
+	'ksockaddr.h' =&gt; 1,
+	'knotifywidgetbase.h' =&gt; 1,
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %kdeincludes;
+open(HEADERS, $kdeheaderlistpath) or die &quot;Couldn't open $kdeheaderlistpath: $!\n&quot;;
+map { chomp ; $kdeincludes{$_} = 1 unless /^\s*#/ } &lt;HEADERS&gt;;
+close HEADERS;
+
+# Can we compile the OpenGl module ?
+if(&quot;@KDE_HAVE_GL@&quot; eq &quot;yes&quot;)
+{
+    open(DEFS, $definespath);
+    my @defs = &lt;DEFS&gt;;
+    close DEFS;
+    if(!grep(/QT_NO_OPENGL/, @defs))
+    {
+      $excludes{'qgl.h'} = undef;
+      $excludes{'qglcolormap.h'} = undef;
+    }
+    else
+    {
+      print STDERR &quot;Qt was not compiled with OpenGL support...\n Skipping QGL Classes.\n&quot;;
+    }
+}
+
+# List Qt headers, and exclude the ones listed above
+my @headers = ();
+
+$qtinc= '@qt_includes@';
+opendir (QT, $qtinc) or die &quot;Couldn't find $qtinc&quot;;
+foreach $filename (readdir(QT)) {
+    $entry = $qtinc.&quot;/&quot;.$filename;
+    if ( ( -e $entry or -l $entry )         # A real file or a symlink
+        &amp;&amp; ( ! -d _ ) )                     # Not a symlink to a dir though
+    {
+        push(@headers, $entry)
+          if ( !defined $excludes{$filename} # Not excluded
+              &amp;&amp; $includes{$filename}        # Known header
+	      &amp;&amp; $filename =~ /\.h$/ ); # Not a backup file etc. Only headers.
+        undef $includes{$filename}
+    }
+}
+closedir QT;
+
+my @kdeheaders = ();
+$kdeprefix = &quot;@KDE_PREFIX@&quot;;
+$kdeinc= '@kde_includes@';
+$kdeinc =~ s/\${prefix}/$kdeprefix/; # Remove ${prefix} in src != build
+-d $kdeinc or die &quot;Couldn't process $kdeinc: $!\n&quot;;
+
+find(
+    {   wanted =&gt; sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $kdeinc);
+                push ( @kdeheaders, $_ )
+	    	  if( !defined $kdeexcludes{$f} # Not excluded
+	    	     &amp;&amp; $kdeincludes{$f}        # Known header
+	    	     &amp;&amp; /\.h$/);     # Not a backup file etc. Only headers.
+	    	undef $kdeincludes{$f}   
+	     };
+	},
+	follow_fast =&gt; 1,
+	follow_skip =&gt; 2,
+	no_chdir =&gt; 1
+    }, $kdeinc
+ );
+
+# Launch kalyptus
+system &quot;perl kalyptus @ARGV --globspace -fsmoke --name=qt $macros --no-cache --allow_k_dcop_accessors --outputdir=$outdir @headers @kdeheaders&quot;;
+my $exit = $? &gt;&gt; 8;
+exit $exit if ($exit);
+
+# Generate diff for smokedata.cpp
+unless ( -e &quot;$finaloutdir/smokedata.cpp&quot; ) {
+    open( TOUCH, &quot;&gt;$finaloutdir/smokedata.cpp&quot;);
+    close TOUCH;
+}
+system &quot;diff -u $finaloutdir/smokedata.cpp $outdir/smokedata.cpp &gt; $outdir/smokedata.cpp.diff&quot;;
+
+# Copy changed or new files to finaloutdir
+opendir (OUT, $outdir) or die &quot;Couldn't opendir $outdir&quot;;
+foreach $filename (readdir(OUT)) {
+    next if ( -d &quot;$outdir/$filename&quot; ); # only files, not dirs
+    my $docopy = 1;
+    if ( -f &quot;$finaloutdir/$filename&quot; ) {
+        $docopy = compare(&quot;$outdir/$filename&quot;, &quot;$finaloutdir/$filename&quot;); # 1 if files are differents
+    }
+    if ($docopy) {
+	#print STDERR &quot;Updating $filename...\n&quot;;
+	cp(&quot;$outdir/$filename&quot;, &quot;$finaloutdir/$filename&quot;);
+    }
+}
+closedir OUT;
+
+# Check for deleted files and warn
+my $deleted = 0;
+opendir(FINALOUT, $finaloutdir) or die &quot;Couldn't opendir $finaloutdir&quot;;
+foreach $filename (readdir(FINALOUT)) {
+    next if ( -d &quot;$finaloutdir/$filename&quot; ); # only files, not dirs
+    if ( $filename =~ /.cpp$/ &amp;&amp; ! ($filename =~ /_la_closure.cpp/) &amp;&amp; ! -f &quot;$outdir/$filename&quot; ) {
+      print STDERR &quot;Removing obsolete file $filename\n&quot;;
+      unlink &quot;$finaloutdir/$filename&quot;;
+      $deleted = 1;
+    }
+}
+closedir FINALOUT;
+
+# Delete outdir
+system &quot;rm -rf $outdir&quot;;
+

Added: trunk/smoke/kde/generate_makefile_am.pl
===================================================================
--- trunk/smoke/kde/generate_makefile_am.pl	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/kde/generate_makefile_am.pl	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,55 @@
+#!/usr/bin/perl -w
+
+use File::Basename;
+
+my $here = `pwd`;
+chomp $here;
+my $outdir = $here;
+my $tempfile = &quot;$outdir/.Makefile.am.tmpfile&quot;;
+
+# Update list of source files in $outdir/Makefile.am
+open( MAKEFILE, &quot;&lt;$outdir/Makefile.am&quot; ) or die;
+my $makeFileData = '';
+my $found = 0;
+while (&lt;MAKEFILE&gt;) {
+	if (/^libsmokeqt_la_SOURCES/)
+	{
+		$found = 1;
+		$makeFileData .= &quot;libsmokeqt_la_SOURCES = smokedata.cpp&quot;;
+	}
+	$makeFileData .= $_ if (!$found);
+}
+close MAKEFILE;
+
+die &quot;libsmokeqt_la_SOURCES not found&quot; if (!$found);
+
+open( MAKEFILE, &quot;&gt;$tempfile&quot; ) or die;
+print MAKEFILE $makeFileData;
+
+my $count = 0;
+opendir (FILES, $outdir) or die;
+foreach $filename (readdir(FILES)) {
+	if ( $filename =~ /^x_.*\.cpp$/ ) {
+		if ( $count++ == 7 ) {
+			$count = 0;
+			print MAKEFILE &quot; \\\n&quot;;
+		}
+		print MAKEFILE &quot; $filename&quot;;
+	}
+}
+
+print MAKEFILE &quot;\n&quot;;
+close MAKEFILE;
+closedir FILES;
+
+system &quot;cmp -s $tempfile $outdir/Makefile.am&quot;;
+if ($? &gt;&gt; 8) {
+    system &quot;cp -f $tempfile $outdir/Makefile.am&quot;;
+    print STDERR &quot;Makefile.am updated.\n&quot;;
+}
+else {
+    print STDERR &quot;Makefile.am unchanged.\n&quot;;
+}
+system &quot;rm -f $tempfile&quot;;
+
+exit 0;


Property changes on: trunk/smoke/kde/generate_makefile_am.pl
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/smoke/kde/header_list
===================================================================
--- trunk/smoke/kde/header_list	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/kde/header_list	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,351 @@
+q1xcompatibility.h
+qabstractlayout.h
+qaccel.h
+qaccessible.h
+qaction.h
+qapp.h
+qapplication.h
+qarray.h
+qasciicache.h
+qasciidict.h
+qassistantclient.h
+qasyncimageio.h
+qasyncio.h
+qbig5codec.h
+qbitarray.h
+qbitarry.h
+qbitmap.h
+qbrush.h
+qbttngrp.h
+qbuffer.h
+qbuttongroup.h
+qbutton.h
+qcache.h
+qcanvas.h
+qcdestyle.h
+qcheckbox.h
+qchkbox.h
+qcleanuphandler.h
+qclipboard.h
+qclipbrd.h
+qcollect.h
+qcollection.h
+qcolordialog.h
+qcolor.h
+qcombobox.h
+qcombo.h
+qcommonstyle.h
+qcompactstyle.h
+qconfig-dist.h
+qconfig.h
+qconnect.h
+qconnection.h
+qcstring.h
+qcursor.h
+qdatabrowser.h
+qdatastream.h
+qdatatable.h
+qdataview.h
+qdatetimeedit.h
+qdatetime.h
+qdatetm.h
+qdeepcopy.h
+qdesktopwidget.h
+qdial.h
+qdialog.h
+qdict.h
+qdir.h
+qdns.h
+qdockarea.h
+qdockwindow.h
+qdom.h
+qdragobject.h
+qdrawutil.h
+qdrawutl.h
+qdropsite.h
+qdstream.h
+qeditorfactory.h
+qerrormessage.h
+qeucjpcodec.h
+qeuckrcodec.h
+qevent.h
+qeventloop.h
+qfeatures.h
+qfiledef.h
+qfiledialog.h
+qfiledlg.h
+qfile.h
+qfileinf.h
+qfileinfo.h
+qfocusdata.h
+qfontdatabase.h
+qfontdialog.h
+qfontdta.h
+qfont.h
+qfontinf.h
+qfontinfo.h
+qfontmet.h
+qfontmetrics.h
+qframe.h
+qftp.h
+qgarray.h
+qgb18030codec.h
+qgbkcodec.h
+qgcache.h
+qgdict.h
+qgeneric.h
+qgif.h
+qglcolormap.h
+qgl.h
+qglist.h
+qglobal.h
+qgplugin.h
+qgrid.h
+qgridview.h
+qgroupbox.h
+qgrpbox.h
+qguardedptr.h
+qgvector.h
+qhbox.h
+qhbuttongroup.h
+qheader.h
+qhgroupbox.h
+qhostaddress.h
+qhttp.h
+qiconset.h
+qiconview.h
+qimageformatplugin.h
+qimage.h
+qinputdialog.h
+qintcache.h
+qintcach.h
+qintdict.h
+qinterlacestyle.h
+qiodev.h
+qiodevice.h
+qjiscodec.h
+qjpunicode.h
+qkeycode.h
+qkeysequence.h
+qlabel.h
+qlayout.h
+qlcdnumber.h
+qlcdnum.h
+qlocale.h
+qlibrary.h
+qlined.h
+qlineedit.h
+qlistbox.h
+qlist.h
+qlistview.h
+qlocalfs.h
+qmainwindow.h
+qmap.h
+qmemarray.h
+qmenubar.h
+qmenudata.h
+qmenudta.h
+qmessagebox.h
+qmetaobject.h
+qmetaobj.h
+qmime.h
+qmlined.h
+qmodules.h
+qmotifdialog.h
+qmotif.h
+qmotifplusstyle.h
+qmotifstyle.h
+qmotifwidget.h
+qmovie.h
+qmsgbox.h
+qmultilinedit.h
+qmultilineedit.h
+qmutex.h
+qnamespace.h
+qnetwork.h
+qnetworkprotocol.h
+qobjcoll.h
+qobjdefs.h
+qobjectcleanuphandler.h
+qobjectdefs.h
+qobjectdict.h
+qobject.h
+qobjectlist.h
+qpaintdc.h
+qpaintdevicedefs.h
+qpaintdevice.h
+qpaintdevicemetrics.h
+qpaintd.h
+qpainter.h
+qpair.h
+qpalette.h
+qpdevmet.h
+qpen.h
+qpicture.h
+qpixmapcache.h
+qpixmap.h
+qplatinumstyle.h
+qpmcache.h
+qpntarry.h
+qpointarray.h
+qpoint.h
+qpolygonscanner.h
+qpopmenu.h
+qpopupmenu.h
+qprintdialog.h
+qprinter.h
+qprndlg.h
+qprocess.h
+qprogbar.h
+qprogdlg.h
+qprogressbar.h
+qprogressdialog.h
+qpsprn.h
+qptrcollection.h
+qptrdict.h
+qptrlist.h
+qptrqueue.h
+qptrstack.h
+qptrvector.h
+qpushbt.h
+qpushbutton.h
+qqueue.h
+qradiobt.h
+qradiobutton.h
+qrangecontrol.h
+qrangect.h
+qrect.h
+qregexp.h
+qregion.h
+qremotefactory.h
+qremoteplugin.h
+qrtlcodec.h
+qscopedptr.h
+qscrbar.h
+qscrollbar.h
+qscrollview.h
+qsemaphore.h
+qsemimodal.h
+qserversocket.h
+qsession.h
+qsessionmanager.h
+qsettings.h
+qsgistyle.h
+qshared.h
+qsignal.h
+qsignalmapper.h
+qsignalslotimp.h
+qsimplerichtext.h
+qsizegrip.h
+qsize.h
+qsizepolicy.h
+qsjiscodec.h
+qslider.h
+qsocketdevice.h
+qsocket.h
+qsocketnotifier.h
+qsocknot.h
+qsortedlist.h
+qsound.h
+qspinbox.h
+qsplashscreen.h
+qsplitter.h
+qsqlcursor.h
+qsqldatabase.h
+qsqldriver.h
+qsqldriverplugin.h
+qsqleditorfactory.h
+qsqlerror.h
+qsqlfield.h
+qsqlform.h
+qsql.h
+qsqlindex.h
+qsqlpropertymap.h
+qsqlquery.h
+qsqlrecord.h
+qsqlresult.h
+qsqlselectcursor.h
+qstack.h
+qstatusbar.h
+qstring.h
+qstringlist.h
+qstrlist.h
+qstrvec.h
+qstylefactory.h
+qstyle.h
+qstyleplugin.h
+qstylesheet.h
+qsyntaxhighlighter.h
+qtabbar.h
+qtabdialog.h
+qtabdlg.h
+qtable.h
+qtabwidget.h
+qtextbrowser.h
+qtextcodecfactory.h
+qtextcodec.h
+qtextcodecplugin.h
+qtextedit.h
+qtextstream.h
+qtextview.h
+qt.h
+qthread.h
+qtimer.h
+qtl.h
+qtmultilineedit.h
+qtoolbar.h
+qtoolbutton.h
+qtoolbox.h
+qtooltip.h
+qtranslator.h
+qtsciicodec.h
+qtstream.h
+qttableview.h
+qurl.h
+qurlinfo.h
+qurloperator.h
+qutfcodec.h
+quuid.h
+qvalidator.h
+qvaluelist.h
+qvaluestack.h
+qvaluevector.h
+qvariant.h
+qvbox.h
+qvbuttongroup.h
+qvector.h
+qvgroupbox.h
+qwaitcondition.h
+qwhatsthis.h
+qwidcoll.h
+qwidgetfactory.h
+qwidget.h
+qwidgetintdict.h
+qwidgetlist.h
+qwidgetplugin.h
+qwidgetstack.h
+qwindefs.h
+qwindowdefs.h
+qwindow.h
+qwindowsstyle.h
+qwizard.h
+qwmatrix.h
+qworkspace.h
+qwsbeosdecoration_qws.h
+qwscommand_qws.h
+qwscursor_qws.h
+qwsdecoration_qws.h
+qwsdefaultdecoration_qws.h
+qwsdisplay_qws.h
+qwsevent_qws.h
+qwshydrodecoration_qws.h
+qwskde2decoration_qws.h
+qwskdedecoration_qws.h
+qwsmanager_qws.h
+qwsmouse_qws.h
+qwsproperty_qws.h
+qwsregionmanager_qws.h
+qwssocket_qws.h
+qwsutils_qws.h
+qwswindowsdecoration_qws.h
+qxml.h

Added: trunk/smoke/kde/hint_header_list.pl
===================================================================
--- trunk/smoke/kde/hint_header_list.pl	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/kde/hint_header_list.pl	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,23 @@
+
+# CVS admin : run this script to compare the set of Qt headers to
+#             the actual content of header_list
+
+$l = &quot;header_list&quot;;
+$q = $ENV{'QTDIR'} || die &quot;QTDIR not set\n&quot;;
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at h</A> = &lt;$q/include/*.h&gt;;
+grep s|.*/(.*\.h)|$1|, @h;
+open(IN, $l) or die &quot;$!: $l\n&quot;;
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at old</A> = &lt;IN&gt;;
+chomp @old;
+map{ $h{$_}++ } @h;
+map{ $old{$_}++ } @old;
+map{ $diff{$_}++ unless $old{$_} } keys %h; 
+map{ delete $diff{$_} if /^qconfig.*/ or !/^q/ } keys %diff;
+print &quot;Check if any of the following headers should be added to $l:\n\n&quot;;
+print join &quot;\n&quot;, keys %diff,  &quot;\n&quot;
+
+
+
+
+
+

Added: trunk/smoke/kde/kde_header_list
===================================================================
--- trunk/smoke/kde/kde_header_list	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/kde/kde_header_list	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,439 @@
+dcopclient.h
+dcopobject.h
+dcopref.h
+dom/css_rule.h
+dom/css_stylesheet.h
+dom/css_value.h
+dom/dom2_events.h
+dom/dom2_range.h
+dom/dom2_traversal.h
+dom/dom2_views.h
+dom/dom_core.h
+dom/dom_doc.h
+dom/dom_element.h
+dom/dom_exception.h
+dom/dom_html.h
+dom/dom_misc.h
+dom/dom_node.h
+dom/dom_string.h
+dom/dom_text.h
+dom/dom_xml.h
+dom/html_base.h
+dom/html_block.h
+dom/html_document.h
+dom/html_element.h
+dom/html_form.h
+dom/html_head.h
+dom/html_image.h
+dom/html_inline.h
+dom/html_list.h
+dom/html_misc.h
+dom/html_object.h
+dom/html_table.h
+kaboutapplication.h
+kaboutdata.h
+kaboutdialog.h
+kaboutkde.h
+kaccelgen.h
+kaccel.h
+kaccelmanager.h
+kactionclasses.h
+kactioncollection.h
+kaction.h
+kactionshortcutlist.h
+kactivelabel.h
+kallocator.h
+kanimwidget.h
+kapp.h
+kapplication.h
+karchive.h
+kar.h
+karrowbutton.h
+kasyncio.h
+kaudioplayer.h
+kauthicon.h
+kautomount.h
+kbookmarkbar.h
+kbookmarkdombuilder.h
+kbookmarkdrag.h
+kbookmarkexporter.h
+kbookmark.h
+kbookmarkimporter_crash.h
+kbookmarkimporter.h
+kbookmarkimporter_ie.h
+kbookmarkimporter_kde1.h
+kbookmarkimporter_ns.h
+kbookmarkimporter_opera.h
+kbookmarkmanager.h
+kbookmarkmenu.h
+kbookmarknotifier.h
+kbufferedio.h
+kbugreport.h
+kbuttonbox.h
+kcalendarsystemfactory.h
+kcalendarsystem.h
+kcatalogue.h
+kcharselect.h
+kcharsets.h
+kclipboard.h
+kcmdlineargs.h
+kcmenumngr.h
+kcmodule.h
+kcmoduleinfo.h
+kcmoduleloader.h
+kcmultidialog.h
+kcolorbtn.h
+kcolorbutton.h
+kcolorcombo.h
+kcolordialog.h
+kcolordlg.h
+kcolordrag.h
+kcombiview.h
+kcombobox.h
+kcommand.h
+kcompletionbox.h
+kcompletion.h
+kconfigdialog.h
+kconfigskeleton.h
+kconfigbackend.h
+kconfigbase.h
+kconfigdata.h
+kconfig.h
+kcpuinfo.h
+kcrash.h
+kcursor.h
+kcustommenueditor.h
+kdatastream.h
+kdatatool.h
+kdatepicker.h
+kdatepik.h
+kdatetbl.h
+kdatetimewidget.h
+kdatewidget.h
+kdcopactionproxy.h
+kdcoppropertyproxy.h
+kdcopservicestarter.h
+kdebugclasses.h
+kdebug.h
+kdedmodule.h
+kdesktopfile.h
+kde_terminal_interface.h
+kdeversion.h
+kdialogbase.h
+kdialog.h
+kdirlister.h
+kdirnotify.h
+kdirnotify_stub.h
+kdiroperator.h
+kdirselectdialog.h
+kdirsize.h
+kdirwatch.h
+kdiskfreesp.h
+kdockwidget.h
+kdockwindow.h
+kdrawutil.h
+kdualcolorbtn.h
+kdualcolorbutton.h
+keditcl.h
+keditlistbox.h
+kedittoolbar.h
+kemailsettings.h
+kextendedsocket.h
+kextsock.h
+kfiledetailview.h
+kfiledialog.h
+kfilefiltercombo.h
+kfilefilter.h
+kfile.h
+kfileiconview.h
+kfileitem.h
+kfilemetainfo.h
+kfilepreview.h
+kfilesharedlg.h
+kfileshare.h
+kfiletreebranch.h
+kfiletreeview.h
+kfiletreeviewitem.h
+kfileview.h
+kfilterbase.h
+kfilterdev.h
+kfinddialog.h
+kfind.h
+kfontcombo.h
+kfontdialog.h
+kfontrequester.h
+kgenericfactory.h
+kglobalaccel.h
+kglobal.h
+kglobalsettings.h
+kguiitem.h
+khelpmenu.h
+khtmldefaults.h
+khtml_events.h
+khtml_part.h
+khtml_settings.h
+khtmlview.h
+kicondialog.h
+kiconeffect.h
+kiconloader.h
+kicontheme.h
+kiconview.h
+kidna.h
+kimageeffect.h
+kimagefilepreview.h
+kimageio.h
+kinputdialog.h
+kinstance.h
+kipc.h
+kjanuswidget.h
+kkeybutton.h
+kkeydialog.h
+kkeynative.h
+klargefile.h
+kled.h
+klibloader.h
+klineeditdlg.h
+klineedit.h
+klistbox.h
+klistview.h
+klistviewsearchline.h
+klocale.h
+kmacroexpander.h
+kmainwindow.h
+kmainwindowiface.h
+kmanagerselection.h
+kmdcodec.h
+kmdichildarea.h
+kmdichildfrmcaption.h
+kmdichildfrm.h
+kmdichildview.h
+kmdidefines.h
+kmdiiterator.h
+kmdilistiterator.h
+kmdimainfrm.h
+kmdinulliterator.h
+kmditaskbar.h
+kmditoolviewaccessor.h
+kmenubar.h
+kmessagebox.h
+kmimemagic.h
+kmimesourcefactory.h
+kmimetype.h
+kmimetyperesolver.h
+kmountpoint.h
+kmultipledrag.h
+kmultitabbar.h
+knotifyclient.h
+knotifydialog.h
+knuminput.h
+knumvalidator.h
+kopenssl.h
+kopenwith.h
+kpalette.h
+kpanelapplet.h
+kpanelappmenu.h
+kpanelextension.h
+kpanelmenu.h
+kpassdlg.h
+kpassivepopup.h
+kpixmapeffect.h
+kpixmap.h
+kpixmapio.h
+kpixmapprovider.h
+kpixmapsplitter.h
+kpluginselector.h
+kplugininfo.h
+kpopupmenu.h
+kpreferencesdialog.h
+kpreferencesmodule.h
+kpreviewwidgetbase.h
+kprintaction.h
+kprinter.h
+kdeprint/kpreloadobject.h
+kprocctrl.h
+kprocess.h
+kprocio.h
+kprogress.h
+kpropertiesdialog.h
+kpropsdlg.h
+kprotocolinfo.h
+kprotocolmanager.h
+kpty.h
+kpushbutton.h
+krandomsequence.h
+krecentdocument.h
+kregexpeditorinterface.h
+kregexp.h
+kreplacedialog.h
+kreplace.h
+krestrictedline.h
+krfcdate.h
+krootpixmap.h
+krootprop.h
+kruler.h
+krun.h
+ksavefile.h
+kscan.h
+ksconfig.h
+kscreensaver.h
+kscreensaver_vroot.h
+kselect.h
+kseparator.h
+kservicegroup.h
+kservice.h
+kservicetype.h
+ksharedpixmap.h
+ksharedptr.h
+kshellcompletion.h
+kshell.h
+kshortcut.h
+kshortcutlist.h
+kshred.h
+ksimpleconfig.h
+ksmimecrypto.h
+ksockaddr.h
+ksock.h
+ksocks.h
+ksortablevaluelist.h
+kspelldlg.h
+kspell.h
+ksqueezedtextlabel.h
+ksslall.h
+ksslcertchain.h
+ksslcertdlg.h
+ksslcertificatecache.h
+ksslcertificatefactory.h
+ksslcertificate.h
+ksslcertificatehome.h
+ksslconfig.h
+ksslconnectioninfo.h
+kssl.h
+ksslinfodlg.h
+ksslkeygen.h
+ksslpeerinfo.h
+ksslpemcallback.h
+ksslpkcs12.h
+ksslpkcs7.h
+ksslsession.h
+ksslsettings.h
+ksslsigners.h
+ksslutils.h
+ksslx509map.h
+ksslx509v3.h
+kstandarddirs.h
+kstartupinfo.h
+kstaticdeleter.h
+kstatusbar.h
+kstdaccel.h
+kstdaction.h
+kstddirs.h
+kstdguiitem.h
+kstringhandler.h
+kstringvalidator.h
+kstyle.h
+ksycocaentry.h
+ksycoca.h
+ksycocatype.h
+ksyntaxhighlighter.h
+ksystemtray.h
+ktabbar.h
+ktabctl.h
+ktabwidget.h
+ktar.h
+ktempdir.h
+ktempfile.h
+ktextbrowser.h
+ktextedit.h
+ktimewidget.h
+ktip.h
+ktoolbarbutton.h
+ktoolbar.h
+ktoolbarradiogroup.h
+ktrader.h
+ktypelist.h
+kuniqueapp.h
+kuniqueapplication.h
+kunload.h
+kurifilter.h
+kurlbar.h
+kurlcombobox.h
+kurlcompletion.h
+kurldrag.h
+kurl.h
+kurllabel.h
+kurlpixmapprovider.h
+kurlrequesterdlg.h
+kurlrequester.h
+kuserprofile.h
+kvmallocator.h
+kwindowinfo.h
+kwindowlistmenu.h
+kwin.h
+kwinmodule.h
+kwizard.h
+kwordwrap.h
+kxmessages.h
+kxmlguibuilder.h
+kxmlguiclient.h
+kxmlguifactory.h
+kxmlgui.h
+kzip.h
+kparts/browserextension.h
+kparts/browserinterface.h
+kparts/browserrun.h
+kparts/componentfactory.h
+kparts/dockmainwindow.h
+kparts/event.h
+kparts/factory.h
+kparts/genericfactory.h
+kparts/historyprovider.h
+kparts/mainwindow.h
+kparts/part.h
+kparts/partmanager.h
+kparts/plugin.h
+kparts/pluginselectormodule.h
+kparts/statusbarextension.h
+kio/authinfo.h
+kio/chmodjob.h
+kio/connection.h
+kio/davjob.h
+kio/defaultprogress.h
+kio/file.h
+kio/global.h
+kio/http.h
+kio/http_slave_defaults.h
+kio/ioslave_defaults.h
+kio/jobclasses.h
+kio/job.h
+kio/kdesasl.h
+kio/kmdbase.h
+kio/kmdcodec.h
+kio/kpac.h
+kio/metainfojob.h
+kio/netaccess.h
+kio/observer.h
+kio/passdlg.h
+kio/paste.h
+kio/previewjob.h
+kio/progressbase.h
+kio/renamedlg.h
+kio/scheduler.h
+kio/sessiondata.h
+kio/skipdlg.h
+kio/slavebase.h
+kio/slaveconfig.h
+kio/slave.h
+kio/slaveinterface.h
+kio/statusbarprogress.h
+kio/tcpslavebase.h
+kio/thumbcreator.h
+kio/uiserver.h
+kio/uiserver_stub.h
+netwm_def.h
+netwm.h
+knewstuff/knewstuff.h
+knewstuff/knewstuffsecure.h
+knewstuff/engine.h
+knewstuff/entry.h
+knewstuff/provider.h
+

Added: trunk/smoke/kde/qt_smoke.h
===================================================================
--- trunk/smoke/kde/qt_smoke.h	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/kde/qt_smoke.h	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,9 @@
+#ifndef QT_SMOKE_H
+#define QT_SMOKE_H
+
+// Defined in smokedata.cpp, initialized by init_qt_Smoke(), used by all .cpp files
+extern Smoke* qt_Smoke;
+
+class QGlobalSpace { };
+
+#endif

Added: trunk/smoke/kde/qtguess.pl.in
===================================================================
--- trunk/smoke/kde/qtguess.pl.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/kde/qtguess.pl.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,502 @@
+#!/usr/bin/perl
+
+# qtguess.pl : check how Qt was compiled. Issue a list of all defined QT_NO_* macros, one per line.
+#
+# author:  germain Garand &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">germain at ebooksfrance.com</A>&gt;
+# licence: GPL v.2
+
+# options: -q: be quieter
+#	   -o file: redirect output to &quot;file&quot;. (default: ./qtdefines)
+#	   -t [0..15]: set the testing threshold (see below)
+#	   -f &quot;flags&quot;: additional compiler flags/parameters
+
+use Getopt::Std;
+
+use vars qw/$opt_f $opt_o $opt_p/;
+
+getopts('qo:f:t:');
+
+# Threshold :
+#	 0 - test basic Qt types/classes
+#	 5 - test higher level, non-gui classes
+#	 8 - test options of the above (ex: QT_NO_IMAGE_SMOOTHSCALE)
+#	10 - test basic widgets
+#	12 - test composite widgets
+#	13 - test widgets inheriting composite widgets
+#	15 - test goodies (default)
+
+my $default_threshold = @qt_test_threshold@;
+my $cc = &quot;@CXX@&quot;;
+my $ccflags = $opt_f || &quot;@CXXFLAGS@&quot;;
+
+my $nspaces = 50;
+
+my %qtdefs=();
+my %qtundefs=();
+
+my $tmp = gettmpfile();
+my $qtinc = '@qt_includes@';
+my $allinc = '@all_includes@';
+my $alllib = '@all_libraries@';
+my $qtflags ='@LIB_QT@';
+my %x;
+$x{'LIBPNG'}  =   '@LIBPNG@';
+$x{'LIBJPEG'} =   '@LIBJPEG@';
+$x{'LIBSM'}   =   '@LIBSM@';
+$x{'LIBSOCKET'} = '@LIBSOCKET@';
+$x{'LIBDL'}      = '@LIBDL@';
+$x{'LIBRESOLV'}  = '@LIBRESOLV@';
+$x{'LIB_X11'} =   '@LIB_X11@';
+$x{'X_PRE_LIBS'} = '@X_PRE_LIBS@';
+$x{'LIB_X11'} =~ s/\$\((.*?)\)/$x{$1}/g;
+
+$qtflags =~ s/\$\((.*?)\)/$x{$1}/g;
+
+ -e &quot;$qtinc/QtCore/qglobal.h&quot; or die &quot;Invalid Qt include directory.\n&quot;;
+
+my $ccmd = &quot;$cc $ccflags $allinc $alllib -o $tmp $tmp.cpp $qtflags&quot;;
+
+my $threshold = defined($opt_t)?$opt_t : $default_threshold;
+$threshold &gt;= 0 or die &quot;invalid testing threshold: $threshold\n&quot;;
+
+print &quot;Checking how Qt was built... \n&quot;;
+print &quot;Threshold is set to $threshold\n&quot; unless $opt_q;
+
+my($count, $used, $total);
+map{ $tests{$_}-&gt;[2]&gt;=$threshold ? ($used++, $total++):$total++ } keys %tests;
+
+print &quot;Number of defines to be tested : $used/$total\n\n&quot; unless $opt_q;
+open( QTDEFS, &quot;&gt;&quot;.($opt_o || &quot;qtdefines&quot;) ) or die &quot;Can't open output file: $!\n&quot;;
+
+grab_qglobal_symbols();
+preliminary_test();
+perform_all_tests();
+
+print +scalar(keys %qtdefs) . &quot; defines found.\n&quot;;
+
+print QTDEFS join(&quot;\n&quot;, keys %qtdefs), &quot;\n&quot;;
+close;
+
+#--------------------------------------------------------------#
+
+sub gettmpfile
+{
+	my $tmpdir = $ENV{'TMP'} || &quot;.&quot;;
+	my $tmpname = $$.&quot;-qtguess&quot;;
+	while( -e &quot;$tmpdir/$tmpname&quot; || -e &quot;$tmpdir/${tmpname}.cpp&quot; )
+	{
+		$tmpname .= int (rand * 9);
+	}
+	return &quot;$tmpdir/$tmpname&quot;;
+}
+
+#--------------------------------------------------------------#
+
+sub grab_qglobal_symbols
+{
+	my $cmd = &quot;$cc -E -D__cplusplus -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2&gt;/dev/null&quot;;
+	my $symbols = `$cmd`;
+        for(0..1)
+        {
+	    if( check_exit_status($?) )
+	    {
+		while( $symbols =~/^#\s*define\s*(QT_\S+)/gm )
+		{
+			$qtdefs{$1} = 1;
+		}
+		print &quot;Found &quot;. scalar( keys %qtdefs ).&quot; predefined symbol&quot;.((scalar( keys %qtdefs ) -1)?&quot;s&quot;:&quot;&quot;).&quot; in qglobal.h\n&quot; unless ($opt_q or !(keys %qtdefs));
+		while( $symbols =~/^#\s*define\s*QT_MODULE_(\S+)/gm )
+		{
+			$qtundefs{&quot;QT_NO_$1&quot;} = 1;
+		}
+		print &quot;Found &quot;. scalar( keys %qtundefs ).&quot; undefined symbol&quot;.((scalar( keys %qtundefs ) -1)?&quot;s&quot;:&quot;&quot;).&quot; in qglobal.h\n&quot; unless ($opt_q or !(keys %qtundefs));
+                last;
+	    }
+	    elsif(! $_) # first try
+	    {
+		print  &quot;Failed to run $cmd.\nTrying without __cplusplus (might be already defined)\n&quot;;
+                $cmd = &quot;$cc -E -dM -I$qtinc $qtinc/qglobal.h 2&gt;/dev/null&quot;;
+                $symbols = `$cmd`;
+                next;
+	    }
+        }
+}
+
+#--------------------------------------------------------------#
+
+sub preliminary_test
+{
+	my $msg = &quot;Trying to compile and link a small program...&quot;;
+	print $msg, &quot; &quot; x ($nspaces - length($msg) + 8);
+	open( OUT, &quot;&gt;${tmp}.cpp&quot; ) or die &quot;Failed to open temp file ${tmp}.cpp: $!\n&quot;;
+	my $simple=q&#163;
+		#include &lt;qapplication.h&gt;
+		int main( int argc, char **argv )
+		{
+			QApplication foo( argc, argv );
+			return 0;
+		}
+	&#163;;
+	print OUT $simple;
+	close OUT;
+        my $out = `$ccmd 2&gt;&amp;1`;
+	if( !check_exit_status($?) )
+	{
+		die &lt;&lt;&quot;EOF&quot;;
+
+FAILED : check your configuration.
+Failed program was:
+$simple
+Compiled with:
+$ccmd
+Compiler output:
+$out
+EOF
+	}
+	else
+	{
+		print &quot;OK\n&quot;;
+	}
+}
+
+#--------------------------------------------------------------#
+
+sub perform_all_tests
+{
+	foreach ( sort { $tests{$a}-&gt;[2] &lt;=&gt; $tests{$b}-&gt;[2]} keys %tests)
+	{
+		$tests{$_}-&gt;[2] &lt; $threshold and next;
+		($qtdefs{$_} || $qtundefs{$_}) and do
+		{
+			print &quot;\rSkipping $_ (in qglobal.h)&quot;.( &quot; &quot; x (($nspaces-16) - length($_)) ).($qtundefs{$_}?&quot;*Undefined*&quot;:&quot; [Defined]&quot;).($opt_q?&quot;&quot;:&quot;\n&quot;);
+			next
+		};
+		print &quot;\rTesting $_&quot;.( &quot; &quot; x ($nspaces - length($_)) );
+		open( OUT, &quot;&gt;${tmp}.cpp&quot; ) or die &quot;Failed to open temp file ${tmp}.cpp: $!\n&quot;;
+		foreach $def(keys %qtdefs)
+		{
+			print OUT &quot;#define $def\n&quot;;
+		}
+		foreach $inc(split /,\s*/, $tests{$_}-&gt;[0])
+		{
+			print OUT &quot;#include &lt;$inc&gt;\n&quot;;
+		}
+		print OUT &quot;#include &lt;qfeatures.h&gt;\n&quot;;
+		print OUT $tests{$_}-&gt;[3] if $tests{$_}-&gt;[3]; # need to define some classes ?
+		print OUT qq&#163;
+
+		int main( int argc, char **argv )
+		{
+		$tests{$_}-&gt;[1]
+		return 0;
+		}
+		&#163;;
+		close OUT;
+
+                my $out = `$ccmd 2&gt;&amp;1`;
+
+		my $ok = check_exit_status($?);
+		if( !$ok )
+		{
+			$qtdefs{$_} = 1;
+		}
+		print +$opt_q ? ++$count.&quot;/$used&quot; : ( $ok ? &quot;*Undefined*\n&quot; : &quot; [Defined]\n&quot; );
+	}
+	$opt_q &amp;&amp; print &quot;\n&quot;;
+}
+
+#--------------------------------------------------------------#
+
+sub check_exit_status
+{
+	my $a = 0xFFFF &amp; shift;
+	if( !$a )
+	{
+		return 1;
+	}
+	elsif( $a == 0xFF00 )
+	{
+		die &quot;\nSystem call failed: $!\n&quot;;
+	}
+	elsif( $a &gt; 0x80 )
+	{
+		# non-zero status.
+	}
+	else
+	{
+		if( $a &amp; 0x80 )
+		{
+			die &quot;\n$cc coredumped with signal &quot;. ($a &amp; ~0x80);
+		}
+		die &quot;\n$cc interrupted by signal $a\n&quot;;
+	}
+	return 0;
+}
+
+#--------------------------------------------------------------#
+
+END
+{
+	unlink $tmp if -e $tmp;
+	unlink &quot;${tmp}.cpp&quot; if -e &quot;${tmp}.cpp&quot;;
+}
+
+#--------------------------------------------------------------#
+
+BEGIN {
+
+# &quot;DEFINE&quot; =&gt; [&quot;header-1.h,... header-n.h&quot;, &quot;main() code&quot;, priority, &quot;Definitions (if needed)&quot;]
+
+our %tests = (
+	&quot;QT_NO_ACCEL&quot; =&gt; 		[&quot;qaccel.h&quot;, &quot;QAccel foo( (QWidget*)NULL );&quot;, 5],
+	&quot;QT_NO_ACCESSIBILITY&quot; =&gt;        [&quot;qaccessible.h&quot;, &quot;QAccessibleEvent event(QEvent::AccessibilityHelp, 0);&quot;, 10],
+	&quot;QT_NO_ACTION&quot; =&gt;		[&quot;qaction.h&quot;, &quot;QAction foo( (QObject*)NULL );&quot;, 5],
+	&quot;QT_NO_ASYNC_IO&quot; =&gt;		[&quot;qasyncio.h&quot;, &quot;QAsyncIO foo();&quot;, 5],
+	&quot;QT_NO_ASYNC_IMAGE_IO&quot;=&gt;	[&quot;qasyncimageio.h&quot;, &quot;QImageDecoder foo( (QImageConsumer*) NULL );&quot;, 5],
+	&quot;QT_NO_BIG_CODECS&quot; =&gt; 		[&quot;qbig5codec.h&quot;, &quot;QBig5Codec foo();&quot;, 5],
+	&quot;QT_NO_BUTTON&quot; =&gt;		[&quot;qbutton.h&quot;, &quot;QButton foo( (QWidget*)NULL );&quot;, 10],
+ 	&quot;QT_NO_BUTTONGROUP&quot; =&gt;		[&quot;qbuttongroup.h&quot;, &quot;QButtonGroup foo( (QWidget*)NULL );&quot;, 12],
+ 	&quot;QT_NO_CANVAS&quot; =&gt;		[&quot;qcanvas.h&quot;, &quot;QCanvas foo( (QObject*)NULL );&quot;, 10],
+ 	&quot;QT_NO_CHECKBOX&quot; =&gt;		[&quot;qcheckbox.h&quot;, &quot;QCheckBox( (QWidget*)NULL );&quot;, 10],
+	&quot;QT_NO_CLIPBOARD&quot; =&gt; 		[&quot;qapplication.h, qclipboard.h&quot;, q&#163;
+						QApplication foo( argc, argv );
+						QClipboard *baz= foo.clipboard();
+					&#163;, 5],
+ 	&quot;QT_NO_COLORDIALOG&quot; =&gt;		[&quot;qcolordialog.h&quot;, &quot;QColorDialog::customCount();&quot;, 12],
+ 	&quot;QT_NO_COMBOBOX&quot; =&gt;		[&quot;qcombobox.h&quot;, &quot;QComboBox( (QWidget*)NULL );&quot;, 10],
+	&quot;QT_NO_COMPAT&quot; =&gt;		[&quot;qfontmetrics.h&quot;, q&#163;
+						QFontMetrics *foo= new QFontMetrics( QFont() );
+						int bar = foo-&gt;width( 'c' );
+					&#163;, 0],
+	&quot;QT_NO_COMPONENT&quot; =&gt;		[&quot;qapplication.h&quot;, q&#163;
+ 						QApplication foo( argc, argv );
+ 						foo.addLibraryPath( QString::null );
+					&#163;, 5],
+ 	&quot;QT_NO_CURSOR&quot; =&gt;		[&quot;qcursor.h&quot;, &quot;QCursor foo;&quot;, 5],
+ 	&quot;QT_NO_DATASTREAM&quot; =&gt;		[&quot;qdatastream.h&quot;, &quot;QDataStream foo;&quot;, 5],
+ 	&quot;QT_NO_DATETIMEEDIT&quot; =&gt;		[&quot;qdatetimeedit.h&quot;, &quot;QTimeEdit foo;&quot;, 12],
+	&quot;QT_NO_DIAL&quot; =&gt;			[&quot;qdial.h&quot;, &quot;QDial foo;&quot;, 10],
+	&quot;QT_NO_DIALOG&quot; =&gt;		[&quot;qdialog.h&quot;, &quot;QDialog foo;&quot;, 12],
+	&quot;QT_NO_DIR&quot; =&gt;			[&quot;qdir.h&quot;, &quot;QDir foo;&quot;, 5],
+	&quot;QT_NO_DNS&quot; =&gt;			[&quot;qdns.h&quot;, &quot;QDns foo;&quot;, 5],
+	&quot;QT_NO_DOM&quot; =&gt;			[&quot;qdom.h&quot;, &quot;QDomDocumentType foo;&quot;, 5],
+	&quot;QT_NO_DRAGANDDROP&quot; =&gt;		[&quot;qevent.h&quot;, &quot;QDropEvent foo( QPoint(1,1) );&quot;, 5],
+	&quot;QT_NO_DRAWUTIL&quot; =&gt;		[&quot;qdrawutil.h, qcolor.h&quot;, &quot;qDrawPlainRect( (QPainter *) NULL, 0, 0, 0, 0, QColor() );&quot;, 10],
+	&quot;QT_NO_ERRORMESSAGE&quot; =&gt; 	[&quot;qerrormessage.h&quot;, &quot;QErrorMessage foo( (QWidget*) NULL );&quot;, 13],
+	&quot;QT_NO_FILEDIALOG&quot; =&gt;		[&quot;qfiledialog.h&quot;, &quot;QFileIconProvider foo;&quot;, 13],
+
+	&quot;QT_NO_FONTDATABASE&quot; =&gt;		[&quot;qfontdatabase.h&quot;, &quot;QFontDatabase foo;&quot;, 5],
+	&quot;QT_NO_FONTDIALOG&quot; =&gt; 		[&quot;qfontdialog.h&quot;,   &quot;QFontDialog::getFont( (bool *)NULL );&quot;, 12],
+	&quot;QT_NO_FRAME&quot; =&gt; 		[&quot;qframe.h&quot;, &quot;QFrame foo;&quot;, 10],
+	&quot;QT_NO_GRID&quot; =&gt;			[&quot;qgrid.h&quot;, &quot;QGrid foo(5);&quot;, 12],
+	&quot;QT_NO_GRIDVIEW&quot; =&gt;		[&quot;qgridview.h&quot;, &quot;QFoo foo;&quot;, 13, q&#163;
+						class QFoo: public QGridView
+						{
+						public:
+							QFoo(){};
+							~QFoo(){};
+							void paintCell(QPainter *, int, int){};
+						};
+					&#163;],
+	&quot;QT_NO_GROUPBOX&quot; =&gt;		[&quot;qgroupbox.h&quot;, &quot;QGroupBox foo;&quot;, 12],
+	&quot;QT_NO_HBOX&quot; =&gt;			[&quot;qhbox.h&quot;, &quot;QHBox foo;&quot;, 12],
+	&quot;QT_NO_HBUTTONGROUP&quot; =&gt;		[&quot;qhbuttongroup.h&quot;, &quot;QHButtonGroup foo;&quot;, 13],
+	&quot;QT_NO_HEADER&quot; =&gt;		[&quot;qheader.h&quot;, &quot;QHeader foo;&quot;, 10],
+	&quot;QT_NO_HGROUPBOX&quot; =&gt;		[&quot;qhgroupbox.h&quot;, &quot;QHGroupBox foo;&quot;, 13],
+	&quot;QT_NO_ICONSET&quot; =&gt;		[&quot;qiconset.h&quot;, &quot;QIconSet foo;&quot;, 8],
+
+	&quot;QT_NO_ICONVIEW&quot; =&gt;		[&quot;qiconview.h&quot;, &quot;QIconView foo;&quot;, 13],
+	&quot;QT_NO_IMAGEFORMATPLUGIN&quot; =&gt;	[&quot;qimageformatplugin.h, qstringlist.h&quot;, &quot;QFoo foo;&quot;, 5, q&#163;
+
+						class QFoo: public QImageFormatPlugin
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+						    QStringList keys() const { return QStringList(); };
+						    bool installIOHandler( const QString &amp;format ) { return true; };
+						};
+						Q_EXPORT_PLUGIN( QFoo )
+					&#163;],
+ 	&quot;QT_NO_IMAGE_DITHER_TO_1&quot; =&gt;	[&quot;qimage.h&quot;, q&#163;
+						QImage *foo = new QImage;
+						foo-&gt;createAlphaMask();
+					&#163;, 8],
+ 	&quot;QT_NO_IMAGE_HEURISTIC_MASK&quot; =&gt;	[&quot;qimage.h&quot;, q&#163;
+						QImage *foo = new QImage;
+						foo-&gt;createHeuristicMask();
+					&#163;, 8],
+	&quot;QT_NO_IMAGE_MIRROR&quot; =&gt;	[&quot;qimage.h&quot;, q&#163;
+						QImage *foo = new QImage;
+						foo-&gt;mirror();
+					&#163;, 8],
+ 	&quot;QT_NO_IMAGE_SMOOTHSCALE&quot; =&gt;	[&quot;qimage.h&quot;, q&#163;
+						QImage *foo = new QImage;
+						foo-&gt;smoothScale( 10, 10);
+					&#163;, 8],
+ 	&quot;QT_NO_IMAGE_TEXT&quot; =&gt;		[&quot;qimage.h&quot;, &quot;QImageTextKeyLang foo;&quot;, 8],
+ 	&quot;QT_NO_IMAGE_TRANSFORMATION&quot; =&gt;	[&quot;qimage.h&quot;, q&#163;
+						QImage *foo = new QImage;
+						foo-&gt;scale( 10, 10);
+					&#163;, 8],
+ 	&quot;QT_NO_IMAGE_TRUECOLOR&quot; =&gt;	[&quot;qimage.h&quot;, q&#163;
+						QImage *foo = new QImage;
+						foo-&gt;convertDepthWithPalette( 1, (QRgb*) NULL, 1 );
+					&#163;, 8],
+	&quot;QT_NO_INPUTDIALOG&quot; =&gt;		[&quot;qinputdialog.h, qstring.h&quot;, q&#163;QInputDialog::getText( QString::null, QString::null);&#163;, 13],
+	&quot;QT_NO_IMAGEIO&quot; =&gt; 		[&quot;qbitmap.h, qstring.h&quot;, q&#163;
+						QBitmap foo( QString::fromLatin1(&quot;foobar&quot;) );
+					&#163;, 5],
+	&quot;QT_NO_IMAGEIO_JPEG&quot; =&gt;		[&quot;qjpegio.h&quot;, &quot;qInitJpegIO();&quot;, 8],
+	&quot;QT_NO_IMAGEIO_MNG&quot; =&gt;		[&quot;qmngio.h&quot;, &quot;qInitMngIO();&quot;, 8],
+	&quot;QT_NO_IMAGEIO_PNG&quot; =&gt;		[&quot;qpngio.h&quot;, &quot;qInitPngIO();&quot;, 8],
+	&quot;QT_NO_LABEL&quot; =&gt;		[&quot;qlabel.h&quot;, &quot;QLabel foo( (QWidget*) NULL );&quot;, 10],
+	&quot;QT_NO_LAYOUT&quot; =&gt;		[&quot;qlayout.h&quot;, &quot;QFoo foo;&quot;, 10, q&#163;
+
+ 						class QFoo: public QLayout
+ 						{
+ 						public:
+ 						    QFoo() {};
+ 						    ~QFoo() {};
+ 						    void addItem( QLayoutItem * ) { };
+						    QSize sizeHint() const { return QSize(); }
+ 						    QLayoutIterator iterator() { return QLayoutIterator( (QGLayoutIterator *) NULL ); };
+						    void setGeometry( const QRect &amp; ) { };
+ 						};
+ 					&#163;],
+	&quot;QT_NO_LCDNUMBER&quot; =&gt;		[&quot;qlcdnumber.h&quot;, &quot;QLCDNumber foo;&quot;, 12],
+	&quot;QT_NO_LINEEDIT&quot; =&gt;		[&quot;qlineedit.h&quot;, &quot;QLineEdit foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_LISTBOX&quot; =&gt;		[&quot;qlistbox.h&quot;, &quot;QListBox foo;&quot;, 13],
+	&quot;QT_NO_LISTVIEW&quot; =&gt;		[&quot;qlistview.h&quot;, &quot;QListView foo;&quot;, 13],
+	&quot;QT_NO_MAINWINDOW&quot; =&gt;		[&quot;qmainwindow.h&quot;, &quot;QMainWindow foo;&quot;, 13],
+	&quot;QT_NO_MENUBAR&quot; =&gt;		[&quot;qmenubar.h&quot;, &quot;QMenuBar foo;&quot;, 13],
+	&quot;QT_NO_MOVIE&quot; =&gt;		[&quot;qmovie.h&quot;, &quot;QMovie foo;&quot;, 5],
+	&quot;QT_NO_MENUDATA&quot; =&gt;		[&quot;qmenudata.h&quot;, &quot;QMenuData foo;&quot;, 9],
+	&quot;QT_NO_MESSAGEBOX&quot; =&gt;		[&quot;qmessagebox.h&quot;, &quot;QMessageBox foo;&quot;, 13],
+	&quot;QT_NO_MIME&quot; =&gt;			[&quot;qmime.h&quot;, &quot;QMimeSourceFactory foo;&quot;, 5],
+ 	&quot;QT_NO_MIMECLIPBOARD&quot; =&gt; 	[&quot;qapplication.h, qclipboard.h&quot;, q&#163;
+ 						QApplication foo( argc, argv );
+ 						QClipboard *baz= foo.clipboard();
+						baz-&gt;data();
+					&#163;, 8],
+
+	&quot;QT_NO_MULTILINEEDIT&quot; =&gt;	[&quot;qmultilineedit.h&quot;, &quot;QMultiLineEdit foo;&quot;, 14],
+	&quot;QT_NO_NETWORK&quot; =&gt;		[&quot;qnetwork.h&quot;, &quot;qInitNetworkProtocols();&quot;, 5],
+	&quot;QT_NO_NETWORKPROTOCOL&quot; =&gt;	[&quot;qnetworkprotocol.h&quot;, &quot;QNetworkProtocol foo;&quot;, 8],
+ 	&quot;QT_NO_NETWORKPROTOCOL_FTP&quot; =&gt;	[&quot;qftp.h&quot;, &quot;QFtp foo;&quot;, 9],
+	&quot;QT_NO_PALETTE&quot; =&gt;		[&quot;qpalette.h&quot;, &quot;QColorGroup foo;&quot;, 5],
+	&quot;QT_NO_PICTURE&quot; =&gt;		[&quot;qpicture.h&quot;, &quot;QPicture foo;&quot;, 5],
+	&quot;QT_NO_PIXMAP_TRANSFORMATION&quot; =&gt;[&quot;qbitmap.h, qwmatrix.h&quot;, q&#163;
+						QBitmap *foo= new QBitmap();
+						QWMatrix bar;
+						foo-&gt;xForm( bar );
+					&#163;, 5],
+	&quot;QT_NO_POPUPMENU&quot; =&gt;		[&quot;qpopupmenu.h&quot;, &quot;QPopupMenu foo;&quot;, 12],
+	&quot;QT_NO_PRINTER&quot; =&gt;		[&quot;qprinter.h&quot;, &quot;QPrinter foo;&quot;, 5],
+	&quot;QT_NO_PRINTDIALOG&quot; =&gt;		[&quot;qprintdialog.h&quot;, &quot;QPrintDialog foo( (QPrinter*) NULL );&quot;, 13],
+	&quot;QT_NO_PROCESS&quot; =&gt;		[&quot;qprocess.h&quot;, &quot;QProcess foo;&quot;, 5],
+	&quot;QT_NO_PROGRESSBAR&quot; =&gt;		[&quot;qprogressbar.h&quot;, &quot;QProgressBar foo;&quot;, 12],
+	&quot;QT_NO_PROGRESSDIALOG&quot; =&gt;	[&quot;qprogressdialog.h&quot;, &quot;QProgressDialog foo;&quot;, 13],
+	&quot;QT_NO_PUSHBUTTON&quot; =&gt;		[&quot;qpushbutton.h&quot;, &quot;QPushButton foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_PROPERTIES&quot; =&gt;		[&quot;qmetaobject.h&quot;, &quot;QMetaProperty foo;&quot;, 0],
+#	&quot;QT_NO_QTMULTILINEEDIT&quot; =&gt;	[&quot;qtmultilineedit.h&quot;, &quot;QtMultiLineEdit foo;&quot;, 15],
+#	&quot;QT_NO_QTTABLEVIEW&quot; =&gt;		[&quot;qttableview.h&quot;, &quot;QFoo foo;&quot;, 16, q&#163;
+#						class QFoo: public QtTableView
+#						{
+#						public:
+#							QFoo() {};
+#							~QFoo() {};
+#							void paintCell( QPainter *, int, int) {};
+#						};
+#						&#163;],
+	&quot;QT_NO_QUUID_STRING&quot; =&gt;		[&quot;quuid.h&quot;, &quot;QUuid foo( QString::null );&quot;, 8],
+	&quot;QT_NO_RANGECONTROL&quot; =&gt;		[&quot;qrangecontrol.h&quot;, &quot;QRangeControl foo;&quot;, 10],
+	&quot;QT_NO_REGEXP&quot; =&gt;		[&quot;qregexp.h&quot;, &quot;QRegExp foo;&quot;, 5],
+	&quot;QT_NO_REGEXP_WILDCARD&quot; =&gt;	[&quot;qregexp.h&quot;, q&#163;
+						QRegExp foo;
+						foo.wildcard();
+					&#163;, 8],
+	&quot;QT_NO_REMOTE&quot; =&gt;		[&quot;qapplication.h&quot;, q&#163;
+   						QApplication foo( argc, argv );
+   						foo.remoteControlEnabled();
+					&#163;, 15],
+	&quot;QT_NO_RADIOBUTTON&quot; =&gt;		[&quot;qradiobutton.h&quot;, &quot;QRadioButton foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_RICHTEXT&quot; =&gt;		[&quot;qsimplerichtext.h, qstring.h, qfont.h&quot;, &quot;QSimpleRichText foo( QString::null, QFont() );&quot;, 10],
+	&quot;QT_NO_SCROLLBAR&quot; =&gt;		[&quot;qscrollbar.h&quot;, &quot;QScrollBar foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_SCROLLVIEW&quot; =&gt;		[&quot;qscrollview.h&quot;, &quot;QScrollView foo;&quot;, 12],
+	&quot;QT_NO_SEMIMODAL&quot; =&gt;		[&quot;qsemimodal.h&quot;, &quot;QSemiModal foo;&quot;, 10],
+	&quot;QT_NO_SESSIONMANAGER&quot; =&gt;	[&quot;qapplication.h&quot;, q&#163;
+  						QApplication foo( argc, argv );
+  						foo.sessionId();
+					&#163;, 15],
+	&quot;QT_NO_SETTINGS&quot; =&gt;		[&quot;qsettings.h&quot;, &quot;QSettings foo;&quot;, 5],
+	&quot;QT_NO_SIGNALMAPPER&quot; =&gt;		[&quot;qsignalmapper.h&quot;, &quot;QSignalMapper foo( (QObject *) NULL );&quot;, 0],
+	&quot;QT_NO_SIZEGRIP&quot; =&gt;		[&quot;qsizegrip.h&quot;, &quot;QSizeGrip foo( (QWidget *) NULL );&quot;, 10],
+	&quot;QT_NO_SLIDER&quot; =&gt;		[&quot;qslider.h&quot;, &quot;QSlider foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_SOUND&quot; =&gt;		[&quot;qsound.h&quot;, &quot;QSound foo( QString::null );&quot;, 5],
+
+
+	&quot;QT_NO_SPINWIDGET&quot; =&gt;		[&quot;qrangecontrol.h&quot;, &quot;QSpinWidget foo;&quot;, 10],
+	&quot;QT_NO_SPRINTF&quot; =&gt;		[&quot;qcolor.h&quot;, q&#163;
+						QColor foo;
+						foo.name();
+					&#163;, 0],
+
+
+
+	&quot;QT_NO_SQL&quot; =&gt;			[&quot;qsqlcursor.h&quot;, &quot;QSqlCursor foo;&quot;, 5],
+	&quot;QT_NO_STRINGLIST&quot; =&gt;		[&quot;qstringlist.h&quot;, &quot;QStringList foo;&quot;, 0],
+	&quot;QT_NO_STYLE&quot; =&gt;		[&quot;qapplication.h&quot;, q&#163;
+   						QApplication foo( argc, argv );
+   						foo.style();
+ 					&#163;, 15],
+
+#	&quot;QT_NO_STYLE_CDE&quot; =&gt;		[&quot;qcdestyle.h&quot;, &quot;QCDEStyle foo;&quot;, 16],
+# 	&quot;QT_NO_STYLE_COMPACT&quot; =&gt;	[&quot;qcompactstyle.h&quot;, &quot;QCompactStyle foo;&quot;, 16],
+#	&quot;QT_NO_STYLE_INTERLACE&quot; =&gt;	[&quot;qinterlacestyle.h&quot;, &quot;QInterlaceStyle foo;&quot;, 16],
+#	&quot;QT_NO_STYLE_PLATINUM&quot; =&gt;	[&quot;qplatinumstyle.h&quot;, &quot;QPlatinumStyle foo;&quot;, 16],
+#	&quot;QT_NO_STYLE_MOTIF&quot; =&gt;		[&quot;qmotifstyle.h&quot;, &quot;QMotifStyle foo;&quot;, 16],
+#	&quot;QT_NO_STYLE_MOTIFPLUS&quot; =&gt;	[&quot;qmotifplusstyle.h&quot;, &quot;QMotifPlusStyle foo;&quot;, 16],
+#	&quot;QT_NO_STYLE_SGI&quot; =&gt;		[&quot;qsgistyle.h&quot;, &quot;QSGIStyle foo;&quot;, 16],
+#	&quot;QT_NO_STYLE_WINDOWS&quot; =&gt;	[&quot;qwindowsstyle.h&quot;, &quot;QWindowsStyle foo;&quot;, 16],
+        &quot;QT_NO_TABBAR&quot; =&gt;               [&quot;qtabbar.h&quot;, &quot;QTabBar foo;&quot;, 10],
+        &quot;QT_NO_TABDIALOG&quot; =&gt;            [&quot;qtabdialog.h&quot;, &quot;QTabDialog foo;&quot;, 12],
+        &quot;QT_NO_TABLE&quot; =&gt;                [&quot;qtable.h&quot;, &quot;QTable foo;&quot;, 10],
+        &quot;QT_NO_TABWIDGET&quot; =&gt;            [&quot;qtabwidget.h&quot;, &quot;QTabWidget foo;&quot;, 10],
+        &quot;QT_NO_TEXTBROWSER&quot; =&gt;          [&quot;qtextbrowser.h&quot;, &quot;QTextBrowser foo;&quot;, 14],
+        &quot;QT_NO_TEXTCODEC&quot; =&gt;            [&quot;qtextcodec.h&quot;, &quot;QTextCodec::codecForIndex(1);&quot;, 5],
+        &quot;QT_NO_TEXTCODECPLUGIN&quot; =&gt;      [&quot;qtextcodecplugin.h, qstringlist.h, qvaluelist.h, qtextcodec.h&quot;, &quot;QFoo foo;&quot;, 6, q&#163; 
+	
+						class QFoo: public QTextCodecPlugin
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                                                    QStringList names() const {return QStringList();}
+                                                    QValueList&lt;int&gt;mibEnums() const {return QValueList&lt;int&gt;();}
+                                                    QTextCodec *createForName( const QString &amp; name ) {return (QTextCodec *)NULL;}
+                                                    QTextCodec *createForMib( int mib ) {return (QTextCodec *)NULL;}
+						};
+						Q_EXPORT_PLUGIN( QFoo )
+					&#163;],
+ 	&quot;QT_NO_TEXTEDIT&quot; =&gt;		[&quot;qtextedit.h&quot;, &quot;QTextEdit foo;&quot;, 13], 
+        &quot;QT_NO_TEXTSTREAM&quot; =&gt;           [&quot;qtextstream.h&quot;, &quot;QTextStream foo;&quot;, 5],
+        &quot;QT_NO_TEXTVIEW&quot; =&gt;             [&quot;qtextview.h&quot;, &quot;QTextView foo;&quot;, 14], #Obsolete
+        &quot;QT_NO_TOOLBAR&quot; =&gt;              [&quot;qtoolbar.h&quot;, &quot;QToolBar foo;&quot;, 10],
+        &quot;QT_NO_TOOLBUTTON&quot; =&gt;           [&quot;qtoolbutton.h&quot;, &quot;QToolButton foo((QWidget *) NULL );&quot;, 12],
+        &quot;QT_NO_TOOLTIP&quot; =&gt;              [&quot;qtooltip.h&quot;, &quot;QToolTip::hide();&quot;, 10],
+        
+	&quot;QT_NO_TRANSFORMATIONS&quot; =&gt;	[&quot;qpainter.h&quot;, q&#163;
+						QPainter *foo= new QPainter();
+						foo-&gt;setViewXForm( true );&#163;, 5],
+        &quot;QT_NO_VARIANT&quot; =&gt;              [&quot;qvariant.h&quot;, &quot;QVariant foo;&quot;, 0],
+        &quot;QT_NO_WHATSTHIS&quot; =&gt;            [&quot;qwhatsthis.h&quot;, &quot;QWhatsThis::inWhatsThisMode();&quot;, 10],
+	&quot;QT_NO_WHEELEVENT&quot; =&gt;		[&quot;qevent.h&quot;, &quot;QWheelEvent foo( QPoint(1,1), 1, 1 );&quot;, 5],
+        &quot;QT_NO_WIDGET_TOPEXTRA&quot; =&gt;      [&quot;qwidget.h&quot;, &quot;QWidget foo; foo.caption();&quot;, 9],
+        &quot;QT_NO_WIDGETSTACK&quot; =&gt;          [&quot;qwidgetstack.h&quot;, &quot;QWidgetStack foo;&quot;, 13],
+        &quot;QT_NO_WIZARD&quot; =&gt;               [&quot;qwizard.h&quot;, &quot;QWizard foo;&quot;, 13],
+	&quot;QT_NO_WMATRIX&quot; =&gt;		[&quot;qwmatrix.h&quot;, &quot;QWMatrix foo;&quot;, 0],
+	&quot;QT_NO_XML&quot; =&gt;			[&quot;qxml.h&quot;, &quot;QXmlNamespaceSupport foo;&quot;, 5],
+	);
+
+}

Added: trunk/smoke/qt/Makefile.am
===================================================================
--- trunk/smoke/qt/Makefile.am	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/Makefile.am	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,28 @@
+lib_LTLIBRARIES = libsmokeqt.la
+
+# set the include path for X, qt and KDE
+INCLUDES         = -I$(srcdir)/.. $(all_includes) -I$(qt_includes)/QtUiTools \
+                   -I$(qt_includes)/QtDBus
+
+EXTRA_DIST=generate.pl.in qtguess.pl.in qt_smoke.h Makefile.am
+
+# the library search path. 
+libsmokeqt_la_LDFLAGS = -version-info 3:3:2 -no-undefined $(all_libraries) $(GLINC)
+
+# the libraries to link against.
+libsmokeqt_la_LIBADD   = $(LIB_QTCORE) $(LIB_QTGUI) $(LIB_QTNETWORK) \
+						$(LIB_QTOPENGL) $(LIB_QTSQL) $(LIB_QTCORE) $(LIB_QTXML) $(LIB_QTSVG) \
+						$(GLLIB) $(LIBQSCINTILLA) \
+						-lQtSvg -lQtUiTools $(LIBQTDBUS) $(LIBQWT)
+
+x_sources = x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+   x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+   x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp
+
+# which sources should be compiled for perlqtkde
+libsmokeqt_la_SOURCES = smokedata.cpp $(x_sources)
+
+$(x_sources) smokedata.cpp:
+	perl generate.pl
+
+CLEANFILES = $(libsmokeqt_la_SOURCES)

Added: trunk/smoke/qt/Makefile.in
===================================================================
--- trunk/smoke/qt/Makefile.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/Makefile.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,51 @@
+# Makefile.in generated by unsermake
+####################################
+
+top_builddir = ../..
+top_srcdir = @top_srcdir@
+srcdir = @srcdir@
+.FORWARDS: all install install-data install-exec clean check force-reedit
+
+all:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake all
+
+install:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake install
+
+install-data:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake install-data
+
+install-exec:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake install-exec
+
+clean:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake clean
+
+check:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake check
+
+force-reedit:
+	@echo 'WARNING: use unsermake instead of make or use a wrapper script, e.g. makeobj!!!'
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake force-reedit
+
+$(top_builddir)/smoke/qt/Makefile: $(top_builddir)/config.status $(top_srcdir)/smoke/qt/Makefile.in
+	cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status smoke/qt/Makefile
+
+$(top_builddir)/smoke/qt/generate.pl: $(top_builddir)/config.status $(srcdir)/generate.pl.in
+		cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status smoke/qt/generate.pl
+
+$(top_builddir)/smoke/qt/qtguess.pl: $(top_builddir)/config.status $(srcdir)/qtguess.pl.in
+		cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status smoke/qt/qtguess.pl
+
+all: $(top_builddir)/smoke/qt/Makefile
+final: 
+	/home/moni/Documents/projekte/php_qt/unsermake/unsermake -C $(top_builddir)/smoke/qt UNSERMAKE_FORCE_FINAL=1 libsmokeqt.la
+
+INCLUDES = -I$(top_srcdir)/smoke/qt/.. $(all_includes) -I$(qt_includes)/QtUiTools -I$(qt_includes)/QtDBus
+.PHONY: all final

Added: trunk/smoke/qt/configure.in.in
===================================================================
--- trunk/smoke/qt/configure.in.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/configure.in.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,200 @@
+
+AC_HAVE_GL
+KDE_HAVE_GL=yes;
+if test &quot;X$GLLIB&quot; = &quot;X&quot;; then
+    KDE_HAVE_GL=no
+fi
+
+AC_SUBST(KDE_HAVE_GL)   
+
+AC_ARG_WITH(
+   threshold,
+   [  --with-threshold@&lt;:@=0..15@:&gt;@  Smoke: Qt tests threshold Default:10 Lower=more tests],
+   [ qt_test_threshold=&quot;$withval&quot; ],
+   [ qt_test_threshold=10 ]
+)
+AC_SUBST(qt_test_threshold)
+
+if test &quot;X$kde_build_libsmoke&quot; = &quot;Xqt&quot; -o &quot;X$kde_build_libsmoke&quot; = &quot;Xqt kde&quot;; then
+
+    AC_CONFIG_FILES([ smoke/qt/qtguess.pl ], [
+        cd smoke/qt
+        perl qtguess.pl
+        cd ../..
+    ])
+    AC_CONFIG_FILES([ smoke/qt/generate.pl ], [
+    ])
+fi
+
+dnl -------
+dnl Test for libqscintilla (QScintilla support)
+dnl -------
+
+AC_ARG_ENABLE(
+   qscintilla,
+   [  --enable-qscintilla@&lt;:@=yes|no@:&gt;@   Smoke: build Smoke with QScintilla extention for qt @&lt;:@default:no@:&gt;@],
+   [ qtextscintilla=&quot;$enableval&quot; ],
+   [ qtextscintilla=&quot;no&quot; ]
+)
+AC_SUBST(qtextscintilla)
+
+AC_DEFUN([AC_FIND_QSCINTILLA],
+[
+AC_MSG_CHECKING([for libqscintilla])
+AC_CACHE_VAL(ac_cv_lib_qscintilla,
+[
+ kde_ldflags_save=&quot;$LDFLAGS&quot;
+ kde_libs_save=&quot;$LIBS&quot;
+ kde_cxxflags_save=&quot;$CXXFLAGS&quot;
+
+ LIBS=&quot;-lqscintilla $LIBQT $LIBS&quot;
+ CXXFLAGS=&quot;$CXXFLAGS $all_includes&quot;
+ LDFLAGS=&quot;$LDFLAGS $all_libraries $USER_LDFLAGS&quot;
+
+AC_TRY_LINK([
+   #include &lt;qextscintillabase.h&gt;
+],
+[
+            QextScintillaBase s;
+],
+            eval &quot;ac_cv_lib_qscintilla='-lqscintilla'&quot;,
+            eval &quot;ac_cv_lib_qscintilla=no&quot;)
+
+ LDFLAGS=$kde_ldflags_save
+ LIBS=$kde_libs_save
+ CXXFLAGS=$kde_cxxflags_save
+])
+
+if test ! &quot;$ac_cv_lib_qscintilla&quot; = no; then
+  AC_DEFINE_UNQUOTED(HAVE_LIBQSCINTILLA, 1, [Define if you have libqscintilla])
+  LIBQSCINTILLA=&quot;$ac_cv_lib_qscintilla&quot;
+  AC_MSG_RESULT($ac_cv_lib_qscintilla)
+else
+  AC_MSG_ERROR(not found. 
+          Check your installation and look into config.log)
+  LIBQSCINTILLA=&quot;&quot;
+fi
+AC_SUBST(LIBQSCINTILLA)
+])
+
+if test &quot;X$qtextscintilla&quot; = &quot;Xyes&quot; ; then
+  AC_FIND_QSCINTILLA
+fi
+
+dnl -------
+dnl Test for libQtDBus (D-Bus support)
+dnl -------
+
+AC_ARG_ENABLE(
+   qtdbus,
+   [  --enable-qtdbus@&lt;:@=yes|no@:&gt;@   Smoke: build Smoke with QtDbus extention for qt @&lt;:@default:no@:&gt;@],
+   [ qtdbus=&quot;$enableval&quot; ],
+   [ qtdbus=&quot;no&quot; ]
+)
+AC_SUBST(qtdbus)
+
+AC_DEFUN([AC_FIND_QTDBUS],
+[
+AC_MSG_CHECKING([for libQtDBus])
+AC_CACHE_VAL(ac_cv_lib_qtdbus,
+[
+AC_LANG_SAVE
+AC_LANG_CPLUSPLUS
+
+ kde_ldflags_save=&quot;$LDFLAGS&quot;
+ kde_libs_save=&quot;$LIBS&quot;
+ kde_cxxflags_save=&quot;$CXXFLAGS&quot;
+
+ LIBS=&quot;-ldbus-1 -lQtDBus -ldbus-glib-1 $LIB_QTCORE $LIB_QTXML $LIBS&quot;
+ CXXFLAGS=&quot;$CXXFLAGS $all_includes -DDBUS_COMPILATION&quot;
+ LDFLAGS=&quot;$LDFLAGS $all_libraries $USER_LDFLAGS&quot;
+
+AC_TRY_LINK([
+   #include &lt;QtDBus/qdbusconnection.h&gt;
+],
+[
+            QDBusConnection b = QDBus::sessionBus();
+],
+            eval &quot;ac_cv_lib_qtdbus='-ldbus-1 -lQtDBus -ldbus-glib-1'&quot;,
+            eval &quot;ac_cv_lib_qtdbus=no&quot;)
+
+ LDFLAGS=$kde_ldflags_save
+ LIBS=$kde_libs_save
+ CXXFLAGS=$kde_cxxflags_save
+AC_LANG_RESTORE
+])
+
+if test ! &quot;$ac_cv_lib_qtdbus&quot; = no; then
+  AC_DEFINE_UNQUOTED(HAVE_LIBQTDBUS, 1, [Define if you have libdbus-qt4-1])
+  LIBQTDBUS=&quot;$ac_cv_lib_qtdbus&quot;
+  AC_MSG_RESULT($ac_cv_lib_qtdbus)
+else
+  AC_MSG_ERROR(not found. 
+          Check your installation and look into config.log)
+  LIBQTDBUS=&quot;&quot;
+fi
+AC_SUBST(LIBQTDBUS)
+])
+
+if test &quot;X$qtdbus&quot; = &quot;Xyes&quot; ; then
+  AC_FIND_QTDBUS
+fi
+
+dnl -------
+dnl Test for libqwt (Scientific Plotting library)
+dnl -------
+
+AC_ARG_ENABLE(
+   qwt,
+   [  --enable-qwt@&lt;:@=yes|no@:&gt;@   Smoke: build Smoke with Qwt extention for qt @&lt;:@default:no@:&gt;@],
+   [ qwt=&quot;$enableval&quot; ],
+   [ qwt=&quot;no&quot; ]
+)
+AC_SUBST(qwt)
+
+AC_DEFUN([AC_FIND_QWT],
+[
+AC_MSG_CHECKING([for libqwt])
+AC_CACHE_VAL(ac_cv_lib_qwt,
+[
+AC_LANG_SAVE
+AC_LANG_CPLUSPLUS
+
+ kde_ldflags_save=&quot;$LDFLAGS&quot;
+ kde_libs_save=&quot;$LIBS&quot;
+ kde_cxxflags_save=&quot;$CXXFLAGS&quot;
+
+ LIBS=&quot;-lqwt $LIB_QTCORE $LIB_QTXML $LIBS&quot;
+ CXXFLAGS=&quot;$CXXFLAGS $all_includes&quot;
+ LDFLAGS=&quot;$LDFLAGS $all_libraries $USER_LDFLAGS&quot;
+
+AC_TRY_LINK([
+   #include &lt;qwt_plot.h&gt;
+],
+[
+            QwtPlot p;
+],
+            eval &quot;ac_cv_lib_qwt='-lqwt'&quot;,
+            eval &quot;ac_cv_lib_qwt=no&quot;)
+
+ LDFLAGS=$kde_ldflags_save
+ LIBS=$kde_libs_save
+ CXXFLAGS=$kde_cxxflags_save
+AC_LANG_RESTORE
+])
+
+if test ! &quot;$ac_cv_lib_qwt&quot; = no; then
+  AC_DEFINE_UNQUOTED(HAVE_LIBQWT, 1, [Define if you have libqwt])
+  LIBQWT=&quot;$ac_cv_lib_qwt&quot;
+  AC_MSG_RESULT($ac_cv_lib_qwt)
+else
+  AC_MSG_ERROR(not found. 
+          Check your installation and look into config.log)
+  LIBQWT=&quot;&quot;
+fi
+AC_SUBST(LIBQWT)
+])
+
+if test &quot;X$qwt&quot; = &quot;Xyes&quot; ; then
+  AC_FIND_QWT
+fi

Added: trunk/smoke/qt/generate.pl.in
===================================================================
--- trunk/smoke/qt/generate.pl.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/generate.pl.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,220 @@
+#!/usr/bin/perl -w
+
+## Run this first, to generate the x_*.cpp files from the Qt headers
+## using kalyptus
+
+my $kalyptusdir = &quot;../../kalyptus&quot;;
+
+use File::Basename;
+use File::Copy qw|cp|;
+use File::Compare;
+use File::Find;
+use Cwd;
+
+my $here = getcwd;
+my $outdir = $here . &quot;/generate.pl.tmpdir&quot;;
+my $finaloutdir = $here;
+my $defines = &quot;qtdefines&quot;;
+my $headerlist = &quot;@srcdir@/header_list&quot;;
+my $definespath = &quot;$here/$defines&quot;;
+my $headerlistpath = &quot;$here/$headerlist&quot;;
+my $qscintilla_headerlist = &quot;&quot;;
+my $qscintilla_headerlistpath = &quot;&quot;;
+my $qtdbus_headerlist = &quot;&quot;;
+my $qtdbus_headerlistpath = &quot;&quot;;
+
+if(&quot;@qtextscintilla@&quot; eq &quot;yes&quot;)
+{
+ $qscintilla_headerlist = &quot;./qscintilla_header_list&quot;;
+ $qscintilla_headerlistpath = &quot;$here/$qscintilla_headerlist&quot;;
+}
+
+if(&quot;@qtdbus@&quot; eq &quot;yes&quot;)
+{
+ $qtdbus_headerlist = &quot;./qtdbus_header_list&quot;;
+ $qtdbus_headerlistpath = &quot;$here/$qtdbus_headerlist&quot;;
+}
+
+if(&quot;@qwt@&quot; eq &quot;yes&quot;)
+{
+ $qwt_headerlist = &quot;./qwt_header_list&quot;;
+ $qwt_headerlistpath = &quot;$here/$qwt_headerlist&quot;;
+}
+
+## If srcdir != builddir, use headerlist from src
+$headerlistpath = $headerlist if ($headerlist =~ /^\//);
+if(&quot;@qtextscintilla@&quot; eq &quot;yes&quot;)
+{
+ $qscintilla_headerlistpath = $qscintilla_headerlist if ($qscintilla_headerlist =~ /^\//);
+}
+
+if(&quot;@qtdbus@&quot; eq &quot;yes&quot;)
+{
+ $qtdbus_headerlistpath = $qtdbus_headerlist if ($qtdbus_headerlist =~ /^\//);
+}
+
+if(&quot;@qwt@&quot; eq &quot;yes&quot;)
+{
+ $qwt_headerlistpath = $qwt_headerlist if ($qwt_headerlist =~ /^\//);
+}
+## Note: outdir and finaloutdir should NOT be the same dir!
+
+# Delete all x_*.cpp files under outdir (or create outdir if nonexistent)
+if (-d $outdir) { system &quot;rm -f $outdir/x_*.cpp&quot;; } else { mkdir $outdir; }
+
+mkdir $finaloutdir unless (-d $finaloutdir);
+
+#  Load the QT_NO_* macros found in &quot;qtdefines&quot;. They'll be passed to kalyptus
+my $macros=&quot;&quot;;
+if ( -e $definespath ){
+    print &quot;Found '$defines'. Reading preprocessor symbols from there...\n&quot;;
+    $macros = &quot; --defines=$definespath &quot;;
+}
+
+mkdir $kalyptusdir, 0777;
+# Need to cd to kalyptus's directory so that perl finds Ast.pm etc.
+chdir &quot;$kalyptusdir&quot; or die &quot;Couldn't go to $kalyptusdir (edit script to change dir)\n&quot;;
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %excludes = (
+    'qaccessible.h' =&gt; 1,  # Accessibility support is not compiled by defaut
+    'qassistantclient.h' =&gt; 1, # Not part of Qt (introduced in Qt-3.1)
+    'qmotif.h' =&gt; 1,       # 
+    'qmotifwidget.h' =&gt; 1, # Motif extension (introduced in Qt-3.1)
+    'qmotifdialog.h' =&gt; 1, #
+    'qxt.h' =&gt; 1, # Xt
+    'qxtwidget.h' =&gt; 1, # Xt
+    'qdns.h' =&gt; 1, # internal
+    'qgl.h' =&gt; 1, # OpenGL
+    'qglcolormap.h' =&gt; 1, # OpenGL
+    'qnp.h' =&gt; 1, # NSPlugin
+    'qttableview.h' =&gt; 1,  # Not in Qt anymore...
+    'qtmultilineedit.h' =&gt; 1,  # Not in Qt anymore...
+    'qwidgetfactory.h' =&gt; 1,  # Just an interface
+    'qsharedmemory.h' =&gt; 1, # &quot;not part of the Qt API&quot; they say
+    'qwindowsstyle.h' =&gt; 1, # Qt windowsstyle, plugin
+    'qmotifstyle.h' =&gt; 1,
+    'qcompactstyle.h' =&gt; 1,
+    'qinterlacestyle.h' =&gt; 1,
+    'qmotifplusstyle.h' =&gt; 1,
+    'qsgistyle.h' =&gt; 1,
+    'qplatinumstyle.h' =&gt; 1,
+    'qcdestyle.h' =&gt; 1,
+	 'qworkspace.h' =&gt; 1,
+    'qwindowsxpstyle.h' =&gt; 1 # play on the safe side 
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %includes;
+open(HEADERS, $headerlistpath) or die &quot;Couldn't open $headerlistpath: $!\n&quot;;
+map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+close HEADERS;
+
+if(&quot;@qtextscintilla@&quot; eq &quot;yes&quot;)
+{
+ open(HEADERS, $qscintilla_headerlistpath) or die &quot;Couldn't open $qscintilla_headerlistpath: $!\n&quot;;
+ map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+ close HEADERS;
+}
+
+if(&quot;@qtdbus@&quot; eq &quot;yes&quot;)
+{
+ open(HEADERS, $qtdbus_headerlistpath) or die &quot;Couldn't open $qtdbus_headerlistpath: $!\n&quot;;
+ map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+ close HEADERS;
+}
+
+if(&quot;@qwt@&quot; eq &quot;yes&quot;)
+{
+ open(HEADERS, $qwt_headerlistpath) or die &quot;Couldn't open $qwt_headerlistpath: $!\n&quot;;
+ map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+ close HEADERS;
+}
+ 
+# Can we compile the OpenGl module ?
+if(&quot;@KDE_HAVE_GL@&quot; eq &quot;yes&quot;)
+{
+    open(DEFS, $definespath);
+    my @defs = &lt;DEFS&gt;;
+    close DEFS;
+    if(!grep(/QT_NO_OPENGL/, @defs))
+    {
+      $excludes{'qgl.h'} = undef;
+      $excludes{'qglcolormap.h'} = undef;
+    }
+    else
+    {
+      print STDERR &quot;Qt was not compiled with OpenGL support...\n Skipping QGL Classes.\n&quot;;
+    }
+}
+
+# List Qt headers, and exclude the ones listed above
+my @headers = ();
+
+$qtinc= '@qt_includes@';
+
+find(
+    {   wanted =&gt; sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qtinc);
+                push ( @headers, $_ )
+	    	  if( !defined $excludes{$f} # Not excluded
+	    	     &amp;&amp; $includes{$f}        # Known header
+	    	     &amp;&amp; /\.h$/);     # Not a backup file etc. Only headers.
+	    	undef $includes{$f}   
+	     };
+	},
+	follow_fast =&gt; 1,
+	follow_skip =&gt; 2,
+	no_chdir =&gt; 1
+    }, $qtinc
+ );
+
+# Launch kalyptus
+chdir &quot;../smoke/qt&quot;;
+system &quot;perl <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">-I at top_srcdir</A>@/kalyptus @top_srcdir@/kalyptus/kalyptus @ARGV --qt4 --globspace -fsmoke --name=qt $macros --no-cache --outputdir=$outdir @headers&quot;;
+my $exit = $? &gt;&gt; 8;
+exit $exit if ($exit);
+chdir &quot;$kalyptusdir&quot;;
+
+# Generate diff for smokedata.cpp
+unless ( -e &quot;$finaloutdir/smokedata.cpp&quot; ) {
+    open( TOUCH, &quot;&gt;$finaloutdir/smokedata.cpp&quot;);
+    close TOUCH;
+}
+system &quot;diff -u $finaloutdir/smokedata.cpp $outdir/smokedata.cpp &gt; $outdir/smokedata.cpp.diff&quot;;
+
+# Copy changed or new files to finaloutdir
+opendir (OUT, $outdir) or die &quot;Couldn't opendir $outdir&quot;;
+foreach $filename (readdir(OUT)) {
+    next if ( -d &quot;$outdir/$filename&quot; ); # only files, not dirs
+    my $docopy = 1;
+    if ( -f &quot;$finaloutdir/$filename&quot; ) {
+        $docopy = compare(&quot;$outdir/$filename&quot;, &quot;$finaloutdir/$filename&quot;); # 1 if files are differents
+    }
+    if ($docopy) {
+	#print STDERR &quot;Updating $filename...\n&quot;;
+	cp(&quot;$outdir/$filename&quot;, &quot;$finaloutdir/$filename&quot;);
+    }
+}
+closedir OUT;
+
+# Check for deleted files and warn
+my $deleted = 0;
+opendir(FINALOUT, $finaloutdir) or die &quot;Couldn't opendir $finaloutdir&quot;;
+foreach $filename (readdir(FINALOUT)) {
+    next if ( -d &quot;$finaloutdir/$filename&quot; ); # only files, not dirs
+    if ( $filename =~ /.cpp$/ &amp;&amp; ! ($filename =~ /_la_closure.cpp/) &amp;&amp; ! -f &quot;$outdir/$filename&quot; ) {
+      print STDERR &quot;Removing obsolete file $filename\n&quot;;
+      unlink &quot;$finaloutdir/$filename&quot;;
+      $deleted = 1;
+    }
+}
+closedir FINALOUT;
+
+# Delete outdir
+system &quot;rm -rf $outdir&quot;;
+

Added: trunk/smoke/qt/generate_makefile_am.pl
===================================================================
--- trunk/smoke/qt/generate_makefile_am.pl	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/generate_makefile_am.pl	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,55 @@
+#!/usr/bin/perl -w
+
+use File::Basename;
+
+my $here = `pwd`;
+chomp $here;
+my $outdir = $here;
+my $tempfile = &quot;$outdir/.Makefile.am.tmpfile&quot;;
+
+# Update list of source files in $outdir/Makefile.am
+open( MAKEFILE, &quot;&lt;$outdir/Makefile.am&quot; ) or die;
+my $makeFileData = '';
+my $found = 0;
+while (&lt;MAKEFILE&gt;) {
+	if (/^libsmokeqt_la_SOURCES/)
+	{
+		$found = 1;
+		$makeFileData .= &quot;libsmokeqt_la_SOURCES = smokedata.cpp&quot;;
+	}
+	$makeFileData .= $_ if (!$found);
+}
+close MAKEFILE;
+
+die &quot;libsmokeqt_la_SOURCES not found&quot; if (!$found);
+
+open( MAKEFILE, &quot;&gt;$tempfile&quot; ) or die;
+print MAKEFILE $makeFileData;
+
+my $count = 0;
+opendir (FILES, $outdir) or die;
+foreach $filename (readdir(FILES)) {
+	if ( $filename =~ /^x_.*\.cpp$/ ) {
+		if ( $count++ == 7 ) {
+			$count = 0;
+			print MAKEFILE &quot; \\\n&quot;;
+		}
+		print MAKEFILE &quot; $filename&quot;;
+	}
+}
+
+print MAKEFILE &quot;\n&quot;;
+close MAKEFILE;
+closedir FILES;
+
+system &quot;cmp -s $tempfile $outdir/Makefile.am&quot;;
+if ($? &gt;&gt; 8) {
+    system &quot;cp -f $tempfile $outdir/Makefile.am&quot;;
+    print STDERR &quot;Makefile.am updated.\n&quot;;
+}
+else {
+    print STDERR &quot;Makefile.am unchanged.\n&quot;;
+}
+system &quot;rm -f $tempfile&quot;;
+
+exit 0;


Property changes on: trunk/smoke/qt/generate_makefile_am.pl
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/smoke/qt/header_list
===================================================================
--- trunk/smoke/qt/header_list	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/header_list	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,297 @@
+QtCore/qabstracteventdispatcher.h
+QtCore/qabstractfileengine.h
+QtCore/qabstractitemmodel.h
+QtCore/qalgorithms.h
+QtCore/qbasictimer.h
+QtCore/qbitarray.h
+QtCore/qbuffer.h
+QtCore/qbytearray.h
+QtCore/qbytearraymatcher.h
+QtCore/qcache.h
+QtCore/qchar.h
+QtCore/qconfig-dist.h
+QtCore/qconfig.h
+QtCore/qconfig-large.h
+QtCore/qconfig-medium.h
+QtCore/qconfig-minimal.h
+QtCore/qconfig-small.h
+QtCore/qcoreapplication.h
+QtCore/qcoreevent.h
+QtCore/qdatastream.h
+QtCore/qdatetime.h
+QtCore/qdebug.h
+QtCore/qdir.h
+QtCore/qeventloop.h
+QtCore/qfactoryinterface.h
+QtCore/qfeatures.h
+QtCore/qfile.h
+QtCore/qfileinfo.h
+QtCore/qfsfileengine.h
+QtCore/qglobal.h
+QtCore/qiodevice.h
+QtCore/qiterator.h
+QtCore/qlibrary.h
+QtCore/qlibraryinfo.h
+QtCore/qline.h
+QtCore/qlocale.h
+QtCore/qmap.h
+QtCore/qmetaobject.h
+QtCore/qmetatype.h
+QtCore/qmimedata.h
+QtCore/qmutex.h
+QtCore/qnamespace.h
+QtCore/qobjectcleanuphandler.h
+QtCore/qobjectdefs.h
+QtCore/qobject.h
+QtCore/qpair.h
+QtCore/qplugin.h
+QtCore/qpluginloader.h
+QtCore/qpointer.h
+QtCore/qpoint.h
+QtCore/qprocess.h
+QtCore/qqueue.h
+QtCore/qreadwritelock.h
+QtCore/qrect.h
+QtCore/qregexp.h
+QtCore/qsemaphore.h
+QtCore/qsettings.h
+QtCore/qshareddata.h
+QtCore/qsignalmapper.h
+QtCore/qsize.h
+QtCore/qsocketnotifier.h
+QtCore/qstack.h
+QtCore/qstring.h
+QtCore/qstringlist.h
+QtCore/qstringmatcher.h
+QtCore/qtemporaryfile.h
+QtCore/qtextcodec.h
+QtCore/qtextcodecplugin.h
+QtCore/qtextstream.h
+QtCore/qthread.h
+QtCore/qthreadstorage.h
+QtCore/qtimeline.h
+QtCore/qtimer.h
+QtCore/qtranslator.h
+QtCore/qurl.h
+QtCore/quuid.h
+QtCore/qvariant.h
+QtCore/qvarlengtharray.h
+QtCore/qvector.h
+QtCore/qwaitcondition.h
+QtGui/qabstractbutton.h
+QtGui/qabstractitemdelegate.h
+QtGui/qabstractitemview.h
+QtGui/qabstractpagesetupdialog.h
+QtGui/qabstractprintdialog.h
+QtGui/qabstractproxymodel.h
+QtGui/qabstractscrollarea.h
+QtGui/qabstractslider.h
+QtGui/qabstractspinbox.h
+QtGui/qabstracttextdocumentlayout.h
+QtGui/qaccessiblebridge.h
+QtGui/qaccessible.h
+QtGui/qaccessibleobject.h
+QtGui/qaccessibleplugin.h
+QtGui/qaccessiblewidget.h
+QtGui/qactiongroup.h
+QtGui/qaction.h
+QtGui/qapplication.h
+QtGui/qbitmap.h
+QtGui/qboxlayout.h
+QtGui/qbrush.h
+QtGui/qbuttongroup.h
+QtGui/qcalendarwidget.h
+QtGui/qcheckbox.h
+QtGui/qcleanlooksstyle.h
+QtGui/qclipboard.h
+QtGui/qcolordialog.h
+QtGui/qcolor.h
+QtGui/qcolormap.h
+QtGui/qcombobox.h
+QtGui/qcommonstyle.h
+QtGui/qcompleter.h
+QtGui/qcursor.h
+QtGui/qdatawidgetmapper.h
+QtGui/qdatetimeedit.h
+QtGui/qdesktopservices.h
+QtGui/qdesktopwidget.h
+QtGui/qdial.h
+QtGui/qdialogbuttonbox.h
+QtGui/qdialog.h
+QtGui/qdirmodel.h
+QtGui/qdockwidget.h
+QtGui/qdrag.h
+QtGui/qdrawutil.h
+QtGui/qerrormessage.h
+QtGui/qevent.h
+QtGui/qfiledialog.h
+QtGui/qfocusframe.h
+QtGui/qfontcombobox.h
+QtGui/qfontdatabase.h
+QtGui/qfontdialog.h
+QtGui/qfont.h
+QtGui/qfontinfo.h
+QtGui/qfontmetrics.h
+QtGui/qframe.h
+QtGui/qgraphicsitemanimation.h
+QtGui/qgraphicsitem.h
+QtGui/qgraphicssceneevent.h
+QtGui/qgraphicsscene.h
+QtGui/qgraphicsview.h
+QtGui/qgridlayout.h
+QtGui/qgroupbox.h
+QtGui/qhboxlayout.h
+QtGui/qheaderview.h
+QtGui/qiconengine.h
+QtGui/qiconengineplugin.h
+QtGui/qicon.h
+QtGui/qimage.h
+QtGui/qimageiohandler.h
+QtGui/qimagereader.h
+QtGui/qimagewriter.h
+QtGui/qinputcontextfactory.h
+QtGui/qinputcontext.h
+QtGui/qinputcontextplugin.h
+QtGui/qinputdialog.h
+QtGui/qitemdelegate.h
+QtGui/qitemeditorfactory.h
+QtGui/qitemselectionmodel.h
+QtGui/qkeysequence.h
+QtGui/qlabel.h
+QtGui/qlayout.h
+QtGui/qlayoutitem.h
+QtGui/qlcdnumber.h
+QtGui/qlineedit.h
+QtGui/qlistview.h
+QtGui/qlistwidget.h
+QtGui/qmacstyle.h
+QtGui/qmainwindow.h
+QtGui/qmatrix.h
+QtGui/qmenubar.h
+QtGui/qmenudata.h
+QtGui/qmenu.h
+QtGui/qmessageboxex.h
+QtGui/qmessagebox.h
+QtGui/qmime.h
+QtGui/qmovie.h
+QtGui/qpagesetupdialog.h
+QtGui/qpaintdevice.h
+QtGui/qpaintengine.h
+QtGui/qpainter.h
+QtGui/qpainterpath.h
+QtGui/qpalette.h
+QtGui/qpen.h
+QtGui/qpictureformatplugin.h
+QtGui/qpicture.h
+QtGui/qpixmapcache.h
+QtGui/qpixmap.h
+QtGui/qplastiquestyle.h
+QtGui/qpolygon.h
+QtGui/qprintdialog.h
+QtGui/qprintengine.h
+QtGui/qprinter.h
+QtGui/qprogressbar.h
+QtGui/qprogressdialog.h
+QtGui/qproxymodel.h
+QtGui/qpushbutton.h
+QtGui/qradiobutton.h
+QtGui/qregion.h
+QtGui/qrgb.h
+QtGui/qrubberband.h
+QtGui/qscrollarea.h
+QtGui/qscrollbar.h
+QtGui/qsessionmanager.h
+QtGui/qshortcut.h
+QtGui/qsizegrip.h
+QtGui/qsizepolicy.h
+QtGui/qslider.h
+QtGui/qsortfilterproxymodel.h
+QtGui/qsound.h
+QtGui/qspinbox.h
+QtGui/qsplashscreen.h
+QtGui/qsplitter.h
+QtGui/qstackedlayout.h
+QtGui/qstackedwidget.h
+QtGui/qstandarditemmodel.h
+QtGui/qstatusbar.h
+QtGui/qstringlistmodel.h
+QtGui/qstylefactory.h
+QtGui/qstyle.h
+QtGui/qstyleoption.h
+QtGui/qstylepainter.h
+QtGui/qstyleplugin.h
+QtGui/qsyntaxhighlighter.h
+QtGui/qsystemtrayicon.h
+QtGui/qtabbar.h
+QtGui/qtableview.h
+QtGui/qtablewidget.h
+QtGui/qtabwidget.h
+QtGui/qtextbrowser.h
+QtGui/qtextcursor.h
+QtGui/qtextdocumentfragment.h
+QtGui/qtextdocument.h
+QtGui/qtextedit.h
+QtGui/qtextformat.h
+QtGui/qtextlayout.h
+QtGui/qtextlist.h
+QtGui/qtextobject.h
+QtGui/qtextoption.h
+QtGui/qtexttable.h
+QtGui/qtoolbar.h
+QtGui/qtoolbox.h
+QtGui/qtoolbutton.h
+QtGui/qtooltip.h
+QtGui/qtreeview.h
+QtGui/qtreewidget.h
+QtGui/qtreewidgetitemiterator.h
+QtGui/qundogroup.h
+QtGui/qundostack.h
+QtGui/qundoview.h
+QtGui/qvalidator.h
+QtGui/qvboxlayout.h
+QtGui/qvfbhdr.h
+QtGui/qwhatsthis.h
+QtGui/qwidgetaction.h
+QtGui/qwidget.h
+QtGui/qwindowdefs.h
+QtGui/qwindowsstyle.h
+QtGui/qwindowsxpstyle.h
+QtGui/qwmatrix.h
+QtGui/qworkspace.h
+QtGui/qx11info_x11.h
+QtNetwork/qabstractsocket.h
+QtNetwork/qftp.h
+QtNetwork/qhostaddress.h
+QtNetwork/qhostinfo.h
+QtNetwork/qhttp.h
+QtNetwork/qnetworkinterface.h
+QtNetwork/qnetworkproxy.h
+QtNetwork/qtcpserver.h
+QtNetwork/qtcpsocket.h
+QtNetwork/qudpsocket.h
+QtNetwork/qurlinfo.h
+QtOpenGL/qglcolormap.h
+QtOpenGL/qglframebufferobject.h
+QtOpenGL/qgl.h
+QtOpenGL/qglpixelbuffer.h
+Qt/qiconset.h
+QtSql/qsqldatabase.h
+QtSql/qsqldriver.h
+QtSql/qsqldriverplugin.h
+QtSql/qsqlerror.h
+QtSql/qsqlfield.h
+QtSql/qsql.h
+QtSql/qsqlindex.h
+QtSql/qsqlquery.h
+QtSql/qsqlquerymodel.h
+QtSql/qsqlrecord.h
+QtSql/qsqlrelationaldelegate.h
+QtSql/qsqlrelationaltablemodel.h
+QtSql/qsqlrelation.h
+QtSql/qsqlresult.h
+QtSql/qsqltablemodel.h
+QtSvg/qsvgrenderer.h
+QtSvg/qsvgwidget.h
+QtUiTools/quiloader.h
+QtXml/qdom.h
+QtXml/qxml.h

Added: trunk/smoke/qt/hint_header_list.pl
===================================================================
--- trunk/smoke/qt/hint_header_list.pl	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/hint_header_list.pl	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,23 @@
+
+# CVS admin : run this script to compare the set of Qt headers to
+#             the actual content of header_list
+
+$l = &quot;header_list&quot;;
+$q = $ENV{'QTDIR'} || die &quot;QTDIR not set\n&quot;;
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at h</A> = &lt;$q/include/*.h&gt;;
+grep s|.*/(.*\.h)|$1|, @h;
+open(IN, $l) or die &quot;$!: $l\n&quot;;
<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">+ at old</A> = &lt;IN&gt;;
+chomp @old;
+map{ $h{$_}++ } @h;
+map{ $old{$_}++ } @old;
+map{ $diff{$_}++ unless $old{$_} } keys %h; 
+map{ delete $diff{$_} if /^qconfig.*/ or !/^q/ } keys %diff;
+print &quot;Check if any of the following headers should be added to $l:\n\n&quot;;
+print join &quot;\n&quot;, keys %diff,  &quot;\n&quot;
+
+
+
+
+
+

Added: trunk/smoke/qt/qscintilla_header_list
===================================================================
--- trunk/smoke/qt/qscintilla_header_list	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/qscintilla_header_list	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,22 @@
+qextscintilla.h
+qextscintillaapis.h
+qextscintillabase.h
+qextscintillacommand.h
+qextscintillacommandset.h
+qextscintilladocument.h
+qextscintillaglobal.h
+qextscintillalexer.h
+qextscintillalexerbash.h
+qextscintillalexercpp.h
+qextscintillalexercsharp.h
+qextscintillalexerhtml.h
+qextscintillalexeridl.h
+qextscintillalexerjava.h
+qextscintillalexerjavascript.h
+qextscintillalexerlua.h
+qextscintillalexerperl.h
+qextscintillalexerpython.h
+qextscintillalexerruby.h
+qextscintillalexersql.h
+qextscintillamacro.h
+qextscintillaprinter.h

Added: trunk/smoke/qt/qt_smoke.h
===================================================================
--- trunk/smoke/qt/qt_smoke.h	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/qt_smoke.h	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,9 @@
+#ifndef QT_SMOKE_H
+#define QT_SMOKE_H
+
+// Defined in smokedata.cpp, initialized by init_qt_Smoke(), used by all .cpp files
+extern Smoke* qt_Smoke;
+
+class QGlobalSpace { };
+
+#endif

Added: trunk/smoke/qt/qtdbus_header_list
===================================================================
--- trunk/smoke/qt/qtdbus_header_list	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/qtdbus_header_list	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,12 @@
+QtDBus/qdbusabstractadaptor.h
+QtDBus/qdbusabstractinterface.h
+QtDBus/qdbusconnection.h
+QtDBus/qdbusconnectioninterface.h
+QtDBus/qdbuserror.h
+QtDBus/qdbusextratypes.h
+QtDBus/qdbusinterface.h
+QtDBus/qdbusmacros.h
+QtDBus/qdbusmessage.h
+QtDBus/qdbusmetatype.h
+QtDBus/qdbusreply.h
+QtDBus/qdbusserver.h

Added: trunk/smoke/qt/qtguess.pl.in
===================================================================
--- trunk/smoke/qt/qtguess.pl.in	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/qtguess.pl.in	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,421 @@
+#!/usr/bin/perl
+
+# qtguess.pl : check how Qt was compiled. Issue a list of all defined QT_NO_* macros, one per line.
+#
+# author:  germain Garand &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">germain at ebooksfrance.com</A>&gt;
+# licence: GPL v.2
+
+# options: -q: be quieter
+#	   -o file: redirect output to &quot;file&quot;. (default: ./qtdefines)
+#	   -t [0..15]: set the testing threshold (see below)
+#	   -f &quot;flags&quot;: additional compiler flags/parameters
+
+use Getopt::Std;
+
+use vars qw/$opt_f $opt_o $opt_p/;
+
+getopts('qo:f:t:');
+
+# Threshold :
+#	 0 - test basic Qt types/classes
+#	 5 - test higher level, non-gui classes
+#	 8 - test options of the above (ex: QT_NO_IMAGE_SMOOTHSCALE)
+#	10 - test basic widgets
+#	12 - test composite widgets
+#	13 - test widgets inheriting composite widgets
+#	15 - test goodies (default)
+
+my $default_threshold = @qt_test_threshold@;
+my $cc = &quot;@CXX@&quot;;
+my $ccflags = $opt_f || &quot;@CXXFLAGS@&quot;;
+
+my $nspaces = 50;
+
+my %qtdefs=();
+my %qtundefs=();
+
+my $tmp = gettmpfile();
+my $qtinc = '@qt_includes@';
+my $allinc = '@all_includes@';
+my $alllib = '@all_libraries@';
+my $qtflags ='@LIB_QTCORE@ @LIB_QTGUI@ @LIB_QTNETWORK@ @LIB_QTXML@ @LIB_QTSQL@ @LIB_QTOPENGL@';
+my %x;
+$x{'LIBPNG'}  =   '@LIBPNG@';
+$x{'LIBJPEG'} =   '@LIBJPEG@';
+$x{'LIBSM'}   =   '@LIBSM@';
+$x{'LIBSOCKET'} = '@LIBSOCKET@';
+$x{'LIBDL'}      = '@LIBDL@';
+$x{'LIBRESOLV'}  = '@LIBRESOLV@';
+$x{'LIB_X11'} =   '@LIB_X11@';
+$x{'X_PRE_LIBS'} = '@X_PRE_LIBS@';
+$x{'LIB_X11'} =~ s/\$\((.*?)\)/$x{$1}/g;
+
+$qtflags =~ s/\$\((.*?)\)/$x{$1}/g;
+
+ -e &quot;$qtinc/QtCore/qglobal.h&quot; or die &quot;Invalid Qt include directory.\n&quot;;
+
+my $ccmd = &quot;$cc $ccflags $allinc $alllib -o $tmp $tmp.cpp $qtflags&quot;;
+
+my $threshold = defined($opt_t)?$opt_t : $default_threshold;
+$threshold &gt;= 0 or die &quot;invalid testing threshold: $threshold\n&quot;;
+
+print &quot;Checking how Qt was built... \n&quot;;
+print &quot;Threshold is set to $threshold\n&quot; unless $opt_q;
+
+my($count, $used, $total);
+map{ $tests{$_}-&gt;[2]&gt;=$threshold ? ($used++, $total++):$total++ } keys %tests;
+
+print &quot;Number of defines to be tested : $used/$total\n\n&quot; unless $opt_q;
+open( QTDEFS, &quot;&gt;&quot;.($opt_o || &quot;qtdefines&quot;) ) or die &quot;Can't open output file: $!\n&quot;;
+
+grab_qglobal_symbols();
+preliminary_test();
+perform_all_tests();
+
+print +scalar(keys %qtdefs) . &quot; defines found.\n&quot;;
+
+print QTDEFS join(&quot;\n&quot;, keys %qtdefs), &quot;\n&quot;;
+close;
+
+#--------------------------------------------------------------#
+
+sub gettmpfile
+{
+	my $tmpdir = $ENV{'TMP'} || &quot;.&quot;;
+	my $tmpname = $$.&quot;-qtguess&quot;;
+	while( -e &quot;$tmpdir/$tmpname&quot; || -e &quot;$tmpdir/${tmpname}.cpp&quot; )
+	{
+		$tmpname .= int (rand * 9);
+	}
+	return &quot;$tmpdir/$tmpname&quot;;
+}
+
+#--------------------------------------------------------------#
+
+sub grab_qglobal_symbols
+{
+	my $cmd = &quot;$cc -E -D__cplusplus -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2&gt;/dev/null&quot;;
+	my $symbols = `$cmd`;
+        for(0..1)
+        {
+	    if( check_exit_status($?) )
+	    {
+		while( $symbols =~/^#\s*define\s*(QT_\S+)/gm )
+		{
+			$qtdefs{$1} = 1;
+		}
+		print &quot;Found &quot;. scalar( keys %qtdefs ).&quot; predefined symbol&quot;.((scalar( keys %qtdefs ) -1)?&quot;s&quot;:&quot;&quot;).&quot; in qglobal.h\n&quot; unless ($opt_q or !(keys %qtdefs));
+		while( $symbols =~/^#\s*define\s*QT_MODULE_(\S+)/gm )
+		{
+			$qtundefs{&quot;QT_NO_$1&quot;} = 1;
+		}
+		print &quot;Found &quot;. scalar( keys %qtundefs ).&quot; undefined symbol&quot;.((scalar( keys %qtundefs ) -1)?&quot;s&quot;:&quot;&quot;).&quot; in qglobal.h\n&quot; unless ($opt_q or !(keys %qtundefs));
+                last;
+	    }
+	    elsif(! $_) # first try
+	    {
+		print  &quot;Failed to run $cmd.\nTrying without __cplusplus (might be already defined)\n&quot;;
+                $cmd = &quot;$cc -E -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2&gt;/dev/null&quot;;
+                $symbols = `$cmd`;
+                next;
+	    }
+        }
+}
+
+#--------------------------------------------------------------#
+
+sub preliminary_test
+{
+	my $msg = &quot;Trying to compile and link a small program...&quot;;
+	print $msg, &quot; &quot; x ($nspaces - length($msg) + 8);
+	open( OUT, &quot;&gt;${tmp}.cpp&quot; ) or die &quot;Failed to open temp file ${tmp}.cpp: $!\n&quot;;
+	my $simple=q&#163;
+		#include &lt;QtGui/qapplication.h&gt;
+		int main( int argc, char **argv )
+		{
+			QApplication foo( argc, argv );
+			return 0;
+		}
+	&#163;;
+	print OUT $simple;
+	close OUT;
+        my $out = `$ccmd 2&gt;&amp;1`;
+	if( !check_exit_status($?) )
+	{
+		die &lt;&lt;&quot;EOF&quot;;
+
+FAILED : check your configuration.
+Failed program was:
+$simple
+Compiled with:
+$ccmd
+Compiler output:
+$out
+EOF
+	}
+	else
+	{
+		print &quot;OK\n&quot;;
+	}
+}
+
+#--------------------------------------------------------------#
+
+sub perform_all_tests
+{
+	foreach ( sort { $tests{$a}-&gt;[2] &lt;=&gt; $tests{$b}-&gt;[2]} keys %tests)
+	{
+		$tests{$_}-&gt;[2] &lt; $threshold and next;
+		($qtdefs{$_} || $qtundefs{$_}) and do
+		{
+			print &quot;\rSkipping $_ (in qglobal.h)&quot;.( &quot; &quot; x (($nspaces-16) - length($_)) ).($qtundefs{$_}?&quot;*Undefined*&quot;:&quot; [Defined]&quot;).($opt_q?&quot;&quot;:&quot;\n&quot;);
+			next
+		};
+		print &quot;\rTesting $_&quot;.( &quot; &quot; x ($nspaces - length($_)) );
+		open( OUT, &quot;&gt;${tmp}.cpp&quot; ) or die &quot;Failed to open temp file ${tmp}.cpp: $!\n&quot;;
+		foreach $def(keys %qtdefs)
+		{
+			print OUT &quot;#define $def\n&quot;;
+		}
+		foreach $inc(split /,\s*/, $tests{$_}-&gt;[0])
+		{
+			print OUT &quot;#include &lt;$inc&gt;\n&quot;;
+		}
+		print OUT &quot;#include &lt;QtCore/qfeatures.h&gt;\n&quot;;
+		print OUT $tests{$_}-&gt;[3] if $tests{$_}-&gt;[3]; # need to define some classes ?
+		print OUT qq&#163;
+
+		int main( int argc, char ** argv)
+		{
+		$tests{$_}-&gt;[1]
+		return 0;
+		}
+
+		&#163;;
+		close OUT;
+
+                my $out = `$ccmd 2&gt;&amp;1`;
+		my $ok = check_exit_status($?);
+		if( !$ok )
+		{
+			$qtdefs{$_} = 1;
+		}
+		print +$opt_q ? ++$count.&quot;/$used&quot; : ( $ok ? &quot;*Undefined*\n&quot; : &quot; [Defined]\n&quot; );
+	}
+	$opt_q &amp;&amp; print &quot;\n&quot;;
+}
+
+#--------------------------------------------------------------#
+
+sub check_exit_status
+{
+	my $a = 0xFFFF &amp; shift;
+	if( !$a )
+	{
+		return 1;
+	}
+	elsif( $a == 0xFF00 )
+	{
+		die &quot;\nSystem call failed: $!\n&quot;;
+	}
+	elsif( $a &gt; 0x80 )
+	{
+		# non-zero status.
+	}
+	else
+	{
+		if( $a &amp; 0x80 )
+		{
+			die &quot;\n$cc coredumped with signal &quot;. ($a &amp; ~0x80);
+		}
+		die &quot;\n$cc interrupted by signal $a\n&quot;;
+	}
+	return 0;
+}
+
+#--------------------------------------------------------------#
+
+END
+{
+	unlink $tmp if -e $tmp;
+	unlink &quot;${tmp}.cpp&quot; if -e &quot;${tmp}.cpp&quot;;
+}
+
+#--------------------------------------------------------------#
+
+BEGIN {
+
+# &quot;DEFINE&quot; =&gt; [&quot;header-1.h,... header-n.h&quot;, &quot;main() code&quot;, priority, &quot;Definitions (if needed)&quot;]
+
+our %tests = (
+	&quot;QT_NO_ACCESSIBILITY&quot; =&gt;        [&quot;QtGui/qaccessible.h&quot;, &quot;QAccessibleEvent event(QEvent::AccessibilityHelp, 0);&quot;, 15],
+	&quot;QT_NO_ACTION&quot; =&gt;		[&quot;QtGui/qaction.h&quot;, &quot;QAction foo( (QObject*)NULL );&quot;, 5],
+	#QT_NO_BIG_CODECS
+ 	&quot;QT_NO_BUTTONGROUP&quot; =&gt;		[&quot;QtGui/qbuttongroup.h&quot;, &quot;QButtonGroup foo( (QObject*)NULL );&quot;, 12],
+ 	&quot;QT_NO_CHECKBOX&quot; =&gt;		[&quot;QtGui/qcheckbox.h&quot;, &quot;QCheckBox foo( (QWidget*)NULL );&quot;, 10],
+	&quot;QT_NO_CLIPBOARD&quot; =&gt; 		[&quot;QtGui/qapplication.h, QtGui/qclipboard.h&quot;, q&#163;
+						QApplication foo( argc, argv );
+						QClipboard *baz= foo.clipboard();
+					&#163;, 5],
+ 	&quot;QT_NO_COLORDIALOG&quot; =&gt;		[&quot;QtGui/qcolordialog.h&quot;, &quot;QColorDialog::customCount();&quot;, 12],
+	#QT_NO_COLORNAMES
+ 	&quot;QT_NO_COMBOBOX&quot; =&gt;		[&quot;QtGui/qcombobox.h&quot;, &quot;QComboBox foo( (QWidget*)NULL );&quot;, 10],
+	&quot;QT_NO_COMPAT&quot; =&gt;		[&quot;QtGui/qfontmetrics.h&quot;, q&#163;
+						QFontMetrics *foo= new QFontMetrics( QFont() );
+						int bar = foo-&gt;width( 'c' );
+					&#163;, 0],
+	&quot;QT_NO_COMPONENT&quot; =&gt;		[&quot;QtGui/qapplication.h&quot;, q&#163;
+ 						QApplication foo( argc, argv );
+ 						foo.addLibraryPath( QString::null );
+					&#163;, 5],
+	#QT_NO_COP
+ 	&quot;QT_NO_CURSOR&quot; =&gt;		[&quot;QtGui/qcursor.h&quot;, &quot;QCursor foo;&quot;, 5],
+ 	&quot;QT_NO_DATASTREAM&quot; =&gt;		[&quot;QtCore/qdatastream.h&quot;, &quot;QDataStream foo;&quot;, 5],
+ 	&quot;QT_NO_DATETIMEEDIT&quot; =&gt;		[&quot;QtGui/qdatetimeedit.h&quot;, &quot;QTimeEdit foo;&quot;, 12],
+	&quot;QT_NO_DIAL&quot; =&gt;			[&quot;QtGui/qdial.h&quot;, &quot;QDial foo;&quot;, 10],
+	&quot;QT_NO_DIALOG&quot; =&gt;		[&quot;QtGui/qdialog.h&quot;, &quot;QDialog foo;&quot;, 12],
+	&quot;QT_NO_DIR&quot; =&gt;			[&quot;QtCore/qdir.h&quot;, &quot;QDir foo;&quot;, 5],
+	#QT_NO_DIRECTPAINTER
+	&quot;QT_NO_DOM&quot; =&gt;			[&quot;QtXml/qdom.h&quot;, &quot;QDomDocumentType foo;&quot;, 5],
+	&quot;QT_NO_DRAGANDDROP&quot; =&gt;		[&quot;QtGui/qevent.h&quot;, &quot;QDropEvent foo( QDropEvent() );&quot;, 5],
+	&quot;QT_NO_DRAWUTIL&quot; =&gt;		[&quot;QtGui/qdrawutil.h, QtGui/qcolor.h&quot;, &quot;qDrawPlainRect( (QPainter *) NULL, 0, 0, 0, 0, QColor() );&quot;, 10],
+	#QT_NO_EFFECTS
+	&quot;QT_NO_ERRORMESSAGE&quot; =&gt; 	[&quot;QtGui/qerrormessage.h&quot;, &quot;QErrorMessage foo( (QWidget*) NULL );&quot;, 13],
+	&quot;QT_NO_FILEDIALOG&quot; =&gt;		[&quot;QtGui/qfiledialog.h&quot;, &quot;QFileDialog foo();&quot;, 13],
+
+	&quot;QT_NO_FONTDATABASE&quot; =&gt;		[&quot;QtGui/qfontdatabase.h&quot;, &quot;QFontDatabase foo;&quot;, 5],
+	&quot;QT_NO_FONTDIALOG&quot; =&gt; 		[&quot;QtGui/qfontdialog.h&quot;,   &quot;QFontDialog::getFont( (bool *)NULL );&quot;, 12],
+	&quot;QT_NO_FRAME&quot; =&gt; 		[&quot;QtGui/qframe.h&quot;, &quot;QFrame foo;&quot;, 10],
+	#QT_NO_FREETYPE
+ 	&quot;QT_NO_FTP&quot; =&gt;	[&quot;QtNetwork/qftp.h&quot;, &quot;QFtp foo;&quot;, 9],
+	&quot;QT_NO_GROUPBOX&quot; =&gt;		[&quot;QtGui/qgroupbox.h&quot;, &quot;QGroupBox foo;&quot;, 12],
+	#QT_NO_IMAGEFORMAT_BMP
+	#QT_NO_IMAGEFORMAT_JPEG
+	#QT_NO_IMAGEFORMATPLUGIN
+	#QT_NO_IMAGEFORMAT_PNG
+	#QT_NO_IMAGEFORMAT_PPM
+	#QT_NO_IMAGEFORMAT_XBM
+ 	&quot;QT_NO_IMAGE_HEURISTIC_MASK&quot; =&gt;	[&quot;QtGui/qimage.h&quot;, q&#163;
+						QImage *foo = new QImage;
+						foo-&gt;createHeuristicMask();
+					&#163;, 8],
+	#QT_NO_IMAGE_TEXT
+	&quot;QT_NO_IMAGEIO&quot; =&gt; 		[&quot;QtGui/qbitmap.h, QtCore/qstring.h&quot;, q&#163;
+						QBitmap foo( QString::fromLatin1(&quot;foobar&quot;) );
+					&#163;, 5],
+	&quot;QT_NO_LABEL&quot; =&gt;		[&quot;QtGui/qlabel.h&quot;, &quot;QLabel foo( (QWidget*) NULL );&quot;, 10],
+	&quot;QT_NO_LAYOUT&quot; =&gt;		[&quot;QtGui/qlayout.h&quot;, &quot;QFoo foo;&quot;, 10, q&#163;
+ 						class QFoo: public QLayout
+ 						{
+ 						public:
+ 						    QFoo() {};
+ 						    ~QFoo() {};
+ 						    void addItem( QLayoutItem * ) { };
+						    QSize sizeHint() const { return QSize(); }
+						    void setGeometry( const QRect &amp; ) { };
+                            QLayoutItem* itemAt(int) const {return (QLayoutItem*) NULL;}
+                            QLayoutItem* takeAt(int) {return (QLayoutItem*) NULL;}
+                            int QFoo::count() const {return 0;}
+
+ 						};
+ 					&#163;],
+	&quot;QT_NO_LCDNUMBER&quot; =&gt;		[&quot;QtGui/qlcdnumber.h&quot;, &quot;QLCDNumber foo;&quot;, 12],
+	&quot;QT_NO_LINEEDIT&quot; =&gt;		[&quot;QtGui/qlineedit.h&quot;, &quot;QLineEdit foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_LISTVIEW&quot; =&gt;		[&quot;QtGui/qlistview.h&quot;, &quot;QListView foo;&quot;, 13],
+	&quot;QT_NO_MAINWINDOW&quot; =&gt;		[&quot;QtGui/qmainwindow.h&quot;, &quot;QMainWindow foo;&quot;, 13],
+	&quot;QT_NO_MATRIX&quot; =&gt;		[&quot;QtGui/qmatrix.h&quot;, &quot;QMatrix foo;&quot;, 0],
+	&quot;QT_NO_MENUBAR&quot; =&gt;		[&quot;QtGui/qmenubar.h&quot;, &quot;QMenuBar foo;&quot;, 13],
+	&quot;QT_NO_MESSAGEBOX&quot; =&gt;		[&quot;QtGui/qmessagebox.h&quot;, &quot;QMessageBox foo;&quot;, 13],
+	&quot;QT_NO_MOVIE&quot; =&gt;		[&quot;QtGui/qmovie.h&quot;, &quot;QMovie foo;&quot;, 5],
+	&quot;QT_NO_NETWORK&quot; =&gt;		[&quot;QtNetwork/qnetworkproxy.h&quot;, &quot;QNetworkProxy foo;&quot;, 5],
+	#QT_NO_NETWORKPROXY
+	&quot;QT_NO_PALETTE&quot; =&gt;		[&quot;QtGui/qpalette.h&quot;, &quot;QPalette foo;&quot;, 5],
+	&quot;QT_NO_PICTURE&quot; =&gt;		[&quot;QtGui/qpicture.h&quot;, &quot;QPicture foo;&quot;, 5],
+	&quot;QT_NO_PRINTER&quot; =&gt;		[&quot;QtGui/qprinter.h&quot;, &quot;QPrinter foo();&quot;, 5],
+	&quot;QT_NO_PRINTDIALOG&quot; =&gt;		[&quot;QtGui/qprintdialog.h&quot;, &quot;QPrintDialog foo( (QPrinter*) NULL );&quot;, 13],
+	&quot;QT_NO_PROCESS&quot; =&gt;		[&quot;QtCore/qprocess.h&quot;, &quot;QProcess foo;&quot;, 5],
+	&quot;QT_NO_PROGRESSBAR&quot; =&gt;		[&quot;QtGui/qprogressbar.h&quot;, &quot;QProgressBar foo;&quot;, 12],
+	&quot;QT_NO_PROGRESSDIALOG&quot; =&gt;	[&quot;QtGui/qprogressdialog.h&quot;, &quot;QProgressDialog foo;&quot;, 13],
+	&quot;QT_NO_PROPERTIES&quot; =&gt;		[&quot;QtCore/qmetaobject.h&quot;, &quot;QMetaProperty foo;&quot;, 0],
+	&quot;QT_NO_PUSHBUTTON&quot; =&gt;		[&quot;QtGui/qpushbutton.h&quot;, &quot;QPushButton foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_QUUID_STRING&quot; =&gt;		[&quot;QtCore/quuid.h&quot;, &quot;QUuid foo( QString() );&quot;, 8],
+	&quot;QT_NO_RADIOBUTTON&quot; =&gt;		[&quot;QtGui/qradiobutton.h&quot;, &quot;QRadioButton foo( (QWidget *) NULL );&quot;, 12],
+	#QT_NO_QWS_ALPHA_CURSOR
+	#QT_NO_QWS_DECORATION_DEFAULT
+	#QT_NO_QWS_INPUTMETHODS
+	#QT_NO_QWS_KEYBOARD
+	#QT_NO_QWS_MOUSE
+	#QT_NO_QWS_MOUSE_AUTO
+	#QT_NO_QWS_MOUSE_MANUAL
+	#QT_NO_QWS_MULTIPROCESS
+	#QT_NO_QWS_PROPERTIES
+	#QT_NO_QWS_QPF
+	#QT_NO_RESIZEHANDLER
+	#QT_NO_RUBBERBAND
+	&quot;QT_NO_SCROLLBAR&quot; =&gt;		[&quot;QtGui/qscrollbar.h&quot;, &quot;QScrollBar foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_SESSIONMANAGER&quot; =&gt;	[&quot;QtGui/qapplication.h&quot;, q&#163;
+  						QApplication foo( argc, argv );
+  						foo.sessionId();
+					&#163;, 15],
+	&quot;QT_NO_SETTINGS&quot; =&gt;		[&quot;QtCore/qsettings.h&quot;, &quot;QSettings foo;&quot;, 5],
+	#QT_NO_SHORTCUT
+	&quot;QT_NO_SIGNALMAPPER&quot; =&gt;		[&quot;QtCore/qsignalmapper.h&quot;, &quot;QSignalMapper foo( (QObject *) NULL );&quot;, 0],
+	&quot;QT_NO_SIZEGRIP&quot; =&gt;		[&quot;QtGui/qsizegrip.h&quot;, &quot;QSizeGrip foo( (QWidget *) NULL );&quot;, 10],
+	&quot;QT_NO_SLIDER&quot; =&gt;		[&quot;QtGui/qslider.h&quot;, &quot;QSlider foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_SOUND&quot; =&gt;		[&quot;QtGui/qsound.h&quot;, &quot;QSound foo( QString::null );&quot;, 5],
+	#QT_NO_SPINWIDGET
+	#QT_NO_SPLASHSCREEN
+	#QT_NO_STACKEDWIDGET
+	#QT_NO_STATUSBAR
+	#QT_NO_STATUSTIP
+	#QT_NO_STL
+	&quot;QT_NO_STRINGLIST&quot; =&gt;		[&quot;qstringlist.h&quot;, &quot;QStringList foo;&quot;, 0],
+	&quot;QT_NO_STYLE_PLASTIQUE&quot; =&gt;		[&quot;QtGui/qplastiquestyle.h&quot;, &quot;QPlastiqueStyle foo;&quot;, 16],
+ 	&quot;QT_NO_STYLE_WINDOWSXP&quot; =&gt;	[&quot;QtGui/qwindowsxpstyle.h&quot;, &quot;QWindowsXPStyle foo;&quot;, 16],
+ 	&quot;QT_NO_STYLE_WINDOWS&quot; =&gt;	[&quot;QtGui/qwindowsstyle.h&quot;, &quot;QWindowsStyle foo;&quot;, 16],
+	&quot;QT_NO_STYLE_MAC&quot; =&gt;	[&quot;QtGui/macstyle.h&quot;, &quot;QMacStyle foo;&quot;, 16],
+    &quot;QT_NO_TABBAR&quot; =&gt;               [&quot;QtGui/qtabbar.h&quot;, &quot;QTabBar foo;&quot;, 10],
+	&quot;QT_NO_TABLEVIEW&quot; =&gt;		[&quot;QtGui/qtableview.h&quot;, &quot;QTableView foo;&quot;, 16],
+    &quot;QT_NO_TABWIDGET&quot; =&gt;            [&quot;QtGui/qtabwidget.h&quot;, &quot;QTabWidget foo;&quot;, 10],
+    &quot;QT_NO_TEXTBROWSER&quot; =&gt;          [&quot;QtGui/qtextbrowser.h&quot;, &quot;QTextBrowser foo;&quot;, 14],
+    &quot;QT_NO_TEXTCODEC&quot; =&gt;            [&quot;QtCore/qtextcodec.h&quot;, &quot;QTextCodec::codecForMib(1);&quot;, 5],
+    &quot;QT_NO_TEXTCODECPLUGIN&quot; =&gt;      [&quot;QtCore/qtextcodecplugin.h, QtCore/qstringlist.h, QtCore/qlist.h, QtCore/qtextcodec.h&quot;, &quot;QFoo foo;&quot;, 6, q&#163; 
+						class QFoo: public QTextCodecPlugin
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            QList&lt;QByteArray&gt; names() const {return QList&lt;QByteArray&gt;();}
+                            QList&lt;int&gt;mibEnums() const {return QList&lt;int&gt;();}
+                            QTextCodec *createForName( const QByteArray &amp; name ) {return (QTextCodec *)NULL;}
+                            QTextCodec *createForMib( int mib ) {return (QTextCodec *)NULL;}
+                            QList&lt;QByteArray&gt; aliases() const {return QList&lt;QByteArray&gt;();}
+						};
+						Q_EXPORT_PLUGIN2( &quot;Foo&quot;, QFoo )
+					&#163;],
+	#QT_NO_TEXTDATE
+ 	&quot;QT_NO_TEXTEDIT&quot; =&gt;		[&quot;QtGui/qtextedit.h&quot;, &quot;QTextEdit foo;&quot;, 13], 
+    &quot;QT_NO_TEXTSTREAM&quot; =&gt;           [&quot;qtextstream.h&quot;, &quot;QTextStream foo;&quot;, 5],
+    &quot;QT_NO_THREAD&quot; =&gt;           [&quot;QtCore/qthread.h&quot;, &quot;QFoo foo;&quot;, 5, q&#163;
+						class QFoo: public QThread
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            void run() {}
+						};
+					&#163;],
+    &quot;QT_NO_TOOLBAR&quot; =&gt;              [&quot;QtGui/qtoolbar.h&quot;, &quot;QToolBar foo;&quot;, 10],
+    &quot;QT_NO_TOOLBUTTON&quot; =&gt;           [&quot;QtGui/qtoolbutton.h&quot;, &quot;QToolButton foo((QWidget *) NULL );&quot;, 12],
+    &quot;QT_NO_TOOLTIP&quot; =&gt;              [&quot;QtGui/qtooltip.h&quot;, &quot;QToolTip::palette();&quot;, 10],
+	#QT_NO_TRANSLATION
+	#QT_NO_UDPSOCKET
+	#QT_NO_URLINFO
+	#QT_NO_VALIDATOR
+    &quot;QT_NO_VARIANT&quot; =&gt;              [&quot;QtCore/qvariant.h&quot;, &quot;QVariant foo;&quot;, 0],
+    &quot;QT_NO_WHATSTHIS&quot; =&gt;            [&quot;QtGui/qwhatsthis.h&quot;, &quot;QWhatsThis::inWhatsThisMode();&quot;, 10],
+	&quot;QT_NO_WHEELEVENT&quot; =&gt;		[&quot;QtGui/qevent.h&quot;, &quot;QWheelEvent foo( QPoint(1,1), 1, (Qt::MouseButtons)1, 0 );&quot;, 5],
+	&quot;QT_NO_XML&quot; =&gt;			[&quot;QtXml/qxml.h&quot;, &quot;QXmlNamespaceSupport foo;&quot;, 5],
+	);
+
+}

Added: trunk/smoke/qt/qwt_header_list
===================================================================
--- trunk/smoke/qt/qwt_header_list	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/qwt_header_list	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,55 @@
+qwt_abstract_scale_draw.h
+qwt_abstract_scale.h
+qwt_abstract_slider.h
+qwt_analog_clock.h
+qwt_array.h
+qwt_arrow_button.h
+qwt_compass.h
+qwt_compass_rose.h
+qwt_counter.h
+qwt_data.h
+qwt_dial.h
+qwt_dial_needle.h
+qwt_double_interval.h
+qwt_double_range.h
+qwt_double_rect.h
+qwt_dyngrid_layout.h
+qwt_event_pattern.h
+qwt_global.h
+qwt.h
+qwt_interval_data.h
+qwt_knob.h
+qwt_layout_metrics.h
+qwt_legend.h
+qwt_legend_item.h
+qwt_math.h
+qwt_paint_buffer.h
+qwt_painter.h
+qwt_picker.h
+qwt_picker_machine.h
+qwt_plot_canvas.h
+qwt_plot_curve.h
+qwt_plot_dict.h
+qwt_plot_grid.h
+qwt_plot.h
+qwt_plot_item.h
+qwt_plot_layout.h
+qwt_plot_marker.h
+qwt_plot_picker.h
+qwt_plot_printfilter.h
+qwt_plot_zoomer.h
+qwt_rect.h
+qwt_round_scale_draw.h
+qwt_scale_div.h
+qwt_scale_draw.h
+qwt_scale_engine.h
+qwt_scale_map.h
+qwt_scale_widget.h
+qwt_slider.h
+qwt_spline.h
+qwt_symbol.h
+qwt_text_engine.h
+qwt_text.h
+qwt_text_label.h
+qwt_thermo.h
+qwt_wheel.h

Added: trunk/smoke/qt/smokeqt.pro
===================================================================
--- trunk/smoke/qt/smokeqt.pro	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qt/smokeqt.pro	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,34 @@
+######################################################################
+# Automatically generated by qmake (2.00a) lun 17. abr 22:10:08 2006
+######################################################################
+
+QT += network xml sql opengl
+TEMPLATE = lib
+TARGET += 
+DEPENDPATH += .
+INCLUDEPATH += .
+INCLUDEPATH += ..
+
+# Input
+HEADERS += qt_smoke.h
+SOURCES += smokedata.cpp \
+           x_1.cpp \
+           x_10.cpp \
+           x_11.cpp \
+           x_12.cpp \
+           x_13.cpp \
+           x_14.cpp \
+           x_15.cpp \
+           x_16.cpp \
+           x_17.cpp \
+           x_18.cpp \
+           x_19.cpp \
+           x_2.cpp \
+           x_20.cpp \
+           x_3.cpp \
+           x_4.cpp \
+           x_5.cpp \
+           x_6.cpp \
+           x_7.cpp \
+           x_8.cpp \
+           x_9.cpp

Added: trunk/smoke/qwidgetitemdata_p.h
===================================================================
--- trunk/smoke/qwidgetitemdata_p.h	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/qwidgetitemdata_p.h	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,70 @@
+/****************************************************************************
+**
+** Copyright (C) 1992-2005 Trolltech AS. All rights reserved.
+**
+** This file is part of the item views module of the Qt Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** See <A HREF="http://www.trolltech.com/pricing.html">http://www.trolltech.com/pricing.html</A> or email <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">sales at trolltech.com</A> for
+**   information about Qt Commercial License Agreements.
+** See <A HREF="http://www.trolltech.com/qpl/">http://www.trolltech.com/qpl/</A> for QPL licensing information.
+** See <A HREF="http://www.trolltech.com/gpl/">http://www.trolltech.com/gpl/</A> for GPL licensing information.
+**
+** Contact <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">info at trolltech.com</A> if any conditions of this licensing are
+** not clear to you.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+****************************************************************************/
+
+#ifndef QWIDGETITEMDATA_P_H
+#define QWIDGETITEMDATA_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+class QWidgetItemData
+{
+public:
+    QWidgetItemData() : role(-1) {}
+    QWidgetItemData(int r, QVariant v) : role(r), value(v) {}
+    int role;
+    QVariant value;
+};
+
+#ifndef QT_NO_DATASTREAM
+
+inline QDataStream &amp;operator&gt;&gt;(QDataStream &amp;in, QWidgetItemData &amp;data)
+{
+    in &gt;&gt; data.role;
+    in &gt;&gt; data.value;
+    return in;
+}
+
+inline QDataStream &amp;operator&lt;&lt;(QDataStream &amp;out, const QWidgetItemData &amp;data)
+{
+    out &lt;&lt; data.role;
+    out &lt;&lt; data.value;
+    return out;
+}
+
+#endif
+
+#endif // QWIDGETITEMDATA_P_H

Added: trunk/smoke/smoke.h
===================================================================
--- trunk/smoke/smoke.h	2006-07-22 16:44:23 UTC (rev 271)
+++ trunk/smoke/smoke.h	2006-07-23 16:24:10 UTC (rev 272)
@@ -0,0 +1,386 @@
+#ifndef SMOKE_H
+#define SMOKE_H
+
+#include &lt;string.h&gt;
+
+/*
+   Copyright (C) 2002, Ashley Winters &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">qaqortog at nwlink.com</A>&gt;
+
+    BSD License
+
+    Redistribution and use in source and binary forms, with or
+      without modification, are permitted provided that the following
+      conditions are met:
+
+    Redistributions of source code must retain the above
+      copyright notice, this list of conditions and the following disclaimer.
+
+    Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials
+      provided with the distribution.&gt;
+
+    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
+    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+    PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR
+    BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+    TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+    THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+class SmokeBinding;
+
+class Smoke {
+public:
+    union StackItem; // defined below
+    /**
+     * A stack is an array of arguments, passed to a method when calling it.
+     */
+    typedef StackItem* Stack;
+
+    enum EnumOperation {
+	EnumNew,
+	EnumDelete,
+	EnumFromLong,
+	EnumToLong
+    };
+
+    typedef short Index;
+    typedef void (*ClassFn)(Index method, void* obj, Stack args);
+    typedef void* (*CastFn)(void* obj, Index from, Index to);
+    typedef void (*EnumFn)(EnumOperation, Index, void*&amp;, long&amp;);
+
+    enum ClassFlags {
+        cf_constructor = 0x01,  // has a constructor
+        cf_deepcopy = 0x02,     // has copy constructor
+        cf_virtual = 0x04,      // has virtual destructor
+        cf_undefined = 0x10     // defined elsewhere
+    };
+    /**
+     * Describe one class.
+     */
+    struct Class {
+	const char *className;	// Name of the class
+	Index parents;		// Index into inheritanceList
+	ClassFn classFn;	// Calls any method in the class
+	EnumFn enumFn;		// Handles enum pointers
+        unsigned short flags;   // ClassFlags
+    };
+
+    enum MethodFlags {
+        mf_static = 0x01,
+        mf_const = 0x02,
+        mf_copyctor = 0x04,  // Copy constructor
+        mf_internal = 0x08,   // For internal use only
+        mf_enum = 0x10,   // An enum value
+        mf_ctor = 0x20,
+        mf_dtor = 0x40,
+        mf_protected = 0x80
+    };
+    /**
+     * Describe one method of one class.
+     */
+    struct Method {
+	Index classId;		// Index into classes
+	Index name;		// Index into methodNames; real name
+	Index args;		// Index into argumentList
+	unsigned char numArgs;	// Number of arguments
+	unsigned char flags;	// MethodFlags (const/static/etc...)
+	Index ret;		// Index into types for the return type
+	Index method;		// Passed to Class.classFn, to call method
+    };
+
+    /**
+     * One MethodMap entry maps the munged method prototype
+     * to the Method entry.
+     *
+     * The munging works this way:
+     * $ is a plain scalar
+     * # is an object
+     * ? is a non-scalar (reference to array or hash, undef)
+     *
+     * e.g. QApplication(int &amp;, char **) becomes QApplication$?
+     */
+    struct MethodMap {
+	Index classId;		// Index into classes
+	Index name;		// Index into methodNames; munged name
+	Index method;		// Index into methods
+    };
+
+    enum TypeFlags {
+        // The first 4 bits indicate the TypeId value, i.e. which field
+        // of the StackItem union is used.
+        tf_elem = 0x0F,
+
+	// Always only one of the next three flags should be set
+	tf_stack = 0x10, 	// Stored on the stack, 'type'
+	tf_ptr = 0x20,   	// Pointer, 'type*'
+	tf_ref = 0x30,   	// Reference, 'type&amp;'
+	// Can | whatever ones of these apply
+	tf_const = 0x40		// const argument
+    };
+    /**
+     * One Type entry is one argument type needed by a method.
+     * Type entries are shared, there is only one entry for &quot;int&quot; etc.
+     */
+    struct Type {
+	const char *name;	// Stringified type name
+	Index classId;		// Index into classes. -1 for none
+        unsigned short flags;   // TypeFlags
+    };
+
+    // We could just pass everything around using void* (pass-by-reference)
+    // I don't want to, though. -aw
+    union StackItem {
+	void* s_voidp;
+	bool s_bool;
+	signed char s_char;
+	unsigned char s_uchar;
+	short s_short;
+	unsigned short s_ushort;
+	int s_int;
+	unsigned int s_uint;
+	long s_long;
+	unsigned long s_ulong;
+	float s_float;
+	double s_double;
+        long s_enum;
+        void* s_class;
+    };
+    enum TypeId {
+	t_voidp,
+	t_bool,
+	t_char,
+	t_uchar,
+	t_short,
+	t_ushort,
+	t_int,
+	t_uint,
+	t_long,
+	t_ulong,
+	t_float,
+	t_double,
+        t_enum,
+        t_class,
+	t_last		// number of pre-defined types
+    };
+
+    // Passed to constructor
+    /**
+     * The classes array defines every class for this module
+     */
+    Class *classes;
+    Index numClasses;
+
+    /**
+     * The methods array defines every method in every class for this module
+     */
+    Method *methods;
+    Index numMethods;
+
+    /**
+     * methodMaps maps the munged method prototypes
+     * to the methods entries.
+     */
+    MethodMap *methodMaps;
+    Index numMethodMaps;
+
+    /**
+     * Array of method names, for Method.name and MethodMap.name
+     */
+    const char **methodNames;
+    Index numMethodNames;
+
+    /**
+     * List of all types needed by the methods (arguments and return values)
+     */
+    Type *types;
+    Index numTypes;
+
+    /**
+     * Groups of class IDs (-1 separated) used as super class lists.
+     * For classes with super classes: Class.parents = index into this array.
+     */
+    Index *inheritanceList;
+    /**
+     * Groups of type IDs (-1 separated), describing the types of argument for a method.
+     * Method.args = index into this array.
+     */
+    Index *argumentList;
+    /**
+     * Groups of method prototypes with the same number of arguments, but different types.
+     * Used to resolve overloading.
+     */
+    Index *ambiguousMethodList;
+    /**
+     * Function used for casting from/to the classes defined by this module.
+     */
+    CastFn castFn;
+
+    // Not passed to constructor
+    SmokeBinding *binding;
+
+    /**
+     * Constructor
+     */
+    Smoke(Class *_classes, Index _numClasses,
+	  Method *_methods, Index _numMethods,
+	  MethodMap *_methodMaps, Index _numMethodMaps,
+	  const char **_methodNames, Index _numMethodNames,
+	  Type *_types, Index _numTypes,
+	  Index *_inheritanceList,
+	  Index *_argumentList,
+	  Index *_ambiguousMethodList,
+	  CastFn _castFn) :
+		classes(_classes), numClasses(_numClasses),
+		methods(_methods), numMethods(_numMethods),
+		methodMaps(_methodMaps), numMethodMaps(_numMethodMaps),
+		methodNames(_methodNames), numMethodNames(_numMethodNames),
+		types(_types), numTypes(_numTypes),
+		inheritanceList(_inheritanceList),
+		argumentList(_argumentList),
+		ambiguousMethodList(_ambiguousMethodList),
+		castFn(_castFn),
+
+		binding(0)
+		{}
+
+    inline void *cast(void *ptr, Index from, Index to) {
+	if(!castFn) return ptr;
+	return (*castFn)(ptr, from, to);
+    }
+
+    // return classname directly
+    inline const char *className(Index classId) {
+	return classes[classId].className;
+    }
+
+    inline int leg(Index a, Index b) {  // ala Perl's &lt;=&gt;
+	if(a == b) return 0;
+	return (a &gt; b) ? 1 : -1;
+    }
+
+    inline Index idType(const char *t) {
+	if(!t) return 0;
+	Index imax = numTypes;
+	Index imin = 0;
+	Index icur = -1;
+	int icmp = -1;
+
+	while(imax &gt;= imin) {
+	    icur = (imin + imax) / 2;
+	    if(icur &gt; 0)
+		icmp = strcmp(types[icur].name, t);
+	    else
+		icmp = -1;
+	    if(!icmp) break;
+	    if(icmp &gt; 0)
+		imax = icur - 1;
+	    else
+		imin = icur + 1;
+	}
+
+	return (!icmp) ? icur : 0;
+    }
+
+    inline Index idClass(const char *c) {
+	if(!c) return 0;
+	Index imax = numClasses;
+	Index imin = 0;
+	Index icur = -1;
+	int icmp = -1;
+
+	while(imax &gt;= imin) {
+	    icur = (imin + imax) / 2;
+	    if(icur &gt; 0)
+		icmp = strcmp(classes[icur].className, c);
+	    else
+		icmp = -1;
+	    if(!icmp) break;
+	    if(icmp &gt; 0)
+		imax = icur - 1;
+	    else
+		imin = icur + 1;
+	}
+
+	return (!icmp) ? icur : 0;
+    }
+
+    inline Index idMethodName(const char *m) {
+	if(!m) return 0;
+	Index imax = numMethodNames;
+	Index imin = 0;
+	Index icur = -1;
+	int icmp = -1;
+	while(imax &gt;= imin) {
+	    icur = (imin + imax) / 2;
+	    icmp = strcmp(methodNames[icur], m);
+	    if(!icmp) break;
+	    if(icmp &gt; 0)
+		imax = icur - 1;
+	    else
+		imin = icur + 1;
+	}
+
+	return (!icmp) ? icur : 0;
+    }
+
+    inline Index idMethod(Index c, Index name) {
+	Index imax = numMethodMaps;
+	Index imin = 0;
+	Index icur = -1;
+	int icmp = -1;
+	while(imax &gt;= imin) {
+	    icur = (imin + imax) / 2;
+	    icmp = leg(methodMaps[icur].classId, c);
+	    if(!icmp) {
+		icmp = leg(methodMaps[icur].name, name);
+		if(!icmp) break;
+	    }
+	    if(icmp &gt; 0)
+		imax = icur - 1;
+	    else
+		imin = icur + 1;
+	}
+
+	return (!icmp) ? icur : 0;
+    }
+
+    inline Index findMethod(Index c, Index name) {
+	// TODO: If method is in a parent module, forward the call from here
+	if(!c || !name) return 0;
+	Index mid = idMethod(c, name);
+	if(mid) return mid;
+	if(!classes[c].parents) return 0;
+	for(int p = classes[c].parents; inheritanceList[p] ; p++) {
+	    mid = findMethod(inheritanceList[p], name);
+	    if(mid) return mid;
+	}
+	return 0;
+    }
+
+    inline Index findMethod(const char *c, const char *name) {
+	Index idc = idClass(c);
+	Index idname = idMethodName(name);
+	return findMethod(idc, idname);
+    }
+};
+
+class SmokeBinding {
+protected:
+    Smoke *smoke;
+public:
+    SmokeBinding(Smoke *s) : smoke(s) {}
+    virtual void deleted(Smoke::Index classId, void *obj) = 0;
+    virtual bool callMethod(Smoke::Index method, void *obj, Smoke::Stack args, bool isAbstract = false) = 0;
+    virtual char* className(Smoke::Index classId) = 0;
+    virtual ~SmokeBinding() {}
+};
+
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000115.html">[Php-qt-svn] r271 - trunk/admin
</A></li>
	<LI>Next message: <A HREF="000117.html">[Php-qt-svn] r273 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#116">[ date ]</a>
              <a href="thread.html#116">[ thread ]</a>
              <a href="subject.html#116">[ subject ]</a>
              <a href="author.html#116">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/php-qt-svn">More information about the Php-qt-svn
mailing list</a><br>
</body></html>
