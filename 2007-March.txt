From tm243 at mail.berlios.de  Sun Mar  4 17:18:35 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Sun, 4 Mar 2007 17:18:35 +0100
Subject: [Php-qt-svn] r300 - in trunk: . php_qt tests
Message-ID: <200703041618.l24GIZPG018422@sheep.berlios.de>

Author: tm243
Date: 2007-03-04 17:18:29 +0100 (Sun, 04 Mar 2007)
New Revision: 300

Modified:
   trunk/ChangeLog
   trunk/php_qt/functions.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/qstring.cpp
   trunk/php_qt/smokephp.cpp
   trunk/tests/QtBasicTestCase.php
   trunk/tests/instances.php
   trunk/tests/qstring.php
   trunk/tests/unicode.php
Log:
* added QString handler
* internal data structure improved
* more tests added



Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2007-02-27 18:49:49 UTC (rev 299)
+++ trunk/ChangeLog	2007-03-04 16:18:29 UTC (rev 300)
@@ -1,3 +1,8 @@
+2007-003-4  Thomas Moenicke <thomas.moenicke at kdemail.net>
+
+		* handling of QString - string in return and argument types
+		* more tests added
+
 2007-002-27  Thomas Moenicke <thomas.moenicke at kdemail.net>
 
 		* implemented constantHandler which fetchs constants from Qt

Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-02-27 18:49:49 UTC (rev 299)
+++ trunk/php_qt/functions.cpp	2007-03-04 16:18:29 UTC (rev 300)
@@ -157,7 +157,7 @@
         return;
     }
 
-	smokephp_object* o = phpqt_fetch(zobject);
+	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(zobject);
 
 	cout << "PHP-Qt object \n(" << endl;
 

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-02-27 18:49:49 UTC (rev 299)
+++ trunk/php_qt/php_qt.cpp	2007-03-04 16:18:29 UTC (rev 300)
@@ -64,7 +64,6 @@
 
 	if (IS_CONST == IS_UNUSED) {
 		if (!zend_get_constant(opline->op2.u.constant.value.str.val, opline->op2.u.constant.value.str.len, &EX_T(opline->result.u.var).tmp_var TSRMLS_CC)) {
-			cout << "not found" << endl;
 			zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'",
 						opline->op2.u.constant.value.str.val,
 						opline->op2.u.constant.value.str.val);
@@ -147,8 +146,8 @@
 ZEND_GET_MODULE(php_qt)
 #endif
 
-static QHash<void*, zval*> zval_x_qt;
-QHash<void*, size_t>SmokeToPtr;
+static QHash<smokephp_object*, zval*> zval_x_qt;
+QHash<void*, smokephp_object*> SmokeQtObjects;
 QStack<QString*> methodNameStack;
 
 // cached
@@ -166,6 +165,7 @@
 union _zend_function *proxyHandler(zval **obj_ptr, char* methodname, int methodname_len TSRMLS_DC){
 
     union _zend_function *fbc;
+
     // a try for non-Qt objects
     fbc = zend_orig_handler.get_method(obj_ptr, methodname, methodname_len);
 
@@ -201,7 +201,7 @@
 ZEND_METHOD(php_qt_generic_class, __toString)
 {
 	if(!strcmp(Z_OBJCE_P(getThis())->name,"QString")){
-		smokephp_object* o = phpqt_fetch(getThis());
+		smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
 		RETVAL_STRING((char*)((QString*) o->ptr)->toAscii().constData(), 1);
 //		RETVAL_STRING((char*)((QString*) o->ptr)->toLocal8Bit().constData(), 1);
 	} else {
@@ -212,9 +212,9 @@
 
 ZEND_METHOD(php_qt_generic_class, __destruct)
 {
-    smokephp_object *o = phpqt_fetch(getThis());
-    zval_x_qt.remove(o->ptr);
-    SmokeToPtr.remove(o->ptr);
+    smokephp_object *o = phpqt_getSmokePHPObjectFromZval(getThis());
+    phpqt_removeZvalPtr(o);
+    SmokeQtObjects.remove(o->ptr);
 	RETVAL_NULL();
 }
 
@@ -240,11 +240,6 @@
     Smoke::StackItem* qargs = (Smoke::StackItem*) safe_emalloc(argc+10, sizeof(Smoke::StackItem), 0);
     smokephp_convertArgsZendToCxx(args, ZEND_NUM_ARGS(), qargs, methodNameStack);
     Smoke::Index method = smokephp_getMethod(qt_Smoke,ce->name, (methodNameStack.top())->toAscii(), &qargs, ZEND_NUM_ARGS(), args);
-	
-	// connect uses char*
-	if(smokephp_isConnect(method)){
-    	smokephp_prepareConnect(args, ZEND_NUM_ARGS(), qargs, method);
-	}
 
 	smokephp_object *o = (smokephp_object*) emalloc(sizeof(smokephp_object));
 
@@ -278,7 +273,7 @@
 		QMetaObject *superdata = (QMetaObject *) i[0].s_voidp;
 
  		QString* phpqt_meta_stringdata = new QString("");
-        uint* phpqt_meta_data = (uint*) emalloc(sizeof(uint)*20*5+10);
+    		uint* phpqt_meta_data = (uint*) emalloc(sizeof(uint)*20*5+10);
 		
 		//	create the metaObject
 		if(phpqt_getMocData(
@@ -304,13 +299,15 @@
 	} 
 
 	// store relations
-	phpqt_setSmokePHPObject(o);
-    PHP_QT_REGISTER(o);
-	zval_x_qt.insert(qargs[0].s_class, getThis());
 
+	PHP_QT_REGISTER(o);
+
     // return value
     smokephp_convertReturn(&qargs[0], qt_Smoke->types[qt_Smoke->methods[method].ret], qt_Smoke->methods[method].ret, return_value);
 
+	phpqt_setSmokePHPObject(o);
+	phpqt_setZvalPtr(o, getThis());
+
     // cleanup
     efree(args);
     efree(qargs);
@@ -340,7 +337,6 @@
     while (qt_Smoke->idClass(ce->name) <= 0) {
 	    ce = ce->parent;
 	}
-
 	// arguments
     int j, argc = ZEND_NUM_ARGS();
     zval ***args;
@@ -353,14 +349,24 @@
     Smoke::StackItem* qargs = (Smoke::StackItem*) safe_emalloc(argc+10, sizeof(Smoke::StackItem), 0);
     smokephp_convertArgsZendToCxx(args, argc, qargs, methodNameStack);
     Smoke::Index method = smokephp_getMethod(qt_Smoke,ce->name, (methodNameStack.top())->toAscii(), &qargs, argc, args);
-    smokephp_prepareConnect(args, argc, qargs, method);
 
+    if(smokephp_isConnect(method)){
+	smokephp_prepareConnect(args, argc, qargs, method);
+    }
+
     // self
     if(getThis()){
-    	smokephp_object *o = phpqt_fetch(getThis());
+    	smokephp_object *o = phpqt_getSmokePHPObjectFromZval(getThis());
         qargs[0].s_class = o->ptr;
     }
 
+    if(method <= 0) {
+	if(methodNameStack.top()->toAscii().constData()) 
+	    php_error(E_ERROR,"Call to undefined method %s %s!", Z_OBJCE_P(getThis())->name, methodNameStack.top()->toAscii().constData());
+	else 
+	    php_error(E_ERROR,"Call to undefined method!");
+    }
+
     // call
     smokephp_callMethod(qt_Smoke, qargs[0].s_class, method, qargs);
 
@@ -504,7 +510,7 @@
 PHP_MSHUTDOWN_FUNCTION(php_qt)
 {
 //	methodNameStack.~QStack();
-//	SmokeToPtr.~QHash();
+//	SmokeQtObjects.~QHash();
 	return SUCCESS;
 }
 
@@ -582,8 +588,10 @@
 	// try the PHP one
 	// eg _q_buttonPressed(), breaking at the first bracket
 	char* method_name = estrdup((d->method(_id)).signature());
+
     for(int i = 0; i < strlen(method_name); i++){
-        if(method_name[i] == 40){
+#define LEFT_PARENTHESIS 40
+        if(method_name[i] == LEFT_PARENTHESIS){
             method_name[i] = 0;
             break;
         }
@@ -591,6 +599,7 @@
 
     // is a Slot
     if(d->method(_id).methodType() == QMetaMethod::Slot){
+
         int j = 0;
         zval*** args = (zval***) safe_emalloc(2, sizeof(zval*), 0);
         QList<QByteArray> qargs = d->method(_id).parameterTypes();
@@ -658,34 +667,7 @@
 
 }
 
-smokephp_object* 
-phpqt_fetch(zval* this_ptr){
 
-	if(this_ptr == NULL){
-	  php_error(E_ERROR,"fatal: object does not exists and could not be fetched, %s",Z_OBJCE_P(this_ptr)->name);
-	}
-
-	smokephp_object *ptr;
-	zval **listhandle;
-	int type;
-	TSRMLS_FETCH();
-
-	if(zend_hash_index_find(Z_OBJPROP_P(this_ptr), 0, (void**) &listhandle) == FAILURE){
-	  php_error(E_ERROR,"underlying Qt-Object missing. Make sure that the constructor of the parent is called, instance of type '%s' fails",Z_OBJCE_P(this_ptr)->name,Z_OBJCE_P(this_ptr)->name);
-	}
-	ptr = (smokephp_object*) zend_list_find(Z_LVAL_PP(listhandle), &type);
-
-	if(!ptr){
-		php_error(E_ERROR,"reference to Qt object missing, %s",Z_OBJCE_P(this_ptr)->name);
-	} 
-	if(type != le_php_qt_hashtype){
-		php_error(E_ERROR,"phpqt_fetch(): wrong type, %s",Z_OBJCE_P(this_ptr)->name);
-	}
-
-	return ptr;
-
-}
-
 static void 
 phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc TSRMLS_DC)
 {
@@ -845,13 +827,24 @@
  *	@return	zval*
  */
 
+
+void
+phpqt_setZvalPtr(smokephp_object *o, zval* z) {
+	zval_x_qt.insert(o,z);
+}
+
+void
+phpqt_removeZvalPtr(smokephp_object *o) {
+	zval_x_qt.remove(o);
+}
+
 zval* 
-phpqt_fetchZendPtr(const QObject *o){
-	return zval_x_qt[(void*) o];
+phpqt_fetchZvalPtr(smokephp_object *o){
+	return zval_x_qt.value(o);
 }
 
 bool
-phpqt_zval2qtIsEnd(void *o){
+phpqt_ZvalPtrExists(smokephp_object *o){
 	return (zval_x_qt.find(o) != zval_x_qt.end());
 }
 
@@ -866,18 +859,52 @@
 	return (char*) fname;
 }
 
+smokephp_object* 
+phpqt_getSmokePHPObjectFromZval(zval* this_ptr){
+
+	if(this_ptr == NULL){
+	  php_error(E_ERROR,"fatal: object does not exists and could not be fetched, %s",Z_OBJCE_P(this_ptr)->name);
+	}
+
+	smokephp_object *ptr;
+	zval **listhandle;
+	int type;
+	TSRMLS_FETCH();
+
+	if(zend_hash_index_find(Z_OBJPROP_P(this_ptr), 0, (void**) &listhandle) == FAILURE){
+	  php_error(E_ERROR,"underlying Qt-Object missing. Make sure that the constructor of the parent is called, instance of type '%s' fails",Z_OBJCE_P(this_ptr)->name,Z_OBJCE_P(this_ptr)->name);
+	}
+	ptr = (smokephp_object*) zend_list_find(Z_LVAL_PP(listhandle), &type);
+
+	if(!ptr){
+		php_error(E_ERROR,"reference to Qt object missing, %s",Z_OBJCE_P(this_ptr)->name);
+	} 
+	if(type != le_php_qt_hashtype){
+		php_error(E_ERROR,"phpqt_getSmokePHPObjectFromZval(): wrong type, %s",Z_OBJCE_P(this_ptr)->name);
+	}
+
+	return ptr;
+
+}
+
+void*
+phpqt_getQtObjectFromZval(zval* this_ptr){
+	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
+	return o->ptr;
+}
+
 smokephp_object*
-phpqt_getSmokePHPObject(void* ptr){
-	return (smokephp_object*) SmokeToPtr[ptr];
+phpqt_getSmokePHPObjectFromQt(void* QtPtr){
+	return (smokephp_object*) SmokeQtObjects.value(QtPtr);
 }
 
 void
 phpqt_setSmokePHPObject(smokephp_object* o){
-	SmokeToPtr.insert(o->ptr, (size_t) o);
+	SmokeQtObjects.insert(o->ptr, o);
 }
 
 bool
-phpqt_SmokePHPObjectExists(smokephp_object* o){
-	return (SmokeToPtr.find(o->ptr) != SmokeToPtr.end());
+phpqt_SmokePHPObjectExists(void* ptr){
+	return (SmokeQtObjects.find(ptr) != SmokeQtObjects.end());
 }
 

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-02-27 18:49:49 UTC (rev 299)
+++ trunk/php_qt/php_qt.h	2007-03-04 16:18:29 UTC (rev 300)
@@ -64,7 +64,7 @@
     phpqt_register(getThis(),le);  \
 
 #define PHP_QT_FETCH()  \
-	phpqt_fetch(getThis()) \
+	phpqt_getQtObjectFromZval(getThis()) \
 
 #define PHP_QT_FENTRY(zend_name, name_, arg_info_, flags_)	\
     t->fname = (char*) emalloc(strlen(#zend_name)+1); \
@@ -109,18 +109,24 @@
 //zend_class_entry* php_qt_generic_class;
 
 static void 		phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc);
-smokephp_object* 	phpqt_fetch(zval* this_ptr);
+
 void 				phpqt_register(zval* this_ptr, zend_rsrc_list_entry le);
 zval* 				phpqt_callMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params[]);
 bool 				phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname);
 bool 				phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* metachar, QString* meta_stringdata, uint* signature);
-zval* 				phpqt_fetchZendPtr(const QObject *o);
-int					phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
+int				phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
 char*				phpqt_checkForOperator(const char* fname);
-bool				phpqt_zval2qtIsEnd(void *o);
-smokephp_object*	phpqt_getSmokePHPObject(void* ptr);
+
+void 				phpqt_setZvalPtr(smokephp_object *o, zval* z);
+void 				phpqt_removeZvalPtr(smokephp_object *o);
+zval* 				phpqt_fetchZvalPtr(smokephp_object *o);
+bool				phpqt_ZvalPtrExists(smokephp_object *o);
+
+void* 				phpqt_getQtObjectFromZval(zval* this_ptr);
+smokephp_object* 		phpqt_getSmokePHPObjectFromZval(zval* this_ptr);
+smokephp_object*		phpqt_getSmokePHPObjectFromQt(void* QtPtr);
 void				phpqt_setSmokePHPObject(smokephp_object* o);
-bool				phpqt_SmokePHPObjectExists(smokephp_object* o);
+bool				phpqt_SmokePHPObjectExists(void* ptr);
 
 extern int le_php_qt_hashtype;
 extern HashTable php_qt_objptr_hash;
@@ -134,7 +140,7 @@
 void				smokephp_callMethod(Smoke *smoke, void *obj, Smoke::Index method, Smoke::Stack qargs);
 void				smokephp_convertReturn(Smoke::StackItem *ret_val, const Smoke::Type type, const Smoke::Index ret, zval* return_value);
 void				smokephp_init();
-Smoke::Index		smokephp_findConnect();
+Smoke::Index			smokephp_findConnect();
 bool				smokephp_isConnect(Smoke::Index method);
 
 

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-02-27 18:49:49 UTC (rev 299)
+++ trunk/php_qt/qstring.cpp	2007-03-04 16:18:29 UTC (rev 300)
@@ -28,12 +28,12 @@
 using namespace std;
 
 
-
 #include <QtCore/QString>
 #include <zend_interfaces.h>
 #include "php_qt.h"
 
 zend_class_entry* qstring_ce;
+extern Smoke* qt_Smoke;
 
 static zend_function_entry QString_methods[] = {
 	ZEND_ME(QString,__toString,NULL,ZEND_ACC_PUBLIC)
@@ -179,7 +179,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -195,8 +195,8 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
 
 
 			}
@@ -274,7 +274,7 @@
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
 
 
 			}
@@ -291,7 +291,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
 
 
 			}
@@ -390,7 +390,7 @@
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -508,7 +508,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -527,7 +527,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -624,10 +624,26 @@
  *    flags:    
  */
 ZEND_METHOD(QString, __construct){
+
+	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
+//	o->ptr = ret_val->s_voidp;
+	o->zval_ptr = getThis();
+	o->ce_ptr = qstring_ce;
+	o->classId = 0;	// QString is not in smoke
+	o->smoke = qt_Smoke;
+	phpqt_setSmokePHPObject(o);
+	// register all 
+	zend_rsrc_list_entry le;
+	le.ptr = o;
+	object_init_ex(return_value, qstring_ce);
+	phpqt_register(o->zval_ptr,le);
+	phpqt_setZvalPtr(o, o->zval_ptr);
+
 	if (ZEND_NUM_ARGS() == 0){
-			QString *QString_ptr = new QString();
-				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
+	    QString *QString_ptr = new QString();
+	    o->ptr = (void*) QString_ptr;
+//	    PHP_QT_REGISTER(QString_ptr);
+	    RETURN_NULL();
 	}
 
 	if (ZEND_NUM_ARGS() == 1){
@@ -646,18 +662,19 @@
 
 
 			QString *QString_ptr = new QString((char) Z_LVAL_P(z_0));
-				PHP_QT_REGISTER(QString_ptr);
+			o->ptr = (void*) QString_ptr;
+//				PHP_QT_REGISTER(QString_ptr);
 				RETURN_NULL();
 			}
 			if(Z_TYPE_P(z_0) == IS_STRING){
 
 			QString *QString_ptr = new QString( (const char*) Z_STRVAL_P(z_0));
-
-				PHP_QT_REGISTER(QString_ptr);
+				o->ptr = (void*) QString_ptr;
+//				PHP_QT_REGISTER(QString_ptr);
 				RETURN_NULL();
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -675,7 +692,7 @@
 		zval *z_1; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -683,11 +700,15 @@
 
 
 			QString *QString_ptr = new QString((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
-				PHP_QT_REGISTER(QString_ptr);
+			o->ptr = (void*) QString_ptr;
+//				PHP_QT_REGISTER(QString_ptr);
 				RETURN_NULL();
 			}
 		}
 	}
+	if (ZEND_NUM_ARGS() > 2) {
+	    php_error(E_ERROR, "Too many arguments in QString constructor\n");
+	}
 }
 
 /*********************************
@@ -872,7 +893,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -965,7 +986,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -981,8 +1002,8 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
 
 
 			}
@@ -1024,7 +1045,7 @@
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -1161,6 +1182,8 @@
 ZEND_METHOD(QString, toAscii){
 	if (ZEND_NUM_ARGS() == 0){
 			QString *obj = (QString*) PHP_QT_FETCH();
+//			smokephp_object* o = PHP_QT_FETCH();
+//			QString *obj = (QString*) o->ptr;
 			RETURN_STRING((char*) obj->toAscii().constData(), 1);
 	}
 }
@@ -1234,7 +1257,7 @@
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -1298,7 +1321,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -1318,7 +1341,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -1349,7 +1372,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -1449,7 +1472,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -1473,7 +1496,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -1492,7 +1515,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -1542,8 +1565,8 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
 
 
 			}
@@ -1566,22 +1589,22 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
+			QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
 
 
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
-			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
 
 
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+			QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
 
 
 			}
@@ -1605,22 +1628,22 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_3 = (QObject*) phpqt_fetch(z_3);
+			QObject* obj_z_3 = (QObject*) phpqt_getQtObjectFromZval(z_3);
 
 
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_3 = (QObject*) phpqt_fetch(z_3);
+			QObject* obj_z_3 = (QObject*) phpqt_getQtObjectFromZval(z_3);
 
 
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
-			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
-			QObject* obj_z_3 = (QObject*) phpqt_fetch(z_3);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
+			QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
+			QObject* obj_z_3 = (QObject*) phpqt_getQtObjectFromZval(z_3);
 
 
 			}
@@ -1639,7 +1662,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzzz", &z_0, &z_1, &z_2, &z_3, &z_4) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG && Z_TYPE_P(z_4) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_4 = (QObject*) phpqt_fetch(z_4);
+			QObject* obj_z_4 = (QObject*) phpqt_getQtObjectFromZval(z_4);
 
 
 			}
@@ -1664,7 +1687,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
 
 
 			}
@@ -1801,7 +1824,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -1818,7 +1841,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -1843,7 +1866,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -1943,7 +1966,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -1962,7 +1985,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -2019,8 +2042,8 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
 
 
 			}
@@ -2046,14 +2069,14 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
 
 
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
 
 
 			}
@@ -2071,7 +2094,7 @@
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+			QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
 
 
 			}
@@ -2089,7 +2112,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT && Z_TYPE_P(z_3) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+			QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
 
 
 			}
@@ -2218,10 +2241,10 @@
 				return;                                             
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
-
-
+			    QString *obj = (QString*) PHP_QT_FETCH();
+			    QString* obj_z_0 = (QString*) phpqt_getQtObjectFromZval(z_0);
+			    obj->append((QString) *obj_z_0);
+			    RETURN_NULL();
 			}
 		}
 	}
@@ -2381,7 +2404,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -2401,7 +2424,7 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}
@@ -2498,7 +2521,7 @@
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
 
 
 			}

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-02-27 18:49:49 UTC (rev 299)
+++ trunk/php_qt/smokephp.cpp	2007-03-04 16:18:29 UTC (rev 300)
@@ -29,6 +29,7 @@
 
 extern Smoke *qt_Smoke;
 extern void init_qt_Smoke();
+extern zend_class_entry* qstring_ce;
 
 Smoke::Index connect1;
 Smoke::Index connect2;
@@ -44,9 +45,9 @@
     virtual void deleted(Smoke::Index, void*) {
             // ignore object deletion
     }
-    virtual bool callMethod(Smoke::Index method, void* ptr, Smoke::Stack args, bool /*isAbstract*/) {
+    virtual bool callMethod(Smoke::Index method, void* QtPtr, Smoke::Stack args, bool /*isAbstract*/) {
 
-		smokephp_object *o = (smokephp_object*) phpqt_getSmokePHPObject(ptr);
+		smokephp_object *o = (smokephp_object*) phpqt_getSmokePHPObjectFromQt(QtPtr);
 
 		if(!o){
 			// no related smokephp_object
@@ -259,7 +260,7 @@
 
 	smokephp_object *o;
 	if(type == IS_OBJECT)
-		o = phpqt_fetch(((zval*) *val));
+		o = phpqt_getSmokePHPObjectFromZval(((zval*) *val));
 
 	switch(type){
 		case IS_STRING:
@@ -389,17 +390,32 @@
 	    } else if (type == IS_STRING){
 
 			if((((zval) **args[i]).is_ref)){
-				qargs[i+1].s_class = phpqt_fetch(*args[i])->ptr;
+				qargs[i+1].s_class = phpqt_getSmokePHPObjectFromZval(*args[i])->ptr;	
 			} else {
-    	    	qargs[i+1].s_class = emalloc(sizeof(QString)+strlen(Z_STRVAL_PP(args[i]))); // important
-    	    	qargs[i+1].s_class = new QString(Z_STRVAL_PP(args[i]));
-            }
+			    // create a new QString object
+    	    		    qargs[i+1].s_class = emalloc(sizeof(QString) + strlen(Z_STRVAL_PP(args[i]))); // important
+    	    		    qargs[i+1].s_class = new QString(Z_STRVAL_PP(args[i]));
+			    // create new smokephp_object
+			    smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
+			    o->ptr = qargs[i+1].s_class;
+			    o->zval_ptr = *args[i];
+			    o->ce_ptr = qstring_ce;
+			    o->classId = 0;	// QString is not in smoke
+			    o->smoke = qt_Smoke;
+			    phpqt_setSmokePHPObject(o);
+			    // register all 
+			    zend_rsrc_list_entry le;
+			    le.ptr = o;
+			    object_init_ex(*args[i], qstring_ce);
+			    phpqt_register(o->zval_ptr,le);
+			    phpqt_setZvalPtr(o, o->zval_ptr);
+        		}
 
-            methodNameStack.top()->append("$");
+        		methodNameStack.top()->append("$");
 
 	    } else if (type == IS_OBJECT){
-			smokephp_object *o = phpqt_fetch(((zval*) *args[i]));
-            qargs[i+1].s_class = o->ptr;
+			smokephp_object *o = phpqt_getSmokePHPObjectFromZval(((zval*) *args[i]));
+        		qargs[i+1].s_class = o->ptr;
             // as default QString is not supported in Smoke
             if(!strcmp(Z_OBJCE_P(((zval*) *args[i]))->name, "QString")){
             	qargs[i+1].s_class = new QString(((QString*) o->ptr)->toAscii().constData());
@@ -424,8 +440,34 @@
 
     switch((type.flags & Smoke::tf_elem)){
         case Smoke::t_voidp:
-            RETVAL_NULL();
-            break;
+	    if(!type.name){
+        	RETVAL_NULL();
+	    } else {
+		if(!strcmp(type.name, "QString")) {
+		    // create new smokephp_object
+		    smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
+		    o->ptr = ret_val->s_voidp;
+		    o->zval_ptr = return_value;
+		    o->ce_ptr = qstring_ce;
+		    o->classId = 0;	// QString is not in smoke
+		    o->smoke = qt_Smoke;
+		    phpqt_setSmokePHPObject(o);
+		    // register all 
+		    zend_rsrc_list_entry le;
+		    le.ptr = o;
+		    object_init_ex(return_value, qstring_ce);
+		    phpqt_register(o->zval_ptr,le);
+		    phpqt_setZvalPtr(o, o->zval_ptr);
+
+		} else if(!strcmp(type.name, "QString*")) {
+		    php_error(E_WARNING,"No handler for returntype %s installed!", type.name);
+		} else if(!strcmp(type.name, "QString&")) {
+		    php_error(E_WARNING,"No handler for returntype %s installed!", type.name);
+		} else {
+		    php_error(E_WARNING,"No handler for returntype %s installed!", type.name);
+		}
+	    }
+    	    break;
         case Smoke::t_bool:
             RETVAL_BOOL(ret_val->s_bool);
             break;
@@ -463,19 +505,19 @@
             php_error(E_WARNING,"type enum not implemented\n");
             break;
         case Smoke::t_class:
-
  			o = (smokephp_object*) emalloc(sizeof(smokephp_object));
 
 			// zval already exists
-//			if(zval_x_qt.find(o) != zval_x_qt.end()){
-			if(phpqt_zval2qtIsEnd(o)){
-				return_value = phpqt_fetchZendPtr((QObject*) o->ptr);
-			// create a new one
+
+			    if(phpqt_SmokePHPObjectExists(ret_val->s_voidp)) {
+				smokephp_object* o = phpqt_getSmokePHPObjectFromQt(ret_val->s_voidp);
+				ZVAL_ZVAL(return_value, o->zval_ptr,0,0);
+				zend_rsrc_list_entry le;
+				le.ptr = o;
+				phpqt_register(return_value, le);
 			} else {
-				
 				o->ptr = ret_val->s_class;
 				o->smoke = qt_Smoke;
-
 				if(!strcmp((char*) qt_Smoke->classes[qt_Smoke->types[ret].classId].className, "QObject")){
 					// cast from, to
 					o->ptr = o->smoke->cast(o->ptr, qt_Smoke->idClass("QObject"), qt_Smoke->types[ret].classId);
@@ -485,8 +527,8 @@
 									ZEND_FETCH_CLASS_AUTO TSRMLS_DC));
 				//
 				} else if (!strcmp((char*) qt_Smoke->classes[qt_Smoke->types[ret].classId].className, "QBool")) {
-            		RETVAL_BOOL(*((QBool*) ret_val->s_class));
-            		return;
+            			    RETVAL_BOOL(*((QBool*) ret_val->s_class));
+            			    return;
 				// fallback, already with correct type
 				} else {
 					object_init_ex(return_value, 
@@ -499,7 +541,7 @@
 				o->ce_ptr = Z_OBJCE_P(return_value);
 				o->classId = qt_Smoke->types[ret].classId;
 
-				if(!phpqt_SmokePHPObjectExists(o))
+				if(!phpqt_SmokePHPObjectExists(o->ptr))
 					phpqt_setSmokePHPObject(o);
 
 				zend_rsrc_list_entry le;
@@ -520,13 +562,15 @@
 smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method){
 
     int j;
-
     // second loop: we dont have the method-Id before the first call
     for(j = 0; j < argc; j++){
- 	    uint type = ((int) ((zval) **args[j]).type);    // als Macro!
-        if (type == IS_STRING) {
-        	qargs[j+1].s_voidp = args[j][0]->value.str.val;
-        }
+ 	uint type = ((int) ((zval) **args[j]).type);    // als Macro!
+	if (type == IS_OBJECT) {
+		if(Z_OBJCE_PP(args[j]) == qstring_ce) {
+		QString* o = (QString*) phpqt_getQtObjectFromZval(*args[j]);
+		qargs[j+1].s_voidp = (void*) o->toAscii().constData();
+	    }
+	}
     }
 
 }

Modified: trunk/tests/QtBasicTestCase.php
===================================================================
--- trunk/tests/QtBasicTestCase.php	2007-02-27 18:49:49 UTC (rev 299)
+++ trunk/tests/QtBasicTestCase.php	2007-03-04 16:18:29 UTC (rev 300)
@@ -17,9 +17,14 @@
      * check if we can fetch constants
      */
 
-    class foo {
+    class foo extends QObject {
 	const a = "a";
 	const b = 24;
+	
+	public function testMethod($value = NULL) {
+	    if ($value) echo $value."\n";
+	}
+	
     }
 
 
@@ -37,22 +42,26 @@
 	// try to fetch a string constant
 	function testFetchStringConstant() {
 	    $this->assertEquals(foo::a, "a", "Could not fetch string constant!");
+	    echo "\ntesting foo::a passed";
 	}
 
 	// try to fetch a numeric constant
 	function testFetchNumConstant() {
 	    $this->assertEquals(foo::b, 24, "Could not fetch numeric constant!");
+	    echo "\ntesting foo::b passed";
 	}
 
 	// try to fetch a Qt constant
 	function testQtConstant() {
 	    $this->assertTrue(Qt::Horizontal == 1, "Could not fetch constant from Qt!");
+	    echo "\ntesting Qt::Horizontal passed";
 	}
 
 	// test the __toString() method
 	function testQString() {
 	    $s = new QString("hello");
 	    $this->assertEquals($s->__toString(), "hello", "Could not handle __toString()!");
+	    echo "\ntesting QString::__toString() passed";
 	}
 
 	// try to append a PHP string to a QString
@@ -60,46 +69,91 @@
 	    $s = new QString("hello");
 	    $s->append(" world");
 	    $this->assertEquals($s->__toString(), "hello world", "Could append simple string to QString!");
+	    echo "\ntesting QString::append(\"hello\") passed";
 	}
 
 	// try to create an instance of QApplication
 	function testQApplication() {
 	    $this->app = new QApplication(&$this->argc,$this->argv);
 	    $this->assertTrue(is_object($this->app), "Could not create an instance of QApplication!");
+	    echo "\ntesting QApplication passed";
 	}
 
-	// try to get a QString as return value
+	// test returning numbers
+	function testReturnNum() {
+	    $date = new QDate(2007,3,24);
+	    $this->assertTrue((gettype($date->day()) == "integer"), "Value returned is not integer type, ".gettype($date->day())." detected!");
+	    $this->assertTrue(($date->day() == 24), "Value returned is wrong!");
+	    echo "\ntesting numbers passed";
+	}
+
+	// test returning double
+	// test returning array
+	// test returning null
+
+	// test returning boolean
+	function testReturnBool() {
+	    $date = new QDate(2007,3,24);
+	    $this->assertTrue((gettype($date->setDate(2007,3,24)) == "boolean"), "Value returned is not boolean type, ".gettype($date->setDate(2007,3,24))." detected!");
+	    $this->assertTrue(($date->setDate(2007,3,24) == true), "Value returned is wrong!");
+	    echo "\ntesting bool passed";
+	}
+
+	// test returning object
+	function testReturnObject() {
+	    $parent = new QObject();
+	    $object = new QObject($parent);
+	    $parent__ = $object->parent();
+	    $this->assertTrue(($parent === $parent__),"Object returned by QObject->parent() is not the same as parent!");
+	    echo "\ntesting objects passed";
+	}
+// ???
+	// test returning a new object
+	function testReturnNewObject() {
+	    $date = new QDate(2007,3,24);
+	    $date__ = $date->addDays(2);
+	    $this->assertFalse(($date === $date__),"new Object returned by QObject->parent() is the same as parent!");
+	    echo "\ntesting new objects passed";
+	}
+
+	// test returning string
 	function testReturnQString() {
 	    $object = new QObject();
-	    $object->setText("hello");
-	    $string = $object->getText();
-	    $this->assertTrue(is_object($string), "Value returned by getText() is not valid.");
-	    $this->assertEquals($string->__toString(), "hello", "Return object does not contain the same text!");
+	    $object->setObjectName("hello");
+	    $string = $object->objectName();
+	    $this->assertTrue(is_object($string), "String is not a QString!");
+	    $this->assertEquals($string->toAscii(), "hello", "Return object does not contain the same text!");
+	    echo "\ntesting QString as return passed";
 	}
 
 	// try to give a QString as argument
-/*	function testAddQString() {
+	function testAddQString() {
 	    $object = new QObject();
-	    $string = new QString("hello");
-//	    $object->setText($string);
-	    $s = $object->getText();
-	    $this->assertEquals($s->__toString(),"hello", "Return object does not contain the same text!");
+	    $object->setObjectName(new QString("hello string"));
+	    $s = $object->objectName();
+	    $this->assertEquals($s->toAscii(),"hello string", "Return object does not contain the same text!");
+	    echo "\ntesting QString as argument passed";
 	}
-*/
-	// try to get an return Object
-	// try to give an object as argument
-	// try to give an object as argument, modify it, give it back and check if it is the same
 
 	// try to append a QString to a QString
-/*	function testQStringAppendObject() {
+	function testQStringAppendObject() {
 	    $s = new QString("hello");
 	    $t = new QString(" world");
 	    $s->append($t);
 	    $this->assertEquals($s->__toString(), "hello world", "Could not append QString to QString!");
+	    echo "\ntesting QString::append(new QString(\"hello\")) passed";
 	}
-*/
-    
 
+	// test methods of an derivated object
+	function testUnknownMethod() {
+	    $date = new QObject();
+	    $foo = new foo($date);
+	    $foo->parent();
+	    $foo->testMethod();
+//	    $foo->___();	// method not defined
+	    echo "\ntesting derivated object passed";
+	}
+
     }    
     
 ?>
\ No newline at end of file

Modified: trunk/tests/instances.php
===================================================================
--- trunk/tests/instances.php	2007-02-27 18:49:49 UTC (rev 299)
+++ trunk/tests/instances.php	2007-03-04 16:18:29 UTC (rev 300)
@@ -3,7 +3,7 @@
     dl('php_qt.' . PHP_SHLIB_SUFFIX);
   }
  
-  $app = new QCoreApplication($argc,$argv);
+  $app = new QCoreApplication(&$argc,$argv);
 
   echo $app." app\n";  
 

Modified: trunk/tests/qstring.php
===================================================================
--- trunk/tests/qstring.php	2007-02-27 18:49:49 UTC (rev 299)
+++ trunk/tests/qstring.php	2007-03-04 16:18:29 UTC (rev 300)
@@ -18,24 +18,24 @@
     echo "\n";
 
 /* this does not work */
-	echo $QString_2." ".$QString_1." ".$QString_3;
+	echo $QString_2."-".$QString_1."-".$QString_3;
     echo "\n";
 
 /* this does not work */
-	$tmp = $QString_2." ".$QString_1." ".$QString_3;
+	$tmp = $QString_2."+".$QString_1."+".$QString_3;
 	print($tmp);
 
     echo "\n";
 
 /* this does not work */
 	$tmp2 = $QString_2;
-	$tmp2 = $QString_1;
-	$tmp2 = $QString_3;
-	echo $tmp;
+	$tmp2 .= $QString_1;
+	$tmp2 .= $QString_3;
+	echo $tmp2;
     echo "\n";
 
 /* this does not work */
-	echo "$QString_2 $QString_1 $QString_3";
+	echo "$QString_2#$QString_1#$QString_3";
     echo "\n";
 
 /* this work: */

Modified: trunk/tests/unicode.php
===================================================================
--- trunk/tests/unicode.php	2007-02-27 18:49:49 UTC (rev 299)
+++ trunk/tests/unicode.php	2007-03-04 16:18:29 UTC (rev 300)
@@ -28,9 +28,9 @@
 			{
 				$this->buttons[] = new QLineEdit(QString::fromUtf8($data->nodeValue, -1),$this);
 
-	            foreach($data->attributes as $attribute){
-                    $this->layout->addWidget(new QLabel($attribute->name.": ".$attribute->value));
-                }
+	        		    foreach($data->attributes as $attribute){
+                			$this->layout->addWidget(new QLabel($attribute->name.": ".$attribute->value));
+            			    }
 
 				$this->layout->addWidget($this->buttons[count($this->buttons)-1]);
 			}
@@ -45,7 +45,7 @@
 
 	}
 
-    $app = new QApplication($argc,$argv);
+    $app = new QApplication(&$argc,$argv);
 	$widget = new TestButtons();
 	$widget->show();
 	$app->exec();



From tm243 at mail.berlios.de  Mon Mar  5 15:54:07 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Mon, 5 Mar 2007 15:54:07 +0100
Subject: [Php-qt-svn] r301 - in trunk: . php_qt
Message-ID: <200703051454.l25Es7Z7009045@sheep.berlios.de>

Author: tm243
Date: 2007-03-05 15:54:06 +0100 (Mon, 05 Mar 2007)
New Revision: 301

Modified:
   trunk/ChangeLog
   trunk/php_qt/functions.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/qstring.cpp
   trunk/php_qt/smokephp.cpp
Log:
* Debugging for metaobject system added
* parent_ce_ptr in smokephp_object



Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2007-03-04 16:18:29 UTC (rev 300)
+++ trunk/ChangeLog	2007-03-05 14:54:06 UTC (rev 301)
@@ -1,5 +1,10 @@
 2007-003-4  Thomas Moenicke <thomas.moenicke at kdemail.net>
 
+		* Debugging for metaobject system added
+		* parent_ce_ptr
+
+2007-003-4  Thomas Moenicke <thomas.moenicke at kdemail.net>
+
 		* handling of QString - string in return and argument types
 		* more tests added
 

Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-03-04 16:18:29 UTC (rev 300)
+++ trunk/php_qt/functions.cpp	2007-03-05 14:54:06 UTC (rev 301)
@@ -134,7 +134,7 @@
 	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
 	o->ptr = new QString(QObject::tr(string));
 	o->smoke = qt_Smoke;
-	o->classId = qstring;
+	o->classId = 0;		// QString is not in smoke
 	o->ce_ptr = qstring_ce;
 	o->zval_ptr = return_value;
 
@@ -142,6 +142,8 @@
 	zend_rsrc_list_entry le;
 	le.ptr = o;
 	phpqt_register(return_value, le);
+	phpqt_setSmokePHPObject(o);
+	phpqt_setZvalPtr(o, o->zval_ptr);
     return;
 }
 

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-03-04 16:18:29 UTC (rev 300)
+++ trunk/php_qt/php_qt.cpp	2007-03-05 14:54:06 UTC (rev 301)
@@ -31,6 +31,8 @@
 
 #include "ext/standard/php_string.h"
 
+#define MOC_DEBUG 0
+
 extern Smoke *qt_Smoke;
 extern void init_qt_Smoke();
 
@@ -257,9 +259,23 @@
 	o->ptr = qargs[0].s_class;
 	o->zval_ptr = getThis();
 	o->ce_ptr = ce;
+	o->parent_ce_ptr = ce;
 	o->classId = qt_Smoke->idClass(ce->name);
 	o->smoke = qt_Smoke;
 
+	// store relations
+
+	PHP_QT_REGISTER(o);
+	phpqt_setSmokePHPObject(o);
+	phpqt_setZvalPtr(o, return_value);
+
+    // return value
+    smokephp_convertReturn(&qargs[0], qt_Smoke->types[qt_Smoke->methods[method].ret], qt_Smoke->methods[method].ret, return_value);
+
+	// make sure it is the right object
+	o->zval_ptr = return_value;
+	o->ce_ptr = Z_OBJCE_P(return_value);	// overwrite
+
 	// if QObject
 	if(smokephp_isQObject(qt_Smoke, qt_Smoke->idClass(ce->name))){
 
@@ -274,11 +290,11 @@
 
  		QString* phpqt_meta_stringdata = new QString("");
     		uint* phpqt_meta_data = (uint*) emalloc(sizeof(uint)*20*5+10);
-		
+
 		//	create the metaObject
 		if(phpqt_getMocData(
 				getThis(),
-				Z_OBJCE_P(getThis())->name,
+				o->parent_ce_ptr->name,
 				superdata,
 				o->meta,
 				phpqt_meta_stringdata,
@@ -298,16 +314,7 @@
 
 	} 
 
-	// store relations
 
-	PHP_QT_REGISTER(o);
-
-    // return value
-    smokephp_convertReturn(&qargs[0], qt_Smoke->types[qt_Smoke->methods[method].ret], qt_Smoke->methods[method].ret, return_value);
-
-	phpqt_setSmokePHPObject(o);
-	phpqt_setZvalPtr(o, getThis());
-
     // cleanup
     efree(args);
     efree(qargs);
@@ -350,8 +357,32 @@
     smokephp_convertArgsZendToCxx(args, argc, qargs, methodNameStack);
     Smoke::Index method = smokephp_getMethod(qt_Smoke,ce->name, (methodNameStack.top())->toAscii(), &qargs, argc, args);
 
+    if(method <= 0) {
+	if(methodNameStack.top()->toAscii().constData()) 
+	    php_error(E_ERROR,"Call to undefined method %s %s!", ce->name, methodNameStack.top()->toAscii().constData());
+	else 
+	    php_error(E_ERROR,"Call to undefined method!");
+    }
+
     if(smokephp_isConnect(method)){
 	smokephp_prepareConnect(args, argc, qargs, method);
+//	smokephp_callMethod(qt_Smoke, qargs[0].s_class, method, qargs);
+
+	QString* o1 = (QString*) phpqt_getQtObjectFromZval(*args[1]);
+	QString* o2 = (QString*) phpqt_getQtObjectFromZval(*args[3]);
+	smokephp_object *oo1 = phpqt_getSmokePHPObjectFromZval(((zval*) *args[0]));
+	smokephp_object *oo2 = phpqt_getSmokePHPObjectFromZval(((zval*) *args[2]));
+
+#if MOC_DEBUG
+	cout << "QObject::connect(" << ((QObject*) oo1->ptr)->metaObject()->className();;
+	cout << ", " << o1->toAscii().constData();
+	cout << ", " << ((QObject*) oo2->ptr)->metaObject()->className();;
+	cout << ", " << o2->toAscii().constData();
+	cout << ")" << endl;
+#endif
+
+	QObject::connect((QObject*) oo1->ptr, o1->toAscii().constData(), (QObject*)oo2->ptr, o2->toAscii().constData());
+	return;
     }
 
     // self
@@ -360,12 +391,6 @@
         qargs[0].s_class = o->ptr;
     }
 
-    if(method <= 0) {
-	if(methodNameStack.top()->toAscii().constData()) 
-	    php_error(E_ERROR,"Call to undefined method %s %s!", Z_OBJCE_P(getThis())->name, methodNameStack.top()->toAscii().constData());
-	else 
-	    php_error(E_ERROR,"Call to undefined method!");
-    }
 
     // call
     smokephp_callMethod(qt_Smoke, qargs[0].s_class, method, qargs);
@@ -472,7 +497,7 @@
         t->fname = NULL;
         t->handler = NULL;
         t->arg_info = NULL;
-        t->flags = NULL;
+        t->flags = (zend_uint) NULL;
         t++;
 
 	// register zend class
@@ -553,6 +578,10 @@
 //	int offset = d->methodOffset();
 	int offset = d->methodCount();
 
+#if MOC_DEBUG
+	cout << "qt_metacall " << so->ce_ptr->name << endl;
+#endif
+
 	// call the C++ one
 	if(_id < offset){
 		// find parent
@@ -571,6 +600,10 @@
 			i[3].s_voidp = (void*) args[3].s_voidp;
 			(*fn)(m.method, so->ptr, i);
 
+#if MOC_DEBUG
+			cout << "\tcall Qt method " << so->ce_ptr->name << "::" << qt_Smoke->methodNames[method] << endl;
+#endif
+
 			if((int)i[0].s_int < 0)
 				return i[0].s_int;	
 
@@ -589,6 +622,7 @@
 	// eg _q_buttonPressed(), breaking at the first bracket
 	char* method_name = estrdup((d->method(_id)).signature());
 
+
     for(int i = 0; i < strlen(method_name); i++){
 #define LEFT_PARENTHESIS 40
         if(method_name[i] == LEFT_PARENTHESIS){
@@ -631,6 +665,10 @@
 
         }
 
+#if MOC_DEBUG
+    cout << "\tcall PHP method " << so->ce_ptr->name << "::" << method_name << endl;
+#endif
+
         phpqt_callMethod(so->zval_ptr, method_name, j, args);
 
     // is a signal
@@ -739,6 +777,7 @@
 
     if((zslot)->type==IS_ARRAY && (zsignal)->type==IS_ARRAY ) {
 
+
         HashTable* slots_hash = HASH_OF(zslot);
         HashTable* signals_hash = HASH_OF(zsignal);
 
@@ -748,6 +787,12 @@
         int signaturecount;
         signaturecount = 2 + strlen(classname);
 
+#if MOC_DEBUG
+	QString *qr = new QString();
+	cout << "+== begin metaobject dump ==+\n";
+	cout << "\t" << classname << "\n\t1 0 0 0 " << zend_hash_num_elements(slots_hash)+zend_hash_num_elements(signals_hash) << " 10 0 0 0 0" << endl << endl;
+#endif
+
 		/// write class signature
 		signature[0] = 1;
 		signature[1] = 0;
@@ -775,6 +820,12 @@
 			/// read slot from hashtable
 			zend_hash_get_current_key(signals_hash,&assocKey,&numKey,0);
 			zend_hash_get_current_data(signals_hash,(void**)&slotdata);
+
+#if MOC_DEBUG
+			qr->append(Z_STRVAL_PP(slotdata));
+			qr->append(" ");
+			cout << "\t" << signaturecount << "8 8 8 0x05 ::s" << endl;
+#endif
 			
 			meta_stringdata->append(Z_STRVAL_PP(slotdata));
 			meta_stringdata->append(QChar::Null);
@@ -799,10 +850,16 @@
 			/// read slot from hashtable
 			zend_hash_get_current_key(slots_hash,&assocKey,&numKey,0);
 			zend_hash_get_current_data(slots_hash,(void**)&slotdata);
+
+#if MOC_DEBUG
+			qr->append(Z_STRVAL_PP(slotdata));
+			qr->append(" ");
+			cout << "\t" << signaturecount << "8 8 8 0x0a ::s" << endl;
+#endif
 	
 			meta_stringdata->append(Z_STRVAL_PP(slotdata));
 			meta_stringdata->append(QChar::Null);
-	
+
 			zend_hash_move_forward(slots_hash);
 	
 			/// write slot signature
@@ -815,6 +872,10 @@
 			signaturecount += strlen(Z_STRVAL_PP(slotdata)) + 1;
 	
 		}
+#if MOC_DEBUG
+		cout << qr->toAscii().constData() << endl;
+		cout << "+== end metaobject dump ==+" << endl;
+#endif
 		return true;
 	} else {
 		return false;
@@ -855,7 +916,6 @@
 
 char*
 phpqt_checkForOperator(const char* fname){
-#warning skip operator support
 	return (char*) fname;
 }
 

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-03-04 16:18:29 UTC (rev 300)
+++ trunk/php_qt/php_qt.h	2007-03-05 14:54:06 UTC (rev 301)
@@ -102,6 +102,7 @@
     int classId;
     void *ptr;
     zend_class_entry *ce_ptr;
+    zend_class_entry *parent_ce_ptr;
     zval *zval_ptr;
     QMetaObject* meta;
 };
@@ -133,9 +134,9 @@
 
 void 				smokephp_convertArgsCxxToZend(zval*** args, int argc, Smoke::StackItem* qargs);
 bool 				smokephp_isQObject(Smoke *smoke, Smoke::Index classId);
-Smoke::Index 		smokephp_getClassId(const char* classname);
+Smoke::Index 			smokephp_getClassId(const char* classname);
 void				smokephp_convertArgsZendToCxx(zval*** args, int argc, Smoke::StackItem* qargs, QStack<QString*> &methodNameStack);
-Smoke::Index		smokephp_getMethod(Smoke *smoke, const char* c, const char* m, Smoke::StackItem** qargs, int argc, zval*** args);
+Smoke::Index			smokephp_getMethod(Smoke *smoke, const char* c, const char* m, Smoke::StackItem** qargs, int argc, zval*** args);
 void				smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method);
 void				smokephp_callMethod(Smoke *smoke, void *obj, Smoke::Index method, Smoke::Stack qargs);
 void				smokephp_convertReturn(Smoke::StackItem *ret_val, const Smoke::Type type, const Smoke::Index ret, zval* return_value);
@@ -144,6 +145,7 @@
 bool				smokephp_isConnect(Smoke::Index method);
 
 
+
 class SmokeType {
     Smoke::Type *_t;		// derived from _smoke and _id, but cached
 

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-03-04 16:18:29 UTC (rev 300)
+++ trunk/php_qt/qstring.cpp	2007-03-05 14:54:06 UTC (rev 301)
@@ -909,6 +909,25 @@
  */
 ZEND_METHOD(QString, number){
 
+	if (ZEND_NUM_ARGS() == 1){
+		/* ol public*/
+		/* int , */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+				QString *obj = (QString*) PHP_QT_FETCH();
+				QString return_object = (QString) obj->number((ulong) Z_LVAL_P(z_0));
+				zend_class_entry *ce;
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+
+
 	if (ZEND_NUM_ARGS() == 2){
 		/* ol public*/
 
@@ -2586,12 +2605,16 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 			RETURN_LONG(obj->toInt((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
 			}
 		}
 	}
+
+	if (ZEND_NUM_ARGS() == 0){
+	    QString *obj = (QString*) PHP_QT_FETCH();
+	    RETURN_LONG(obj->toInt());
+	}
+
 }
 
 /*********************************

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-03-04 16:18:29 UTC (rev 300)
+++ trunk/php_qt/smokephp.cpp	2007-03-05 14:54:06 UTC (rev 301)
@@ -410,7 +410,6 @@
 			    phpqt_register(o->zval_ptr,le);
 			    phpqt_setZvalPtr(o, o->zval_ptr);
         		}
-
         		methodNameStack.top()->append("$");
 
 	    } else if (type == IS_OBJECT){



From tm243 at mail.berlios.de  Tue Mar  6 08:47:59 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Tue, 6 Mar 2007 08:47:59 +0100
Subject: [Php-qt-svn] r302 - trunk/php_qt
Message-ID: <200703060747.l267lxn2007563@sheep.berlios.de>

Author: tm243
Date: 2007-03-06 08:47:58 +0100 (Tue, 06 Mar 2007)
New Revision: 302

Modified:
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/qstring.cpp
Log:
* work on QString __construct(), toInt(), number()



Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-03-05 14:54:06 UTC (rev 301)
+++ trunk/php_qt/php_qt.cpp	2007-03-06 07:47:58 UTC (rev 302)
@@ -968,3 +968,25 @@
 	return (SmokeQtObjects.find(ptr) != SmokeQtObjects.end());
 }
 
+void
+phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce){
+
+	if(!ce) {
+	    ce = Z_OBJCE_P(zval_ptr);
+	}
+
+	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
+	o->ptr = ptr;
+	o->zval_ptr = zval_ptr;
+	o->ce_ptr = ce;
+	o->classId = 0;	// QString is not in smoke
+	o->smoke = qt_Smoke;
+	phpqt_setSmokePHPObject(o);
+	// register all 
+	zend_rsrc_list_entry le;
+	le.ptr = o;
+	object_init_ex(zval_ptr, qstring_ce);
+	phpqt_register(o->zval_ptr,le);
+	phpqt_setZvalPtr(o, o->zval_ptr);
+
+}

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-03-05 14:54:06 UTC (rev 301)
+++ trunk/php_qt/php_qt.h	2007-03-06 07:47:58 UTC (rev 302)
@@ -128,6 +128,7 @@
 smokephp_object*		phpqt_getSmokePHPObjectFromQt(void* QtPtr);
 void				phpqt_setSmokePHPObject(smokephp_object* o);
 bool				phpqt_SmokePHPObjectExists(void* ptr);
+void				phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL);
 
 extern int le_php_qt_hashtype;
 extern HashTable php_qt_objptr_hash;

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-03-05 14:54:06 UTC (rev 301)
+++ trunk/php_qt/qstring.cpp	2007-03-06 07:47:58 UTC (rev 302)
@@ -128,7 +128,6 @@
 
 }
 
-
 ZEND_METHOD(QString,__toString){
 
   QString *QString_ptr = (QString *) PHP_QT_FETCH();
@@ -140,7 +139,6 @@
   RETURN_STRING(c,l);
 }
 
-
 /*		public enumSectionFlag:long {
 			SectionDefault = 0x00,
 			SectionSkipEmpty = 0x01,
@@ -625,84 +623,50 @@
  */
 ZEND_METHOD(QString, __construct){
 
-	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
-//	o->ptr = ret_val->s_voidp;
-	o->zval_ptr = getThis();
-	o->ce_ptr = qstring_ce;
-	o->classId = 0;	// QString is not in smoke
-	o->smoke = qt_Smoke;
-	phpqt_setSmokePHPObject(o);
-	// register all 
-	zend_rsrc_list_entry le;
-	le.ptr = o;
-	object_init_ex(return_value, qstring_ce);
-	phpqt_register(o->zval_ptr,le);
-	phpqt_setZvalPtr(o, o->zval_ptr);
-
 	if (ZEND_NUM_ARGS() == 0){
 	    QString *QString_ptr = new QString();
-	    o->ptr = (void*) QString_ptr;
-//	    PHP_QT_REGISTER(QString_ptr);
+	    phpqt_createObject(getThis(), (void*) QString_ptr, qstring_ce);
 	    RETURN_NULL();
 	}
 
 	if (ZEND_NUM_ARGS() == 1){
-		/* l public*/
-
-		/* char c,  */
-		/* s public*/
-
-		/* const char* ch,  */
-		/* o public*/
-
-		/* const QLatin1String& latin1,  */
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG){
-
-
-			QString *QString_ptr = new QString((char) Z_LVAL_P(z_0));
-			o->ptr = (void*) QString_ptr;
-//				PHP_QT_REGISTER(QString_ptr);
+				QString *QString_ptr = new QString((char) Z_LVAL_P(z_0));
+				phpqt_createObject(getThis(), (void*) QString_ptr, qstring_ce);
 				RETURN_NULL();
 			}
 			if(Z_TYPE_P(z_0) == IS_STRING){
-
-			QString *QString_ptr = new QString( (const char*) Z_STRVAL_P(z_0));
-				o->ptr = (void*) QString_ptr;
-//				PHP_QT_REGISTER(QString_ptr);
+				QString *QString_ptr = new QString( (const char*) Z_STRVAL_P(z_0));
+				phpqt_createObject(getThis(), (void*) QString_ptr, qstring_ce);
 				RETURN_NULL();
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
-
-
+				smokephp_object *o = phpqt_getSmokePHPObjectFromZval(z_0);
+				if(o->ce_ptr == qstring_ce){
+				    QString *QString_ptr = new QString(*((QString*) o->ptr));
+				}
+				phpqt_createObject(getThis(), (void*) o->ptr, o->ce_ptr);
+				RETURN_NULL();
 			}
 		}
 	}
 
 	if (ZEND_NUM_ARGS() == 2){
-		/* ol public*/
-
-		/* const QChar* unicode, int size,  */
-		/* ll public*/
-
-		/* int size, char c,  */
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG){
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
-
-
+			    smokephp_object* o = phpqt_getSmokePHPObjectFromZval(z_0);
+// TODO type checking
+    			    phpqt_createObject(getThis(), o->ptr, o->ce_ptr);
+			    RETURN_NULL();
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-
-
-			QString *QString_ptr = new QString((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
-			o->ptr = (void*) QString_ptr;
-//				PHP_QT_REGISTER(QString_ptr);
-				RETURN_NULL();
+			    QString *QString_ptr = new QString((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
+			    phpqt_createObject(getThis(), QString_ptr, qstring_ce);
+			    RETURN_NULL();
 			}
 		}
 	}
@@ -915,14 +879,11 @@
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG){
-				QString *obj = (QString*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->number((ulong) Z_LVAL_P(z_0));
-				zend_class_entry *ce;
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				QString obj = (QString) QString::number((ulong) Z_LVAL_P(z_0));
+				QString *s1 = new QString(obj);
+				object_init_ex(return_value, qstring_ce);
+				phpqt_createObject(return_value, (void*) s1, qstring_ce);
+				return;
 			}
 		}
 	}



From tm243 at mail.berlios.de  Tue Mar  6 21:58:02 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Tue, 6 Mar 2007 21:58:02 +0100
Subject: [Php-qt-svn] r303 - trunk/php_qt
Message-ID: <200703062058.l26Kw2mD003571@sheep.berlios.de>

Author: tm243
Date: 2007-03-06 21:58:02 +0100 (Tue, 06 Mar 2007)
New Revision: 303

Modified:
   trunk/php_qt/qstring.cpp
Log:
* more work on QString



Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-03-06 07:47:58 UTC (rev 302)
+++ trunk/php_qt/qstring.cpp	2007-03-06 20:58:02 UTC (rev 303)
@@ -134,7 +134,8 @@
 
   int l = QString_ptr->size();
 
-  char* c = (char*) (QString_ptr->toUtf8()).constData();
+//  char* c = (char*) (QString_ptr->toUtf8()).constData();
+  char* c = (char*) (QString_ptr->toAscii()).constData();
 
   RETURN_STRING(c,l);
 }
@@ -305,10 +306,11 @@
  */
 ZEND_METHOD(QString, clear){
 	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			obj->clear();
-			RETURN_NULL();
+	    QString *obj = (QString*) PHP_QT_FETCH();
+	    obj->clear();
+	    RETURN_NULL();
 	}
+	php_error(E_ERROR, "wrong argument in QString clear()");
 }
 
 /*********************************
@@ -870,12 +872,18 @@
 /*
  *    function  number
  *    flags:    s
+ *
+ *	QString number ( long n, int base = 10 ) 
+ *	QString number ( ulong n, int base = 10 ) 
+ *	QString number ( int n, int base = 10 ) 
+ *	QString number ( uint n, int base = 10 ) 
+ *	QString number ( qlonglong n, int base = 10 ) 
+ *	QString number ( qulonglong n, int base = 10 ) 
+ *	QString number ( double n, char format = 'g', int precision = 6 )
  */
 ZEND_METHOD(QString, number){
 
 	if (ZEND_NUM_ARGS() == 1){
-		/* ol public*/
-		/* int , */
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG){
@@ -884,18 +892,18 @@
 				object_init_ex(return_value, qstring_ce);
 				phpqt_createObject(return_value, (void*) s1, qstring_ce);
 				return;
+			} else if(Z_TYPE_P(z_0) == IS_DOUBLE){
+				QString obj = (QString) QString::number((double) Z_DVAL_P(z_0));
+				QString *s1 = new QString(obj);
+				object_init_ex(return_value, qstring_ce);
+				phpqt_createObject(return_value, (void*) s1, qstring_ce);
+				return;
 			}
+			
 		}
 	}
 
-
 	if (ZEND_NUM_ARGS() == 2){
-		/* ol public*/
-
-		/* unsigned long , int base,  */
-		/* ll public*/
-
-		/* int , int base,  */
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
@@ -927,9 +935,6 @@
 	}
 
 	if (ZEND_NUM_ARGS() == 3){
-		/* lll public*/
-
-		/* double , char f, int prec,  */
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		zval *z_2; // define ZVAL
@@ -948,6 +953,7 @@
 			}
 		}
 	}
+	php_error(E_ERROR, "wrong argument in QString::number()");
 }
 
 /*********************************
@@ -1523,9 +1529,10 @@
  */
 ZEND_METHOD(QString, isEmpty){
 	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			RETURN_BOOL(obj->isEmpty());
+	    QString *obj = (QString*) PHP_QT_FETCH();
+	    RETURN_BOOL(obj->isEmpty());
 	}
+	php_error(E_ERROR, "wrong argument in QString isEmpty()");
 }
 
 /*********************************
@@ -2187,17 +2194,9 @@
 ZEND_METHOD(QString, append){
 
 	if (ZEND_NUM_ARGS() == 1){
-		/* l public*/
-
-		/* char c,  */
-		/* s public*/
-
-		/* const char* s,  */
-		/* o public*/
-
-		/* const QString& s,  */
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
+			/* QString & append ( QChar ch ) */
 			if(Z_TYPE_P(z_0) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->append((char) Z_LVAL_P(z_0));
@@ -2208,10 +2207,9 @@
 				phpqt_register(return_value,le);                   
 				return;                                             
 			}
+			/* QString & append ( const char * str ) */
 			if(Z_TYPE_P(z_0) == IS_STRING){
-			QString *obj = (QString*) PHP_QT_FETCH();
-
-
+				QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->append( (const char*) Z_STRVAL_P(z_0));
 				zend_class_entry *ce;                                   
 				object_init_ex(return_value, qstring_ce);     
@@ -2220,11 +2218,17 @@
 				phpqt_register(return_value,le);                   
 				return;                                             
 			}
+
+			/*  QString & append ( const QLatin1String & str )
+			    QString & append ( const QByteArray & ba )
+			    QString & append ( const QString & str ) */
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
-			    QString *obj = (QString*) PHP_QT_FETCH();
+			    smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
 			    QString* obj_z_0 = (QString*) phpqt_getQtObjectFromZval(z_0);
-			    obj->append((QString) *obj_z_0);
-			    RETURN_NULL();
+			    QString s = ((QString*) o->ptr)->append((QString) *obj_z_0);
+			    object_init_ex(return_value, qstring_ce);     
+			    phpqt_createObject(return_value, &s, qstring_ce);
+			    return;
 			}
 		}
 	}
@@ -2269,20 +2273,22 @@
  */
 ZEND_METHOD(QString, toDouble){
 
+	/* double toDouble ( bool * ok = 0 ) const */
 	if (ZEND_NUM_ARGS() == 1){
-		/* l public*/
-
-		/* int* ok,  */
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-
-
-			RETURN_DOUBLE(obj->toDouble((bool*) Z_LVAL_P(z_0)));
+			    QString *obj = (QString*) PHP_QT_FETCH();
+			    RETURN_DOUBLE(obj->toDouble((bool*) Z_LVAL_P(z_0)));
 			}
 		}
 	}
+	if(ZEND_NUM_ARGS() == 0) {
+	    QString *obj = (QString*) PHP_QT_FETCH();
+	    RETURN_DOUBLE(obj->toDouble());
+	}
+	php_error(E_ERROR, "wrong argument in QString toDouble()");
+
 }
 
 /*********************************



From tm243 at mail.berlios.de  Thu Mar  8 22:16:51 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Thu, 8 Mar 2007 22:16:51 +0100
Subject: [Php-qt-svn] r304 - trunk/tests
Message-ID: <200703082116.l28LGp0G010614@sheep.berlios.de>

Author: tm243
Date: 2007-03-08 22:16:51 +0100 (Thu, 08 Mar 2007)
New Revision: 304

Added:
   trunk/tests/QStringTestCase.php
Log:
* test case for QString



Added: trunk/tests/QStringTestCase.php
===================================================================
--- trunk/tests/QStringTestCase.php	2007-03-06 20:58:02 UTC (rev 303)
+++ trunk/tests/QStringTestCase.php	2007-03-08 21:16:51 UTC (rev 304)
@@ -0,0 +1,76 @@
+<?php
+
+    /**
+     *	This file contains a couple of QString tests
+     */
+
+    require_once('PHPUnit/Framework/TestCase.php');
+    require_once('PHPUnit/Framework/TestSuite.php');
+
+    class QStringTestCase extends PHPUnit_Framework_TestCase {
+    
+	public function __construct($name) {
+	    parent::__construct($name);
+	}
+
+	function test_construct() {
+	    $s1 = new QString("bird");
+	    $s2 = new QString($s1);	   // QString ( const QString & other ) 
+	    $this->assertEquals($s2->__toString(), "bird", "Could not construct QString!");
+	    $s3 = new QString(40);	   // QString ( QChar ch ) 
+	    $this->assertEquals($s3->__toString(), "(", "Could not construct QString!");
+	    $s4 = new QString("helicopter");
+	    $this->assertEquals($s4->__toString(), "helicopter", "Could not construct QString!");
+//	    $s5 = new QString(40,3);
+//	    $this->assertEquals($s5->__toString(), "(((", "Could not construct QString!");
+	    echo "\ntesting QString::__construct() passed";
+	}
+
+	function test_append() {
+	    $s1 = new QString("bird");
+	    $s2 = new QString(" plug");
+	    $s1->append($s2);
+	    $this->assertEquals($s1->__toString(), "bird plug", "Could not append QString to QString!");
+	    $s1->append(" helicopter");
+	    $this->assertEquals($s1->__toString(), "bird plug helicopter", "Could not append string to QString!");
+	    $s1->append(40);
+	    $this->assertEquals($s1->__toString(), "bird plug helicopter(", "Could not append QChar to QString!");
+	    echo "\ntesting QString::append() passed";
+	}
+
+	function test_toInt() {
+	    $s1 = new QString("24");
+	    $this->assertEquals($s1->toInt(), 24, "Could not get integer!");
+	    echo "\ntesting QString::toInt() passed";
+	}
+
+	function test_toDouble() {
+	    $s1 = new QString("24.3");
+	    $this->assertEquals($s1->toDouble(), 24.3, "Could not get double!");
+	    echo "\ntesting QString::toDouble() passed";
+	}
+
+	function test_number() {
+	    $this->assertEquals(QString::number(24)->__toString(), "24", "Could not get string version of integer!");
+	    $this->assertEquals(QString::number(24.3)->__toString(), "24.3", "Could not get string version of double!");
+	    echo "\ntesting QString::number() passed";
+	}
+
+	function test_isEmpty() {
+	    $s1 = new QString();
+	    $this->assertTrue($s1->isEmpty(), "Could not ask isEmpty()!");
+	    $s1->append("I");
+	    $this->assertFalse($s1->isEmpty(), "Could not ask isEmpty()!");
+	    echo "\ntesting QString::isEmpty() passed";
+	}
+
+	function test_clear() {
+	    $s1 = new QString("hello");
+	    $s1->clear();
+	    $this->assertEquals($s1->__toString(), "", "Could not clear()!");
+	    echo "\ntesting QString::clear() passed";
+	}
+
+    }    
+    
+?>
\ No newline at end of file



From tm243 at mail.berlios.de  Wed Mar 21 14:08:34 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 21 Mar 2007 14:08:34 +0100
Subject: [Php-qt-svn] r305 - in trunk: . examples/calculator php_qt tests
Message-ID: <200703211308.l2LD8YWO018140@sheep.berlios.de>

Author: tm243
Date: 2007-03-21 14:08:26 +0100 (Wed, 21 Mar 2007)
New Revision: 305

Added:
   trunk/php_qt/handlers.cpp
   trunk/php_qt/marshall.h
   trunk/php_qt/marshall_basetypes.h
   trunk/php_qt/marshall_primitives.h
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/marshall_types.h
Modified:
   trunk/CREDITS
   trunk/ChangeLog
   trunk/examples/calculator/main.php
   trunk/php_qt/CMakeLists.txt
   trunk/php_qt/functions.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/qstring.cpp
   trunk/php_qt/smokephp.cpp
   trunk/tests/QtBasicTestCase.php
Log:
* object oriented handlers



Modified: trunk/CREDITS
===================================================================
--- trunk/CREDITS	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/CREDITS	2007-03-21 13:08:26 UTC (rev 305)
@@ -3,10 +3,15 @@
 Thomas Moenicke <thomas.moenicke at kdemail.net>
     main developer, maintainer
 
-Katrina Niolet  <kniolet at ildiinc.com>?
-    contributor
+contributors
+    Katrina Niolet
+    Jean-Luc Gyger
+    Ferenc Veres
 
-Jean-Luc Gyger <jean_luc.gyger at freesurf.ch>
-    developer
+parts of PHP-Qt are derived from the QtRuby sources, written by:
+	Richard Dale
 
-Thanks to Ferenc Veres for testing and suggestions.
+	which is a ruby version of the PerlQt/Smoke project, written by:
+	    Ashley Winters
+	    Germain Garand
+	    David Faure

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/ChangeLog	2007-03-21 13:08:26 UTC (rev 305)
@@ -1,5 +1,9 @@
 2007-003-4  Thomas Moenicke <thomas.moenicke at kdemail.net>
 
+		* object oriented handlers (see QtRuby)
+
+2007-003-4  Thomas Moenicke <thomas.moenicke at kdemail.net>
+
 		* Debugging for metaobject system added
 		* parent_ce_ptr
 

Modified: trunk/examples/calculator/main.php
===================================================================
--- trunk/examples/calculator/main.php	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/examples/calculator/main.php	2007-03-21 13:08:26 UTC (rev 305)
@@ -15,7 +15,7 @@
 
     require_once('calculator.php');
 
-    $app = new QApplication(&$argc,$argv);
+    $app = new QApplication($argc,$argv);
 
     $calc = new Calculator();
     $calc->show();

Modified: trunk/php_qt/CMakeLists.txt
===================================================================
--- trunk/php_qt/CMakeLists.txt	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/php_qt/CMakeLists.txt	2007-03-21 13:08:26 UTC (rev 305)
@@ -18,6 +18,8 @@
     php_qt.cpp
     smokephp.cpp
     qstring.cpp
+    marshall_types.cpp
+    handlers.cpp
     )
 
 add_library(php_qt SHARED ${phpqt_LIB_SRCS})

Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/php_qt/functions.cpp	2007-03-21 13:08:26 UTC (rev 305)
@@ -98,6 +98,31 @@
     return;
 }
 
+/*!
+ *  emits a signal
+ */
+
+PHP_FUNCTION(emit)
+{
+    const char* string;
+    int string_len;
+    if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s",&string,&string_len)) {
+        return;
+    }
+
+    char* tmp = (char*) emalloc((int) string_len + 2);
+    strcpy(tmp,"1");
+
+    strncat(tmp, string, (int) string_len);
+
+    ZVAL_STRING(return_value,tmp,1);
+
+    efree(tmp);
+
+    return;
+}
+
+
 /**
  *	simply returns the first parameter because objects are casted automatically in smokephp_convertReturn(...)
  *
@@ -152,13 +177,14 @@
  *
  */
 
-PHP_FUNCTION(check_qobject)
+
+void check_object(zval* zobject)
 {
-    zval* zobject;
-    if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"o",&zobject)) {
-        return;
-    }
 
+	if(!phpqt_SmokePHPObjectExists(zobject)) {
+	    php_error(E_ERROR,"Object is not registered.");
+	}
+
 	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(zobject);
 
 	cout << "PHP-Qt object \n(" << endl;
@@ -167,7 +193,7 @@
 	cout << "\tclass entry => " << Z_OBJCE_P(zobject)->name << endl;
 	cout << "\t  ref count => " << zobject->refcount << endl;
 	cout << "\t     is_ref => " << zobject->is_ref << endl;
-	cout << "\t       type => " << zobject->type << endl;
+	cout << "\t       type => " << Z_TYPE_P(zobject) << endl;
 
 	cout << endl;
 
@@ -182,3 +208,14 @@
 	cout << ")" << endl;
 
 }
+
+PHP_FUNCTION(check_qobject)
+{
+
+    zval* zobject;
+    if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"o",&zobject)) {
+        return;
+    }
+
+    check_object(zobject);
+}

Added: trunk/php_qt/handlers.cpp
===================================================================
--- trunk/php_qt/handlers.cpp	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/php_qt/handlers.cpp	2007-03-21 13:08:26 UTC (rev 305)
@@ -0,0 +1,339 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <QtCore/qprocess.h>
+#include <QtCore/qtextcodec.h>
+
+#include "smoke.h"
+#include "marshall.h"
+#include "php_qt.h"
+#include "smokephp.h"
+
+extern zend_class_entry* qstring_ce;
+
+bool
+matches_arg(Smoke *smoke, Smoke::Index meth, Smoke::Index argidx, const char *argtype)
+{
+	Smoke::Index *arg = smoke->argumentList + smoke->methods[meth].args + argidx;
+	SmokeType type = SmokeType(smoke, *arg);
+	if (type.name() && qstrcmp(type.name(), argtype) == 0) {
+		return true;
+	}
+	return false;
+}
+
+void*
+construct_copy(smokephp_object *o)
+{
+    const char *className = o->smoke->className(o->classId);
+    int classNameLen = strlen(className);
+    char *ccSig = new char[classNameLen + 2];       // copy constructor signature
+    strcpy(ccSig, className);
+    strcat(ccSig, "#");
+    Smoke::Index ccId = o->smoke->idMethodName(ccSig);
+    delete[] ccSig;
+
+    char *ccArg = new char[classNameLen + 8];
+    sprintf(ccArg, "const %s&", className);
+
+    Smoke::Index ccMeth = o->smoke->findMethod(o->classId, ccId);
+
+    if(!ccMeth) {
+	delete[] ccArg;
+	return 0;
+    }
+
+    Smoke::Index method = o->smoke->methodMaps[ccMeth].method;
+    if(method > 0) {
+	// Make sure it's a copy constructor
+	if(!matches_arg(o->smoke, method, 0, ccArg)) {
+            delete[] ccArg;
+	    return 0;
+        }
+        delete[] ccArg;
+        ccMeth = method;
+    } else {
+        // ambiguous method, pick the copy constructor
+	Smoke::Index i = -method;
+	while(o->smoke->ambiguousMethodList[i]) {
+	    if(matches_arg(o->smoke, o->smoke->ambiguousMethodList[i], 0, ccArg))
+		break;
+            i++;
+	}
+        delete[] ccArg;
+	ccMeth = o->smoke->ambiguousMethodList[i];
+	if(!ccMeth)
+	    return 0;
+    }
+
+    // Okay, ccMeth is the copy constructor. Time to call it.
+    Smoke::StackItem args[2];
+    args[0].s_voidp = 0;
+    args[1].s_voidp = o->ptr;
+    Smoke::ClassFn fn = o->smoke->classes[o->classId].classFn;
+    (*fn)(o->smoke->methods[ccMeth].method, 0, args);
+    return args[0].s_voidp;
+}
+
+
+#include "marshall_basetypes.h"
+template <class T>
+static void marshall_it(Marshall *m)
+{
+	switch(m->action()) {
+		case Marshall::FromZVAL:
+			marshall_from_php<T>(m);
+		break;
+ 
+		case Marshall::ToZVAL:
+			marshall_to_php<T>( m );
+		break;
+				
+		default:
+			m->unsupported();
+		break;
+	}
+}
+
+void
+marshall_basetype(Marshall *m)
+{
+	switch(m->type().elem()) {
+
+		case Smoke::t_bool:
+			marshall_it<bool>(m);
+		break;
+
+		case Smoke::t_char:
+			marshall_it<signed char>(m);
+		break;
+		
+		case Smoke::t_uchar:
+			marshall_it<unsigned char>(m);
+		break;
+ 
+		case Smoke::t_short:
+			marshall_it<short>(m);
+		break;
+      
+		case Smoke::t_ushort:
+			marshall_it<unsigned short>(m);
+		break;
+
+		case Smoke::t_int:
+			marshall_it<int>(m);
+		break;
+		
+		case Smoke::t_uint:
+			marshall_it<unsigned int>(m);
+		break;
+ 
+		case Smoke::t_long:
+			marshall_it<long>(m);
+		break;
+
+		case Smoke::t_ulong:
+			marshall_it<unsigned long>(m);
+		break;
+ 
+		case Smoke::t_float:
+			marshall_it<float>(m);
+		break;
+
+		case Smoke::t_double:
+			marshall_it<double>(m);
+		break;
+
+		case Smoke::t_enum:
+			marshall_it<SmokeEnumWrapper>(m);
+		break;
+     
+		case Smoke::t_class:
+			marshall_it<SmokeClassWrapper>(m);
+		break;
+
+		default:
+			m->unsupported();
+		break;	
+	}
+
+}
+
+static void marshall_void(Marshall * /*m*/) {}
+static void marshall_unknown(Marshall *m) {
+    m->unsupported();
+}
+
+static void marshall_charPP(Marshall *m) {
+    m->item().s_voidp = transformArray(m->var());
+    m->next();
+}
+
+static void marshall_charP(Marshall *m) {
+  marshall_it<char *>(m);
+}
+
+void marshall_ucharP(Marshall *m) {
+  marshall_it<unsigned char *>(m);
+}
+
+static const char * KCODE = "NONE";
+static QTextCodec *codec = 0;
+
+static void 
+init_codec() {
+//	zval* temp = read from php.ini
+//	KCODE = temp->value.str.val;
+
+	if (qstrcmp(KCODE, "EUC") == 0) {
+		codec = QTextCodec::codecForName("eucJP");
+	} else if (qstrcmp(KCODE, "SJIS") == 0) {
+		codec = QTextCodec::codecForName("Shift-JIS");
+	}
+}
+
+
+QString* 
+qstringFromZString(zval* zstring) {
+	if (KCODE == 0) {
+		init_codec();
+	}
+
+	if (qstrcmp(KCODE, "UTF8") == 0)
+		return new QString(QString::fromUtf8(zstring->value.str.val, zstring->value.str.len));
+	else if (qstrcmp(KCODE, "EUC") == 0)
+		return new QString(codec->toUnicode(zstring->value.str.val));
+	else if (qstrcmp(KCODE, "SJIS") == 0)
+		return new QString(codec->toUnicode(zstring->value.str.val));
+	else if(qstrcmp(KCODE, "NONE") == 0)
+		return new QString(QString::fromLatin1(zstring->value.str.val));
+
+	return new QString(QString::fromLocal8Bit(zstring->value.str.val, zstring->value.str.len));
+}
+
+zval* 
+zstringFromQString(QString * s) {
+	if (KCODE == 0) {
+		init_codec();
+	}
+
+	zval* return_value = (zval*) emalloc(sizeof(zval));
+	if (qstrcmp(KCODE, "UTF8") == 0) {
+		ZVAL_STRING(return_value, (char*) s->toUtf8().constData(), /* duplicate */ 1);
+	} else if (qstrcmp(KCODE, "EUC") == 0) {
+		ZVAL_STRING(return_value, (char*) codec->fromUnicode(*s).constData(), /* duplicate */ 1);
+	} else if (qstrcmp(KCODE, "SJIS") == 0) {
+		ZVAL_STRING(return_value, (char*) codec->fromUnicode(*s).constData(), /* duplicate */ 1);
+	} else if (qstrcmp(KCODE, "NONE") == 0) {
+		ZVAL_STRING(return_value, (char*) s->toLatin1().constData(), /* duplicate */ 1);
+	} else {
+		ZVAL_STRING(return_value, (char*) s->toUtf8().constData(), /* duplicate */ 1);
+	}
+	return return_value;
+}
+
+
+static void marshall_QString(Marshall *m) {
+	switch(m->action()) {
+		case Marshall::FromZVAL:
+		{
+			if(Z_TYPE_P(m->var()) != IS_STRING){ // is object
+			    m->item().s_voidp = phpqt_getQtObjectFromZval(m->var());
+			    m->next();
+			    break;
+			}
+
+			QString* s = 0;
+			if( m->var() != Qnil) {
+				s = qstringFromZString(m->var());
+			} else {
+				s = new QString();
+			}
+
+			m->item().s_voidp = s;
+			m->next();
+
+			if (!m->type().isConst() && m->var() != Qnil && s != 0 && !s->isNull()) {
+				m->var()->value.str.len = 0;
+				zval* temp = zstringFromQString(s);
+				ZVAL_STRING(m->var(), temp->value.str.val, 1);
+			}
+
+			if (s != 0 && m->cleanup()) {
+				delete s;
+			}
+		}
+		break;
+
+		case Marshall::ToZVAL:
+		{
+			QString* s = (QString*) m->item().s_voidp;
+			phpqt_createObject(m->retval(), (void*) s, qstring_ce);
+
+			if(s) {
+				if (s->isNull()) {
+					m->setRetval(Qnil);
+				}
+			} else {
+				m->setRetval(Qnil);
+			}
+		}
+		break;
+ 
+		default:
+			m->unsupported();
+		break;
+
+   }
+}
+
+static void marshall_IntR(Marshall *m) {
+    m->item().s_voidp = &Z_LVAL_P(m->var());
+    m->next();
+}
+
+TypeHandler Qt_handlers[] = {
+    { "WId", marshall_it<WId> },
+    { "Q_PID", marshall_it<Q_PID> },
+    { "QString", marshall_QString },
+    { "QString&", marshall_QString },
+    { "QString*", marshall_QString },
+    { "int&", marshall_IntR },
+    { "char**", marshall_charPP },
+    { "char*", marshall_charP },
+    { 0, 0 }
+};
+
+QHash<QByteArray, TypeHandler*> type_handlers;
+
+void install_handlers(TypeHandler *h) {
+	while(h->name) {
+		type_handlers.insert(h->name, h);
+		h++;
+	}
+}
+
+Marshall::HandlerFn getMarshallFn(const SmokeType &type) {
+	if(type.elem())
+		return marshall_basetype;
+	if(!type.name())
+		return marshall_void;
+
+	TypeHandler *h = type_handlers[type.name()];
+
+	if(h == 0 && type.isConst() && strlen(type.name()) > strlen("const ")) {
+			h = type_handlers[type.name() + strlen("const ")];
+	}
+	
+	if(h != 0) {
+		return h->fn;
+	}
+
+	return marshall_unknown;
+}

Added: trunk/php_qt/marshall.h
===================================================================
--- trunk/php_qt/marshall.h	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/php_qt/marshall.h	2007-03-21 13:08:26 UTC (rev 305)
@@ -0,0 +1,69 @@
+#ifndef MARSHALL_H
+#define MARSHALL_H
+
+#include <smoke.h>
+#include <php.h>
+
+class SmokeType;
+
+class Marshall {
+public:
+    /**
+     * FromZVAL is used for virtual function return ce_ptrs and regular
+     * method arguments.
+     *
+     * ToZVAL is used for method return-values and virtual function
+     * arguments.
+     */
+    typedef void (*HandlerFn)(Marshall *);
+    enum Action { FromZVAL, ToZVAL };
+    virtual SmokeType type() = 0;
+    virtual Action action() = 0;
+    virtual Smoke::StackItem &item() = 0;
+    virtual zval* var() = 0;
+    virtual void unsupported() = 0;
+    virtual Smoke *smoke() = 0;
+    /**
+     * For return-values, next() does nothing.
+     * For FromRV, next() calls the method and returns.
+     * For ToRV, next() calls the virtual function and returns.
+     *
+     * Required to reset Marshall object to the state it was
+     * before being called when it returns.
+     */
+    virtual void next() = 0;
+    /**
+     * For FromSV, cleanup() returns false when the handler should free
+     * any allocated memory after next().
+     *
+     * For ToSV, cleanup() returns true when the handler should delete
+     * the pointer passed to it.
+     */
+    virtual bool cleanup() = 0;
+
+    zval* retval() {return _retval;};
+    zval* setRetval(zval* retval) {_retval = retval;};
+
+    virtual ~Marshall() {}
+
+protected:
+    zval* _retval;
+
+};    
+
+class SmokeEnumWrapper {
+public:
+	Marshall *m;
+};	
+
+class SmokeClassWrapper {
+public:
+  Marshall *m;
+};
+
+struct TypeHandler {
+    const char *name;
+    Marshall::HandlerFn fn;
+};
+
+#endif

Added: trunk/php_qt/marshall_basetypes.h
===================================================================
--- trunk/php_qt/marshall_basetypes.h	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/php_qt/marshall_basetypes.h	2007-03-21 13:08:26 UTC (rev 305)
@@ -0,0 +1,220 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+template <class T> T* smoke_ptr(Marshall *m) { return (T*) m->item().s_voidp; }
+
+template<> bool* smoke_ptr<bool>(Marshall *m) { return &m->item().s_bool; }
+template<> signed char* smoke_ptr<signed char>(Marshall *m) { return &m->item().s_char; }
+template<> unsigned char* smoke_ptr<unsigned char>(Marshall *m) { return &m->item().s_uchar; }
+template<> short* smoke_ptr<short>(Marshall *m) { return &m->item().s_short; }
+template<> unsigned short* smoke_ptr<unsigned short>(Marshall *m) { return &m->item().s_ushort; }
+template<> int* smoke_ptr<int>(Marshall *m) { return &m->item().s_int; }
+template<> unsigned int* smoke_ptr<unsigned int>(Marshall *m) { return &m->item().s_uint; }
+template<> long* smoke_ptr<long>(Marshall *m) { 	return &m->item().s_long; }
+template<> unsigned long* smoke_ptr<unsigned long>(Marshall *m) { return &m->item().s_ulong; }
+template<> float* smoke_ptr<float>(Marshall *m) { return &m->item().s_float; }
+template<> double* smoke_ptr<double>(Marshall *m) { return &m->item().s_double; }
+template<> void* smoke_ptr<void>(Marshall *m) { return m->item().s_voidp; }
+
+template <class T> T php_to_primitive(zval*);
+template <class T> zval* primitive_to_php(T, zval* return_value);
+
+template <class T> 
+static void marshall_from_php(Marshall *m) 
+{
+	zval* obj = m->var();
+	(*smoke_ptr<T>(m)) = php_to_primitive<T>(obj);
+}
+
+template <class T>
+static void marshall_to_php(Marshall *m)
+{
+	m->setRetval(primitive_to_php<T>( *smoke_ptr<T>(m) , m->retval()));
+}
+
+#include "marshall_primitives.h"
+//#include "marshall_complex.h"
+
+// Special case marshallers
+
+template <> 
+static void marshall_from_php<char *>(Marshall *m) 
+{
+	zval* obj = m->var();
+	m->item().s_voidp = php_to_primitive<char*>(obj);
+}
+
+template <>
+static void marshall_from_php<SmokeEnumWrapper>(Marshall *m)
+{
+	zval* v = m->var();
+
+	if (Z_TYPE_P(v) == IS_OBJECT) {
+		// A Qt::Enum is a subclass of Qt::Integer, so 'get_qinteger()' can be called ok
+	} else {
+		m->item().s_enum = (long) Z_LVAL_P(v);
+	}
+
+}
+
+template <>
+static void marshall_to_php<SmokeEnumWrapper>(Marshall *m)
+{
+	long val = m->item().s_enum;
+}
+
+template <>
+static void marshall_from_php<SmokeClassWrapper>(Marshall *m)
+{
+	zval* v = m->var();
+
+	if(v == NULL) {
+		m->item().s_class = 0;
+		return;
+	}
+
+	if(!phpqt_SmokePHPObjectExists(v)) {
+		php_error(E_ERROR, "Invalid type, expecting %s, %s given\n", m->type().name(), zend_zval_type_name(v));
+		return;
+	}
+
+	smokephp_object *o = phpqt_getSmokePHPObjectFromZval(v);
+	if(!o || !o->ptr) {
+		if(m->type().isRef()) {
+			php_error(E_WARNING, "References can't be nil\n");
+			m->unsupported();
+		}
+					
+		m->item().s_class = 0;
+		return;
+	}
+
+	void *ptr = o->ptr;
+
+//	if((!m->cleanup() && m->type().isStack())) {
+	if(m->type().isRef()){
+		ptr = construct_copy(o);
+#ifdef DEBUG
+			php_error(E_WARNING, "copying %s %p to %p\n", resolve_classname(o->smoke, o->classId, o->ptr), o->ptr, ptr);
+#endif
+	}
+
+	const Smoke::Class &cl = m->smoke()->classes[m->type().classId()];
+
+	ptr = o->smoke->cast(
+		ptr,				// pointer
+		o->classId,			// from
+		o->smoke->idClass(cl.className)	// to
+		);
+
+	m->item().s_class = ptr;
+	return;
+}
+
+template <>
+static void marshall_to_php<SmokeClassWrapper>(Marshall *m)
+{
+
+	if(m->item().s_voidp == 0) {
+		m->setRetval(Qnil);
+		return;
+	}
+	void *p = m->item().s_voidp;
+
+	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
+	zval* obj = m->var();
+
+	if(phpqt_SmokePHPObjectExists(p)) {
+	    smokephp_object* o = phpqt_getSmokePHPObjectFromQt(p);
+	    ZVAL_ZVAL(obj, o->zval_ptr,0,0);
+	    zend_rsrc_list_entry le;
+	    le.ptr = o;
+	    phpqt_register(obj, le);
+	// create a new object
+	} else {
+	    o->ptr = m->item().s_class;
+	    o->smoke = m->smoke();
+
+	    if (Z_TYPE_P(m->var()) == IS_OBJECT) {
+		// do nothing
+	    } else if(!strcmp((char*) m->smoke()->classes[m->type().classId()].className, "QObject")){
+		// cast from, to
+		o->ptr = o->smoke->cast(o->ptr, m->smoke()->idClass("QObject"), m->type().classId());
+		object_init_ex(obj, 
+			    zend_fetch_class((char*)((QObject*) o->ptr)->metaObject()->className(),
+			    strlen(((QObject*) o->ptr)->metaObject()->className()), 
+			    ZEND_FETCH_CLASS_AUTO TSRMLS_DC));
+	    // fallback, already with correct type
+	    } else {
+		object_init_ex(obj, 
+		zend_fetch_class((char*) m->smoke()->classes[m->type().classId()].className,
+				strlen(m->smoke()->classes[m->type().classId()].className), 
+				ZEND_FETCH_CLASS_AUTO TSRMLS_DC));
+	    }
+
+	    Z_TYPE_P(m->var()) = IS_OBJECT;
+	    o->zval_ptr = obj;
+	    o->ce_ptr = Z_OBJCE_P(obj);
+	    o->parent_ce_ptr = o->ce_ptr;
+	    o->classId = m->type().classId();
+
+	    if(!phpqt_SmokePHPObjectExists(o->ptr))
+		phpqt_setSmokePHPObject(o);
+
+	    zend_rsrc_list_entry le;
+	    le.ptr = o;
+	    phpqt_register(obj, le);
+	    phpqt_setZvalPtr(o, obj);
+
+	    const char * classname = o->ce_ptr->name;
+//	    if(m->type().isConst() && m->type().isRef()) {
+	    if(m->type().isRef()) {
+		p = construct_copy( o );
+#ifdef DEBUG
+			php_error(E_WARNING, "copying %s %p to %p\n", classname, o->ptr, p);
+#endif
+
+		if(p) {
+			o->ptr = p;
+			o->allocated = true;
+		}
+	}
+
+#ifdef DEBUG
+		php_error(E_WARNING, "allocating %s %p -> %p\n", classname, o->ptr, (void*)obj);
+#endif
+
+	if(m->type().isStack()) {
+		o->allocated = true;
+	}
+
+	}
+}
+
+template <>
+static void marshall_to_php<char *>(Marshall *m)
+{
+	char *sv = (char*)m->item().s_voidp;
+	zval* obj;
+	if(sv) {
+	    ZVAL_STRING(obj,sv,/*duplicate*/ 1);
+	} else {
+	    obj = Qnil;
+	}
+	if(m->cleanup())
+		delete[] sv;
+
+	m->setRetval(obj);
+}
+
+template <>
+static void marshall_to_php<unsigned char *>(Marshall *m)
+{
+	m->unsupported();
+}

Added: trunk/php_qt/marshall_primitives.h
===================================================================
--- trunk/php_qt/marshall_primitives.h	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/php_qt/marshall_primitives.h	2007-03-21 13:08:26 UTC (rev 305)
@@ -0,0 +1,266 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+template <>
+static bool php_to_primitive<bool>(zval* v)
+{
+	if (v->type == IS_OBJECT) {
+		// A Qt::Boolean has been passed as a value
+		php_error(E_WARNING,"A Qt::Boolean has been passed as a value");
+	} else {
+		return ZEND_NORMALIZE_BOOL(v);
+	}
+}
+
+template <>
+static zval* primitive_to_php<bool>(bool sv, zval* return_value)
+{
+	RETVAL_BOOL(sv);
+	return return_value;
+}
+
+template <>
+static signed char php_to_primitive<signed char>(zval* v)
+{
+	return v->value.str.val[0];
+}
+
+template <>
+static zval* primitive_to_php<signed char>(signed char sv, zval* return_value)
+{
+    php_error(E_ERROR,"signed char not implemented");
+}
+
+template <>
+static unsigned char php_to_primitive<unsigned char>(zval* v)
+{
+	return v->value.str.val[0];
+}
+
+template <>
+static zval* primitive_to_php<unsigned char>(unsigned char sv, zval* return_value)
+{
+    php_error(E_ERROR,"unsigned char not implemented");
+}
+
+template <>
+static short php_to_primitive<short>(zval* v)
+{
+	return Z_LVAL_P(v);
+}
+
+template <>
+static zval* primitive_to_php<short>(short sv, zval* return_value)
+{
+        RETVAL_LONG(sv);
+	return return_value;
+}
+
+template <>
+static unsigned short php_to_primitive<unsigned short>(zval* v)
+{
+	return Z_LVAL_P(v);
+}
+
+template <>
+static zval* primitive_to_php<unsigned short>(unsigned short sv, zval* return_value)
+{
+        RETVAL_LONG(sv);
+	return return_value;
+}
+
+template <>
+static int php_to_primitive<int>(zval* v)
+{
+	if (v->type == IS_OBJECT) {
+	    php_error(E_WARNING,"An integer has been passed as an object");
+	} else {
+	    return Z_LVAL_P(v);
+	}
+}
+
+template <>
+static zval* primitive_to_php<int>(int sv, zval* return_value)
+{
+        RETVAL_LONG(sv);
+	return return_value;
+}
+
+template <>
+static unsigned int php_to_primitive<unsigned int>(zval* v)
+{
+	if (v->type == IS_OBJECT) {
+	    php_error(E_WARNING,"An unsigned integer has been passed as an object");
+	} else {
+	    return Z_LVAL_P(v);
+	}
+}
+
+template <>
+static zval* primitive_to_php<unsigned int>(unsigned int sv, zval* return_value)
+{
+        RETVAL_LONG(sv);
+	return return_value;
+}
+
+template <>
+static long php_to_primitive<long>(zval* v)
+{
+	if (v->type == IS_OBJECT) {
+	    php_error(E_WARNING,"A long has been passed as an object");
+	} else {
+	    return Z_LVAL_P(v);
+	}
+}
+
+template <>
+static zval* primitive_to_php<long>(long sv, zval* return_value)
+{
+        RETVAL_LONG(sv);
+	return return_value;
+}
+
+template <>
+static unsigned long php_to_primitive<unsigned long>(zval* v)
+{
+	if (v->type == IS_OBJECT) {
+	    php_error(E_WARNING,"An unsigned long has been passed as an object");
+	} else {
+	    return Z_LVAL_P(v);
+	}
+}
+
+template <>
+static zval* primitive_to_php<unsigned long>(unsigned long sv, zval* return_value)
+{
+        RETVAL_LONG(sv);
+	return return_value;
+}
+
+template <>
+static long long php_to_primitive<long long>(zval* v)
+{
+	return Z_LVAL_P(v);
+}
+
+template <>
+static zval* primitive_to_php<long long>(long long sv, zval* return_value)
+{
+        RETVAL_LONG(sv);
+	return return_value;
+}
+
+template <>
+static unsigned long long php_to_primitive<unsigned long long>(zval* v)
+{
+        return Z_LVAL_P(v);
+}
+
+template <>
+static zval* primitive_to_php<unsigned long long>(unsigned long long sv, zval* return_value)
+{
+        RETVAL_LONG(sv);
+	return return_value;
+}
+
+template <>
+static float php_to_primitive<float>(zval* v)
+{
+        return Z_DVAL_P(v);
+}
+
+template <>
+static zval* primitive_to_php<float>(float sv, zval* return_value)
+{
+        RETVAL_DOUBLE(sv);
+	return return_value;
+}
+
+template <>
+static double php_to_primitive<double>(zval* v)
+{
+        return Z_DVAL_P(v);
+}
+
+template <>
+static zval* primitive_to_php<double>(double sv, zval* return_value)
+{
+        RETVAL_DOUBLE(sv);
+	return return_value;
+}
+
+template <>
+static char* php_to_primitive<char *>(zval* rv)
+{
+	if(rv == Qnil)
+		return 0;
+	
+	int len = rv->value.str.len;
+	char* mem = (char*) malloc(len+1);
+	memcpy(mem, rv->value.str.val, len);
+	mem[len] ='\0';
+	return (char*) mem;
+}
+
+template <>
+static unsigned char* php_to_primitive<unsigned char *>(zval* rv)
+{
+	if(rv == Qnil)
+		return 0;
+
+	int len = rv->value.str.len;
+	char* mem = (char*) malloc(len+1);
+	memcpy(mem, rv->value.str.val, len);
+	mem[len] ='\0';
+	return (unsigned char*) mem;
+}
+
+template <>
+static zval* primitive_to_php<int*>(int* sv, zval* return_value)
+{
+	if(!sv) {
+		return Qnil;
+	}
+
+	return primitive_to_php<int>(*sv, return_value);
+}
+
+#if defined(Q_OS_WIN32)
+template <>
+static WId php_to_primitive<WId>(zval* v)
+{
+	if(v == Qnil)
+		return 0;
+	
+	return (WId) Z_LVAL_P(v);
+}
+
+template <>
+static zval* primitive_to_php<WId>(WId sv, zval* return_value)
+{
+        RETVAL_LONG((unsigned long) sv);
+	return return_value;
+}
+
+template <>
+static Q_PID php_to_primitive<Q_PID>(zval* v)
+{
+	if(v == Qnil)
+		return 0;
+	
+	return (Q_PID) Z_LVAL_P(v);
+}
+
+template <>
+static zval* primitive_to_php<Q_PID>(Q_PID sv, zval* return_value)
+{
+        RETVAL_LONG((unsigned long) sv);
+	return return_value;
+}
+#endif

Added: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/php_qt/marshall_types.cpp	2007-03-21 13:08:26 UTC (rev 305)
@@ -0,0 +1,679 @@
+/***************************************************************************
+    marshall_types.cpp - Derived from the QtRuby and PerlQt sources, see AUTHORS
+                         for details
+                             -------------------
+    begin                : March 21 2007
+    copyright            : (C) 2007 by Thomas Moenicke
+    email                : tm at php-qt.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "marshall_types.h"
+
+void
+smokeStackToQtStack(Smoke::Stack stack, void ** o, int items, MocArgument* args)
+{
+	for (int i = 0; i < items; i++) {
+		Smoke::StackItem *si = stack + i;
+		switch(args[i].argType) {
+		case xmoc_bool:
+			o[i] = &si->s_bool;
+			break;
+		case xmoc_int:
+			o[i] = &si->s_int;
+			break;
+		case xmoc_double:
+			o[i] = &si->s_double;
+			break;
+		case xmoc_charstar:
+			o[i] = &si->s_voidp;
+			break;
+		case xmoc_QString:
+			o[i] = si->s_voidp;
+			break;
+		default:
+		{
+			const SmokeType &t = args[i].st;
+			void *p;
+			switch(t.elem()) {
+			case Smoke::t_bool:
+				p = &si->s_bool;
+				break;
+			case Smoke::t_char:
+				p = &si->s_char;
+				break;
+			case Smoke::t_uchar:
+				p = &si->s_uchar;
+				break;
+			case Smoke::t_short:
+				p = &si->s_short;
+				break;
+			case Smoke::t_ushort:
+				p = &si->s_ushort;
+				break;
+			case Smoke::t_int:
+				p = &si->s_int;
+				break;
+			case Smoke::t_uint:
+				p = &si->s_uint;
+				break;
+			case Smoke::t_long:
+				p = &si->s_long;
+				break;
+			case Smoke::t_ulong:
+				p = &si->s_ulong;
+				break;
+			case Smoke::t_float:
+				p = &si->s_float;
+				break;
+			case Smoke::t_double:
+				p = &si->s_double;
+				break;
+			case Smoke::t_enum:
+			{
+				// allocate a new enum value
+				Smoke::EnumFn fn = SmokeClass(t).enumFn();
+				if (!fn) {
+					php_error(E_WARNING, "Unknown enumeration %s\n", t.name());
+					p = new int((int)si->s_enum);
+					break;
+				}
+				Smoke::Index id = t.typeId();
+				(*fn)(Smoke::EnumNew, id, p, si->s_enum);
+				(*fn)(Smoke::EnumFromLong, id, p, si->s_enum);
+				// FIXME: MEMORY LEAK
+				break;
+			}
+			case Smoke::t_class:
+			case Smoke::t_voidp:
+				if (strchr(t.name(), '*') != 0) {
+					p = &si->s_voidp;
+				} else {
+					p = si->s_voidp;
+				}
+				break;
+			default:
+				p = 0;
+				break;
+			}
+			o[i] = p;
+		}
+		}
+	}
+}
+
+void
+smokeStackFromQtStack(Smoke::Stack stack, void ** _o, int items, MocArgument* args)
+{
+	for (int i = 0; i < items; i++) {
+		void *o = _o[i];
+		switch(args[i].argType) {
+		case xmoc_bool:
+		stack[i].s_bool = *(bool*)o;
+		break;
+		case xmoc_int:
+		stack[i].s_int = *(int*)o;
+		break;
+		case xmoc_double:
+		stack[i].s_double = *(double*)o;
+		break;
+		case xmoc_charstar:
+		stack[i].s_voidp = o;
+		break;
+		case xmoc_QString:
+		stack[i].s_voidp = o;
+		break;
+		default:	// case xmoc_ptr:
+		{
+			const SmokeType &t = args[i].st;
+			void *p = o;
+			switch(t.elem()) {
+			case Smoke::t_bool:
+			stack[i].s_bool = **(bool**)o;
+			break;
+			case Smoke::t_char:
+			stack[i].s_char = **(char**)o;
+			break;
+			case Smoke::t_uchar:
+			stack[i].s_uchar = **(unsigned char**)o;
+			break;
+			case Smoke::t_short:
+			stack[i].s_short = **(short**)p;
+			break;
+			case Smoke::t_ushort:
+			stack[i].s_ushort = **(unsigned short**)p;
+			break;
+			case Smoke::t_int:
+			stack[i].s_int = **(int**)p;
+			break;
+			case Smoke::t_uint:
+			stack[i].s_uint = **(unsigned int**)p;
+			break;
+			case Smoke::t_long:
+			stack[i].s_long = **(long**)p;
+			break;
+			case Smoke::t_ulong:
+			stack[i].s_ulong = **(unsigned long**)p;
+			break;
+			case Smoke::t_float:
+			stack[i].s_float = **(float**)p;
+			break;
+			case Smoke::t_double:
+			stack[i].s_double = **(double**)p;
+			break;
+			case Smoke::t_enum:
+			{
+				Smoke::EnumFn fn = SmokeClass(t).enumFn();
+				if (!fn) {
+					php_error(E_WARNING, "Unknown enumeration %s\n", t.name());
+					stack[i].s_enum = **(int**)p;
+					break;
+				}
+				Smoke::Index id = t.typeId();
+				(*fn)(Smoke::EnumToLong, id, p, stack[i].s_enum);
+			}
+			break;
+			case Smoke::t_class:
+			case Smoke::t_voidp:
+				if (strchr(t.name(), '*') != 0) {
+					stack[i].s_voidp = *(void **)p;
+				} else {
+					stack[i].s_voidp = p;
+				}
+			break;
+			}
+		}
+		}
+	}
+}
+
+MethodReturnValueBase::MethodReturnValueBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack) :
+	_smoke(smoke), _method(meth), _stack(stack)
+{ 
+	_st.set(_smoke, method().ret);
+}
+
+const Smoke::Method&
+MethodReturnValueBase::method() 
+{ 
+	return _smoke->methods[_method]; 
+}
+
+Smoke::StackItem&
+MethodReturnValueBase::item() 
+{ 
+	return _stack[0]; 
+}
+
+Smoke *
+MethodReturnValueBase::smoke() 
+{ 
+	return _smoke; 
+}
+
+SmokeType 
+MethodReturnValueBase::type() 
+{ 
+	return _st; 
+}
+
+void 
+MethodReturnValueBase::next() {}
+
+bool 
+MethodReturnValueBase::cleanup() 
+{ 
+	return false; 
+}
+
+void 
+MethodReturnValueBase::unsupported() 
+{
+	php_error(E_ERROR, "Cannot handle '%s' as return-type of %s::%s",
+	type().name(),
+	classname(),
+	_smoke->methodNames[method().name]);	
+}
+
+zval* 
+MethodReturnValueBase::var() 
+{ 
+	return _retval; 
+}
+
+const char *
+MethodReturnValueBase::classname() 
+{ 
+	return _smoke->className(method().classId); 
+}
+
+
+VirtualMethodReturnValue::VirtualMethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval retval) :
+	MethodReturnValueBase(smoke,meth,stack), _retval2(retval) 
+{
+	_retval = &_retval2;
+	Marshall::HandlerFn fn = getMarshallFn(type());
+	(*fn)(this);
+}
+
+Marshall::Action 
+VirtualMethodReturnValue::action() 
+{ 
+	return Marshall::FromZVAL; 
+}
+
+MethodReturnValue::MethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* retval) :
+	MethodReturnValueBase(smoke,meth,stack) 
+{
+	_retval = retval;
+
+	Marshall::HandlerFn fn = getMarshallFn(type());
+	(*fn)(this);
+}
+
+Marshall::Action 
+MethodReturnValue::action() 
+{ 
+	return Marshall::ToZVAL; 
+}
+
+const char *
+MethodReturnValue::classname() 
+{ 
+	return qstrcmp(MethodReturnValueBase::classname(), "QGlobalSpace") == 0 ? "" : MethodReturnValueBase::classname(); 
+}
+
+
+MethodCallBase::MethodCallBase(Smoke *smoke, Smoke::Index meth) :
+	_smoke(smoke), _method(meth), _cur(-1), _called(false), _sp(0)  
+{  
+}
+
+MethodCallBase::MethodCallBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack) :
+	_smoke(smoke), _method(meth), _stack(stack), _cur(-1), _called(false), _sp(0) 
+{  
+}
+
+Smoke *
+MethodCallBase::smoke() 
+{ 
+	return _smoke; 
+}
+
+SmokeType 
+MethodCallBase::type() 
+{ 
+	return SmokeType(_smoke, _args[_cur]); 
+}
+
+Smoke::StackItem &
+MethodCallBase::item() 
+{ 
+	return _stack[_cur + 1]; 
+}
+
+const Smoke::Method &
+MethodCallBase::method() 
+{ 
+	return _smoke->methods[_method]; 
+}
+	
+void 
+MethodCallBase::next() 
+{
+	int oldcur = _cur;
+	_cur++;
+	while(!_called && _cur < items() ) {
+		Marshall::HandlerFn fn = getMarshallFn(type());
+		(*fn)(this);
+		_cur++;
+	}
+
+	callMethod();
+	_cur = oldcur;
+}
+
+void 
+MethodCallBase::unsupported() 
+{
+	php_error(E_ERROR, "Cannot handle '%s' as argument of %s::%s",
+		type().name(),
+		classname(),
+		_smoke->methodNames[method().name]);
+}
+
+const char* 
+MethodCallBase::classname() 
+{ 
+	return _smoke->className(method().classId); 
+}
+
+
+VirtualMethodCall::VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval obj, zval ***sp) :
+	MethodCallBase(smoke,meth,stack), _obj(obj)
+{		
+	_sp = sp;
+	_args = _smoke->argumentList + method().args;
+}
+
+VirtualMethodCall::~VirtualMethodCall() 
+{
+}
+
+Marshall::Action 
+VirtualMethodCall::action() 
+{ 
+	return Marshall::ToZVAL; 
+}
+
+zval*
+VirtualMethodCall::var() 
+{ 
+	return (zval*) _sp[_cur]; 
+}
+	
+int 
+VirtualMethodCall::items() 
+{ 
+	return method().numArgs; 
+}
+
+void 
+VirtualMethodCall::callMethod() 
+{
+	if (_called) return;
+	_called = true;
+
+//	zval* _retval = callMethod(_obj, _smoke->methodNames[method().name],
+//		method().numArgs,	_sp );
+	zval _retval;
+	VirtualMethodReturnValue r(_smoke, _method, _stack, _retval);
+}
+
+bool 
+VirtualMethodCall::cleanup() 
+{ 
+	return false; 
+}
+
+MethodCall::MethodCall(Smoke *smoke, Smoke::Index method, zval* target, zval ***sp, int items, zval *retval) :
+	MethodCallBase(smoke,method), _target(target), _current_object(0), _sp(sp), _items(items)
+{
+
+    if(target != NULL) {
+	if (phpqt_SmokePHPObjectExists(_target)) {
+		smokephp_object *o = phpqt_getSmokePHPObjectFromZval(_target);
+		if (o && o->ptr) {
+			_current_object = o->ptr;
+			_current_object_class = o->classId;
+		}
+	}
+    } else {_target = new zval;}
+
+    _args = _smoke->argumentList + _smoke->methods[_method].args;
+    _items = _smoke->methods[_method].numArgs;
+    _stack = new Smoke::StackItem[items + 1];
+    _retval = retval;
+}
+
+MethodCall::~MethodCall() 
+{
+	delete[] _stack;
+}
+
+Marshall::Action 
+MethodCall::action() 
+{ 
+	return Marshall::FromZVAL; 
+}
+
+zval* 
+MethodCall::var() 
+{
+	if (_cur < 0) return _retval;
+	return (zval*) *_sp[_cur];
+}
+
+int 
+MethodCall::items() 
+{ 
+	return _items; 
+}
+
+bool 
+MethodCall::cleanup() 
+{ 
+	return true; 
+}
+
+const char *
+MethodCall::classname() 
+{ 
+	return qstrcmp(MethodCallBase::classname(), "QGlobalSpace") == 0 ? "" : MethodCallBase::classname(); 
+}
+
+SigSlotBase::SigSlotBase(zval ***args) : _cur(-1), _called(false) 
+{ 
+}
+
+SigSlotBase::~SigSlotBase() 
+{ 
+	delete[] _stack; 
+}
+
+const MocArgument &
+SigSlotBase::arg() 
+{ 
+	return _args[_cur + 1]; 
+}
+
+SmokeType 
+SigSlotBase::type() 
+{ 
+	return arg().st; 
+}
+
+Smoke::StackItem &
+SigSlotBase::item() 
+{ 
+	return _stack[_cur]; 
+}
+
+zval* 
+SigSlotBase::var() 
+{ 
+	return *_sp[_cur]; 
+}
+
+Smoke *
+SigSlotBase::smoke() 
+{ 
+	return type().smoke(); 
+}
+
+void 
+SigSlotBase::unsupported() 
+{
+	php_error(E_ERROR, "Cannot handle '%s' as %s argument\n", type().name(), mytype() );
+}
+
+void
+SigSlotBase::next() 
+{
+	int oldcur = _cur;
+	_cur++;
+
+	while(!_called && _cur < _items - 1) {
+		Marshall::HandlerFn fn = getMarshallFn(type());
+		(*fn)(this);
+		_cur++;
+	}
+
+	mainfunction();
+	_cur = oldcur;
+}
+
+/*
+	Converts a zval* returned by a slot invocation to a Qt slot 
+	reply type
+*/
+class SlotReturnValue : public Marshall {
+    MocArgument *	_replyType;
+    Smoke::Stack _stack;
+	zval* _result;
+public:
+	SlotReturnValue(void ** o, zval* result, MocArgument * replyType) 
+	{
+		_result = result;
+		_replyType = replyType;
+		_stack = new Smoke::StackItem[1];
+		Marshall::HandlerFn fn = getMarshallFn(type());
+		(*fn)(this);
+		// Save any address in zeroth element of the arrary of 'void*'s passed to 
+		// qt_metacall()
+		void * ptr = o[0];
+		smokeStackToQtStack(_stack, o, 1, _replyType);
+		// Only if the zeroth element of the array of 'void*'s passed to qt_metacall()
+		// contains an address, is the return value of the slot needed.
+		if (ptr != 0) {
+			*(void**)ptr = *(void**)(o[0]);
+		}
+    }
+
+    SmokeType type() { 
+		return _replyType[0].st; 
+	}
+    Marshall::Action action() { return Marshall::FromZVAL; }
+    Smoke::StackItem &item() { return _stack[0]; }
+    zval* var() {
+    	return _result;
+    }
+	
+	void unsupported() 
+	{
+		php_error(E_ERROR, "Cannot handle '%s' as slot reply-type", type().name());
+    }
+	Smoke *smoke() { return type().smoke(); }
+    
+	void next() {}
+    
+	bool cleanup() { return false; }
+	
+	~SlotReturnValue() {
+		delete[] _stack;
+	}
+};
+/*
+InvokeSlot::InvokeSlot(zval* obj, ID slotname, zval*** args, void ** o) : SigSlotBase(args),
+    _obj(obj), _slotname(slotname), _o(o)
+{
+//	_sp = (zval *) ALLOC_N(VALUE, _items - 1);
+	copyArguments();
+}
+
+InvokeSlot::~InvokeSlot() 
+{ 
+	xfree(_sp);	
+}
+
+Marshall::Action 
+InvokeSlot::action() 
+{ 
+	return Marshall::ToZVAL; 
+}
+
+const char *
+InvokeSlot::mytype() 
+{ 
+	return "slot"; 
+}
+
+bool 
+InvokeSlot::cleanup() 
+{ 
+	return false; 
+}
+
+void 
+InvokeSlot::copyArguments() 
+{
+	smokeStackFromQtStack(_stack, _o + 1, _items - 1, _args + 1);
+}
+
+void 
+InvokeSlot::invokeSlot() 
+{
+	if (_called) return;
+	_called = true;
+	if (_args[0].argType != xmoc_void) {
+		SlotReturnValue r(_o, &result, _args);
+	}
+}
+
+void 
+InvokeSlot::mainfunction() 
+{ 
+	invokeSlot(); 
+}
+*/
+
+EmitSignal::EmitSignal(QObject *obj, int id, int items, zval*** args, zval ***sp, zval * result) : SigSlotBase(args),
+    _obj(obj), _id(id)
+{ 
+	_sp = sp;
+	_result = result;
+}
+
+Marshall::Action 
+EmitSignal::action() 
+{ 
+	return Marshall::FromZVAL; 
+}
+
+Smoke::StackItem &
+EmitSignal::item() 
+{ 
+	return _stack[_cur]; 
+}
+
+const char *
+EmitSignal::mytype() 
+{ 
+	return "signal"; 
+}
+
+void 
+EmitSignal::emitSignal() 
+{
+	if (_called) return;
+	_called = true;
+	void ** o = new void*[_items];
+//	smokeStackToQtStack(_stack, o + 1, _items - 1, _args + 1);
+	_obj->metaObject()->activate(_obj, _id, o);
+	
+	if (_args[0].argType != xmoc_void) {
+		SignalReturnValue r(o, _result, _args);
+	}
+	delete[] o;
+}
+
+void 
+EmitSignal::mainfunction() 
+{ 
+	emitSignal(); 
+}
+
+bool 
+EmitSignal::cleanup() 
+{ 
+	return true; 
+}
+

Added: trunk/php_qt/marshall_types.h
===================================================================
--- trunk/php_qt/marshall_types.h	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/php_qt/marshall_types.h	2007-03-21 13:08:26 UTC (rev 305)
@@ -0,0 +1,276 @@
+/***************************************************************************
+    marshall_types.cpp - Derived from the QtRuby and PerlQt sources, see AUTHORS
+                         for details
+                             -------------------
+    begin                : March 21 2007
+    copyright            : (C) 2007 by Thomas Moenicke
+    email                : tm at php-qt.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef MARSHALL_TYPES_H
+#define MARSHALL_TYPES_H
+
+#include <QtCore/qstring.h>
+#include <QtCore/qobject.h>
+#include <QtCore/qmetaobject.h>
+
+#include "marshall.h"
+#include "php_qt.h"
+#include "smokephp.h"
+#include "smoke.h"
+
+
+Marshall::HandlerFn getMarshallFn(const SmokeType &type);
+
+extern void smokeStackToQtStack(Smoke::Stack stack, void ** o, int items, MocArgument* args);
+extern void smokeStackFromQtStack(Smoke::Stack stack, void ** _o, int items, MocArgument* args);
+
+class MethodReturnValueBase : public Marshall 
+{
+public:
+	MethodReturnValueBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack);
+	const Smoke::Method &method();
+	Smoke::StackItem &item();
+	Smoke *smoke();
+	SmokeType type();
+	void next();
+	bool cleanup();
+	void unsupported();
+	zval* var();
+
+protected:
+	Smoke *_smoke;
+	Smoke::Index _method;
+	Smoke::Stack _stack;
+	SmokeType _st;
+
+	virtual const char *classname();
+};
+
+
+class VirtualMethodReturnValue : public MethodReturnValueBase {
+public:
+	VirtualMethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval retval);
+	Marshall::Action action();
+
+private:
+	zval _retval2;
+};
+
+
+class MethodReturnValue : public MethodReturnValueBase {
+public:
+	MethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval *retval);
+    Marshall::Action action();
+
+private:
+	const char *classname();
+};
+
+class MethodCallBase : public Marshall
+{
+public:
+	MethodCallBase(Smoke *smoke, Smoke::Index meth);
+	MethodCallBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack);
+	Smoke *smoke();
+	SmokeType type();
+	Smoke::StackItem &item();
+	const Smoke::Method &method();
+	virtual int items() = 0;
+	virtual void callMethod() = 0;	
+	void next();
+	void unsupported();
+
+protected:
+	Smoke *_smoke;
+	Smoke::Index _method;
+	Smoke::Stack _stack;
+	int _cur;
+	Smoke::Index *_args;
+	bool _called;
+	zval ***_sp;
+	virtual const char* classname();
+};
+
+
+class VirtualMethodCall : public MethodCallBase {
+public:
+	VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval obj, zval ***sp);
+	~VirtualMethodCall();
+	Marshall::Action action();
+	zval* var();
+	int items();
+	void callMethod();
+	bool cleanup();
+ 
+private:
+	zval _obj;
+};
+
+
+class MethodCall : public MethodCallBase {
+public:
+	MethodCall(Smoke *smoke, Smoke::Index method, zval* target, zval ***sp, int items, zval *retval);
+	~MethodCall();
+	Marshall::Action action();
+	zval* var();
+	inline void callMethod() {
+		if(_called) return;
+		_called = true;
+
+		QString className(_smoke->className(method().classId));
+
+		if (	! className.endsWith(_smoke->methodNames[method().name])
+			&& Z_TYPE_P(_target) == IS_NULL
+			&& !(method().flags & Smoke::mf_static) ) 
+		{
+			php_error(E_ERROR, "Instance is not initialized, cannot call %s", 
+						_smoke->methodNames[method().name]);
+		}
+
+		if (Z_TYPE_P(_target) == IS_NULL && !(method().flags & Smoke::mf_static)) {
+			php_error(E_ERROR, "%s is not a class method\n", _smoke->methodNames[method().name]);
+		}
+
+		Smoke::ClassFn fn = _smoke->classes[method().classId].classFn;
+		void *ptr = _smoke->cast(_current_object, _current_object_class, method().classId);
+		_items = -1;
+		(*fn)(method().method, ptr, _stack);
+		MethodReturnValue r(_smoke, _method, _stack, _retval);
+	}
+
+	int items();
+	bool cleanup();
+private:
+	zval* _target;
+	void *_current_object;
+	Smoke::Index _current_object_class;
+	zval ***_sp;
+	int _items;
+
+	const char *classname();
+};
+
+
+class SigSlotBase : public Marshall {
+public:
+	SigSlotBase(zval ***args);
+	~SigSlotBase();
+	const MocArgument &arg();
+	SmokeType type();
+	Smoke::StackItem &item();
+	zval* var();
+	Smoke *smoke();
+	virtual const char *mytype() = 0;
+	virtual void mainfunction() = 0;
+	void unsupported();
+	void next(); 
+
+protected:
+	MocArgument *_args;
+	int _cur;
+	bool _called;
+	Smoke::Stack _stack;
+	int _items;
+	zval ***_sp;
+};
+
+
+class EmitSignal : public SigSlotBase {
+    QObject *_obj;
+    int _id;
+	zval * _result;
+ public:
+    EmitSignal(QObject *obj, int id, int items, zval*** args, zval ***sp, zval * result);
+    Marshall::Action action();
+    Smoke::StackItem &item();
+	const char *mytype();
+	void emitSignal();
+	void mainfunction();
+	bool cleanup();
+};
+
+class InvokeNativeSlot : public SigSlotBase {
+    QObject *_obj;
+    int _id;
+	zval * _result;
+ public:
+    InvokeNativeSlot(QObject *obj, int id, int items, zval* args, zval ***sp, zval * result);
+    Marshall::Action action();
+    Smoke::StackItem &item();
+	const char *mytype();
+	void invokeSlot();
+	void mainfunction();
+	bool cleanup();
+};
+/*
+class InvokeSlot : public SigSlotBase {
+    zval _obj;
+    ID _slotname;
+    void **_o;
+public:
+    InvokeSlot(zval obj, ID slotname, zval args, void ** o);
+	~InvokeSlot();
+    Marshall::Action action();
+	const char *mytype();
+    bool cleanup();
+	void copyArguments();
+	void invokeSlot(); 
+	void mainfunction();
+};
+*/
+
+/*
+	Converts a C++ value returned by a signal invocation to a PHP 
+	reply type
+*/
+class SignalReturnValue : public Marshall {
+    MocArgument *	_replyType;
+    Smoke::Stack _stack;
+	zval * _result;
+public:
+	SignalReturnValue(void ** o, zval * result, MocArgument * replyType) 
+	{
+		_result = result;
+		_replyType = replyType;
+		_stack = new Smoke::StackItem[1];
+//		smokeStackFromQtStack(_stack, o, 1, _replyType);
+		Marshall::HandlerFn fn = getMarshallFn(type());
+		(*fn)(this);
+    }
+
+    SmokeType type() { 
+		return _replyType[0].st; 
+	}
+    Marshall::Action action() { return Marshall::ToZVAL; }
+    Smoke::StackItem &item() { return _stack[0]; }
+    zval* var() {
+    	return _result;
+    }
+	
+	void unsupported() 
+	{
+		php_error(E_ERROR, "Cannot handle '%s' as signal reply-type", type().name());
+    }
+	Smoke *smoke() { return type().smoke(); }
+    
+	void next() {}
+    
+	bool cleanup() { return false; }
+	
+	~SignalReturnValue() {
+		delete[] _stack;
+	}
+};
+
+
+#endif

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/php_qt/php_qt.cpp	2007-03-21 13:08:26 UTC (rev 305)
@@ -23,23 +23,28 @@
 // TODO		references, arrays
 // TODO		emit()
 
-//#define DEBUG=0
 
+
 #include <QtCore/qglobal.h>
 #include <zend_interfaces.h>
 #include "php_qt.h"
 
 #include "ext/standard/php_string.h"
 
+#include "marshall.h"
+#include "php_qt.h"
+#include "smokephp.h"
+#include "smoke.h"
+#include "marshall_types.h"
+
+#define DEBUG 0
 #define MOC_DEBUG 0
 
 extern Smoke *qt_Smoke;
 extern void init_qt_Smoke();
+extern TypeHandler Qt_handlers[];
+void install_handlers(TypeHandler *);
 
-/* If you declare any globals in php_php_qt.h uncomment this:
-ZEND_DECLARE_MODULE_GLOBALS(php_qt)
-*/
-
 /* True global resources - no need for thread safety here */
 static int le_php_qt;
 
@@ -119,6 +124,7 @@
 	PHP_FE(confirm_php_qt_compiled,	NULL)		/* For testing, remove later. */
 	PHP_FE(SIGNAL,	NULL)
 	PHP_FE(SLOT,	NULL)	
+	PHP_FE(emit,	NULL)	
 	PHP_FE(qobject_cast,	NULL)
 	PHP_FE(tr,	NULL)
 	PHP_FE(check_qobject,	NULL)
@@ -148,7 +154,7 @@
 ZEND_GET_MODULE(php_qt)
 #endif
 
-static QHash<smokephp_object*, zval*> zval_x_qt;
+static QHash<smokephp_object*, zval*> smoke_x_zval;
 QHash<void*, smokephp_object*> SmokeQtObjects;
 QStack<QString*> methodNameStack;
 
@@ -214,23 +220,26 @@
 
 ZEND_METHOD(php_qt_generic_class, __destruct)
 {
+    if(phpqt_SmokePHPObjectExists(getThis())) {
     smokephp_object *o = phpqt_getSmokePHPObjectFromZval(getThis());
     phpqt_removeZvalPtr(o);
     SmokeQtObjects.remove(o->ptr);
+    }
 	RETVAL_NULL();
 }
 
-// TODO cache idClass
-
 ZEND_METHOD(php_qt_generic_class, __construct)
 {
-
     // find parents
     zend_class_entry *ce = Z_OBJCE_P(getThis());
+    zend_class_entry *ce_parent = Z_OBJCE_P(getThis());
+
     while (qt_Smoke->idClass(ce->name) <= 0) {
-	    ce = ce->parent;
-	}
+	    ce_parent = ce->parent;
+	    ce = ce->parent; // orig
+    }
 
+    // get arguments
     int i, argc = ZEND_NUM_ARGS();
     zval ***args = (zval ***) safe_emalloc(argc, sizeof(zval **), 0);    
     if(zend_get_parameters_array_ex(argc, args) == FAILURE){
@@ -239,43 +248,14 @@
     }
 
     methodNameStack.push(new QString(ce->name));
-    Smoke::StackItem* qargs = (Smoke::StackItem*) safe_emalloc(argc+10, sizeof(Smoke::StackItem), 0);
-    smokephp_convertArgsZendToCxx(args, ZEND_NUM_ARGS(), qargs, methodNameStack);
-    Smoke::Index method = smokephp_getMethod(qt_Smoke,ce->name, (methodNameStack.top())->toAscii(), &qargs, ZEND_NUM_ARGS(), args);
+    smokephp_prepareMethodName(args, argc, methodNameStack);
+    Smoke::Index method = smokephp_getMethod(qt_Smoke,ce->name, (methodNameStack.top())->toAscii(), ZEND_NUM_ARGS(), args);
+    MethodCall c(qt_Smoke, method, getThis(), args, argc-1, getThis());
+    c.next();
 
-	smokephp_object *o = (smokephp_object*) emalloc(sizeof(smokephp_object));
+    smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
+    o->parent_ce_ptr = ce_parent; // = ce if no parent
 
-	if (!strcmp(ce->name, "QString")){
-		if(argc > 0){
-        	qargs[0].s_class = new QString(Z_STRVAL_PP(args[0]));
-    	} else {
-    		qargs[0].s_class = new QString("");	// create an empty string
-    	}
-	} else {
-	    // call Qt method via Smoke
-    	smokephp_callMethod(qt_Smoke, 0, method, qargs);
- 	}
-
-	o->ptr = qargs[0].s_class;
-	o->zval_ptr = getThis();
-	o->ce_ptr = ce;
-	o->parent_ce_ptr = ce;
-	o->classId = qt_Smoke->idClass(ce->name);
-	o->smoke = qt_Smoke;
-
-	// store relations
-
-	PHP_QT_REGISTER(o);
-	phpqt_setSmokePHPObject(o);
-	phpqt_setZvalPtr(o, return_value);
-
-    // return value
-    smokephp_convertReturn(&qargs[0], qt_Smoke->types[qt_Smoke->methods[method].ret], qt_Smoke->methods[method].ret, return_value);
-
-	// make sure it is the right object
-	o->zval_ptr = return_value;
-	o->ce_ptr = Z_OBJCE_P(return_value);	// overwrite
-
 	// if QObject
 	if(smokephp_isQObject(qt_Smoke, qt_Smoke->idClass(ce->name))){
 
@@ -312,12 +292,10 @@
 			o->meta = superdata;
 		}
 
-	} 
+	}
 
-
     // cleanup
     efree(args);
-    efree(qargs);
     methodNameStack.pop();
 
     return;
@@ -344,7 +322,7 @@
     while (qt_Smoke->idClass(ce->name) <= 0) {
 	    ce = ce->parent;
 	}
-	// arguments
+    // arguments
     int j, argc = ZEND_NUM_ARGS();
     zval ***args;
     args = (zval ***) safe_emalloc(argc, sizeof(zval **), 0);
@@ -353,58 +331,24 @@
 	    WRONG_PARAM_COUNT;
     }
 
-    Smoke::StackItem* qargs = (Smoke::StackItem*) safe_emalloc(argc+10, sizeof(Smoke::StackItem), 0);
-    smokephp_convertArgsZendToCxx(args, argc, qargs, methodNameStack);
-    Smoke::Index method = smokephp_getMethod(qt_Smoke,ce->name, (methodNameStack.top())->toAscii(), &qargs, argc, args);
+    smokephp_prepareMethodName(args, argc, methodNameStack);
+    Smoke::Index method = smokephp_getMethod(qt_Smoke,ce->name, (methodNameStack.top())->toAscii(), argc, args);
 
     if(method <= 0) {
 	if(methodNameStack.top()->toAscii().constData()) 
-	    php_error(E_ERROR,"Call to undefined method %s %s!", ce->name, methodNameStack.top()->toAscii().constData());
+	    php_error(E_ERROR,"Call to undefined method %s::%s()", ce->name, methodNameStack.top()->toAscii().constData());
 	else 
 	    php_error(E_ERROR,"Call to undefined method!");
     }
 
-    if(smokephp_isConnect(method)){
-	smokephp_prepareConnect(args, argc, qargs, method);
-//	smokephp_callMethod(qt_Smoke, qargs[0].s_class, method, qargs);
+    MethodCall c(qt_Smoke, method, getThis(), args, argc-1, return_value);
+    c.next();
 
-	QString* o1 = (QString*) phpqt_getQtObjectFromZval(*args[1]);
-	QString* o2 = (QString*) phpqt_getQtObjectFromZval(*args[3]);
-	smokephp_object *oo1 = phpqt_getSmokePHPObjectFromZval(((zval*) *args[0]));
-	smokephp_object *oo2 = phpqt_getSmokePHPObjectFromZval(((zval*) *args[2]));
-
-#if MOC_DEBUG
-	cout << "QObject::connect(" << ((QObject*) oo1->ptr)->metaObject()->className();;
-	cout << ", " << o1->toAscii().constData();
-	cout << ", " << ((QObject*) oo2->ptr)->metaObject()->className();;
-	cout << ", " << o2->toAscii().constData();
-	cout << ")" << endl;
-#endif
-
-	QObject::connect((QObject*) oo1->ptr, o1->toAscii().constData(), (QObject*)oo2->ptr, o2->toAscii().constData());
-	return;
-    }
-
-    // self
-    if(getThis()){
-    	smokephp_object *o = phpqt_getSmokePHPObjectFromZval(getThis());
-        qargs[0].s_class = o->ptr;
-    }
-
-
-    // call
-    smokephp_callMethod(qt_Smoke, qargs[0].s_class, method, qargs);
-
-    // return now
-    smokephp_convertReturn(&qargs[0], qt_Smoke->types[qt_Smoke->methods[method].ret], qt_Smoke->methods[method].ret, return_value);
-
     // cleanup
     efree(args);
-    efree(qargs);
     methodNameStack.pop();
 
     return;
-
 }
 
 /*! 
@@ -414,6 +358,8 @@
 PHP_MINIT_FUNCTION(php_qt)
 {
 
+        install_handlers(Qt_handlers);
+
 	// object list
 	le_php_qt_hashtype = zend_register_list_destructors_ex(phpqt_destroyHashtable, NULL, "PHP-Qt object list", module_number);
 	// FIXME: 50 is fix
@@ -891,22 +837,22 @@
 
 void
 phpqt_setZvalPtr(smokephp_object *o, zval* z) {
-	zval_x_qt.insert(o,z);
+	smoke_x_zval.insert(o,z);
 }
 
 void
 phpqt_removeZvalPtr(smokephp_object *o) {
-	zval_x_qt.remove(o);
+	smoke_x_zval.remove(o);
 }
 
 zval* 
 phpqt_fetchZvalPtr(smokephp_object *o){
-	return zval_x_qt.value(o);
+	return smoke_x_zval.value(o);
 }
 
 bool
 phpqt_ZvalPtrExists(smokephp_object *o){
-	return (zval_x_qt.find(o) != zval_x_qt.end());
+	return (smoke_x_zval.find(o) != smoke_x_zval.end());
 }
 
 /**
@@ -919,6 +865,25 @@
 	return (char*) fname;
 }
 
+bool
+phpqt_SmokePHPObjectExists(zval* this_ptr){
+
+	if(this_ptr == NULL){
+	  php_error(E_ERROR,"fatal: object does not exists and could not be fetched, %s",Z_OBJCE_P(this_ptr)->name);
+	}
+
+	smokephp_object *ptr;
+	zval **listhandle;
+	int type;
+	TSRMLS_FETCH();
+
+	if(zend_hash_index_find(Z_OBJPROP_P(this_ptr), 0, (void**) &listhandle) == FAILURE){
+	    return false;
+	}
+
+	return true;
+}
+
 smokephp_object* 
 phpqt_getSmokePHPObjectFromZval(zval* this_ptr){
 
@@ -969,23 +934,27 @@
 }
 
 void
-phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce){
+phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce, Smoke::Index classId){
 
 	if(!ce) {
 	    ce = Z_OBJCE_P(zval_ptr);
+	    // classID here
 	}
 
+	Z_TYPE_P(zval_ptr) = IS_OBJECT;
+
 	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
 	o->ptr = ptr;
 	o->zval_ptr = zval_ptr;
 	o->ce_ptr = ce;
-	o->classId = 0;	// QString is not in smoke
+	o->parent_ce_ptr = ce;
+	o->classId = classId;
 	o->smoke = qt_Smoke;
 	phpqt_setSmokePHPObject(o);
 	// register all 
 	zend_rsrc_list_entry le;
 	le.ptr = o;
-	object_init_ex(zval_ptr, qstring_ce);
+	object_init_ex(zval_ptr, ce);
 	phpqt_register(o->zval_ptr,le);
 	phpqt_setZvalPtr(o, o->zval_ptr);
 

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/php_qt/php_qt.h	2007-03-21 13:08:26 UTC (rev 305)
@@ -20,7 +20,9 @@
  *
  */
 
-#define debug
+#ifndef QTPHP_H
+#define QTPHP_H
+
 #define MONITOR
 
 #define COMPILE_DL_PHP_QT
@@ -51,6 +53,7 @@
 #define ZEND_MN ZEND_FN
 #endif
 
+#define Qnil (zval *) NULL
 #define QOUT()                                              \
     extern QTextStream qout(stdout, QIODevice::WriteOnly);  \
 
@@ -92,12 +95,14 @@
 /* emulate SIGNAL(), SLOT() macros */
 PHP_FUNCTION(SIGNAL);
 PHP_FUNCTION(SLOT);
+PHP_FUNCTION(emit);
 PHP_FUNCTION(qobject_cast);
 PHP_FUNCTION(tr);
 
 PHP_FUNCTION(check_qobject);
 
 struct smokephp_object {
+    bool allocated;
     Smoke *smoke;
     int classId;
     void *ptr;
@@ -108,7 +113,7 @@
 };
 
 //zend_class_entry* php_qt_generic_class;
-
+void check_object(zval* zobject);
 static void 		phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc);
 
 void 				phpqt_register(zval* this_ptr, zend_rsrc_list_entry le);
@@ -127,8 +132,9 @@
 smokephp_object* 		phpqt_getSmokePHPObjectFromZval(zval* this_ptr);
 smokephp_object*		phpqt_getSmokePHPObjectFromQt(void* QtPtr);
 void				phpqt_setSmokePHPObject(smokephp_object* o);
+bool 				phpqt_SmokePHPObjectExists(zval* this_ptr);
 bool				phpqt_SmokePHPObjectExists(void* ptr);
-void				phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL);
+void				phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL, Smoke::Index classId = 0);
 
 extern int le_php_qt_hashtype;
 extern HashTable php_qt_objptr_hash;
@@ -136,71 +142,16 @@
 void 				smokephp_convertArgsCxxToZend(zval*** args, int argc, Smoke::StackItem* qargs);
 bool 				smokephp_isQObject(Smoke *smoke, Smoke::Index classId);
 Smoke::Index 			smokephp_getClassId(const char* classname);
-void				smokephp_convertArgsZendToCxx(zval*** args, int argc, Smoke::StackItem* qargs, QStack<QString*> &methodNameStack);
-Smoke::Index			smokephp_getMethod(Smoke *smoke, const char* c, const char* m, Smoke::StackItem** qargs, int argc, zval*** args);
+void				smokephp_prepareMethodName(zval*** args, int argc, QStack<QString*> &methodNameStack);
+Smoke::Index			smokephp_getMethod(Smoke *smoke, const char* c, const char* m, int argc, zval*** args);
 void				smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method);
 void				smokephp_callMethod(Smoke *smoke, void *obj, Smoke::Index method, Smoke::Stack qargs);
-void				smokephp_convertReturn(Smoke::StackItem *ret_val, const Smoke::Type type, const Smoke::Index ret, zval* return_value);
 void				smokephp_init();
 Smoke::Index			smokephp_findConnect();
 bool				smokephp_isConnect(Smoke::Index method);
 
+void* 				transformArray(zval* args);
 
-
-class SmokeType {
-    Smoke::Type *_t;		// derived from _smoke and _id, but cached
-
-    Smoke *_smoke;
-    Smoke::Index _id;
-public:
-    SmokeType() : _t(0), _smoke(0), _id(0) {}
-    SmokeType(Smoke *s, Smoke::Index i) : _smoke(s), _id(i) {
-	if(_id < 0 || _id > _smoke->numTypes) _id = 0;
-	_t = _smoke->types + _id;
-    }
-    // default copy constructors are fine, this is a constant structure
-
-    // mutators
-    void set(Smoke *s, Smoke::Index i) {
-	_smoke = s;
-	_id = i;
-	_t = _smoke->types + _id;
-    }
-
-    // accessors
-    Smoke *smoke() const { return _smoke; }
-    Smoke::Index typeId() const { return _id; }
-    const Smoke::Type &type() const { return *_t; }
-    unsigned short flags() const { return _t->flags; }
-    unsigned short elem() const { return _t->flags & Smoke::tf_elem; }
-    const char *name() const { return _t->name; }
-    Smoke::Index classId() const { return _t->classId; }
-
-    // tests
-    bool isStack() const { return ((flags() & Smoke::tf_ref) == Smoke::tf_stack); }
-    bool isPtr() const { return ((flags() & Smoke::tf_ref) == Smoke::tf_ptr); }
-    bool isRef() const { return ((flags() & Smoke::tf_ref) == Smoke::tf_ref); }
-    bool isConst() const { return (flags() & Smoke::tf_const); }
-    bool isClass() const {
-	if(elem() == Smoke::t_class)
-	    return classId() ? true : false;
-	return false;
-    }
-
-    bool operator ==(const SmokeType &b) const {
-	const SmokeType &a = *this;
-	if(a.name() == b.name()) return true;
-	if(a.name() && b.name() && qstrcmp(a.name(), b.name()) == 0)
-	    return true;
-	return false;
-    }
-    bool operator !=(const SmokeType &b) const {
-	const SmokeType &a = *this;
-	return !(a == b);
-    }
-
-};
-
 ZEND_METHOD(QString, __toString);
 ZEND_METHOD(QString, compare);
 ZEND_METHOD(QString, utf16);
@@ -281,3 +232,5 @@
 ZEND_METHOD(QString, toLocal8Bit);
 ZEND_METHOD(QString, toInt);
 ZEND_METHOD(QString, isNull);
+
+#endif

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/php_qt/qstring.cpp	2007-03-21 13:08:26 UTC (rev 305)
@@ -2225,9 +2225,9 @@
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			    smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
 			    QString* obj_z_0 = (QString*) phpqt_getQtObjectFromZval(z_0);
-			    QString s = ((QString*) o->ptr)->append((QString) *obj_z_0);
+			    QString* s = new QString(((QString*) o->ptr)->append((QString) *obj_z_0));
 			    object_init_ex(return_value, qstring_ce);     
-			    phpqt_createObject(return_value, &s, qstring_ce);
+			    phpqt_createObject(return_value, s, qstring_ce);
 			    return;
 			}
 		}

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/php_qt/smokephp.cpp	2007-03-21 13:08:26 UTC (rev 305)
@@ -66,6 +66,10 @@
 			phpqt_metacall(o, args, (QMetaObject::Call) args[1].s_enum, args[2].s_int, (void**) args[3].s_voidp);
 			return true;
 		}
+
+//		VirtualMethodCall c(smoke, method, args, obj, ...);
+//		c.next();
+
 		return false;
 
     }
@@ -112,7 +116,7 @@
  *  @return Smoke::Index        unambiguous method ID
  */
 Smoke::Index 
-smokephp_getMethod(Smoke *smoke, const char* c, const char* m, Smoke::StackItem** qargs, int argc, zval*** args) {
+smokephp_getMethod(Smoke *smoke, const char* c, const char* m, int argc, zval*** args) {
 
     Smoke::Index method = smoke->findMethod(c, m);	// qt_Smoke->methods
     Smoke::Index i = smoke->methodMaps[method].method;
@@ -159,8 +163,16 @@
 							php_error(E_WARNING,"type enum not yet implemented\n");
 							break;
 						case Smoke::t_class:
-							if(type == IS_OBJECT)
+							if(type == IS_OBJECT){
+							    QByteArray* name = 
+							    new QByteArray(
+								qt_Smoke->types[
+								    qt_Smoke->argumentList[
+									qt_Smoke->methods[
+									    qt_Smoke->ambiguousMethodList[i]].args+k]].name);
+							    if(name->contains(Z_OBJCE((zval) **args[k])->name))
 								right = true;
+							}
 							break;
 						default:
 							php_error(E_ERROR, "unknown argument type");
@@ -292,7 +304,7 @@
 
 }
 
-static 
+
 void* transformArray(zval* args){
 
 	// array informations
@@ -306,7 +318,7 @@
 	uint type = (int) (**first_elem).type;
 	if(type < 0 || type > 9){
 		// should never happen
-		php_error(E_ERROR, "could not guess type of array");
+		php_error(E_ERROR, "Could not get type of array");
 	}
 	
 	void* e_arrayv;
@@ -333,231 +345,41 @@
 
 	zend_hash_apply_with_arguments(((zval) *args).value.ht, (apply_func_args_t) treatArray, 3, type, e_arrayc, e_arrayv);
 
+	return e_arrayv;
+
 }
 
-void 
-smokephp_convertArgsZendToCxx(zval*** args, int argc, Smoke::StackItem* qargs, QStack<QString*> &methodNameStack) {
+void smokephp_prepareMethodName(zval*** args, int argc, QStack<QString*> &methodNameStack){
 
     for(int i=0;i<argc;i++){
-
 	    uint type = ((int) ((zval) **args[i]).type);
 
-		if (type == IS_RESOURCE){ // TODO
-
+	    if (type == IS_RESOURCE){ // TODO
 	    } else if (type == IS_ARRAY){
-			// TODO reference
-      	    qargs[i+1].s_voidp = transformArray(*args[i]);
-			methodNameStack.top()->append("?");
-
+		methodNameStack.top()->append("?");
 	    } else if (type == IS_BOOL){
-
-			// Reference
-	    	if((((zval) **args[i]).is_ref)){
-				qargs[i+1].s_voidp = &Z_LVAL_PP(args[i]);
-	    	} else {
-    	    	qargs[i+1].s_bool = Z_BVAL_PP(args[i]);
-    	    }
-
-            methodNameStack.top()->append("$");
-
+        	methodNameStack.top()->append("$");
 	    } else if (type == IS_LONG){
-
-	    	// Reference
-	    	if((((zval) **args[i]).is_ref)){
-				qargs[i+1].s_voidp = &Z_LVAL_PP(args[i]);
-	    	} else {
-				qargs[i+1].s_short = Z_LVAL_PP(args[i]);
-				qargs[i+1].s_ushort = Z_LVAL_PP(args[i]);
-				qargs[i+1].s_int = Z_LVAL_PP(args[i]);
-				qargs[i+1].s_uint = Z_LVAL_PP(args[i]);
-				qargs[i+1].s_long = Z_LVAL_PP(args[i]);
-				qargs[i+1].s_ulong = Z_LVAL_PP(args[i]);
-	    	}
-
-    	    methodNameStack.top()->append("$");
-
+    		methodNameStack.top()->append("$");
 	    } else if (type == IS_DOUBLE){
-
-	    	// Reference
-	    	if((((zval) **args[i]).is_ref)){
-				qargs[i+1].s_voidp = &Z_DVAL_PP(args[i]);
-	    	} else {
-    	    	qargs[i+1].s_double = Z_DVAL_PP(args[i]);
-    	    	qargs[i+1].s_float = Z_DVAL_PP(args[i]);
-    	    }
-            methodNameStack.top()->append("$");
-
+        	methodNameStack.top()->append("$");
 	    } else if (type == IS_STRING){
-
-			if((((zval) **args[i]).is_ref)){
-				qargs[i+1].s_class = phpqt_getSmokePHPObjectFromZval(*args[i])->ptr;	
-			} else {
-			    // create a new QString object
-    	    		    qargs[i+1].s_class = emalloc(sizeof(QString) + strlen(Z_STRVAL_PP(args[i]))); // important
-    	    		    qargs[i+1].s_class = new QString(Z_STRVAL_PP(args[i]));
-			    // create new smokephp_object
-			    smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
-			    o->ptr = qargs[i+1].s_class;
-			    o->zval_ptr = *args[i];
-			    o->ce_ptr = qstring_ce;
-			    o->classId = 0;	// QString is not in smoke
-			    o->smoke = qt_Smoke;
-			    phpqt_setSmokePHPObject(o);
-			    // register all 
-			    zend_rsrc_list_entry le;
-			    le.ptr = o;
-			    object_init_ex(*args[i], qstring_ce);
-			    phpqt_register(o->zval_ptr,le);
-			    phpqt_setZvalPtr(o, o->zval_ptr);
-        		}
-        		methodNameStack.top()->append("$");
-
+        	methodNameStack.top()->append("$");
 	    } else if (type == IS_OBJECT){
-			smokephp_object *o = phpqt_getSmokePHPObjectFromZval(((zval*) *args[i]));
-        		qargs[i+1].s_class = o->ptr;
-            // as default QString is not supported in Smoke
-            if(!strcmp(Z_OBJCE_P(((zval*) *args[i]))->name, "QString")){
-            	qargs[i+1].s_class = new QString(((QString*) o->ptr)->toAscii().constData());
-            	methodNameStack.top()->append("$");
-            } else {
-            	methodNameStack.top()->append("#");
-            }
-
+        	// as default QString is not supported in Smoke
+        	if(!strcmp(Z_OBJCE_P(((zval*) *args[i]))->name, "QString")){
+            	    methodNameStack.top()->append("$");
+        	} else {
+        	    methodNameStack.top()->append("#");
+        	}
 	    } else {
 	        php_error(E_ERROR,"Unknown argument or unsupported argument type %d, type %d, exit\n", i, type);
 	        exit(FAILURE);
 	    }
-
     }
-
 }
 
 void 
-smokephp_convertReturn(Smoke::StackItem *ret_val, const Smoke::Type type, const Smoke::Index ret, zval* return_value){
-
-    smokephp_object* o;
-
-    switch((type.flags & Smoke::tf_elem)){
-        case Smoke::t_voidp:
-	    if(!type.name){
-        	RETVAL_NULL();
-	    } else {
-		if(!strcmp(type.name, "QString")) {
-		    // create new smokephp_object
-		    smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
-		    o->ptr = ret_val->s_voidp;
-		    o->zval_ptr = return_value;
-		    o->ce_ptr = qstring_ce;
-		    o->classId = 0;	// QString is not in smoke
-		    o->smoke = qt_Smoke;
-		    phpqt_setSmokePHPObject(o);
-		    // register all 
-		    zend_rsrc_list_entry le;
-		    le.ptr = o;
-		    object_init_ex(return_value, qstring_ce);
-		    phpqt_register(o->zval_ptr,le);
-		    phpqt_setZvalPtr(o, o->zval_ptr);
-
-		} else if(!strcmp(type.name, "QString*")) {
-		    php_error(E_WARNING,"No handler for returntype %s installed!", type.name);
-		} else if(!strcmp(type.name, "QString&")) {
-		    php_error(E_WARNING,"No handler for returntype %s installed!", type.name);
-		} else {
-		    php_error(E_WARNING,"No handler for returntype %s installed!", type.name);
-		}
-	    }
-    	    break;
-        case Smoke::t_bool:
-            RETVAL_BOOL(ret_val->s_bool);
-            break;
-        case Smoke::t_char:
-            RETVAL_STRING((char*)ret_val->s_char, 1);
-            break;
-        case Smoke::t_uchar:
-            RETVAL_STRING((char*)ret_val->s_char, 1);
-            break;
-        case Smoke::t_short:
-            RETVAL_LONG(ret_val->s_short);
-            break;
-        case Smoke::t_ushort:
-            RETVAL_LONG(ret_val->s_ushort);
-            break;
-        case Smoke::t_int:
-            RETVAL_LONG(ret_val->s_int);
-            break;
-        case Smoke::t_uint:
-            RETVAL_LONG(ret_val->s_uint);
-            break;
-        case Smoke::t_long:
-            RETVAL_LONG(ret_val->s_long);
-            break;
-        case Smoke::t_ulong:
-            RETVAL_LONG(ret_val->s_ulong);
-            break;
-        case Smoke::t_float:
-            RETVAL_DOUBLE(ret_val->s_float);
-            break;
-        case Smoke::t_double:
-            RETVAL_DOUBLE(ret_val->s_double);
-            break;
-        case Smoke::t_enum:
-            php_error(E_WARNING,"type enum not implemented\n");
-            break;
-        case Smoke::t_class:
- 			o = (smokephp_object*) emalloc(sizeof(smokephp_object));
-
-			// zval already exists
-
-			    if(phpqt_SmokePHPObjectExists(ret_val->s_voidp)) {
-				smokephp_object* o = phpqt_getSmokePHPObjectFromQt(ret_val->s_voidp);
-				ZVAL_ZVAL(return_value, o->zval_ptr,0,0);
-				zend_rsrc_list_entry le;
-				le.ptr = o;
-				phpqt_register(return_value, le);
-			} else {
-				o->ptr = ret_val->s_class;
-				o->smoke = qt_Smoke;
-				if(!strcmp((char*) qt_Smoke->classes[qt_Smoke->types[ret].classId].className, "QObject")){
-					// cast from, to
-					o->ptr = o->smoke->cast(o->ptr, qt_Smoke->idClass("QObject"), qt_Smoke->types[ret].classId);
-					object_init_ex(return_value, 
-									zend_fetch_class((char*)((QObject*) o->ptr)->metaObject()->className(),
-									strlen(((QObject*) o->ptr)->metaObject()->className()), 
-									ZEND_FETCH_CLASS_AUTO TSRMLS_DC));
-				//
-				} else if (!strcmp((char*) qt_Smoke->classes[qt_Smoke->types[ret].classId].className, "QBool")) {
-            			    RETVAL_BOOL(*((QBool*) ret_val->s_class));
-            			    return;
-				// fallback, already with correct type
-				} else {
-					object_init_ex(return_value, 
-									zend_fetch_class((char*) qt_Smoke->classes[qt_Smoke->types[ret].classId].className,
-									strlen(qt_Smoke->classes[qt_Smoke->types[ret].classId].className), 
-									ZEND_FETCH_CLASS_AUTO TSRMLS_DC));
-				}
-
-				o->zval_ptr = return_value;
-				o->ce_ptr = Z_OBJCE_P(return_value);
-				o->classId = qt_Smoke->types[ret].classId;
-
-				if(!phpqt_SmokePHPObjectExists(o->ptr))
-					phpqt_setSmokePHPObject(o);
-
-				zend_rsrc_list_entry le;
-				le.ptr = o;
-				phpqt_register(return_value, le);
-
-			}
-
-            return;
-        default:
-            php_error(E_ERROR,"unknown return type\n");
-            return;
-    }
-    return;
-}
-
-void 
 smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method){
 
     int j;

Modified: trunk/tests/QtBasicTestCase.php
===================================================================
--- trunk/tests/QtBasicTestCase.php	2007-03-08 21:16:51 UTC (rev 304)
+++ trunk/tests/QtBasicTestCase.php	2007-03-21 13:08:26 UTC (rev 305)
@@ -20,7 +20,7 @@
     class foo extends QObject {
 	const a = "a";
 	const b = 24;
-	
+
 	public function testMethod($value = NULL) {
 	    if ($value) echo $value."\n";
 	}
@@ -31,8 +31,6 @@
 
     class QtBasicTestCase extends PHPUnit_Framework_TestCase {
     
-	private $argc = 1; 
-	private $argv = "init";
 	private $app;
     
 	public function __construct($name) {
@@ -41,50 +39,59 @@
 
 	// try to fetch a string constant
 	function testFetchStringConstant() {
+	    echo "\ntesting foo::a";
 	    $this->assertEquals(foo::a, "a", "Could not fetch string constant!");
-	    echo "\ntesting foo::a passed";
+	    echo " passed";
 	}
 
 	// try to fetch a numeric constant
 	function testFetchNumConstant() {
+	    echo "\ntesting foo::b";
 	    $this->assertEquals(foo::b, 24, "Could not fetch numeric constant!");
-	    echo "\ntesting foo::b passed";
+	    echo " passed";
 	}
 
 	// try to fetch a Qt constant
 	function testQtConstant() {
+	    echo "\ntesting Qt::Horizontal";
 	    $this->assertTrue(Qt::Horizontal == 1, "Could not fetch constant from Qt!");
-	    echo "\ntesting Qt::Horizontal passed";
+	    echo " passed";
 	}
 
 	// test the __toString() method
 	function testQString() {
+	    echo "\ntesting QString::__toString()";
 	    $s = new QString("hello");
 	    $this->assertEquals($s->__toString(), "hello", "Could not handle __toString()!");
-	    echo "\ntesting QString::__toString() passed";
+	    echo " passed";
 	}
 
 	// try to append a PHP string to a QString
 	function testQStringAppendString() {
+	    echo "\ntesting QString::append(\"hello\")";
 	    $s = new QString("hello");
 	    $s->append(" world");
 	    $this->assertEquals($s->__toString(), "hello world", "Could append simple string to QString!");
-	    echo "\ntesting QString::append(\"hello\") passed";
+	    echo " passed";
 	}
 
 	// try to create an instance of QApplication
 	function testQApplication() {
-	    $this->app = new QApplication(&$this->argc,$this->argv);
+	    echo "\ntesting QApplication";
+	    $argc=1;
+	    $argv=array("argv");
+	    $this->app = new QApplication($argc,$argv);
 	    $this->assertTrue(is_object($this->app), "Could not create an instance of QApplication!");
-	    echo "\ntesting QApplication passed";
+	    echo " passed";
 	}
 
 	// test returning numbers
 	function testReturnNum() {
+	    echo "\ntesting numbers";
 	    $date = new QDate(2007,3,24);
 	    $this->assertTrue((gettype($date->day()) == "integer"), "Value returned is not integer type, ".gettype($date->day())." detected!");
 	    $this->assertTrue(($date->day() == 24), "Value returned is wrong!");
-	    echo "\ntesting numbers passed";
+	    echo " passed";
 	}
 
 	// test returning double
@@ -93,67 +100,81 @@
 
 	// test returning boolean
 	function testReturnBool() {
+	    echo "\ntesting bool";
 	    $date = new QDate(2007,3,24);
 	    $this->assertTrue((gettype($date->setDate(2007,3,24)) == "boolean"), "Value returned is not boolean type, ".gettype($date->setDate(2007,3,24))." detected!");
 	    $this->assertTrue(($date->setDate(2007,3,24) == true), "Value returned is wrong!");
-	    echo "\ntesting bool passed";
+	    echo " passed";
 	}
 
 	// test returning object
 	function testReturnObject() {
+	    echo "\ntesting objects";
 	    $parent = new QObject();
 	    $object = new QObject($parent);
 	    $parent__ = $object->parent();
 	    $this->assertTrue(($parent === $parent__),"Object returned by QObject->parent() is not the same as parent!");
-	    echo "\ntesting objects passed";
+	    echo " passed";
 	}
 // ???
 	// test returning a new object
 	function testReturnNewObject() {
+	    echo "\ntesting new objects";
 	    $date = new QDate(2007,3,24);
 	    $date__ = $date->addDays(2);
 	    $this->assertFalse(($date === $date__),"new Object returned by QObject->parent() is the same as parent!");
-	    echo "\ntesting new objects passed";
+	    echo " passed";
 	}
 
 	// test returning string
 	function testReturnQString() {
+	    echo "\ntesting QString as return";
 	    $object = new QObject();
 	    $object->setObjectName("hello");
 	    $string = $object->objectName();
 	    $this->assertTrue(is_object($string), "String is not a QString!");
 	    $this->assertEquals($string->toAscii(), "hello", "Return object does not contain the same text!");
-	    echo "\ntesting QString as return passed";
+	    echo " passed";
 	}
 
 	// try to give a QString as argument
 	function testAddQString() {
+	    echo "\ntesting QString as argument";
 	    $object = new QObject();
 	    $object->setObjectName(new QString("hello string"));
 	    $s = $object->objectName();
 	    $this->assertEquals($s->toAscii(),"hello string", "Return object does not contain the same text!");
-	    echo "\ntesting QString as argument passed";
+	    echo " passed";
 	}
 
 	// try to append a QString to a QString
 	function testQStringAppendObject() {
+	    echo "\ntesting QString::append(new QString(\"hello\"))";
 	    $s = new QString("hello");
 	    $t = new QString(" world");
 	    $s->append($t);
 	    $this->assertEquals($s->__toString(), "hello world", "Could not append QString to QString!");
-	    echo "\ntesting QString::append(new QString(\"hello\")) passed";
+	    echo " passed";
 	}
 
 	// test methods of an derivated object
 	function testUnknownMethod() {
+	    echo "\ntesting derivated object";
 	    $date = new QObject();
 	    $foo = new foo($date);
 	    $foo->parent();
 	    $foo->testMethod();
 //	    $foo->___();	// method not defined
-	    echo "\ntesting derivated object passed";
+	    echo " passed";
 	}
 
+	function testAmbiguousMethodCall() {
+	    echo "\ntesting ambiguous method call";
+	    $w = new QWidget();
+	    $w->setPalette(new QPalette(new QColor(250, 250, 200)));
+	    echo " passed";
+	}
+
     }    
     
 ?>
\ No newline at end of file



From tm243 at mail.berlios.de  Wed Mar 21 14:14:40 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 21 Mar 2007 14:14:40 +0100
Subject: [Php-qt-svn] r306 - trunk/php_qt
Message-ID: <200703211314.l2LDEeRs018607@sheep.berlios.de>

Author: tm243
Date: 2007-03-21 14:14:37 +0100 (Wed, 21 Mar 2007)
New Revision: 306

Added:
   trunk/php_qt/smokephp.h
Log:
* forgotten file



Added: trunk/php_qt/smokephp.h
===================================================================
--- trunk/php_qt/smokephp.h	2007-03-21 13:08:26 UTC (rev 305)
+++ trunk/php_qt/smokephp.h	2007-03-21 13:14:37 UTC (rev 306)
@@ -0,0 +1,323 @@
+#ifndef SMOKEPHP_H
+#define SMOKEPHP_H
+
+#include "smoke.h"
+
+#undef DEBUG
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#ifndef __USE_POSIX
+#define __USE_POSIX
+#endif
+#ifndef __USE_XOPEN
+#define __USE_XOPEN
+#endif
+#include "php.h"
+#define Qnil (zval *) NULL
+
+#include <QtCore/qbytearray.h>
+
+#include "php_qt.h"
+#include "marshall.h"
+
+//class SmokePHP;
+
+class SmokeType {
+    Smoke::Type *_t;		// derived from _smoke and _id, but cached
+
+    Smoke *_smoke;
+    Smoke::Index _id;
+public:
+    SmokeType() : _t(0), _smoke(0), _id(0) {}
+    SmokeType(Smoke *s, Smoke::Index i) : _smoke(s), _id(i) {
+	if(_id < 0 || _id > _smoke->numTypes) _id = 0;
+	_t = _smoke->types + _id;
+    }
+    // default copy constructors are fine, this is a constant structure
+
+    // mutators
+    void set(Smoke *s, Smoke::Index i) {
+	_smoke = s;
+	_id = i;
+	_t = _smoke->types + _id;
+    }
+
+    // accessors
+    Smoke *smoke() const { return _smoke; }
+    Smoke::Index typeId() const { return _id; }
+    const Smoke::Type &type() const { return *_t; }
+    unsigned short flags() const { return _t->flags; }
+    unsigned short elem() const { return _t->flags & Smoke::tf_elem; }
+    const char *name() const { return _t->name; }
+    Smoke::Index classId() const { return _t->classId; }
+
+    // tests
+    bool isStack() const { return ((flags() & Smoke::tf_ref) == Smoke::tf_stack); }
+    bool isPtr() const { return ((flags() & Smoke::tf_ref) == Smoke::tf_ptr); }
+    bool isRef() const { return ((flags() & Smoke::tf_ref) == Smoke::tf_ref); }
+    bool isConst() const { return (flags() & Smoke::tf_const); }
+    bool isClass() const {
+	if(elem() == Smoke::t_class)
+	    return classId() ? true : false;
+	return false;
+    }
+    bool isQString() const {
+	if(elem() == Smoke::t_voidp && !(elem() == Smoke::t_class))
+	    return true;
+	return false;
+    }
+    bool operator ==(const SmokeType &b) const {
+	const SmokeType &a = *this;
+	if(a.name() == b.name()) return true;
+	if(a.name() && b.name() && qstrcmp(a.name(), b.name()) == 0)
+	    return true;
+	return false;
+    }
+    bool operator !=(const SmokeType &b) const {
+	const SmokeType &a = *this;
+	return !(a == b);
+    }
+
+};
+
+class SmokeClass {
+    Smoke::Class *_c;
+    Smoke *_smoke;
+    Smoke::Index _id;
+public:
+    SmokeClass(const SmokeType &t) {
+	_smoke = t.smoke();
+	_id = t.classId();
+	_c = _smoke->classes + _id;
+    }
+    SmokeClass(Smoke *smoke, Smoke::Index id) : _smoke(smoke), _id(id) {
+	_c = _smoke->classes + _id;
+    }
+
+    Smoke *smoke() const { return _smoke; }
+    const Smoke::Class &c() const { return *_c; }
+    Smoke::Index classId() const { return _id; }
+    const char *className() const { return _c->className; }
+    Smoke::ClassFn classFn() const { return _c->classFn; }
+    Smoke::EnumFn enumFn() const { return _c->enumFn; }
+    bool operator ==(const SmokeClass &b) const {
+	const SmokeClass &a = *this;
+	if(a.className() == b.className()) return true;
+	if(a.className() && b.className() && qstrcmp(a.className(), b.className()) == 0)
+	    return true;
+	return false;
+    }
+    bool operator !=(const SmokeClass &b) const {
+	const SmokeClass &a = *this;
+	return !(a == b);
+    }
+    bool isa(const SmokeClass &sc) const {
+	// This is a sick function, if I do say so myself
+	if(*this == sc) return true;
+	Smoke::Index *parents = _smoke->inheritanceList + _c->parents;
+	for(int i = 0; parents[i]; i++) {
+	    if(SmokeClass(_smoke, parents[i]).isa(sc)) return true;
+	}
+	return false;
+    }
+
+    unsigned short flags() const { return _c->flags; }
+    bool hasConstructor() const { return flags() & Smoke::cf_constructor; }
+    bool hasCopy() const { return flags() & Smoke::cf_deepcopy; }
+    bool hasVirtual() const { return flags() & Smoke::cf_virtual; }
+    bool hasFire() const { return !(flags() & Smoke::cf_undefined); }
+};
+
+class SmokeMethod {
+    Smoke::Method *_m;
+    Smoke *_smoke;
+    Smoke::Index _id;
+public:
+    SmokeMethod(Smoke *smoke, Smoke::Index id) : _smoke(smoke), _id(id) {
+	_m = _smoke->methods + _id;
+    }
+
+    Smoke *smoke() const { return _smoke; }
+    const Smoke::Method &m() const { return *_m; }
+    SmokeClass c() const { return SmokeClass(_smoke, _m->classId); }
+    const char *name() const { return _smoke->methodNames[_m->name]; }
+    int numArgs() const { return _m->numArgs; }
+    unsigned short flags() const { return _m->flags; }
+    SmokeType arg(int i) const {
+	if(i >= numArgs()) return SmokeType();
+	return SmokeType(_smoke, _smoke->argumentList[_m->args + i]);
+    }
+    SmokeType ret() const { return SmokeType(_smoke, _m->ret); }
+    Smoke::Index methodId() const { return _id; }
+    Smoke::Index method() const { return _m->method; }
+
+    bool isStatic() const { return flags() & Smoke::mf_static; }
+    bool isConst() const { return flags() & Smoke::mf_const; }
+
+    void call(Smoke::Stack args, void *ptr = 0) const {
+	Smoke::ClassFn fn = c().classFn();
+	(*fn)(method(), ptr, args);
+    }
+};
+
+class Smoke_MAGIC {	// to be rewritten
+    SmokeClass _c;
+    void *_ptr;
+    bool _isAllocated;
+public:
+    Smoke_MAGIC(void *p, const SmokeClass &c) :
+	_c(c), _ptr(p), _isAllocated(false) {}
+    const SmokeClass &c() const { return _c; }
+    void *ptr() const { return _ptr; }
+    bool isAllocated() const { return _isAllocated; }
+    void setAllocated(bool isAllocated) { _isAllocated = isAllocated; }
+};
+
+ 
+/**
+ * SmokeObject is a thin wrapper around zval* objects. Each SmokeObject instance
+ * increments the refcount of its zval* for the duration of its existance.
+ *
+ * SmokeObject instances are only returned from SmokePHP, since the method
+ * of binding data to the scalar must be consistent across all modules.
+ */
+class SmokeObject {
+    zval* rv;
+    Smoke_MAGIC *m;
+
+public:
+    SmokeObject(zval* obj, Smoke_MAGIC *mag) : rv(obj), m(mag) {
+    }
+    
+    ~SmokeObject() {
+    }
+    
+    SmokeObject(const SmokeObject &other) {
+	rv = other.rv;
+	m = other.m;
+
+    }
+    
+    SmokeObject &operator =(const SmokeObject &other) {
+	rv = other.rv;
+	m = other.m;
+	return *this;
+    }
+
+    const SmokeClass &c() { return m->c(); }
+    Smoke *smoke() { return c().smoke(); }
+    zval* var() { return rv; }
+    void *ptr() { return m->ptr(); }
+    Smoke::Index classId() { return c().classId(); }
+    void *cast(const SmokeClass &toc) {
+	return smoke()->cast(
+	    ptr(),
+	    classId(),
+	    smoke()->idClass(toc.className())
+	);
+    }
+    const char *className() { return c().className(); }
+
+    bool isValid() const { return !(rv == Qnil); }
+    bool isAllocated() const { return m->isAllocated(); }
+    void setAllocated(bool i) { m->setAllocated(i); }
+};
+
+
+/**
+ * Since it's not easy to share functions between PHP modules, the common
+ * interface between all Smoked libraries and PHP will be defined in this
+ * class. There will be only one SmokePHP instance loaded for an entire PHP
+ * process. It has no data members here -- this is only an abstract interface.
+ */
+
+class SmokePHP {
+    void *future_extension;
+public:
+    SmokePHP() : future_extension(0) {}
+
+    // don't need this, we're only defining an interface
+    virtual ~SmokePHP() = 0;
+
+    /**
+     * Registers a Smoke object
+     */
+    virtual void registerSmoke(const char *name, Smoke *smoke) = 0;
+
+    /**
+     * Gets a smoke object from its name
+     */
+    virtual Smoke *getSmoke(const char *name) = 0;
+
+    /**
+     * Determines if the named smoke is registered.
+     */
+    bool isSmokeRegistered(const char *name) { return getSmoke(name) ? true : false; }
+
+    virtual void registerHandlers(TypeHandler *handlers) = 0;
+
+    /**
+     * Returns a new blessed SV referring to the pointer passed.
+     * Use sv_2mortal() before passing it around.
+     *
+     * @param p pointer to the C++ object. The pointer isn't automatically deleted by SmokePerl.
+     * @param c class of the pointer
+     * @see #getObject
+     * @see #deleteObject
+     */
+    virtual SmokeObject newObject(void *p, const SmokeClass &c) = 0;
+
+    /**
+     * Same as newObject(), except it doesn't treat p as owned by Perl
+     */
+    virtual SmokeObject wrapObject(void *p, const SmokeClass &c) = 0;
+
+    /**
+     * Any SV* created with newObject() on a class with virtual methods can be
+     * retrieved again.
+     */
+    virtual SmokeObject getObject(void *p) = 0;
+
+    /**
+     * Create a SmokeObject from the given zval*
+     */
+    virtual SmokeObject getObject(zval* value) = 0;
+};
+
+/*
+ * Type handling by moc is simple.
+ *
+ * If the type name matches /^(?:const\s+)?\Q$types\E&?$/, use the
+ * static_QUType, where $types is join('|', qw(bool int double char* QString);
+ *
+ * Everything else is passed as a pointer! There are types which aren't
+ * Smoke::tf_ptr but will have to be passed as a pointer. Make sure to keep
+ * track of what's what.
+ */
+
+/*
+ * Simply using typeids isn't enough for signals/slots. It will be possible
+ * to declare signals and slots which use arguments which can't all be
+ * found in a single smoke object. Instead, we need to store smoke => typeid
+ * pairs. We also need additional informatation, such as whether we're passing
+ * a pointer to the union element.
+ */
+
+enum MocArgumentType {
+    xmoc_ptr,
+    xmoc_bool,
+    xmoc_int,
+    xmoc_double,
+    xmoc_charstar,
+    xmoc_QString,
+    xmoc_void
+};
+
+struct MocArgument {
+    // smoke object and associated typeid
+    SmokeType st;
+    MocArgumentType argType;
+};
+
+#endif // SMOKEPHP_H



From tm243 at mail.berlios.de  Thu Mar 22 13:40:31 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Thu, 22 Mar 2007 13:40:31 +0100
Subject: [Php-qt-svn] r307 - in trunk: . php_qt
Message-ID: <200703221240.l2MCeVWk000714@sheep.berlios.de>

Author: tm243
Date: 2007-03-22 13:40:31 +0100 (Thu, 22 Mar 2007)
New Revision: 307

Modified:
   trunk/ChangeLog
   trunk/php_qt/functions.cpp
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/marshall_types.h
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/smokephp.cpp
Log:
* added signal handler



Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2007-03-21 13:14:37 UTC (rev 306)
+++ trunk/ChangeLog	2007-03-22 12:40:31 UTC (rev 307)
@@ -1,5 +1,9 @@
-2007-003-4  Thomas Moenicke <thomas.moenicke at kdemail.net>
+2007-003-22  Thomas Moenicke <thomas.moenicke at kdemail.net>
 
+		* signal handler added
+
+2007-003-21  Thomas Moenicke <thomas.moenicke at kdemail.net>
+
 		* object oriented handlers (see QtRuby)
 
 2007-003-4  Thomas Moenicke <thomas.moenicke at kdemail.net>

Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-03-21 13:14:37 UTC (rev 306)
+++ trunk/php_qt/functions.cpp	2007-03-22 12:40:31 UTC (rev 307)
@@ -109,16 +109,7 @@
     if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s",&string,&string_len)) {
         return;
     }
-
-    char* tmp = (char*) emalloc((int) string_len + 2);
-    strcpy(tmp,"1");
-
-    strncat(tmp, string, (int) string_len);
-
-    ZVAL_STRING(return_value,tmp,1);
-
-    efree(tmp);
-
+    QByteArray signature(string);
     return;
 }
 

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-03-21 13:14:37 UTC (rev 306)
+++ trunk/php_qt/marshall_types.cpp	2007-03-22 12:40:31 UTC (rev 307)
@@ -21,8 +21,9 @@
 void
 smokeStackToQtStack(Smoke::Stack stack, void ** o, int items, MocArgument* args)
 {
+
 	for (int i = 0; i < items; i++) {
-		Smoke::StackItem *si = stack + i;
+		Smoke::StackItem *si = stack;
 		switch(args[i].argType) {
 		case xmoc_bool:
 			o[i] = &si->s_bool;
@@ -357,7 +358,7 @@
 }
 
 
-VirtualMethodCall::VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval obj, zval ***sp) :
+VirtualMethodCall::VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* obj, zval ***sp) :
 	MethodCallBase(smoke,meth,stack), _obj(obj)
 {		
 	_sp = sp;
@@ -460,8 +461,11 @@
 	return qstrcmp(MethodCallBase::classname(), "QGlobalSpace") == 0 ? "" : MethodCallBase::classname(); 
 }
 
-SigSlotBase::SigSlotBase(zval ***args) : _cur(-1), _called(false) 
+SigSlotBase::SigSlotBase(int items, MocArgument* mocStack, zval*** sp) : _cur(-1), _called(false), _sp(sp)
 { 
+	_items = items + 1;
+	_args = mocStack;
+	_stack = new Smoke::StackItem[_items -1];
 }
 
 SigSlotBase::~SigSlotBase() 
@@ -490,7 +494,7 @@
 zval* 
 SigSlotBase::var() 
 { 
-	return *_sp[_cur]; 
+	return (zval*) *_sp[_cur]; 
 }
 
 Smoke *
@@ -516,7 +520,6 @@
 		(*fn)(this);
 		_cur++;
 	}
-
 	mainfunction();
 	_cur = oldcur;
 }
@@ -571,11 +574,11 @@
 		delete[] _stack;
 	}
 };
-/*
-InvokeSlot::InvokeSlot(zval* obj, ID slotname, zval*** args, void ** o) : SigSlotBase(args),
+
+/*InvokeSlot::InvokeSlot(zval* obj, int slotname, zval*** args, void ** o) : SigSlotBase(args),
     _obj(obj), _slotname(slotname), _o(o)
 {
-//	_sp = (zval *) ALLOC_N(VALUE, _items - 1);
+	_sp = (zval *) safe_emalloc((zval*), _items - 1, 0);
 	copyArguments();
 }
 
@@ -625,9 +628,10 @@
 }
 */
 
-EmitSignal::EmitSignal(QObject *obj, int id, int items, zval*** args, zval ***sp, zval * result) : SigSlotBase(args),
+EmitSignal::EmitSignal(QObject *obj, int id, int items, MocArgument *mocStack, zval ***sp, zval * result) : SigSlotBase(items, mocStack, _sp),
     _obj(obj), _id(id)
 { 
+	_id = id;
 	_sp = sp;
 	_result = result;
 }
@@ -640,7 +644,7 @@
 
 Smoke::StackItem &
 EmitSignal::item() 
-{ 
+{
 	return _stack[_cur]; 
 }
 
@@ -653,15 +657,18 @@
 void 
 EmitSignal::emitSignal() 
 {
+
 	if (_called) return;
 	_called = true;
+
 	void ** o = new void*[_items];
-//	smokeStackToQtStack(_stack, o + 1, _items - 1, _args + 1);
+	smokeStackToQtStack(_stack, o + 1, _items - 1, _args + 1);
 	_obj->metaObject()->activate(_obj, _id, o);
-	
+
 	if (_args[0].argType != xmoc_void) {
-		SignalReturnValue r(o, _result, _args);
+//		SignalReturnValue r(o, _result, _args);
 	}
+
 	delete[] o;
 }
 

Modified: trunk/php_qt/marshall_types.h
===================================================================
--- trunk/php_qt/marshall_types.h	2007-03-21 13:14:37 UTC (rev 306)
+++ trunk/php_qt/marshall_types.h	2007-03-22 12:40:31 UTC (rev 307)
@@ -104,7 +104,7 @@
 
 class VirtualMethodCall : public MethodCallBase {
 public:
-	VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval obj, zval ***sp);
+	VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* obj, zval ***sp);
 	~VirtualMethodCall();
 	Marshall::Action action();
 	zval* var();
@@ -113,7 +113,7 @@
 	bool cleanup();
  
 private:
-	zval _obj;
+	zval* _obj;
 };
 
 
@@ -163,7 +163,7 @@
 
 class SigSlotBase : public Marshall {
 public:
-	SigSlotBase(zval ***args);
+	SigSlotBase(int items, MocArgument* mocStack, zval*** sp);
 	~SigSlotBase();
 	const MocArgument &arg();
 	SmokeType type();
@@ -190,7 +190,7 @@
     int _id;
 	zval * _result;
  public:
-    EmitSignal(QObject *obj, int id, int items, zval*** args, zval ***sp, zval * result);
+    EmitSignal(QObject *obj, int id, int items, MocArgument* mocStack, zval ***sp, zval * result);
     Marshall::Action action();
     Smoke::StackItem &item();
 	const char *mytype();
@@ -212,13 +212,13 @@
 	void mainfunction();
 	bool cleanup();
 };
-/*
+
 class InvokeSlot : public SigSlotBase {
     zval _obj;
-    ID _slotname;
+    int _slotname;
     void **_o;
 public:
-    InvokeSlot(zval obj, ID slotname, zval args, void ** o);
+    InvokeSlot(zval* obj, int slotname, zval*** args, void ** o);
 	~InvokeSlot();
     Marshall::Action action();
 	const char *mytype();
@@ -227,8 +227,8 @@
 	void invokeSlot(); 
 	void mainfunction();
 };
-*/
 
+
 /*
 	Converts a C++ value returned by a signal invocation to a PHP 
 	reply type
@@ -243,7 +243,7 @@
 		_result = result;
 		_replyType = replyType;
 		_stack = new Smoke::StackItem[1];
-//		smokeStackFromQtStack(_stack, o, 1, _replyType);
+		smokeStackFromQtStack(_stack, o, 1, _replyType);
 		Marshall::HandlerFn fn = getMarshallFn(type());
 		(*fn)(this);
     }

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-03-21 13:14:37 UTC (rev 306)
+++ trunk/php_qt/php_qt.cpp	2007-03-22 12:40:31 UTC (rev 307)
@@ -20,17 +20,13 @@
  *
  */
 
-// TODO		references, arrays
-// TODO		emit()
+// TODO		references
 
-
-
-#include <QtCore/qglobal.h>
 #include <zend_interfaces.h>
 #include "php_qt.h"
-
 #include "ext/standard/php_string.h"
 
+#include <QtCore/qglobal.h>
 #include "marshall.h"
 #include "php_qt.h"
 #include "smokephp.h"
@@ -115,11 +111,11 @@
 
 }
 
-
 /*! php_qt_functions[]
  *
  * Every user visible function must have an entry in php_qt_functions[].
  */
+#undef emit
 function_entry php_qt_functions[] = {
 	PHP_FE(confirm_php_qt_compiled,	NULL)		/* For testing, remove later. */
 	PHP_FE(SIGNAL,	NULL)
@@ -154,6 +150,7 @@
 ZEND_GET_MODULE(php_qt)
 #endif
 
+
 static QHash<smokephp_object*, zval*> smoke_x_zval;
 QHash<void*, smokephp_object*> SmokeQtObjects;
 QStack<QString*> methodNameStack;
@@ -193,6 +190,7 @@
 ZEND_METHOD(php_qt_generic_class, __construct);
 ZEND_METHOD(php_qt_generic_class, __destruct);
 ZEND_METHOD(php_qt_generic_class, __toString);
+ZEND_METHOD(php_qt_generic_class, emit);
 ZEND_METHOD(php_qt_generic_class, proxyMethod);
 ZEND_METHOD(php_qt_generic_class, staticProxyMethod);
 
@@ -200,12 +198,16 @@
     ZEND_ME(php_qt_generic_class,__construct,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(php_qt_generic_class,__destruct,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(php_qt_generic_class,__toString,NULL,ZEND_ACC_PUBLIC)
+    ZEND_ME(php_qt_generic_class,emit,NULL,ZEND_ACC_PUBLIC)
     ZEND_ME(php_qt_generic_class,proxyMethod,NULL,ZEND_ACC_PUBLIC)
     {NULL,NULL,NULL}
 };
 
 static zend_function_entry*** php_qt_static_methods;
 
+ZEND_METHOD(php_qt_generic_class, emit){
+}
+
 ZEND_METHOD(php_qt_generic_class, __toString)
 {
 	if(!strcmp(Z_OBJCE_P(getThis())->name,"QString")){
@@ -335,8 +337,38 @@
     Smoke::Index method = smokephp_getMethod(qt_Smoke,ce->name, (methodNameStack.top())->toAscii(), argc, args);
 
     if(method <= 0) {
-	if(methodNameStack.top()->toAscii().constData()) 
+	if(methodNameStack.top()->toAscii().constData()) {
+
+	    // is it a signal?
+	    if(getThis()){
+		smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
+		if(o->meta != NULL){
+		    QMetaObject* mo = (QMetaObject*) o->meta;
+		    QByteArray signalname(methodNameStack.top()->toAscii().constData());
+		    signalname.replace("$","");
+		    signalname.replace("#","");
+		    signalname.replace("?","");
+		    MocArgument *mocStack = new MocArgument[argc+1]; // first entry is return value
+		    signalname.append(smokephp_getSignature(argc, args, mocStack)->constData());
+		    // seems to be a signal
+		    int index = mo->indexOfSignal(signalname);
+		    if(index >= 0) {
+			QObject *qobj = (QObject*)o->smoke->cast(
+			    o->ptr,
+			    o->classId,
+			    o->smoke->idClass("QObject")
+			);
+			zval* result;
+			EmitSignal signal(qobj, index, argc, mocStack, args, result);
+			signal.next();
+			// TODO return value
+			RETURN_NULL();
+		    }
+		}
+	    }
+
 	    php_error(E_ERROR,"Call to undefined method %s::%s()", ce->name, methodNameStack.top()->toAscii().constData());
+	}
 	else 
 	    php_error(E_ERROR,"Call to undefined method!");
     }
@@ -414,6 +446,7 @@
         PHP_QT_ME(php_qt_generic_class,__construct,NULL,ZEND_ACC_PUBLIC);
         PHP_QT_ME(php_qt_generic_class,__destruct,NULL,ZEND_ACC_PUBLIC);
         PHP_QT_ME(php_qt_generic_class,__toString,NULL,ZEND_ACC_PUBLIC);
+	PHP_QT_ME(php_qt_generic_class,emit,NULL,ZEND_ACC_PUBLIC);
         PHP_QT_ME(php_qt_generic_class,proxyMethod,NULL,ZEND_ACC_PUBLIC);
 
 	QHash<const char*, bool> tmpMethodList;	// avoids doubled method names
@@ -693,7 +726,7 @@
     zval* retval;
     MAKE_STD_ZVAL(retval);
 
-    if(call_user_function_ex(CG(function_table),&this_ptr,function_name,&retval,param_count,args,0,NULL) == FAILURE){
+    if(call_user_function(EG(function_table),&this_ptr,function_name,retval,param_count,*args) == FAILURE){
     	php_error(E_ERROR, "PHP-Qt could not call method %s", methodname);
     }
 

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-03-21 13:14:37 UTC (rev 306)
+++ trunk/php_qt/php_qt.h	2007-03-22 12:40:31 UTC (rev 307)
@@ -26,22 +26,25 @@
 #define MONITOR
 
 #define COMPILE_DL_PHP_QT
-#define PHPQT_CLASS_COUNT 50
+#define PHPQT_CLASS_COUNT 256
 
 #include <iostream>
 using namespace std;
 
 #include <zend_interfaces.h>
+#include "php.h"
+#include "php_ini.h"
+#include "ext/standard/info.h"
+
 #include "smoke.h"
-
+#include "smokephp.h"
+#include <QtCore/QMetaMethod>
+#include <QtCore/QStack>
+#include <QtCore/QHash>
 #include <QtCore/QTextStream>
 #include <QtCore/QVariant>
-#include <QtCore/QStack>
 #include <QtCore/QString>
-#include <QtCore/QMetaMethod>
-#include <QtCore/QHash>
 #include <QtCore/QCoreApplication>
-
 #include <QtGui/QWidget>
 #include <QtGui/QApplication>
 #include <QtGui/QLayout>
@@ -80,9 +83,6 @@
 
 #define PHP_QT_ME(classname, name, arg_info, flags)	PHP_QT_FENTRY(name, ZEND_MN(classname##_##name), arg_info, flags)
 
-#include "php.h"
-#include "php_ini.h"
-#include "ext/standard/info.h"
 
 PHP_MINIT_FUNCTION(php_qt);
 PHP_MSHUTDOWN_FUNCTION(php_qt);
@@ -91,14 +91,13 @@
 PHP_MINFO_FUNCTION(php_qt);
 
 PHP_FUNCTION(confirm_php_qt_compiled);	/* For testing, remove later. */
-
 /* emulate SIGNAL(), SLOT() macros */
 PHP_FUNCTION(SIGNAL);
 PHP_FUNCTION(SLOT);
+#undef emit
 PHP_FUNCTION(emit);
 PHP_FUNCTION(qobject_cast);
 PHP_FUNCTION(tr);
-
 PHP_FUNCTION(check_qobject);
 
 struct smokephp_object {
@@ -143,6 +142,7 @@
 bool 				smokephp_isQObject(Smoke *smoke, Smoke::Index classId);
 Smoke::Index 			smokephp_getClassId(const char* classname);
 void				smokephp_prepareMethodName(zval*** args, int argc, QStack<QString*> &methodNameStack);
+QByteArray* 			smokephp_getSignature(int argc, zval ***argv, MocArgument* mocStack);
 Smoke::Index			smokephp_getMethod(Smoke *smoke, const char* c, const char* m, int argc, zval*** args);
 void				smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method);
 void				smokephp_callMethod(Smoke *smoke, void *obj, Smoke::Index method, Smoke::Stack qargs);

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-03-21 13:14:37 UTC (rev 306)
+++ trunk/php_qt/smokephp.cpp	2007-03-22 12:40:31 UTC (rev 307)
@@ -22,6 +22,7 @@
 
 #include "php_qt.h"
 #include "smoke.h"
+#include "marshall_types.h"
 #include <QtCore/QMetaMethod>
 #include <QtCore/QHash>
 #include <QtCore/QCoreApplication>
@@ -67,9 +68,16 @@
 			return true;
 		}
 
-//		VirtualMethodCall c(smoke, method, args, obj, ...);
-//		c.next();
+		if(phpqt_methodExists(o->ce_ptr, (char*) methodName)){
+/*		    zval*** sp = (zval***) malloc(sizeof(zval)*2);
+		    zval* obj;
+		    phpqt_callMethod(o->zval_ptr, (char*) methodName, 0, sp);
 
+		    VirtualMethodCall c(smoke, method, args, obj, sp);
+		    c.next();
+*/
+		}
+		
 		return false;
 
     }
@@ -170,7 +178,7 @@
 								    qt_Smoke->argumentList[
 									qt_Smoke->methods[
 									    qt_Smoke->ambiguousMethodList[i]].args+k]].name);
-							    if(name->contains(Z_OBJCE((zval) **args[k])->name))
+							    if(name->contains(Z_OBJCE_P((zval*) *args[k])->name))
 								right = true;
 							}
 							break;
@@ -379,6 +387,65 @@
     }
 }
 
+
+static Smoke::Index getSmokeIndex(const char* name) {
+    Smoke::Type *p = qt_Smoke->types + 1;
+    Smoke::Index index = 0;
+    for(index=1;index<=qt_Smoke->numTypes;index++){
+	if(!strcmp((p++)->name, name)){
+	    return index;
+	}
+    }
+    return 0;
+}
+
+QByteArray* smokephp_getSignature(int argc, zval ***argv, MocArgument* mocStack){
+
+    mocStack[0].argType = xmoc_bool;	// return
+
+    QByteArray *signature = new QByteArray("(");// = new QByteArray();
+    for(int i=0;i<argc;i++){
+	    uint type = ((int) ((zval) **argv[i]).type);
+	    mocStack[i+1].st = SmokeType(qt_Smoke,0);
+	    if (type == IS_RESOURCE){ // TODO
+	    } else if (type == IS_ARRAY){
+		//    xmoc_ptr,
+	    } else if (type == IS_BOOL){
+		mocStack[i+1].argType = xmoc_bool;
+		mocStack[i+1].st = SmokeType(qt_Smoke,getSmokeIndex("bool"));
+		signature->append("bool");
+	    } else if (type == IS_LONG){
+		mocStack[i+1].argType = xmoc_int;
+		mocStack[i+1].st = SmokeType(qt_Smoke,getSmokeIndex("int"));
+		signature->append("int");
+	    } else if (type == IS_DOUBLE){
+		mocStack[i+1].argType = xmoc_double;
+		mocStack[i+1].st = SmokeType(qt_Smoke,getSmokeIndex("double"));
+		signature->append("double");
+	    } else if (type == IS_STRING){
+		mocStack[i+1].argType = xmoc_charstar;
+		mocStack[i+1].st = SmokeType(qt_Smoke,getSmokeIndex("char*"));
+		signature->append("string");
+	    } else if (type == IS_OBJECT){
+		if(Z_OBJCE_P(((zval*) *argv[i])) == qstring_ce)
+		    mocStack[i+1].argType = xmoc_QString;
+		else {
+		    smokephp_object *o = phpqt_getSmokePHPObjectFromZval((zval*) *argv[i]);
+		    mocStack[i+1].st = SmokeType(qt_Smoke,o->classId);
+		    mocStack[i+1].argType = xmoc_void;
+		}
+		signature->append("object");
+	    } else {
+	        php_error(E_ERROR,"Unknown argument or unsupported argument type %d, type %d, exit\n", i, type);
+	        exit(FAILURE);
+	    }
+    }
+    signature->append(")");
+    return signature;
+
+}
+
+
 void 
 smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method){
 



From tm243 at mail.berlios.de  Fri Mar 23 10:46:05 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Fri, 23 Mar 2007 10:46:05 +0100
Subject: [Php-qt-svn] r308 - in trunk: . php_qt
Message-ID: <200703230946.l2N9k5YM021105@sheep.berlios.de>

Author: tm243
Date: 2007-03-23 10:46:04 +0100 (Fri, 23 Mar 2007)
New Revision: 308

Modified:
   trunk/ChangeLog
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/smokephp.cpp
Log:
* call of overwritten protected methods



Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2007-03-22 12:40:31 UTC (rev 307)
+++ trunk/ChangeLog	2007-03-23 09:46:04 UTC (rev 308)
@@ -1,5 +1,9 @@
 2007-003-22  Thomas Moenicke <thomas.moenicke at kdemail.net>
 
+		* call of overwritten protected methods
+
+2007-003-22  Thomas Moenicke <thomas.moenicke at kdemail.net>
+
 		* signal handler added
 
 2007-003-21  Thomas Moenicke <thomas.moenicke at kdemail.net>

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-03-22 12:40:31 UTC (rev 307)
+++ trunk/php_qt/php_qt.cpp	2007-03-23 09:46:04 UTC (rev 308)
@@ -150,7 +150,6 @@
 ZEND_GET_MODULE(php_qt)
 #endif
 
-
 static QHash<smokephp_object*, zval*> smoke_x_zval;
 QHash<void*, smokephp_object*> SmokeQtObjects;
 QStack<QString*> methodNameStack;
@@ -167,15 +166,29 @@
  *	proxy handler
  */
 
-union _zend_function *proxyHandler(zval **obj_ptr, char* methodname, int methodname_len TSRMLS_DC){
+union _zend_function *proxyHandler(zval **obj_ptr, char* methodName, int methodName_len TSRMLS_DC){
 
     union _zend_function *fbc;
 
+    // overwritten protected Qt methods wont work until we cheat here
+    int method_len = strlen(methodName);
+    char* lc_method_name = (char*) do_alloca(method_len+1);
+    zend_str_tolower_copy(lc_method_name, methodName, method_len);
+    // get the zend object and the function pointer
+    zend_object *zobj = zend_objects_get_address(*obj_ptr TSRMLS_CC);
+    if (zend_hash_find(&zobj->ce->function_table, lc_method_name, method_len+1, (void **)&fbc) != FAILURE) {
+	if(fbc->common.fn_flags & ZEND_ACC_PROTECTED){
+	    if(qt_Smoke->idMethodName(methodName) > 0){
+		fbc->common.fn_flags = ZEND_ACC_PUBLIC;
+	    }
+	}
+    }
+
     // a try for non-Qt objects
-    fbc = zend_orig_handler.get_method(obj_ptr, methodname, methodname_len);
+    fbc = zend_orig_handler.get_method(obj_ptr, methodName, methodName_len);
 
     if(!fbc) {    // maybe a Qt object
-        methodNameStack.push(new QString(methodname));
+        methodNameStack.push(new QString(methodName));
 	    // call proxy
 	    fbc = zend_orig_handler.get_method(obj_ptr, "proxyMethod", 11);
     }
@@ -394,7 +407,6 @@
 
 	// object list
 	le_php_qt_hashtype = zend_register_list_destructors_ex(phpqt_destroyHashtable, NULL, "PHP-Qt object list", module_number);
-	// FIXME: 50 is fix
 	zend_hash_init_ex(&php_qt_objptr_hash, PHPQT_CLASS_COUNT, NULL, NULL, 1, 0);
 
 	// overwrite method handler
@@ -712,7 +724,7 @@
 }
 
 zval* 
-phpqt_callMethod(zval* this_ptr, char* methodname, zend_uint param_count, zval** args[])
+phpqt_callMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args[])
 {
 
 	if(this_ptr == NULL){
@@ -721,13 +733,13 @@
 
     zval *function_name;
     MAKE_STD_ZVAL(function_name);
-    ZVAL_STRING(function_name,methodname,1);
+    ZVAL_STRING(function_name,methodName,1);
 
     zval* retval;
     MAKE_STD_ZVAL(retval);
 
     if(call_user_function(EG(function_table),&this_ptr,function_name,retval,param_count,*args) == FAILURE){
-    	php_error(E_ERROR, "PHP-Qt could not call method %s", methodname);
+    	php_error(E_ERROR, "PHP-Qt could not call method %s", methodName);
     }
 
     return retval;

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-03-22 12:40:31 UTC (rev 307)
+++ trunk/php_qt/smokephp.cpp	2007-03-23 09:46:04 UTC (rev 308)
@@ -69,10 +69,11 @@
 		}
 
 		if(phpqt_methodExists(o->ce_ptr, (char*) methodName)){
-/*		    zval*** sp = (zval***) malloc(sizeof(zval)*2);
+		    zval*** sp = (zval***) malloc(sizeof(zval)*2);
 		    zval* obj;
-		    phpqt_callMethod(o->zval_ptr, (char*) methodName, 0, sp);
 
+		    phpqt_callMethod(o->zval_ptr, (char*) methodName, 0, sp);
+/*
 		    VirtualMethodCall c(smoke, method, args, obj, sp);
 		    c.next();
 */
@@ -387,18 +388,6 @@
     }
 }
 
-
-static Smoke::Index getSmokeIndex(const char* name) {
-    Smoke::Type *p = qt_Smoke->types + 1;
-    Smoke::Index index = 0;
-    for(index=1;index<=qt_Smoke->numTypes;index++){
-	if(!strcmp((p++)->name, name)){
-	    return index;
-	}
-    }
-    return 0;
-}
-
 QByteArray* smokephp_getSignature(int argc, zval ***argv, MocArgument* mocStack){
 
     mocStack[0].argType = xmoc_bool;	// return
@@ -410,21 +399,22 @@
 	    if (type == IS_RESOURCE){ // TODO
 	    } else if (type == IS_ARRAY){
 		//    xmoc_ptr,
+		php_error(E_WARNING, "Array given as signal argument");
 	    } else if (type == IS_BOOL){
 		mocStack[i+1].argType = xmoc_bool;
-		mocStack[i+1].st = SmokeType(qt_Smoke,getSmokeIndex("bool"));
+		mocStack[i+1].st = SmokeType(qt_Smoke,qt_Smoke->idType("bool"));
 		signature->append("bool");
 	    } else if (type == IS_LONG){
 		mocStack[i+1].argType = xmoc_int;
-		mocStack[i+1].st = SmokeType(qt_Smoke,getSmokeIndex("int"));
+		mocStack[i+1].st = SmokeType(qt_Smoke,qt_Smoke->idType("int"));
 		signature->append("int");
 	    } else if (type == IS_DOUBLE){
 		mocStack[i+1].argType = xmoc_double;
-		mocStack[i+1].st = SmokeType(qt_Smoke,getSmokeIndex("double"));
+		mocStack[i+1].st = SmokeType(qt_Smoke,qt_Smoke->idType("double"));
 		signature->append("double");
 	    } else if (type == IS_STRING){
 		mocStack[i+1].argType = xmoc_charstar;
-		mocStack[i+1].st = SmokeType(qt_Smoke,getSmokeIndex("char*"));
+		mocStack[i+1].st = SmokeType(qt_Smoke,qt_Smoke->idType("char*"));
 		signature->append("string");
 	    } else if (type == IS_OBJECT){
 		if(Z_OBJCE_P(((zval*) *argv[i])) == qstring_ce)



From tm243 at mail.berlios.de  Fri Mar 23 11:54:06 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Fri, 23 Mar 2007 11:54:06 +0100
Subject: [Php-qt-svn] r309 - in trunk: . php_qt
Message-ID: <200703231054.l2NAs6Ba025217@sheep.berlios.de>

Author: tm243
Date: 2007-03-23 11:54:06 +0100 (Fri, 23 Mar 2007)
New Revision: 309

Modified:
   trunk/ChangeLog
   trunk/php_qt/functions.cpp
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/marshall_types.h
   trunk/php_qt/smokephp.cpp
Log:
* call of virtual methods



Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2007-03-23 09:46:04 UTC (rev 308)
+++ trunk/ChangeLog	2007-03-23 10:54:06 UTC (rev 309)
@@ -1,5 +1,9 @@
 2007-003-22  Thomas Moenicke <thomas.moenicke at kdemail.net>
 
+		* call of virtual methods
+
+2007-003-22  Thomas Moenicke <thomas.moenicke at kdemail.net>
+
 		* call of overwritten protected methods
 
 2007-003-22  Thomas Moenicke <thomas.moenicke at kdemail.net>

Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-03-23 09:46:04 UTC (rev 308)
+++ trunk/php_qt/functions.cpp	2007-03-23 10:54:06 UTC (rev 309)
@@ -138,7 +138,7 @@
  *	tr() returns QObject::tr()
  *
  */
-
+extern zval* zstringFromQString(QString* s);
 PHP_FUNCTION(tr)
 {
     const char* string;

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-03-23 09:46:04 UTC (rev 308)
+++ trunk/php_qt/marshall_types.cpp	2007-03-23 10:54:06 UTC (rev 309)
@@ -359,8 +359,8 @@
 
 
 VirtualMethodCall::VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* obj, zval ***sp) :
-	MethodCallBase(smoke,meth,stack), _obj(obj)
-{		
+	MethodCallBase(smoke,meth,stack), _obj(obj), _sp(sp)
+{
 	_sp = sp;
 	_args = _smoke->argumentList + method().args;
 }
@@ -378,9 +378,12 @@
 zval*
 VirtualMethodCall::var() 
 { 
-	return (zval*) _sp[_cur]; 
+    if(*_sp[_cur] == NULL) {
+	MAKE_STD_ZVAL(*_sp[_cur]);
+    }
+    return (zval*) *_sp[_cur]; 
 }
-	
+
 int 
 VirtualMethodCall::items() 
 { 
@@ -393,8 +396,8 @@
 	if (_called) return;
 	_called = true;
 
-//	zval* _retval = callMethod(_obj, _smoke->methodNames[method().name],
-//		method().numArgs,	_sp );
+	phpqt_callMethod(_obj, (char*) _smoke->methodNames[method().name], method().numArgs, _sp);
+
 	zval _retval;
 	VirtualMethodReturnValue r(_smoke, _method, _stack, _retval);
 }

Modified: trunk/php_qt/marshall_types.h
===================================================================
--- trunk/php_qt/marshall_types.h	2007-03-23 09:46:04 UTC (rev 308)
+++ trunk/php_qt/marshall_types.h	2007-03-23 10:54:06 UTC (rev 309)
@@ -114,6 +114,7 @@
  
 private:
 	zval* _obj;
+	zval ***_sp;
 };
 
 

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-03-23 09:46:04 UTC (rev 308)
+++ trunk/php_qt/smokephp.cpp	2007-03-23 10:54:06 UTC (rev 309)
@@ -69,14 +69,11 @@
 		}
 
 		if(phpqt_methodExists(o->ce_ptr, (char*) methodName)){
-		    zval*** sp = (zval***) malloc(sizeof(zval)*2);
-		    zval* obj;
+		    Smoke::Method & meth = smoke->methods[method];
+		    zval*** sp = (zval ***) safe_emalloc((int) meth.numArgs, sizeof(zval **), 0);
 
-		    phpqt_callMethod(o->zval_ptr, (char*) methodName, 0, sp);
-/*
-		    VirtualMethodCall c(smoke, method, args, obj, sp);
+		    VirtualMethodCall c(smoke, method, args, o->zval_ptr, sp);
 		    c.next();
-*/
 		}
 		
 		return false;



From tm243 at mail.berlios.de  Mon Mar 26 11:09:30 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Mon, 26 Mar 2007 11:09:30 +0200
Subject: [Php-qt-svn] r310 - trunk/php_qt
Message-ID: <200703260909.l2Q99UWe025615@sheep.berlios.de>

Author: tm243
Date: 2007-03-26 11:09:29 +0200 (Mon, 26 Mar 2007)
New Revision: 310

Modified:
   trunk/php_qt/marshall_basetypes.h
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/smokephp.cpp
Log:
* code cleaned up



Modified: trunk/php_qt/marshall_basetypes.h
===================================================================
--- trunk/php_qt/marshall_basetypes.h	2007-03-23 10:54:06 UTC (rev 309)
+++ trunk/php_qt/marshall_basetypes.h	2007-03-26 09:09:29 UTC (rev 310)
@@ -172,11 +172,12 @@
 	    phpqt_register(obj, le);
 	    phpqt_setZvalPtr(o, obj);
 
-	    const char * classname = o->ce_ptr->name;
+
 //	    if(m->type().isConst() && m->type().isRef()) {
 	    if(m->type().isRef()) {
 		p = construct_copy( o );
 #ifdef DEBUG
+			const char * classname = o->ce_ptr->name;
 			php_error(E_WARNING, "copying %s %p to %p\n", classname, o->ptr, p);
 #endif
 

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-03-23 10:54:06 UTC (rev 309)
+++ trunk/php_qt/marshall_types.cpp	2007-03-26 09:09:29 UTC (rev 310)
@@ -367,6 +367,7 @@
 
 VirtualMethodCall::~VirtualMethodCall() 
 {
+//    delete[] _stack;
 }
 
 Marshall::Action 

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-03-23 10:54:06 UTC (rev 309)
+++ trunk/php_qt/php_qt.cpp	2007-03-26 09:09:29 UTC (rev 310)
@@ -36,7 +36,6 @@
 #define DEBUG 0
 #define MOC_DEBUG 0
 
-extern Smoke *qt_Smoke;
 extern void init_qt_Smoke();
 extern TypeHandler Qt_handlers[];
 void install_handlers(TypeHandler *);
@@ -84,16 +83,16 @@
 		zval_copy_ctor(&EX_T(opline->result.u.var).tmp_var);
 	} else {
 		// enums are methods here
-		Smoke::Index method = qt_Smoke->findMethod(ce->name, opline->op2.u.constant.value.str.val);
+		Smoke::Index method = PQ::smoke()->findMethod(ce->name, opline->op2.u.constant.value.str.val);
 		if(method <= 0) // smoke could not find one
 		    php_error(E_ERROR, "undefined class constant '%s'", opline->op2.u.constant.value.str.val);
 
-		method = qt_Smoke->methodMaps[method].method;
+		method = PQ::smoke()->methodMaps[method].method;
 
 		// get the Qt value
 		Smoke::Stack args = (Smoke::Stack) safe_emalloc(1, sizeof(Smoke::Stack), 0);
 		void* dummy; // dummy here
-		smokephp_callMethod(qt_Smoke, dummy, method, args);
+		smokephp_callMethod(dummy, method, args);
 
 		// write the zend return value
 		zval* return_value;
@@ -178,7 +177,7 @@
     zend_object *zobj = zend_objects_get_address(*obj_ptr TSRMLS_CC);
     if (zend_hash_find(&zobj->ce->function_table, lc_method_name, method_len+1, (void **)&fbc) != FAILURE) {
 	if(fbc->common.fn_flags & ZEND_ACC_PROTECTED){
-	    if(qt_Smoke->idMethodName(methodName) > 0){
+	    if(PQ::smoke()->idMethodName(methodName) > 0){
 		fbc->common.fn_flags = ZEND_ACC_PUBLIC;
 	    }
 	}
@@ -236,9 +235,14 @@
 ZEND_METHOD(php_qt_generic_class, __destruct)
 {
     if(phpqt_SmokePHPObjectExists(getThis())) {
-    smokephp_object *o = phpqt_getSmokePHPObjectFromZval(getThis());
-    phpqt_removeZvalPtr(o);
-    SmokeQtObjects.remove(o->ptr);
+	smokephp_object *o = phpqt_getSmokePHPObjectFromZval(getThis());
+	phpqt_removeZvalPtr(o);
+	SmokeQtObjects.remove(o->ptr);
+
+	efree(o->zval_ptr);
+//	((QObject*) o->ptr)->~QObject();
+//	delete o->ptr;	// segfault
+	efree(o);
     }
 	RETVAL_NULL();
 }
@@ -249,7 +253,7 @@
     zend_class_entry *ce = Z_OBJCE_P(getThis());
     zend_class_entry *ce_parent = Z_OBJCE_P(getThis());
 
-    while (qt_Smoke->idClass(ce->name) <= 0) {
+    while (PQ::smoke()->idClass(ce->name) <= 0) {
 	    ce_parent = ce->parent;
 	    ce = ce->parent; // orig
     }
@@ -264,15 +268,15 @@
 
     methodNameStack.push(new QString(ce->name));
     smokephp_prepareMethodName(args, argc, methodNameStack);
-    Smoke::Index method = smokephp_getMethod(qt_Smoke,ce->name, (methodNameStack.top())->toAscii(), ZEND_NUM_ARGS(), args);
-    MethodCall c(qt_Smoke, method, getThis(), args, argc-1, getThis());
+    Smoke::Index method = smokephp_getMethod(ce->name, (methodNameStack.top())->toAscii(), ZEND_NUM_ARGS(), args);
+    MethodCall c(PQ::smoke(), method, getThis(), args, argc-1, getThis());
     c.next();
 
     smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
     o->parent_ce_ptr = ce_parent; // = ce if no parent
 
 	// if QObject
-	if(smokephp_isQObject(qt_Smoke, qt_Smoke->idClass(ce->name))){
+	if(smokephp_isQObject(PQ::smoke()->idClass(ce->name))){
 
 		// fetch superdata
 		Smoke::Index nameId = o->smoke->idMethodName("metaObject");
@@ -334,7 +338,7 @@
     }
 
     // find parents
-    while (qt_Smoke->idClass(ce->name) <= 0) {
+    while (PQ::smoke()->idClass(ce->name) <= 0) {
 	    ce = ce->parent;
 	}
     // arguments
@@ -347,7 +351,7 @@
     }
 
     smokephp_prepareMethodName(args, argc, methodNameStack);
-    Smoke::Index method = smokephp_getMethod(qt_Smoke,ce->name, (methodNameStack.top())->toAscii(), argc, args);
+    Smoke::Index method = smokephp_getMethod(ce->name, (methodNameStack.top())->toAscii(), argc, args);
 
     if(method <= 0) {
 	if(methodNameStack.top()->toAscii().constData()) {
@@ -386,7 +390,7 @@
 	    php_error(E_ERROR,"Call to undefined method!");
     }
 
-    MethodCall c(qt_Smoke, method, getThis(), args, argc-1, return_value);
+    MethodCall c(PQ::smoke(), method, getThis(), args, argc-1, return_value);
     c.next();
 
     // cleanup
@@ -427,24 +431,24 @@
 
 	Smoke::Index qobject = smokephp_getClassId("QObject");
 
-	php_qt_static_methods = (zend_function_entry***) safe_emalloc((qt_Smoke->numClasses), sizeof(zend_function_entry **), 0);
+	php_qt_static_methods = (zend_function_entry***) safe_emalloc((PQ::smoke()->numClasses), sizeof(zend_function_entry **), 0);
 
 	int method_count;
 	// cache class entries
 	Smoke::Index i = 1;
 	QHash<const char*, zend_class_entry*> tmpCeTable;
 	// loop for all classes, register them
-	for(i = 1; i <= qt_Smoke->numClasses; i++){
+	for(i = 1; i <= PQ::smoke()->numClasses; i++){
 
         // statical methods, there is no method handler which can be overwritten
         // hope this will be better in future / see zend_std_get_static_method()
         method_count = 0;
-        for(int j=0;j<qt_Smoke->numMethods;j++){
-            if(qt_Smoke->methods[j].classId == i){
-                if(!(qt_Smoke->methods[j].flags & Smoke::mf_enum)){
-                    if((qt_Smoke->methods[j].flags & Smoke::mf_static)){
+        for(int j=0;j<PQ::smoke()->numMethods;j++){
+            if(PQ::smoke()->methods[j].classId == i){
+                if(!(PQ::smoke()->methods[j].flags & Smoke::mf_enum)){
+                    if((PQ::smoke()->methods[j].flags & Smoke::mf_static)){
                         // avoids overloaded methods
-                        if(strcmp(qt_Smoke->methodNames[qt_Smoke->methods[j-1].name],qt_Smoke->methodNames[qt_Smoke->methods[j].name])){
+                        if(strcmp(PQ::smoke()->methodNames[PQ::smoke()->methods[j-1].name],PQ::smoke()->methodNames[PQ::smoke()->methods[j].name])){
                             method_count++;
                         }
                     }
@@ -463,16 +467,16 @@
 
 	QHash<const char*, bool> tmpMethodList;	// avoids doubled method names
 
-        for(int j=0;j<qt_Smoke->numMethods;j++){
-            if(qt_Smoke->methods[j].classId == i){
-                if(!(qt_Smoke->methods[j].flags & Smoke::mf_enum)){
-                    if(qt_Smoke->methods[j].flags & Smoke::mf_static){
+        for(int j=0;j<PQ::smoke()->numMethods;j++){
+            if(PQ::smoke()->methods[j].classId == i){
+                if(!(PQ::smoke()->methods[j].flags & Smoke::mf_enum)){
+                    if(PQ::smoke()->methods[j].flags & Smoke::mf_static){
                         // avoids overloaded methods, fast
-                        if(strcmp(qt_Smoke->methodNames[qt_Smoke->methods[j-1].name],qt_Smoke->methodNames[qt_Smoke->methods[j].name])){
-                        	if(!tmpMethodList.contains(qt_Smoke->methodNames[qt_Smoke->methods[j].name])){ // method already defined in this class?
-								tmpMethodList[qt_Smoke->methodNames[qt_Smoke->methods[j].name]] = true;
-								t->fname = (char*) emalloc(strlen(qt_Smoke->methodNames[qt_Smoke->methods[j].name])+1);
-								t->fname = (char*) qt_Smoke->methodNames[qt_Smoke->methods[j].name];
+                        if(strcmp(PQ::smoke()->methodNames[PQ::smoke()->methods[j-1].name],PQ::smoke()->methodNames[PQ::smoke()->methods[j].name])){
+                        	if(!tmpMethodList.contains(PQ::smoke()->methodNames[PQ::smoke()->methods[j].name])){ // method already defined in this class?
+								tmpMethodList[PQ::smoke()->methodNames[PQ::smoke()->methods[j].name]] = true;
+								t->fname = (char*) emalloc(strlen(PQ::smoke()->methodNames[PQ::smoke()->methods[j].name])+1);
+								t->fname = (char*) PQ::smoke()->methodNames[PQ::smoke()->methods[j].name];
 								t->handler = ZEND_MN(php_qt_generic_class_proxyMethod);
 								t->arg_info = NULL;
 								t->flags = ZEND_ACC_PUBLIC|ZEND_ACC_STATIC;
@@ -493,10 +497,10 @@
 
 	// register zend class
 	zend_class_entry ce;
-	INIT_CLASS_ENTRY(ce, qt_Smoke->classes[i].className, p);
-	ce.name_length = strlen(qt_Smoke->classes[i].className);
+	INIT_CLASS_ENTRY(ce, PQ::smoke()->classes[i].className, p);
+	ce.name_length = strlen(PQ::smoke()->classes[i].className);
 	zend_class_entry* ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);
-	tmpCeTable[qt_Smoke->classes[i].className] = ce_ptr;
+	tmpCeTable[PQ::smoke()->classes[i].className] = ce_ptr;
 	// cache QObject
 	if(qobject == i){
 	    qobject_ce = ce_ptr;
@@ -504,13 +508,13 @@
 	} // end for
 
 	_register_QString();
-	tmpCeTable[qt_Smoke->classes[i].className] = qstring_ce;
+	tmpCeTable[PQ::smoke()->classes[i].className] = qstring_ce;
 
 	// do inheritance, all classes must be defined before
-	for(Smoke::Index i = 1; i <= qt_Smoke->numClasses; i++){
-	    zend_class_entry* ce = tmpCeTable[qt_Smoke->classes[i].className];
-	    for(Smoke::Index *p = qt_Smoke->inheritanceList + qt_Smoke->classes[i].parents; *p; p++) {
-		zend_class_entry *parent_ce = tmpCeTable[qt_Smoke->classes[*p].className];
+	for(Smoke::Index i = 1; i <= PQ::smoke()->numClasses; i++){
+	    zend_class_entry* ce = tmpCeTable[PQ::smoke()->classes[i].className];
+	    for(Smoke::Index *p = PQ::smoke()->inheritanceList + PQ::smoke()->classes[i].parents; *p; p++) {
+		zend_class_entry *parent_ce = tmpCeTable[PQ::smoke()->classes[*p].className];
     		zend_do_inheritance(ce, parent_ce TSRMLS_CC);
 	    }
 	}
@@ -592,7 +596,7 @@
 			(*fn)(m.method, so->ptr, i);
 
 #if MOC_DEBUG
-			cout << "\tcall Qt method " << so->ce_ptr->name << "::" << qt_Smoke->methodNames[method] << endl;
+			cout << "\tcall Qt method " << so->ce_ptr->name << "::" << PQ::smoke()->methodNames[method] << endl;
 #endif
 
 			if((int)i[0].s_int < 0)
@@ -719,6 +723,7 @@
 		return true;
 	}
 
+	efree(lcname);
 	return false;
 
 }
@@ -994,7 +999,7 @@
 	o->ce_ptr = ce;
 	o->parent_ce_ptr = ce;
 	o->classId = classId;
-	o->smoke = qt_Smoke;
+	o->smoke = PQ::smoke();
 	phpqt_setSmokePHPObject(o);
 	// register all 
 	zend_rsrc_list_entry le;

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-03-23 10:54:06 UTC (rev 309)
+++ trunk/php_qt/php_qt.h	2007-03-26 09:09:29 UTC (rev 310)
@@ -135,17 +135,29 @@
 bool				phpqt_SmokePHPObjectExists(void* ptr);
 void				phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL, Smoke::Index classId = 0);
 
+extern Smoke* qt_Smoke;
+class PQ
+{
+private:
+    PQ();
+    PQ(const PQ& cc){}
+
+public:
+    ~PQ();
+    static inline Smoke* smoke() { return qt_Smoke; }
+};
+
 extern int le_php_qt_hashtype;
 extern HashTable php_qt_objptr_hash;
 
 void 				smokephp_convertArgsCxxToZend(zval*** args, int argc, Smoke::StackItem* qargs);
-bool 				smokephp_isQObject(Smoke *smoke, Smoke::Index classId);
+bool 				smokephp_isQObject(Smoke::Index classId);
 Smoke::Index 			smokephp_getClassId(const char* classname);
 void				smokephp_prepareMethodName(zval*** args, int argc, QStack<QString*> &methodNameStack);
 QByteArray* 			smokephp_getSignature(int argc, zval ***argv, MocArgument* mocStack);
-Smoke::Index			smokephp_getMethod(Smoke *smoke, const char* c, const char* m, int argc, zval*** args);
+Smoke::Index			smokephp_getMethod(const char* c, const char* m, int argc, zval*** args);
 void				smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method);
-void				smokephp_callMethod(Smoke *smoke, void *obj, Smoke::Index method, Smoke::Stack qargs);
+void				smokephp_callMethod(void *obj, Smoke::Index method, Smoke::Stack qargs);
 void				smokephp_init();
 Smoke::Index			smokephp_findConnect();
 bool				smokephp_isConnect(Smoke::Index method);

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-03-23 10:54:06 UTC (rev 309)
+++ trunk/php_qt/smokephp.cpp	2007-03-26 09:09:29 UTC (rev 310)
@@ -28,7 +28,6 @@
 #include <QtCore/QCoreApplication>
 #include <QtGui/QApplication>
 
-extern Smoke *qt_Smoke;
 extern void init_qt_Smoke();
 extern zend_class_entry* qstring_ce;
 
@@ -55,7 +54,7 @@
 			return false;
 		}
 
-		const char *methodName = qt_Smoke->methodNames[smoke->methods[method].name];
+		const char *methodName = smoke->methodNames[smoke->methods[method].name];
 
 		// metaobjects
 		if(!strcmp(methodName, "metaObject")){
@@ -73,7 +72,7 @@
 		    zval*** sp = (zval ***) safe_emalloc((int) meth.numArgs, sizeof(zval **), 0);
 
 		    VirtualMethodCall c(smoke, method, args, o->zval_ptr, sp);
-		    c.next();
+//		    c.next();
 		}
 		
 		return false;
@@ -108,11 +107,11 @@
 */
     init_qt_Smoke();
 
-    if(qt_Smoke->numClasses <= 0){
+    if(PQ::smoke()->numClasses <= 0){
 	php_error(E_ERROR,"could not initialize smoke (no class definitions)");
     }
 
-    qt_Smoke->binding = new PHPQtSmokeBinding(qt_Smoke);
+    PQ::smoke()->binding = new PHPQtSmokeBinding(PQ::smoke());
 
 }
 
@@ -122,23 +121,23 @@
  *  @return Smoke::Index        unambiguous method ID
  */
 Smoke::Index 
-smokephp_getMethod(Smoke *smoke, const char* c, const char* m, int argc, zval*** args) {
+smokephp_getMethod(const char* c, const char* m, int argc, zval*** args) {
 
-    Smoke::Index method = smoke->findMethod(c, m);	// qt_Smoke->methods
-    Smoke::Index i = smoke->methodMaps[method].method;
+    Smoke::Index method = PQ::smoke()->findMethod(c, m);	// qt_Smoke->methods
+    Smoke::Index i = PQ::smoke()->methodMaps[method].method;
 
     if(i <= 0) {
 	    i = -i;		// turn into ambiguousMethodList index
-	    while(qt_Smoke->ambiguousMethodList[i]) {
+	    while(PQ::smoke()->ambiguousMethodList[i]) {
 
-	    	Smoke::Method &methodRef = qt_Smoke->methods[qt_Smoke->ambiguousMethodList[i]];
+	    	Smoke::Method &methodRef = PQ::smoke()->methods[PQ::smoke()->ambiguousMethodList[i]];
 
 			if ((methodRef.flags & Smoke::mf_internal) == 0) {
 				// try to compare smoke types with the php ones
 				bool right = false;
 				for(int k=0;k < argc;k++){
 					uint type = ((int) ((zval) **args[k]).type);
-					switch((qt_Smoke->types[qt_Smoke->argumentList[qt_Smoke->methods[qt_Smoke->ambiguousMethodList[i]].args+k]].flags & Smoke::tf_elem)){
+					switch((PQ::smoke()->types[PQ::smoke()->argumentList[PQ::smoke()->methods[PQ::smoke()->ambiguousMethodList[i]].args+k]].flags & Smoke::tf_elem)){
 						case Smoke::t_voidp:
 							if(type == IS_ARRAY)
 								right = true;
@@ -172,10 +171,10 @@
 							if(type == IS_OBJECT){
 							    QByteArray* name = 
 							    new QByteArray(
-								qt_Smoke->types[
-								    qt_Smoke->argumentList[
-									qt_Smoke->methods[
-									    qt_Smoke->ambiguousMethodList[i]].args+k]].name);
+								PQ::smoke()->types[
+								    PQ::smoke()->argumentList[
+									PQ::smoke()->methods[
+									    PQ::smoke()->ambiguousMethodList[i]].args+k]].name);
 							    if(name->contains(Z_OBJCE_P((zval*) *args[k])->name))
 								right = true;
 							}
@@ -187,9 +186,9 @@
 				}
 				if(right){
 #ifdef DEBUG
-					php_error(E_NOTICE, "Ambiguous Method %s::%s => %d, %d", c, m, qt_Smoke->ambiguousMethodList[i], i);
+					php_error(E_NOTICE, "Ambiguous Method %s::%s => %d, %d", c, m, PQ::smoke()->ambiguousMethodList[i], i);
 #endif
-					return qt_Smoke->ambiguousMethodList[i];
+					return PQ::smoke()->ambiguousMethodList[i];
 				}
 			}
 			
@@ -207,46 +206,13 @@
  *  @return void
  */
 void
-smokephp_callMethod(Smoke *smoke, void *obj, Smoke::Index method, Smoke::Stack qargs) {
-    Smoke::Method *m = smoke->methods + method;
-    Smoke::ClassFn fn = smoke->classes[m->classId].classFn;
+smokephp_callMethod(void *obj, Smoke::Index method, Smoke::Stack qargs) {
+    Smoke::Method *m = PQ::smoke()->methods + method;
+    Smoke::ClassFn fn = PQ::smoke()->classes[m->classId].classFn;
     fn(m->method, obj, qargs);
 }
 
 /*!
- * cast argument pointer to the correct type for the specified method argument
- * args[i].s_class = (void*)(typeof(args[i]))(className*)obj
- *
- *  @param  Smoke::Index        method
- *  @param  Smoke::Stack        qargs
- *  @param  Smoke::Index        i
- *  @param  void*               obj
- *  @param  const char*         className
- */
-void 
-smokephp_smokeCast(Smoke *smoke, Smoke::Index method, Smoke::Stack qargs, Smoke::Index i, void *obj, const char *className) {
-    // cast obj from className to the desired type of args[i]
-    Smoke::Index arg = smoke->argumentList[
-        smoke->methods[method].args + i - 1
-    ];
-    // cast(obj, from_type, to_type)
-    qargs[i].s_class = smoke->cast(obj, smoke->idClass(className), smoke->types[arg].classId);
-}
-
-/*!
- *  cast obj to the required type of this, which, dur to multiple-inheritance, could change the pointer-address
- *  from the one returned by new. Puts the pointer in args[0].s_class, even though smoke doesn't do it that way
- *
- *  @param  Smoke::Index        method
- *  @param  Smoke::Stack        qargs
- *  @param  const char*         className
- */
-void 
-smokephp_smokeCastThis(Smoke *smoke, Smoke::Index method, Smoke::Stack qargs, void *obj, const char *className) {
-    qargs[0].s_class = smoke->cast(obj, smoke->idClass(className), smoke->methods[method].classId);
-}
-
-/*!
  *  The munging works this way:
  *  $ is a plain scalar
  *  # is an object
@@ -392,33 +358,33 @@
     QByteArray *signature = new QByteArray("(");// = new QByteArray();
     for(int i=0;i<argc;i++){
 	    uint type = ((int) ((zval) **argv[i]).type);
-	    mocStack[i+1].st = SmokeType(qt_Smoke,0);
+	    mocStack[i+1].st = SmokeType(PQ::smoke(),0);
 	    if (type == IS_RESOURCE){ // TODO
 	    } else if (type == IS_ARRAY){
 		//    xmoc_ptr,
 		php_error(E_WARNING, "Array given as signal argument");
 	    } else if (type == IS_BOOL){
 		mocStack[i+1].argType = xmoc_bool;
-		mocStack[i+1].st = SmokeType(qt_Smoke,qt_Smoke->idType("bool"));
+		mocStack[i+1].st = SmokeType(PQ::smoke(),PQ::smoke()->idType("bool"));
 		signature->append("bool");
 	    } else if (type == IS_LONG){
 		mocStack[i+1].argType = xmoc_int;
-		mocStack[i+1].st = SmokeType(qt_Smoke,qt_Smoke->idType("int"));
+		mocStack[i+1].st = SmokeType(PQ::smoke(),PQ::smoke()->idType("int"));
 		signature->append("int");
 	    } else if (type == IS_DOUBLE){
 		mocStack[i+1].argType = xmoc_double;
-		mocStack[i+1].st = SmokeType(qt_Smoke,qt_Smoke->idType("double"));
+		mocStack[i+1].st = SmokeType(PQ::smoke(),PQ::smoke()->idType("double"));
 		signature->append("double");
 	    } else if (type == IS_STRING){
 		mocStack[i+1].argType = xmoc_charstar;
-		mocStack[i+1].st = SmokeType(qt_Smoke,qt_Smoke->idType("char*"));
+		mocStack[i+1].st = SmokeType(PQ::smoke(),PQ::smoke()->idType("char*"));
 		signature->append("string");
 	    } else if (type == IS_OBJECT){
 		if(Z_OBJCE_P(((zval*) *argv[i])) == qstring_ce)
 		    mocStack[i+1].argType = xmoc_QString;
 		else {
 		    smokephp_object *o = phpqt_getSmokePHPObjectFromZval((zval*) *argv[i]);
-		    mocStack[i+1].st = SmokeType(qt_Smoke,o->classId);
+		    mocStack[i+1].st = SmokeType(PQ::smoke(),o->classId);
 		    mocStack[i+1].argType = xmoc_void;
 		}
 		signature->append("object");
@@ -454,21 +420,21 @@
 smokephp_findConnect(){
 
 	for(int i=0;i<10000;i++){
-		if(qt_Smoke->methodMaps[i].name == qt_Smoke->idMethodName("connect#$#$")){
-			connect1 = qt_Smoke->methodMaps[i].method;
+		if(PQ::smoke()->methodMaps[i].name == PQ::smoke()->idMethodName("connect#$#$")){
+			connect1 = PQ::smoke()->methodMaps[i].method;
 		}
-		if(qt_Smoke->methodMaps[i].name == qt_Smoke->idMethodName("connect#$#$$")){
-			connect2 = qt_Smoke->methodMaps[i].method;
+		if(PQ::smoke()->methodMaps[i].name == PQ::smoke()->idMethodName("connect#$#$$")){
+			connect2 = PQ::smoke()->methodMaps[i].method;
 		}
-		if(qt_Smoke->methodMaps[i].name == qt_Smoke->idMethodName("connect")){
-			connect3 = qt_Smoke->methodMaps[i].method;
+		if(PQ::smoke()->methodMaps[i].name == PQ::smoke()->idMethodName("connect")){
+			connect3 = PQ::smoke()->methodMaps[i].method;
 		}
 		// these are ambiguous methods
-		if(qt_Smoke->methodMaps[i].name == qt_Smoke->idMethodName("connect#$$")){
-			connect4 = qt_Smoke->methodMaps[i].method;
+		if(PQ::smoke()->methodMaps[i].name == PQ::smoke()->idMethodName("connect#$$")){
+			connect4 = PQ::smoke()->methodMaps[i].method;
 		}
-		if(qt_Smoke->methodMaps[i].name == qt_Smoke->idMethodName("connect#$$$")){
-			connect5 = qt_Smoke->methodMaps[i].method;
+		if(PQ::smoke()->methodMaps[i].name == PQ::smoke()->idMethodName("connect#$$$")){
+			connect5 = PQ::smoke()->methodMaps[i].method;
 		}
 	}
 }
@@ -484,8 +450,8 @@
 smokephp_getClassId(const char* classname){
 
 	Smoke::Index classId = 0;
-	Smoke::Class *p = qt_Smoke->classes;
-	while(p++ != qt_Smoke->classes+qt_Smoke->numClasses){
+	Smoke::Class *p = PQ::smoke()->classes;
+	while(p++ != PQ::smoke()->classes+PQ::smoke()->numClasses){
 		classId++;
 		if(!strcmp(p->className,classname)){
 			return classId;
@@ -498,12 +464,12 @@
 }
 
 bool 
-smokephp_isQObject(Smoke *smoke, Smoke::Index classId) {
-	if(strcmp(smoke->classes[classId].className, "QObject") == 0)
+smokephp_isQObject(Smoke::Index classId) {
+	if(strcmp(PQ::smoke()->classes[classId].className, "QObject") == 0)
 		return true;
 	
-	for(Smoke::Index *p = smoke->inheritanceList + smoke->classes[classId].parents;	*p;	p++) {
-		if(smokephp_isQObject(smoke, *p))
+	for(Smoke::Index *p = PQ::smoke()->inheritanceList + PQ::smoke()->classes[classId].parents;	*p;	p++) {
+		if(smokephp_isQObject(*p))
 			return true;
     }
     return false;



From tm243 at mail.berlios.de  Mon Mar 26 11:30:46 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Mon, 26 Mar 2007 11:30:46 +0200
Subject: [Php-qt-svn] r311 - trunk/php_qt
Message-ID: <200703260930.l2Q9UkLo027247@sheep.berlios.de>

Author: tm243
Date: 2007-03-26 11:30:46 +0200 (Mon, 26 Mar 2007)
New Revision: 311

Modified:
   trunk/php_qt/functions.cpp
   trunk/php_qt/marshall_basetypes.h
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/smokephp.cpp
Log:
* code cleaned up



Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-03-26 09:09:29 UTC (rev 310)
+++ trunk/php_qt/functions.cpp	2007-03-26 09:30:46 UTC (rev 311)
@@ -159,7 +159,6 @@
 	le.ptr = o;
 	phpqt_register(return_value, le);
 	phpqt_setSmokePHPObject(o);
-	phpqt_setZvalPtr(o, o->zval_ptr);
     return;
 }
 

Modified: trunk/php_qt/marshall_basetypes.h
===================================================================
--- trunk/php_qt/marshall_basetypes.h	2007-03-26 09:09:29 UTC (rev 310)
+++ trunk/php_qt/marshall_basetypes.h	2007-03-26 09:30:46 UTC (rev 311)
@@ -170,9 +170,7 @@
 	    zend_rsrc_list_entry le;
 	    le.ptr = o;
 	    phpqt_register(obj, le);
-	    phpqt_setZvalPtr(o, obj);
 
-
 //	    if(m->type().isConst() && m->type().isRef()) {
 	    if(m->type().isRef()) {
 		p = construct_copy( o );

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-03-26 09:09:29 UTC (rev 310)
+++ trunk/php_qt/php_qt.cpp	2007-03-26 09:30:46 UTC (rev 311)
@@ -20,8 +20,6 @@
  *
  */
 
-// TODO		references
-
 #include <zend_interfaces.h>
 #include "php_qt.h"
 #include "ext/standard/php_string.h"
@@ -40,7 +38,6 @@
 extern TypeHandler Qt_handlers[];
 void install_handlers(TypeHandler *);
 
-/* True global resources - no need for thread safety here */
 static int le_php_qt;
 
 // object list
@@ -58,6 +55,61 @@
 static opcode_handler_t *phpqt_original_opcode_handlers;
 static opcode_handler_t phpqt_opcode_handlers[PHPQT_OPHANDLER_COUNT];
 
+
+/*! php_qt_functions[]
+ *
+ * Every user visible function must have an entry in php_qt_functions[].
+ */
+#undef emit
+function_entry php_qt_functions[] = {
+	PHP_FE(confirm_php_qt_compiled,	NULL)		/* For testing, remove later. */
+	PHP_FE(SIGNAL,	NULL)
+	PHP_FE(SLOT,	NULL)	
+	PHP_FE(emit,	NULL)	
+	PHP_FE(qobject_cast,	NULL)
+	PHP_FE(tr,	NULL)
+	PHP_FE(check_qobject,	NULL)
+	{NULL, NULL, NULL}	/* Must be the last line in php_qt_functions[] */
+};
+
+/*! php_qt_module_entry
+ */
+zend_module_entry php_qt_module_entry = {
+#if ZEND_MODULE_API_NO >= 20010901
+	STANDARD_MODULE_HEADER,
+#endif
+	"php_qt",
+	php_qt_functions,
+	PHP_MINIT(php_qt),
+	PHP_MSHUTDOWN(php_qt),
+	PHP_RINIT(php_qt),		/* Replace with NULL if there's nothing to do at request start */
+	PHP_RSHUTDOWN(php_qt),	/* Replace with NULL if there's nothing to do at request end */
+	PHP_MINFO(php_qt),
+#if ZEND_MODULE_API_NO >= 20010901
+	PHPQT_VERSION,
+#endif
+	STANDARD_MODULE_PROPERTIES
+};
+
+#ifdef COMPILE_DL_PHP_QT
+ZEND_GET_MODULE(php_qt)
+#endif
+
+QHash<void*, smokephp_object*> SmokeQtObjects;
+QStack<QByteArray*> methodNameStack;
+
+// cached
+Smoke::Index qbool;
+Smoke::Index qstring;
+Smoke::Index qobject;
+zend_class_entry* qobject_ce;
+extern zend_class_entry* qstring_ce;
+extern void 	_register_QString();
+
+/*
+ *	constants handler
+ */
+
 static int constantHandler(ZEND_OPCODE_HANDLER_ARGS) {
 
 	zend_op *opline = EX__(opline);
@@ -110,57 +162,7 @@
 
 }
 
-/*! php_qt_functions[]
- *
- * Every user visible function must have an entry in php_qt_functions[].
- */
-#undef emit
-function_entry php_qt_functions[] = {
-	PHP_FE(confirm_php_qt_compiled,	NULL)		/* For testing, remove later. */
-	PHP_FE(SIGNAL,	NULL)
-	PHP_FE(SLOT,	NULL)	
-	PHP_FE(emit,	NULL)	
-	PHP_FE(qobject_cast,	NULL)
-	PHP_FE(tr,	NULL)
-	PHP_FE(check_qobject,	NULL)
-	{NULL, NULL, NULL}	/* Must be the last line in php_qt_functions[] */
-};
 
-/*! php_qt_module_entry
- */
-zend_module_entry php_qt_module_entry = {
-#if ZEND_MODULE_API_NO >= 20010901
-	STANDARD_MODULE_HEADER,
-#endif
-	"php_qt",
-	php_qt_functions,
-	PHP_MINIT(php_qt),
-	PHP_MSHUTDOWN(php_qt),
-	PHP_RINIT(php_qt),		/* Replace with NULL if there's nothing to do at request start */
-	PHP_RSHUTDOWN(php_qt),	/* Replace with NULL if there's nothing to do at request end */
-	PHP_MINFO(php_qt),
-#if ZEND_MODULE_API_NO >= 20010901
-	"0.0.4", /* Replace with version number for your extension */
-#endif
-	STANDARD_MODULE_PROPERTIES
-};
-
-#ifdef COMPILE_DL_PHP_QT
-ZEND_GET_MODULE(php_qt)
-#endif
-
-static QHash<smokephp_object*, zval*> smoke_x_zval;
-QHash<void*, smokephp_object*> SmokeQtObjects;
-QStack<QString*> methodNameStack;
-
-// cached
-Smoke::Index qbool;
-Smoke::Index qstring;
-Smoke::Index qobject;
-zend_class_entry* qobject_ce;
-extern zend_class_entry* qstring_ce;
-extern void 	_register_QString();
-
 /**
  *	proxy handler
  */
@@ -187,7 +189,7 @@
     fbc = zend_orig_handler.get_method(obj_ptr, methodName, methodName_len);
 
     if(!fbc) {    // maybe a Qt object
-        methodNameStack.push(new QString(methodName));
+        methodNameStack.push(new QByteArray(methodName));
 	    // call proxy
 	    fbc = zend_orig_handler.get_method(obj_ptr, "proxyMethod", 11);
     }
@@ -236,7 +238,6 @@
 {
     if(phpqt_SmokePHPObjectExists(getThis())) {
 	smokephp_object *o = phpqt_getSmokePHPObjectFromZval(getThis());
-	phpqt_removeZvalPtr(o);
 	SmokeQtObjects.remove(o->ptr);
 
 	efree(o->zval_ptr);
@@ -266,9 +267,9 @@
 	    WRONG_PARAM_COUNT;
     }
 
-    methodNameStack.push(new QString(ce->name));
-    smokephp_prepareMethodName(args, argc, methodNameStack);
-    Smoke::Index method = smokephp_getMethod(ce->name, (methodNameStack.top())->toAscii(), ZEND_NUM_ARGS(), args);
+    methodNameStack.push(new QByteArray(ce->name));
+    smokephp_prepareMethodName(args, argc, methodNameStack);	// #, $, ?
+    Smoke::Index method = smokephp_getMethod(ce->name, methodNameStack.top()->constData(), ZEND_NUM_ARGS(), args);
     MethodCall c(PQ::smoke(), method, getThis(), args, argc-1, getThis());
     c.next();
 
@@ -334,7 +335,7 @@
         char* class_name = get_active_class_name(&space);
         char* method_name = get_active_function_name();
         ce = zend_fetch_class(class_name,strlen(class_name), ZEND_FETCH_CLASS_AUTO TSRMLS_DC);
-        methodNameStack.push(new QString(method_name));
+        methodNameStack.push(new QByteArray(method_name));
     }
 
     // find parents
@@ -351,17 +352,17 @@
     }
 
     smokephp_prepareMethodName(args, argc, methodNameStack);
-    Smoke::Index method = smokephp_getMethod(ce->name, (methodNameStack.top())->toAscii(), argc, args);
+    Smoke::Index method = smokephp_getMethod(ce->name, methodNameStack.top()->constData(), argc, args);
 
     if(method <= 0) {
-	if(methodNameStack.top()->toAscii().constData()) {
+	if(methodNameStack.top()->constData()) {
 
 	    // is it a signal?
 	    if(getThis()){
 		smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
 		if(o->meta != NULL){
 		    QMetaObject* mo = (QMetaObject*) o->meta;
-		    QByteArray signalname(methodNameStack.top()->toAscii().constData());
+		    QByteArray signalname(methodNameStack.top()->constData());
 		    signalname.replace("$","");
 		    signalname.replace("#","");
 		    signalname.replace("?","");
@@ -384,7 +385,7 @@
 		}
 	    }
 
-	    php_error(E_ERROR,"Call to undefined method %s::%s()", ce->name, methodNameStack.top()->toAscii().constData());
+	    php_error(E_ERROR,"Call to undefined method %s::%s()", ce->name, methodNameStack.top()->constData());
 	}
 	else 
 	    php_error(E_ERROR,"Call to undefined method!");
@@ -878,38 +879,6 @@
   	}
 }
 
-/*!
- *	fetchs the zval-ptr from hashtable
- *	@param	QObject*
- *	@return	zval*
- */
-
-
-void
-phpqt_setZvalPtr(smokephp_object *o, zval* z) {
-	smoke_x_zval.insert(o,z);
-}
-
-void
-phpqt_removeZvalPtr(smokephp_object *o) {
-	smoke_x_zval.remove(o);
-}
-
-zval* 
-phpqt_fetchZvalPtr(smokephp_object *o){
-	return smoke_x_zval.value(o);
-}
-
-bool
-phpqt_ZvalPtrExists(smokephp_object *o){
-	return (smoke_x_zval.find(o) != smoke_x_zval.end());
-}
-
-/**
- *	maps method names to the related names of operator-extension
- *	@param	const char*		fname		function name
- */
-
 char*
 phpqt_checkForOperator(const char* fname){
 	return (char*) fname;
@@ -1006,6 +975,5 @@
 	le.ptr = o;
 	object_init_ex(zval_ptr, ce);
 	phpqt_register(o->zval_ptr,le);
-	phpqt_setZvalPtr(o, o->zval_ptr);
 
 }

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-03-26 09:09:29 UTC (rev 310)
+++ trunk/php_qt/php_qt.h	2007-03-26 09:30:46 UTC (rev 311)
@@ -23,6 +23,8 @@
 #ifndef QTPHP_H
 #define QTPHP_H
 
+#define PHPQT_VERSION "0.0.4"
+
 #define MONITOR
 
 #define COMPILE_DL_PHP_QT
@@ -122,11 +124,6 @@
 int				phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
 char*				phpqt_checkForOperator(const char* fname);
 
-void 				phpqt_setZvalPtr(smokephp_object *o, zval* z);
-void 				phpqt_removeZvalPtr(smokephp_object *o);
-zval* 				phpqt_fetchZvalPtr(smokephp_object *o);
-bool				phpqt_ZvalPtrExists(smokephp_object *o);
-
 void* 				phpqt_getQtObjectFromZval(zval* this_ptr);
 smokephp_object* 		phpqt_getSmokePHPObjectFromZval(zval* this_ptr);
 smokephp_object*		phpqt_getSmokePHPObjectFromQt(void* QtPtr);
@@ -153,7 +150,7 @@
 void 				smokephp_convertArgsCxxToZend(zval*** args, int argc, Smoke::StackItem* qargs);
 bool 				smokephp_isQObject(Smoke::Index classId);
 Smoke::Index 			smokephp_getClassId(const char* classname);
-void				smokephp_prepareMethodName(zval*** args, int argc, QStack<QString*> &methodNameStack);
+void				smokephp_prepareMethodName(zval*** args, int argc, QStack<QByteArray*> &methodNameStack);
 QByteArray* 			smokephp_getSignature(int argc, zval ***argv, MocArgument* mocStack);
 Smoke::Index			smokephp_getMethod(const char* c, const char* m, int argc, zval*** args);
 void				smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method);

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-03-26 09:09:29 UTC (rev 310)
+++ trunk/php_qt/smokephp.cpp	2007-03-26 09:30:46 UTC (rev 311)
@@ -73,6 +73,7 @@
 
 		    VirtualMethodCall c(smoke, method, args, o->zval_ptr, sp);
 //		    c.next();
+		    efree(sp);
 		}
 		
 		return false;
@@ -321,7 +322,7 @@
 
 }
 
-void smokephp_prepareMethodName(zval*** args, int argc, QStack<QString*> &methodNameStack){
+void smokephp_prepareMethodName(zval*** args, int argc, QStack<QByteArray*> &methodNameStack){
 
     for(int i=0;i<argc;i++){
 	    uint type = ((int) ((zval) **args[i]).type);



From tm243 at mail.berlios.de  Mon Mar 26 11:44:14 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Mon, 26 Mar 2007 11:44:14 +0200
Subject: [Php-qt-svn] r312 - trunk/php_qt
Message-ID: <200703260944.l2Q9iE45028405@sheep.berlios.de>

Author: tm243
Date: 2007-03-26 11:44:13 +0200 (Mon, 26 Mar 2007)
New Revision: 312

Modified:
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/smokephp.cpp
Log:
* code cleaned up



Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-03-26 09:30:46 UTC (rev 311)
+++ trunk/php_qt/marshall_types.cpp	2007-03-26 09:44:13 UTC (rev 312)
@@ -397,7 +397,7 @@
 	if (_called) return;
 	_called = true;
 
-	phpqt_callMethod(_obj, (char*) _smoke->methodNames[method().name], method().numArgs, _sp);
+	phpqt_callPHPMethod(_obj, (char*) _smoke->methodNames[method().name], method().numArgs, _sp);
 
 	zval _retval;
 	VirtualMethodReturnValue r(_smoke, _method, _stack, _retval);

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-03-26 09:30:46 UTC (rev 311)
+++ trunk/php_qt/php_qt.cpp	2007-03-26 09:44:13 UTC (rev 312)
@@ -427,11 +427,8 @@
 
 	smokephp_init();
 
-// TODO		QObject Nummer suchen, nachher vergleichen
-	smokephp_findConnect();
+	Smoke::Index qobject = PQ::smoke()->idClass("QObject");
 
-	Smoke::Index qobject = smokephp_getClassId("QObject");
-
 	php_qt_static_methods = (zend_function_entry***) safe_emalloc((PQ::smoke()->numClasses), sizeof(zend_function_entry **), 0);
 
 	int method_count;
@@ -665,7 +662,7 @@
     cout << "\tcall PHP method " << so->ce_ptr->name << "::" << method_name << endl;
 #endif
 
-        phpqt_callMethod(so->zval_ptr, method_name, j, args);
+        phpqt_callPHPMethod(so->zval_ptr, method_name, j, args);
 
     // is a signal
     } else {
@@ -730,7 +727,7 @@
 }
 
 zval* 
-phpqt_callMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args[])
+phpqt_callPHPMethod(zval* this_ptr, char* methodName, zend_uint param_count, zval** args[])
 {
 
 	if(this_ptr == NULL){

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-03-26 09:30:46 UTC (rev 311)
+++ trunk/php_qt/php_qt.h	2007-03-26 09:44:13 UTC (rev 312)
@@ -101,6 +101,7 @@
 PHP_FUNCTION(qobject_cast);
 PHP_FUNCTION(tr);
 PHP_FUNCTION(check_qobject);
+void check_object(zval* zobject);
 
 struct smokephp_object {
     bool allocated;
@@ -113,12 +114,11 @@
     QMetaObject* meta;
 };
 
-//zend_class_entry* php_qt_generic_class;
-void check_object(zval* zobject);
-static void 		phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc);
 
+static void 			phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc);
+
 void 				phpqt_register(zval* this_ptr, zend_rsrc_list_entry le);
-zval* 				phpqt_callMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params[]);
+zval* 				phpqt_callPHPMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params[]);
 bool 				phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname);
 bool 				phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* metachar, QString* meta_stringdata, uint* signature);
 int				phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
@@ -147,17 +147,13 @@
 extern int le_php_qt_hashtype;
 extern HashTable php_qt_objptr_hash;
 
-void 				smokephp_convertArgsCxxToZend(zval*** args, int argc, Smoke::StackItem* qargs);
 bool 				smokephp_isQObject(Smoke::Index classId);
-Smoke::Index 			smokephp_getClassId(const char* classname);
 void				smokephp_prepareMethodName(zval*** args, int argc, QStack<QByteArray*> &methodNameStack);
 QByteArray* 			smokephp_getSignature(int argc, zval ***argv, MocArgument* mocStack);
 Smoke::Index			smokephp_getMethod(const char* c, const char* m, int argc, zval*** args);
 void				smokephp_prepareConnect(zval*** args, int argc, Smoke::StackItem* qargs, const Smoke::Index method);
 void				smokephp_callMethod(void *obj, Smoke::Index method, Smoke::Stack qargs);
 void				smokephp_init();
-Smoke::Index			smokephp_findConnect();
-bool				smokephp_isConnect(Smoke::Index method);
 
 void* 				transformArray(zval* args);
 

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-03-26 09:30:46 UTC (rev 311)
+++ trunk/php_qt/smokephp.cpp	2007-03-26 09:44:13 UTC (rev 312)
@@ -102,10 +102,10 @@
 void 
 smokephp_init() {
 
-/*    if (qt_Smoke != 0L) {
+    if (qt_Smoke != 0L) {
 	php_error(E_ERROR,"could not initialize smoke");
     }
-*/
+
     init_qt_Smoke();
 
     if(PQ::smoke()->numClasses <= 0){
@@ -417,53 +417,6 @@
 
 }
 
-Smoke::Index
-smokephp_findConnect(){
-
-	for(int i=0;i<10000;i++){
-		if(PQ::smoke()->methodMaps[i].name == PQ::smoke()->idMethodName("connect#$#$")){
-			connect1 = PQ::smoke()->methodMaps[i].method;
-		}
-		if(PQ::smoke()->methodMaps[i].name == PQ::smoke()->idMethodName("connect#$#$$")){
-			connect2 = PQ::smoke()->methodMaps[i].method;
-		}
-		if(PQ::smoke()->methodMaps[i].name == PQ::smoke()->idMethodName("connect")){
-			connect3 = PQ::smoke()->methodMaps[i].method;
-		}
-		// these are ambiguous methods
-		if(PQ::smoke()->methodMaps[i].name == PQ::smoke()->idMethodName("connect#$$")){
-			connect4 = PQ::smoke()->methodMaps[i].method;
-		}
-		if(PQ::smoke()->methodMaps[i].name == PQ::smoke()->idMethodName("connect#$$$")){
-			connect5 = PQ::smoke()->methodMaps[i].method;
-		}
-	}
-}
-
-/**
- *	returns the related classId
- *	@todo	caching, SmokeType
- *	@param	char*	classname
- *	@return Smoke::Index
- */
-
-Smoke::Index 
-smokephp_getClassId(const char* classname){
-
-	Smoke::Index classId = 0;
-	Smoke::Class *p = PQ::smoke()->classes;
-	while(p++ != PQ::smoke()->classes+PQ::smoke()->numClasses){
-		classId++;
-		if(!strcmp(p->className,classname)){
-			return classId;
-		}
-	}
-	// should never happen
-	php_error(E_ERROR,"fatal: QObject not found\n");
-	return 0;
-
-}
-
 bool 
 smokephp_isQObject(Smoke::Index classId) {
 	if(strcmp(PQ::smoke()->classes[classId].className, "QObject") == 0)
@@ -475,16 +428,3 @@
     }
     return false;
 }
-
-bool
-smokephp_isConnect(Smoke::Index method){
-
-	if(
-		method == connect1
-		|| method == connect2
-		|| method == connect3
-		|| method == connect4
-		|| method == connect5
-	) return true; else return false;
-
-}



From tm243 at mail.berlios.de  Mon Mar 26 11:55:56 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Mon, 26 Mar 2007 11:55:56 +0200
Subject: [Php-qt-svn] r313 - trunk/php_qt
Message-ID: <200703260955.l2Q9tumQ030327@sheep.berlios.de>

Author: tm243
Date: 2007-03-26 11:55:56 +0200 (Mon, 26 Mar 2007)
New Revision: 313

Modified:
   trunk/php_qt/php_qt.h
Log:
* code cleaned up



Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-03-26 09:44:13 UTC (rev 312)
+++ trunk/php_qt/php_qt.h	2007-03-26 09:55:56 UTC (rev 313)
@@ -59,18 +59,7 @@
 #endif
 
 #define Qnil (zval *) NULL
-#define QOUT()                                              \
-    extern QTextStream qout(stdout, QIODevice::WriteOnly);  \
 
-#ifndef NOT_YET_IMPLEMENTED
-#define NOT_YET_IMPLEMENTED { php_printf("%s(): functionality not yet implemented\n",get_active_function_name(TSRMLS_C));} 
-#endif
-
-#define PHP_QT_REGISTER(object)     \
-    zend_rsrc_list_entry le;        \
-    le.ptr = object;                \
-    phpqt_register(getThis(),le);  \
-
 #define PHP_QT_FETCH()  \
 	phpqt_getQtObjectFromZval(getThis()) \
 



From tm243 at mail.berlios.de  Mon Mar 26 13:33:16 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Mon, 26 Mar 2007 13:33:16 +0200
Subject: [Php-qt-svn] r314 - in trunk: php_qt tests
Message-ID: <200703261133.l2QBXGka015708@sheep.berlios.de>

Author: tm243
Date: 2007-03-26 13:33:16 +0200 (Mon, 26 Mar 2007)
New Revision: 314

Modified:
   trunk/php_qt/handlers.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/qstring.cpp
   trunk/tests/unicode.php
Log:
* php.ini entry for text codec: UTF8 (default), EUC, SJIS, Latin1
  usage: qt.codec = UTF8



Modified: trunk/php_qt/handlers.cpp
===================================================================
--- trunk/php_qt/handlers.cpp	2007-03-26 09:55:56 UTC (rev 313)
+++ trunk/php_qt/handlers.cpp	2007-03-26 11:33:16 UTC (rev 314)
@@ -183,18 +183,21 @@
   marshall_it<unsigned char *>(m);
 }
 
-static const char * KCODE = "NONE";
+static const char * KCODE = 0;
 static QTextCodec *codec = 0;
 
-static void 
+void 
 init_codec() {
-//	zval* temp = read from php.ini
-//	KCODE = temp->value.str.val;
 
+	KCODE = INI_ORIG_STR("qt.codec");
+
 	if (qstrcmp(KCODE, "EUC") == 0) {
 		codec = QTextCodec::codecForName("eucJP");
 	} else if (qstrcmp(KCODE, "SJIS") == 0) {
 		codec = QTextCodec::codecForName("Shift-JIS");
+	} else if ((qstrcmp(KCODE, "UTF8") != 0) && (qstrcmp(KCODE,"Latin1") != 0)) {
+	    php_error(E_WARNING, "unknown text codec, set to local8Bit");
+	    KCODE="";
 	}
 }
 
@@ -211,7 +214,7 @@
 		return new QString(codec->toUnicode(zstring->value.str.val));
 	else if (qstrcmp(KCODE, "SJIS") == 0)
 		return new QString(codec->toUnicode(zstring->value.str.val));
-	else if(qstrcmp(KCODE, "NONE") == 0)
+	else if(qstrcmp(KCODE, "Latin1") == 0)
 		return new QString(QString::fromLatin1(zstring->value.str.val));
 
 	return new QString(QString::fromLocal8Bit(zstring->value.str.val, zstring->value.str.len));
@@ -219,6 +222,7 @@
 
 zval* 
 zstringFromQString(QString * s) {
+
 	if (KCODE == 0) {
 		init_codec();
 	}
@@ -230,7 +234,7 @@
 		ZVAL_STRING(return_value, (char*) codec->fromUnicode(*s).constData(), /* duplicate */ 1);
 	} else if (qstrcmp(KCODE, "SJIS") == 0) {
 		ZVAL_STRING(return_value, (char*) codec->fromUnicode(*s).constData(), /* duplicate */ 1);
-	} else if (qstrcmp(KCODE, "NONE") == 0) {
+	} else if (qstrcmp(KCODE, "Latin1") == 0) {
 		ZVAL_STRING(return_value, (char*) s->toLatin1().constData(), /* duplicate */ 1);
 	} else {
 		ZVAL_STRING(return_value, (char*) s->toUtf8().constData(), /* duplicate */ 1);

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-03-26 09:55:56 UTC (rev 313)
+++ trunk/php_qt/php_qt.cpp	2007-03-26 11:33:16 UTC (rev 314)
@@ -48,6 +48,10 @@
 static zend_object_handlers php_qt_handler;
 static zend_object_handlers zend_orig_handler;
 
+PHP_INI_BEGIN()
+    PHP_INI_ENTRY("qt.codec", "UTF8", PHP_INI_ALL, NULL)
+PHP_INI_END()
+
 // opcode handler
 #define PHPQT_OPHANDLER_COUNT				((25 * 151) + 1)
 #define EX__(element) execute_data->element
@@ -224,14 +228,7 @@
 
 ZEND_METHOD(php_qt_generic_class, __toString)
 {
-	if(!strcmp(Z_OBJCE_P(getThis())->name,"QString")){
-		smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
-		RETVAL_STRING((char*)((QString*) o->ptr)->toAscii().constData(), 1);
-//		RETVAL_STRING((char*)((QString*) o->ptr)->toLocal8Bit().constData(), 1);
-	} else {
-		RETVAL_STRING("", 1);
-	}
-	return;
+	RETURN_STRING("", 1);
 }
 
 ZEND_METHOD(php_qt_generic_class, __destruct)
@@ -408,6 +405,9 @@
 PHP_MINIT_FUNCTION(php_qt)
 {
 
+	REGISTER_INI_ENTRIES();
+	init_codec();
+
         install_handlers(Qt_handlers);
 
 	// object list
@@ -555,9 +555,7 @@
 	php_info_print_table_header(2, "PHP-Qt support", "enabled");
 	php_info_print_table_end();
 
-	/* Remove comments if you have entries in php.ini
 	DISPLAY_INI_ENTRIES();
-	*/
 }
 
 /*!

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-03-26 09:55:56 UTC (rev 313)
+++ trunk/php_qt/php_qt.h	2007-03-26 11:33:16 UTC (rev 314)
@@ -92,6 +92,9 @@
 PHP_FUNCTION(check_qobject);
 void check_object(zval* zobject);
 
+void init_codec();
+zval* zstringFromQString(QString * s);
+
 struct smokephp_object {
     bool allocated;
     Smoke *smoke;

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-03-26 09:55:56 UTC (rev 313)
+++ trunk/php_qt/qstring.cpp	2007-03-26 11:33:16 UTC (rev 314)
@@ -132,12 +132,12 @@
 
   QString *QString_ptr = (QString *) PHP_QT_FETCH();
 
-  int l = QString_ptr->size();
+  zval* z = zstringFromQString(QString_ptr);
+  ZVAL_ZVAL(return_value, z,1,0);
+  efree(z);
 
-//  char* c = (char*) (QString_ptr->toUtf8()).constData();
-  char* c = (char*) (QString_ptr->toAscii()).constData();
+  return;
 
-  RETURN_STRING(c,l);
 }
 
 /*		public enumSectionFlag:long {
@@ -2123,25 +2123,26 @@
 		zval *z_1; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
+  			    if(getThis() == NULL){
 
-// wichtig: Speicher auf dem Heap alloziieren
-			  QString *return_object = new QString;
-  			  if(getThis() != NULL){
-		        QString *obj = (QString*) PHP_QT_FETCH();
-// hier einfach ?berschreiben
-      			*return_object = (QString) obj->fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-// static
-		      } else {
-		        *return_object = (QString) QString::fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-
-		      }		
-			  zend_class_entry *ce;                                   
+//		    		QString *obj = (QString*) PHP_QT_FETCH();
+//				*return_object = (QString) obj->fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+/*			  zend_class_entry *ce;                                   
 			  object_init_ex(return_value, qstring_ce);
 			  zend_rsrc_list_entry le;                            
 			  le.ptr = return_object;
 			  phpqt_register(return_value,le);
-			  return;
+*/
+
+				QString obj = (QString) QString::fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				QString *s1 = new QString(obj);
+				object_init_ex(return_value, qstring_ce);
+				phpqt_createObject(return_value, (void*) s1, qstring_ce);
+				return;
+
+			    }
 			}
+
 		}
 	}
 }

Modified: trunk/tests/unicode.php
===================================================================
--- trunk/tests/unicode.php	2007-03-26 09:55:56 UTC (rev 313)
+++ trunk/tests/unicode.php	2007-03-26 11:33:16 UTC (rev 314)
@@ -45,7 +45,7 @@
 
 	}
 
-    $app = new QApplication(&$argc,$argv);
+    $app = new QApplication($argc,$argv);
 	$widget = new TestButtons();
 	$widget->show();
 	$app->exec();



From tm243 at mail.berlios.de  Mon Mar 26 13:35:00 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Mon, 26 Mar 2007 13:35:00 +0200
Subject: [Php-qt-svn] r315 - trunk/php_qt
Message-ID: <200703261135.l2QBZ0JJ015815@sheep.berlios.de>

Author: tm243
Date: 2007-03-26 13:34:59 +0200 (Mon, 26 Mar 2007)
New Revision: 315

Modified:
   trunk/php_qt/qstring.cpp
Log:
* code cleaned up



Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-03-26 11:33:16 UTC (rev 314)
+++ trunk/php_qt/qstring.cpp	2007-03-26 11:34:59 UTC (rev 315)
@@ -2116,24 +2116,11 @@
 ZEND_METHOD(QString, fromUtf8){
 
 	if (ZEND_NUM_ARGS() == 2){
-		/* sl public*/
-
-		/* const char* , int size,  */
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
   			    if(getThis() == NULL){
-
-//		    		QString *obj = (QString*) PHP_QT_FETCH();
-//				*return_object = (QString) obj->fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-/*			  zend_class_entry *ce;                                   
-			  object_init_ex(return_value, qstring_ce);
-			  zend_rsrc_list_entry le;                            
-			  le.ptr = return_object;
-			  phpqt_register(return_value,le);
-*/
-
 				QString obj = (QString) QString::fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
 				QString *s1 = new QString(obj);
 				object_init_ex(return_value, qstring_ce);



