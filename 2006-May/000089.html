<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Php-qt-svn] r245 - trunk/tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/php-qt-svn/2006-May/index.html" >
   <LINK REL="made" HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r245%20-%20trunk/tools&In-Reply-To=%3C200605241530.k4OFUcYH031759%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000088.html">
   <LINK REL="Next"  HREF="000090.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Php-qt-svn] r245 - trunk/tools</H1>
    <B>tm243 at BerliOS</B> 
    <A HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r245%20-%20trunk/tools&In-Reply-To=%3C200605241530.k4OFUcYH031759%40sheep.berlios.de%3E"
       TITLE="[Php-qt-svn] r245 - trunk/tools">tm243 at berlios.de
       </A><BR>
    <I>Wed May 24 17:30:38 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000088.html">[Php-qt-svn] r244 - trunk/tutorials/t7
</A></li>
        <LI>Next message: <A HREF="000090.html">[Php-qt-svn] r246 - trunk/tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#89">[ date ]</a>
              <a href="thread.html#89">[ thread ]</a>
              <a href="subject.html#89">[ subject ]</a>
              <a href="author.html#89">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tm243
Date: 2006-05-24 17:30:37 +0200 (Wed, 24 May 2006)
New Revision: 245

Removed:
   trunk/tools/kalyptusCxxToPHP.pm
Log:
php extension for kalyptus will be replaced.

Deleted: trunk/tools/kalyptusCxxToPHP.pm
===================================================================
--- trunk/tools/kalyptusCxxToPHP.pm	2006-05-19 08:29:33 UTC (rev 244)
+++ trunk/tools/kalyptusCxxToPHP.pm	2006-05-24 15:30:37 UTC (rev 245)
@@ -1,1911 +0,0 @@
-#***************************************************************************
-#    copyright            : (C) 2005 Thomas Moenicke
-#    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>
-#    author               : Thomas Moenicke, based on the CSharp generation code
-#                            by Adam Treat &amp; Richard Dale.
-#***************************************************************************/
-
-#/***************************************************************************
-# *                                                                         *
-# *   This program is free software; you can redistribute it and/or modify  *
-# *   it under the terms of the GNU General Public License as published by  *
-# *   the Free Software Foundation; either version 2 of the License, or     *
-# *   (at your option) any later version.                                   *
-# *                                                                         *
-#***************************************************************************/
-
-#   - multiple inherits
-#   - method overloading, marshalling
-#   - return values
-
-# TODO
-#   - support for all types in method calls
-#   - fit cplusplusToZEND, cplusplusToInvoke, cplusplusToMacro
-#   - setter methods support only one php property (adequate, I believe)
-
-#   php properties, enums
-#   RETURN_BYTE[]
-
-
-package kalyptusCxxToPHP;
-
-use File::Path;
-use File::Basename;
-
-use Carp;
-use Ast;
-use kdocAstUtil;
-use kdocUtil;
-use Iter;
-use kalyptusDataDict;
-
-use strict;
-no strict &quot;subs&quot;;
-
-use vars qw/ @clist $host $who $now $gentext %functionId $docTop
-	$lib $rootnode $outputdir $opt $debug $typeprefix $eventHandlerCount
-	$pastaccess $pastname $pastreturn $pastparams $nullctor $ctorCount @properties @functions @constructors %methods *CLASS *HEADER *AG_ZEND_CLASS_ENTRY *AG_EXTERN_ZEND_CLASS_ENTRY *AG_VOID_REGISTER *AG_ZEND_PHP_QT *AG_CONFIGM4 *AG_QT_MINIT *AG_PHP_QT_CPP *QTCTYPES *KDETYPES /;
-
-BEGIN
-{
-    @clist = ();
-
-    # Page footer
-
-	$who = kdocUtil::userName();
-	$host = kdocUtil::hostName();
-	$now = localtime;
-	$gentext = &quot;$who using kalyptus $main::Version.&quot;;
-
-	$docTop =&lt;&lt;EOF
- * begin           : $now
- * generated by    : $gentext
- */
-EOF
-}
-
-# TODO here:
-# one is needed for php types, one for zend types (e.q. zval)
-sub cplusplusToZEND
-{
-	my ( $cplusplusType )  = @_;
-	if ( $cplusplusType =~ /bool/ &amp;&amp; kalyptusDataDict::ctypemap($cplusplusType) eq &quot;int&quot; ) {
-		return &quot;bool&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*void\s*\**/ ) {
-		return &quot;NULL&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*\bint\s*\&amp;*/) {
-		return &quot;long&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*\bint\s*\*/) {
-		return &quot;int[]&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*double\s*\*/ ) {
-		return &quot;double[]&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*short\s*\*/ ) {
-		return &quot;short[]&quot;;
-	} elsif ( $cplusplusType =~ /QByteArray/ || $cplusplusType =~ /QBitArray/ ) {
-		return &quot;byte[]&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\*\*/ ) {
-		return &quot;char&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\**/ ) {
-		return &quot;char* &quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned int\s*\**/ ) {
-		return &quot;uint&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned short\s*\**/ ) {
-		return &quot;ushort&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned long\s*\**/ ) {
-		return &quot;ulong&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned char\s*\**/ ) {
-		return &quot;string&quot;;
-	} elsif ( $cplusplusType =~ /^GUID/ ) {
-		return &quot;System.Guid&quot;;
-	} elsif ( $cplusplusType =~ /^FILE/ ) {
-		return &quot;string&quot;;
-	} elsif ( $cplusplusType =~ /^_NPStream/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^QPtrCollection/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^QStyleHintReturn/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^type/i ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^Key/ || $cplusplusType =~ /^key_type/ || $cplusplusType =~ /^K/) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^QUnknownInterface/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^GDHandle/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^QTextParag/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^QDiskFont/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^QDomNodePrivate/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^Display/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^QUuid/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^Q_REFCOUNT/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^EventRef/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^MSG/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^QWSEvent/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^XEvent/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^CGContextRef/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^QWSDecoration/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^QTextFormat/ || $cplusplusType =~ /^QTextDocument/ || $cplusplusType =~ /^QTextCursor/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^QSqlRecordPrivate/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^Text/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^Event/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /^NavDirection/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif (
-			$cplusplusType =~ /^pointer$/
-			 || $cplusplusType =~/T\*$/
-			 || $cplusplusType =~/T\&amp;*$/
-			 || $cplusplusType =~/T1\&amp;*$/
-			 || $cplusplusType =~/T2\&amp;*$/
-			 || $cplusplusType =~/^Iterator/i
-			 || $cplusplusType =~/^_iterator/i
-			 || $cplusplusType =~/^reference/
-			 || $cplusplusType =~/^_reference/) {
-		return &quot;IntPtr&quot;;
-	} elsif ($cplusplusType =~ /::/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /::/ ||
-			 $cplusplusType =~ /&amp;$/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /&amp;$/ ||
-			 $cplusplusType =~ /\*/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /\*/) {
-
-#		$cplusplusType =~ s/::/./g;
-#		$cplusplusType =~ s/&amp;//g;
-#		$cplusplusType =~ s/\*//g;
-#		return $cplusplusType;
-        return &quot;zval*&quot;;
-
-	} else {
- 		return kalyptusDataDict::ctypemap($cplusplusType);
-	}
-}
-
-# zend.h:
-#/* data types */
-#/* All data types &lt;= IS_BOOL have their constructor/destructors skipped */
-#define IS_NULL		0
-#define IS_LONG		1
-#define IS_DOUBLE	2
-#define IS_BOOL		3
-#define IS_ARRAY	4
-#define IS_OBJECT	5
-#define IS_STRING	6
-#define IS_RESOURCE	7
-#define IS_CONSTANT	8
-#define IS_CONSTANT_ARRAY	9
-
-
-sub cplusplusToZENDType
-{
-	my ( $cplusplusType )  = @_;
-	if ( $cplusplusType =~ /bool/ &amp;&amp; kalyptusDataDict::ctypemap($cplusplusType) eq &quot;int&quot; ) {
-		return &quot;BOOL&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*void\s*\**/ ) {
-		return &quot;NULL&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\&amp;*/ ) {
-		return &quot;LONG&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\*/) {
-		return &quot;ARRAY&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*double\s*\*/ ) {
-		return &quot;ARRAY&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*short\s*\*/ ) {
-		return &quot;ARRAY&quot;;
-	} elsif ( $cplusplusType =~ /QByteArray/ || $cplusplusType =~ /QBitArray/ ) {
-		return &quot;ARRAY&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\*\*/ ) {
-		return &quot;STRING&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\**/ ) {
-		return &quot;STRING&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned int\s*\**/ ) {
-		return &quot;LONG&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned short\s*\**/ ) {
-		return &quot;LONG&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned long\s*\**/ ) {
-		return &quot;LONG&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned char\s*\**/ ) {
-		return &quot;STRING&quot;;
-	} elsif ( $cplusplusType =~ /^GUID/ ) {
-		return &quot;System.Guid&quot;;
-	} elsif ( $cplusplusType =~ /^FILE/ ) {
-		return &quot;STRING&quot;;
-	} elsif ( $cplusplusType =~ /^_NPStream/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^QPtrCollection/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^QStyleHintReturn/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^type/i ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^Key/ || $cplusplusType =~ /^key_type/ || $cplusplusType =~ /^K/) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^QUnknownInterface/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^GDHandle/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^QTextParag/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^QDiskFont/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^QDomNodePrivate/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^Display/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^QUuid/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^Q_REFCOUNT/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^EventRef/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^MSG/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^QWSEvent/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^XEvent/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^CGContextRef/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^QWSDecoration/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^QTextFormat/ || $cplusplusType =~ /^QTextDocument/ || $cplusplusType =~ /^QTextCursor/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^QSqlRecordPrivate/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^Text/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^Event/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif ( $cplusplusType =~ /^NavDirection/ ) {
-		return &quot;OBJECT&quot;;
-	} elsif (
-			$cplusplusType =~ /^pointer$/
-			 || $cplusplusType =~/T\*$/
-			 || $cplusplusType =~/T\&amp;*$/
-			 || $cplusplusType =~/T1\&amp;*$/
-			 || $cplusplusType =~/T2\&amp;*$/
-			 || $cplusplusType =~/^Iterator/i
-			 || $cplusplusType =~/^_iterator/i
-			 || $cplusplusType =~/^reference/
-			 || $cplusplusType =~/^_reference/) {
-		return &quot;OBJECT&quot;;
-	} elsif ($cplusplusType =~ /::/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /::/ ||
-			 $cplusplusType =~ /&amp;$/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /&amp;$/ ||
-			 $cplusplusType =~ /\*/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /\*/) {
-
-#		$cplusplusType =~ s/::/./g;
-#		$cplusplusType =~ s/&amp;//g;
-#		$cplusplusType =~ s/\*//g;
-#		return $cplusplusType;
-        return &quot;OBJECT&quot;;
-
-	} else {
- 		return kalyptusDataDict::ctypemap($cplusplusType);
-	}
-}
-
-# function is not used yet
-sub cplusplusToPInvoke
-{
-	my ( $cplusplusType )  = @_;
-	if ( $cplusplusType =~ /bool/ &amp;&amp; kalyptusDataDict::ctypemap($cplusplusType) eq &quot;int&quot; ) {
-		return &quot;bool&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*void\s*\*/ ) {
-		return &quot;int&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\&amp;*/ ) {
-		return &quot;int&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\*/) {
-		return &quot;int[]&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*double\s*\*/ ) {
-		return &quot;double[]&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*short\s*\*/ ) {
-		return &quot;short[]&quot;;
-	} elsif ( $cplusplusType =~ /QByteArray/ || $cplusplusType =~ /QBitArray/ ) {
-		return &quot;byte[]&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\*\*/ ) {
-		return &quot;string[]&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\**/ ) {
-		return &quot;string&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned int\s*\**/ ) {
-		return &quot;uint&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned short\s*\**&amp;*/ ) {
-		return &quot;ushort&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned long\s*\**/ ) {
-		return &quot;ulong&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned char\s*\**/ ) {
-		return &quot;string&quot;;
-	} elsif ( $cplusplusType =~ /^GUID/ ) {
-		return &quot;System.Guid&quot;;
-	} elsif ( $cplusplusType =~ /^FILE/ ) {
-		return &quot;string&quot;;
-	} elsif ( $cplusplusType =~ /^_NPStream/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^QPtrCollection/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^QStyleHintReturn/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^type/i ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^Key/ || $cplusplusType =~ /^key_type/ || $cplusplusType =~ /^K/) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^QUnknownInterface/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^GDHandle/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^QTextParag/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^QDiskFont/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^QDomNodePrivate/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^Display/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^QUuid/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^Q_REFCOUNT/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^EventRef/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^MSG/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^QWSEvent/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^XEvent/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^CGContextRef/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^QWSDecoration/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^QTextFormat/ || $cplusplusType =~ /^QTextDocument/ || $cplusplusType =~ /^QTextCursor/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^QSqlRecordPrivate/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^Text/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^Event/ ) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /^NavDirection/ ) {
-		return &quot;RawObject&quot;;
-	} elsif (
-			$cplusplusType =~ /^pointer$/
-			 || $cplusplusType =~/T\*$/
-			 || $cplusplusType =~/T\&amp;*$/
-			 || $cplusplusType =~/T1\&amp;*$/
-			 || $cplusplusType =~/T2\&amp;*$/
-			 || $cplusplusType =~/^iterator/i
-			 || $cplusplusType =~/^_iterator/i
-			 || $cplusplusType =~/^reference/
-			 || $cplusplusType =~/^_reference/) {
-		return &quot;RawObject&quot;;
-	} elsif ( $cplusplusType =~ /&amp;$/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /&amp;$/ ) {
-		return &quot;IntPtr&quot;;
-	} elsif ( $cplusplusType =~ /\*/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /\*/ ) {
-		return &quot;IntPtr&quot;;
-	} else {
-		return kalyptusDataDict::ctypemap($cplusplusType);
-	}
-}
-
-# deprecated
-sub cplusplusToMacro
-{
-	my ( $class, $cnode )  = @_;
-
-    my $functionname = $cnode-&gt;{astNodeName};
-    my $classname = $class-&gt;{astNodeName};
-
-    my $function = $cnode;  # for better reading
-    my $access = $function-&gt;{Access};
-    my $returntype = $function-&gt;{ReturnType};
-
-# skip
-    if ($functionname eq &quot;qObject&quot;) {
-        print CLASS &quot;// skip &quot;,$functionname,&quot;\n&quot;;
-        return;
-    }
-
-# make sure that this function will be added only at one time
-    my $mark = 0;
-    my $func;
-    foreach $func ( @functions ) {
-        if ( $func eq $functionname ) {
-            print CLASS &quot;// marked for overloading: &quot;,$functionname,&quot;\n&quot;;
-            $mark = 1;
-        }
-    }
-
-# print doc in phpDocumentor style
-    if(!$mark){
-
-        my $c = @functions;
-        if($c&gt;0){
-            print CLASS &quot;\t}\n&quot;;
-            print CLASS &quot;}\n&quot;;
-        }
-
-        push @functions, $functionname;
-        print CLASS &quot;
-
-/*********************************
- *    class     &quot;,$classname,&quot;
- *    function  &quot;,$functionname,&quot;
- *    flags:    &quot;,$function-&gt;{Flags},&quot;
- *\n&quot;;
-
-        my $count = 0;
-        foreach $b ( @{$cnode-&gt;{ParamList}} ) {
-            print CLASS &quot; *    \@param   &quot;,$b-&gt;{ArgType},&quot;\n&quot;;
-        }
-        if (!$count) {
-            print CLASS &quot; *    \@param   -\n&quot;;
-        }
-
-        print CLASS &quot;
- *    \@access   &quot;,$access,&quot;
- *    \@return   &quot;,$returntype,&quot;
-*********************************/
-&quot;;
-    } else {
-        print CLASS &quot;\t}\n&quot;;
-    }
-
-    # skip virtuals
-    if ( $function-&gt;{Flags} =~ /v/ ){
-        print CLASS &quot;ZEND_METHOD(&quot;,$classname,&quot;, &quot;,$functionname,&quot;){\n&quot;;
-        print CLASS &quot;// marked as virtual, skipped\n&quot;;
-        print CLASS &quot;\tphp_printf(\&quot;%s(): virtual functions are not yet implemented&quot;,'\n',&quot;\&quot;,get_active_function_name(TSRMLS_C));\n&quot;;
-        print CLASS &quot;}\n&quot;;
-        return;
-    }
-
-    if(!$mark){
-        print CLASS &quot;ZEND_METHOD(&quot;,$classname,&quot;, &quot;,$functionname,&quot;){\n&quot;;
-    }
-
-    my $p = @{$cnode-&gt;{ParamList}};
-    print CLASS &quot;\tif (ZEND_NUM_ARGS() == &quot;,$p,&quot;){\n&quot;;
-
-    my $count = 0;
-    my $paratype; # for zend
-    my $short = &quot;,\&quot;&quot;;
-    my $paraf;  # for qt
-    my @objects;
-
-# write method implementation
-    foreach $b ( @{$cnode-&gt;{ParamList}} ) {
-
-        if($count &gt; 0){
-            $paraf .= &quot;, &quot;;
-        }
-        print CLASS &quot;\t// &quot;,$b-&gt;{DefaultValue},&quot;\n&quot;;
-# todo: long, double
-        if ( $b-&gt;{ArgType} =~ /char/ ) {
-            print CLASS &quot;\t\tchar* var_&quot;,$count,&quot;;\n&quot;;
-            print CLASS &quot;\t\tint* len_&quot;,$count,&quot;;\n\n&quot;;
-            $paratype .= &quot;, &amp;var_&quot;.$count.&quot;, &amp;len_&quot;.$count;
-            $paraf .= &quot; var_&quot;.$count;
-            $short .= &quot;s&quot;;
-        } elsif ( $b-&gt;{ArgType} =~ /int/ ) {
-            print CLASS &quot;\t\tlong var_&quot;,$count,&quot;;\n&quot;;
-            $paratype .= &quot;, &amp;var_&quot;.$count;
-            $paraf .= &quot;(&quot;.$b-&gt;{ArgType}.&quot;) var_&quot;.$count;
-            $short .= &quot;l&quot;;
-        } elsif ( $b-&gt;{ArgType} =~ /bool/ ) {
-            print CLASS &quot;\t\tbool* var_&quot;,$count,&quot;;\n&quot;;
-            $paratype .= &quot;, &amp;var_&quot;.$count;
-            $paraf .= &quot;(&quot;.$b-&gt;{ArgType}.&quot;) var_&quot;.$count;
-            $short .= &quot;b&quot;;
-        }
-        else {
-            print CLASS &quot;\t\tzval* var_&quot;,$count,&quot;;\n\n&quot;;
-            $paratype .= &quot;, &amp;var_&quot;.$count;
-            $paraf .= &quot; var_&quot;.$count;
-            $short .= &quot;o&quot;;
-            push @objects, &quot;var_&quot;.$count;
-        }
-
-        $count++;
-    }
-    $short .= &quot;\&quot;&quot;;
-
-
-
-    if( $count ) {
-        print CLASS &quot;\t\tif(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC&quot;,$short,$paratype,&quot;) == FAILURE) {\n&quot;;
-        print CLASS &quot;\t\t\tRETURN_FALSE;\n&quot;;
-        print CLASS &quot;\t\t}\n&quot;;
-    }
-
-# properties:
-    # we have a nxn relation
-    my $prop;
-    my $obj_tmp;
-
-    foreach $prop ( @properties ) {
-
-       if ( $prop-&gt;{WRITE} =~ /$functionname/ ) {
-        foreach $obj_tmp ( @properties ) {
-            # mostly these methods are setmethods with only one argument
-            # maybe source of error
-# todo: test with QLCDNumber
-            my $postfix = cplusplusToZEND($prop-&gt;{type});
-            $postfix =~ s/zval\*//;
-            if ( $postfix ) {
-                $postfix = &quot;_&quot;.cplusplusToZEND($prop-&gt;{type});
-            }
-
-            print CLASS  &quot;\t\tzend_update_property&quot;,$postfix,&quot;(Z_OBJCE_P(getThis()),getThis(),\&quot;&quot;,$prop-&gt;{astNodeName},&quot;\&quot;,strlen(\&quot;&quot;,$prop-&gt;{astNodeName},&quot;\&quot;),var_0 TSRMLS_CC);\n&quot;;
-            print CLASS &quot;\t}\n&quot;;
-            return;
-        }
-       }
-    }
-
-    my $rt = cplusplusToZEND($returntype);
-
-    my $obj;
-
-        foreach $obj ( @objects ) {
-            print CLASS &quot;\t\tQObject* tmp_&quot;,$obj,&quot; = (QObject*) php_qt_fetch(&quot;,$obj,&quot;);\n&quot;;
-            $paraf =~ s/$obj/tmp_$obj/;
-        }
-
-        print CLASS &quot;\t\t$classname *o = ($classname*) PHP_QT_FETCH();\n&quot;;
-
-
-        if ( $rt eq &quot;NULL&quot; ) {
-            print CLASS &quot;\t\to-&gt;&quot;,$functionname,&quot;(&quot;,$paraf,&quot;);\n&quot;;
-            print CLASS &quot;\t\tRETURN_NULL();\n&quot;;
-        } elsif ( $rt =~ /zval/ ) {
-
-# TODO: consider 'const',
-# and non-pointer types, pointer types
-            print CLASS &quot;\t\t&quot;,$returntype,&quot; obj = (&quot;,$returntype,&quot;) o-&gt;&quot;,$functionname,&quot;(&quot;,$paraf,&quot;);\n&quot;;
-            print CLASS &quot;\t\tzend_class_entry *ce;                                   \n&quot;;
-#            print CLASS &quot;\tif(obj != NULL) {                                       \n&quot;;
-            print CLASS &quot;\t\t    object_init_ex(return_value, &quot;,$classname,&quot;_ce_ptr);     \n&quot;;
-            print CLASS &quot;\t\t    zend_rsrc_list_entry le;                            \n&quot;;
-            print CLASS &quot;\t\t    le.ptr = &obj;                                       \n&quot;;
-            print CLASS &quot;\t\t    php_qt_register(return_value,le);                   \n&quot;;
-            print CLASS &quot;\t\t    return;                                             \n&quot;;
-#            print CLASS &quot;\t}                                                       \n&quot;;
-#            print CLASS &quot;\telse                                                    \n&quot;;
-#            print CLASS &quot;\t    RETURN_NULL();                                      \n&quot;;
-
-        } else {
-            print CLASS &quot;\t\tRETURN_&quot;,uc($rt),&quot;(o-&gt;&quot;,$functionname,&quot;(&quot;,$paraf,&quot;));\n&quot; if defined $rt;
-        }
-
-    if( $cnode-&gt;{Flags} =~ /s/ ){
-        $access .= &quot;|ZEND_ACC_STATIC&quot;;
-    }
-
-    print ZEND_PHP_QT &quot;\nZEND_METHOD(&quot;,$class-&gt;{astNodeName},&quot;, &quot;,$functionname,&quot;);&quot;;
-    print AG_ZEND_PHP_QT &quot;\nZEND_METHOD(&quot;,$class-&gt;{astNodeName},&quot;, &quot;,$functionname,&quot;);&quot;;
-
-# code snippets for php_qt.cpp here
-    $access = uc($access);
-    $access =~ s/_SLOTS//;
-    $access =~ s/_SIGNALS//;
-
-    print AG_PHP_QT_CPP &quot;\tZEND_ME(&quot;,$classname,&quot;,&quot;,$functionname,&quot;,NULL,ZEND_ACC_&quot;,$access,&quot;)\n&quot;;
-
-}
-
-sub writeDoc
-{
-	( $lib, $rootnode, $outputdir, $opt ) = @_;
-
-	$debug = $main::debuggen;
-
-	mkpath( $outputdir ) unless -f $outputdir;
-    mkpath( $outputdir.&quot;/classes/&quot; ) unless -f $outputdir.&quot;/classes/&quot;;
-
-# open files
-
-    # AG_ZEND_CLASS_ENTRY
-    my $file_ag_zend_class_entry = &quot;$outputdir/ag_zend_class_entry.inc&quot;;
-    open( AG_ZEND_CLASS_ENTRY, &quot;&gt;$file_ag_zend_class_entry&quot; ) || die &quot;Couldn't create $file_ag_zend_class_entry\n&quot;;
-    $file_ag_zend_class_entry =~ s/\.h/.h/;
-
-    # AG_EXTERN_ZEND_CLASS_ENTRY
-    my $file_ag_extern_zend_class_entry = &quot;$outputdir/ag_extern_zend_class_entry.inc&quot;;
-    open( AG_EXTERN_ZEND_CLASS_ENTRY, &quot;&gt;$file_ag_extern_zend_class_entry&quot; ) || die &quot;Couldn't create $file_ag_extern_zend_class_entry\n&quot;;
-    $file_ag_extern_zend_class_entry =~ s/\.h/.h/;
-
-    # AG_ZEND_PHP_QT
-    my $file_ag_zend_php_qt = &quot;$outputdir/ag_zend_php_qt.inc&quot;;
-    open( AG_ZEND_PHP_QT, &quot;&gt;$file_ag_zend_php_qt&quot; ) || die &quot;Couldn't create $file_ag_zend_php_qt\n&quot;;
-    $file_ag_zend_php_qt =~ s/\.h/.h/;
-
-    # AG_CONFIGM4
-    my $file_ag_configm4 = &quot;$outputdir/ag_configm4.inc&quot;;
-    open( AG_CONFIGM4, &quot;&gt;$file_ag_configm4&quot; ) || die &quot;Couldn't create $file_ag_configm4\n&quot;;
-    $file_ag_configm4 =~ s/\.h/.h/;
-
-    # AG_QT_MINIT
-    my $file_ag_qt_minit = &quot;$outputdir/ag_qt_minit.inc&quot;;
-    open( AG_QT_MINIT, &quot;&gt;$file_ag_qt_minit&quot; ) || die &quot;Couldn't create $file_ag_qt_minit\n&quot;;
-    $file_ag_qt_minit =~ s/\.h/.h/;
-
-    # AG_PHP_QT_CPP
-    my $file_ag_php_qt_cpp = &quot;$outputdir/ag_php_qt_cpp.inc&quot;;
-    open( AG_PHP_QT_CPP, &quot;&gt;$file_ag_php_qt_cpp&quot; ) || die &quot;Couldn't create $file_ag_php_qt_cpp\n&quot;;
-    $file_ag_php_qt_cpp =~ s/\.h/.h/;
-
-    print ZEND_PHP_QT &quot;/*
- * PHP-Qt - The PHP language bindings for Qt
- *
- * Copyright (C) 2005 
- * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;, 
- * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- * 
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- * 
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * QFrame.cpp - QFrame PHP implementation.
- * begin           : Sun Dec 11 13:58:03 2005
- * generated by    : moni using kalyptus 0.9.
- */
-
-/*
- * Copyright (C) 2005
- * Thomas Moenicke &lt;tm\@ippfp.org&gt;,
- * Jean-Luc Gyger &lt;jean_luc.gyger\@freesurf.ch&gt;
- *
-*/
-/* \$Id: header,v 1.15 2004/01/08 16:46:52 sniper Exp \$ */
-
-#ifndef PHP_PHP_QT_H
-#define PHP_PHP_QT_H
-
-extern zend_module_entry php_qt_module_entry;
-#define phpext_php_qt_ptr &amp;php_qt_module_entry
-
-#ifdef ZTS
-#include \&quot;TSRM.h\&quot;
-#endif
-
-PHP_MINIT_FUNCTION(php_qt);
-PHP_MSHUTDOWN_FUNCTION(php_qt);
-PHP_RINIT_FUNCTION(php_qt);
-PHP_RSHUTDOWN_FUNCTION(php_qt);
-PHP_MINFO_FUNCTION(php_qt);
-
-PHP_FUNCTION(confirm_php_qt_compiled);	/* For testing, remove later. */
-
-/* emulate SIGNAL(), SLOT() macros */
-PHP_FUNCTION(SIGNAL);
-PHP_FUNCTION(SLOT);
-    \n\n&quot;;
-
-    print PHP_QT_MINIT &quot;\n&quot;;
-
-	# Document all compound nodes
-	Iter::LocalCompounds( $rootnode, sub { writeClassDoc( shift ); } );
-
-    print ZEND_PHP_QT &quot;\n/*
-  	Declare any global variables you may need between the BEGIN
-	and END macros here:
-
-ZEND_BEGIN_MODULE_GLOBALS(php_qt)
-	long  global_value;
-	char *global_string;
-ZEND_END_MODULE_GLOBALS(php_qt)
-*/
-
-/* In every utility function you add that needs to use variables
-   in php_php_qt_globals, call TSRMLS_FETCH(); after declaring other
-   variables used by that function, or better yet, pass in TSRMLS_CC
-   after the last function argument and declare your utility function
-   with TSRMLS_DC after the last declared argument.  Always refer to
-   the globals in your function as PHP_QT_G(variable).  You are
-   encouraged to rename these macros something shorter, see
-   examples in any other php module directory.
-*/
-
-#ifdef ZTS
-#define PHP_QT_G(v) TSRMG(php_qt_globals_id, zend_php_qt_globals *, v)
-#else
-#define PHP_QT_G(v) (php_qt_globals.v)
-#endif
-
-#endif	/* PHP_PHP_QT_H */
-
-
-/*
- * Local variables:
- * tab-width: 4
- * c-basic-offset: 4
- * End:
- * vim600: noet sw=4 ts=4 fdm=marker
- * vim&lt;600: noet sw=4 ts=4
- */\n
-    &quot;;
-
-# close files
-
-    close AG_ZEND_CLASS_ENTRY;
-    close AG_EXTERN_ZEND_CLASS_ENTRY;
-
-    print AG_ZEND_PHP_QT &quot;\n&quot;;
-    close AG_ZEND_PHP_QT;
-    close AG_CONFIGM4;
-    close AG_QT_MINIT;
-    close AG_PHP_QT_CPP;
-
-}
-
-sub writeClassDoc
-{
-	my( $node ) = @_;
-
-    $ctorCount = 0;
-
-    if(
-            $node-&gt;{astNodeName} eq &quot;QAbstractButton&quot;
-        ||  $node-&gt;{astNodeName} eq &quot;QLCDNumber&quot;
-        ||  $node-&gt;{astNodeName} eq &quot;QLatin1String&quot;
-||  $node-&gt;{astNodeName} eq &quot;QApplication&quot;
-||  $node-&gt;{astNodeName} eq &quot;QCoreApplication&quot;
-||  $node-&gt;{astNodeName} eq &quot;QBoxLayout&quot;
-||  $node-&gt;{astNodeName} eq &quot;QAbstractSlider&quot;
-||  $node-&gt;{astNodeName} eq &quot;QWidget&quot;
-||  $node-&gt;{astNodeName} eq &quot;QLayoutItem&quot;
-||  $node-&gt;{astNodeName} eq &quot;QLineEdit&quot;
-||  $node-&gt;{astNodeName} eq &quot;QObject&quot;
-||  $node-&gt;{astNodeName} eq &quot;QPushButton&quot;
-||  $node-&gt;{astNodeName} eq &quot;QLayout&quot;
-||  $node-&gt;{astNodeName} eq &quot;QHBoxLayout&quot;
-||  $node-&gt;{astNodeName} eq &quot;QFrame&quot;
-||  $node-&gt;{astNodeName} eq &quot;QPushButton&quot;
-||  $node-&gt;{astNodeName} eq &quot;QSlider&quot;
-||  $node-&gt;{astNodeName} eq &quot;QSpacerItem&quot;
-||  $node-&gt;{astNodeName} eq &quot;QString&quot;
-||  $node-&gt;{astNodeName} eq &quot;QVBoxLayout&quot;
-||  $node-&gt;{astNodeName} eq &quot;Qt&quot;
-||  $node-&gt;{astNodeName} eq &quot;QInternal&quot;
-||  $node-&gt;{astNodeName} eq &quot;Attribute&quot;
-    ){
-        print $node-&gt;{astNodeName},&quot; skipped\n&quot;;
-        return;
-    }
-
-	print &quot;Enter: $node-&gt;{astNodeName}\n&quot; if $debug;
-	if( exists $node-&gt;{ExtSource} ) {
-		warn &quot;Trying to write doc for &quot;.$node-&gt;{AstNodeName}.
-			&quot; from &quot;.$node-&gt;{ExtSource}.&quot;\n&quot;;
-		return;
-	}
-
-	my $typeName = $node-&gt;{astNodeName}.&quot;*&quot;;
-
-	if ( kalyptusDataDict::ctypemap($typeName) eq &quot;&quot; ) {
-		$typeprefix = ($typeName =~ /^Q/ ? &quot;qt_&quot; : &quot;kde_&quot;);
-		kalyptusDataDict::setctypemap($typeName, $typeprefix.$node-&gt;{astNodeName}.&quot;*&quot;);
-		print &quot;'$typeName' =&gt; '$typeprefix$typeName',\n&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($typeName) =~ /^qt_/ ) {
-		$typeprefix = &quot;qt_&quot;;
-	} elsif ( kalyptusDataDict::ctypemap($typeName) =~ /^kde_/ ) {
-		$typeprefix = &quot;kde_&quot;;
-	} else {
-		$typeprefix = &quot;kde_&quot;;
-	}
-# make the class file
-	my $file = join(&quot;__&quot;, kdocAstUtil::heritage($node)).&quot;.cpp&quot;;
-    $file = $outputdir.&quot;/classes/&quot;.lc($file);
-	my $docnode = $node-&gt;{DocNode};
-	my @list = ();
-	my $version = undef;
-	my $author = undef;
-
-	if( $#{$node-&gt;{Kids}} &lt; 0 || $node-&gt;{Access} eq &quot;private&quot;) {
-		return;
-	}
-
-	open( CLASS, &quot;&gt;$file&quot; ) || die &quot;Couldn't create $file\n&quot;;
-	$file =~ s/\.h/.cpp/;
-
-	my $short = &quot;&quot;;
-	my $extra = &quot;&quot;;
-
-print CLASS &quot;/*
- * PHP-Qt - The PHP language bindings for Qt
- *
- * Copyright (C) 2005
- * Thomas Moenicke &lt;tm\@ippfp.org&gt;,
- * Jean-Luc Gyger &lt;jean_luc.gyger\@freesurf.ch&gt;
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
-&quot;;
-
-	print CLASS &quot; * &quot;, $node-&gt;{astNodeName}, &quot;.cpp - &quot;, $node-&gt;{astNodeName}, &quot; PHP implementation.\n&quot;;
-	print CLASS $docTop;
-
-    print CLASS &quot;
-#include &lt;iostream&gt;
-using namespace std;\n&quot;;
-
-    print CLASS &quot;\n#include &lt;$node-&gt;{astNodeName}&gt;\n&quot;;
-    print CLASS &quot;#include \&quot;../php_qt.h\&quot;\n\n&quot;;
-
-    print CLASS checkIncludes($node);
-
-    print AG_PHP_QT_CPP &quot;static zend_function_entry &quot;,$node-&gt;{astNodeName},&quot;_methods[] = {\n&quot;;
-
-
-    print AG_ZEND_CLASS_ENTRY &quot;zend_class_entry *&quot;,$node-&gt;{astNodeName},&quot;_ce_ptr;\n&quot;;
-    print AG_CONFIGM4 &quot;\tqt/classes/&quot;,lc($node-&gt;{astNodeName}),&quot;.cpp \\ \n&quot;;
-    print AG_EXTERN_ZEND_CLASS_ENTRY &quot;extern zend_class_entry *&quot;,$node-&gt;{astNodeName},&quot;_ce_ptr;\n&quot;;
-    print AG_EXTERN_ZEND_CLASS_ENTRY &quot;void \t_register_&quot;,$node-&gt;{astNodeName},&quot;();\n&quot;;
-
-
-    print PHP_QT_MINIT &quot;\n\t_register_&quot;,$node-&gt;{astNodeName},&quot;(TSRMLS_C);\n&quot;;
-    print AG_QT_MINIT &quot;\n\t_register_&quot;,$node-&gt;{astNodeName},&quot;(TSRMLS_C);\n&quot;;
-
-
-	# ancestors
-	my @ancestors = ();
-	Iter::Ancestors( $node, $rootnode, undef, undef,
-		sub { # print
-			my ( $ances, $name, $type, $template ) = @_;
-			push @ancestors, $name;
-			},
-			undef
-		);
-
-	if ( $#ancestors &lt; 0 ) {
-# INTERFACE
-		if ( kalyptusDataDict::interfacemap($node-&gt;{astNodeName}) ne () ) {
-			$file = &quot;$outputdir/&quot;.join(&quot;__&quot;, kdocAstUtil::heritage($node)).&quot;.cpp&quot;;
-			my $interfaceName = kalyptusDataDict::interfacemap($node-&gt;{astNodeName});
-			$file =~ s/$node-&gt;{astNodeName}/$interfaceName/;
-			open( INTERFACE, &quot;&gt;$file&quot; ) || die &quot;Couldn't create $file\n&quot;;
-			print INTERFACE &quot;// &quot;, kalyptusDataDict::interfacemap($node-&gt;{astNodeName}), &quot;.cpp - &quot;, kalyptusDataDict::interfacemap($node-&gt;{astNodeName}), &quot; PHP implementation.&quot;;
-			print INTERFACE $docTop;	# header
-print INTERFACE &quot;
-/*
- * PHP-Qt - The PHP language bindings for Qt
- *
- * Copyright (C) 2005
- * Thomas Moenicke &lt;tm\@ippfp.org&gt;,
- * Jean-Luc Gyger &lt;jean_luc.gyger\@freesurf.ch&gt;
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include &lt;iostream&gt;
-using namespace std;
-
-#include \&quot;../php_qt.h\&quot;
-&quot;;
-		} # ancestors &lt; 0
-
-#        print CLASS &quot;\n#include &lt;&quot;,$node-&gt;{astNodeName},&quot;&gt;\n\n&quot;;
-
-# CLASS
-	} else {
-
-#        print CLASS &quot;\n#include &lt;&quot;,$node-&gt;{astNodeName},&quot;&gt;\n\n&quot;;
-        print ZEND_PHP_QT &quot;\n\n/* $node-&gt;{astNodeName} */&quot;;
-
-	}
-# JNISOURCE?
-	Iter::MembersByType ( $node,
-		sub { print CLASS &quot;&quot;, $_[0], &quot;&quot;; print JNISOURCE &quot;&quot;, $_[0], &quot;&quot;;  },
-		sub {	my ($node, $kid ) = @_;
-
-                 generateClassMethodForEnum( $node, $kid );
-               },
-		sub { print CLASS &quot;&quot;; print JNISOURCE &quot;&quot;; }
-	);
-
-	Iter::MembersByType ( $node,
-		sub { print CLASS &quot;&quot;, $_[0], &quot;&quot;; print CLASS &quot;&quot;, $_[0], &quot;&quot;;  },
-		sub {	my ($node, $kid ) = @_;
-            if ($kid-&gt;{NodeType} eq &quot;property&quot;){
-                push @properties, $kid;
-            }
-        },
-		sub { print CLASS &quot;&quot;; print CLASS &quot;&quot;; }
-	);
-
-# methods
-	%functionId = ();
-	$eventHandlerCount = 0;
-
-	Iter::MembersByType ( $node,
-		sub { print CLASS &quot;&quot;, $_[0], &quot;&quot;; print CLASS &quot;&quot;, $_[0], &quot;&quot;; },
-		sub {	my ($node, $kid ) = @_;
-                               listMember( $node, $kid );
-                         },
-		sub { print CLASS &quot;&quot;; print CLASS &quot;&quot;; }
-	);
-
-    # traverse
-    foreach my $key (keys %methods){
-        my $node_ = $methods{ $key };
-        my @methods_ = $node_-&gt;{&quot;method&quot;};
-# group
-        my @one;
-        my @two;
-        my @three;
-        my @four;
-        my @five;
-        my @six;
-        my @seven;
-        my @eight;
-        my @nine;
-        my @ten;
-
-
-        print CLASS &quot;
-/*********************************
- *    class     &quot;,$node-&gt;{astNodeName},&quot; */\n&quot;;
-
-        my $first = 1;
-
-        foreach my $m_ (@methods_){
-# params
-            foreach my $n_ (@{$m_}){
-
-# skip destructor
-            if($n_-&gt;{ReturnType} =~ /~/){ next; }
-
-            if($first == 1){
-                $first = 0;
-                print CLASS &quot;/*
- *    function  &quot;,$n_-&gt;{astNodeName},&quot;
- *    flags:    &quot;,$n_-&gt;{Flags},&quot;
- */\n&quot;;
-#print_r($n_);
-# write class related stuff
-# check whether method is a ctor
-                if($node-&gt;{astNodeName} eq $n_-&gt;{astNodeName}){
-                    print CLASS &quot;ZEND_METHOD(&quot;,$node-&gt;{astNodeName},&quot;, __construct){\n&quot;;
-                    $n_-&gt;AddProp(&quot;ctor&quot;,&quot;ctor&quot;);
-                    print AG_ZEND_PHP_QT &quot;\nZEND_METHOD(&quot;,$node-&gt;{astNodeName},&quot;, __construct);&quot;;
-                    print AG_PHP_QT_CPP &quot;\tZEND_ME(&quot;,$node-&gt;{astNodeName},&quot;, __construct,NULL,ZEND_ACC_PUBLIC)\n&quot;;
-# normal
-                } else {
-                    print CLASS &quot;ZEND_METHOD(&quot;,$node-&gt;{astNodeName},&quot;, &quot;,$n_-&gt;{astNodeName},&quot;){\n&quot;;
-
-                    my $access = $n_-&gt;{Access};
-                    if( $n_-&gt;{Flags} =~ /s/ ){
-                        $access .= &quot;|ZEND_ACC_STATIC&quot;;
-                    }
-                    $access = uc($access);
-                    $access =~ s/_SLOTS//;
-                    $access =~ s/_SIGNALS//;
-                    print AG_PHP_QT_CPP &quot;\tZEND_ME(&quot;,$node-&gt;{astNodeName},&quot;,&quot;,$n_-&gt;{astNodeName},&quot;,NULL,ZEND_ACC_&quot;,$access,&quot;)\n&quot;;
-                    print AG_ZEND_PHP_QT &quot;\nZEND_METHOD(&quot;,$node-&gt;{astNodeName},&quot;, &quot;,$n_-&gt;{astNodeName},&quot;);&quot;;
-                }
-            }
-
-                my $count = 0;
-                foreach $b ( @{$n_-&gt;{ParamList}} ) {
-                    $count++;
-                }
-# copy
-                if($count == 0){
-                    if(!(
-                        $n_-&gt;{astNodeName} =~ /className/
-                        || $n_-&gt;{astNodeName} =~ /qt_/
-                        || $n_-&gt;{astNodeName} =~ /staticMetaObject/
-                        || $n_-&gt;{astNodeName} =~ /qObject/
-                        )
-                    ){
-                        print CLASS &quot;\tif (ZEND_NUM_ARGS() == 0){\n&quot;;
-                        print CLASS createReturn($node-&gt;{astNodeName}, $n_,&quot;&quot;);
-                        print CLASS &quot;\t}\n&quot;;
-                    }
-                } elsif($count == 1){
-                    push @one, $n_;
-                } elsif($count == 2){
-                    push @two, $n_;
-                } elsif($count == 3){
-                    push @three, $n_;
-                } elsif($count == 4){
-                    push @four, $n_;
-                } elsif($count == 5){
-                    push @five, $n_;
-                } elsif($count == 6){
-                    push @six, $n_;
-                } elsif($count == 7){
-                    push @seven, $n_;
-                } elsif($count == 8){
-                    push @eight, $n_;
-                } elsif($count == 9){
-                    push @nine, $n_;
-                } elsif($count == 10){
-                    push @ten, $n_;
-                } else {
-                    print &quot;error, too much args: &quot;,$count,&quot; &quot;,$node-&gt;{astNodeName},&quot; &quot;,$n_-&gt;{astNodeName},&quot;\n&quot;;
-                }
-            }
-
-            my %one_ = mergeEquals($node-&gt;{astNodeName}<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">,1, at one</A>);
-            print CLASS marshal($node-&gt;{astNodeName},1,%one_);
-
-            my %two_ = mergeEquals($node-&gt;{astNodeName}<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">,2, at two</A>);
-            print CLASS marshal($node-&gt;{astNodeName},2,%two_);
-
-            my %three_ = mergeEquals($node-&gt;{astNodeName}<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">,3, at three</A>);
-            print CLASS marshal($node-&gt;{astNodeName},3,%three_);
-
-            my %four_ = mergeEquals($node-&gt;{astNodeName}<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">,4, at four</A>);
-            print CLASS marshal($node-&gt;{astNodeName},4,%four_);
-
-            my %five_ = mergeEquals($node-&gt;{astNodeName}<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">,5, at five</A>);
-            print CLASS marshal($node-&gt;{astNodeName},5,%five_);
-
-            my %six_ = mergeEquals($node-&gt;{astNodeName}<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">,6, at six</A>);
-            print CLASS marshal($node-&gt;{astNodeName},6,%six_);
-
-            my %seven_ = mergeEquals($node-&gt;{astNodeName}<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">,7, at seven</A>);
-            print CLASS marshal($node-&gt;{astNodeName},7,%seven_);
-
-            my %eight_ = mergeEquals($node-&gt;{astNodeName}<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">,8, at eight</A>);
-            print CLASS marshal($node-&gt;{astNodeName},8,%eight_);
-
-            my %nine_ = mergeEquals($node-&gt;{astNodeName}<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">,9, at nine</A>);
-            print CLASS marshal($node-&gt;{astNodeName},9,%nine_);
-
-            my %ten_ = mergeEquals($node-&gt;{astNodeName}<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">,10, at ten</A>);
-            print CLASS marshal($node-&gt;{astNodeName},105,%ten_);
-
-#            print CLASS &quot;}\n&quot;; # ZEND_METHOD
-
-        }
-        print CLASS &quot;}\n&quot;;
-    }
-
-    print CLASS &quot;\n&quot;;
-
-
-# creating the constructor
-     my $function = $node-&gt;{astNodeName};
-
-#destructor
-    print CLASS &quot;\nPHP_QT_DESTRUCT(&quot;,$function,&quot;);\n\n&quot;;
-
-	close CLASS;
-	$nullctor = 0;
-
-    print AG_PHP_QT_CPP &quot;
-    {NULL,NULL,NULL}
-};\n&quot;;
-
-# inheritance
-    my $zend_inherit = $node-&gt;{astNodeName}.&quot;_ce_ptr = zend_register_internal_class(&amp;ce TSRMLS_CC);&quot;;
-    my $ancestor;
-
-    my $first = 1;
-	foreach $ancestor ( @ancestors ) {
-        if($first) {
-            $zend_inherit = $node-&gt;{astNodeName}.&quot;_ce_ptr = zend_register_internal_class_ex(&amp;ce TSRMLS_CC, &quot;.$ancestor.&quot;_ce_ptr,NULL TSRMLS_CC);\n&quot;;
-            $first = 0;
-        } else {
-           $zend_inherit .= &quot;\tzend_do_inheritance(&quot;.$node-&gt;{astNodeName}.&quot;_ce_ptr, &quot;.$ancestor.&quot;_ce_ptr TSRMLS_CC);\n&quot;;
-        }
-	}
-
-    print AG_PHP_QT_CPP &quot;
-void _register_&quot;,$node-&gt;{astNodeName},&quot;(TSRMLS_D)
-{
-    zend_class_entry ce;
-    INIT_CLASS_ENTRY(ce,\&quot;&quot;,$node-&gt;{astNodeName},&quot;\&quot;,&quot;,$node-&gt;{astNodeName},&quot;_methods);
-    &quot;,$zend_inherit,&quot;
-&quot;;
-
-	Iter::MembersByType ( $node,
-		sub { print CLASS &quot;&quot;, $_[0], &quot;&quot;; print CLASS &quot;&quot;, $_[0], &quot;&quot;;  },
-		sub {	my ($node, $kid ) = @_;
-            if ($kid-&gt;{NodeType} eq &quot;property&quot;){
-                print AG_PHP_QT_CPP
-#                    &quot;zend_declare_property_string(&quot;,$node-&gt;{astNodeName},&quot;_ce_ptr,\&quot;&quot;,$kid-&gt;{astNodeName},&quot;\&quot;,strlen(\&quot;&quot;,$kid-&gt;{astNodeName},&quot;\&quot;),\&quot;\&quot;,ZEND_ACC_PROTECTED TSRMLS_CC);&quot;;
-                     &quot;\tPHP_QT_DECLARE_PROPERTY(\&quot;$kid-&gt;{astNodeName}\&quot;);\n&quot;;
-
-            }
-        },
-		sub { print CLASS &quot;&quot;; print JNISOURCE &quot;&quot;; }
-	);
-
-    print AG_PHP_QT_CPP &quot;
-}\n&quot;;
-
-
-
-	if ( kalyptusDataDict::interfacemap($node-&gt;{astNodeName}) ne () ) {
-		close INTERFACE;
-    }
-
-    undef @properties;
-    undef @functions;
-    undef @constructors;
-    undef %methods;
-}
-
-# for every node
-sub listMember
-{
-	my( $class, $m, $ancestorCount) = @_;
-	my $name;
-    my $function;
-	my $PHPaccess;
-	my $PHPparams;
-    my $pCount;
-
-    my @ctor_params;
-	my $returnType;
-
-	$name = $m-&gt;{astNodeName} ;
-	my $type = $m-&gt;{NodeType};
-	my $docnode = $m-&gt;{DocNode};
-
-	if ( $m-&gt;{ReturnType} =~ /~/ ) {
-		$name = &quot;~&quot;.$name;
-	}
-
-    $function = $name;
-
-	$function =~ s/~//;
-
-	if( $type eq &quot;method&quot; &amp;&amp; $m-&gt;{Access} ne &quot;private&quot; &amp;&amp; $m-&gt;{Access} ne &quot;private_slots&quot; &amp;&amp; $m-&gt;{Access} ne &quot;signals&quot; ) {
-		if ( $m-&gt;{ReturnType} =~ /[&lt;&gt;]/ || $m-&gt;{Params} =~ /[&lt;&gt;]/  || $m-&gt;{Params} =~ /\.\.\./ || $m-&gt;{Params} =~ /Impl/
-				|| $m-&gt;{ReturnType} =~ /QAuBucket/ || $m-&gt;{Params} =~ /QAuBucket/
-				|| $m-&gt;{ReturnType} =~ /QMember/ || $m-&gt;{Params} =~ /QMember/   ) {
-			return;
-		}
-
-# returntype
-		$returnType = $m-&gt;{ReturnType};
-		$returnType =~ s/const\s*//;
-		$returnType =~ s/inline\s*//;
-		$returnType =~ s/\s*([,\*\&amp;])\s*/$1/;
-		$returnType =~ s/^\s*//;
-		$returnType =~ s/\s*$//;
-
-		if ( $returnType ne &quot;&quot; &amp;&amp; cplusplusToPInvoke($returnType) eq () ) {
-			$returnType =~ s/^.*::.*$/int/;
-		} else {
-			$returnType = cplusplusToPInvoke($returnType);
-		}
-
-		if ( $returnType eq &quot;RawObject&quot;) {
-			$returnType = &quot;IntPtr&quot;;
-		}
-
-		my $cparams = $m-&gt;{Params};
-		my $cplusplusparams;
-		my $pinvokeparams;
-		my $pinvokeargs;
-
-		# TODO port to $m-&gt;{ParamList}
-		$cparams =~ s/\s+/ /g;
-		$cparams =~ s/\s*([,\*\&amp;])\s*/$1 /g;
-		$cparams =~ s/^\s*void\s*$//;
-		my $argId = 0;
-		my @cargs = kdocUtil::splitUnnested(&quot;,&quot;, $cparams);
-		$cparams = &quot;&quot;;
-		foreach my $arg ( @cargs ) {
-			my $argType;
-			my $cargType;
-			my $PHPargType;
-			my $pinvokeargType;
-			if ( $arg =~ /^\s*$/ ) {
-				next;
-			}
-
-			# A '&lt;arg&gt; = &lt;value&gt;' default parameter
-			$arg =~ s/\s*([^\s].*[^\s])\s*/$1/;
-			$arg =~ s/(\w+)\[\]/\* $1/;
-			$arg =~ s/=\s*((&quot;[^\&quot;]*&quot;)|(\'.\')|(([-\w:.]*)\s*(\|\s*[-\w]*)*(\(\w*\))?))//;
-
-			if ( $arg =~ /^(.*)\s+(\w+)\s*$/ ) {
-				$argType = $1;
-				$arg = $2;
-			} else {
-				$argType = $arg;
-				$argId++;
-				$arg = &quot;arg&quot;.$argId;
-			}
-			$arg =~ s/^id$/identifier/;
-			$argType =~ s/\s*([^\s].*[^\s])\s*/$1/;
-			$argType =~ s/\s*const//g;
-			$argType =~ s/^\s*//;
-			$argType =~ s/([\*\&amp;])\s*([\*\&amp;])/$1$2/;
-			$cargType = kalyptusDataDict::ctypemap($argType);
-			$PHPargType = cplusplusToZEND($argType);
-			$pinvokeargType = cplusplusToPInvoke($argType);
-
-			if ( $PHPargType eq &quot;&quot; ) {
-				$PHPargType = $argType;
-				$PHPargType =~ s/\&amp;/\*/;
-				$PHPargType =~ s/^.*::.*$/int/;
-			}
-			if ( $pinvokeargType eq &quot;&quot; ) {
-				$pinvokeargType = $argType;
-				$pinvokeargType =~ s/\&amp;/\*/;
-				$pinvokeargType =~ s/^.*::.*$/int/;
-			}
-
-			if ( $pinvokeargType =~ /IntPtr/ ) {
-				$pinvokeargs .= &quot;$arg.Ptr, &quot;;
- 			} elsif ( $PHPargType =~ /\./ ) {
-				$pinvokeargs .= &quot;($pinvokeargType)$arg, &quot;;
-			} else {
-				$pinvokeargs .= &quot;$arg, &quot;;
-			}
-
-			if ( $pinvokeargType =~ /RawObject/ ) {
-				 $pinvokeargType =~ s/RawObject/IntPtr/;
-			}
-
-# save these attributes for ctor
-            @ctor_params[$pCount++] = [$PHPargType,$arg,$argType];
-
-            $PHPparams .= &quot;$PHPargType $arg, &quot;;
-            $pinvokeparams .= &quot;$pinvokeargType $arg, &quot;;
-		}
-		$cparams =~ s/, $//;
-		$cplusplusparams =~ s/, $//;
-		$PHPparams =~ s/, $//;
-		$pinvokeparams =~ s/, $//;
-		$pinvokeargs =~ s/, $//;
-
-		my $flags = $m-&gt;{Flags};
-
-		if ( !defined $flags ) {
-			warn &quot;Method &quot;.$m-&gt;{astNodeName}.  &quot; has no flags\n&quot;;
-		}
-
-
-		my $extra = &quot;&quot;;
-		$extra .= &quot;static &quot; if $flags =~ &quot;s&quot;;
-
-		if ( $name =~ /operator/  ) {
-			return;
-		}
-
-		if ( $m-&gt;{Access} =~ /protected/ &amp;&amp; $name ne $class-&gt;{astNodeName}  ) {
-			if ( $class-&gt;{Pure} ) {
-				return;
-			}
-
-			$name = &quot;protected_&quot;.$name;
-		}
-
-		$m-&gt;{Access} =~ /([^_]*)(.*)?\s*/;
-		$PHPaccess = $1;
-		if ( $extra =~ /static/ ) {
-			$PHPaccess .= &quot; static&quot;;
-		}
-
-		if ( $name eq $class-&gt;{astNodeName} &amp;&amp; $class-&gt;{Pure} ) {
-			return;
-		}
-
-		if ( defined $docnode ) {
-			if ( defined $docnode-&gt;{Text} ) {
-				print CLASS &quot;\n/** &quot;;
-				my $node;
-				my $line;
-				foreach $node ( @{$docnode-&gt;{Text}} ) {
-					next if $node-&gt;{NodeType} ne &quot;DocText&quot;;
-					$line = $node-&gt;{astNodeName};
-					print CLASS $line, &quot;\n&quot;;
-				}
-				print CLASS &quot;*/\n&quot;;
-			}
-		}
-
-		#This is to make sure we have no duplicate methods...
-		my $currentmethod .= &quot;$name $returnType $PHPparams&quot;;
-		my $pastmethod .= &quot;$pastname $pastreturn $pastparams&quot;;
-
-        if($currentmethod ne $pastmethod) {
-            if ( $name =~ /.*Event$/ ) {
-                return;
-            }
-# prepare arguments
-            mergeNumbers($class,$m);
-	    }
-	}
-	#Part of the duplicate methods check.
-	$pastname = $name;
-	$pastreturn = $returnType;
-	$pastparams = $PHPparams;
-
-	$PHPparams = &quot;&quot;;
-
-}
-
-sub generateClassMethodForEnum
-{
-	my( $class, $m ) = @_;
-	my $enum = $m-&gt;{astNodeName};
-	my $PHPaccess;
-
-	$m-&gt;{Access} =~ /([^_]*)(.*)?\s*/;
-	$PHPaccess = $1;
-
-	if( $m-&gt;{NodeType} eq &quot;enum&quot; ) {
-		my $enum = $m-&gt;{astNodeName};
-		my @enums = split(&quot;,&quot;, $m-&gt;{Params});
-		my $enumCount = 0;
-
-		if($enum ne &quot; &quot;) {
-			print CLASS &quot;\n\n/*\t\t$PHPaccess enum&quot;, $enum,&quot;:long {&quot;;
-
-			foreach my $enum_ ( @enums ) {
-				$enum_ =~ s/\s//g;
-				$enum_ =~ s/::/./g;
-				if($#enums == $enumCount){
-
-					if ( $enum_ =~ /(.*)=(.*)/ ) {
-						print CLASS &quot;\n\t\t\t$1 = $2&quot;;
-					} else {
-						print CLASS &quot;\n\t\t\t$enum = $enumCount&quot;;
-					}
-
-				} else {
-
-					if ( $enum_ =~ /(.*)=(.*)/ ) {
-						print CLASS &quot;\n\t\t\t$1 = $2,&quot;;
-					} else {
-						print CLASS &quot;\n\t\t\t$enum = $enumCount,&quot;;
-					}
-
-				}
-#                $enum =~ s/=//g;
-                my @constant = split(/=/,$enum_);
-
-# what to skip?
-                    if(!(
-                            $class-&gt;{astNodeName} =~ /QContextMenuEvent/
-                        ||  $class-&gt;{astNodeName} =~ /QInputMethodEvent/
-                        ||  $class-&gt;{astNodeName} =~ /QPainter/
-                        ||  $class-&gt;{astNodeName} =~ /QTabletEvent/
-                    )){
-                        print AG_QT_MINIT &quot;\t  REGISTER_LONG_CONSTANT(\&quot;&quot;,uc($class-&gt;{astNodeName}),&quot;_&quot;,uc($enum),&quot;_&quot;,uc($constant[0]),&quot;\&quot;, &quot;,$class-&gt;{astNodeName},&quot;::&quot;,$constant[0],&quot;, CONST_CS | CONST_PERSISTENT);\n&quot;;
-                        $enumCount++;
-                    }
-			}
-
-			print CLASS &quot;\n\t\t}\n*/&quot;;
-		}
-	}
-}
-
-sub print_r
-{
-    my ( $cnode ) = @_;
-
-    my @n = Ast::GetProps($cnode);
-    foreach $a ( @n ) {
-        print CLASS &quot;&gt;&quot;,$a,&quot;: &quot;,$cnode-&gt;{$a},&quot;\n&quot;;
-    }
-}
-
-# groups arguments regarding argument count
-
-sub mergeNumbers
-{
-	my ( $class, $cnode )  = @_;
-
-    my $functionname = $cnode-&gt;{astNodeName};
-    my $classname = $class-&gt;{astNodeName};
-
-    foreach my $key ( keys %methods ) {
-		if ( $key eq $functionname ) {
-            #add to existing
-			$methods{ $key }-&gt;AddPropList(&quot;method&quot;, $cnode);
-			return;
-		}
-    }
-
-    # add new
-    $methods{ $functionname } = Ast::New( $functionname );
-    $methods{ $functionname }-&gt;AddPropList(&quot;method&quot;,$cnode);
-
-}
-
-# finds equal strings and groups them
-
-sub mergeEquals {
-
-    my ($classname, $count, @args) = @_;
-    # find all equal strings
-
-    my @param_check;
-    my %tmp;
-    my $skip = 0;       # helping
-# create all strings
-    foreach my $method (@args){
-        my $paramstring = &quot;&quot;;
-        foreach my $param ( @{$method-&gt;{ParamList}} ) {
-
-# add cast type
-            $param-&gt;AddProp(&quot;cast&quot;,$param-&gt;{ArgType});
-            $param-&gt;{cast} = checkCast($param-&gt;{cast});
-
-            $param = checkEnum($param);
-
-# TODO: test it with QByteArray
-            if ( $param-&gt;{ArgType} =~ /const char/ ) {
-                $paramstring .= &quot;s&quot;;
-            } elsif ( $param-&gt;{ArgType} =~ /char/ ) {
-                $paramstring .= &quot;l&quot;;
-            } elsif ( $param-&gt;{ArgType} =~ /int/ ) {
-                $paramstring .= &quot;l&quot;;
-            } elsif ( $param-&gt;{ArgType} =~ /double/ ) {
-                $paramstring .= &quot;l&quot;;
-            } elsif ( $param-&gt;{ArgType} =~ /bool/ ) {
-                $paramstring .= &quot;b&quot;;
-            } else {
-                $paramstring .= &quot;o&quot;;
-            }
-        }
-
-        push @param_check, $paramstring;
-
-# check if already available
-        foreach my $key ( keys %tmp ) {
-# yes: add
-            if ( $key eq $paramstring ) {
-                #add to existing
-                $tmp{ $key }-&gt;AddPropList(&quot;params&quot;, $method);
-                $skip = 1;
-                last;
-            }
-        }
-# no: create new
-        if($skip == 0){
-            $tmp{ $paramstring } = Ast::New( $paramstring );
-            $tmp{ $paramstring }-&gt;AddPropList(&quot;params&quot;,$method);
-        }
-        $skip = 0;
-# add method name
-        $tmp{ $paramstring }-&gt;AddProp(&quot;methodname&quot;,$method-&gt;{astNodeName});
-        $tmp{ $paramstring }-&gt;AddProp(&quot;ReturnType&quot;,$method-&gt;{ReturnType});
-        $tmp{ $paramstring }-&gt;AddProp(&quot;Access&quot;,$method-&gt;{Access});
-        $tmp{ $paramstring }-&gt;AddProp(&quot;Flags&quot;,$method-&gt;{Flags});
-
-        if($classname eq $tmp{ $paramstring }-&gt;{methodname} ) {
-            $tmp{ $paramstring }-&gt;AddProp(&quot;ctor&quot;,&quot;ctor&quot;);
-        }
-
-    }
-    
-    return %tmp;
-
-}
-
-# group by count and strings
-
-sub marshal {
-
-    my ($classname, $count, %args) = @_;
-    my $return;
-
-    my $not_empty = %args;
-    if($not_empty){
-        $return .= &quot;\n\tif (ZEND_NUM_ARGS() == &quot;.$count.&quot;){\n&quot;;
-    }
-
-    my $c = 0;                  # helping variable
-    my $run = 0;
-
-# node is the method
-    foreach my $key (keys %args){
-        # docu
-#        foreach $b ( @{$method-&gt;{ParamList}} ) {
-#            $return .= &quot; *    \@param   &quot;.$b-&gt;{ArgType}.&quot;\n&quot;;
-#            $return .= &quot; */\n&quot;;
-#        }
-
-# handle arguments at first
-
-        # initialize vars and agruments for zend_parse_parameters
-        my $d = 0;                  # helping variable
-        my $paratype;               # for zend
-        my $shortstring = &quot;\&quot;&quot;;    # short string for zend function
-        my $param_zend_function;    # parameter for zend function
-        my @objects;                # object stack
-        my $method = $args{$key};   # helping
-# skip qt_xxx
-        if(
-            $method-&gt;{methodname} =~ /qt_/
-            || $method-&gt;{methodname} =~ /className/
-        ){
-            last;
-        }
-
-        my $object_selection = &quot;&quot;;
-        my $tmp_count = 0;          # helping
-        my $c__ = $c;                # ugly
-        my $param_comment = &quot;\t\t/* &quot;;
-
-# identical strings grouped
-        $return .= &quot;\t\t/* &quot;.$key.&quot; &quot;.$method-&gt;{Access}.&quot;*/\n&quot;;
-
-# skip protected method
-        if($method-&gt;{Access} eq &quot;protected&quot;){
-            next;
-        }
-
-        $run = $key.&quot;_&quot;;
-# first parameters are static, the others coincides with this
-# exception: objects
-        my $params = @{$method-&gt;{params}}[0];
-
-# parse the first parameters
-        foreach my $first_param (@{$params-&gt;{ParamList}})  {
-
-# just a comment
-            $param_comment .= $first_param-&gt;{ArgType}.&quot; &quot;.$first_param-&gt;{ArgName}.&quot;, &quot;;
-
-            # comma for param_zend_function params
-            if($d &gt; 0){
-                $param_zend_function .= &quot; ,&quot;;
-            }
-
-            $first_param = checkEnum($first_param);
-
-            # the types
-# char
-            if ( $first_param-&gt;{ArgType} =~ /const char/ ) {
-                $return .= &quot;\t\tchar* var_&quot;.$run.$c__.&quot;;   // default: &quot;.$first_param-&gt;{DefaultValue}.&quot;\n&quot;;
-                $return .= &quot;\t\tint len_&quot;.$run.$c__.&quot;;\n\n&quot;;
-
-                $paratype .= &quot;, &amp;var_&quot;.$run.$c__.&quot;, len_&quot;.$run.$c__;
-                $param_zend_function .= &quot; (&quot;.$first_param-&gt;{ArgType}.&quot;) var_&quot;.$run.$c__;
-                $shortstring .= &quot;s&quot;;
-# int
-            } elsif (
-                $first_param-&gt;{ArgType} =~ /int/
-                || $first_param-&gt;{ArgType} =~ /char/
-                || $first_param-&gt;{ArgType} =~ /short/
-                || $first_param-&gt;{ArgType} =~ /double/
-            ) {
-
-                $return .= &quot;\t\tlong var_&quot;.$run.$c__.&quot;;    // default: &quot;.$first_param-&gt;{DefaultValue}.&quot;\n&quot;;
-
-                $paratype .= &quot;, &amp;var_&quot;.$run.$c__;
-# cast if param is an enum
-                if(defined $first_param-&gt;{cast}){
-                    $param_zend_function .= &quot;(&quot;.$first_param-&gt;{cast}.&quot;) var_&quot;.$run.$c__;
-                } else {
-                    $param_zend_function .= &quot;(&quot;.$first_param-&gt;{ArgType}.&quot;) var_&quot;.$run.$c__;
-                }
-                $shortstring .= &quot;l&quot;;
-# bool
-            } elsif ( $first_param-&gt;{ArgType} =~ /bool/ ) {
-                $return .= &quot;\t\tbool var_&quot;.$run.$c__.&quot;;   // _default: &quot;.$first_param-&gt;{DefaultValue}.&quot;\n&quot;;
-
-                $paratype .= &quot;, &amp;var_&quot;.$run.$c__;
-                $param_zend_function .= &quot;(&quot;.$first_param-&gt;{ArgType}.&quot;) var_&quot;.$run.$c__;
-                $shortstring .= &quot;b&quot;;
-# objects
-            } else {
-# while overloading, only one object will be created, query for name
-
-                $return .= &quot;\t\tzval* z_var_&quot;.$run.$c__.&quot;;   // default: &quot;.$first_param-&gt;{DefaultValue}.&quot;\n&quot;;
-
-                $paratype .= &quot;, &amp;z_var_&quot;.$run.$c__;
-                $param_zend_function .= &quot;() var_o_&quot;.$c__; # deprecated
-                $shortstring .= &quot;o&quot;;
-                push @objects, &quot;var_&quot;.$run.$c__;   # ?
-                # name query
-                $object_selection .= &quot;\t\t\tQString tmp_&quot;.$run.$tmp_count++.&quot;(var_&quot;.$run.$c__.&quot;-&gt;metaObject()-&gt;className());\n&quot;;
-            }
-            if(exists $first_param-&gt;{DefaultValue} != &quot;&quot;){
-                $shortstring .= &quot;|&quot;;
-            }
-            $c__++;
-            $d++;
-        }
-        $return .= &quot;\n&quot;;
-# add additional objects
-        $param_comment .= &quot; */\n&quot;;
-        $return .= $param_comment;
-
-        foreach my $params (@{$method-&gt;{params}}){
-
-            my $skip_first = 1;
-            $tmp_count = 0;
-#            $c = $c__;
-# found in qpainter
-            $c__ = $c;
-            my $c_ = 0;
-
-# skip first, this was already created
-            my $object_test;
-            my $object_call;
-            my $obj_first = 1;
-# parse the rest
-            foreach my $param ( @{$params-&gt;{ParamList}} ) {
-
-                $param = checkEnum($param);
-
-                if($skip_first == 1){
-                    $object_selection .= &quot;\t\t\t&quot;;
-                    $skip_first = 0;
-                } else {
-                    $object_call .= &quot;, &quot;;
-                }
-
-# char
-                if ( $param-&gt;{ArgType} =~ /char/ ) {
-                    $object_call .= &quot;(&quot;.$param-&gt;{ArgType}.&quot;) var_&quot;.$run.$c__;
-# int
-# short
-# double
-                } elsif (
-                    $param-&gt;{ArgType} =~ /int/
-                    || $param-&gt;{ArgType} =~ /short/
-                    || $param-&gt;{ArgType} =~ /double/
-                ) {
-                    if(defined $param-&gt;{cast}){
-                        $object_call .= &quot;(&quot;.$param-&gt;{cast}.&quot;) var_&quot;.$run.$c__;
-                    } else {
-                        $object_call .= &quot;(&quot;.$param-&gt;{ArgType}.&quot;) var_&quot;.$run.$c__;
-                    }
-# bool
-                } elsif ( $param-&gt;{ArgType} =~ /bool/ ) {
-                    $object_call .= &quot;(&quot;.$param-&gt;{ArgType}.&quot;) var_&quot;.$run.$c__;
-# object
-                } else {
-                    if($obj_first == 1){
-                        $obj_first = 0;
-                    } else {
-                        $object_test .= &quot; &amp;&amp; &quot;;
-                    }
-# temporarly
-                    my $objectname = $param-&gt;{ArgType};
-                    $objectname =~ s/[*&amp;]//;
-                    $object_test .= &quot;tmp_&quot;.$run.$tmp_count++.&quot; == \&quot;&quot;.checkCast($objectname).&quot;\&quot;&quot;;
-                    $object_call .= &quot;(&quot;.checkCast($param-&gt;{ArgType}).&quot;) &quot;.$objects[$c_++];
-
-                }
-                $c__++;
-            } # foreach param
-
-            if(!$obj_first){
-                $object_selection .= &quot;\n\t\t\tif(&quot;.$object_test.&quot;) {\n&quot;;
-                $object_selection .= &quot;\t&quot;.createReturn($classname, $method, $object_call);
-                $object_selection .=  &quot;\t\t\t}&quot;;
-            }
-        } # foreach params
-
-        $shortstring .= &quot;\&quot;&quot;;
-
-# write zend_parse_parameters method
-        $return .= &quot;\t\tif(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;.$shortstring.$paratype.&quot;) == SUCCESS) {\n&quot;;
-# only if ctor
-        if(!($method-&gt;{ctor} eq &quot;ctor&quot;)) {
-            $return .= &quot;\t\t\t&quot;.$classname.&quot; *obj = (&quot;.$classname.&quot;*) PHP_QT_FETCH();\n&quot;;
-        }
-
-# objects as return type
-        my $obj;
-        my $objc = 0;
-        foreach $obj ( @objects ) {
-            $return .= &quot;\t\t\tQObject* &quot;.$obj.&quot; = (QObject*) php_qt_fetch(z_&quot;.$obj.&quot;);\n&quot;;
-            $objc++;
-        }
-
-# add object handling
-        my $not_empty = %args;
-        if($not_empty){
-            $return .= &quot;\n&quot;.$object_selection;
-            undef $object_selection;
-            $return .= &quot;\n&quot;;
-# $c counts objects, if there is no object the return mechanism has to be created
-            if($objc == 0){
-                $return .= createReturn($classname, $method, $param_zend_function);
-            }
-            if($c &gt; 0){
-                $return .= &quot;\t\t}\n&quot;;
-# break run if there are objects
-                next;
-            }
-        }
-
-# return handling
-#        $return .= createReturn($classname, $method, $param_zend_function);
-
-        $return .= &quot;\t\t}\n&quot;;
-        $tmp_count=0;
-
-    } # foreach args
-
-    my $not_empty = %args;
-    if($not_empty){
-        $return .= &quot;\t}\n&quot;;
-    }
-
-    return $return;
-}
-
-sub createReturn {
-
-    my ($classname, $method, $param_zend_function) = @_;
-    my $return;
-
-# sometimes it goes wrong
-# it is more secure to re-check that
-    if($classname eq $method-&gt;{astNodeName} ) {
-        $method-&gt;AddProp(&quot;ctor&quot;,&quot;ctor&quot;);
-    }
-
-
-# constructor
-    if($method-&gt;{ctor} eq &quot;ctor&quot;){
-        $return .= &quot;\t\t\t&quot;.$classname.&quot; *&quot;.$classname.&quot;_ptr = new &quot;.$classname.&quot;(&quot;.$param_zend_function.&quot;);\n&quot;;
-        $return .= &quot;\t\t\tPHP_QT_REGISTER(&quot;.$classname.&quot;_ptr);\n&quot;;
-# php class members here
-        $return .= &quot;\t\t\tRETURN_NULL();\n&quot;;
-        return $return;
-    }
-
-# no arguments, no object created
-    if($param_zend_function eq &quot;&quot;){
-        $return .= &quot;\t\t\t&quot;.$classname.&quot; *obj = (&quot;.$classname.&quot;*) PHP_QT_FETCH();\n&quot;;
-    }
-
-    my $methodname;
-    if (defined $method-&gt;{methodname}) {
-        $methodname = $method-&gt;{methodname}
-    } else {
-        $methodname = $method-&gt;{astNodeName} if defined $method-&gt;{astNodeName};
-    }
-
-    my $returntype = $method-&gt;{ReturnType};
-
-    my $zend_return_type = cplusplusToZEND($returntype);
-
-# handle return value here
-# if no return type specified
-        if ( $zend_return_type eq &quot;NULL&quot; || !defined $zend_return_type) {
-            $return .=  &quot;\t\t\tobj-&gt;&quot;.$methodname.&quot;(&quot;.$param_zend_function.&quot;);\n&quot;;
-            $return .=  &quot;\t\t\tRETURN_NULL();\n&quot;;
-# const char*
-        } elsif ( $zend_return_type =~ /char/ ){
-            $return .=  &quot;\t\t\tRETURN_STRING((char*) obj-&gt;&quot;.$methodname.&quot;(&quot;.$param_zend_function.&quot;), 1);\n&quot; if defined $zend_return_type;
-        } elsif ( $zend_return_type =~ /byte/ ) {
-            $return .= &quot;\t\t// bytearray, skipped\n&quot;;
-            $return .= &quot;\t\tRETURN_NULL();\n&quot;;
-#if return type is an object
-        } elsif ( $zend_return_type =~ /zval/ ) {
-#        TODO: consider 'const',
-#        and non-pointer types, pointer types
-            $return .=  &quot;\t\t\t&quot;.checkCast($returntype).&quot; return_object = (&quot;.checkCast($returntype).&quot;) obj-&gt;&quot;.$methodname.&quot;(&quot;.$param_zend_function.&quot;);\n&quot;;
-            $return .=  &quot;\t\t\t\tzend_class_entry *ce;                                   \n&quot;;
-            $return .=  &quot;\t\t\t\tobject_init_ex(return_value, &quot;.$classname.&quot;_ce_ptr);     \n&quot;;
-            $return .=  &quot;\t\t\t\tzend_rsrc_list_entry le;                            \n&quot;;
-            $return .=  &quot;\t\t\t\tle.ptr = (void*) &amp;return_object;                                       \n&quot;;
-            $return .=  &quot;\t\t\t\tphp_qt_register(return_value,le);                   \n&quot;;
-            $return .=  &quot;\t\t\t\treturn;                                             \n&quot;;
-#simple types
-        } else {
-            $return .=  &quot;\t\t\tRETURN_&quot;.uc($zend_return_type).&quot;(obj-&gt;&quot;.$methodname.&quot;(&quot;.$param_zend_function.&quot;));\n&quot; if defined $zend_return_type;
-        }
-
-    if(!defined $zend_return_type){
-        $return .= &quot;&quot;;
-    }
-
-    return $return;
-
-}
-
-sub checkEnum(){
-    my ($param) = @_;
-
-        my $ArgType = kalyptusDataDict::ctypemap($param-&gt;{ArgType});
-
-    if(!($param-&gt;{ArgType} =~ /qt_/)){
-        if($ArgType eq &quot;&quot;){
-            $ArgType = &quot;int&quot;;
-            $ArgType = $param-&gt;{ArgType};
-        }
-
-        $param-&gt;{ArgType} = $ArgType;
-    }
-
-    return $param;
-}
-
-# check additional header files
-sub checkIncludes(){
-    my ($class) = @_;
-    my $return;
-
-    if($class-&gt;{astNodeName} eq &quot;QFont&quot;) {
-        $return .= &quot;#include &lt;QStringList&gt;\n&quot;;
-    }
-    if($class-&gt;{astNodeName} eq &quot;QPainter&quot;) {
-        $return .= &quot;#include &lt;QPainterPath&gt;\n&quot;;
-    }
-
-    return $return;
-
-}
-
-sub checkCast(){
-
-    my ($returntype) = @_;
-
-    if($returntype eq 'Style') {
-        $returntype = &quot;QFont::Style&quot;;
-    }
-    if($returntype eq 'StyleHint') {
-        $returntype = &quot;QFont::StyleHint&quot;;
-    }
-    if($returntype eq 'StyleStrategy') {
-        $returntype = &quot;QFont::StyleStrategy&quot;;
-    }
-    if($returntype eq 'CompositionMode') {
-        $returntype = &quot;QPainter::CompositionMode&quot;;
-    }
-    if($returntype eq 'RenderHint') {
-        $returntype = &quot;QPainter::RenderHint&quot;;
-    }
-
-    $returntype =~ s/qt_//;
-
-    return $returntype;
-}
-
-
-1;
-


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000088.html">[Php-qt-svn] r244 - trunk/tutorials/t7
</A></li>
	<LI>Next message: <A HREF="000090.html">[Php-qt-svn] r246 - trunk/tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#89">[ date ]</a>
              <a href="thread.html#89">[ thread ]</a>
              <a href="subject.html#89">[ subject ]</a>
              <a href="author.html#89">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/php-qt-svn">More information about the Php-qt-svn
mailing list</a><br>
</body></html>
