<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Php-qt-svn] r246 - trunk/tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/php-qt-svn/2006-May/index.html" >
   <LINK REL="made" HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r246%20-%20trunk/tools&In-Reply-To=%3C200605241531.k4OFVTvL031847%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000089.html">
   <LINK REL="Next"  HREF="000091.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Php-qt-svn] r246 - trunk/tools</H1>
    <B>tm243 at BerliOS</B> 
    <A HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r246%20-%20trunk/tools&In-Reply-To=%3C200605241531.k4OFVTvL031847%40sheep.berlios.de%3E"
       TITLE="[Php-qt-svn] r246 - trunk/tools">tm243 at berlios.de
       </A><BR>
    <I>Wed May 24 17:31:29 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000089.html">[Php-qt-svn] r245 - trunk/tools
</A></li>
        <LI>Next message: <A HREF="000091.html">[Php-qt-svn] r247 - trunk/tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#90">[ date ]</a>
              <a href="thread.html#90">[ thread ]</a>
              <a href="subject.html#90">[ subject ]</a>
              <a href="author.html#90">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tm243
Date: 2006-05-24 17:31:29 +0200 (Wed, 24 May 2006)
New Revision: 246

Added:
   trunk/tools/kalyptusCxxToPHP.pm
Log:
php extension for kalyptus rewritten.

Added: trunk/tools/kalyptusCxxToPHP.pm
===================================================================
--- trunk/tools/kalyptusCxxToPHP.pm	2006-05-24 15:30:37 UTC (rev 245)
+++ trunk/tools/kalyptusCxxToPHP.pm	2006-05-24 15:31:29 UTC (rev 246)
@@ -0,0 +1,907 @@
+#***************************************************************************
+#    copyright            : (C) 2006 Thomas Moenicke
+#    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>
+#    author               : Thomas Moenicke
+#***************************************************************************/
+
+#/***************************************************************************
+# *                                                                         *
+# *   This program is free software; you can redistribute it and/or modify  *
+# *   it under the terms of the GNU General Public License as published by  *
+# *   the Free Software Foundation; either version 2 of the License, or     *
+# *   (at your option) any later version.                                   *
+# *                                                                         *
+#***************************************************************************/
+
+# sub cplusplusToZEND               $cplusplusType
+# sub cplusplusToZENDType           $cplusplusType
+# sub cplusplusToPInvoke            $cplusplusType
+# sub cplusplusToMacro              $class, $cnode
+
+# sub writeDoc                      $lib, $rootnode, $outputdir, $opt
+# sub writeClassDoc                 $node
+
+
+package kalyptusCxxToPHP;
+
+use File::Path;
+use File::Basename;
+
+use Carp;
+use Ast;
+use kdocAstUtil;
+use kdocUtil;
+use Iter;
+use kalyptusDataDict;
+
+#use strict;
+no strict &quot;subs&quot;;
+
+use vars qw/
+    @clist
+    $host $who $now $gentext %functionId $docTop
+	$lib $rootnode $outputdir $opt $debug $typeprefix $eventHandlerCount
+	$pastaccess $pastname $pastreturn $pastparams $nullctor $ctorCount @properties @functions @constructors
+
+    %methods
+
+    $classname;
+    *CLASS
+    *HEADER
+
+    *AG_ZEND_CLASS_ENTRY
+    *AG_EXTERN_ZEND_CLASS_ENTRY
+    *AG_VOID_REGISTER
+    *AG_ZEND_PHP_QT
+    *AG_CONFIGM4
+    *AG_QT_MINIT
+    *AG_PHP_QT_CPP
+
+    *QTCTYPES
+    *KDETYPES
+    /;
+
+
+BEGIN
+{
+    @clist = ();
+
+    # Page footer
+
+	$who = kdocUtil::userName();
+	$host = kdocUtil::hostName();
+	$now = localtime;
+	$gentext = &quot;$who using kalyptus $main::Version.&quot;;
+
+	$docTop =&lt;&lt;EOF
+ * begin           : $now
+ * generated by    : $gentext
+ */
+EOF
+}
+
+#   for all header files
+
+#   $lib            not used
+#   $rootnode       rootnode of Ast
+#   $outputdir      string of dirname
+#   $opt            not used
+
+sub writeDoc
+{
+	my ( $lib, $rootnode, $outputdir_, $opt ) = @_;
+
+    $outputdir = $outputdir_;
+
+#    kdocAstUtil::dumpAst($rootnode);
+
+    openAllFiles();
+
+	# Document all compound nodes
+	Iter::LocalCompounds( $rootnode, sub { writeClassDoc( shift ); } );
+
+    closeAllFiles();
+
+}
+
+# for one class
+
+sub writeClassDoc
+{
+	my( $class ) = @_;
+    $classname = $class-&gt;{astNodeName};
+
+    openClassFile($class);
+
+    checkIncludes($class);
+    writeAllFiles($class);
+
+    DerivedClass($class);
+
+    handleAllMethods($class);
+    Inheritance($class);
+
+    closeClassFile();
+
+}
+
+# all methods of this class
+
+sub handleAllMethods
+{
+    my ($class) = @_;
+
+    %methods = ();
+
+	Iter::MembersByType ($class,sub{},
+		sub
+        {
+            my ($class, $kid ) = @_;
+            if ($kid-&gt;{NodeType} eq &quot;property&quot; )
+            {
+                push @properties, $kid;
+            }
+            if($kid-&gt;{NodeType} eq &quot;method&quot;)
+            {
+                mergeMethods($kid);
+            }
+        },sub {}
+	);
+
+    foreach my $key (keys %methods)
+    {
+        $method = %methods-&gt;{$key};
+
+        writeMethodDoc($method);
+        handleMethod($method);
+
+    }
+}
+
+# all args of this method
+#
+# every method has a list of arguments from overloaded methods
+#
+sub handleMethod
+{
+    my ( $method ) = @_;
+
+    my $methodname = $method-&gt;{astNodeName};
+    $methodname = &quot;__construct&quot; if($methodname eq $classname);
+
+    print CLASS &quot;ZEND_METHOD(&quot;.$classname.&quot;,&quot;.$methodname.&quot;){&quot;;
+    print CLASS &quot;PHP_QT_FETCH_ARGS();&quot;;
+
+    my $first = &quot;true&quot;;
+    # get _all_ arg
+    ARGLIST: foreach my $overloadedmethod (@{$method-&gt;{&quot;argList&quot;}})
+    {
+        if($first eq &quot;true&quot;){
+            $first = &quot;false&quot;;
+            next;
+        }
+
+        my @cargs = kdocUtil::splitUnnested(&quot;,&quot;, $overloadedmethod-&gt;{Params});
+        my $params;     # collect args for every try
+
+        my $zend_args_query;        # parameter for the type check statement
+        my $ce_ptr_query;           # parameter for the class check statement
+        my $count_args=0;
+        my @stack = ();             # argument stack, regular parameters
+        my @stack_optional = ();    # argument stack, optional parameters
+
+        my @ifdef_stack = ();       # object safety
+
+        # check whether agument is optional or regular
+        foreach my $cpp_arg ( @cargs ) {
+
+            if($cpp_arg =~ /=/){
+                push(@stack_optional,$cpp_arg);
+            } else {
+                push(@stack,$cpp_arg);
+            }
+        }
+
+        #
+        # all regular args
+        #
+        foreach $cpp_arg (@stack){
+
+            $params .= $cpp_arg.&quot;,&quot;; # collect args for this try
+            $zend_arg = cplusplusToZVAL($cpp_arg);
+
+            # intercept unknown types
+            if($zend_arg eq &quot;unknown&quot;){
+                print CLASS &quot;\n// notice: unknown argument &quot;.$cpp_arg.&quot;, skipped\n&quot;;
+                next ARGLIST;
+            }
+
+            $zend_args_query .= &quot; &amp;&amp; Z_TYPE_P(args[&quot;.$count_args.&quot;]) == IS_&quot;.$zend_arg;
+            if($zend_arg eq &quot;OBJECT&quot;){
+                if($count_args &gt; 1){
+                    $ce_ptr_query .= &quot;&amp;&amp; &quot;;
+                }
+                $ce_ptr_query .= &quot;Z_OBJCE_P(args[&quot;.$count_args.&quot;]) == &quot;.unwrapClassType($cpp_arg).&quot;_ce_ptr&quot;;
+                push(@ifdef_stack,unwrapClassType($cpp_arg));
+            }
+            $count_args++;
+        }
+
+        # type check
+        print CLASS &quot;\n\t///&quot;.$overloadedmethod-&gt;{Params}.&quot;\n&quot;;
+
+        # ifdef
+        print CLASS &quot;#ifdef PHP_QT_&quot;.unwrapClassType($method-&gt;{ReturnType}).&quot; // return type\n\n&quot;
+            if cplusplusToZVAL($method-&gt;{ReturnType}) eq &quot;OBJECT&quot;;
+
+        print CLASS &quot;if(ZEND_NUM_ARGS() == &quot;.$count_args.$zend_args_query.&quot;){&quot;;
+
+        # class check if object
+        if($ce_ptr_query ne &quot;&quot;){
+            print CLASS &quot;&quot;.expandIfdefs(@ifdef_stack);  # ifdef PHP_QT_QString
+            print CLASS &quot; if(&quot;.$ce_ptr_query.&quot;){&quot;;
+            handleArguments($params,$method-&gt;{ReturnType},$method-&gt;{Flags}, $methodname); # argument handling
+            print CLASS &quot;}\n&quot;;
+            print CLASS &quot;&quot;.expandEndifs(@ifdef_stack);  # endif
+
+        # simple types
+        } else {
+            handleArguments($params,$method-&gt;{ReturnType},$method-&gt;{Flags}, $methodname); # argument handling
+        }
+        print CLASS &quot;}&quot;;
+
+        #
+        # for all optional parameters
+        #
+        foreach $cpp_arg (@stack_optional){
+
+            $params .= $cpp_arg.&quot;,&quot;; # collect args for this try
+            $zend_arg = cplusplusToZVAL($cpp_arg);
+
+            # intercept unknown types
+            if($zend_arg eq &quot;unknown&quot;){
+                print CLASS &quot;\n// notice: unknown argument &quot;.$cpp_arg.&quot;, skipped\n&quot;;
+                next ARGLIST;
+            }
+
+            $zend_args_query .= &quot; &amp;&amp; Z_TYPE_P(args[&quot;.$count_args++.&quot;]) == IS_&quot;.$zend_arg;
+
+            # type check
+            print CLASS &quot;if(ZEND_NUM_ARGS() == &quot;.$count_args.$zend_args_query.&quot;){&quot;;
+
+            # if object
+            if($ce_ptr_query ne &quot;&quot;){
+                print CLASS &quot;&quot;.expandIfdefs(@ifdef_stack);  # ifdef PHP_QT_QString
+                print CLASS &quot; if(&quot;.$ce_ptr_query.&quot;){&quot;;  # ask object types
+                handleArguments($params,$method-&gt;{ReturnType},$method-&gt;{Flags}, $methodname); # argument handling
+                print CLASS &quot;}\n&quot;;
+                print CLASS &quot;&quot;.expandEndifs(@ifdef_stack);  # endif
+            # if simple type
+            } else {
+                # argument handling
+                handleArguments($params,$method-&gt;{ReturnType},$method-&gt;{Flags}, $methodname);
+            }
+            print CLASS &quot;}&quot;; # end type check
+
+        } # stack_optional
+
+        # ifdef
+        print CLASS &quot;#endif // return type\n\n&quot; if cplusplusToZVAL($method-&gt;{ReturnType}) eq &quot;OBJECT&quot;;
+    }
+
+    print CLASS &quot;php_error(E_ERROR,\&quot;could not parse argument\&quot;);&quot;;
+    print CLASS &quot;}\n&quot;;
+
+}
+
+#
+# prepare and invoke args for a try
+#
+
+sub handleArguments
+{
+    my ( $params, $return, $flags, $methodname ) = @_;
+
+    my $returnType = cplusplusToZVAL($return);      # example: BOOL, LONG, DOUBLE, STRING, OBJECT
+    if($returnType eq &quot;unknown&quot;){
+        print CLASS &quot;php_error(E_ERROR,\&quot;unsupported return type &quot;.$return.&quot;\&quot;);&quot;;
+        return;
+    }
+
+    if($flags =~ /s/){
+    } else {
+        print CLASS &quot;if(getThis() == NULL){php_error(E_ERROR,\&quot;method '&quot;.$methodname.&quot;' is not static\&quot;); RETURN_NULL;}&quot;;
+    }
+
+
+    my $preparation;    # invoke zend to cpp, prepare return object if necessary
+    my $cpp_call_params;    # the args passed to Qt method
+    my $count_args = 0;
+    my @cargs = kdocUtil::splitUnnested(&quot;,&quot;, $params);  # fetch args
+
+    $preparation .= &quot;\n\t/// try &quot;.$params.&quot;\n&quot;;
+    $preparation .= &quot;if(getThis != NULL){&quot;.$classname.&quot; *selfpointer = static_cast&lt;&quot;.$classname.&quot;*&gt;(PHP_QT_FETCH());}&quot;;
+
+    # argument handling
+    foreach $arg (@cargs) {
+
+        $argType = cplusplusToZVAL($arg);
+
+        # should never happen, checked above
+        if($argType eq &quot;unknown&quot;){
+            print CLASS &quot;\n// unknown, skipped: &quot;.$arg.&quot;\n&quot;;
+            return; # return arg handling
+        }
+
+        # for all arg types, e.g. bool*
+        $classType = unwrapClassType($arg);
+
+        # handling of pointers, references
+        my $postfix, $prefix, $prefix_ZVAL;
+        if(checkRPN($arg) eq &quot;reference&quot;){
+            $postfix = &quot;&amp;&quot;; # cast (old c cast)
+            $prefix = &quot;*&quot;;  # dereferencing the pointer
+        } elsif (checkRPN($arg) eq &quot;pointer&quot;){
+            $postfix = &quot;*&quot;; # cast
+            $prefix = &quot;&quot;;   # nothing, is already a pointer
+            $prefix_ZVAL = &quot;&amp;&quot;;
+        } elsif (checkRPN($arg) eq &quot;normal&quot;){
+            $prefix = &quot;*&quot;;  # dereferencing the pointer
+            $postfix = &quot;&quot;;  # nothing to do here
+        }
+
+        $cpp_call_params .= &quot;(&quot;.checkConst($arg).&quot; &quot;.$classType.$postfix.&quot;)&quot;;
+
+        if($argType eq &quot;OBJECT&quot;){
+            # example: QString *cpp_arg_0 = static_cast&lt;QString*&gt;(php_qt_fetch(args[0]);
+            $preparation .= $classType.&quot; *cpp_arg_&quot;.$count_args.&quot; = static_cast&lt;&quot;.$classType.&quot;*&gt;(php_qt_fetch(args[&quot;.$count_args.&quot;]));\n&quot;;
+            $cpp_call_params .= $prefix.&quot;cpp_arg_&quot;.$count_args.&quot; &quot;;
+        } else {
+            # example: Z_LVAL_P(arg_0), Z_STRVAL(arg_0)
+            $cpp_call_params .= $prefix_ZVAL.&quot;Z_&quot;.invokeTypeToZ_XVAL($argType).&quot;VAL_P(args[&quot;.$count_args.&quot;]) &quot;;
+        }
+
+        $cpp_call_params .= &quot;,&quot;;
+        $count_args++;
+    }
+
+    chop($cpp_call_params); # remove last comma
+
+    print CLASS $preparation;   # printout declaration
+
+    # return handling
+    my $returnClassName = unwrapClassType($return); # example: QString (from QString &amp;c)
+    my $prefix, $postfix, $infix;
+
+    if(checkRPN($return) eq &quot;reference&quot;){       # tested
+        $prefix = $returnClassName.&quot;&amp;&quot;;
+        $infix = &quot;&amp;&quot;;
+    } elsif (checkRPN($return) eq &quot;pointer&quot;){
+        $prefix = $returnClassName.&quot;* &quot;;
+    } elsif (checkRPN($return) eq &quot;normal&quot;){    # tested with non-objects
+        # allocate memory on the heap
+        if($returnType eq &quot;OBJECT&quot;){
+            print CLASS $returnClassName.&quot; *return_object = new &quot;.$returnClassName.&quot;;\n&quot;;
+        }
+        $prefix = &quot;*&quot;;
+    }
+
+    if($returnType eq &quot;OBJECT&quot;){
+        if($flags =~ /s/){
+            print CLASS &quot;if(getThis() == NULL){&quot;.$prefix.&quot; return_object = static_cast&lt;&quot;                .$returnClassName.$infix.&quot;&gt;(&quot;.$classname.&quot;::&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;));} else {print CLASS &quot;                .$prefix.&quot; return_object = static_cast&lt;&quot;               .$returnClassName.$infix.&quot;&gt;(selfpointer-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;));}&quot;;
+        } else {
+            print CLASS $prefix.&quot; return_object = static_cast&lt;&quot;
+                .$returnClassName.$infix.&quot;&gt;(selfpointer-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;));&quot;;
+        }
+        print CLASS &quot;zend_class_entry *ce;&quot;;
+        print CLASS &quot;object_init_ex(return_value, QString_ce_ptr);&quot;;
+        print CLASS &quot;zend_rsrc_list_entry le;&quot;;
+        print CLASS &quot;le.ptr = (void*) &quot;.$infix.&quot;return_object;&quot;;
+        print CLASS &quot;php_qt_register(return_value,le);&quot;;
+        print CLASS &quot;return;&quot;;
+    } else {
+        if($method-&gt;{astNodeName} eq $classname){
+            print CLASS &quot;PHP_QT_REGISTER(selfpointer-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;));&quot;;
+        } else {
+            if($flags =~ /s/){
+                print CLASS &quot;if(getThis() == NULL){RETURN_&quot;.$returnType.&quot;(&quot;.$classname.&quot;::&quot;
+                    .$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;));} else {RETURN_&quot;
+                    .$returnType.&quot;(selfpointer-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;));}&quot;;
+            } else {
+                print CLASS &quot;RETURN_&quot;.$returnType.&quot;(selfpointer-&gt;&quot;.$method-&gt;{astNodeName}.&quot;(&quot;.$cpp_call_params.&quot;));&quot;;
+            }
+        }
+    }
+}
+
+# group and merge methods by name, for argument handling
+
+sub mergeMethods
+{
+	my ( $method )  = @_;
+
+    # looking for existing list
+    foreach my $key ( %methods ) {
+        if ( $key-&gt;{astNodeName} eq $method-&gt;{astNodeName} ) {
+            #add to existing list
+            push(@{$methods{ $method-&gt;{astNodeName} }-&gt;{&quot;argList&quot;}},$method);
+	        return;
+ 		}
+    }
+
+    # add new list
+    $methods{ $method-&gt;{astNodeName} } = $method;
+
+    my $methodlist = ();
+    $methods{ $method-&gt;{astNodeName} }-&gt;AddProp(&quot;methodname&quot;, $method-&gt;{astNodeName});
+    $methods{ $method-&gt;{astNodeName} }-&gt;AddPropList(&quot;argList&quot;, $methodlist);
+
+    push(@{$methods{ $method-&gt;{astNodeName} }-&gt;{&quot;argList&quot;}},$method);
+
+}
+
+# write documentation for method
+
+sub writeMethodDoc
+{
+    my ( $method ) = @_;
+
+        print CLASS &quot;/*!\n&quot;;
+        print CLASS &quot; * method &quot;.$method-&gt;{astNodeName}.&quot;\n&quot;;
+        print CLASS &quot; * \n&quot;;
+
+        foreach my $overloadedmethod (@{$method-&gt;{&quot;argList&quot;}})
+        {
+            my @cargs = kdocUtil::splitUnnested(&quot;,&quot;, $overloadedmethod-&gt;{Params});
+
+            # mark as overloaded
+            if(@cargs&gt;0) {
+                print CLASS &quot; * \n&quot;;
+                print CLASS &quot; * overloaded args:\n&quot;;
+            } else {
+                print CLASS &quot; * \@param: -\n&quot;;
+            }
+
+            foreach my $arg ( @cargs ) {
+                print CLASS &quot; * \@param\t&quot;.$arg.&quot;\n&quot;;
+            }
+
+        }
+
+        print CLASS &quot; * \n&quot;;
+        print CLASS &quot; * \@access\t&quot;.$method-&gt;{Access}.&quot;\n&quot;;
+        print CLASS &quot; * \@return\t&quot;.$method-&gt;{ReturnType}.&quot;\n&quot;;
+        print CLASS &quot; * \@flags\t&quot;.$method-&gt;{Flags}.&quot;\n&quot;;
+        print CLASS &quot; */\n\n&quot;
+
+}
+
+################################################################################
+#                                                                              #
+#   HELPER FUNCTIONS                                                           #
+#                                                                              #
+################################################################################
+
+sub openAllFiles
+{
+
+	mkpath( $outputdir ) unless -f $outputdir;
+    mkpath( $outputdir.&quot;/classes/&quot; ) unless -f $outputdir.&quot;/classes/&quot;;
+
+    # AG_ZEND_CLASS_ENTRY
+    my $file_ag_zend_class_entry = &quot;$outputdir/ag_zend_class_entry.inc&quot;;
+    open( AG_ZEND_CLASS_ENTRY, &quot;&gt;$file_ag_zend_class_entry&quot; ) || die &quot;Couldn't create $file_ag_zend_class_entry\n&quot;;
+    $file_ag_zend_class_entry =~ s/\.h/.h/;
+
+    # AG_EXTERN_ZEND_CLASS_ENTRY
+    my $file_ag_extern_zend_class_entry = &quot;$outputdir/ag_extern_zend_class_entry.inc&quot;;
+    open( AG_EXTERN_ZEND_CLASS_ENTRY, &quot;&gt;$file_ag_extern_zend_class_entry&quot; ) || die &quot;Couldn't create $file_ag_extern_zend_class_entry\n&quot;;
+    $file_ag_extern_zend_class_entry =~ s/\.h/.h/;
+
+    # AG_ZEND_PHP_QT
+    my $file_ag_zend_php_qt = &quot;$outputdir/ag_zend_php_qt.inc&quot;;
+    open( AG_ZEND_PHP_QT, &quot;&gt;$file_ag_zend_php_qt&quot; ) || die &quot;Couldn't create $file_ag_zend_php_qt\n&quot;;
+    $file_ag_zend_php_qt =~ s/\.h/.h/;
+
+    # AG_CONFIGM4
+    my $file_ag_configm4 = &quot;$outputdir/ag_configm4.inc&quot;;
+    open( AG_CONFIGM4, &quot;&gt;$file_ag_configm4&quot; ) || die &quot;Couldn't create $file_ag_configm4\n&quot;;
+    $file_ag_configm4 =~ s/\.h/.h/;
+
+    # AG_QT_MINIT
+    my $file_ag_qt_minit = &quot;$outputdir/ag_qt_minit.inc&quot;;
+    open( AG_QT_MINIT, &quot;&gt;$file_ag_qt_minit&quot; ) || die &quot;Couldn't create $file_ag_qt_minit\n&quot;;
+    $file_ag_qt_minit =~ s/\.h/.h/;
+
+    # AG_PHP_QT_CPP
+    my $file_ag_php_qt_cpp = &quot;$outputdir/ag_php_qt_cpp.inc&quot;;
+    open( AG_PHP_QT_CPP, &quot;&gt;$file_ag_php_qt_cpp&quot; ) || die &quot;Couldn't create $file_ag_php_qt_cpp\n&quot;;
+    $file_ag_php_qt_cpp =~ s/\.h/.h/;
+
+    print AG_PHP_QT_MINIT &quot;\n&quot;;
+    print AG_ZEND_PHP_QT &quot;/*
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006
+ * Thomas Moenicke &lt;tm\@ippfp.org&gt;,
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef PHP_PHP_QT_H
+#define PHP_PHP_QT_H
+
+extern zend_module_entry php_qt_module_entry;
+#define phpext_php_qt_ptr &amp;php_qt_module_entry
+
+#ifdef ZTS
+#include \&quot;TSRM.h\&quot;
+#endif
+
+PHP_MINIT_FUNCTION(php_qt);
+PHP_MSHUTDOWN_FUNCTION(php_qt);
+PHP_RINIT_FUNCTION(php_qt);
+PHP_RSHUTDOWN_FUNCTION(php_qt);
+PHP_MINFO_FUNCTION(php_qt);
+
+PHP_FUNCTION(confirm_php_qt_compiled);	/* For testing, remove later. */
+
+/* emulate SIGNAL(), SLOT() macros */
+PHP_FUNCTION(SIGNAL);
+PHP_FUNCTION(SLOT);
+    \n\n&quot;;
+
+}
+
+# write stuff to files
+sub writeAllFiles
+{
+    my ($node) = @_;
+
+    print AG_ZEND_CLASS_ENTRY &quot;zend_class_entry *&quot;,$node-&gt;{astNodeName},&quot;_ce_ptr;\n&quot;;
+    print AG_ZEND_CLASS_ENTRY &quot;#ifndef PHP_QT_&quot;.$classname.&quot;\n#define PHP_QT_&quot;.$classname.&quot;\n\n&quot;;
+
+    print AG_CONFIGM4 &quot;\tqt/classes/&quot;,lc($node-&gt;{astNodeName}),&quot;.cpp \\ \n&quot;;
+    print AG_EXTERN_ZEND_CLASS_ENTRY &quot;extern zend_class_entry *&quot;,$node-&gt;{astNodeName},&quot;_ce_ptr;\n&quot;;
+    print AG_EXTERN_ZEND_CLASS_ENTRY &quot;void \t_register_&quot;,$node-&gt;{astNodeName},&quot;();\n&quot;;
+
+
+    print PHP_QT_MINIT &quot;\n\t_register_&quot;,$node-&gt;{astNodeName},&quot;(TSRMLS_C);\n&quot;;
+    print AG_QT_MINIT &quot;\n\t_register_&quot;,$node-&gt;{astNodeName},&quot;(TSRMLS_C);\n&quot;;
+
+}
+
+sub closeAllFiles
+{
+
+    print AG_ZEND_PHP_QT &quot;\n/*
+  	Declare any global variables you may need between the BEGIN
+	and END macros here:
+
+ZEND_BEGIN_MODULE_GLOBALS(php_qt)
+	long  global_value;
+	char *global_string;
+ZEND_END_MODULE_GLOBALS(php_qt)
+*/
+
+#ifdef ZTS
+#define PHP_QT_G(v) TSRMG(php_qt_globals_id, zend_php_qt_globals *, v)
+#else
+#define PHP_QT_G(v) (php_qt_globals.v)
+#endif
+
+#endif	/* PHP_PHP_QT_H */
+\n
+    &quot;;
+
+    close AG_ZEND_CLASS_ENTRY;
+    close AG_EXTERN_ZEND_CLASS_ENTRY;
+    close AG_ZEND_PHP_QT;
+    close AG_CONFIGM4;
+    close AG_QT_MINIT;
+    close AG_PHP_QT_CPP;
+}
+
+sub openClassFile
+{
+
+    my ( $node ) = @_;
+
+	my $file = join(&quot;__&quot;, kdocAstUtil::heritage($node)).&quot;.cpp&quot;;
+    $file = $outputdir.&quot;/classes/&quot;.lc($file);
+
+	if( $#{$node-&gt;{Kids}} &lt; 0 || $node-&gt;{Access} eq &quot;private&quot;) {
+		return;
+	}
+	open( CLASS, &quot;&gt;$file&quot; ) || die &quot;Couldn't create $file\n&quot;;
+	$file =~ s/\.h/.cpp/;
+
+print CLASS &quot;/*
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2006
+ * Thomas Moenicke &lt;tm\@ippfp.org&gt;,
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+&quot;;
+
+	print CLASS &quot; * &quot;, $node-&gt;{astNodeName}, &quot;.cpp - &quot;, $node-&gt;{astNodeName}, &quot; PHP implementation.\n&quot;;
+	print CLASS $docTop;
+
+    print CLASS &quot;
+#include &lt;iostream&gt;
+using namespace std;\n&quot;;
+
+    print CLASS &quot;#include \&quot;../php_qt.h\&quot;\n\n&quot;;
+    print CLASS &quot;\n#include &lt;$node-&gt;{astNodeName}&gt;\n&quot;;
+
+}
+
+# check additional header files
+# hardcoded
+sub checkIncludes(){
+    my ($class) = @_;
+    my $return;
+
+    if($class-&gt;{astNodeName} eq &quot;QFont&quot;) {
+        $return .= &quot;#include &lt;QStringList&gt;\n&quot;;
+    }
+    if($class-&gt;{astNodeName} eq &quot;QPainter&quot;) {
+        $return .= &quot;#include &lt;QPainterPath&gt;\n&quot;;
+    }
+    if($class-&gt;{astNodeName} eq &quot;QApplication&quot;) {
+        $return .= &quot;#include &lt;QPalette&gt;\n#include &lt;QFontMetrics&gt;\n#include &lt;QIcon&gt;\n&quot;;
+    }
+    if($class-&gt;{astNodeName} eq &quot;QCoreApplication&quot;) {
+        $return .= &quot;#include &lt;QStringList&gt;\n&quot;;
+    }
+    if($class-&gt;{astNodeName} eq &quot;QWidget&quot;) {
+        $return .= &quot;#include &lt;QIcon&gt;\n&quot;;
+    }
+
+    print CLASS $return;
+}
+
+sub DerivedClass
+{
+    my ($node) = @_;
+
+    print CLASS &quot;#include &lt;QMetaMethod&gt;
+    class &quot;.$classname.&quot;_php_qt : public &quot;.$classname.&quot;{
+
+    public:
+        &quot;.$classname.&quot;_php_qt(zval* zend_ptr);
+
+        zval* zend_ptr;
+        QMetaObject* dynamicMetaObject;
+
+        const QMetaObject* metaObject() const;
+        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
+    };
+    PHP_QT_MOC(&quot;.$classname.&quot;);
+&quot;;
+# TODO:
+# virtual and private classes
+
+}
+
+#
+
+sub Inheritance
+{
+    my ($node) = @_;
+
+    # find ancestors
+    my @ancestors = ();
+	Iter::Ancestors( $node, $rootnode, undef, undef,
+		sub {
+			my ( $ances, $name, $type, $template ) = @_;
+            push @ancestors, $name;
+		},
+		undef
+	);
+
+    # print mainfile stuff
+    print AG_PHP_QT_CPP &quot;
+    {NULL,NULL,NULL}
+};\n&quot;;
+
+    my $zend_inherit = $node-&gt;{astNodeName}.&quot;_ce_ptr = zend_register_internal_class(&amp;ce TSRMLS_CC);&quot;;
+    my $ancestor;
+
+    my $first = 1;
+	foreach $ancestor ( @ancestors ) {
+        if($first) {
+            $zend_inherit = $node-&gt;{astNodeName}.&quot;_ce_ptr = zend_register_internal_class_ex(&amp;ce TSRMLS_CC, &quot;.$ancestor.&quot;_ce_ptr,NULL TSRMLS_CC);\n&quot;;
+            $first = 0;
+        } else {
+           $zend_inherit .= &quot;\tzend_do_inheritance(&quot;.$node-&gt;{astNodeName}.&quot;_ce_ptr, &quot;.$ancestor.&quot;_ce_ptr TSRMLS_CC);\n&quot;;
+        }
+	}
+
+    print AG_PHP_QT_CPP &quot;
+void _register_&quot;,$node-&gt;{astNodeName},&quot;(TSRMLS_D)
+{
+    zend_class_entry ce;
+    INIT_CLASS_ENTRY(ce,\&quot;&quot;,$node-&gt;{astNodeName},&quot;\&quot;,&quot;,$node-&gt;{astNodeName},&quot;_methods);
+    &quot;,$zend_inherit,&quot;
+&quot;;
+
+# 	Iter::MembersByType ( $node,
+# 		sub { print CLASS &quot;&quot;, $_[0], &quot;&quot;; print CLASS &quot;&quot;, $_[0], &quot;&quot;;  },
+# 		sub {	my ($node, $kid ) = @_;
+#             if ($kid-&gt;{NodeType} eq &quot;property&quot;){
+#                 print AG_PHP_QT_CPP &quot;\tPHP_QT_DECLARE_PROPERTY(\&quot;$kid-&gt;{astNodeName}\&quot;);\n&quot;;
+#             }
+#         },
+# 		sub { print CLASS &quot;&quot;; print JNISOURCE &quot;&quot;; }
+# 	);
+
+    print AG_PHP_QT_CPP &quot;
+}\n&quot;;
+
+
+}
+
+sub closeClassFile
+{
+    close CLASS;
+}
+
+sub cplusplusToZVAL
+{
+	my ( $cplusplusType )  = @_;
+
+	if ( $cplusplusType =~ /bool/) {
+		return &quot;BOOL&quot;;
+	} elsif ( $cplusplusType =~ /\s*void\s*\**/ ) {
+		return &quot;NULL&quot;;
+	} elsif ( $cplusplusType =~ /\s*::\s*/) {
+		return &quot;LONG&quot;;
+	} elsif ( $cplusplusType =~ /\s*\bint\s*\&amp;*/) {
+		return &quot;LONG&quot;;
+	} elsif ( $cplusplusType =~ /\s*int\s*\&amp;*/) {
+		return &quot;LONG&quot;;
+	} elsif ( $cplusplusType =~ /\s*short\s*\&amp;*/) {
+		return &quot;LONG&quot;;
+	} elsif ( $cplusplusType =~ /\s*char\s*\*\*/ ) {
+		return &quot;STRING&quot;;
+	} elsif ( $cplusplusType =~ /\s*char\s*\**/ ) {
+		return &quot;STRING&quot;;
+	} elsif ( $cplusplusType =~ /\s*unsigned int\s*\**/ ) {
+		return &quot;LONG&quot;;
+	} elsif ( $cplusplusType =~ /\s*unsigned short\s*\**/ ) {
+        return &quot;LONG&quot;;
+	} elsif ( $cplusplusType =~ /\s*unsigned long\s*\**/ ) {
+		return &quot;LONG&quot;;
+	} elsif ( $cplusplusType =~ /\s*float\s*\**/ ) {
+        return &quot;DOUBLE&quot;;
+	} elsif ( $cplusplusType =~ /\s*double\s*\**/ ) {
+        return &quot;DOUBLE&quot;;
+	} elsif ( $cplusplusType =~ /\s*unsigned char\s*\**/ ) {
+		return &quot;STRING&quot;;
+	} elsif ( $cplusplusType =~ /Q/ ) {
+        return &quot;OBJECT&quot;;
+	} else {
+        return &quot;unknown&quot;;
+    }
+}
+
+# helper: unwraps the classtype from arg string
+sub unwrapClassType
+{
+    my ($argString) = @_;
+
+    $argString =~ s/const//;
+    $argString =~ s/\*//;
+    $argString =~ s/\&amp;//;
+
+    # skip spaces
+    @c = split(/ /,$argString);
+    foreach(@c){
+        if($_ ne &quot;&quot;){
+            return $_;
+        }
+    }
+
+    return $c[0];
+
+}
+
+# checks for references, pointers, objects
+
+sub checkRPN
+{
+    my ($e) = @_;
+
+    my $rpo;
+
+    if($e =~ /\*/){
+        $rpo = &quot;pointer&quot;;
+    } elsif ($e =~ /\&amp;/) {
+        $rpo = &quot;reference&quot;;
+    } else {
+        $rpo = &quot;normal&quot;;
+    }
+
+    return $rpo;
+
+}
+
+# checks for const
+sub checkConst
+{
+    my ($e) = @_;
+    if($e =~ /const/){
+        return &quot;const&quot;;
+    }
+    return &quot;&quot;;
+}
+
+# invokes types for the Z_XVAL macro
+sub invokeTypeToZ_XVAL
+{
+    my ($type) = @_;
+    my $Z_VAL = substr($type,0,1);
+    if($Z_VAL eq &quot;S&quot;){
+        return &quot;STR&quot;;
+    }
+    # due problems with references
+    if($Z_VAL eq &quot;B&quot;){
+        return &quot;L&quot;;
+    }
+
+    return $Z_VAL;
+}
+
+#
+# expand #ifdef PHP_QT_QString ... #endif statements
+#
+
+sub expandIfdefs
+{
+    my (@ifdef_stack) = @_;
+    my $ifdef;
+    foreach $def (@ifdef_stack){
+        $ifdef .= &quot;#ifdef PHP_QT_&quot;.$def.&quot;\n&quot;;
+    }
+    return $ifdef;
+}
+
+sub expandEndifs
+{
+    my (@ifdef_stack) = @_;
+    my $endif;
+    foreach $def (@ifdef_stack){
+        $endif .= &quot;#endif\n\n&quot;;
+    }
+    return $endif;
+}
+
+1;


Property changes on: trunk/tools/kalyptusCxxToPHP.pm
___________________________________________________________________
Name: svn:executable
   + *


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000089.html">[Php-qt-svn] r245 - trunk/tools
</A></li>
	<LI>Next message: <A HREF="000091.html">[Php-qt-svn] r247 - trunk/tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#90">[ date ]</a>
              <a href="thread.html#90">[ thread ]</a>
              <a href="subject.html#90">[ subject ]</a>
              <a href="author.html#90">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/php-qt-svn">More information about the Php-qt-svn
mailing list</a><br>
</body></html>
