<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Php-qt-svn] r290 - in trunk: . kalyptus php_qt smoke smoke/kde	smoke/qt
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/php-qt-svn/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r290%20-%20in%20trunk%3A%20.%20kalyptus%20php_qt%20smoke%20smoke/kde%0A%09smoke/qt&In-Reply-To=%3C200702192135.l1JLZ6h6027914%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000135.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Php-qt-svn] r290 - in trunk: . kalyptus php_qt smoke smoke/kde	smoke/qt</H1>
    <B>tm243 at BerliOS</B> 
    <A HREF="mailto:php-qt-svn%40lists.berlios.de?Subject=Re%3A%20%5BPhp-qt-svn%5D%20r290%20-%20in%20trunk%3A%20.%20kalyptus%20php_qt%20smoke%20smoke/kde%0A%09smoke/qt&In-Reply-To=%3C200702192135.l1JLZ6h6027914%40sheep.berlios.de%3E"
       TITLE="[Php-qt-svn] r290 - in trunk: . kalyptus php_qt smoke smoke/kde	smoke/qt">tm243 at mail.berlios.de
       </A><BR>
    <I>Mon Feb 19 22:35:06 CET 2007</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000135.html">[Php-qt-svn] r291 - in trunk: . cmake cmake/modules
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#134">[ date ]</a>
              <a href="thread.html#134">[ thread ]</a>
              <a href="subject.html#134">[ subject ]</a>
              <a href="author.html#134">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tm243
Date: 2007-02-19 22:34:59 +0100 (Mon, 19 Feb 2007)
New Revision: 290

Added:
   trunk/CMakeLists.txt
   trunk/php_qt/
   trunk/php_qt/qstring.cpp
   trunk/smoke/CMakeLists.txt
   trunk/smoke/kde/CMakeLists.txt
   trunk/smoke/kde/generate.pl.cmake
   trunk/smoke/kde/qtguess.pl.cmake
   trunk/smoke/qt/CMakeLists.txt
   trunk/smoke/qt/generate.pl.cmake
   trunk/smoke/qt/qscintilla2_header_list
   trunk/smoke/qt/qtguess.pl.cmake
Removed:
   trunk/include/
   trunk/kalyptus/kalyptus.spec.in
   trunk/modules/
   trunk/qt/
   trunk/smoke/qwidgetitemdata_p.h
   trunk/tools/
Modified:
   trunk/ChangeLog
   trunk/README
   trunk/config.m4
   trunk/kalyptus/kalyptus
   trunk/kalyptus/kalyptusCxxToSmoke.pm
   trunk/kalyptus/kalyptusDataDict.pm
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/smokephp.cpp
   trunk/smoke/kde/header_list
   trunk/smoke/kde/kde_header_list
   trunk/smoke/qt/header_list
   trunk/smoke/qt/qt_smoke.h
   trunk/smoke/qt/qtdbus_header_list
   trunk/smoke/qt/qtguess.pl.in
   trunk/smoke/qt/qwt_header_list
   trunk/smoke/qt/smokeqt.pro
Log:
added cmake build system, added QString, updated smoke and kalyptus.

Added: trunk/CMakeLists.txt
===================================================================
--- trunk/CMakeLists.txt	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/CMakeLists.txt	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,22 @@
+
+PROJECT(PHP-Qt)
+
+set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/modules)
+set(kdebindings_SOURCE_DIR ${PHP-Qt_SOURCE_DIR})
+
+
+
+find_package(Perl REQUIRED)	# for kalyptus
+find_package(Qt4 REQUIRED)	# for kalyptus
+
+include(FindPHP5)
+
+IF(NOT PHP5_FOUND)
+    MESSAGE(FATAL_ERROR &quot;PHP5 could not be found!&quot;)
+ENDIF(NOT PHP5_FOUND)
+
+add_subdirectory(smoke)
+add_subdirectory(php_qt)
+
+
+

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/ChangeLog	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,3 +1,9 @@
+2007-002-19  Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">thomas.moenicke at kdemail.net</A>&gt;
+
+		* new cmake build system added
+		* implemented QString since it is not in Smoke
+		* Updated copies of smoke and kalyptus
+
 2006-011-18  Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">thomas.moenicke at kdemail.net</A>&gt;
 
 		* method argument handling: support for arrays, references

Modified: trunk/README
===================================================================
--- trunk/README	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/README	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,5 +1,6 @@
 PHP-Qt - an extension for PHP5 that aims to write software with the Qt Toolkit.
-===============================================================================
+================================================================================
+
 PHP-Qt is an extension for PHP5 that aims to write software with the Qt Toolkit. 
 It provides an object-oriented interface to the Qt4 Framework and allowes 
 to write Qt applications in the PHP language.
@@ -7,42 +8,43 @@
 Requirements
 ============
 
-PHP-Qt requires PHP 5.1RC1 or greater and Qt4 header files.
+PHP-Qt requires PHP 5.1 or greater, the Qt4 header files and CMake.
 
 PHP5: You should have a the header files and the development scripts.
 Qt4: You should have the header files.
 
-Note: at this time it is only possible to compile it in a unix environment.
+Note: at this time compilation is only tested in a Unix environment.
 
 Compiling and installation
 ==========================
 
-You have a php-5.1.xxx build directory where you have compiled php. You also 
-have a copy of php_qt. After downloading or checking out from SVN copy the 
-unpacked php_qt directory into the php-5.1xxx/ext/ directory.
+short:
 
-We prefer to build PHP-Qt as module! In this example php is 
-installed in /usr/local/php511
+cmake /path/to/php_qt
+make
+make install
 
-At first it is neccessary to check your environment for compiling. 
-To do that change into the php-5.1xxx/ext/php_qt directory and run phpize, kdeize
-and configure:
+more detailed:
 
-/usr/local/php511/bin/phpize
+You have cmake installed and the path to your PHP5 header files. After 
+downloading or checking out from SVN the easiest way is to create a build 
+directory in your copy of PHP-Qt. The extension will be built out-of-source 
+which allows you to have a clean copy of PHP-Qt without any files of the build 
+system.
 
-./kdeize
+PHP-Qt will be compiled as module! 
 
-./configure \
-  --enable-php_qt \
-  --with-qt-includes=/usr/lib/qt4/include \
-  --with-qt-libraries=/usr/lib/qt4 \
-  --with-php-config=/usr/local/php511/bin/php-config \
+At first it is neccessary to create your build environment for compiling.
+To do that just change into the 'php_qt/build' directory and run cmake:
 
-If --with-qt-includes and --with-qt-config are omitted, configure will try to find files in default or standard pathes
+cmake ..
 
-To remove old objectfiles run 
+You can give arguments to cmake via the -D option:
+  -DQT_INCLUDE_DIR=/usr/lib/qt4/include \
+  -DQT_LIBRARY_DIR=/usr/lib/qt4
 
-make clean
+If no argument is given cmake will try to find the Qt4 and PHP5 files in the default or standard 
+pathes as /usr/include, /usr/local/include etc.
 
 Finally, run 
 
@@ -52,12 +54,16 @@
 
 make install
 
-to copy 'php_qt.so' into php's extension directory. If it fails please check 
-all related pathes on your system at first.
+to copy 'php_qt.so' into php's extension directory. If it fails please check if you have 
+permissions and all related pathes on your system are correct.
 
+To remove old objectfiles run 
+
+make clean
+
 To test it, simply run one of the test scripts in the php_qt/test/ subdirectory.
+To get a clean build system just remove all files in the build/ directory.
 
-
 Mailing lists
 =============
 
@@ -83,6 +89,6 @@
 
 The website for the project:
 
-    <A HREF="http://php-qt.berlios.de">http://php-qt.berlios.de</A>
+    <A HREF="http://www.php-qt.org">http://www.php-qt.org</A>
 
 

Modified: trunk/config.m4
===================================================================
--- trunk/config.m4	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/config.m4	2007-02-19 21:34:59 UTC (rev 290)
@@ -144,7 +144,7 @@
     x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp \
     smokedata.cpp,,shared_objects_php_qt,yes)
 
-  PHP_NEW_EXTENSION(php_qt, qt/smokephp.cpp qt/php_qt.cpp qt/functions.cpp,$ext_shared,cli)
-  PHP_ADD_BUILD_DIR($ext_builddir/qt)
+  PHP_NEW_EXTENSION(php_qt, php_qt/smokephp.cpp php_qt/php_qt.cpp php_qt/functions.cpp,$ext_shared,cli)
+  PHP_ADD_BUILD_DIR($ext_builddir/php_qt)
 
 fi

Modified: trunk/kalyptus/kalyptus
===================================================================
--- trunk/kalyptus/kalyptus	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/kalyptus/kalyptus	2007-02-19 21:34:59 UTC (rev 290)
@@ -2,7 +2,7 @@
 
 # KDOC -- C++ and CORBA IDL interface documentation tool.
 # Sirtaj Singh Kang &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">taj at kde.org</A>&gt;, Jan 1999.
-# $Id: kalyptus 596521 2006-10-17 19:47:11Z rdale $
+# $Id: kalyptus 630755 2007-02-06 09:42:26Z rdale $
 
 # All files in this project are distributed under the GNU General
 # Public License. This is Free Software.
@@ -22,7 +22,7 @@
 
 use vars qw/ %rootNodes $declNodeType @includes_list %options @formats_wanted $allow_k_dcop_accessors
         @includeclasses $includeclasses $skipInternal %defines $defines $match_qt_defines
-	$libdir $libname $outputdir @libs $parse_global_space $qt_embedded $qt4 $striphpath $doPrivate $readstdin
+	$libdir $libname $outputdir @libs $parse_global_space $qt_embedded $qt4 $properties $striphpath $doPrivate $readstdin
 	$Version $quiet $debug $debuggen $parseonly $currentfile $cSourceNode $exe
 	%formats %flagnames @allowed_k_dcop_accesors $allowed_k_dcop_accesors_re $rootNode 
 	@classStack $cNode $globalSpaceClassName
@@ -157,6 +157,7 @@
 	&quot;globspace&quot;,	\$parse_global_space,
 	&quot;qte&quot;,	\$qt_embedded,
 	&quot;qt4&quot;,	\$qt4,
+	&quot;properties&quot;,	\$properties,
 	&quot;allow_k_dcop_accessors&quot;, \$allow_k_dcop_accessors,
 
 	&quot;cpp|P&quot;,	\$cpp,
@@ -470,10 +471,13 @@
 		$p =~ s/Q_EXPORT_CODECS_BIG5//;
 		$p =~ s/Q_DECL_DEPRECATED//;
 		$p =~ s/Q_SCRIPTABLE//;
+		$p =~ s/QT_STATIC_CONST_IMPL/const/;
+		$p =~ s/QT_STATIC_CONST/static const/;
 		$p =~ s/QT_COMPAT / /;
 		$p =~ s/Q_DISABLE_COPY\((\w+)\)/$1(const $1 &amp;);\n$1 &amp;operator=(const $1 &amp;);/;
 		$p =~ s/QWIDGETSIZE_MAX/32767/; # Qt/E uses this #define as an enum value - yuck!
 		$p =~ s/Q_SIGNALS/signals/;
+		$p =~ s/Q_SLOTS/slots/;
 		$p =~ s/ASYNC/void/;
 		$p =~ s/[A-Z_0-9]*_EXPORT_DEPRECATED//;
 		$p =~ s/[A-Z_0-9]*_EXPORT\s/ /;
@@ -512,7 +516,6 @@
 		next if ( $p =~ /^\s*Q_ENUMS/           # ignore Q_ENUMS
                         || $p =~ /^\s*Q_FLAGS/       # and Q_FLAGS
                         || $p =~ /^\s*Q_DECLARE_FLAGS/       # and Q_DECLARE_FLAGS
-                        || ( !$qt4 &amp;&amp; $p =~ /^\s*Q_PROPERTY/ )      # and Q_PROPERTY
                         || $p =~ /^\s*QDOC_PROPERTY/
                         || $p =~ /^\s*Q_GADGET/
                         || $p =~ /^\s*Q_OVERRIDE/       # and Q_OVERRIDE
@@ -712,8 +715,10 @@
 	elsif ( $l =~ /Q_PROPERTY/ ) {	# property
 		do {
 			$decl .= $l;
-	
-			if ( $l =~ /[)]/ ) {
+			my $lparens = kdocUtil::countReg( $decl, '\(' );
+			my $rparens = kdocUtil::countReg( $decl, '\)' );
+
+			if ( $lparens == $rparens ) {
 				$decl =~ s/\n/ /gs;
 				return $decl;
 			}
@@ -803,8 +808,8 @@
     # properties
     elsif ( $decl =~ s/Q_PROPERTY// ) {
 		print &quot;Property: &lt;$1&gt;\n&quot; if $debug;
-
-		$newNode = newProperty( $decl );
+		
+		$newNode = newProperty( $decl ) if $properties;
 	}
 	# Typedef struct/class
 	elsif ( $decl =~ /^\s*typedef
@@ -1773,10 +1778,12 @@
     my @items = split(/ /,$property);
 
     do {
-	    my ( $node ) = Ast::New( $items[1] );
+	    my ( $node ) = Ast::New( &quot;Q_PROPERTY_&quot; . $items[1] );
 
 	    $node-&gt;AddProp( &quot;NodeType&quot;, &quot;property&quot; );
-        $node-&gt;AddProp( &quot;type&quot;, $items[0] );
+        my $type = $items[0];
+        $type =~ s/\(//g;
+        $node-&gt;AddProp( &quot;Type&quot;, $type );
         $node-&gt;AddProp( &quot;READ&quot;, $items[3] );
         $node-&gt;AddProp( &quot;WRITE&quot;, $items[5] );
         $node-&gt;AddProp( &quot;NOTIFY&quot;, $items[7] );

Deleted: trunk/kalyptus/kalyptus.spec.in
===================================================================
--- trunk/kalyptus/kalyptus.spec.in	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/kalyptus/kalyptus.spec.in	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,62 +0,0 @@
-# You might want to change the next 2 lines, the rest should be ok
-%define qtdir /usr/lib/qt-3.0.0
-Prefix: /opt/kde3
-
-Name: kalyptus
-Icon: kde-icon.xpm
-Summary: Bindings generation tools for the K Desktop Environment (KDE) 3.0.
-Version: @VERSION@
-Release: 1
-Epoch: 1
-#Source: <A HREF="ftp://ftp.kde.org/pub/kde/stable/%{version">ftp://ftp.kde.org/pub/kde/stable/%{version</A>}/distribution/tar/generic/source/kdoc-%{version}.tar.bz2
-Group: Bindings
-BuildRoot: /var/tmp/%{name}-buildroot
-Copyright: GPL
-BuildArch: noarch
-
-%description
-Bindings generation tools for the K Desktop Environment 3.0.
-
-%prep
-rm -rf $RPM_BUILD_ROOT
-
-%setup -q -n %{name}
-make -f Makefile.cvs
-
-%build
-export KDEDIR=%{prefix} QTDIR=%{qtdir}
-CXXFLAGS=&quot;$RPM_OPT_FLAGS -I%{prefix}/include/kde&quot; ./configure \
-	--prefix=%{prefix}
-make CXXFLAGS=&quot;$RPM_OPT_FLAGS -DNO_DEBUG -DNDEBUG&quot;
-
-%install
-make install DESTDIR=$RPM_BUILD_ROOT
-
-cd $RPM_BUILD_ROOT
-find . -type d | sed '1,3d;s,^\.,\%attr(-\,root\,root) \%dir ,' &gt; \
-	$RPM_BUILD_DIR/file.list.%{name}
-perl -pi -e &quot;s|\%attr\(-,root,root\) \%dir %{prefix}/man/man1||&quot; $RPM_BUILD_DIR/file.list.%{name}
-perl -pi -e &quot;s|\%attr\(-,root,root\) \%dir %{prefix}/man||&quot; $RPM_BUILD_DIR/file.list.%{name}
-perl -pi -e &quot;s|\%attr\(-,root,root\) \%dir %{prefix}/bin||&quot; $RPM_BUILD_DIR/file.list.%{name}
-perl -pi -e &quot;s|\%attr\(-,root,root\) \%dir %{prefix}/lib$||&quot; $RPM_BUILD_DIR/file.list.%{name}
-
-find . -type f | sed -e 's,^\.,\%attr(-\,root\,root) ,' \
-	-e '/\/config\//s|^|%config|' &gt;&gt; \
-	$RPM_BUILD_DIR/file.list.%{name}
-
-find . -type l | sed 's,^\.,\%attr(-\,root\,root) ,' &gt;&gt; \
-	$RPM_BUILD_DIR/file.list.%{name}
-
-sed -e &quot;s,%{prefix}/man/.*,&amp;*,g&quot; $RPM_BUILD_DIR/file.list.%{name} &gt;$RPM_BUILD_DIR/file.list.%{name}.new
-mv -f $RPM_BUILD_DIR/file.list.%{name}.new $RPM_BUILD_DIR/file.list.%{name}
-
-echo &quot;%docdir %{prefix}/doc/kde&quot; &gt;&gt; $RPM_BUILD_DIR/file.list.%{name}
-
-%clean
-rm -rf $RPM_BUILD_ROOT $RPM_BUILD_DIR/file.list.%{name}
-
-%files -f ../file.list.%{name}
-
-%changelog
-* Thu May 11 2000 Bernhard Rosenkraenzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">bero at redhat.com</A>&gt;
-- initial

Modified: trunk/kalyptus/kalyptusCxxToSmoke.pm
===================================================================
--- trunk/kalyptus/kalyptusCxxToSmoke.pm	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/kalyptus/kalyptusCxxToSmoke.pm	2007-02-19 21:34:59 UTC (rev 290)
@@ -78,6 +78,7 @@
      'quint64' =&gt; '$',
      'qint64' =&gt; '$',
      'long long' =&gt; '$',
+     'qlonglong' =&gt; '$',
      'qulonglong' =&gt; '$',
      'WId' =&gt; '$',
      'Q_PID' =&gt; '$',
@@ -257,7 +258,7 @@
    'ViewItemFeatures' =&gt; 'int',
 );
 
-$headerSubdirectories = &quot;kio/|dnssd/|solid/|solid/ifaces/|phonon/|sonnet/|kdevelop/|kinterfacedesigner/|kontact/|kate/|kparts/|dom/|kabc/|ksettings/|kjs/|ktexteditor/|kdeprint/|kdesu/|knewstuff|dbus-1.0/dbus/&quot;
+$headerSubdirectories = &quot;kio/|phonon/ui/|kmediaplayer/|dnssd/|solid/|solid/ifaces/|phonon/|sonnet/|kdevelop/|kinterfacedesigner/|kontact/|kate/|kparts/|dom/|kabc/|ksettings/|kjs/|ktexteditor/|kdeprint/|kdesu/|knewstuff/|dbus-1.0/dbus/&quot;
 
 }
 
@@ -339,7 +340,7 @@
 	    $classNode-&gt;{Access} eq &quot;protected&quot; || # e.g. QPixmap::QPixmapData
 	    exists $classNode-&gt;{Tmpl} ||
 	    # Don't generate standard bindings for QString, this class is handled as a native type
-#	    $className eq 'QString' ||
+	    $className eq 'QString' ||
 	    $className eq 'QStringData' ||
 	    $className eq 'QLatin1String' ||
 	    $className eq 'QTLWExtra' ||
@@ -383,14 +384,18 @@
 	    ($className eq 'QSysInfo' and $main::qt4) ||
 	    ($className eq 'QPNGImageWriter' and $main::qt4) ||
 	    ($className eq 'QPNGImagePacker' and $main::qt4) ||
+	    ($className eq 'QSqlRelationalDelegate' and $main::qt4) ||
 	    ($className eq 'QTextCodec::ConverterState' and $main::qt4) ||
 	    ($className eq 'QTextLayout::Selection' and $main::qt4) ||
 	    ($className eq 'QTextStreamManipulator' and $main::qt4) ||
 	    $className eq 'DCOPArg' ||
 	    $className eq 'DCOPReply' ||
 	    $className eq 'KBookmarkMenu::DynMenuInfo' ||
+	    $className eq 'KDateTime::Spec' ||
+	    $className eq 'KEncodingFileDialog::Result' ||
 	    $className eq 'KDE' ||
 	    $className eq 'KDEDesktopMimeType::Service' ||
+	    $className eq 'KDialogButtonBox' ||
 	    $className eq 'KEntry' ||
 	    $className eq 'KEntryKey' ||
 	    $className eq 'KGlobalSettings::KMouseSettings' ||
@@ -398,12 +403,15 @@
 	    $className eq 'KNotifyClient::Instance' ||
 	    $className eq 'KParts::ComponentFactory' ||
 	    $className eq 'KParts::Plugin::PluginInfo' ||
+	    $className eq 'KParts::MainWindow' ||
 	    $className eq 'KProtocolInfo::ExtraField' ||
 	    $className eq 'KXMLGUIClient::StateChange' ||
 	    $className eq 'KIconTheme' ||
 	    $className eq 'KEditListBox::CustomEditor' ||
 		$className eq 'KIO::KBookmarkMenuNSImporter' ||
+		$className eq 'KIO::NetRC' ||
 	    $className eq 'KExtendedSocket' ||
+	    $className eq 'KSettings::PluginPage' ||
 	    $className eq 'KSocket' ||
 	    $className eq 'KPerDomainSettings' ||
 	    $className eq 'KApplicationPropsPlugin' ||
@@ -417,6 +425,7 @@
 	    $className eq 'KDEDModule' ||
 	    $className eq 'KFileMetaInfoProvider' ||
 	    $className eq 'KFileMimeTypeInfo' ||
+	    $className eq 'KMimeTypeChooserDialog' ||
 	    $className eq 'KExecPropsPlugin' ||
 	    $className eq 'KFilePermissionsPropsPlugin' ||
 	    $className eq 'KImageFilePreview' ||
@@ -427,11 +436,14 @@
 	    $className eq 'KSharedPixmap' ||
 	    $className eq 'KLibrary' ||
 	    $className eq 'KScanDialogFactory' ||
+	    $className eq 'KTimeZone::Transition' ||
+	    $className eq 'KTipDatabase' ||
 	    $className eq 'KBufferedIO' ||
 	    $className eq 'KDictSpellingHighlighter' ||
 		$className eq 'KPropertiesDialog' ||
 	    $className eq 'ProgressItem' ||
 	    $className eq 'KIO::ChmodInfo' ||
+	    $className eq 'KUrl::List' ||
 	    $className eq 'khtml::DrawContentsEvent' || # the khtml:: classes build, but don't link
 	    $className eq 'khtml::MouseDoubleClickEvent' ||
 	    $className eq 'khtml::MouseMoveEvent' ||
@@ -489,7 +501,11 @@
 	    $className =~ /.*Impl$/ ||
 	    $className =~ /.*Internal.*/ ||
 	    $classNode-&gt;{Deprecated} ||
-	    $classNode-&gt;{NodeType} eq 'union'  # Skip unions for now, e.g. QPDevCmdParam
+	    $classNode-&gt;{NodeType} eq 'union' || # Skip unions for now, e.g. QPDevCmdParam
+	    $className eq 'KImportedBookmarkMenu' || # KDE4
+	    $className eq 'KUndoRedoAction' || # KDE4
+	    $className eq 'KTzfileTimeZoneData' || # KDE4
+	    $className eq 'KUndoRedoAction' # KDE4
 	  ) {
 	    print STDERR &quot;Skipping $className\n&quot; if ($debug);
 	    print STDERR &quot;Skipping union $className\n&quot; if ( $classNode-&gt;{NodeType} eq 'union');
@@ -573,10 +589,24 @@
 
 	    # All we want from private methods is to check for virtuals, nothing else
 	    next if ( $m-&gt;{Access} =~ /private/ );
-		
 		# Don't generate code for deprecated methods, 
 		# or where the code won't compile/link for obscure reasons. Or even obvious reasons..
 		if ( ($classNode-&gt;{astNodeName} eq 'KCharSelectTable' and $name eq 'paintCell')
+			# KDE4
+			|| ($name eq 'operator&lt;&lt;' and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QDataStream/ and $m-&gt;{ParamList}[1]-&gt;{ArgType} =~ /KDateTime::Spec/ )
+			|| ($name eq 'operator&gt;&gt;' and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QDataStream/ and $m-&gt;{ParamList}[1]-&gt;{ArgType} =~ /KDateTime::Spec/ )
+                        || ($name eq 'operator&lt;&lt;' and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QDataStream/ and $m-&gt;{ParamList}[1]-&gt;{ArgType} =~ /const KDateTime/ )
+                        || ($name eq 'operator&gt;&gt;' and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QDataStream/ and $m-&gt;{ParamList}[1]-&gt;{ArgType} =~ /KDateTime/ )
+			|| ($classNode-&gt;{astNodeName} eq 'TextEvent' and $name eq 'data')
+			|| ($classNode-&gt;{astNodeName} eq 'KApplication' and $name eq 'startKdeinit')
+			|| ($classNode-&gt;{astNodeName} eq 'Slave' and $name eq 'Slave')
+			|| ($classNode-&gt;{astNodeName} eq 'KIcon' and $name eq 'setOverlays')
+			|| ($classNode-&gt;{astNodeName} eq 'KResolver' and $name eq 'setError')
+			|| ($classNode-&gt;{astNodeName} eq 'Entry' and $name eq 'setCompatibility')
+			|| ($classNode-&gt;{astNodeName} eq 'KTimeZone' and $name eq 'source')
+			|| ($classNode-&gt;{astNodeName} eq 'KTzfileTimeZoneSource' and $name eq 'location')
+			|| ($classNode-&gt;{astNodeName} eq 'Wallet' and $name eq 'Wallet')
+			# end KDE4
 			|| ($classNode-&gt;{astNodeName} eq 'KAnimWidget' and $name eq 'KAnimWidget' and @{$m-&gt;{ParamList}} == 2)
 			|| ($classNode-&gt;{astNodeName} eq 'KCModuleLoader' and $name eq 'errorModule')
 			|| ($classNode-&gt;{astNodeName} eq 'KDCOPActionProxy' and $name eq 'actions')
@@ -595,13 +625,19 @@
 			|| ($classNode-&gt;{astNodeName} eq 'SlaveBase' and $name eq 'cacheAuthentication')
 			|| ($classNode-&gt;{astNodeName} eq 'KInputDialog' and $name eq 'getDouble')
 			|| ($classNode-&gt;{astNodeName} eq 'KToolBar' and $name eq 'enable')
+			|| ($classNode-&gt;{astNodeName} eq 'KToolBar' and $name eq 'changeEvent')
 			|| ($classNode-&gt;{astNodeName} eq 'KAccel' and $name eq 'insert' and @{$m-&gt;{ParamList}} == 2)
 			|| ($classNode-&gt;{astNodeName} eq 'KAccel' and $name eq 'autoupdate')
 			|| ($classNode-&gt;{astNodeName} eq 'KAccel' and $name eq 'getAutoUpdate')
+			|| ($classNode-&gt;{astNodeName} eq 'KAction' and $name eq 'activated')
+			|| ($classNode-&gt;{astNodeName} eq 'KAction' and $name eq 'actionOfType')
+			|| ($classNode-&gt;{astNodeName} eq 'KAction' and $name eq 'actionsOfType')
+			|| ($classNode-&gt;{astNodeName} eq 'KActionCollection' and $name eq 'add')
 			|| ($classNode-&gt;{astNodeName} eq 'KStdAccel' and $name eq 'insert')
 			|| ($classNode-&gt;{astNodeName} eq 'KBookmarkMenu' and $name eq 'invalid')
 			|| ($classNode-&gt;{astNodeName} eq 'KCharsets' and $name eq 'languages')
 			|| ($classNode-&gt;{astNodeName} eq 'KCombiView' and $name eq 'setDropOptions')
+			|| ($classNode-&gt;{astNodeName} eq 'KDialogButtonBox' and $name eq 'using')
 			|| ($classNode-&gt;{astNodeName} eq 'KFileMetaInfoItem' and $name eq 'unit')
 			|| ($classNode-&gt;{astNodeName} eq 'KInstance' and $name eq 'charsets')
 			|| ($classNode-&gt;{astNodeName} eq 'KInstance' and $name eq 'KInstance' and $m-&gt;{Access} =~ /protected/)
@@ -628,10 +664,12 @@
 			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'pasteData')
 			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'pasteDataAsync')
 			|| ($classNode-&gt;{astNodeName} eq 'KIO' and $name eq 'isClipboardEmpty')
+			|| ($classNode-&gt;{astNodeName} eq 'KIO::NetRC' and $name eq 'lookup')
 			|| ($classNode-&gt;{astNodeName} eq 'DCOPRef' and $name eq 'callExt')
 			|| ($classNode-&gt;{astNodeName} eq 'DCOPRef' and $name eq 'call')
 			|| ($classNode-&gt;{astNodeName} eq 'DCOPRef' and $name eq 'send')
 			|| ($classNode-&gt;{astNodeName} eq 'DOM' and $name eq 'operator&lt;&lt;') # Avoid kdbgstream debugging method
+			|| ($name eq 'initgroups')
 			|| ($name eq 'qInitJpegIO' and $main::qt4)
 			|| ($name eq 'qInitPngIO' and $main::qt4)
 			|| ($name eq 'qt_metacast' and $main::qt4)
@@ -716,6 +754,9 @@
 				|| ($classNode-&gt;{astNodeName} eq 'QUrl' and $name eq 'QUrl'
 					and $#{$m-&gt;{ParamList}} == 0 &amp;&amp; $m-&gt;{ParamList}[0]-&gt;{ArgType} eq 'QUrlPrivate&amp;')
 				|| ($classNode-&gt;{astNodeName} eq 'QGlobalSpace' and $name eq 'operator&lt;&lt;' and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /QDebug/)
+				|| ($classNode-&gt;{astNodeName} eq 'QGlobalSpace' and $name eq 'qDebug')
+				|| ($classNode-&gt;{astNodeName} eq 'QGlobalSpace' and $name eq 'qWarning')
+				|| ($classNode-&gt;{astNodeName} eq 'QGlobalSpace' and $name eq 'qCritical')
 				|| ($classNode-&gt;{astNodeName} eq 'QGlobalSpace' and $#{$m-&gt;{ParamList}} &gt; 0 and $name =~ /operator/ and $m-&gt;{ParamList}[1]-&gt;{ArgType} =~ /QVariant::Type/)
 				|| ($#{$m-&gt;{ParamList}} &gt; 0 and $m-&gt;{ParamList}[0]-&gt;{ArgType} =~ /Private/)
 				|| ($classNode-&gt;{astNodeName} eq 'QScrollArea' and $name eq 'alignment')
@@ -726,7 +767,10 @@
 				|| ($classNode-&gt;{astNodeName} eq 'QDBusBusService' and $name eq 'requestName')
 				|| ($classNode-&gt;{astNodeName} eq 'QGLFormat' and $name eq 'openGLVersionFlags')
 				|| ($classNode-&gt;{astNodeName} eq 'QAbstractUndoItem' and $name eq '~QAbstractUndoItem')
+				|| ($classNode-&gt;{astNodeName} eq 'QApplication' and $name eq 'setKeypadNavigationEnabled')
+				|| ($classNode-&gt;{astNodeName} eq 'QApplication' and $name eq 'keypadNavigationEnabled')
 				|| ($name eq 'qDBusMetaTypeId')
+				|| ($m-&gt;{ReturnType} =~ /template/)
 				|| ($m-&gt;{ReturnType} =~ /QT3_SUPPORT/) ) )
 
 			|| $m-&gt;{Deprecated} ) {
@@ -752,6 +796,24 @@
 				$kledAmbiguousConstructor = $m;
 			}
 		}
+
+		# cut the last arguments in size(), boundingRect(), both methods was ambiguous
+		if ($classNode-&gt;{astNodeName} eq 'QFontMetrics' and $name eq 'boundingRect' &amp;&amp; $#{$m-&gt;{ParamList}} == 7) {
+			if ($m-&gt;{ParamList}[7]-&gt;{ArgType} =~ /int/ &amp;&amp; defined $m-&gt;{ParamList}[7]-&gt;{DefaultValue}) {
+			    pop(@{$m-&gt;{ParamList}});
+			    $#{$m-&gt;{ParamList}}--;
+			    $m-&gt;{Params} =~ s/int \*tabarray\=0//;
+			}
+		}
+
+		if ($classNode-&gt;{astNodeName} eq 'QFontMetrics' and $name eq 'size' &amp;&amp; $#{$m-&gt;{ParamList}} == 3) {
+			if ($m-&gt;{ParamList}[3]-&gt;{ArgType} =~ /int/ &amp;&amp; defined $m-&gt;{ParamList}[3]-&gt;{DefaultValue}) {
+			    pop(@{$m-&gt;{ParamList}});
+			    $#{$m-&gt;{ParamList}}--;
+			    $m-&gt;{Params} =~ s/int \*tabarray\=0//;
+			}
+		}
+
 		
 	    my $argId = 0;
 	    my $firstDefaultParam;
@@ -1302,7 +1364,13 @@
 		$sig = $class_name . &quot;::&quot; . $signature;
 		$idx = $allMethods{$sig};
 	}
-    die &quot;generateVirtualMethod: $className: No method found for $sig\n&quot; if !defined $idx;
+#    die &quot;generateVirtualMethod: $className: No method found for $sig\n&quot; if !defined $idx;
+
+if ( !defined $idx ) {
+    print &quot;generateVirtualMethod: $className: No method found for $sig\n&quot;;
+    return ('', '');
+}
+
     if($flags =~ &quot;p&quot;) { # pure virtual
 	$methodCode .= &quot;\t${libname}_Smoke-&gt;binding-&gt;callMethod($idx, (void*)$this, x, true /*pure virtual*/);\n&quot;;
     } else {

Modified: trunk/kalyptus/kalyptusDataDict.pm
===================================================================
--- trunk/kalyptus/kalyptusDataDict.pm	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/kalyptus/kalyptusDataDict.pm	2007-02-19 21:34:59 UTC (rev 290)
@@ -51,6 +51,7 @@
 'DCOPObject' =&gt; 'DCOPObjectInterface',
 'KDevCore' =&gt; 'KDevCoreInterface',
 'QSqlQuery' =&gt; 'QSqlQueryInterface',
+'QGraphicsItem' =&gt; 'QGraphicsItemInterface',
 
 );
 
@@ -2366,7 +2367,6 @@
 'Section&amp;'  =&gt;  'kde_Section*' ,
 'Section*&amp;'  =&gt;  'kde_Section*' ,
 'Section*'  =&gt;  'kde_Section*' ,
-'SegmentStyle' =&gt; 'int',
 'SelectionInterface*' =&gt; 'kde_SelectionInterface*',
 'Separator' =&gt; 'int',
 'Server&amp;'  =&gt;  'Server*' ,

Copied: trunk/php_qt (from rev 289, trunk/qt)

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/qt/php_qt.cpp	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/php_qt/php_qt.cpp	2007-02-19 21:34:59 UTC (rev 290)
@@ -25,6 +25,7 @@
 
 //#define DEBUG=0
 
+#include &lt;QtCore/qglobal.h&gt;
 #include &lt;zend_interfaces.h&gt;
 #include &quot;php_qt.h&quot;
 
@@ -93,7 +94,7 @@
 Smoke::Index qstring;
 Smoke::Index qobject;
 zend_class_entry* qobject_ce;
-zend_class_entry* qstring_ce;
+extern zend_class_entry* qstring_ce;
 
 /**
  *	proxy handler
@@ -322,7 +323,7 @@
 	// object list
 	le_php_qt_hashtype = zend_register_list_destructors_ex(phpqt_destroy_hashtable, NULL, &quot;PHP-Qt object list&quot;, module_number);
 	// FIXME: 50 is fix
-	zend_hash_init_ex(&amp;php_qt_objptr_hash, 50, NULL, NULL, 1, 0);
+	zend_hash_init_ex(&amp;php_qt_objptr_hash, PHPQT_CLASS_COUNT, NULL, NULL, 1, 0);
 
 	// overwrite method handler
 	php_qt_handler = *zend_get_std_object_handlers();
@@ -335,7 +336,7 @@
 	smokephp_findConnect();
 
 	Smoke::Index qobject = smokephp_getClassId(&quot;QObject&quot;);
-	Smoke::Index qstring = smokephp_getClassId(&quot;QString&quot;);
+//	Smoke::Index qstring = smokephp_getClassId(&quot;QString&quot;);
 
     php_qt_static_methods = (zend_function_entry***) safe_emalloc((qt_Smoke-&gt;numClasses), sizeof(zend_function_entry **), 0);
 
@@ -435,7 +436,7 @@
 			zend_declare_class_constant_long(ce_ptr, &quot;Bold&quot;, strlen(&quot;Bold&quot;), QFont::Bold);
 		} 
 		
-	}
+	} // end for
 
     for(Smoke::Index i = 1; i &lt;= qt_Smoke-&gt;numClasses; i++){
 		zend_class_entry *ce = zend_fetch_class((char*) qt_Smoke-&gt;classes[i].className, strlen(qt_Smoke-&gt;classes[i].className), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/qt/php_qt.h	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/php_qt/php_qt.h	2007-02-19 21:34:59 UTC (rev 290)
@@ -23,25 +23,28 @@
 #define debug
 #define MONITOR
 
+#define COMPILE_DL_PHP_QT
+#define PHPQT_CLASS_COUNT 50
+
 #include &lt;iostream&gt;
 using namespace std;
 
 #include &lt;zend_interfaces.h&gt;
 #include &quot;smoke.h&quot;
 
-#include &lt;QTextStream&gt;
-#include &lt;QVariant&gt;
-#include &lt;QWidget&gt;
-#include &lt;QStack&gt;
-#include &lt;QString&gt;
-#include &lt;QMetaMethod&gt;
-#include &lt;QHash&gt;
-#include &lt;QCoreApplication&gt;
-#include &lt;QApplication&gt;
+#include &lt;QtCore/QTextStream&gt;
+#include &lt;QtCore/QVariant&gt;
+#include &lt;QtCore/QStack&gt;
+#include &lt;QtCore/QString&gt;
+#include &lt;QtCore/QMetaMethod&gt;
+#include &lt;QtCore/QHash&gt;
+#include &lt;QtCore/QCoreApplication&gt;
 
-#include &lt;QLayout&gt;
-#include &lt;QLCDNumber&gt;
-#include &lt;QFont&gt;
+#include &lt;QtGui/QWidget&gt;
+#include &lt;QtGui/QApplication&gt;
+#include &lt;QtGui/QLayout&gt;
+#include &lt;QtGui/QLCDNumber&gt;
+#include &lt;QtGui/QFont&gt;
 
 // for older php versions
 #ifndef ZEND_MN
@@ -74,11 +77,6 @@
 
 #define PHP_QT_ME(classname, name, arg_info, flags)	PHP_QT_FENTRY(name, ZEND_MN(classname##_##name), arg_info, flags)
 
-
-#ifdef HAVE_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
 #include &quot;php.h&quot;
 #include &quot;php_ini.h&quot;
 #include &quot;ext/standard/info.h&quot;

Added: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/qt/qstring.cpp	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/php_qt/qstring.cpp	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,2497 @@
+/*
+ * PHP-Qt - The PHP language bindings for Qt
+ *
+ * Copyright (C) 2005
+ * Thomas Moenicke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">tm at ippfp.org</A>&gt;,
+ * Jean-Luc Gyger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">jean_luc.gyger at freesurf.ch</A>&gt;
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * QString.cpp - QString PHP implementation.
+ * begin           : Wed Jan 18 23:31:01 2006
+ * generated by    : moni using kalyptus 0.9.
+ */
+
+#include &lt;iostream&gt;
+using namespace std;
+
+
+
+#include &lt;QtCore/QString&gt;
+#include &lt;zend_interfaces.h&gt;
+#include &quot;php_qt.h&quot;
+
+zend_class_entry* qstring_ce;
+
+ZEND_METHOD(QString,__toString){
+
+  QString *QString_ptr = (QString *) PHP_QT_FETCH();
+
+  int l = QString_ptr-&gt;size();
+
+  char* c = (char*) (QString_ptr-&gt;toUtf8()).constData();
+
+  RETURN_STRING(c,l);
+}
+
+
+/*		public enumSectionFlag:long {
+			SectionDefault = 0x00,
+			SectionSkipEmpty = 0x01,
+			SectionIncludeLeadingSep = 0x02,
+			SectionIncludeTrailingSep = 0x04,
+			SectionCaseInsensitiveSeps = 0x08
+		}
+*/
+
+/*		public enumSplitBehavior:long {
+			SplitBehavior = 0,
+			SplitBehavior = 1
+		}
+*/
+
+/*		public enumNormalizationForm:long {
+			NormalizationForm = 0,
+			NormalizationForm = 1,
+			NormalizationForm = 2,
+			NormalizationForm = 3
+		}
+*/
+/*********************************
+ *    class     QString */
+/*
+ *    function  compare
+ *    flags:    c
+ */
+ZEND_METHOD(QString, compare){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* o public*/
+
+		/* const QString&amp; s,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* oo public*/
+
+		/* const QString&amp; s1, const QString&amp; s2,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  utf16
+ *    flags:    c
+ */
+ZEND_METHOD(QString, utf16){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				const ushort * return_object = (const ushort *) obj-&gt;utf16();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  constData
+ *    flags:    c
+ */
+ZEND_METHOD(QString, constData){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				const QChar * return_object = (const QChar *) obj-&gt;constData();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  insert
+ *    flags:    
+ */
+ZEND_METHOD(QString, insert){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int i, char c,  */
+		/* lo public*/
+
+		/* int i, const QString&amp; s,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString &amp; return_object = (QString &amp;) obj-&gt;insert((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* lol public*/
+
+		/* int i, const QChar* uc, int len,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  clear
+ *    flags:    
+ */
+ZEND_METHOD(QString, clear){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			obj-&gt;clear();
+			RETURN_NULL();
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  setUtf16
+ *    flags:    
+ */
+ZEND_METHOD(QString, setUtf16){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const ushort* utf16, int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString &amp; return_object = (QString &amp;) obj-&gt;setUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  prepend
+ *    flags:    
+ */
+ZEND_METHOD(QString, prepend){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* char c,  */
+		/* s public*/
+
+		/* const char* s,  */
+		/* o public*/
+
+		/* const QString&amp; s,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString &amp; return_object = (QString &amp;) obj-&gt;prepend((char) Z_LVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_STRING){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString &amp; return_object = (QString &amp;) obj-&gt;prepend( (const char*) Z_STRVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  trimmed
+ *    flags:    c
+ */
+ZEND_METHOD(QString, trimmed){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				QString return_object = (QString) obj-&gt;trimmed();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  chop
+ *    flags:    
+ */
+ZEND_METHOD(QString, chop){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int n,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj-&gt;chop((int) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  leftJustified
+ *    flags:    c
+ */
+ZEND_METHOD(QString, leftJustified){
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* lll public*/
+
+		/* int width, char fill, int trunc,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;leftJustified((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(bool) Z_LVAL_P(z_2));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  squeeze
+ *    flags:    
+ */
+ZEND_METHOD(QString, squeeze){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			obj-&gt;squeeze();
+			RETURN_NULL();
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  count
+ *    flags:    c
+ */
+ZEND_METHOD(QString, count){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_LONG(obj-&gt;count());
+	}
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* o public*/
+
+		/* const QRegExp&amp; ,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QString&amp; s, int cs,  */
+		/* ll public*/
+
+		/* char c, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj-&gt;count((char) Z_LVAL_P(z_0) ,(Qt::CaseSensitivity) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fromAscii
+ *    flags:    s
+ */
+ZEND_METHOD(QString, fromAscii){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* sl public*/
+
+		/* const char* , int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;fromAscii( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toLongLong
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toLongLong){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj-&gt;toLongLong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toUpper
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toUpper){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				QString return_object = (QString) obj-&gt;toUpper();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  QString
+ *    flags:    
+ */
+ZEND_METHOD(QString, __construct){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *QString_ptr = new QString();
+				PHP_QT_REGISTER(QString_ptr);
+				RETURN_NULL();
+	}
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* char c,  */
+		/* s public*/
+
+		/* const char* ch,  */
+		/* o public*/
+
+		/* const QLatin1String&amp; latin1,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+
+
+			QString *QString_ptr = new QString((char) Z_LVAL_P(z_0));
+				PHP_QT_REGISTER(QString_ptr);
+				RETURN_NULL();
+			}
+			if(Z_TYPE_P(z_0) == IS_STRING){
+
+			QString *QString_ptr = new QString( (const char*) Z_STRVAL_P(z_0));
+
+				PHP_QT_REGISTER(QString_ptr);
+				RETURN_NULL();
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QChar* unicode, int size,  */
+		/* ll public*/
+
+		/* int size, char c,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+
+
+			QString *QString_ptr = new QString((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
+				PHP_QT_REGISTER(QString_ptr);
+				RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  normalized
+ *    flags:    c
+ */
+ZEND_METHOD(QString, normalized){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* o public*/
+
+		/* QString::NormalizationForm mode,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;normalized((QString::NormalizationForm) Z_LVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* QString::NormalizationForm mode, int version,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;normalized((QString::NormalizationForm) Z_LVAL_P(z_0) ,(QChar::UnicodeVersion) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fromUtf16
+ *    flags:    s
+ */
+ZEND_METHOD(QString, fromUtf16){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const ushort* , int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;fromUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  isRightToLeft
+ *    flags:    c
+ */
+ZEND_METHOD(QString, isRightToLeft){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_BOOL(obj-&gt;isRightToLeft());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  setNum
+ *    flags:    
+ */
+ZEND_METHOD(QString, setNum){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* short , int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString &amp; return_object = (QString &amp;) obj-&gt;setNum((short) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* oll public*/
+
+		/* float , char f, int prec,  */
+		/* lll public*/
+
+		/* double , char f, int prec,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString &amp; return_object = (QString &amp;) obj-&gt;setNum((float) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString &amp; return_object = (QString &amp;) obj-&gt;setNum((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  endsWith
+ *    flags:    c
+ */
+ZEND_METHOD(QString, endsWith){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QString&amp; s, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  number
+ *    flags:    s
+ */
+ZEND_METHOD(QString, number){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* unsigned long , int base,  */
+		/* ll public*/
+
+		/* int , int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;number((ulong) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;number((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* lll public*/
+
+		/* double , char f, int prec,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;number((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  localeAwareCompare
+ *    flags:    c
+ */
+ZEND_METHOD(QString, localeAwareCompare){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* o public*/
+
+		/* const QString&amp; s,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* oo public*/
+
+		/* const QString&amp; s1, const QString&amp; s2,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  section
+ *    flags:    c
+ */
+ZEND_METHOD(QString, section){
+
+	if (ZEND_NUM_ARGS() == 4){
+		/* lllo public*/
+
+		/* char sep, int start, int end, QString::SectionFlags flags,  */
+		/* ollo public*/
+
+		/* const QString&amp; in_sep, int start, int end, QString::SectionFlags flags,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		zval *z_3; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;section((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(QString::SectionFlags) Z_LVAL_P(z_3));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  isSimpleText
+ *    flags:    c
+ */
+ZEND_METHOD(QString, isSimpleText){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_BOOL(obj-&gt;isSimpleText());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  size
+ *    flags:    c
+ */
+ZEND_METHOD(QString, size){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_LONG(obj-&gt;size());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  simplified
+ *    flags:    c
+ */
+ZEND_METHOD(QString, simplified){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				QString return_object = (QString) obj-&gt;simplified();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toUInt
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toUInt){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj-&gt;toUInt((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toUShort
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toUShort){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj-&gt;toUShort((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  truncate
+ *    flags:    
+ */
+ZEND_METHOD(QString, truncate){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int pos,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj-&gt;truncate((int) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toAscii
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toAscii){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_STRING((char*) obj-&gt;toAscii().constData(), 1);
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  length
+ *    flags:    c
+ */
+ZEND_METHOD(QString, length){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_LONG(obj-&gt;length());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  right
+ *    flags:    c
+ */
+ZEND_METHOD(QString, right){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int len,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;right((int) Z_LVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  push_front
+ *    flags:    
+ */
+ZEND_METHOD(QString, push_front){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* char c,  */
+		/* o public*/
+
+		/* const QString&amp; s,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj-&gt;push_front((char) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toUtf8
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toUtf8){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_STRING((char*) obj-&gt;toUtf8().constData(), 1);
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toULongLong
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toULongLong){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj-&gt;toULongLong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  indexOf
+ *    flags:    c
+ */
+ZEND_METHOD(QString, indexOf){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QRegExp&amp; , int from,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* oll public*/
+
+		/* const QString&amp; s, int from, int cs,  */
+		/* lll public*/
+
+		/* char c, int from, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj-&gt;indexOf((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(Qt::CaseSensitivity) Z_LVAL_P(z_2)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fromRawData
+ *    flags:    s
+ */
+ZEND_METHOD(QString, fromRawData){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QChar* , int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  constEnd
+ *    flags:    c
+ */
+ZEND_METHOD(QString, constEnd){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			obj-&gt;constEnd();
+			RETURN_NULL();
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  left
+ *    flags:    c
+ */
+ZEND_METHOD(QString, left){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int len,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;left((int) Z_LVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fromLocal8Bit
+ *    flags:    s
+ */
+ZEND_METHOD(QString, fromLocal8Bit){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* sl public*/
+
+		/* const char* , int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;fromLocal8Bit( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  startsWith
+ *    flags:    c
+ */
+ZEND_METHOD(QString, startsWith){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QString&amp; s, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  remove
+ *    flags:    
+ */
+ZEND_METHOD(QString, remove){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* o public*/
+
+		/* const QRegExp&amp; rx,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QString&amp; s, int cs,  */
+		/* ll public*/
+
+		/* int i, int len,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString &amp; return_object = (QString &amp;) obj-&gt;remove((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  isEmpty
+ *    flags:    c
+ */
+ZEND_METHOD(QString, isEmpty){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_BOOL(obj-&gt;isEmpty());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  arg
+ *    flags:    c
+ */
+ZEND_METHOD(QString, arg){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* oo public*/
+
+		/* const QString&amp; a1, const QString&amp; a2,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* ooo public*/
+
+		/* const QString&amp; a1, const QString&amp; a2, const QString&amp; a3,  */
+		/* olo public*/
+
+		/* const QString&amp; a, int fieldWidth, const QChar&amp; fillChar,  */
+		/* llo public*/
+
+		/* char a, int fieldWidth, const QChar&amp; fillChar,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 4){
+		/* lllo public*/
+
+		/* int a, int fieldWidth, int base, const QChar&amp; fillChar,  */
+		/* ollo public*/
+
+		/* qlonglong a, int fieldwidth, int base, const QChar&amp; fillChar,  */
+		/* oooo public*/
+
+		/* const QString&amp; a1, const QString&amp; a2, const QString&amp; a3, const QString&amp; a4,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		zval *z_3; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_3 = (QObject*) phpqt_fetch(z_3);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_3 = (QObject*) phpqt_fetch(z_3);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_3) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+			QObject* obj_z_3 = (QObject*) phpqt_fetch(z_3);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 5){
+		/* llllo public*/
+
+		/* double a, int fieldWidth, char fmt, int prec, const QChar&amp; fillChar,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		zval *z_3; // define ZVAL
+		zval *z_4; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3, &amp;z_4) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG &amp;&amp; Z_TYPE_P(z_3) == IS_LONG &amp;&amp; Z_TYPE_P(z_4) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_4 = (QObject*) phpqt_fetch(z_4);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  vsprintf
+ *    flags:    
+ */
+ZEND_METHOD(QString, vsprintf){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* so public*/
+
+		/* const char* format, va_list ap,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toFloat
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toFloat){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int* ok,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+//			RETURN_FLOAT(obj-&gt;toFloat((bool*) Z_LVAL_P(z_0)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  isDetached
+ *    flags:    c
+ */
+ZEND_METHOD(QString, isDetached){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_BOOL(obj-&gt;isDetached());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  reserve
+ *    flags:    
+ */
+ZEND_METHOD(QString, reserve){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int size,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj-&gt;reserve((int) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toULong
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toULong){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+//			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+//			RETURN_ULONG(obj-&gt;toULong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toShort
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toShort){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+//			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+//			RETURN_SHORT(obj-&gt;toShort((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  split
+ *    flags:    c
+ */
+ZEND_METHOD(QString, split){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* oo public*/
+
+		/* const QRegExp&amp; sep, QString::SplitBehavior behavior,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* ool public*/
+
+		/* const QString&amp; sep, QString::SplitBehavior behavior, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  setUnicode
+ *    flags:    
+ */
+ZEND_METHOD(QString, setUnicode){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QChar* unicode, int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fromLatin1
+ *    flags:    s
+ */
+ZEND_METHOD(QString, fromLatin1){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* sl public*/
+
+		/* const char* , int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;fromLatin1( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  data
+ *    flags:    
+ */
+ZEND_METHOD(QString, data){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				QChar * return_object = (QChar *) obj-&gt;data();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toLatin1
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toLatin1){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_STRING((char*) obj-&gt;toLatin1().constData(), 1);
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  end
+ *    flags:    
+ */
+ZEND_METHOD(QString, end){
+	if (ZEND_NUM_ARGS() == 0){
+//			QString *obj = (QString*) PHP_QT_FETCH();
+//			RETURN_INTPTR(obj-&gt;end());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  contains
+ *    flags:    c
+ */
+ZEND_METHOD(QString, contains){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* o public*/
+
+		/* const QRegExp&amp; rx,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QString&amp; s, int cs,  */
+		/* ll public*/
+
+		/* char c, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj-&gt;contains((char) Z_LVAL_P(z_0) ,(Qt::CaseSensitivity) Z_LVAL_P(z_1));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  resize
+ *    flags:    
+ */
+ZEND_METHOD(QString, resize){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int size,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj-&gt;resize((int) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  replace
+ *    flags:    
+ */
+ZEND_METHOD(QString, replace){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* oo public*/
+
+		/* const QRegExp&amp; rx, const QString&amp; after,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* ool public*/
+
+		/* const QString&amp; before, const QString&amp; after, int cs,  */
+		/* lol public*/
+
+		/* char c, const QString&amp; after, int cs,  */
+		/* lll public*/
+
+		/* int i, int len, char after,  */
+		/* llo public*/
+
+		/* int i, int len, const QString&amp; after,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_1 = (QObject*) phpqt_fetch(z_1);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString &amp; return_object = (QString &amp;) obj-&gt;replace((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(char) Z_LVAL_P(z_2));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 4){
+		/* llol public*/
+
+		/* int i, int len, const QChar* s, int slen,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		zval *z_3; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2, &amp;z_3) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_3) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_2 = (QObject*) phpqt_fetch(z_2);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fromUtf8
+ *    flags:    s
+ */
+ZEND_METHOD(QString, fromUtf8){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* sl public*/
+
+		/* const char* , int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_STRING &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+
+// wichtig: Speicher auf dem Heap alloziieren
+			  QString *return_object = new QString;
+  			  if(getThis() != NULL){
+		        QString *obj = (QString*) PHP_QT_FETCH();
+// hier einfach &#252;berschreiben
+      			*return_object = (QString) obj-&gt;fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+// static
+		      } else {
+		        *return_object = (QString) QString::fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+
+		      }		
+			  zend_class_entry *ce;                                   
+			  object_init_ex(return_value, qstring_ce);
+			  zend_rsrc_list_entry le;                            
+			  le.ptr = return_object;
+			  phpqt_register(return_value,le);
+			  return;
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toLong
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toLong){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj-&gt;toLong((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  detach
+ *    flags:    
+ */
+ZEND_METHOD(QString, detach){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			obj-&gt;detach();
+			RETURN_NULL();
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  append
+ *    flags:    
+ */
+ZEND_METHOD(QString, append){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* char c,  */
+		/* s public*/
+
+		/* const char* s,  */
+		/* o public*/
+
+		/* const QString&amp; s,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString &amp; return_object = (QString &amp;) obj-&gt;append((char) Z_LVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_STRING){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString &amp; return_object = (QString &amp;) obj-&gt;append( (const char*) Z_STRVAL_P(z_0));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  mid
+ *    flags:    c
+ */
+ZEND_METHOD(QString, mid){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int i, int len,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;mid((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toDouble
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toDouble){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int* ok,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_DOUBLE(obj-&gt;toDouble((bool*) Z_LVAL_P(z_0)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  fill
+ *    flags:    
+ */
+ZEND_METHOD(QString, fill){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* char c, int size,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString &amp; return_object = (QString &amp;) obj-&gt;fill((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  rightJustified
+ *    flags:    c
+ */
+ZEND_METHOD(QString, rightJustified){
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* lll public*/
+
+		/* int width, char fill, int trunc,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+				QString return_object = (QString) obj-&gt;rightJustified((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(bool) Z_LVAL_P(z_2));
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toLower
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toLower){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				QString return_object = (QString) obj-&gt;toLower();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  lastIndexOf
+ *    flags:    c
+ */
+ZEND_METHOD(QString, lastIndexOf){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ol public*/
+
+		/* const QRegExp&amp; , int from,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+
+	if (ZEND_NUM_ARGS() == 3){
+		/* oll public*/
+
+		/* const QString&amp; s, int from, int cs,  */
+		/* lll public*/
+
+		/* char c, int from, int cs,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		zval *z_2; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zzz&quot;, &amp;z_0, &amp;z_1, &amp;z_2) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_OBJECT &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG &amp;&amp; Z_TYPE_P(z_2) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj-&gt;lastIndexOf((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(Qt::CaseSensitivity) Z_LVAL_P(z_2)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  unicode
+ *    flags:    c
+ */
+ZEND_METHOD(QString, unicode){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+				const QChar * return_object = (const QChar *) obj-&gt;unicode();
+				zend_class_entry *ce;                                   
+				object_init_ex(return_value, qstring_ce);     
+				zend_rsrc_list_entry le;                            
+				le.ptr = (void*) &amp;return_object;                                       
+				phpqt_register(return_value,le);                   
+				return;                                             
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  at
+ *    flags:    c
+ */
+ZEND_METHOD(QString, at){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* int i,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj-&gt;at((int) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  begin
+ *    flags:    
+ */
+ZEND_METHOD(QString, begin){
+	if (ZEND_NUM_ARGS() == 0){
+//			QString *obj = (QString*) PHP_QT_FETCH();
+//			RETURN_INTPTR(obj-&gt;begin());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  push_back
+ *    flags:    
+ */
+ZEND_METHOD(QString, push_back){
+
+	if (ZEND_NUM_ARGS() == 1){
+		/* l public*/
+
+		/* char c,  */
+		/* o public*/
+
+		/* const QString&amp; s,  */
+		zval *z_0; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;z&quot;, &amp;z_0) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			obj-&gt;push_back((char) Z_LVAL_P(z_0));
+			RETURN_NULL();
+			}
+			if(Z_TYPE_P(z_0) == IS_OBJECT){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			QObject* obj_z_0 = (QObject*) phpqt_fetch(z_0);
+
+
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  capacity
+ *    flags:    c
+ */
+ZEND_METHOD(QString, capacity){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_LONG(obj-&gt;capacity());
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  constBegin
+ *    flags:    c
+ */
+ZEND_METHOD(QString, constBegin){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			obj-&gt;constBegin();
+			RETURN_NULL();
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toLocal8Bit
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toLocal8Bit){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_STRING((char*) obj-&gt;toLocal8Bit().constData(), 1);
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  toInt
+ *    flags:    c
+ */
+ZEND_METHOD(QString, toInt){
+
+	if (ZEND_NUM_ARGS() == 2){
+		/* ll public*/
+
+		/* int* ok, int base,  */
+		zval *z_0; // define ZVAL
+		zval *z_1; // define ZVAL
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;zz&quot;, &amp;z_0, &amp;z_1) == SUCCESS) {
+			if(Z_TYPE_P(z_0) == IS_LONG &amp;&amp; Z_TYPE_P(z_1) == IS_LONG){
+			QString *obj = (QString*) PHP_QT_FETCH();
+
+
+			RETURN_LONG(obj-&gt;toInt((bool*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1)));
+			}
+		}
+	}
+}
+
+/*********************************
+ *    class     QString */
+/*
+ *    function  isNull
+ *    flags:    c
+ */
+ZEND_METHOD(QString, isNull){
+	if (ZEND_NUM_ARGS() == 0){
+			QString *obj = (QString*) PHP_QT_FETCH();
+			RETURN_BOOL(obj-&gt;isNull());
+	}
+}
+
+# warning: implement me
+//PHP_QT_DESTRUCT(QString);
+

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/qt/smokephp.cpp	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/php_qt/smokephp.cpp	2007-02-19 21:34:59 UTC (rev 290)
@@ -22,10 +22,10 @@
 
 #include &quot;php_qt.h&quot;
 #include &quot;smoke.h&quot;
-#include &lt;QMetaMethod&gt;
-#include &lt;QHash&gt;
-#include &lt;QCoreApplication&gt;
-#include &lt;QApplication&gt;
+#include &lt;QtCore/QMetaMethod&gt;
+#include &lt;QtCore/QHash&gt;
+#include &lt;QtCore/QCoreApplication&gt;
+#include &lt;QtGui/QApplication&gt;
 
 extern Smoke *qt_Smoke;
 extern void init_qt_Smoke();
@@ -92,7 +92,7 @@
 smokephp_init() {
 
     if (qt_Smoke != 0L) {
-	php_error(E_ERROR,&quot;could not initialize smoke&quot;);
+		php_error(E_ERROR,&quot;could not initialize smoke&quot;);
     }
 
     init_qt_Smoke();

Added: trunk/smoke/CMakeLists.txt
===================================================================
--- trunk/smoke/CMakeLists.txt	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/CMakeLists.txt	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,18 @@
+
+#Laurent reuse configure.in.in
+#message(STATUS &quot;${CMAKE_CURRENT_SOURCE_DIR}: skipped subdir $(kde_build_libsmoke)&quot;)
+
+add_subdirectory(qt)
+#add_subdirectory(kde)
+
+########### install files ###############
+
+#install( FILES  smoke.h DESTINATION ${INCLUDE_INSTALL_DIR} )
+
+
+
+#original Makefile.am contents follow:
+
+#SUBDIRS = $(kde_build_libsmoke)
+#
+#include_HEADERS = smoke.h

Added: trunk/smoke/kde/CMakeLists.txt
===================================================================
--- trunk/smoke/kde/CMakeLists.txt	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/kde/CMakeLists.txt	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,153 @@
+
+include_directories( ${CMAKE_SOURCE_DIR}/smoke ${INCLUDE_INSTALL_DIR}/khexedit/ )
+
+set(srcdir ${CMAKE_CURRENT_SOURCE_DIR})
+set(KDE_PREFIX ${CMAKE_INSTALL_PREFIX})
+set(qt_includes ${QT_INCLUDE_DIR})
+set(kde_includes ${KDE4_INCLUDE_DIR})
+if(OPENGL_FOUND AND OPENGL_GLU_FOUND)
+   set(KDE_HAVE_GL &quot;yes&quot;)
+else(OPENGL_FOUND AND OPENGL_GLU_FOUND)
+   set(KDE_HAVE_GL &quot;no&quot;)
+endif(OPENGL_FOUND AND OPENGL_GLU_FOUND)	
+
+# for qtguess.pl
+set(qt_test_threshold 10)
+set(qtflags &quot;-lQtCore -lQtGui&quot;)
+FOREACH(filename ${QT_INCLUDES})
+    set(all_includes &quot;-I${filename} ${all_includes}&quot;)
+ENDFOREACH(filename)
+
+configure_file(generate.pl.cmake ${CMAKE_CURRENT_BINARY_DIR}/generate.pl @ONLY )
+configure_file(qtguess.pl.cmake ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl @ONLY)
+
+# macro is defined in qt-copy/src/qbase.pri but couldn't be found by qtguess, so I append it manually
+file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/qtdefines &quot;QT_NO_CAST_TO_ASCII\n&quot;)
+
+########### next target ###############
+
+add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_2.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_3.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_4.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_5.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_6.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_7.cpp 
+                ${CMAKE_CURRENT_BINARY_DIR}/x_8.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_9.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_10.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_11.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_12.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_13.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_14.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_15.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_16.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_17.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_18.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_19.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_20.cpp
+
+                  COMMAND ${PERL_EXECUTABLE} ARGS ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl
+                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl
+
+                  COMMAND ${PERL_EXECUTABLE} ARGS ${CMAKE_CURRENT_BINARY_DIR}/generate.pl
+                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/generate.pl
+                  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
+
+macro_add_file_dependencies( ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp ${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp )
+
+
+set(smokekde_LIB_SRCS ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp  
+		${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_2.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_3.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_4.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_5.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_6.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_7.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_8.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_9.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_10.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_11.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_12.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_13.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_14.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_15.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_16.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_17.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_18.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_19.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_20.cpp
+)
+
+kde4_add_library(smokekde SHARED ${smokekde_LIB_SRCS})
+
+target_link_libraries(smokekde 
+    ${QT_QTNETWORK_LIBRARY} 
+    ${QT_QTSQL_LIBRARY} 
+    ${QT_QTOPENGL_LIBRARY} 
+    ${QT_QTXML_LIBRARY} 
+    ${QT_QTSVG_LIBRARY} 
+    ${QT_QTUITOOLS_LIBRARY} 
+    ${QT_QT3SUPPORT_LIBRARY} 
+    ${KDE4_KDECORE_LIBS} 
+    ${KDE4_KDEUI_LIBS}
+    ${KDE4_KIO_LIBS} 
+    ${KDE4_KNOTIFYCONFIG_LIBS}
+    ${KDE4_SONNETUI_LIBS}
+    ${KDE4_KNEWSTUFF_LIBS}
+    ${KDE4_KDNSSD_LIBS}
+    ${KDE4_KHTML_LIBS}
+    ${KDE4_KDE3SUPPORT_LIBS}
+    kmediaplayer
+    kntlm )
+
+set_target_properties(smokekde PROPERTIES VERSION 2.0.0 SOVERSION 2 )
+install(TARGETS smokekde DESTINATION ${LIB_INSTALL_DIR} )
+
+
+########### install files ###############
+
+
+
+
+#original Makefile.am contents follow:
+
+#
+#
+#lib_LTLIBRARIES = libsmokekde.la
+#
+## set the include path for X, qt and KDE
+#INCLUDES         = -I$(srcdir)/.. $(all_includes) -I$(qt_includes)/QtUiTools \
+#                   -I$(qt_includes)/QtDBus
+#
+#EXTRA_DIST=generate.pl.in qtguess.pl.in qt_smoke.h Makefile.am
+#
+## the library search path. 
+#libsmokekde_la_LDFLAGS = -version-info 2:0:0 -no-undefined $(all_libraries) $(GLINC) $(KDE_RPATH)
+#
+## the libraries to link against.
+#libsmokekde_la_LIBADD   = $(LIB_QTCORE) $(LIB_QTGUI) $(LIB_QTNETWORK) \
+#						$(LIB_QTOPENGL) $(LIB_QTSQL) $(LIB_QTCORE) $(LIB_QTXML) $(LIB_QTSVG) \
+#						$(GLLIB) $(LIBQSCINTILLA) \
+#						-lQtSvg -lQtUiTools $(LIBQTDBUS) \
+#						$(LIB_KHTML) -lkjs -lfontconfig $(LIB_KMDI) $(LIB_KNS) $(LIB_KSPELL) \
+#						$(LIB_KUTILS) $(LIB_KDEPRINT)
+#
+#x_sources = x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+#   x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+#   x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp
+#
+## which sources should be compiled for perlqtkde
+#libsmokekde_la_SOURCES = smokedata.cpp $(x_sources)
+#
+#$(x_sources) smokedata.cpp:
+#	perl generate.pl
+#
+#CLEANFILES = $(libsmokekde_la_SOURCES)
+#
+#
+#
+#
+#

Added: trunk/smoke/kde/generate.pl.cmake
===================================================================
--- trunk/smoke/kde/generate.pl.cmake	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/kde/generate.pl.cmake	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,212 @@
+#!/usr/bin/perl -w
+
+## Run this first, to generate the x_*.cpp files from the Qt headers
+## using kalyptus
+
+my $kalyptusdir = &quot;@srcdir@/../../kalyptus&quot;;
+
+use File::Basename;
+use File::Copy qw|cp|;
+use File::Compare;
+use File::Find;
+use Cwd;
+
+my $here = getcwd;
+my $outdir = $here . &quot;/generate.pl.tmpdir&quot;;
+my $finaloutdir = $here;
+my $defines = &quot;qtdefines&quot;;
+my $headerlist = &quot;@srcdir@/header_list&quot;;
+my $kdeheaderlist = &quot;@srcdir@/kde_header_list&quot;;
+my $definespath = &quot;$here/$defines&quot;;
+my $headerlistpath = &quot;$here/$headerlist&quot;;
+my $kdeheaderlistpath = &quot;$here/$kdeheaderlist&quot;;
+
+# If srcdir != builddir, then srcdir is probvably an absolute
+# path, and it makes no sense to prepend $here.
+$definespath = $defines if $defines =~ /^\//;
+$headerlistpath = $headerlist if $headerlist =~ /^\//;
+$kdeheaderlistpath = $kdeheaderlist if $kdeheaderlist =~ /^\//;
+
+## Note: outdir and finaloutdir should NOT be the same dir!
+
+# Delete all x_*.cpp files under outdir (or create outdir if nonexistent)
+if (-d $outdir) { system &quot;rm -f $outdir/x_*.cpp&quot;; } else { mkdir $outdir; }
+
+mkdir $finaloutdir unless (-d $finaloutdir);
+
+#  Load the QT_NO_* macros found in &quot;qtdefines&quot;. They'll be passed to kalyptus
+my $macros=&quot;&quot;;
+if ( -e $definespath ){
+    print &quot;Found '$defines'. Reading preprocessor symbols from there...\n&quot;;
+    $macros = &quot; --defines=$definespath &quot;;
+}
+
+# Need to cd to kalyptus's directory so that perl finds Ast.pm etc.
+chdir &quot;$kalyptusdir&quot; or die &quot;Couldn't go to $kalyptusdir (edit script to change dir)\n&quot;;
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %excludes = (
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %includes;
+open(HEADERS, $headerlistpath) or die &quot;Couldn't open $headerlistpath: $!\n&quot;;
+map { chomp ; $includes{$_} = 1 unless /^\s*#/ } &lt;HEADERS&gt;;
+close HEADERS;
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %kdeexcludes = (
+#   These headers don't look suitable for inclusion:
+	'kallocator.h' =&gt; 1,
+	'kbookmarkimporter_crash.h' =&gt; 1,
+	'kbookmarkimporter_ie.h' =&gt; 1,
+	'kbookmarkimporter_opera.h' =&gt; 1,
+	'kbookmarkimporter_ns.h' =&gt; 1,
+	'kcrash.h' =&gt; 1,
+	'kdebug.h' =&gt; 1,
+	'kde_terminal_interface.h' =&gt; 1,
+
+#	These headers currently give problems
+	'kio/uiserver.h' =&gt; 1,
+	'kio/thumbcreator.h' =&gt; 1,
+	'kio/file.h' =&gt; 1,
+	'kio/chmodjob.h' =&gt; 1,
+	'kparts/genericfactory.h' =&gt; 1,
+	'kopenssl.h' =&gt; 1,
+	'kautomount.h' =&gt; 1,
+	'kimagefilepreview.h' =&gt; 1,
+	'kpropertiesdialog.h' =&gt; 1,
+	'knotifydialog.h' =&gt; 1,
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %kdeincludes;
+open(HEADERS, $kdeheaderlistpath) or die &quot;Couldn't open $kdeheaderlistpath: $!\n&quot;;
+map { chomp ; $kdeincludes{$_} = 1 unless /^\s*#/ } &lt;HEADERS&gt;;
+close HEADERS;
+
+# Can we compile the OpenGl module ?
+if(&quot;@KDE_HAVE_GL@&quot; eq &quot;yes&quot;)
+{
+    open(DEFS, $definespath);
+    my @defs = &lt;DEFS&gt;;
+    close DEFS;
+    if(!grep(/QT_NO_OPENGL/, @defs))
+    {
+      $excludes{'qgl.h'} = undef;
+      $excludes{'qglcolormap.h'} = undef;
+    }
+    else
+    {
+      print STDERR &quot;Qt was not compiled with OpenGL support...\n Skipping QGL Classes.\n&quot;;
+    }
+}
+
+# List Qt headers, and exclude the ones listed above
+my @headers = ();
+
+$qtinc= '@qt_includes@';
+
+find(
+    {   wanted =&gt; sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qtinc);
+                if( !defined $excludes{$f} # Not excluded
+                     &amp;&amp; $includes{$f}        # Known header
+                     &amp;&amp; /\.h$/)     # Not a backup file etc. Only headers.
+                {
+                    my $header = $_;
+                    open(FILE, $_);
+                    my @header_lines = &lt;FILE&gt;;
+                    if (@header_lines == 1) {
+                        $line = $header_lines[0];
+                        if ($line =~ /^#include &quot;(.*)&quot;/) {
+                            push ( @headers, $qtinc . substr($1, 2) );
+                        } else {
+                            push ( @headers, $header );
+                        }
+                    } else {
+                        push ( @headers, $header );
+                    }
+                }
+	    	undef $includes{$f}   
+	     };
+	},
+	follow_fast =&gt; 1,
+	follow_skip =&gt; 2,
+	no_chdir =&gt; 1
+    }, $qtinc
+ );
+
+my @kdeheaders = ();
+$kdeprefix = &quot;@KDE_PREFIX@&quot;;
+$kdeinc= '@kde_includes@';
+$kdeinc =~ s/\${prefix}/$kdeprefix/; # Remove ${prefix} in src != build
+-d $kdeinc or die &quot;Couldn't process $kdeinc: $!\n&quot;;
+
+find(
+    {   wanted =&gt; sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $kdeinc);
+                push ( @kdeheaders, $_ )
+	    	  if( !defined $kdeexcludes{$f} # Not excluded
+	    	     &amp;&amp; $kdeincludes{$f}        # Known header
+	    	     &amp;&amp; /\.h$/);     # Not a backup file etc. Only headers.
+	    	undef $kdeincludes{$f}   
+	     };
+	},
+	follow_fast =&gt; 1,
+	follow_skip =&gt; 2,
+	no_chdir =&gt; 1
+    }, $kdeinc
+ );
+
+# Launch kalyptus
+system &quot;perl kalyptus @ARGV --qt4 --globspace -fsmoke --name=qt $macros --no-cache --allow_k_dcop_accessors --outputdir=$outdir @headers @kdeheaders&quot;;
+my $exit = $? &gt;&gt; 8;
+exit $exit if ($exit);
+
+# Generate diff for smokedata.cpp
+unless ( -e &quot;$finaloutdir/smokedata.cpp&quot; ) {
+    open( TOUCH, &quot;&gt;$finaloutdir/smokedata.cpp&quot;);
+    close TOUCH;
+}
+system &quot;diff -u $finaloutdir/smokedata.cpp $outdir/smokedata.cpp &gt; $outdir/smokedata.cpp.diff&quot;;
+
+# Copy changed or new files to finaloutdir
+opendir (OUT, $outdir) or die &quot;Couldn't opendir $outdir&quot;;
+foreach $filename (readdir(OUT)) {
+    next if ( -d &quot;$outdir/$filename&quot; ); # only files, not dirs
+    my $docopy = 1;
+    if ( -f &quot;$finaloutdir/$filename&quot; ) {
+        $docopy = compare(&quot;$outdir/$filename&quot;, &quot;$finaloutdir/$filename&quot;); # 1 if files are differents
+    }
+    if ($docopy) {
+	#print STDERR &quot;Updating $filename...\n&quot;;
+	cp(&quot;$outdir/$filename&quot;, &quot;$finaloutdir/$filename&quot;);
+    }
+}
+closedir OUT;
+
+# Check for deleted files and warn
+my $deleted = 0;
+opendir(FINALOUT, $finaloutdir) or die &quot;Couldn't opendir $finaloutdir&quot;;
+foreach $filename (readdir(FINALOUT)) {
+    next if ( -d &quot;$finaloutdir/$filename&quot; ); # only files, not dirs
+    if ( $filename =~ /.cpp$/ &amp;&amp; ! ($filename =~ /_la_closure.cpp/) &amp;&amp; ! -f &quot;$outdir/$filename&quot; ) {
+      print STDERR &quot;Removing obsolete file $filename\n&quot;;
+      unlink &quot;$finaloutdir/$filename&quot;;
+      $deleted = 1;
+    }
+}
+closedir FINALOUT;
+
+# Delete outdir
+system &quot;rm -rf $outdir&quot;;
+

Modified: trunk/smoke/kde/header_list
===================================================================
--- trunk/smoke/kde/header_list	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/kde/header_list	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,351 +1,312 @@
-q1xcompatibility.h
-qabstractlayout.h
-qaccel.h
-qaccessible.h
-qaction.h
-qapp.h
-qapplication.h
-qarray.h
-qasciicache.h
-qasciidict.h
-qassistantclient.h
-qasyncimageio.h
-qasyncio.h
-qbig5codec.h
-qbitarray.h
-qbitarry.h
-qbitmap.h
-qbrush.h
-qbttngrp.h
-qbuffer.h
-qbuttongroup.h
-qbutton.h
-qcache.h
-qcanvas.h
-qcdestyle.h
-qcheckbox.h
-qchkbox.h
-qcleanuphandler.h
-qclipboard.h
-qclipbrd.h
-qcollect.h
-qcollection.h
-qcolordialog.h
-qcolor.h
-qcombobox.h
-qcombo.h
-qcommonstyle.h
-qcompactstyle.h
-qconfig-dist.h
-qconfig.h
-qconnect.h
-qconnection.h
-qcstring.h
-qcursor.h
-qdatabrowser.h
-qdatastream.h
-qdatatable.h
-qdataview.h
-qdatetimeedit.h
-qdatetime.h
-qdatetm.h
-qdeepcopy.h
-qdesktopwidget.h
-qdial.h
-qdialog.h
-qdict.h
-qdir.h
-qdns.h
-qdockarea.h
-qdockwindow.h
-qdom.h
-qdragobject.h
-qdrawutil.h
-qdrawutl.h
-qdropsite.h
-qdstream.h
-qeditorfactory.h
-qerrormessage.h
-qeucjpcodec.h
-qeuckrcodec.h
-qevent.h
-qeventloop.h
-qfeatures.h
-qfiledef.h
-qfiledialog.h
-qfiledlg.h
-qfile.h
-qfileinf.h
-qfileinfo.h
-qfocusdata.h
-qfontdatabase.h
-qfontdialog.h
-qfontdta.h
-qfont.h
-qfontinf.h
-qfontinfo.h
-qfontmet.h
-qfontmetrics.h
-qframe.h
-qftp.h
-qgarray.h
-qgb18030codec.h
-qgbkcodec.h
-qgcache.h
-qgdict.h
-qgeneric.h
-qgif.h
-qglcolormap.h
-qgl.h
-qglist.h
-qglobal.h
-qgplugin.h
-qgrid.h
-qgridview.h
-qgroupbox.h
-qgrpbox.h
-qguardedptr.h
-qgvector.h
-qhbox.h
-qhbuttongroup.h
-qheader.h
-qhgroupbox.h
-qhostaddress.h
-qhttp.h
-qiconset.h
-qiconview.h
-qimageformatplugin.h
-qimage.h
-qinputdialog.h
-qintcache.h
-qintcach.h
-qintdict.h
-qinterlacestyle.h
-qiodev.h
-qiodevice.h
-qjiscodec.h
-qjpunicode.h
-qkeycode.h
-qkeysequence.h
-qlabel.h
-qlayout.h
-qlcdnumber.h
-qlcdnum.h
-qlocale.h
-qlibrary.h
-qlined.h
-qlineedit.h
-qlistbox.h
-qlist.h
-qlistview.h
-qlocalfs.h
-qmainwindow.h
-qmap.h
-qmemarray.h
-qmenubar.h
-qmenudata.h
-qmenudta.h
-qmessagebox.h
-qmetaobject.h
-qmetaobj.h
-qmime.h
-qmlined.h
-qmodules.h
-qmotifdialog.h
-qmotif.h
-qmotifplusstyle.h
-qmotifstyle.h
-qmotifwidget.h
-qmovie.h
-qmsgbox.h
-qmultilinedit.h
-qmultilineedit.h
-qmutex.h
-qnamespace.h
-qnetwork.h
-qnetworkprotocol.h
-qobjcoll.h
-qobjdefs.h
-qobjectcleanuphandler.h
-qobjectdefs.h
-qobjectdict.h
-qobject.h
-qobjectlist.h
-qpaintdc.h
-qpaintdevicedefs.h
-qpaintdevice.h
-qpaintdevicemetrics.h
-qpaintd.h
-qpainter.h
-qpair.h
-qpalette.h
-qpdevmet.h
-qpen.h
-qpicture.h
-qpixmapcache.h
-qpixmap.h
-qplatinumstyle.h
-qpmcache.h
-qpntarry.h
-qpointarray.h
-qpoint.h
-qpolygonscanner.h
-qpopmenu.h
-qpopupmenu.h
-qprintdialog.h
-qprinter.h
-qprndlg.h
-qprocess.h
-qprogbar.h
-qprogdlg.h
-qprogressbar.h
-qprogressdialog.h
-qpsprn.h
-qptrcollection.h
-qptrdict.h
-qptrlist.h
-qptrqueue.h
-qptrstack.h
-qptrvector.h
-qpushbt.h
-qpushbutton.h
-qqueue.h
-qradiobt.h
-qradiobutton.h
-qrangecontrol.h
-qrangect.h
-qrect.h
-qregexp.h
-qregion.h
-qremotefactory.h
-qremoteplugin.h
-qrtlcodec.h
-qscopedptr.h
-qscrbar.h
-qscrollbar.h
-qscrollview.h
-qsemaphore.h
-qsemimodal.h
-qserversocket.h
-qsession.h
-qsessionmanager.h
-qsettings.h
-qsgistyle.h
-qshared.h
-qsignal.h
-qsignalmapper.h
-qsignalslotimp.h
-qsimplerichtext.h
-qsizegrip.h
-qsize.h
-qsizepolicy.h
-qsjiscodec.h
-qslider.h
-qsocketdevice.h
-qsocket.h
-qsocketnotifier.h
-qsocknot.h
-qsortedlist.h
-qsound.h
-qspinbox.h
-qsplashscreen.h
-qsplitter.h
-qsqlcursor.h
-qsqldatabase.h
-qsqldriver.h
-qsqldriverplugin.h
-qsqleditorfactory.h
-qsqlerror.h
-qsqlfield.h
-qsqlform.h
-qsql.h
-qsqlindex.h
-qsqlpropertymap.h
-qsqlquery.h
-qsqlrecord.h
-qsqlresult.h
-qsqlselectcursor.h
-qstack.h
-qstatusbar.h
-qstring.h
-qstringlist.h
-qstrlist.h
-qstrvec.h
-qstylefactory.h
-qstyle.h
-qstyleplugin.h
-qstylesheet.h
-qsyntaxhighlighter.h
-qtabbar.h
-qtabdialog.h
-qtabdlg.h
-qtable.h
-qtabwidget.h
-qtextbrowser.h
-qtextcodecfactory.h
-qtextcodec.h
-qtextcodecplugin.h
-qtextedit.h
-qtextstream.h
-qtextview.h
-qt.h
-qthread.h
-qtimer.h
-qtl.h
-qtmultilineedit.h
-qtoolbar.h
-qtoolbutton.h
-qtoolbox.h
-qtooltip.h
-qtranslator.h
-qtsciicodec.h
-qtstream.h
-qttableview.h
-qurl.h
-qurlinfo.h
-qurloperator.h
-qutfcodec.h
-quuid.h
-qvalidator.h
-qvaluelist.h
-qvaluestack.h
-qvaluevector.h
-qvariant.h
-qvbox.h
-qvbuttongroup.h
-qvector.h
-qvgroupbox.h
-qwaitcondition.h
-qwhatsthis.h
-qwidcoll.h
-qwidgetfactory.h
-qwidget.h
-qwidgetintdict.h
-qwidgetlist.h
-qwidgetplugin.h
-qwidgetstack.h
-qwindefs.h
-qwindowdefs.h
-qwindow.h
-qwindowsstyle.h
-qwizard.h
-qwmatrix.h
-qworkspace.h
-qwsbeosdecoration_qws.h
-qwscommand_qws.h
-qwscursor_qws.h
-qwsdecoration_qws.h
-qwsdefaultdecoration_qws.h
-qwsdisplay_qws.h
-qwsevent_qws.h
-qwshydrodecoration_qws.h
-qwskde2decoration_qws.h
-qwskdedecoration_qws.h
-qwsmanager_qws.h
-qwsmouse_qws.h
-qwsproperty_qws.h
-qwsregionmanager_qws.h
-qwssocket_qws.h
-qwsutils_qws.h
-qwswindowsdecoration_qws.h
-qxml.h
+QtCore/qabstracteventdispatcher.h
+QtCore/qabstractfileengine.h
+QtCore/qabstractitemmodel.h
+QtCore/qalgorithms.h
+QtCore/qbasictimer.h
+QtCore/qbitarray.h
+QtCore/qbuffer.h
+QtCore/qbytearray.h
+QtCore/qbytearraymatcher.h
+QtCore/qcache.h
+QtCore/qchar.h
+QtCore/qconfig-dist.h
+QtCore/qconfig.h
+QtCore/qconfig-large.h
+QtCore/qconfig-medium.h
+QtCore/qconfig-minimal.h
+QtCore/qconfig-small.h
+QtCore/qcoreapplication.h
+QtCore/qcoreevent.h
+QtCore/qdatastream.h
+QtCore/qdatetime.h
+QtCore/qdebug.h
+QtCore/qdir.h
+QtCore/qeventloop.h
+QtCore/qfactoryinterface.h
+QtCore/qfeatures.h
+QtCore/qfile.h
+QtCore/qfileinfo.h
+QtCore/qfilesystemwatcher.h
+QtCore/qfsfileengine.h
+QtCore/qglobal.h
+QtCore/qiodevice.h
+QtCore/qiterator.h
+QtCore/qlibrary.h
+QtCore/qlibraryinfo.h
+QtCore/qline.h
+QtCore/qlocale.h
+QtCore/qmap.h
+QtCore/qmetaobject.h
+QtCore/qmetatype.h
+QtCore/qmimedata.h
+QtCore/qmutex.h
+QtCore/qnamespace.h
+QtCore/qobjectcleanuphandler.h
+QtCore/qobjectdefs.h
+QtCore/qobject.h
+QtCore/qpair.h
+QtCore/qplugin.h
+QtCore/qpluginloader.h
+QtCore/qpointer.h
+QtCore/qpoint.h
+QtCore/qprocess.h
+QtCore/qqueue.h
+QtCore/qreadwritelock.h
+QtCore/qrect.h
+QtCore/qregexp.h
+QtCore/qsemaphore.h
+QtCore/qsettings.h
+QtCore/qshareddata.h
+QtCore/qsignalmapper.h
+QtCore/qsize.h
+QtCore/qsocketnotifier.h
+QtCore/qstack.h
+QtCore/qstring.h
+QtCore/qstringlist.h
+QtCore/qstringmatcher.h
+QtCore/qtemporaryfile.h
+QtCore/qtextcodec.h
+QtCore/qtextcodecplugin.h
+QtCore/qtextstream.h
+QtCore/qthread.h
+QtCore/qthreadstorage.h
+QtCore/qtimeline.h
+QtCore/qtimer.h
+QtCore/qtranslator.h
+QtCore/qurl.h
+QtCore/quuid.h
+QtCore/qvariant.h
+QtCore/qvarlengtharray.h
+QtCore/qvector.h
+QtCore/qwaitcondition.h
+QtDBus/qdbusabstractadaptor.h
+QtDBus/qdbusabstractinterface.h
+QtDBus/qdbusargument.h
+QtDBus/qdbusconnection.h
+QtDBus/qdbusconnectioninterface.h
+QtDBus/qdbuserror.h
+QtDBus/qdbusextratypes.h
+QtDBus/qdbusinterface.h
+QtDBus/qdbusmacros.h
+QtDBus/qdbusmessage.h
+QtDBus/qdbusmetatype.h
+QtDBus/qdbusreply.h
+QtDBus/qdbusserver.h
+QtGui/qabstractbutton.h
+QtGui/qabstractitemdelegate.h
+QtGui/qabstractitemview.h
+QtGui/qabstractpagesetupdialog.h
+QtGui/qabstractprintdialog.h
+QtGui/qabstractproxymodel.h
+QtGui/qabstractscrollarea.h
+QtGui/qabstractslider.h
+QtGui/qabstractspinbox.h
+QtGui/qabstracttextdocumentlayout.h
+QtGui/qaccessiblebridge.h
+QtGui/qaccessible.h
+QtGui/qaccessibleobject.h
+QtGui/qaccessibleplugin.h
+QtGui/qaccessiblewidget.h
+QtGui/qactiongroup.h
+QtGui/qaction.h
+QtGui/qapplication.h
+QtGui/qbitmap.h
+QtGui/qboxlayout.h
+QtGui/qbrush.h
+QtGui/qbuttongroup.h
+QtGui/qcalendarwidget.h
+QtGui/qcheckbox.h
+QtGui/qcleanlooksstyle.h
+QtGui/qclipboard.h
+QtGui/qcolordialog.h
+QtGui/qcolor.h
+QtGui/qcolormap.h
+QtGui/qcombobox.h
+QtGui/qcommonstyle.h
+QtGui/qcompleter.h
+QtGui/qcursor.h
+QtGui/qdatawidgetmapper.h
+QtGui/qdatetimeedit.h
+QtGui/qdesktopservices.h
+QtGui/qdesktopwidget.h
+QtGui/qdial.h
+QtGui/qdialogbuttonbox.h
+QtGui/qdialog.h
+QtGui/qdirmodel.h
+QtGui/qdockwidget.h
+QtGui/qdrag.h
+QtGui/qdrawutil.h
+QtGui/qerrormessage.h
+QtGui/qevent.h
+QtGui/qfiledialog.h
+QtGui/qfocusframe.h
+QtGui/qfontcombobox.h
+QtGui/qfontdatabase.h
+QtGui/qfontdialog.h
+QtGui/qfont.h
+QtGui/qfontinfo.h
+QtGui/qfontmetrics.h
+QtGui/qframe.h
+QtGui/qgraphicsitemanimation.h
+QtGui/qgraphicsitem.h
+QtGui/qgraphicssceneevent.h
+QtGui/qgraphicsscene.h
+QtGui/qgraphicsview.h
+QtGui/qgridlayout.h
+QtGui/qgroupbox.h
+QtGui/qhboxlayout.h
+QtGui/qheaderview.h
+QtGui/qiconengine.h
+QtGui/qiconengineplugin.h
+QtGui/qicon.h
+QtGui/qimage.h
+QtGui/qimageiohandler.h
+QtGui/qimagereader.h
+QtGui/qimagewriter.h
+QtGui/qinputcontextfactory.h
+QtGui/qinputcontext.h
+QtGui/qinputcontextplugin.h
+QtGui/qinputdialog.h
+QtGui/qitemdelegate.h
+QtGui/qitemeditorfactory.h
+QtGui/qitemselectionmodel.h
+QtGui/qkeysequence.h
+QtGui/qlabel.h
+QtGui/qlayout.h
+QtGui/qlayoutitem.h
+QtGui/qlcdnumber.h
+QtGui/qlineedit.h
+QtGui/qlistview.h
+QtGui/qlistwidget.h
+QtGui/qmacstyle.h
+QtGui/qmainwindow.h
+QtGui/qmatrix.h
+QtGui/qmenubar.h
+QtGui/qmenudata.h
+QtGui/qmenu.h
+QtGui/qmessageboxex.h
+QtGui/qmessagebox.h
+QtGui/qmime.h
+QtGui/qmovie.h
+QtGui/qpagesetupdialog.h
+QtGui/qpaintdevice.h
+QtGui/qpaintengine.h
+QtGui/qpainter.h
+QtGui/qpainterpath.h
+QtGui/qpalette.h
+QtGui/qpen.h
+QtGui/qpictureformatplugin.h
+QtGui/qpicture.h
+QtGui/qpixmapcache.h
+QtGui/qpixmap.h
+QtGui/qplastiquestyle.h
+QtGui/qpolygon.h
+QtGui/qprintdialog.h
+QtGui/qprintengine.h
+QtGui/qprinter.h
+QtGui/qprogressbar.h
+QtGui/qprogressdialog.h
+QtGui/qproxymodel.h
+QtGui/qpushbutton.h
+QtGui/qradiobutton.h
+QtGui/qregion.h
+QtGui/qrgb.h
+QtGui/qrubberband.h
+QtGui/qscrollarea.h
+QtGui/qscrollbar.h
+QtGui/qsessionmanager.h
+QtGui/qshortcut.h
+QtGui/qsizegrip.h
+QtGui/qsizepolicy.h
+QtGui/qslider.h
+QtGui/qsortfilterproxymodel.h
+QtGui/qsound.h
+QtGui/qspinbox.h
+QtGui/qsplashscreen.h
+QtGui/qsplitter.h
+QtGui/qstackedlayout.h
+QtGui/qstackedwidget.h
+QtGui/qstandarditemmodel.h
+QtGui/qstatusbar.h
+QtGui/qstringlistmodel.h
+QtGui/qstylefactory.h
+QtGui/qstyle.h
+QtGui/qstyleoption.h
+QtGui/qstylepainter.h
+QtGui/qstyleplugin.h
+QtGui/qsyntaxhighlighter.h
+QtGui/qsystemtrayicon.h
+QtGui/qtabbar.h
+QtGui/qtableview.h
+QtGui/qtablewidget.h
+QtGui/qtabwidget.h
+QtGui/qtextbrowser.h
+QtGui/qtextcursor.h
+QtGui/qtextdocumentfragment.h
+QtGui/qtextdocument.h
+QtGui/qtextedit.h
+QtGui/qtextformat.h
+QtGui/qtextlayout.h
+QtGui/qtextlist.h
+QtGui/qtextobject.h
+QtGui/qtextoption.h
+QtGui/qtexttable.h
+QtGui/qtoolbar.h
+QtGui/qtoolbox.h
+QtGui/qtoolbutton.h
+QtGui/qtooltip.h
+QtGui/qtreeview.h
+QtGui/qtreewidget.h
+QtGui/qtreewidgetitemiterator.h
+QtGui/qundogroup.h
+QtGui/qundostack.h
+QtGui/qundoview.h
+QtGui/qvalidator.h
+QtGui/qvboxlayout.h
+QtGui/qvfbhdr.h
+QtGui/qwhatsthis.h
+QtGui/qwidgetaction.h
+QtGui/qwidget.h
+QtGui/qwindowdefs.h
+QtGui/qwindowsstyle.h
+QtGui/qwindowsxpstyle.h
+QtGui/qwmatrix.h
+QtGui/qworkspace.h
+QtGui/qx11embed_x11.h
+QtGui/qx11info_x11.h
+QtNetwork/qabstractsocket.h
+QtNetwork/qftp.h
+QtNetwork/qhostaddress.h
+QtNetwork/qhostinfo.h
+QtNetwork/qhttp.h
+QtNetwork/qnetworkinterface.h
+QtNetwork/qnetworkproxy.h
+QtNetwork/qtcpserver.h
+QtNetwork/qtcpsocket.h
+QtNetwork/qudpsocket.h
+QtNetwork/qurlinfo.h
+QtOpenGL/qglcolormap.h
+QtOpenGL/qglframebufferobject.h
+QtOpenGL/qgl.h
+QtOpenGL/qglpixelbuffer.h
+Qt/qiconset.h
+QtSql/qsqldatabase.h
+QtSql/qsqldriver.h
+QtSql/qsqldriverplugin.h
+QtSql/qsqlerror.h
+QtSql/qsqlfield.h
+QtSql/qsql.h
+QtSql/qsqlindex.h
+QtSql/qsqlquery.h
+QtSql/qsqlquerymodel.h
+QtSql/qsqlrecord.h
+QtSql/qsqlrelationaldelegate.h
+QtSql/qsqlrelationaltablemodel.h
+QtSql/qsqlrelation.h
+QtSql/qsqlresult.h
+QtSql/qsqltablemodel.h
+QtSvg/qsvgrenderer.h
+QtSvg/qsvgwidget.h
+QtUiTools/quiloader.h
+QtXml/qdom.h
+QtXml/qxml.h

Modified: trunk/smoke/kde/kde_header_list
===================================================================
--- trunk/smoke/kde/kde_header_list	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/kde/kde_header_list	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,6 +1,10 @@
-dcopclient.h
-dcopobject.h
-dcopref.h
+dnssd/domainbrowser.h
+dnssd/publicservice.h
+dnssd/query.h
+dnssd/remoteservice.h
+dnssd/servicebase.h
+dnssd/servicebrowser.h
+dnssd/settings.h
 dom/css_rule.h
 dom/css_stylesheet.h
 dom/css_value.h
@@ -30,32 +34,34 @@
 dom/html_misc.h
 dom/html_object.h
 dom/html_table.h
+fixx11h.h
 kaboutapplication.h
 kaboutdata.h
 kaboutdialog.h
 kaboutkde.h
+kacceleratormanager.h
 kaccelgen.h
-kaccel.h
-kaccelmanager.h
-kactionclasses.h
+kacl.h
 kactioncollection.h
 kaction.h
-kactionshortcutlist.h
+kactionmenu.h
+kactionselector.h
 kactivelabel.h
 kallocator.h
 kanimwidget.h
-kapp.h
 kapplication.h
 karchive.h
 kar.h
 karrowbutton.h
+kascii.h
+kassistantdialog.h
 kasyncio.h
-kaudioplayer.h
-kauthicon.h
+kauthorized.h
 kautomount.h
+kautostart.h
+kcomponentdata.h
 kbookmarkbar.h
 kbookmarkdombuilder.h
-kbookmarkdrag.h
 kbookmarkexporter.h
 kbookmark.h
 kbookmarkimporter_crash.h
@@ -66,237 +72,304 @@
 kbookmarkimporter_opera.h
 kbookmarkmanager.h
 kbookmarkmenu.h
+kbookmarkmenu_p.h
 kbookmarknotifier.h
 kbufferedio.h
+kbufferedsocket.h
 kbugreport.h
+kbuildsycocaprogressdialog.h
 kbuttonbox.h
+kbuttongroup.h
 kcalendarsystemfactory.h
 kcalendarsystem.h
-kcatalogue.h
+kcatalog.h
 kcharselect.h
 kcharsets.h
+kclientsocketbase.h
 kclipboard.h
 kcmdlineargs.h
-kcmenumngr.h
-kcmodule.h
+kcmodulecontainer.h
 kcmoduleinfo.h
 kcmoduleloader.h
+kcmoduleproxy.h
 kcmultidialog.h
-kcolorbtn.h
+kcodecs.h
 kcolorbutton.h
 kcolorcombo.h
-kcolordialog.h
-kcolordlg.h
-kcolordrag.h
+kcolormimedata.h
+kcolorvalueselector.h
 kcombiview.h
 kcombobox.h
 kcommand.h
 kcompletionbox.h
 kcompletion.h
-kconfigdialog.h
-kconfigskeleton.h
+kcompositejob.h
 kconfigbackend.h
 kconfigbase.h
 kconfigdata.h
+kconfigdialog.h
+kconfigdialogmanager.h
 kconfig.h
+kconfigskeleton.h
 kcpuinfo.h
 kcrash.h
 kcursor.h
 kcustommenueditor.h
-kdatastream.h
+kdatagramsocket.h
 kdatatool.h
 kdatepicker.h
-kdatepik.h
-kdatetbl.h
+kdatetime.h
 kdatetimewidget.h
 kdatewidget.h
-kdcopactionproxy.h
-kdcoppropertyproxy.h
-kdcopservicestarter.h
-kdebugclasses.h
+kdbusservicestarter.h
 kdebug.h
+kdedesktopmimetype.h
 kdedmodule.h
+kdefakes.h
+kde_file.h
+kdelibs_export.h
+kdemacros.h
+kdeprint/kpreloadobject.h
+kdeprint/kprintdialogpage.h
 kdesktopfile.h
 kde_terminal_interface.h
 kdeversion.h
-kdialogbase.h
+kdialogbuttonbox.h
 kdialog.h
 kdirlister.h
+kdirmodel.h
 kdirnotify.h
-kdirnotify_stub.h
 kdiroperator.h
 kdirselectdialog.h
 kdirsize.h
 kdirwatch.h
 kdiskfreesp.h
-kdockwidget.h
-kdockwindow.h
 kdrawutil.h
-kdualcolorbtn.h
-kdualcolorbutton.h
-keditcl.h
 keditlistbox.h
 kedittoolbar.h
 kemailsettings.h
-kextendedsocket.h
-kextsock.h
-kfiledetailview.h
+kencodingfiledialog.h
 kfiledialog.h
 kfilefiltercombo.h
 kfilefilter.h
 kfile.h
-kfileiconview.h
 kfileitem.h
 kfilemetainfo.h
 kfilepreview.h
-kfilesharedlg.h
 kfileshare.h
 kfiletreebranch.h
-kfiletreeview.h
-kfiletreeviewitem.h
 kfileview.h
 kfilterbase.h
 kfilterdev.h
 kfinddialog.h
 kfind.h
-kfontcombo.h
+kfontaction.h
 kfontdialog.h
 kfontrequester.h
-kgenericfactory.h
+kfontsizeaction.h
 kglobalaccel.h
 kglobal.h
 kglobalsettings.h
 kguiitem.h
+khbox.h
 khelpmenu.h
 khtmldefaults.h
 khtml_events.h
 khtml_part.h
 khtml_settings.h
 khtmlview.h
-kicondialog.h
 kiconeffect.h
+kiconengine.h
+kicon.h
 kiconloader.h
 kicontheme.h
-kiconview.h
 kidna.h
 kimageeffect.h
 kimagefilepreview.h
 kimageio.h
 kinputdialog.h
 kinstance.h
+kio/authinfo.h
+kiobuffer.h
+kio/chmodjob.h
+kio/connection.h
+kio/copyjob.h
+kio/davjob.h
+kio/defaultprogress.h
+kio/deletejob.h
+kio/file.h
+kio/filejob.h
+kio/forwardingslavebase.h
+kio/global.h
+kio/http.h
+kio/http_slave_defaults.h
+kio/ioslave_defaults.h
+kio/jobclasses.h
+kio/job.h
+kio/jobuidelegate.h
+kio/kntlm.h
+kio/metainfojob.h
+kio/netaccess.h
+kio/observer.h
+kio/passdlg.h
+kio/paste.h
+kio/previewjob.h
+kio/progressbase.h
+kio/renamedlg.h
+kio/safesite.h
+kio/scheduler.h
+kio/sessiondata.h
+kio/skipdlg.h
+kio/slavebase.h
+kio/slaveconfig.h
+kio/slave.h
+kio/slaveinterface.h
+kio/statusbarprogress.h
+kio/tcpslavebase.h
+kio/thumbcreator.h
+kio/uiserver.h
 kipc.h
-kjanuswidget.h
+kjob.h
+kjobuidelegate.h
 kkeybutton.h
 kkeydialog.h
-kkeynative.h
-klargefile.h
+kkeyserver.h
+kkeyserver_x11.h
+klanguagebutton.h
+klauncher_iface.h
 kled.h
 klibloader.h
-klineeditdlg.h
 klineedit.h
-klistbox.h
-klistview.h
-klistviewsearchline.h
 klocale.h
+klocalizedstring.h
+klockfile.h
 kmacroexpander.h
 kmainwindow.h
-kmainwindowiface.h
 kmanagerselection.h
-kmdcodec.h
-kmdichildarea.h
-kmdichildfrmcaption.h
-kmdichildfrm.h
-kmdichildview.h
-kmdidefines.h
-kmdiiterator.h
-kmdilistiterator.h
-kmdimainfrm.h
-kmdinulliterator.h
-kmditaskbar.h
-kmditoolviewaccessor.h
+kmediaplayer/player.h
+kmediaplayer/view.h
 kmenubar.h
+kmenu.h
 kmessagebox.h
+kmessageboxmessagehandler.h
+kmessage.h
 kmimemagic.h
 kmimesourcefactory.h
+kmimetypechooser.h
 kmimetype.h
 kmimetyperesolver.h
+kmimetypetrader.h
 kmountpoint.h
-kmultipledrag.h
 kmultitabbar.h
+knetworkinterface.h
+knewstuff/downloaddialog.h
+knewstuff/engine.h
+knewstuff/entry.h
+knewstuff/knewstuffbutton.h
+knewstuff/knewstuffgeneric.h
+knewstuff/knewstuff.h
+knewstuff/knewstuffsecure.h
+knewstuff/providerdialog.h
+knewstuff/provider.h
+knfsshare.h
+knotification.h
+knotificationrestrictions.h
 knotifyclient.h
+knotifyconfigwidget.h
 knotifydialog.h
 knuminput.h
 knumvalidator.h
 kopenssl.h
 kopenwith.h
+kpagedialog.h
+kpagemodel.h
+kpageview.h
+kpagewidget.h
+kpagewidgetmodel.h
 kpalette.h
-kpanelapplet.h
-kpanelappmenu.h
-kpanelextension.h
-kpanelmenu.h
-kpassdlg.h
+kparts/browserextension.h
+kparts/browserinterface.h
+kparts/browserrun.h
+kparts/componentfactory.h
+kparts/event.h
+kparts/factory.h
+kparts/historyprovider.h
+kparts/mainwindow.h
+kparts/part.h
+kparts/partmanager.h
+kparts/plugin.h
+kparts/statusbarextension.h
 kpassivepopup.h
+kpassivepopupmessagehandler.h
+kpassworddialog.h
+kpastetextaction.h
 kpixmapeffect.h
-kpixmap.h
-kpixmapio.h
 kpixmapprovider.h
+kpixmapregionselectordialog.h
+kpixmapregionselectorwidget.h
 kpixmapsplitter.h
+kplugininfo.h
 kpluginselector.h
-kplugininfo.h
-kpopupmenu.h
-kpreferencesdialog.h
-kpreferencesmodule.h
 kpreviewwidgetbase.h
 kprintaction.h
 kprinter.h
-kdeprint/kpreloadobject.h
 kprocctrl.h
 kprocess.h
 kprocio.h
-kprogress.h
+kprogressbar.h
+kprogressdialog.h
 kpropertiesdialog.h
 kpropsdlg.h
 kprotocolinfo.h
 kprotocolmanager.h
 kpty.h
 kpushbutton.h
+krandom.h
 krandomsequence.h
 krecentdocument.h
+krecentfilesaction.h
 kregexpeditorinterface.h
-kregexp.h
+kremoteencoding.h
 kreplacedialog.h
 kreplace.h
+kresolver.h
 krestrictedline.h
+kreverseresolver.h
 krfcdate.h
-krootpixmap.h
-krootprop.h
 kruler.h
 krun.h
+ksambashare.h
 ksavefile.h
 kscan.h
-ksconfig.h
-kscreensaver.h
-kscreensaver_vroot.h
-kselect.h
+kselectaction.h
+kselector.h
+kseparatoraction.h
 kseparator.h
+kserversocket.h
 kservicegroup.h
 kservice.h
+kserviceoffer.h
 kservicetype.h
-ksharedpixmap.h
+kservicetypeprofile.h
+kservicetypetrader.h
+ksettings/componentsdialog.h
+ksettings/dialog.h
+ksettings/dispatcher.h
+ksettings/pluginpage.h
 ksharedptr.h
 kshellcompletion.h
 kshell.h
+kshortcutdialog.h
 kshortcut.h
-kshortcutlist.h
-kshred.h
 ksimpleconfig.h
 ksmimecrypto.h
-ksockaddr.h
-ksock.h
+ksocketaddress.h
+ksocketbase.h
+ksocketdevice.h
 ksocks.h
-ksortablevaluelist.h
-kspelldlg.h
-kspell.h
+ksockssocketdevice.h
+ksortablelist.h
+ksplashscreen.h
 ksqueezedtextlabel.h
 ksslall.h
 ksslcertchain.h
@@ -309,7 +382,6 @@
 ksslconnectioninfo.h
 kssl.h
 ksslinfodlg.h
-ksslkeygen.h
 ksslpeerinfo.h
 ksslpemcallback.h
 ksslpkcs12.h
@@ -326,114 +398,72 @@
 kstatusbar.h
 kstdaccel.h
 kstdaction.h
-kstddirs.h
 kstdguiitem.h
+kstreamsocket.h
 kstringhandler.h
 kstringvalidator.h
-kstyle.h
+ksvgrenderer.h
 ksycocaentry.h
 ksycoca.h
 ksycocatype.h
-ksyntaxhighlighter.h
-ksystemtray.h
+ksystemtrayicon.h
 ktabbar.h
 ktabctl.h
 ktabwidget.h
 ktar.h
 ktempdir.h
 ktempfile.h
+ktemporaryfile.h
 ktextbrowser.h
 ktextedit.h
-ktimewidget.h
+ktimezones.h
+ktimezonewidget.h
 ktip.h
-ktoolbarbutton.h
+ktoggleaction.h
+ktogglefullscreenaction.h
+ktoggletoolbaraction.h
 ktoolbar.h
-ktoolbarradiogroup.h
+ktoolbarlabelaction.h
+ktoolbarpopupaction.h
+ktoolbarspaceraction.h
+ktoolinvocation.h
 ktrader.h
+ktreewidgetsearchline.h
 ktypelist.h
-kuniqueapp.h
+ktzfiletimezone.h
 kuniqueapplication.h
-kunload.h
 kurifilter.h
-kurlbar.h
 kurlcombobox.h
 kurlcompletion.h
-kurldrag.h
 kurl.h
 kurllabel.h
 kurlpixmapprovider.h
 kurlrequesterdlg.h
 kurlrequester.h
-kuserprofile.h
+kuser.h
+kvbox.h
 kvmallocator.h
-kwindowinfo.h
+kwallet.h
 kwindowlistmenu.h
 kwin.h
 kwinmodule.h
-kwizard.h
 kwordwrap.h
+kxerrorhandler.h
 kxmessages.h
 kxmlguibuilder.h
 kxmlguiclient.h
 kxmlguifactory.h
-kxmlgui.h
+kxyselector.h
 kzip.h
-kparts/browserextension.h
-kparts/browserinterface.h
-kparts/browserrun.h
-kparts/componentfactory.h
-kparts/dockmainwindow.h
-kparts/event.h
-kparts/factory.h
-kparts/genericfactory.h
-kparts/historyprovider.h
-kparts/mainwindow.h
-kparts/part.h
-kparts/partmanager.h
-kparts/plugin.h
-kparts/pluginselectormodule.h
-kparts/statusbarextension.h
-kio/authinfo.h
-kio/chmodjob.h
-kio/connection.h
-kio/davjob.h
-kio/defaultprogress.h
-kio/file.h
-kio/global.h
-kio/http.h
-kio/http_slave_defaults.h
-kio/ioslave_defaults.h
-kio/jobclasses.h
-kio/job.h
-kio/kdesasl.h
-kio/kmdbase.h
-kio/kmdcodec.h
-kio/kpac.h
-kio/metainfojob.h
-kio/netaccess.h
-kio/observer.h
-kio/passdlg.h
-kio/paste.h
-kio/previewjob.h
-kio/progressbase.h
-kio/renamedlg.h
-kio/scheduler.h
-kio/sessiondata.h
-kio/skipdlg.h
-kio/slavebase.h
-kio/slaveconfig.h
-kio/slave.h
-kio/slaveinterface.h
-kio/statusbarprogress.h
-kio/tcpslavebase.h
-kio/thumbcreator.h
-kio/uiserver.h
-kio/uiserver_stub.h
-netwm_def.h
 netwm.h
-knewstuff/knewstuff.h
-knewstuff/knewstuffsecure.h
-knewstuff/engine.h
-knewstuff/entry.h
-knewstuff/provider.h
-
+renamedlgplugin.h
+sonnet/backgroundchecker.h
+sonnet/configdialog.h
+sonnet/configwidget.h
+sonnet/defaultdictionary.h
+sonnet/dialog.h
+sonnet/filter.h
+sonnet/highlighter.h
+sonnet/loader.h
+sonnet/settings.h
+sonnet/speller.h

Added: trunk/smoke/kde/qtguess.pl.cmake
===================================================================
--- trunk/smoke/kde/qtguess.pl.cmake	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/kde/qtguess.pl.cmake	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,422 @@
+#!/usr/bin/perl
+
+# qtguess.pl : check how Qt was compiled. Issue a list of all defined QT_NO_* macros, one per line.
+#
+# author:  germain Garand &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">germain at ebooksfrance.com</A>&gt;
+# licence: GPL v.2
+
+# options: -q: be quieter
+#	   -o file: redirect output to &quot;file&quot;. (default: ./qtdefines)
+#	   -t [0..15]: set the testing threshold (see below)
+#	   -f &quot;flags&quot;: additional compiler flags/parameters
+
+use Getopt::Std;
+
+use vars qw/$opt_f $opt_o $opt_p/;
+
+getopts('qo:f:t:');
+
+# Threshold :
+#	 0 - test basic Qt types/classes
+#	 5 - test higher level, non-gui classes
+#	 8 - test options of the above (ex: QT_NO_IMAGE_SMOOTHSCALE)
+#	10 - test basic widgets
+#	12 - test composite widgets
+#	13 - test widgets inheriting composite widgets
+#	15 - test goodies (default)
+
+my $default_threshold = @qt_test_threshold@;
+my $cc = &quot;@CMAKE_CXX_COMPILER@&quot;;
+my $ccflags = $opt_f || &quot;@CMAKE_CXX_FLAGS@&quot;;
+
+my $nspaces = 50;
+
+my %qtdefs=();
+my %qtundefs=();
+
+my $tmp = gettmpfile();
+my $qtinc = '@QT_INCLUDE_DIR@';
+my $allinc = '@all_includes@';
+my $alllib = '<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">-L at QT_LIBRARY_DIR</A>@';
+my $qtflags = '@qtflags@';
+#my %x;
+#$x{'LIBPNG'}  =   '@LIBPNG@';
+#$x{'LIBJPEG'} =   '@LIBJPEG@';
+#$x{'LIBSM'}   =   '@LIBSM@';
+#$x{'LIBSOCKET'} = '@LIBSOCKET@';
+#$x{'LIBDL'}      = '@LIBDL@';
+#$x{'LIBRESOLV'}  = '@LIBRESOLV@';
+#$x{'LIB_X11'} =   '@LIB_X11@';
+#$x{'X_PRE_LIBS'} = '@X_PRE_LIBS@';
+#$x{'LIB_X11'} =~ s/\$\((.*?)\)/$x{$1}/g;
+#
+#$qtflags =~ s/\$\((.*?)\)/$x{$1}/g;
+
+ -e &quot;$qtinc/QtCore/qglobal.h&quot; or die &quot;Invalid Qt include directory.\n&quot;;
+
+my $ccmd = &quot;$cc $ccflags $allinc $alllib -o $tmp $tmp.cpp $qtflags&quot;;
+
+my $threshold = defined($opt_t)?$opt_t : $default_threshold;
+$threshold &gt;= 0 or die &quot;invalid testing threshold: $threshold\n&quot;;
+
+print &quot;Checking how Qt was built... \n&quot;;
+print &quot;Threshold is set to $threshold\n&quot; unless $opt_q;
+
+my($count, $used, $total);
+map{ $tests{$_}-&gt;[2]&gt;=$threshold ? ($used++, $total++):$total++ } keys %tests;
+
+print &quot;Number of defines to be tested : $used/$total\n\n&quot; unless $opt_q;
+open( QTDEFS, &quot;&gt;&gt;&quot;.($opt_o || &quot;qtdefines&quot;) ) or die &quot;Can't open output file: $!\n&quot;;
+
+grab_qglobal_symbols();
+preliminary_test();
+perform_all_tests();
+
+print +scalar(keys %qtdefs) . &quot; defines found.\n&quot;;
+
+print QTDEFS join(&quot;\n&quot;, keys %qtdefs), &quot;\n&quot;;
+close;
+
+#--------------------------------------------------------------#
+
+sub gettmpfile
+{
+	my $tmpdir = $ENV{'TMP'} || &quot;.&quot;;
+	my $tmpname = $$.&quot;-qtguess&quot;;
+	while( -e &quot;$tmpdir/$tmpname&quot; || -e &quot;$tmpdir/${tmpname}.cpp&quot; )
+	{
+		$tmpname .= int (rand * 9);
+	}
+	return &quot;$tmpdir/$tmpname&quot;;
+}
+
+#--------------------------------------------------------------#
+
+sub grab_qglobal_symbols
+{
+	my $cmd = &quot;$cc -E -D__cplusplus -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2&gt;/dev/null&quot;;
+	my $symbols = `$cmd`;
+        for(0..1)
+        {
+	    if( check_exit_status($?) )
+	    {
+		while( $symbols =~/^#\s*define\s*(QT_\S+)/gm )
+		{
+			$qtdefs{$1} = 1;
+		}
+		print &quot;Found &quot;. scalar( keys %qtdefs ).&quot; predefined symbol&quot;.((scalar( keys %qtdefs ) -1)?&quot;s&quot;:&quot;&quot;).&quot; in qglobal.h\n&quot; unless ($opt_q or !(keys %qtdefs));
+		while( $symbols =~/^#\s*define\s*QT_MODULE_(\S+)/gm )
+		{
+			$qtundefs{&quot;QT_NO_$1&quot;} = 1;
+		}
+		print &quot;Found &quot;. scalar( keys %qtundefs ).&quot; undefined symbol&quot;.((scalar( keys %qtundefs ) -1)?&quot;s&quot;:&quot;&quot;).&quot; in qglobal.h\n&quot; unless ($opt_q or !(keys %qtundefs));
+                last;
+	    }
+	    elsif(! $_) # first try
+	    {
+		print  &quot;Failed to run $cmd.\nTrying without __cplusplus (might be already defined)\n&quot;;
+                $cmd = &quot;$cc -E -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2&gt;/dev/null&quot;;
+                $symbols = `$cmd`;
+                next;
+	    }
+        }
+}
+
+#--------------------------------------------------------------#
+
+sub preliminary_test
+{
+	my $msg = &quot;Trying to compile and link a small program...&quot;;
+	print $msg, &quot; &quot; x ($nspaces - length($msg) + 8);
+	open( OUT, &quot;&gt;${tmp}.cpp&quot; ) or die &quot;Failed to open temp file ${tmp}.cpp: $!\n&quot;;
+	my $simple=q&#163;
+		#include &lt;QtGui/qapplication.h&gt;
+		int main( int argc, char **argv )
+		{
+			QApplication foo( argc, argv );
+			return 0;
+		}
+	&#163;;
+	print OUT $simple;
+	close OUT;
+        my $out = `$ccmd 2&gt;&amp;1`;
+	if( !check_exit_status($?) )
+	{
+		die &lt;&lt;&quot;EOF&quot;;
+
+FAILED : check your configuration.
+Failed program was:
+$simple
+Compiled with:
+$ccmd
+Compiler output:
+$out
+EOF
+	}
+	else
+	{
+		print &quot;OK\n&quot;;
+	}
+}
+
+#--------------------------------------------------------------#
+
+sub perform_all_tests
+{
+	foreach ( sort { $tests{$a}-&gt;[2] &lt;=&gt; $tests{$b}-&gt;[2]} keys %tests)
+	{
+		$tests{$_}-&gt;[2] &lt; $threshold and next;
+		($qtdefs{$_} || $qtundefs{$_}) and do
+		{
+			print &quot;\rSkipping $_ (in qglobal.h)&quot;.( &quot; &quot; x (($nspaces-16) - length($_)) ).($qtundefs{$_}?&quot;*Undefined*&quot;:&quot; [Defined]&quot;).($opt_q?&quot;&quot;:&quot;\n&quot;);
+			next
+		};
+		print &quot;\rTesting $_&quot;.( &quot; &quot; x ($nspaces - length($_)) );
+		open( OUT, &quot;&gt;${tmp}.cpp&quot; ) or die &quot;Failed to open temp file ${tmp}.cpp: $!\n&quot;;
+		foreach $def(keys %qtdefs)
+		{
+			print OUT &quot;#define $def\n&quot;;
+		}
+		foreach $inc(split /,\s*/, $tests{$_}-&gt;[0])
+		{
+			print OUT &quot;#include &lt;$inc&gt;\n&quot;;
+		}
+		print OUT &quot;#include &lt;QtCore/qfeatures.h&gt;\n&quot;;
+		print OUT $tests{$_}-&gt;[3] if $tests{$_}-&gt;[3]; # need to define some classes ?
+		print OUT qq&#163;
+
+		int main( int argc, char ** argv)
+		{
+		$tests{$_}-&gt;[1]
+		return 0;
+		}
+
+		&#163;;
+		close OUT;
+
+                my $out = `$ccmd 2&gt;&amp;1`;
+		my $ok = check_exit_status($?);
+		if( !$ok )
+		{
+			$qtdefs{$_} = 1;
+		}
+		print +$opt_q ? ++$count.&quot;/$used&quot; : ( $ok ? &quot;*Undefined*\n&quot; : &quot; [Defined]\n&quot; );
+	}
+	$opt_q &amp;&amp; print &quot;\n&quot;;
+}
+
+#--------------------------------------------------------------#
+
+sub check_exit_status
+{
+	my $a = 0xFFFF &amp; shift;
+	if( !$a )
+	{
+		return 1;
+	}
+	elsif( $a == 0xFF00 )
+	{
+		die &quot;\nSystem call failed: $!\n&quot;;
+	}
+	elsif( $a &gt; 0x80 )
+	{
+		# non-zero status.
+	}
+	else
+	{
+		if( $a &amp; 0x80 )
+		{
+			die &quot;\n$cc coredumped with signal &quot;. ($a &amp; ~0x80);
+		}
+		die &quot;\n$cc interrupted by signal $a\n&quot;;
+	}
+	return 0;
+}
+
+#--------------------------------------------------------------#
+
+END
+{
+	unlink $tmp if -e $tmp;
+	unlink &quot;${tmp}.cpp&quot; if -e &quot;${tmp}.cpp&quot;;
+}
+
+#--------------------------------------------------------------#
+
+BEGIN {
+
+# &quot;DEFINE&quot; =&gt; [&quot;header-1.h,... header-n.h&quot;, &quot;main() code&quot;, priority, &quot;Definitions (if needed)&quot;]
+
+our %tests = (
+	&quot;QT_NO_ACCESSIBILITY&quot; =&gt;        [&quot;QtGui/qaccessible.h&quot;, &quot;QAccessibleEvent event(QEvent::AccessibilityHelp, 0);&quot;, 15],
+	&quot;QT_NO_ACTION&quot; =&gt;		[&quot;QtGui/qaction.h&quot;, &quot;QAction foo( (QObject*)NULL );&quot;, 5],
+	#QT_NO_BIG_CODECS
+ 	&quot;QT_NO_BUTTONGROUP&quot; =&gt;		[&quot;QtGui/qbuttongroup.h&quot;, &quot;QButtonGroup foo( (QObject*)NULL );&quot;, 12],
+ 	&quot;QT_NO_CHECKBOX&quot; =&gt;		[&quot;QtGui/qcheckbox.h&quot;, &quot;QCheckBox foo( (QWidget*)NULL );&quot;, 10],
+	&quot;QT_NO_CLIPBOARD&quot; =&gt; 		[&quot;QtGui/qapplication.h, QtGui/qclipboard.h&quot;, q&#163;
+						QApplication foo( argc, argv );
+						QClipboard *baz= foo.clipboard();
+					&#163;, 5],
+ 	&quot;QT_NO_COLORDIALOG&quot; =&gt;		[&quot;QtGui/qcolordialog.h&quot;, &quot;QColorDialog::customCount();&quot;, 12],
+	#QT_NO_COLORNAMES
+ 	&quot;QT_NO_COMBOBOX&quot; =&gt;		[&quot;QtGui/qcombobox.h&quot;, &quot;QComboBox foo( (QWidget*)NULL );&quot;, 10],
+	&quot;QT_NO_COMPAT&quot; =&gt;		[&quot;QtGui/qfontmetrics.h&quot;, q&#163;
+						QFontMetrics *foo= new QFontMetrics( QFont() );
+						int bar = foo-&gt;width( 'c' );
+					&#163;, 0],
+	&quot;QT_NO_COMPONENT&quot; =&gt;		[&quot;QtGui/qapplication.h&quot;, q&#163;
+ 						QApplication foo( argc, argv );
+ 						foo.addLibraryPath( QString::null );
+					&#163;, 5],
+	#QT_NO_COP
+ 	&quot;QT_NO_CURSOR&quot; =&gt;		[&quot;QtGui/qcursor.h&quot;, &quot;QCursor foo;&quot;, 5],
+ 	&quot;QT_NO_DATASTREAM&quot; =&gt;		[&quot;QtCore/qdatastream.h&quot;, &quot;QDataStream foo;&quot;, 5],
+ 	&quot;QT_NO_DATETIMEEDIT&quot; =&gt;		[&quot;QtGui/qdatetimeedit.h&quot;, &quot;QTimeEdit foo;&quot;, 12],
+	&quot;QT_NO_DIAL&quot; =&gt;			[&quot;QtGui/qdial.h&quot;, &quot;QDial foo;&quot;, 10],
+	&quot;QT_NO_DIALOG&quot; =&gt;		[&quot;QtGui/qdialog.h&quot;, &quot;QDialog foo;&quot;, 12],
+	&quot;QT_NO_DIR&quot; =&gt;			[&quot;QtCore/qdir.h&quot;, &quot;QDir foo;&quot;, 5],
+	#QT_NO_DIRECTPAINTER
+	&quot;QT_NO_DOM&quot; =&gt;			[&quot;QtXml/qdom.h&quot;, &quot;QDomDocumentType foo;&quot;, 5],
+	&quot;QT_NO_DRAGANDDROP&quot; =&gt;		[&quot;QtGui/qevent.h&quot;, &quot;QDropEvent foo( QDropEvent() );&quot;, 5],
+	&quot;QT_NO_DRAWUTIL&quot; =&gt;		[&quot;QtGui/qdrawutil.h, QtGui/qcolor.h&quot;, &quot;qDrawPlainRect( (QPainter *) NULL, 0, 0, 0, 0, QColor() );&quot;, 10],
+	#QT_NO_EFFECTS
+	&quot;QT_NO_ERRORMESSAGE&quot; =&gt; 	[&quot;QtGui/qerrormessage.h&quot;, &quot;QErrorMessage foo( (QWidget*) NULL );&quot;, 13],
+	&quot;QT_NO_FILEDIALOG&quot; =&gt;		[&quot;QtGui/qfiledialog.h&quot;, &quot;QFileDialog foo();&quot;, 13],
+
+	&quot;QT_NO_FONTDATABASE&quot; =&gt;		[&quot;QtGui/qfontdatabase.h&quot;, &quot;QFontDatabase foo;&quot;, 5],
+	&quot;QT_NO_FONTDIALOG&quot; =&gt; 		[&quot;QtGui/qfontdialog.h&quot;,   &quot;QFontDialog::getFont( (bool *)NULL );&quot;, 12],
+	&quot;QT_NO_FRAME&quot; =&gt; 		[&quot;QtGui/qframe.h&quot;, &quot;QFrame foo;&quot;, 10],
+	#QT_NO_FREETYPE
+ 	&quot;QT_NO_FTP&quot; =&gt;	[&quot;QtNetwork/qftp.h&quot;, &quot;QFtp foo;&quot;, 9],
+	&quot;QT_NO_GROUPBOX&quot; =&gt;		[&quot;QtGui/qgroupbox.h&quot;, &quot;QGroupBox foo;&quot;, 12],
+	#QT_NO_IMAGEFORMAT_BMP
+	#QT_NO_IMAGEFORMAT_JPEG
+	#QT_NO_IMAGEFORMATPLUGIN
+	#QT_NO_IMAGEFORMAT_PNG
+	#QT_NO_IMAGEFORMAT_PPM
+	#QT_NO_IMAGEFORMAT_XBM
+ 	&quot;QT_NO_IMAGE_HEURISTIC_MASK&quot; =&gt;	[&quot;QtGui/qimage.h&quot;, q&#163;
+						QImage *foo = new QImage;
+						foo-&gt;createHeuristicMask();
+					&#163;, 8],
+	#QT_NO_IMAGE_TEXT
+	&quot;QT_NO_IMAGEIO&quot; =&gt; 		[&quot;QtGui/qbitmap.h, QtCore/qstring.h&quot;, q&#163;
+						QBitmap foo( QString::fromLatin1(&quot;foobar&quot;) );
+					&#163;, 5],
+	&quot;QT_NO_LABEL&quot; =&gt;		[&quot;QtGui/qlabel.h&quot;, &quot;QLabel foo( (QWidget*) NULL );&quot;, 10],
+	&quot;QT_NO_LAYOUT&quot; =&gt;		[&quot;QtGui/qlayout.h&quot;, &quot;QFoo foo;&quot;, 10, q&#163;
+ 						class QFoo: public QLayout
+ 						{
+ 						public:
+ 						    QFoo() {};
+ 						    ~QFoo() {};
+ 						    void addItem( QLayoutItem * ) { };
+						    QSize sizeHint() const { return QSize(); }
+						    void setGeometry( const QRect &amp; ) { };
+                            QLayoutItem* itemAt(int) const {return (QLayoutItem*) NULL;}
+                            QLayoutItem* takeAt(int) {return (QLayoutItem*) NULL;}
+                            int QFoo::count() const {return 0;}
+
+ 						};
+ 					&#163;],
+	&quot;QT_NO_LCDNUMBER&quot; =&gt;		[&quot;QtGui/qlcdnumber.h&quot;, &quot;QLCDNumber foo;&quot;, 12],
+	&quot;QT_NO_LINEEDIT&quot; =&gt;		[&quot;QtGui/qlineedit.h&quot;, &quot;QLineEdit foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_LISTVIEW&quot; =&gt;		[&quot;QtGui/qlistview.h&quot;, &quot;QListView foo;&quot;, 13],
+	&quot;QT_NO_MAINWINDOW&quot; =&gt;		[&quot;QtGui/qmainwindow.h&quot;, &quot;QMainWindow foo;&quot;, 13],
+	&quot;QT_NO_MATRIX&quot; =&gt;		[&quot;QtGui/qmatrix.h&quot;, &quot;QMatrix foo;&quot;, 0],
+	&quot;QT_NO_MENUBAR&quot; =&gt;		[&quot;QtGui/qmenubar.h&quot;, &quot;QMenuBar foo;&quot;, 13],
+	&quot;QT_NO_MESSAGEBOX&quot; =&gt;		[&quot;QtGui/qmessagebox.h&quot;, &quot;QMessageBox foo;&quot;, 13],
+	&quot;QT_NO_MOVIE&quot; =&gt;		[&quot;QtGui/qmovie.h&quot;, &quot;QMovie foo;&quot;, 5],
+	&quot;QT_NO_NETWORK&quot; =&gt;		[&quot;QtNetwork/qnetworkproxy.h&quot;, &quot;QNetworkProxy foo;&quot;, 5],
+	#QT_NO_NETWORKPROXY
+	&quot;QT_NO_PALETTE&quot; =&gt;		[&quot;QtGui/qpalette.h&quot;, &quot;QPalette foo;&quot;, 5],
+	&quot;QT_NO_PICTURE&quot; =&gt;		[&quot;QtGui/qpicture.h&quot;, &quot;QPicture foo;&quot;, 5],
+	&quot;QT_NO_PRINTER&quot; =&gt;		[&quot;QtGui/qprinter.h&quot;, &quot;QPrinter foo();&quot;, 5],
+	&quot;QT_NO_PRINTDIALOG&quot; =&gt;		[&quot;QtGui/qprintdialog.h&quot;, &quot;QPrintDialog foo( (QPrinter*) NULL );&quot;, 13],
+	&quot;QT_NO_PROCESS&quot; =&gt;		[&quot;QtCore/qprocess.h&quot;, &quot;QProcess foo;&quot;, 5],
+	&quot;QT_NO_PROGRESSBAR&quot; =&gt;		[&quot;QtGui/qprogressbar.h&quot;, &quot;QProgressBar foo;&quot;, 12],
+	&quot;QT_NO_PROGRESSDIALOG&quot; =&gt;	[&quot;QtGui/qprogressdialog.h&quot;, &quot;QProgressDialog foo;&quot;, 13],
+	&quot;QT_NO_PROPERTIES&quot; =&gt;		[&quot;QtCore/qmetaobject.h&quot;, &quot;QMetaProperty foo;&quot;, 0],
+	&quot;QT_NO_PUSHBUTTON&quot; =&gt;		[&quot;QtGui/qpushbutton.h&quot;, &quot;QPushButton foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_QUUID_STRING&quot; =&gt;		[&quot;QtCore/quuid.h&quot;, &quot;QUuid foo( QString() );&quot;, 8],
+	&quot;QT_NO_RADIOBUTTON&quot; =&gt;		[&quot;QtGui/qradiobutton.h&quot;, &quot;QRadioButton foo( (QWidget *) NULL );&quot;, 12],
+	#QT_NO_QWS_ALPHA_CURSOR
+	#QT_NO_QWS_DECORATION_DEFAULT
+	#QT_NO_QWS_INPUTMETHODS
+	#QT_NO_QWS_KEYBOARD
+	#QT_NO_QWS_MOUSE
+	#QT_NO_QWS_MOUSE_AUTO
+	#QT_NO_QWS_MOUSE_MANUAL
+	#QT_NO_QWS_MULTIPROCESS
+	#QT_NO_QWS_PROPERTIES
+	#QT_NO_QWS_QPF
+	#QT_NO_RESIZEHANDLER
+	#QT_NO_RUBBERBAND
+	&quot;QT_NO_SCROLLBAR&quot; =&gt;		[&quot;QtGui/qscrollbar.h&quot;, &quot;QScrollBar foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_SESSIONMANAGER&quot; =&gt;	[&quot;QtGui/qapplication.h&quot;, q&#163;
+  						QApplication foo( argc, argv );
+  						foo.sessionId();
+					&#163;, 15],
+	&quot;QT_NO_SETTINGS&quot; =&gt;		[&quot;QtCore/qsettings.h&quot;, &quot;QSettings foo;&quot;, 5],
+	#QT_NO_SHORTCUT
+	&quot;QT_NO_SIGNALMAPPER&quot; =&gt;		[&quot;QtCore/qsignalmapper.h&quot;, &quot;QSignalMapper foo( (QObject *) NULL );&quot;, 0],
+	&quot;QT_NO_SIZEGRIP&quot; =&gt;		[&quot;QtGui/qsizegrip.h&quot;, &quot;QSizeGrip foo( (QWidget *) NULL );&quot;, 10],
+	&quot;QT_NO_SLIDER&quot; =&gt;		[&quot;QtGui/qslider.h&quot;, &quot;QSlider foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_SOUND&quot; =&gt;		[&quot;QtGui/qsound.h&quot;, &quot;QSound foo( QString::null );&quot;, 5],
+	#QT_NO_SPINWIDGET
+	#QT_NO_SPLASHSCREEN
+	#QT_NO_STACKEDWIDGET
+	#QT_NO_STATUSBAR
+	#QT_NO_STATUSTIP
+	#QT_NO_STL
+	&quot;QT_NO_STRINGLIST&quot; =&gt;		[&quot;qstringlist.h&quot;, &quot;QStringList foo;&quot;, 0],
+	&quot;QT_NO_STYLE_PLASTIQUE&quot; =&gt;		[&quot;QtGui/qplastiquestyle.h&quot;, &quot;QPlastiqueStyle foo;&quot;, 16],
+ 	&quot;QT_NO_STYLE_WINDOWSXP&quot; =&gt;	[&quot;QtGui/qwindowsxpstyle.h&quot;, &quot;QWindowsXPStyle foo;&quot;, 16],
+ 	&quot;QT_NO_STYLE_WINDOWS&quot; =&gt;	[&quot;QtGui/qwindowsstyle.h&quot;, &quot;QWindowsStyle foo;&quot;, 16],
+	&quot;QT_NO_STYLE_MAC&quot; =&gt;	[&quot;QtGui/macstyle.h&quot;, &quot;QMacStyle foo;&quot;, 16],
+	&quot;QT_NO_STYLE_CLEANLOOKS&quot; =&gt;	[&quot;QtGui/qcleanlooksstyle.h&quot;, &quot;QCleanlooksStyle foo;&quot;, 16],
+    &quot;QT_NO_TABBAR&quot; =&gt;               [&quot;QtGui/qtabbar.h&quot;, &quot;QTabBar foo;&quot;, 10],
+	&quot;QT_NO_TABLEVIEW&quot; =&gt;		[&quot;QtGui/qtableview.h&quot;, &quot;QTableView foo;&quot;, 16],
+    &quot;QT_NO_TABWIDGET&quot; =&gt;            [&quot;QtGui/qtabwidget.h&quot;, &quot;QTabWidget foo;&quot;, 10],
+    &quot;QT_NO_TEXTBROWSER&quot; =&gt;          [&quot;QtGui/qtextbrowser.h&quot;, &quot;QTextBrowser foo;&quot;, 14],
+    &quot;QT_NO_TEXTCODEC&quot; =&gt;            [&quot;QtCore/qtextcodec.h&quot;, &quot;QTextCodec::codecForMib(1);&quot;, 5],
+    &quot;QT_NO_TEXTCODECPLUGIN&quot; =&gt;      [&quot;QtCore/qtextcodecplugin.h, QtCore/qstringlist.h, QtCore/qlist.h, QtCore/qtextcodec.h&quot;, &quot;QFoo foo;&quot;, 6, q&#163; 
+						class QFoo: public QTextCodecPlugin
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            QList&lt;QByteArray&gt; names() const {return QList&lt;QByteArray&gt;();}
+                            QList&lt;int&gt;mibEnums() const {return QList&lt;int&gt;();}
+                            QTextCodec *createForName( const QByteArray &amp; name ) {return (QTextCodec *)NULL;}
+                            QTextCodec *createForMib( int mib ) {return (QTextCodec *)NULL;}
+                            QList&lt;QByteArray&gt; aliases() const {return QList&lt;QByteArray&gt;();}
+						};
+						Q_EXPORT_PLUGIN2( &quot;Foo&quot;, QFoo )
+					&#163;],
+	#QT_NO_TEXTDATE
+ 	&quot;QT_NO_TEXTEDIT&quot; =&gt;		[&quot;QtGui/qtextedit.h&quot;, &quot;QTextEdit foo;&quot;, 13], 
+    &quot;QT_NO_TEXTSTREAM&quot; =&gt;           [&quot;qtextstream.h&quot;, &quot;QTextStream foo;&quot;, 5],
+    &quot;QT_NO_THREAD&quot; =&gt;           [&quot;QtCore/qthread.h&quot;, &quot;QFoo foo;&quot;, 5, q&#163;
+						class QFoo: public QThread
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            void run() {}
+						};
+					&#163;],
+    &quot;QT_NO_TOOLBAR&quot; =&gt;              [&quot;QtGui/qtoolbar.h&quot;, &quot;QToolBar foo;&quot;, 10],
+    &quot;QT_NO_TOOLBUTTON&quot; =&gt;           [&quot;QtGui/qtoolbutton.h&quot;, &quot;QToolButton foo((QWidget *) NULL );&quot;, 12],
+    &quot;QT_NO_TOOLTIP&quot; =&gt;              [&quot;QtGui/qtooltip.h&quot;, &quot;QToolTip::palette();&quot;, 10],
+	#QT_NO_TRANSLATION
+	#QT_NO_UDPSOCKET
+	#QT_NO_URLINFO
+	#QT_NO_VALIDATOR
+    &quot;QT_NO_VARIANT&quot; =&gt;              [&quot;QtCore/qvariant.h&quot;, &quot;QVariant foo;&quot;, 0],
+    &quot;QT_NO_WHATSTHIS&quot; =&gt;            [&quot;QtGui/qwhatsthis.h&quot;, &quot;QWhatsThis::inWhatsThisMode();&quot;, 10],
+	&quot;QT_NO_WHEELEVENT&quot; =&gt;		[&quot;QtGui/qevent.h&quot;, &quot;QWheelEvent foo( QPoint(1,1), 1, (Qt::MouseButtons)1, 0 );&quot;, 5],
+	&quot;QT_NO_XML&quot; =&gt;			[&quot;QtXml/qxml.h&quot;, &quot;QXmlNamespaceSupport foo;&quot;, 5],
+	);
+
+}

Added: trunk/smoke/qt/CMakeLists.txt
===================================================================
--- trunk/smoke/qt/CMakeLists.txt	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/CMakeLists.txt	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,132 @@
+
+include(FindQScintilla)
+include(FindQwt)
+
+include_directories( ${QT_INCLUDES}  ${CMAKE_CURRENT_SOURCE_DIR}/../ ${CMAKE_CURRENT_SOURCE_DIR} )
+
+if(QSCINTILLA_FOUND)
+    include_directories( ${QSCINTILLA_INCLUDE_DIR} )
+endif(QSCINTILLA_FOUND)
+
+if(QWT_FOUND)
+    include_directories( ${QWT_INCLUDE_DIR} )
+endif(QWT_FOUND)
+
+IF(QT_QTDBUS_FOUND)
+    SET(QTDBUS_LIBRARY QtDBus)
+ENDIF(QT_QTDBUS_FOUND)
+
+# for qtguess.pl
+set(qt_test_threshold 10)
+set(qtflags &quot;-lQtCore -lQtGui&quot;)
+FOREACH(filename ${QT_INCLUDES})
+    set(all_includes &quot;-I${filename} ${all_includes}&quot;)
+ENDFOREACH(filename)
+
+configure_file(qtguess.pl.cmake ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl @ONLY)
+configure_file(generate.pl.cmake ${CMAKE_CURRENT_BINARY_DIR}/generate.pl @ONLY )
+
+# macro is defined in qt-copy/src/qbase.pri but couldn't be found by qtguess, so I append it manually
+file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/qtdefines &quot;QT_NO_CAST_TO_ASCII\n&quot;)
+
+########### next target ###############
+
+add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_2.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_3.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_4.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_5.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_6.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_7.cpp 
+                ${CMAKE_CURRENT_BINARY_DIR}/x_8.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_9.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_10.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_11.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_12.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_13.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_14.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_15.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_16.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_17.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_18.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_19.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_20.cpp
+
+                  COMMAND ${PERL_EXECUTABLE} ARGS ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl
+                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/qtguess.pl
+
+                  COMMAND ${PERL_EXECUTABLE} ARGS ${CMAKE_CURRENT_BINARY_DIR}/generate.pl
+                  DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/generate.pl
+
+                  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
+
+macro_add_file_dependencies( ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp ${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp )
+
+set(smokeqt_LIB_SRCS ${CMAKE_CURRENT_BINARY_DIR}/smokedata.cpp  
+		${CMAKE_CURRENT_BINARY_DIR}/x_1.cpp 
+		${CMAKE_CURRENT_BINARY_DIR}/x_2.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_3.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_4.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_5.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_6.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_7.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_8.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_9.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_10.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_11.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_12.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_13.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_14.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_15.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_16.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_17.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_18.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_19.cpp
+                ${CMAKE_CURRENT_BINARY_DIR}/x_20.cpp
+)
+
+# kde4_add_library(smokeqt SHARED ${smokeqt_LIB_SRCS})
+add_library(smokeqt SHARED ${smokeqt_LIB_SRCS})
+
+target_link_libraries(smokeqt ${QT_QTCORE_LIBRARY} QtSvg QtGui QtNetwork QtSql QtOpenGL QtXml QtUiTools ${QTDBUS_LIBRARY} ${QSCINTILLA_LIBRARIES} ${QWT_LIBRARIES} )
+
+set_target_properties(smokeqt PROPERTIES VERSION 2.0.0 SOVERSION 2 )
+install(TARGETS smokeqt DESTINATION lib )
+
+
+########### install files ###############
+
+
+
+
+#original Makefile.am contents follow:
+
+#lib_LTLIBRARIES = libsmokeqt.la
+#
+## set the include path for X, qt and KDE
+#INCLUDES         = -I$(srcdir)/.. $(all_includes) -I$(qt_includes)/QtUiTools \
+#                   -I$(qt_includes)/QtDBus
+#
+#EXTRA_DIST=generate.pl.in qtguess.pl.in qt_smoke.h Makefile.am
+#
+## the library search path. 
+#libsmokeqt_la_LDFLAGS = -version-info 2:0:0 -no-undefined $(all_libraries) $(GLINC)
+#
+## the libraries to link against.
+#libsmokeqt_la_LIBADD   = $(LIB_QTCORE) $(LIB_QTGUI) $(LIB_QTNETWORK) \
+#						$(LIB_QTOPENGL) $(LIB_QTSQL) $(LIB_QTCORE) $(LIB_QTXML) $(LIB_QTSVG) \
+#						$(GLLIB) $(LIBQSCINTILLA) \
+#						-lQtSvg -lQtUiTools $(LIBQTDBUS) $(LIBQWT)
+#
+#x_sources = x_1.cpp x_2.cpp x_3.cpp x_4.cpp x_5.cpp x_6.cpp x_7.cpp \
+#   x_8.cpp x_9.cpp x_10.cpp x_11.cpp x_12.cpp x_13.cpp x_14.cpp x_15.cpp \
+#   x_16.cpp x_17.cpp x_18.cpp x_19.cpp x_20.cpp
+#
+## which sources should be compiled for perlqtkde
+#libsmokeqt_la_SOURCES = smokedata.cpp $(x_sources)
+#
+#$(x_sources) smokedata.cpp:
+#	perl generate.pl
+#
+#CLEANFILES = $(libsmokeqt_la_SOURCES)

Added: trunk/smoke/qt/generate.pl.cmake
===================================================================
--- trunk/smoke/qt/generate.pl.cmake	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/generate.pl.cmake	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,254 @@
+#!/usr/bin/perl -w
+
+## Run this first, to generate the x_*.cpp files from the Qt headers
+## using kalyptus
+
+my $kalyptusdir = &quot;@CMAKE_CURRENT_SOURCE_DIR@/../../kalyptus&quot;;
+
+use File::Basename;
+use File::Copy qw|cp|;
+use File::Compare;
+use File::Find;
+use Cwd;
+
+my $here = getcwd;
+my $outdir = $here . &quot;/generate.pl.tmpdir&quot;;
+my $finaloutdir = $here;
+my $defines = &quot;qtdefines&quot;;
+my $headerlist = &quot;@CMAKE_CURRENT_SOURCE_DIR@/header_list&quot;;
+my $definespath = &quot;$here/$defines&quot;;
+my $headerlistpath = &quot;$headerlist&quot;;
+my $qscintilla_headerlist = &quot;&quot;;
+my $qscintilla_headerlistpath = &quot;&quot;;
+my $qtdbus_headerlist = &quot;&quot;;
+my $qtdbus_headerlistpath = &quot;&quot;;
+
+if(&quot;@QSCINTILLA_FOUND@&quot; eq &quot;YES&quot;)
+{
+ $qscintilla_headerlist = &quot;@CMAKE_CURRENT_SOURCE_DIR@/qscintilla2_header_list&quot;;
+ $qscintilla_headerlistpath = &quot;$here/$qscintilla_headerlist&quot;;
+}
+
+if(&quot;@QT_QTDBUS_FOUND@&quot; eq &quot;1&quot;)
+{
+ $qtdbus_headerlist = &quot;@CMAKE_CURRENT_SOURCE_DIR@/qtdbus_header_list&quot;;
+ $qtdbus_headerlistpath = &quot;$here/$qtdbus_headerlist&quot;;
+}
+
+if(&quot;@QWT_FOUND@&quot; eq &quot;YES&quot;)
+{
+ $qwt_headerlist = &quot;@CMAKE_CURRENT_SOURCE_DIR@/qwt_header_list&quot;;
+ $qwt_headerlistpath = &quot;$here/$qwt_headerlist&quot;;
+}
+
+## If srcdir != builddir, use headerlist from src
+$headerlistpath = $headerlist if ($headerlist =~ /^\//);
+if(&quot;@QSCINTILLA_FOUND@&quot; eq &quot;YES&quot;)
+{
+ $qscintilla_headerlistpath = $qscintilla_headerlist if ($qscintilla_headerlist =~ /^\//);
+}
+
+if(&quot;@QT_QTDBUS_FOUND@&quot; eq &quot;1&quot;)
+{
+ $qtdbus_headerlistpath = $qtdbus_headerlist if ($qtdbus_headerlist =~ /^\//);
+}
+
+if(&quot;@QWT_FOUND@&quot; eq &quot;YES&quot;)
+{
+ $qwt_headerlistpath = $qwt_headerlist if ($qwt_headerlist =~ /^\//);
+}
+## Note: outdir and finaloutdir should NOT be the same dir!
+
+# Delete all x_*.cpp files under outdir (or create outdir if nonexistent)
+if (-d $outdir) { system &quot;rm -f $outdir/x_*.cpp&quot;; } else { mkdir $outdir; }
+
+mkdir $finaloutdir unless (-d $finaloutdir);
+
+#  Load the QT_NO_* macros found in &quot;qtdefines&quot;. They'll be passed to kalyptus
+my $macros=&quot;&quot;;
+if ( -e $definespath ){
+    print &quot;Found '$defines'. Reading preprocessor symbols from there...\n&quot;;
+    $macros = &quot; --defines=$definespath &quot;;
+}
+
+mkdir $kalyptusdir, 0777;
+# Need to cd to kalyptus's directory so that perl finds Ast.pm etc.
+chdir &quot;$kalyptusdir&quot; or die &quot;Couldn't go to $kalyptusdir (edit script to change dir)\n&quot;;
+
+# Find out which header files we need to parse
+# We don't want all of them - e.g. not template-based stuff
+my %excludes = (
+    'qaccessible.h' =&gt; 1,  # Accessibility support is not compiled by defaut
+    'qassistantclient.h' =&gt; 1, # Not part of Qt (introduced in Qt-3.1)
+    'qmotif.h' =&gt; 1,       # 
+    'qmotifwidget.h' =&gt; 1, # Motif extension (introduced in Qt-3.1)
+    'qmotifdialog.h' =&gt; 1, #
+    'qxt.h' =&gt; 1, # Xt
+    'qxtwidget.h' =&gt; 1, # Xt
+    'qdns.h' =&gt; 1, # internal
+    'qgl.h' =&gt; 1, # OpenGL
+    'qglcolormap.h' =&gt; 1, # OpenGL
+    'qnp.h' =&gt; 1, # NSPlugin
+    'qttableview.h' =&gt; 1,  # Not in Qt anymore...
+    'qtmultilineedit.h' =&gt; 1,  # Not in Qt anymore...
+    'qwidgetfactory.h' =&gt; 1,  # Just an interface
+    'qsharedmemory.h' =&gt; 1, # &quot;not part of the Qt API&quot; they say
+    'qwindowsstyle.h' =&gt; 1, # Qt windowsstyle, plugin
+    'qmotifstyle.h' =&gt; 1,
+    'qcompactstyle.h' =&gt; 1,
+    'qinterlacestyle.h' =&gt; 1,
+    'qmotifplusstyle.h' =&gt; 1,
+    'qsgistyle.h' =&gt; 1,
+    'qplatinumstyle.h' =&gt; 1,
+    'qcdestyle.h' =&gt; 1,
+	 'qworkspace.h' =&gt; 1,
+    'qwindowsxpstyle.h' =&gt; 1 # play on the safe side 
+);
+
+# Some systems have a QTDIR = KDEDIR = PREFIX
+# We need a complete list
+
+my %includes;
+open(HEADERS, $headerlistpath) or die &quot;Couldn't open $headerlistpath: $!\n&quot;;
+map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+close HEADERS;
+
+if(&quot;@QSCINTILLA_FOUND@&quot; eq &quot;YES&quot;)
+{
+ open(HEADERS, $qscintilla_headerlistpath) or die &quot;Couldn't open $qscintilla_headerlistpath: $!\n&quot;;
+ map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+ close HEADERS;
+}
+
+if(&quot;@QT_QTDBUS_FOUND@&quot; eq &quot;1&quot;)
+{
+ open(HEADERS, $qtdbus_headerlistpath) or die &quot;Couldn't open $qtdbus_headerlistpath: $!\n&quot;;
+ map { chomp ; $includes{$_} = 1 } &lt;HEADERS&gt;;
+ close HEADERS;
+}
+
+my %qwt_includes;
+if(&quot;@QWT_FOUND@&quot; eq &quot;YES&quot;)
+{
+ open(HEADERS, $qwt_headerlistpath) or die &quot;Couldn't open $qwt_headerlistpath: $!\n&quot;;
+ map { chomp ; $qwt_includes{$_} = 1 } &lt;HEADERS&gt;;
+ close HEADERS;
+}
+ 
+# Can we compile the OpenGl module ?
+if(&quot;@QT_OPENGL_FOUND@&quot; eq &quot;YES&quot;)
+{
+    open(DEFS, $definespath);
+    my @defs = &lt;DEFS&gt;;
+    close DEFS;
+    if(!grep(/QT_NO_OPENGL/, @defs))
+    {
+      $excludes{'qgl.h'} = undef;
+      $excludes{'qglcolormap.h'} = undef;
+    }
+    else
+    {
+      print STDERR &quot;Qt was not compiled with OpenGL support...\n Skipping QGL Classes.\n&quot;;
+    }
+}
+
+# List Qt headers, and exclude the ones listed above
+my @headers = ();
+
+$qtinc= '@QT_INCLUDE_DIR@';
+
+find(
+    {   wanted =&gt; sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qtinc);
+                if( !defined $excludes{$f} # Not excluded
+                     &amp;&amp; $includes{$f}        # Known header
+                     &amp;&amp; /\.h$/)     # Not a backup file etc. Only headers.
+                {
+                    my $header = $_;
+                    open(FILE, $_);
+                    my @header_lines = &lt;FILE&gt;;
+                    if (@header_lines == 1) {
+                        $line = $header_lines[0];
+                        if ($line =~ /^#include &quot;(.*)&quot;/) {
+                            push ( @headers, $qtinc . substr($1, 2) );
+                        } else {
+                            push ( @headers, $header );
+                        }
+                    } else {
+                        push ( @headers, $header );
+                    }
+                }
+	    	undef $includes{$f}   
+	     };
+	},
+	follow_fast =&gt; 1,
+	follow_skip =&gt; 2,
+	no_chdir =&gt; 1
+    }, $qtinc
+ );
+
+$qwtinc = '@QWT_INCLUDE_DIR@';
+
+find(
+    {   wanted =&gt; sub {
+	    (-e || -l and !-d) and do {
+	        $f = substr($_, 1 + length $qwtinc);
+		push ( @headers, $_ )
+                if( !defined $excludes{$f} # Not excluded
+                     &amp;&amp; $qwt_includes{$f}        # Known header
+                     &amp;&amp; /\.h$/);     # Not a backup file etc. Only headers.
+	    	undef $qwt_includes{$f}   
+	     };
+	},
+	follow_fast =&gt; 1,
+	follow_skip =&gt; 2,
+	no_chdir =&gt; 1
+    }, $qwtinc
+ );
+ 
+# Launch kalyptus
+chdir &quot;../smoke/qt&quot;;
+system &quot;perl <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">-I at kdebindings_SOURCE_DIR</A>@/kalyptus @kdebindings_SOURCE_DIR@/kalyptus/kalyptus @ARGV --qt4 --globspace -fsmoke --name=qt $macros --no-cache --outputdir=$outdir @headers&quot;;
+my $exit = $? &gt;&gt; 8;
+exit $exit if ($exit);
+chdir &quot;$kalyptusdir&quot;;
+
+# Generate diff for smokedata.cpp
+unless ( -e &quot;$finaloutdir/smokedata.cpp&quot; ) {
+    open( TOUCH, &quot;&gt;$finaloutdir/smokedata.cpp&quot;);
+    close TOUCH;
+}
+system &quot;diff -u $finaloutdir/smokedata.cpp $outdir/smokedata.cpp &gt; $outdir/smokedata.cpp.diff&quot;;
+
+# Copy changed or new files to finaloutdir
+opendir (OUT, $outdir) or die &quot;Couldn't opendir $outdir&quot;;
+foreach $filename (readdir(OUT)) {
+    next if ( -d &quot;$outdir/$filename&quot; ); # only files, not dirs
+    my $docopy = 1;
+    if ( -f &quot;$finaloutdir/$filename&quot; ) {
+        $docopy = compare(&quot;$outdir/$filename&quot;, &quot;$finaloutdir/$filename&quot;); # 1 if files are differents
+    }
+    if ($docopy) {
+	#print STDERR &quot;Updating $filename...\n&quot;;
+	cp(&quot;$outdir/$filename&quot;, &quot;$finaloutdir/$filename&quot;);
+    }
+}
+closedir OUT;
+
+# Check for deleted files and warn
+my $deleted = 0;
+opendir(FINALOUT, $finaloutdir) or die &quot;Couldn't opendir $finaloutdir&quot;;
+foreach $filename (readdir(FINALOUT)) {
+    next if ( -d &quot;$finaloutdir/$filename&quot; ); # only files, not dirs
+    if ( $filename =~ /.cpp$/ &amp;&amp; ! ($filename =~ /_la_closure.cpp/) &amp;&amp; ! -f &quot;$outdir/$filename&quot; ) {
+      print STDERR &quot;Removing obsolete file $filename\n&quot;;
+      unlink &quot;$finaloutdir/$filename&quot;;
+      $deleted = 1;
+    }
+}
+closedir FINALOUT;
+
+# Delete outdir
+system &quot;rm -rf $outdir&quot;;
+

Modified: trunk/smoke/qt/header_list
===================================================================
--- trunk/smoke/qt/header_list	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/header_list	2007-02-19 21:34:59 UTC (rev 290)
@@ -26,6 +26,7 @@
 QtCore/qfeatures.h
 QtCore/qfile.h
 QtCore/qfileinfo.h
+QtCore/qfilesystemwatcher.h
 QtCore/qfsfileengine.h
 QtCore/qglobal.h
 QtCore/qiodevice.h
@@ -258,6 +259,7 @@
 QtGui/qwindowsxpstyle.h
 QtGui/qwmatrix.h
 QtGui/qworkspace.h
+QtGui/qx11embed_x11.h
 QtGui/qx11info_x11.h
 QtNetwork/qabstractsocket.h
 QtNetwork/qftp.h

Added: trunk/smoke/qt/qscintilla2_header_list
===================================================================
--- trunk/smoke/qt/qscintilla2_header_list	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/qscintilla2_header_list	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,30 @@
+Qsci/qsciapis.h
+Qsci/qscicommand.h
+Qsci/qscicommandset.h
+Qsci/qscidocument.h
+Qsci/qsciglobal.h
+Qsci/qscilexerbash.h
+Qsci/qscilexerbatch.h
+Qsci/qscilexercpp.h
+Qsci/qscilexercsharp.h
+Qsci/qscilexercss.h
+Qsci/qscilexerdiff.h
+Qsci/qscilexer.h
+Qsci/qscilexerhtml.h
+Qsci/qscilexeridl.h
+Qsci/qscilexerjava.h
+Qsci/qscilexerjavascript.h
+Qsci/qscilexerlua.h
+Qsci/qscilexermakefile.h
+Qsci/qscilexerperl.h
+Qsci/qscilexerpov.h
+Qsci/qscilexerproperties.h
+Qsci/qscilexerpython.h
+Qsci/qscilexerruby.h
+Qsci/qscilexersql.h
+Qsci/qscilexertex.h
+Qsci/qscimacro.h
+Qsci/qscintilla2_header_list
+Qsci/qsciprinter.h
+Qsci/qsciscintillabase.h
+Qsci/qsciscintilla.h

Modified: trunk/smoke/qt/qt_smoke.h
===================================================================
--- trunk/smoke/qt/qt_smoke.h	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/qt_smoke.h	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,8 +1,9 @@
 #ifndef QT_SMOKE_H
 #define QT_SMOKE_H
-
+#include &lt;kdemacros.h&gt;
 // Defined in smokedata.cpp, initialized by init_qt_Smoke(), used by all .cpp files
-extern Smoke* qt_Smoke;
+extern KDE_EXPORT Smoke* qt_Smoke;
+extern KDE_EXPORT void init_qt_Smoke();
 
 class QGlobalSpace { };
 

Modified: trunk/smoke/qt/qtdbus_header_list
===================================================================
--- trunk/smoke/qt/qtdbus_header_list	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/qtdbus_header_list	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,5 +1,6 @@
 QtDBus/qdbusabstractadaptor.h
 QtDBus/qdbusabstractinterface.h
+QtDBus/qdbusargument.h
 QtDBus/qdbusconnection.h
 QtDBus/qdbusconnectioninterface.h
 QtDBus/qdbuserror.h

Added: trunk/smoke/qt/qtguess.pl.cmake
===================================================================
--- trunk/smoke/qt/qtguess.pl.cmake	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/qtguess.pl.cmake	2007-02-19 21:34:59 UTC (rev 290)
@@ -0,0 +1,423 @@
+#!/usr/bin/perl
+
+# qtguess.pl : check how Qt was compiled. Issue a list of all defined QT_NO_* macros, one per line.
+#
+# author:  germain Garand &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">germain at ebooksfrance.com</A>&gt;
+# licence: GPL v.2
+
+# options: -q: be quieter
+#	   -o file: redirect output to &quot;file&quot;. (default: ./qtdefines)
+#	   -t [0..15]: set the testing threshold (see below)
+#	   -f &quot;flags&quot;: additional compiler flags/parameters
+
+use Getopt::Std;
+
+use vars qw/$opt_f $opt_o $opt_p/;
+
+getopts('qo:f:t:');
+
+# Threshold :
+#	 0 - test basic Qt types/classes
+#	 5 - test higher level, non-gui classes
+#	 8 - test options of the above (ex: QT_NO_IMAGE_SMOOTHSCALE)
+#	10 - test basic widgets
+#	12 - test composite widgets
+#	13 - test widgets inheriting composite widgets
+#	15 - test goodies (default)
+
+my $default_threshold = @qt_test_threshold@;
+my $cc = &quot;@CMAKE_CXX_COMPILER@&quot;;
+my $ccflags = $opt_f || &quot;@CMAKE_CXX_FLAGS@&quot;;
+
+my $nspaces = 50;
+
+my %qtdefs=();
+my %qtundefs=();
+
+my $tmp = gettmpfile();
+my $qtinc = '@QT_INCLUDE_DIR@';
+my $allinc = '@all_includes@';
+my $alllib = '<A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">-L at QT_LIBRARY_DIR</A>@';
+my $qtflags = '@qtflags@';
+# my %x;
+# $x{'LIBPNG'}  =   '@LIBPNG@';
+# $x{'LIBJPEG'} =   '@LIBJPEG@';
+# $x{'LIBSM'}   =   '@LIBSM@';
+# $x{'LIBSOCKET'} = '@LIBSOCKET@';
+# $x{'LIBDL'}      = '@LIBDL@';
+# $x{'LIBRESOLV'}  = '@LIBRESOLV@';
+# $x{'LIB_X11'} =   '@LIB_X11@';
+# $x{'X_PRE_LIBS'} = '@X_PRE_LIBS@';
+# $x{'LIB_X11'} =~ s/\$\((.*?)\)/$x{$1}/g;
+# 
+# $qtflags =~ s/\$\((.*?)\)/$x{$1}/g;
+
+ -e &quot;$qtinc/QtCore/qglobal.h&quot; or die &quot;Invalid Qt include directory.\n&quot;;
+
+my $ccmd = &quot;$cc $ccflags $allinc $alllib -o $tmp $tmp.cpp $qtflags&quot;;
+
+my $threshold = defined($opt_t)?$opt_t : $default_threshold;
+$threshold &gt;= 0 or die &quot;invalid testing threshold: $threshold\n&quot;;
+
+print &quot;Checking how Qt was built... \n&quot;;
+print &quot;Threshold is set to $threshold\n&quot; unless $opt_q;
+
+my($count, $used, $total);
+map{ $tests{$_}-&gt;[2]&gt;=$threshold ? ($used++, $total++):$total++ } keys %tests;
+
+print &quot;Number of defines to be tested : $used/$total\n\n&quot; unless $opt_q;
+open( QTDEFS, &quot;&gt;&gt;&quot;.($opt_o || &quot;qtdefines&quot;) ) or die &quot;Can't open output file: $!\n&quot;;
+
+grab_qglobal_symbols();
+preliminary_test();
+perform_all_tests();
+
+print +scalar(keys %qtdefs) . &quot; defines found.\n&quot;;
+
+print QTDEFS join(&quot;\n&quot;, keys %qtdefs), &quot;\n&quot;;
+close;
+
+#--------------------------------------------------------------#
+
+sub gettmpfile
+{
+	my $tmpdir = $ENV{'TMP'} || &quot;.&quot;;
+	my $tmpname = $$.&quot;-qtguess&quot;;
+	while( -e &quot;$tmpdir/$tmpname&quot; || -e &quot;$tmpdir/${tmpname}.cpp&quot; )
+	{
+		$tmpname .= int (rand * 9);
+	}
+	return &quot;$tmpdir/$tmpname&quot;;
+}
+
+#--------------------------------------------------------------#
+
+sub grab_qglobal_symbols
+{
+	my $cmd = &quot;$cc -E -D__cplusplus -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2&gt;/dev/null&quot;;
+	my $symbols = `$cmd`;
+        for(0..1)
+        {
+	    if( check_exit_status($?) )
+	    {
+		while( $symbols =~/^#\s*define\s*(QT_\S+)/gm )
+		{
+			$qtdefs{$1} = 1;
+		}
+		print &quot;Found &quot;. scalar( keys %qtdefs ).&quot; predefined symbol&quot;.((scalar( keys %qtdefs ) -1)?&quot;s&quot;:&quot;&quot;).&quot; in qglobal.h\n&quot; unless ($opt_q or !(keys %qtdefs));
+		while( $symbols =~/^#\s*define\s*QT_MODULE_(\S+)/gm )
+		{
+			$qtundefs{&quot;QT_NO_$1&quot;} = 1;
+		}
+		print &quot;Found &quot;. scalar( keys %qtundefs ).&quot; undefined symbol&quot;.((scalar( keys %qtundefs ) -1)?&quot;s&quot;:&quot;&quot;).&quot; in qglobal.h\n&quot; unless ($opt_q or !(keys %qtundefs));
+                last;
+	    }
+	    elsif(! $_) # first try
+	    {
+		print  &quot;Failed to run $cmd.\nTrying without __cplusplus (might be already defined)\n&quot;;
+                $cmd = &quot;$cc -E -dM -I$qtinc/QtCore $qtinc/QtCore/qglobal.h 2&gt;/dev/null&quot;;
+                $symbols = `$cmd`;
+                next;
+	    }
+        }
+}
+
+#--------------------------------------------------------------#
+
+sub preliminary_test
+{
+	my $msg = &quot;Trying to compile and link a small program...&quot;;
+	print $msg, &quot; &quot; x ($nspaces - length($msg) + 8);
+	open( OUT, &quot;&gt;${tmp}.cpp&quot; ) or die &quot;Failed to open temp file ${tmp}.cpp: $!\n&quot;;
+	my $simple=q&quot;
+		#include &lt;QtGui/qapplication.h&gt;
+		int main( int argc, char **argv )
+		{
+			QApplication foo( argc, argv );
+			return 0;
+		}
+	&quot;;
+	print OUT $simple;
+	close OUT;
+        my $out = `$ccmd 2&gt;&amp;1`;
+	if( !check_exit_status($?) )
+	{
+		die &lt;&lt;&quot;EOF&quot;;
+
+FAILED : check your configuration.
+Failed program was:
+$simple
+Compiled with:
+$ccmd
+Compiler output:
+$out
+EOF
+	}
+	else
+	{
+		print &quot;OK\n&quot;;
+	}
+}
+
+#--------------------------------------------------------------#
+
+sub perform_all_tests
+{
+	foreach ( sort { $tests{$a}-&gt;[2] &lt;=&gt; $tests{$b}-&gt;[2]} keys %tests)
+	{
+		$tests{$_}-&gt;[2] &lt; $threshold and next;
+		($qtdefs{$_} || $qtundefs{$_}) and do
+		{
+			print &quot;\rSkipping $_ (in qglobal.h)&quot;.( &quot; &quot; x (($nspaces-16) - length($_)) ).($qtundefs{$_}?&quot;*Undefined*&quot;:&quot; [Defined]&quot;).($opt_q?&quot;&quot;:&quot;\n&quot;);
+			next
+		};
+		print &quot;\rTesting $_&quot;.( &quot; &quot; x ($nspaces - length($_)) );
+		open( OUT, &quot;&gt;${tmp}.cpp&quot; ) or die &quot;Failed to open temp file ${tmp}.cpp: $!\n&quot;;
+		foreach $def(keys %qtdefs)
+		{
+			print OUT &quot;#define $def\n&quot;;
+		}
+		foreach $inc(split /,\s*/, $tests{$_}-&gt;[0])
+		{
+			print OUT &quot;#include &lt;$inc&gt;\n&quot;;
+		}
+		print OUT &quot;#include &lt;QtCore/qfeatures.h&gt;\n&quot;;
+		print OUT $tests{$_}-&gt;[3] if $tests{$_}-&gt;[3]; # need to define some classes ?
+		print OUT qq&quot;
+
+		int main( int argc, char ** argv)
+		{
+		$tests{$_}-&gt;[1]
+		return 0;
+		}
+
+		&quot;;
+		close OUT;
+
+                my $out = `$ccmd 2&gt;&amp;1`;
+		my $ok = check_exit_status($?);
+		if( !$ok )
+		{
+			$qtdefs{$_} = 1;
+		}
+		print +$opt_q ? ++$count.&quot;/$used&quot; : ( $ok ? &quot;*Undefined*\n&quot; : &quot; [Defined]\n&quot; );
+	}
+	$opt_q &amp;&amp; print &quot;\n&quot;;
+}
+
+#--------------------------------------------------------------#
+
+sub check_exit_status
+{
+	my $a = 0xFFFF &amp; shift;
+	if( !$a )
+	{
+		return 1;
+	}
+	elsif( $a == 0xFF00 )
+	{
+		die &quot;\nSystem call failed: $!\n&quot;;
+	}
+	elsif( $a &gt; 0x80 )
+	{
+		# non-zero status.
+	}
+	else
+	{
+		if( $a &amp; 0x80 )
+		{
+			die &quot;\n$cc coredumped with signal &quot;. ($a &amp; ~0x80);
+		}
+		die &quot;\n$cc interrupted by signal $a\n&quot;;
+	}
+	return 0;
+}
+
+#--------------------------------------------------------------#
+
+END
+{
+	unlink $tmp if -e $tmp;
+	unlink &quot;${tmp}.cpp&quot; if -e &quot;${tmp}.cpp&quot;;
+}
+
+#--------------------------------------------------------------#
+
+BEGIN {
+
+# &quot;DEFINE&quot; =&gt; [&quot;header-1.h,... header-n.h&quot;, &quot;main() code&quot;, priority, &quot;Definitions (if needed)&quot;]
+
+our %tests = (
+	&quot;QT_NO_ACCESSIBILITY&quot; =&gt;        [&quot;QtGui/qaccessible.h&quot;, &quot;QAccessibleEvent event(QEvent::AccessibilityHelp, 0);&quot;, 15],
+	&quot;QT_NO_ACTION&quot; =&gt;		[&quot;QtGui/qaction.h&quot;, &quot;QAction foo( (QObject*)NULL );&quot;, 5],
+	#QT_NO_BIG_CODECS
+ 	&quot;QT_NO_BUTTONGROUP&quot; =&gt;		[&quot;QtGui/qbuttongroup.h&quot;, &quot;QButtonGroup foo( (QObject*)NULL );&quot;, 12],
+ 	&quot;QT_NO_CHECKBOX&quot; =&gt;		[&quot;QtGui/qcheckbox.h&quot;, &quot;QCheckBox foo( (QWidget*)NULL );&quot;, 10],
+	&quot;QT_NO_CLIPBOARD&quot; =&gt; 		[&quot;QtGui/qapplication.h, QtGui/qclipboard.h&quot;, q&quot;
+						QApplication foo( argc, argv );
+						QClipboard *baz= foo.clipboard();
+					&quot;, 5],
+ 	&quot;QT_NO_COLORDIALOG&quot; =&gt;		[&quot;QtGui/qcolordialog.h&quot;, &quot;QColorDialog::customCount();&quot;, 12],
+	#QT_NO_COLORNAMES
+ 	&quot;QT_NO_COMBOBOX&quot; =&gt;		[&quot;QtGui/qcombobox.h&quot;, &quot;QComboBox foo( (QWidget*)NULL );&quot;, 10],
+	&quot;QT_NO_COMPAT&quot; =&gt;		[&quot;QtGui/qfontmetrics.h&quot;, q&quot;
+						QFontMetrics *foo= new QFontMetrics( QFont() );
+						int bar = foo-&gt;width( 'c' );
+					&quot;, 0],
+	&quot;QT_NO_COMPONENT&quot; =&gt;		[&quot;QtGui/qapplication.h&quot;, q&quot;
+ 						QApplication foo( argc, argv );
+ 						foo.addLibraryPath( QString::null );
+					&quot;, 5],
+	#QT_NO_COP
+ 	&quot;QT_NO_CURSOR&quot; =&gt;		[&quot;QtGui/qcursor.h&quot;, &quot;QCursor foo;&quot;, 5],
+ 	&quot;QT_NO_DATASTREAM&quot; =&gt;		[&quot;QtCore/qdatastream.h&quot;, &quot;QDataStream foo;&quot;, 5],
+ 	&quot;QT_NO_DATETIMEEDIT&quot; =&gt;		[&quot;QtGui/qdatetimeedit.h&quot;, &quot;QTimeEdit foo;&quot;, 12],
+	&quot;QT_NO_DIAL&quot; =&gt;			[&quot;QtGui/qdial.h&quot;, &quot;QDial foo;&quot;, 10],
+	&quot;QT_NO_DIALOG&quot; =&gt;		[&quot;QtGui/qdialog.h&quot;, &quot;QDialog foo;&quot;, 12],
+	&quot;QT_NO_DIR&quot; =&gt;			[&quot;QtCore/qdir.h&quot;, &quot;QDir foo;&quot;, 5],
+	#QT_NO_DIRECTPAINTER
+	&quot;QT_NO_DOM&quot; =&gt;			[&quot;QtXml/qdom.h&quot;, &quot;QDomDocumentType foo;&quot;, 5],
+	&quot;QT_NO_DRAGANDDROP&quot; =&gt;		[&quot;QtGui/qevent.h&quot;, &quot;QDropEvent foo( QDropEvent() );&quot;, 5],
+	&quot;QT_NO_DRAWUTIL&quot; =&gt;		[&quot;QtGui/qdrawutil.h, QtGui/qcolor.h&quot;, &quot;qDrawPlainRect( (QPainter *) NULL, 0, 0, 0, 0, QColor() );&quot;, 10],
+	#QT_NO_EFFECTS
+	&quot;QT_NO_ERRORMESSAGE&quot; =&gt; 	[&quot;QtGui/qerrormessage.h&quot;, &quot;QErrorMessage foo( (QWidget*) NULL );&quot;, 13],
+	&quot;QT_NO_FILEDIALOG&quot; =&gt;		[&quot;QtGui/qfiledialog.h&quot;, &quot;QFileDialog foo();&quot;, 13],
+
+	&quot;QT_NO_FONTDATABASE&quot; =&gt;		[&quot;QtGui/qfontdatabase.h&quot;, &quot;QFontDatabase foo;&quot;, 5],
+	&quot;QT_NO_FONTDIALOG&quot; =&gt; 		[&quot;QtGui/qfontdialog.h&quot;,   &quot;QFontDialog::getFont( (bool *)NULL );&quot;, 12],
+	&quot;QT_NO_FRAME&quot; =&gt; 		[&quot;QtGui/qframe.h&quot;, &quot;QFrame foo;&quot;, 10],
+	#QT_NO_FREETYPE
+ 	&quot;QT_NO_FTP&quot; =&gt;	[&quot;QtNetwork/qftp.h&quot;, &quot;QFtp foo;&quot;, 9],
+	&quot;QT_NO_GROUPBOX&quot; =&gt;		[&quot;QtGui/qgroupbox.h&quot;, &quot;QGroupBox foo;&quot;, 12],
+	#QT_NO_IMAGEFORMAT_BMP
+	#QT_NO_IMAGEFORMAT_JPEG
+	#QT_NO_IMAGEFORMATPLUGIN
+	#QT_NO_IMAGEFORMAT_PNG
+	#QT_NO_IMAGEFORMAT_PPM
+	#QT_NO_IMAGEFORMAT_XBM
+ 	&quot;QT_NO_IMAGE_HEURISTIC_MASK&quot; =&gt;	[&quot;QtGui/qimage.h&quot;, q&quot;
+						QImage *foo = new QImage;
+						foo-&gt;createHeuristicMask();
+					&quot;, 8],
+	#QT_NO_IMAGE_TEXT
+	&quot;QT_NO_IMAGEIO&quot; =&gt; 		[&quot;QtGui/qbitmap.h, QtCore/qstring.h&quot;, q&quot;
+						QBitmap foo( QString::fromLatin1('foobar') );
+					&quot;, 5],
+	&quot;QT_NO_LABEL&quot; =&gt;		[&quot;QtGui/qlabel.h&quot;, &quot;QLabel foo( (QWidget*) NULL );&quot;, 10],
+	&quot;QT_NO_LAYOUT&quot; =&gt;		[&quot;QtGui/qlayout.h&quot;, &quot;QFoo foo;&quot;, 10, q&quot;
+ 						class QFoo: public QLayout
+ 						{
+ 						public:
+ 						    QFoo() {};
+ 						    ~QFoo() {};
+ 						    void addItem( QLayoutItem * ) { };
+						    QSize sizeHint() const { return QSize(); }
+						    void setGeometry( const QRect &amp; ) { };
+                            QLayoutItem* itemAt(int) const {return (QLayoutItem*) NULL;}
+                            QLayoutItem* takeAt(int) {return (QLayoutItem*) NULL;}
+                            int QFoo::count() const {return 0;}
+
+ 						};
+ 					&quot;],
+	&quot;QT_NO_LCDNUMBER&quot; =&gt;		[&quot;QtGui/qlcdnumber.h&quot;, &quot;QLCDNumber foo;&quot;, 12],
+	&quot;QT_NO_LINEEDIT&quot; =&gt;		[&quot;QtGui/qlineedit.h&quot;, &quot;QLineEdit foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_LISTVIEW&quot; =&gt;		[&quot;QtGui/qlistview.h&quot;, &quot;QListView foo;&quot;, 13],
+	&quot;QT_NO_MAINWINDOW&quot; =&gt;		[&quot;QtGui/qmainwindow.h&quot;, &quot;QMainWindow foo;&quot;, 13],
+	&quot;QT_NO_MATRIX&quot; =&gt;		[&quot;QtGui/qmatrix.h&quot;, &quot;QMatrix foo;&quot;, 0],
+	&quot;QT_NO_MENUBAR&quot; =&gt;		[&quot;QtGui/qmenubar.h&quot;, &quot;QMenuBar foo;&quot;, 13],
+	&quot;QT_NO_MESSAGEBOX&quot; =&gt;		[&quot;QtGui/qmessagebox.h&quot;, &quot;QMessageBox foo;&quot;, 13],
+	&quot;QT_NO_MOVIE&quot; =&gt;		[&quot;QtGui/qmovie.h&quot;, &quot;QMovie foo;&quot;, 5],
+	&quot;QT_NO_NETWORK&quot; =&gt;		[&quot;QtNetwork/qnetworkproxy.h&quot;, &quot;QNetworkProxy foo;&quot;, 5],
+	#QT_NO_NETWORKPROXY
+	&quot;QT_NO_PALETTE&quot; =&gt;		[&quot;QtGui/qpalette.h&quot;, &quot;QPalette foo;&quot;, 5],
+	&quot;QT_NO_PICTURE&quot; =&gt;		[&quot;QtGui/qpicture.h&quot;, &quot;QPicture foo;&quot;, 5],
+	&quot;QT_NO_PRINTER&quot; =&gt;		[&quot;QtGui/qprinter.h&quot;, &quot;QPrinter foo();&quot;, 5],
+	&quot;QT_NO_PRINTDIALOG&quot; =&gt;		[&quot;QtGui/qprintdialog.h&quot;, &quot;QPrintDialog foo( (QPrinter*) NULL );&quot;, 13],
+	&quot;QT_NO_PROCESS&quot; =&gt;		[&quot;QtCore/qprocess.h&quot;, &quot;QProcess foo;&quot;, 5],
+	&quot;QT_NO_PROGRESSBAR&quot; =&gt;		[&quot;QtGui/qprogressbar.h&quot;, &quot;QProgressBar foo;&quot;, 12],
+	&quot;QT_NO_PROGRESSDIALOG&quot; =&gt;	[&quot;QtGui/qprogressdialog.h&quot;, &quot;QProgressDialog foo;&quot;, 13],
+	&quot;QT_NO_PROPERTIES&quot; =&gt;		[&quot;QtCore/qmetaobject.h&quot;, &quot;QMetaProperty foo;&quot;, 0],
+	&quot;QT_NO_PUSHBUTTON&quot; =&gt;		[&quot;QtGui/qpushbutton.h&quot;, &quot;QPushButton foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_QUUID_STRING&quot; =&gt;		[&quot;QtCore/quuid.h&quot;, &quot;QUuid foo( QString() );&quot;, 8],
+	&quot;QT_NO_RADIOBUTTON&quot; =&gt;		[&quot;QtGui/qradiobutton.h&quot;, &quot;QRadioButton foo( (QWidget *) NULL );&quot;, 12],
+	#QT_NO_QWS_ALPHA_CURSOR
+	#QT_NO_QWS_DECORATION_DEFAULT
+	#QT_NO_QWS_INPUTMETHODS
+	#QT_NO_QWS_KEYBOARD
+	#QT_NO_QWS_MOUSE
+	#QT_NO_QWS_MOUSE_AUTO
+	#QT_NO_QWS_MOUSE_MANUAL
+	#QT_NO_QWS_MULTIPROCESS
+	#QT_NO_QWS_PROPERTIES
+	#QT_NO_QWS_QPF
+	#QT_NO_RESIZEHANDLER
+	#QT_NO_RUBBERBAND
+	&quot;QT_NO_SCROLLBAR&quot; =&gt;		[&quot;QtGui/qscrollbar.h&quot;, &quot;QScrollBar foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_SESSIONMANAGER&quot; =&gt;	[&quot;QtGui/qapplication.h&quot;, q&quot;
+  						QApplication foo( argc, argv );
+  						foo.sessionId();
+					&quot;, 15],
+	&quot;QT_NO_SETTINGS&quot; =&gt;		[&quot;QtCore/qsettings.h&quot;, &quot;QSettings foo;&quot;, 5],
+	#QT_NO_SHORTCUT
+	&quot;QT_NO_SIGNALMAPPER&quot; =&gt;		[&quot;QtCore/qsignalmapper.h&quot;, &quot;QSignalMapper foo( (QObject *) NULL );&quot;, 0],
+	&quot;QT_NO_SIZEGRIP&quot; =&gt;		[&quot;QtGui/qsizegrip.h&quot;, &quot;QSizeGrip foo( (QWidget *) NULL );&quot;, 10],
+	&quot;QT_NO_SLIDER&quot; =&gt;		[&quot;QtGui/qslider.h&quot;, &quot;QSlider foo( (QWidget *) NULL );&quot;, 12],
+	&quot;QT_NO_SOUND&quot; =&gt;		[&quot;QtGui/qsound.h&quot;, &quot;QSound foo( QString::null );&quot;, 5],
+	#QT_NO_SPINWIDGET
+	#QT_NO_SPLASHSCREEN
+	#QT_NO_STACKEDWIDGET
+	#QT_NO_STATUSBAR
+	#QT_NO_STATUSTIP
+	#QT_NO_STL
+	&quot;QT_NO_STRINGLIST&quot; =&gt;		[&quot;qstringlist.h&quot;, &quot;QStringList foo;&quot;, 0],
+	&quot;QT_NO_STYLE_PLASTIQUE&quot; =&gt;		[&quot;QtGui/qplastiquestyle.h&quot;, &quot;QPlastiqueStyle foo;&quot;, 16],
+ 	&quot;QT_NO_STYLE_WINDOWSXP&quot; =&gt;	[&quot;QtGui/qwindowsxpstyle.h&quot;, &quot;QWindowsXPStyle foo;&quot;, 16],
+ 	&quot;QT_NO_STYLE_WINDOWS&quot; =&gt;	[&quot;QtGui/qwindowsstyle.h&quot;, &quot;QWindowsStyle foo;&quot;, 16],
+	&quot;QT_NO_STYLE_MAC&quot; =&gt;	[&quot;QtGui/macstyle.h&quot;, &quot;QMacStyle foo;&quot;, 16],
+	&quot;QT_NO_STYLE_CLEANLOOKS&quot; =&gt;	[&quot;QtGui/qcleanlooksstyle.h&quot;, &quot;QCleanlooksStyle foo;&quot;, 16],
+    &quot;QT_NO_TABBAR&quot; =&gt;               [&quot;QtGui/qtabbar.h&quot;, &quot;QTabBar foo;&quot;, 10],
+	&quot;QT_NO_TABLEVIEW&quot; =&gt;		[&quot;QtGui/qtableview.h&quot;, &quot;QTableView foo;&quot;, 16],
+    &quot;QT_NO_TABWIDGET&quot; =&gt;            [&quot;QtGui/qtabwidget.h&quot;, &quot;QTabWidget foo;&quot;, 10],
+    &quot;QT_NO_TEXTBROWSER&quot; =&gt;          [&quot;QtGui/qtextbrowser.h&quot;, &quot;QTextBrowser foo;&quot;, 14],
+    &quot;QT_NO_TEXTCODEC&quot; =&gt;            [&quot;QtCore/qtextcodec.h&quot;, &quot;QTextCodec::codecForMib(1);&quot;, 5],
+    &quot;QT_NO_TEXTCODECPLUGIN&quot; =&gt;      [&quot;QtCore/qtextcodecplugin.h, QtCore/qstringlist.h, QtCore/qlist.h, QtCore/qtextcodec.h&quot;, &quot;QFoo foo;&quot;, 6, q&quot;
+						class QFoo: public QTextCodecPlugin
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            QList&lt;QByteArray&gt; names() const {return QList&lt;QByteArray&gt;();}
+                            QList&lt;int&gt;mibEnums() const {return QList&lt;int&gt;();}
+                            QTextCodec *createForName( const QByteArray &amp; name ) {return (QTextCodec *)NULL;}
+                            QTextCodec *createForMib( int mib ) {return (QTextCodec *)NULL;}
+                            QList&lt;QByteArray&gt; aliases() const {return QList&lt;QByteArray&gt;();}
+						};
+						Q_EXPORT_PLUGIN2( 'Foo', QFoo )
+					&quot;],
+	#QT_NO_TEXTDATE
+ 	&quot;QT_NO_TEXTEDIT&quot; =&gt;		[&quot;QtGui/qtextedit.h&quot;, &quot;QTextEdit foo;&quot;, 13], 
+    &quot;QT_NO_TEXTSTREAM&quot; =&gt;           [&quot;qtextstream.h&quot;, &quot;QTextStream foo;&quot;, 5],
+    &quot;QT_NO_THREAD&quot; =&gt;           [&quot;QtCore/qthread.h&quot;, &quot;QFoo foo;&quot;, 5, q&quot;
+						class QFoo: public QThread
+						{
+						public:
+						    QFoo() {};
+						    ~QFoo() {};
+                            void run() {}
+						};
+					&quot;],
+    &quot;QT_NO_TOOLBAR&quot; =&gt;              [&quot;QtGui/qtoolbar.h&quot;, &quot;QToolBar foo;&quot;, 10],
+    &quot;QT_NO_TOOLBUTTON&quot; =&gt;           [&quot;QtGui/qtoolbutton.h&quot;, &quot;QToolButton foo((QWidget *) NULL );&quot;, 12],
+    &quot;QT_NO_TOOLTIP&quot; =&gt;              [&quot;QtGui/qtooltip.h&quot;, &quot;QToolTip::palette();&quot;, 10],
+	#QT_NO_TRANSLATION
+	#QT_NO_UDPSOCKET
+	#QT_NO_URLINFO
+	#QT_NO_VALIDATOR
+    &quot;QT_NO_VARIANT&quot; =&gt;              [&quot;QtCore/qvariant.h&quot;, &quot;QVariant foo;&quot;, 0],
+    &quot;QT_NO_WHATSTHIS&quot; =&gt;            [&quot;QtGui/qwhatsthis.h&quot;, &quot;QWhatsThis::inWhatsThisMode();&quot;, 10],
+	&quot;QT_NO_WHEELEVENT&quot; =&gt;		[&quot;QtGui/qevent.h&quot;, &quot;QWheelEvent foo( QPoint(1,1), 1, (Qt::MouseButtons)1, 0 );&quot;, 5],
+	&quot;QT_NO_XML&quot; =&gt;			[&quot;QtXml/qxml.h&quot;, &quot;QXmlNamespaceSupport foo;&quot;, 5],
+
+	);
+
+}

Modified: trunk/smoke/qt/qtguess.pl.in
===================================================================
--- trunk/smoke/qt/qtguess.pl.in	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/qtguess.pl.in	2007-02-19 21:34:59 UTC (rev 290)
@@ -374,6 +374,7 @@
  	&quot;QT_NO_STYLE_WINDOWSXP&quot; =&gt;	[&quot;QtGui/qwindowsxpstyle.h&quot;, &quot;QWindowsXPStyle foo;&quot;, 16],
  	&quot;QT_NO_STYLE_WINDOWS&quot; =&gt;	[&quot;QtGui/qwindowsstyle.h&quot;, &quot;QWindowsStyle foo;&quot;, 16],
 	&quot;QT_NO_STYLE_MAC&quot; =&gt;	[&quot;QtGui/macstyle.h&quot;, &quot;QMacStyle foo;&quot;, 16],
+	&quot;QT_NO_STYLE_CLEANLOOKS&quot; =&gt;	[&quot;QtGui/qcleanlooksstyle.h&quot;, &quot;QCleanlooksStyle foo;&quot;, 16],
     &quot;QT_NO_TABBAR&quot; =&gt;               [&quot;QtGui/qtabbar.h&quot;, &quot;QTabBar foo;&quot;, 10],
 	&quot;QT_NO_TABLEVIEW&quot; =&gt;		[&quot;QtGui/qtableview.h&quot;, &quot;QTableView foo;&quot;, 16],
     &quot;QT_NO_TABWIDGET&quot; =&gt;            [&quot;QtGui/qtabwidget.h&quot;, &quot;QTabWidget foo;&quot;, 10],

Modified: trunk/smoke/qt/qwt_header_list
===================================================================
--- trunk/smoke/qt/qwt_header_list	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/qwt_header_list	2007-02-19 21:34:59 UTC (rev 290)
@@ -4,9 +4,11 @@
 qwt_analog_clock.h
 qwt_array.h
 qwt_arrow_button.h
+qwt_color_map.h
 qwt_compass.h
 qwt_compass_rose.h
 qwt_counter.h
+qwt_curve_fitter.h
 qwt_data.h
 qwt_dial.h
 qwt_dial_needle.h
@@ -25,6 +27,7 @@
 qwt_math.h
 qwt_paint_buffer.h
 qwt_painter.h
+qwt_panner.h
 qwt_picker.h
 qwt_picker_machine.h
 qwt_plot_canvas.h
@@ -34,10 +37,16 @@
 qwt_plot.h
 qwt_plot_item.h
 qwt_plot_layout.h
+qwt_plot_magnifier.h
 qwt_plot_marker.h
+qwt_plot_panner.h
 qwt_plot_picker.h
 qwt_plot_printfilter.h
+qwt_plot_rasteritem.h
+qwt_plot_spectrogram.h
 qwt_plot_zoomer.h
+qwt_polygon.h
+qwt_raster_data.h
 qwt_rect.h
 qwt_round_scale_draw.h
 qwt_scale_div.h
@@ -51,5 +60,7 @@
 qwt_text_engine.h
 qwt_text.h
 qwt_text_label.h
+qwt_text_plugin.h
 qwt_thermo.h
+qwt_valuelist.h
 qwt_wheel.h

Modified: trunk/smoke/qt/smokeqt.pro
===================================================================
--- trunk/smoke/qt/smokeqt.pro	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qt/smokeqt.pro	2007-02-19 21:34:59 UTC (rev 290)
@@ -2,13 +2,18 @@
 # Automatically generated by qmake (2.00a) lun 17. abr 22:10:08 2006
 ######################################################################
 
-QT += network xml sql opengl
+QT += network xml sql opengl svg uitools
 TEMPLATE = lib
 TARGET += 
 DEPENDPATH += .
 INCLUDEPATH += .
 INCLUDEPATH += ..
 
+# Add a 'qdbus' option if building with QtDBus:
+CONFIG += uitools
+
+DEFINES += QT_NO_DEBUG_STREAM
+
 # Input
 HEADERS += qt_smoke.h
 SOURCES += smokedata.cpp \

Deleted: trunk/smoke/qwidgetitemdata_p.h
===================================================================
--- trunk/smoke/qwidgetitemdata_p.h	2006-11-28 08:04:52 UTC (rev 289)
+++ trunk/smoke/qwidgetitemdata_p.h	2007-02-19 21:34:59 UTC (rev 290)
@@ -1,70 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 1992-2005 Trolltech AS. All rights reserved.
-**
-** This file is part of the item views module of the Qt Toolkit.
-**
-** This file may be distributed under the terms of the Q Public License
-** as defined by Trolltech AS of Norway and appearing in the file
-** LICENSE.QPL included in the packaging of this file.
-**
-** This file may be distributed and/or modified under the terms of the
-** GNU General Public License version 2 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.
-**
-** See <A HREF="http://www.trolltech.com/pricing.html">http://www.trolltech.com/pricing.html</A> or email <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">sales at trolltech.com</A> for
-**   information about Qt Commercial License Agreements.
-** See <A HREF="http://www.trolltech.com/qpl/">http://www.trolltech.com/qpl/</A> for QPL licensing information.
-** See <A HREF="http://www.trolltech.com/gpl/">http://www.trolltech.com/gpl/</A> for GPL licensing information.
-**
-** Contact <A HREF="https://lists.berlios.de/mailman/listinfo/php-qt-svn">info at trolltech.com</A> if any conditions of this licensing are
-** not clear to you.
-**
-** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
-** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
-**
-****************************************************************************/
-
-#ifndef QWIDGETITEMDATA_P_H
-#define QWIDGETITEMDATA_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-class QWidgetItemData
-{
-public:
-    QWidgetItemData() : role(-1) {}
-    QWidgetItemData(int r, QVariant v) : role(r), value(v) {}
-    int role;
-    QVariant value;
-};
-
-#ifndef QT_NO_DATASTREAM
-
-inline QDataStream &amp;operator&gt;&gt;(QDataStream &amp;in, QWidgetItemData &amp;data)
-{
-    in &gt;&gt; data.role;
-    in &gt;&gt; data.value;
-    return in;
-}
-
-inline QDataStream &amp;operator&lt;&lt;(QDataStream &amp;out, const QWidgetItemData &amp;data)
-{
-    out &lt;&lt; data.role;
-    out &lt;&lt; data.value;
-    return out;
-}
-
-#endif
-
-#endif // QWIDGETITEMDATA_P_H


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000135.html">[Php-qt-svn] r291 - in trunk: . cmake cmake/modules
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#134">[ date ]</a>
              <a href="thread.html#134">[ thread ]</a>
              <a href="subject.html#134">[ subject ]</a>
              <a href="author.html#134">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/php-qt-svn">More information about the Php-qt-svn
mailing list</a><br>
</body></html>
