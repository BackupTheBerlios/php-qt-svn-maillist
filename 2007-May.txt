From tm243 at mail.berlios.de  Sun May 20 23:13:28 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Sun, 20 May 2007 23:13:28 +0200
Subject: [Php-qt-svn] r316 - in trunk: . examples/calculator php_qt tests
	tutorials/t5
Message-ID: <200705202113.l4KLDS71006873@sheep.berlios.de>

Author: tm243
Date: 2007-05-20 23:13:23 +0200 (Sun, 20 May 2007)
New Revision: 316

Modified:
   trunk/ChangeLog
   trunk/examples/calculator/button.php
   trunk/examples/calculator/calculator.php
   trunk/php_qt/functions.cpp
   trunk/php_qt/handlers.cpp
   trunk/php_qt/marshall.h
   trunk/php_qt/marshall_basetypes.h
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/marshall_types.h
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/php_qt/qstring.cpp
   trunk/php_qt/smokephp.cpp
   trunk/tests/QtBasicTestCase.php
   trunk/tutorials/t5/main.php
Log:
* using createObject()
* got references working
* lots of stuff i cannot remember



Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/ChangeLog	2007-05-20 21:13:23 UTC (rev 316)
@@ -1,3 +1,6 @@
+
+		* mapping of zend object instead of zval
+
 2007-003-22  Thomas Moenicke <thomas.moenicke at kdemail.net>
 
 		* call of virtual methods

Modified: trunk/examples/calculator/button.php
===================================================================
--- trunk/examples/calculator/button.php	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/examples/calculator/button.php	2007-05-20 21:13:23 UTC (rev 316)
@@ -11,7 +11,7 @@
 
     class Button extends QToolButton {
 
-        function __construct($text, &$color)
+        function __construct($text, $color)
         {
             parent::__construct();
 
@@ -19,7 +19,7 @@
             $this->setText($text);
 
     	    $newPalette = new QPalette();
-            $newPalette->setColor(QPalette::Button, &$color);
+            $newPalette->setColor(QPalette::Button, $color);
             $this->setPalette($newPalette);
         }
     }

Modified: trunk/examples/calculator/calculator.php
===================================================================
--- trunk/examples/calculator/calculator.php	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/examples/calculator/calculator.php	2007-05-20 21:13:23 UTC (rev 316)
@@ -111,7 +111,7 @@
             $this->reciprocalButton = $this->createButton(tr("1/x"), $operatorColor, SLOT('unaryOperatorClicked()'));
             $this->equalButton = $this->createButton(tr("="), $operatorColor, SLOT('equalClicked()'));
 
-            $this->mainLayout = &new QGridLayout($this);
+            $this->mainLayout = new QGridLayout($this);
             $this->mainLayout->setSizeConstraint(QLayout::SetFixedSize);
 
             $this->mainLayout->addWidget($this->display, 0, 0, 1, 6);
@@ -156,7 +156,7 @@
                     || $event->type() == QEvent::MouseButtonRelease
                     || $event->type() == QEvent::ContextMenu) {
 
-                    $mouseEvent = &$event;
+                    $mouseEvent = $event;
                     if ($mouseEvent->buttons() & Qt::LeftButton) {
                         $newPalette = $this->palette();
                         $newPalette->setColor(QPalette::Base,
@@ -376,9 +376,9 @@
             $this->sumInMemory += $this->display->text()->toDouble();
         }
 
-        function createButton($text, &$color, $member)
+        function createButton($text, $color, $member)
         {
-            $button = new Button($text, &$color);
+            $button = new Button($text, $color);
             $this->connect($button, SIGNAL('clicked()'), $this, $member);
             return $button;
         }

Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/php_qt/functions.cpp	2007-05-20 21:13:23 UTC (rev 316)
@@ -62,15 +62,16 @@
         return;
     }
 
-    char* tmp = (char*) emalloc((int) string_len + 2);
-    strcpy(tmp,"2");
+//     char* tmp = (char*) emalloc((int) string_len + 2);
+//     strcpy(tmp,"2");
+//     strncat(tmp, string, (int) string_len);
 
-    strncat(tmp, string, (int) string_len);
+	QString *qstring = new QString(string);
+	qstring->prepend("2");
+    ZVAL_STRING(return_value,(char*) qstring->toLatin1().constData(),1);
 
-    ZVAL_STRING(return_value,tmp,1);
+//     efree(tmp);
 
-    efree(tmp);
-
     return;
 }
 
@@ -86,15 +87,16 @@
         return;
     }
 
-    char* tmp = (char*) emalloc((int) string_len + 2);
-    strcpy(tmp,"1");
+//     char* tmp = (char*) emalloc((int) string_len + 2);
+//     strcpy(tmp,"1");
+//     strncat(tmp, string, (int) string_len);
 
-    strncat(tmp, string, (int) string_len);
+	QString *qstring = new QString(string);
+	qstring->prepend("1");
+    ZVAL_STRING(return_value,(char*) qstring->toLatin1().constData(),1);
 
-    ZVAL_STRING(return_value,tmp,1);
+//     efree(tmp);
 
-    efree(tmp);
-
     return;
 }
 
@@ -117,6 +119,7 @@
 /**
  *	simply returns the first parameter because objects are casted automatically in smokephp_convertReturn(...)
  *
+ *	function defined for compatibility
  */
 
 PHP_FUNCTION(qobject_cast){
@@ -129,7 +132,10 @@
         return; 
     }
 
-	ZVAL_ZVAL(return_value, obj, 0, 0);
+	// just return the first argument
+	// see marshall_basetypes.h, marshall_to_php<SmokeClassWrapper>
+ 	zval_ptr_dtor(return_value_ptr);
+ 	*(return_value_ptr) = obj;
     return;
 
 }
@@ -147,18 +153,9 @@
         return;
     }
 
-	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
-	o->ptr = new QString(QObject::tr(string));
-	o->smoke = qt_Smoke;
-	o->classId = 0;		// QString is not in smoke
-	o->ce_ptr = qstring_ce;
-	o->zval_ptr = return_value;
+	QString *ptr = new QString(QObject::tr(string));
+	phpqt_createObject(return_value, ptr, qstring_ce, QSTRING_CLASSID);
 
-	object_init_ex(return_value, qstring_ce);
-	zend_rsrc_list_entry le;
-	le.ptr = o;
-	phpqt_register(return_value, le);
-	phpqt_setSmokePHPObject(o);
     return;
 }
 
@@ -168,44 +165,84 @@
  */
 
 
-void check_object(zval* zobject)
+void check_qobject(zval* zobject)
 {
 
 	if(!phpqt_SmokePHPObjectExists(zobject)) {
-	    php_error(E_ERROR,"Object is not registered.");
-	}
 
-	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(zobject);
+		cout << "PHP Object \n(" << endl;
 
-	cout << "PHP-Qt object \n(" << endl;
+		cout << "\t       zval => " << zobject << endl;
+// 		cout << "\tclass entry => " << Z_OBJCE_P(zobject)->name << endl;
+		cout << "\t  ref count => " << zobject->refcount << endl;
+		cout << "\t     is_ref => " << (int) zobject->is_ref << endl;
+		cout << "\t       type => " << printType(Z_TYPE_P(zobject)) << endl;
 
-	cout << "\t       zval => " << zobject << endl;
-	cout << "\tclass entry => " << Z_OBJCE_P(zobject)->name << endl;
-	cout << "\t  ref count => " << zobject->refcount << endl;
-	cout << "\t     is_ref => " << zobject->is_ref << endl;
-	cout << "\t       type => " << Z_TYPE_P(zobject) << endl;
+		if(Z_TYPE_P(zobject) == 5)
+		{
+		 cout <<"\t obj-handle => " << zobject->value.obj.handle << endl;
+		}
 
-	cout << endl;
+		cout << ")" << endl;
 
-	cout << "\t      smokeobj => " << o << endl;
-	cout << "\t         Smoke => " << o->smoke << endl;
-	cout << "\t       classId => " << o->classId << endl;
-	cout << "\t        Qt ptr => " << o->ptr << endl;
-	cout << "\t        ce_ptr => " << o->ce_ptr << endl;
-	cout << "\t      zval_ptr => " << o->zval_ptr << endl;
-	cout << "\t  QMetaObject* => " << o->meta << endl;
+	} else {
 
-	cout << ")" << endl;
+		smokephp_object* o = phpqt_getSmokePHPObjectFromZval(zobject);
 
+		cout << "PHP-Qt object \n(" << endl;
+
+		cout << "\t       zval => " << zobject << endl;
+	// 	cout << "\tclass entry => " << Z_OBJCE_P(zobject)->name << endl;
+		cout << "\tclass entry => " << o->ce_ptr->name << endl;
+		cout << "\t  ref count => " << zobject->refcount << endl;
+		cout << "\t     is_ref => " << (int) zobject->is_ref << endl;
+		cout << "\t       type => " << printType(Z_TYPE_P(zobject)) << endl;
+
+		if(Z_TYPE_P(zobject) == 5)
+		{
+		 cout <<"\t obj-handle => " << zobject->value.obj.handle << endl;
+		}
+
+		cout << endl;
+
+		cout << "\t      smokeobj => " << o << endl;
+		cout << "\t         Smoke => " << o->smoke << endl;
+		cout << "\t       classId => " << o->classId << endl;
+		cout << "\t        Qt ptr => " << o->ptr << endl;
+		cout << "\t        ce_ptr => " << o->ce_ptr << endl;
+		cout << "\t      zval_ptr => " << o->zval_ptr << endl;
+		cout << "\t  QMetaObject* => " << o->meta << endl;
+
+		cout << ")" << endl;
+	}
 }
 
 PHP_FUNCTION(check_qobject)
 {
 
     zval* zobject;
-    if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"o",&zobject)) {
+    if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z",&zobject)) {
         return;
     }
 
-    check_object(zobject);
+    check_qobject(zobject);
 }
+
+
+const char* printType(int type)
+{
+ switch(type){
+	case IS_NULL:	return "IS_NULL"; break; // 0
+	case IS_LONG:	return "IS_LONG"; break; // 1
+	case IS_DOUBLE: return "IS_DOUBLE"; break;	//2
+	case IS_BOOL: return "IS_BOOL"; break; //	3
+	case IS_ARRAY: return "IS_ARRAY"; break; // 4
+	case IS_OBJECT: return "IS_OBJECT"; break; //	5
+	case IS_STRING: return "IS_STRING"; break; // 6
+	case IS_RESOURCE: return "IS_RESOURCE"; break; // 7
+	case IS_CONSTANT: return "IS_CONSTANT"; break; // 8
+	case IS_CONSTANT_ARRAY: return "IS_CONSTANT_ARRAY"; break; //	9
+ }
+ return "unknown";
+}
+

Modified: trunk/php_qt/handlers.cpp
===================================================================
--- trunk/php_qt/handlers.cpp	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/php_qt/handlers.cpp	2007-05-20 21:13:23 UTC (rev 316)
@@ -31,46 +31,57 @@
 void*
 construct_copy(smokephp_object *o)
 {
-    const char *className = o->smoke->className(o->classId);
+	const char *className;
+	if(o->classId > 0)
+	{
+		className = o->smoke->className(o->classId);
+	} else {
+		// must be a qstring
+		return o->ptr;
+	}
+
     int classNameLen = strlen(className);
+
     char *ccSig = new char[classNameLen + 2];       // copy constructor signature
     strcpy(ccSig, className);
     strcat(ccSig, "#");
     Smoke::Index ccId = o->smoke->idMethodName(ccSig);
     delete[] ccSig;
-
     char *ccArg = new char[classNameLen + 8];
     sprintf(ccArg, "const %s&", className);
 
     Smoke::Index ccMeth = o->smoke->findMethod(o->classId, ccId);
 
     if(!ccMeth) {
-	delete[] ccArg;
-	return 0;
+		delete[] ccArg;
+		return 0;
     }
 
     Smoke::Index method = o->smoke->methodMaps[ccMeth].method;
-    if(method > 0) {
-	// Make sure it's a copy constructor
-	if(!matches_arg(o->smoke, method, 0, ccArg)) {
-            delete[] ccArg;
-	    return 0;
-        }
-        delete[] ccArg;
-        ccMeth = method;
+    if(method > 0)
+    {
+		// Make sure it's a copy constructor
+		if(!matches_arg(o->smoke, method, 0, ccArg)) {
+				delete[] ccArg;
+			return 0;
+		}
+		delete[] ccArg;
+		ccMeth = method;
     } else {
         // ambiguous method, pick the copy constructor
-	Smoke::Index i = -method;
-	while(o->smoke->ambiguousMethodList[i]) {
-	    if(matches_arg(o->smoke, o->smoke->ambiguousMethodList[i], 0, ccArg))
-		break;
-            i++;
+		Smoke::Index i = -method;
+		while(o->smoke->ambiguousMethodList[i]) {
+			if(matches_arg(o->smoke, o->smoke->ambiguousMethodList[i], 0, ccArg))
+			break;
+				i++;
+		}
+        delete[] ccArg;
+		ccMeth = o->smoke->ambiguousMethodList[i];
+		if(!ccMeth)
+		{
+			return 0;
+		}
 	}
-        delete[] ccArg;
-	ccMeth = o->smoke->ambiguousMethodList[i];
-	if(!ccMeth)
-	    return 0;
-    }
 
     // Okay, ccMeth is the copy constructor. Time to call it.
     Smoke::StackItem args[2];
@@ -226,7 +237,6 @@
 	if (KCODE == 0) {
 		init_codec();
 	}
-
 	zval* return_value = (zval*) emalloc(sizeof(zval));
 	if (qstrcmp(KCODE, "UTF8") == 0) {
 		ZVAL_STRING(return_value, (char*) s->toUtf8().constData(), /* duplicate */ 1);
@@ -278,14 +288,19 @@
 		case Marshall::ToZVAL:
 		{
 			QString* s = (QString*) m->item().s_voidp;
-			phpqt_createObject(m->retval(), (void*) s, qstring_ce);
+			zval* obj = m->var();
+// 			object_init_ex(obj, qstring_ce);
 
+			phpqt_createObject(obj, (void*) s, qstring_ce, -1);
+
 			if(s) {
 				if (s->isNull()) {
-					m->setRetval(Qnil);
+// 					m->setRetval(Qnil);
+					*(m->var()) = *Qnil;
 				}
 			} else {
-				m->setRetval(Qnil);
+// 				m->setRetval(Qnil);
+				*(m->var()) = *Qnil;
 			}
 		}
 		break;

Modified: trunk/php_qt/marshall.h
===================================================================
--- trunk/php_qt/marshall.h	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/php_qt/marshall.h	2007-05-20 21:13:23 UTC (rev 316)
@@ -41,15 +41,11 @@
      */
     virtual bool cleanup() = 0;
 
-    zval* retval() {return _retval;};
-    zval* setRetval(zval* retval) {_retval = retval;};
-
     virtual ~Marshall() {}
 
-protected:
-    zval* _retval;
+	const char* identifier;
 
-};    
+};
 
 class SmokeEnumWrapper {
 public:

Modified: trunk/php_qt/marshall_basetypes.h
===================================================================
--- trunk/php_qt/marshall_basetypes.h	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/php_qt/marshall_basetypes.h	2007-05-20 21:13:23 UTC (rev 316)
@@ -7,6 +7,10 @@
  *                                                                         *
  ***************************************************************************/
 
+#include "marshall_types.h"
+#include <QtCore/QHash>
+// extern QHash<zval*, smokephp_object*> zval_x_smokephp;
+
 template <class T> T* smoke_ptr(Marshall *m) { return (T*) m->item().s_voidp; }
 
 template<> bool* smoke_ptr<bool>(Marshall *m) { return &m->item().s_bool; }
@@ -28,14 +32,14 @@
 template <class T> 
 static void marshall_from_php(Marshall *m) 
 {
-	zval* obj = m->var();
-	(*smoke_ptr<T>(m)) = php_to_primitive<T>(obj);
+	zval* zobj = m->var();
+	(*smoke_ptr<T>(m)) = php_to_primitive<T>(zobj);
 }
 
 template <class T>
 static void marshall_to_php(Marshall *m)
 {
-	m->setRetval(primitive_to_php<T>( *smoke_ptr<T>(m) , m->retval()));
+	*(m->var()) = *primitive_to_php<T>( *smoke_ptr<T>(m) , m->var());
 }
 
 #include "marshall_primitives.h"
@@ -46,8 +50,8 @@
 template <> 
 static void marshall_from_php<char *>(Marshall *m) 
 {
-	zval* obj = m->var();
-	m->item().s_voidp = php_to_primitive<char*>(obj);
+	zval* zobj = m->var();
+	m->item().s_voidp = php_to_primitive<char*>(zobj);
 }
 
 template <>
@@ -69,6 +73,7 @@
 	long val = m->item().s_enum;
 }
 
+// m = MethodCall
 template <>
 static void marshall_from_php<SmokeClassWrapper>(Marshall *m)
 {
@@ -79,8 +84,10 @@
 		return;
 	}
 
-	if(!phpqt_SmokePHPObjectExists(v)) {
-		php_error(E_ERROR, "Invalid type, expecting %s, %s given\n", m->type().name(), zend_zval_type_name(v));
+	if(!/*phpqt_SmokePHPObjectExists*/(v)) {
+		check_qobject(v);
+// 		php_error(E_ERROR, "Invalid type, expecting %s, %s given\n", m->type().name(), zend_zval_type_name(v));
+		php_error(E_ERROR, "Invalid type, expecting %s, %s given (probably PHP-Qt lost the Qt object)\n", m->type().name(), Z_OBJCE_P(v)->name);
 		return;
 	}
 
@@ -120,96 +127,91 @@
 template <>
 static void marshall_to_php<SmokeClassWrapper>(Marshall *m)
 {
-
 	if(m->item().s_voidp == 0) {
-		m->setRetval(Qnil);
+		qWarning("Qt Object doesnt exist!");
+		*(m->var()) = *(Qnil);
 		return;
 	}
 	void *p = m->item().s_voidp;
 
-	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
-	zval* obj = m->var();
+	// return the original
+	if(phpqt_SmokePHPObjectExists(p)) {
+		if(((MethodReturnValue*) m)->retval_ptr()){
+			// destroys the return_value initialized by ZE, we creare our own:
+			zval_ptr_dtor(((MethodReturnValue*) m)->retval_ptr());
+			// prepare the return value
+			smokephp_object* o = phpqt_createOriginal(m->var(), p);
+			// overwrite the old one:
+			*(((MethodReturnValue*) m)->retval_ptr()) = o->zval_ptr;
+		}
+		return;
 
-	if(phpqt_SmokePHPObjectExists(p)) {
-	    smokephp_object* o = phpqt_getSmokePHPObjectFromQt(p);
-	    ZVAL_ZVAL(obj, o->zval_ptr,0,0);
-	    zend_rsrc_list_entry le;
-	    le.ptr = o;
-	    phpqt_register(obj, le);
-	// create a new object
+	//create a new PHP obnject (return_value):
 	} else {
-	    o->ptr = m->item().s_class;
-	    o->smoke = m->smoke();
+		void* __p = m->item().s_class;
+	    QObject* __qo = ((QObject*) __p);
+		char* __className = (char*) m->smoke()->classes[m->type().classId()].className; // name of the class
+		int __strLenClassName = strlen(m->smoke()->classes[m->type().classId()].className);
 
-	    if (Z_TYPE_P(m->var()) == IS_OBJECT) {
-		// do nothing
-	    } else if(!strcmp((char*) m->smoke()->classes[m->type().classId()].className, "QObject")){
-		// cast from, to
-		o->ptr = o->smoke->cast(o->ptr, m->smoke()->idClass("QObject"), m->type().classId());
-		object_init_ex(obj, 
-			    zend_fetch_class((char*)((QObject*) o->ptr)->metaObject()->className(),
-			    strlen(((QObject*) o->ptr)->metaObject()->className()), 
-			    ZEND_FETCH_CLASS_AUTO TSRMLS_DC));
+		zend_class_entry *_ce;
+	    if (Z_TYPE_P(m->var()) == IS_OBJECT)
+	    {
+	    	_ce = Z_OBJCE_P(m->var());
+		// object has to be casted
+	    } else if(!strcmp(__className, "QObject")) { // classname == QObject
+			// cast the Qt object: from, to
+			__p = m->smoke()->cast(__p, m->smoke()->idClass("QObject"), m->type().classId());
+			// cast the php one
+			_ce = zend_fetch_class((char*) __qo->metaObject()->className(), strlen(__qo->metaObject()->className()), ZEND_FETCH_CLASS_AUTO TSRMLS_DC);
+
 	    // fallback, already with correct type
 	    } else {
-		object_init_ex(obj, 
-		zend_fetch_class((char*) m->smoke()->classes[m->type().classId()].className,
-				strlen(m->smoke()->classes[m->type().classId()].className), 
-				ZEND_FETCH_CLASS_AUTO TSRMLS_DC));
+			_ce = zend_fetch_class(__className, __strLenClassName, ZEND_FETCH_CLASS_AUTO TSRMLS_DC);
 	    }
 
-	    Z_TYPE_P(m->var()) = IS_OBJECT;
-	    o->zval_ptr = obj;
-	    o->ce_ptr = Z_OBJCE_P(obj);
-	    o->parent_ce_ptr = o->ce_ptr;
-	    o->classId = m->type().classId();
+// #warning parent_ce in createObject
+		smokephp_object *o = phpqt_createObject(m->var(), __p, _ce, m->type().classId());
 
-	    if(!phpqt_SmokePHPObjectExists(o->ptr))
-		phpqt_setSmokePHPObject(o);
-
-	    zend_rsrc_list_entry le;
-	    le.ptr = o;
-	    phpqt_register(obj, le);
-
 //	    if(m->type().isConst() && m->type().isRef()) {
-	    if(m->type().isRef()) {
-		p = construct_copy( o );
+	    if(m->type().isRef()) 
+	    {
+			p = construct_copy( o );
 #ifdef DEBUG
 			const char * classname = o->ce_ptr->name;
 			php_error(E_WARNING, "copying %s %p to %p\n", classname, o->ptr, p);
 #endif
-
-		if(p) {
-			o->ptr = p;
-			o->allocated = true;
+			if(p) {
+				o->ptr = p;
+				o->allocated = true;
+			}
 		}
-	}
 
 #ifdef DEBUG
-		php_error(E_WARNING, "allocating %s %p -> %p\n", classname, o->ptr, (void*)obj);
+		php_error(E_WARNING, "allocating %s %p -> %p\n", __className, o->ptr, (void*)m->var());
 #endif
 
-	if(m->type().isStack()) {
-		o->allocated = true;
-	}
+		if(m->type().isStack()) {
+			o->allocated = true;
+		}
 
-	}
-}
+	} // smokephp_object p doesn't exist
+} // marshall_to_php
 
 template <>
 static void marshall_to_php<char *>(Marshall *m)
 {
 	char *sv = (char*)m->item().s_voidp;
-	zval* obj;
+	zval* zobj;
 	if(sv) {
-	    ZVAL_STRING(obj,sv,/*duplicate*/ 1);
+	    ZVAL_STRING(zobj,sv,/*duplicate*/ 1);
 	} else {
-	    obj = Qnil;
+	    zobj = Qnil;
 	}
 	if(m->cleanup())
 		delete[] sv;
 
-	m->setRetval(obj);
+	*(m->var()) = *zobj;
+// 	m->setRetval(zobj);
 }
 
 template <>

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/php_qt/marshall_types.cpp	2007-05-20 21:13:23 UTC (rev 316)
@@ -196,9 +196,14 @@
 	}
 }
 
+/**
+ *	MethodReturnValueBase
+ */
+
 MethodReturnValueBase::MethodReturnValueBase(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack) :
 	_smoke(smoke), _method(meth), _stack(stack)
-{ 
+{
+	identifier = "MethodReturnValueBase";
 	_st.set(_smoke, method().ret);
 }
 
@@ -210,8 +215,8 @@
 
 Smoke::StackItem&
 MethodReturnValueBase::item() 
-{ 
-	return _stack[0]; 
+{
+	return _stack[0];
 }
 
 Smoke *
@@ -247,19 +252,29 @@
 zval* 
 MethodReturnValueBase::var() 
 { 
-	return _retval; 
+	return _retval;
 }
 
+void
+MethodReturnValueBase::setVar(zval* zobj)
+{
+	_retval = zobj;
+}
+
 const char *
 MethodReturnValueBase::classname() 
 { 
 	return _smoke->className(method().classId); 
 }
 
+/**
+ *	VirtualMethodReturnValue
+ */
 
 VirtualMethodReturnValue::VirtualMethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval retval) :
 	MethodReturnValueBase(smoke,meth,stack), _retval2(retval) 
 {
+	identifier = "VirtualMethodReturnValue";
 	_retval = &_retval2;
 	Marshall::HandlerFn fn = getMarshallFn(type());
 	(*fn)(this);
@@ -271,11 +286,15 @@
 	return Marshall::FromZVAL; 
 }
 
-MethodReturnValue::MethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* retval) :
-	MethodReturnValueBase(smoke,meth,stack) 
+/**
+ *	MethodReturnValue
+ */
+
+MethodReturnValue::MethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* retval, zval** return_value_ptr) :
+	MethodReturnValueBase(smoke,meth,stack), _return_value_ptr(return_value_ptr)
 {
+	identifier = "MethodReturnValue";
 	_retval = retval;
-
 	Marshall::HandlerFn fn = getMarshallFn(type());
 	(*fn)(this);
 }
@@ -292,7 +311,13 @@
 	return qstrcmp(MethodReturnValueBase::classname(), "QGlobalSpace") == 0 ? "" : MethodReturnValueBase::classname(); 
 }
 
+zval**
+MethodReturnValue::retval_ptr(){ return _return_value_ptr; }
 
+/**
+ *	MethodCallBase
+ */
+
 MethodCallBase::MethodCallBase(Smoke *smoke, Smoke::Index meth) :
 	_smoke(smoke), _method(meth), _cur(-1), _called(false), _sp(0)  
 {  
@@ -357,10 +382,14 @@
 	return _smoke->className(method().classId); 
 }
 
+/**
+ *	VirtualMethodCall
+ */
 
 VirtualMethodCall::VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* obj, zval ***sp) :
 	MethodCallBase(smoke,meth,stack), _obj(obj), _sp(sp)
 {
+	identifier = "VirtualMethodCall";
 	_sp = sp;
 	_args = _smoke->argumentList + method().args;
 }
@@ -409,24 +438,31 @@
 	return false; 
 }
 
-MethodCall::MethodCall(Smoke *smoke, Smoke::Index method, zval* target, zval ***sp, int items, zval *retval) :
-	MethodCallBase(smoke,method), _target(target), _current_object(0), _sp(sp), _items(items)
+/**
+ *	MethodCall
+ */
+
+MethodCall::MethodCall(Smoke *smoke, Smoke::Index method, zval* target, zval ***sp, int items, zval *retval, zval** return_value_ptr) :
+	MethodCallBase(smoke,method), _target(target), _current_object(0), _sp(sp), _items(items), _retval(retval), _return_value_ptr(return_value_ptr)
 {
-
-    if(target != NULL) {
-	if (phpqt_SmokePHPObjectExists(_target)) {
-		smokephp_object *o = phpqt_getSmokePHPObjectFromZval(_target);
-		if (o && o->ptr) {
-			_current_object = o->ptr;
-			_current_object_class = o->classId;
+	identifier = "MethodCall";
+    if(target != NULL)
+    {
+		if (phpqt_SmokePHPObjectExists(_target))
+		{
+			smokephp_object *o = phpqt_getSmokePHPObjectFromZval(_target);
+			if (o && o->ptr)
+			{
+				_current_object = o->ptr;
+				_current_object_class = o->classId;
+			}
 		}
-	}
-    } else {_target = new zval;}
+	} else {_target = (zval*) emalloc(sizeof(zval));}
 
     _args = _smoke->argumentList + _smoke->methods[_method].args;
     _items = _smoke->methods[_method].numArgs;
     _stack = new Smoke::StackItem[items + 1];
-    _retval = retval;
+// 	_retval = retval;
 }
 
 MethodCall::~MethodCall() 
@@ -465,10 +501,13 @@
 	return qstrcmp(MethodCallBase::classname(), "QGlobalSpace") == 0 ? "" : MethodCallBase::classname(); 
 }
 
-SigSlotBase::SigSlotBase(int items, MocArgument* mocStack, zval*** sp) : _cur(-1), _called(false), _sp(sp)
+/**
+ *	SigSlotBase
+ */
+
+SigSlotBase::SigSlotBase(zval*** sp) : _cur(-1), _called(false), _sp(sp)
 { 
-	_items = items + 1;
-	_args = mocStack;
+	identifier = "SigSlotBase";
 	_stack = new Smoke::StackItem[_items -1];
 }
 
@@ -528,10 +567,13 @@
 	_cur = oldcur;
 }
 
-/*
-	Converts a zval* returned by a slot invocation to a Qt slot 
-	reply type
-*/
+/**
+ *	SlotReturnValue
+ *
+ *	Converts a zval* returned by a slot invocation to a Qt slot 
+ *	reply type
+ */
+
 class SlotReturnValue : public Marshall {
     MocArgument *	_replyType;
     Smoke::Stack _stack;
@@ -579,16 +621,23 @@
 	}
 };
 
-/*InvokeSlot::InvokeSlot(zval* obj, int slotname, zval*** args, void ** o) : SigSlotBase(args),
+/**
+ *	InvokeSlot
+ *	TODO
+ */
+
+InvokeSlot::InvokeSlot(zval* obj, int slotname, zval*** args, void ** o) : SigSlotBase(args),
     _obj(obj), _slotname(slotname), _o(o)
 {
-	_sp = (zval *) safe_emalloc((zval*), _items - 1, 0);
+	identifier = "InvokeSlot";
+	_sp = (zval ***) safe_emalloc(sizeof(zval), _items - 1, 0);
+	_sp = args;
 	copyArguments();
 }
 
 InvokeSlot::~InvokeSlot() 
 { 
-	xfree(_sp);	
+	free(_sp);	
 }
 
 Marshall::Action 
@@ -620,8 +669,9 @@
 {
 	if (_called) return;
 	_called = true;
+	zval* result = phpqt_callPHPMethod(_obj, (char*) PQ::smoke()->methodNames[PQ::smoke()->methods[_slotname].name], _items - 1, _sp);
 	if (_args[0].argType != xmoc_void) {
-		SlotReturnValue r(_o, &result, _args);
+		SlotReturnValue r(_o, result, _args);
 	}
 }
 
@@ -630,11 +680,17 @@
 { 
 	invokeSlot(); 
 }
-*/
 
-EmitSignal::EmitSignal(QObject *obj, int id, int items, MocArgument *mocStack, zval ***sp, zval * result) : SigSlotBase(items, mocStack, _sp),
+/**
+ *	EmitSignal
+ */
+
+EmitSignal::EmitSignal(QObject *obj, int id, int items, MocArgument *mocStack, zval ***sp, zval * result) :
     _obj(obj), _id(id)
-{ 
+{
+	identifier = "EmitSignal";
+	_items = items + 1;
+	_args = mocStack;
 	_id = id;
 	_sp = sp;
 	_result = result;
@@ -688,3 +744,48 @@
 	return true; 
 }
 
+SmokeType 
+EmitSignal::type() 
+{ 
+	return arg().st; 
+}
+
+zval* 
+EmitSignal::var() 
+{ 
+	return (zval*) *_sp[_cur]; 
+}
+
+Smoke *
+EmitSignal::smoke() 
+{ 
+	return type().smoke(); 
+}
+
+void 
+EmitSignal::unsupported() 
+{
+	php_error(E_ERROR, "Cannot handle '%s' as %s argument\n", type().name(), mytype() );
+}
+
+const MocArgument &
+EmitSignal::arg() 
+{ 
+	return _args[_cur + 1]; 
+}
+
+void
+EmitSignal::next() 
+{
+	int oldcur = _cur;
+	_cur++;
+
+	while(!_called && _cur < _items - 1) {
+		Marshall::HandlerFn fn = getMarshallFn(type());
+		(*fn)(this);
+		_cur++;
+	}
+	mainfunction();
+	_cur = oldcur;
+}
+

Modified: trunk/php_qt/marshall_types.h
===================================================================
--- trunk/php_qt/marshall_types.h	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/php_qt/marshall_types.h	2007-05-20 21:13:23 UTC (rev 316)
@@ -34,6 +34,10 @@
 extern void smokeStackToQtStack(Smoke::Stack stack, void ** o, int items, MocArgument* args);
 extern void smokeStackFromQtStack(Smoke::Stack stack, void ** _o, int items, MocArgument* args);
 
+/**
+ *	MethodReturnValueBase
+ */
+
 class MethodReturnValueBase : public Marshall 
 {
 public:
@@ -46,16 +50,21 @@
 	bool cleanup();
 	void unsupported();
 	zval* var();
+	void setVar(zval* zobj);
 
 protected:
 	Smoke *_smoke;
 	Smoke::Index _method;
 	Smoke::Stack _stack;
 	SmokeType _st;
+	zval* _retval;
 
 	virtual const char *classname();
 };
 
+/**
+ *	VirtualMethodReturnValue
+ */
 
 class VirtualMethodReturnValue : public MethodReturnValueBase {
 public:
@@ -66,16 +75,25 @@
 	zval _retval2;
 };
 
+/**
+ *	MethodReturnValue
+ */
 
 class MethodReturnValue : public MethodReturnValueBase {
 public:
-	MethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval *retval);
+	MethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval *retval, zval** return_value_ptr);
     Marshall::Action action();
+	zval** retval_ptr();
 
 private:
+	zval **_return_value_ptr;
 	const char *classname();
 };
 
+/**
+ *	MethodCallBase
+ */
+
 class MethodCallBase : public Marshall
 {
 public:
@@ -101,6 +119,9 @@
 	virtual const char* classname();
 };
 
+/**
+ *	VirtualMethodCall
+ */
 
 class VirtualMethodCall : public MethodCallBase {
 public:
@@ -117,10 +138,13 @@
 	zval ***_sp;
 };
 
+/**
+ *	MethodCall
+ */
 
 class MethodCall : public MethodCallBase {
 public:
-	MethodCall(Smoke *smoke, Smoke::Index method, zval* target, zval ***sp, int items, zval *retval);
+	MethodCall(Smoke *smoke, Smoke::Index method, zval* target, zval ***sp, int items, zval *retval, zval** return_value_ptr);
 	~MethodCall();
 	Marshall::Action action();
 	zval* var();
@@ -130,7 +154,7 @@
 
 		QString className(_smoke->className(method().classId));
 
-		if (	! className.endsWith(_smoke->methodNames[method().name])
+		if (! className.endsWith(_smoke->methodNames[method().name])
 			&& Z_TYPE_P(_target) == IS_NULL
 			&& !(method().flags & Smoke::mf_static) ) 
 		{
@@ -146,25 +170,31 @@
 		void *ptr = _smoke->cast(_current_object, _current_object_class, method().classId);
 		_items = -1;
 		(*fn)(method().method, ptr, _stack);
-		MethodReturnValue r(_smoke, _method, _stack, _retval);
+		MethodReturnValue r(_smoke, _method, _stack, _retval, _return_value_ptr);
 	}
 
 	int items();
 	bool cleanup();
+
 private:
 	zval* _target;
 	void *_current_object;
 	Smoke::Index _current_object_class;
 	zval ***_sp;
 	int _items;
+	zval *_retval;
+	zval **_return_value_ptr;
 
 	const char *classname();
 };
 
+/**
+ *	SigSlotBase
+ */
 
 class SigSlotBase : public Marshall {
 public:
-	SigSlotBase(int items, MocArgument* mocStack, zval*** sp);
+	SigSlotBase(zval*** sp);
 	~SigSlotBase();
 	const MocArgument &arg();
 	SmokeType type();
@@ -186,7 +216,8 @@
 };
 
 
-class EmitSignal : public SigSlotBase {
+
+class EmitSignal : public Marshall {
     QObject *_obj;
     int _id;
 	zval * _result;
@@ -198,6 +229,19 @@
 	void emitSignal();
 	void mainfunction();
 	bool cleanup();
+	void next(); 
+	SmokeType type();
+	zval* var();
+	void unsupported();
+	Smoke* smoke();
+	const MocArgument &arg();
+ protected:
+	MocArgument *_args;
+	int _cur;
+	bool _called;
+	Smoke::Stack _stack;
+	int _items;
+	zval ***_sp;
 };
 
 class InvokeNativeSlot : public SigSlotBase {
@@ -215,7 +259,7 @@
 };
 
 class InvokeSlot : public SigSlotBase {
-    zval _obj;
+    zval* _obj;
     int _slotname;
     void **_o;
 public:
@@ -230,10 +274,12 @@
 };
 
 
-/*
-	Converts a C++ value returned by a signal invocation to a PHP 
-	reply type
-*/
+/**
+ *	SignalReturnValue
+ *
+ *	Converts a C++ value returned by a signal invocation to a PHP 
+ *	reply type
+ */
 class SignalReturnValue : public Marshall {
     MocArgument *	_replyType;
     Smoke::Stack _stack;

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/php_qt/php_qt.cpp	2007-05-20 21:13:23 UTC (rev 316)
@@ -25,13 +25,14 @@
 #include "ext/standard/php_string.h"
 
 #include <QtCore/qglobal.h>
+
 #include "marshall.h"
 #include "php_qt.h"
 #include "smokephp.h"
 #include "smoke.h"
 #include "marshall_types.h"
 
-#define DEBUG 0
+#define DEBUG 1
 #define MOC_DEBUG 0
 
 extern void init_qt_Smoke();
@@ -70,7 +71,7 @@
 	PHP_FE(SIGNAL,	NULL)
 	PHP_FE(SLOT,	NULL)	
 	PHP_FE(emit,	NULL)	
-	PHP_FE(qobject_cast,	NULL)
+	PHP_FE(qobject_cast,	phpqt_cast_arginfo)
 	PHP_FE(tr,	NULL)
 	PHP_FE(check_qobject,	NULL)
 	{NULL, NULL, NULL}	/* Must be the last line in php_qt_functions[] */
@@ -100,6 +101,7 @@
 #endif
 
 QHash<void*, smokephp_object*> SmokeQtObjects;
+QHash<zend_object_handle, smokephp_object*> obj_x_smokephp;
 QStack<QByteArray*> methodNameStack;
 
 // cached
@@ -166,13 +168,12 @@
 
 }
 
-
 /**
  *	proxy handler
  */
 
-union _zend_function *proxyHandler(zval **obj_ptr, char* methodName, int methodName_len TSRMLS_DC){
-
+union _zend_function *proxyHandler(zval **obj_ptr, char* methodName, int methodName_len TSRMLS_DC)
+{
     union _zend_function *fbc;
 
     // overwritten protected Qt methods wont work until we cheat here
@@ -181,18 +182,21 @@
     zend_str_tolower_copy(lc_method_name, methodName, method_len);
     // get the zend object and the function pointer
     zend_object *zobj = zend_objects_get_address(*obj_ptr TSRMLS_CC);
-    if (zend_hash_find(&zobj->ce->function_table, lc_method_name, method_len+1, (void **)&fbc) != FAILURE) {
-	if(fbc->common.fn_flags & ZEND_ACC_PROTECTED){
-	    if(PQ::smoke()->idMethodName(methodName) > 0){
-		fbc->common.fn_flags = ZEND_ACC_PUBLIC;
-	    }
-	}
+    if (zend_hash_find(&zobj->ce->function_table, lc_method_name, method_len+1, (void **)&fbc) != FAILURE)
+    {
+		if(fbc->common.fn_flags & ZEND_ACC_PROTECTED)
+		{
+			if(PQ::smoke()->idMethodName(methodName) > 0)
+			{
+				fbc->common.fn_flags = ZEND_ACC_PUBLIC;
+			}
+		}
     }
 
     // a try for non-Qt objects
     fbc = zend_orig_handler.get_method(obj_ptr, methodName, methodName_len);
-
-    if(!fbc) {    // maybe a Qt object
+    if(!fbc) // maybe a Qt object
+    {
         methodNameStack.push(new QByteArray(methodName));
 	    // call proxy
 	    fbc = zend_orig_handler.get_method(obj_ptr, "proxyMethod", 11);
@@ -233,16 +237,26 @@
 
 ZEND_METHOD(php_qt_generic_class, __destruct)
 {
-    if(phpqt_SmokePHPObjectExists(getThis())) {
-	smokephp_object *o = phpqt_getSmokePHPObjectFromZval(getThis());
-	SmokeQtObjects.remove(o->ptr);
+qDebug() << "__destruct" << getThis() << PZVAL_IS_REF(getThis());
+	if(phpqt_SmokePHPObjectExists(getThis())) {
 
-	efree(o->zval_ptr);
-//	((QObject*) o->ptr)->~QObject();
-//	delete o->ptr;	// segfault
-	efree(o);
-    }
-	RETVAL_NULL();
+ 		smokephp_object *o = phpqt_getSmokePHPObjectFromZval(getThis());
+
+// qDebug() << (o->zval_ptr == getThis());
+// qDebug() << "__destruct" << (o->zval_ptr == getThis()) << getThis() << o->zval_ptr;
+		// its not a reference
+// 		if(getThis() == o->zval_ptr)
+		if(!PZVAL_IS_REF(getThis()))
+		{
+			o->allocated = false;
+		}
+		if(!phpqt_unmapSmokePHPObject(getThis()))
+		{
+			qFatal("try to unmap unregistered zval");
+		}
+
+//check_qobject(getThis());
+	}
 }
 
 ZEND_METHOD(php_qt_generic_class, __construct)
@@ -258,19 +272,21 @@
 
     // get arguments
     int i, argc = ZEND_NUM_ARGS();
-    zval ***args = (zval ***) safe_emalloc(argc, sizeof(zval **), 0);    
-    if(zend_get_parameters_array_ex(argc, args) == FAILURE){
-	    efree(args);
-	    WRONG_PARAM_COUNT;
+    zval ***args = (zval ***) safe_emalloc(argc, sizeof(zval **), 0);
+    if(zend_get_parameters_array_ex(argc, args) == FAILURE)
+    {
+	    efree(args);   WRONG_PARAM_COUNT;
     }
 
     methodNameStack.push(new QByteArray(ce->name));
     smokephp_prepareMethodName(args, argc, methodNameStack);	// #, $, ?
     Smoke::Index method = smokephp_getMethod(ce->name, methodNameStack.top()->constData(), ZEND_NUM_ARGS(), args);
-    MethodCall c(PQ::smoke(), method, getThis(), args, argc-1, getThis());
+
+	MethodCall c(PQ::smoke(), method, getThis(), args, argc-1, getThis(), return_value_ptr);
     c.next();
 
-    smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
+	// smokephp_object is created above in c.next()
+     smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
     o->parent_ce_ptr = ce_parent; // = ce if no parent
 
 	// if QObject
@@ -383,12 +399,13 @@
 	    }
 
 	    php_error(E_ERROR,"Call to undefined method %s::%s()", ce->name, methodNameStack.top()->constData());
+		
 	}
 	else 
 	    php_error(E_ERROR,"Call to undefined method!");
     }
 
-    MethodCall c(PQ::smoke(), method, getThis(), args, argc-1, return_value);
+    MethodCall c(PQ::smoke(), method, getThis(), args, argc-1, return_value, return_value_ptr);
     c.next();
 
     // cleanup
@@ -396,7 +413,7 @@
     methodNameStack.pop();
 
     return;
-}
+} // proxyMethod
 
 /*! 
  *	PHP_MINIT_FUNCTION
@@ -404,11 +421,10 @@
 
 PHP_MINIT_FUNCTION(php_qt)
 {
-
 	REGISTER_INI_ENTRIES();
 	init_codec();
 
-        install_handlers(Qt_handlers);
+	install_handlers(Qt_handlers);
 
 	// object list
 	le_php_qt_hashtype = zend_register_list_destructors_ex(phpqt_destroyHashtable, NULL, "PHP-Qt object list", module_number);
@@ -423,7 +439,7 @@
 	memcpy(phpqt_opcode_handlers, zend_opcode_handlers, sizeof(phpqt_opcode_handlers));
 	phpqt_original_opcode_handlers = zend_opcode_handlers;
 	zend_opcode_handlers = phpqt_opcode_handlers;
-	phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + 0] = constantHandler; 
+	phpqt_opcode_handlers[(ZEND_FETCH_CONSTANT*25) + 0] = constantHandler;
 
 	smokephp_init();
 
@@ -457,33 +473,39 @@
         zend_function_entry* t = (zend_function_entry*) safe_emalloc((method_count+7), sizeof(zend_function_entry), 0);
         zend_function_entry* p = t;
 
-        PHP_QT_ME(php_qt_generic_class,__construct,NULL,ZEND_ACC_PUBLIC);
+        PHP_QT_ME(php_qt_generic_class,__construct,phpqt_cast_arginfo,ZEND_ACC_PUBLIC);
         PHP_QT_ME(php_qt_generic_class,__destruct,NULL,ZEND_ACC_PUBLIC);
         PHP_QT_ME(php_qt_generic_class,__toString,NULL,ZEND_ACC_PUBLIC);
-	PHP_QT_ME(php_qt_generic_class,emit,NULL,ZEND_ACC_PUBLIC);
-        PHP_QT_ME(php_qt_generic_class,proxyMethod,NULL,ZEND_ACC_PUBLIC);
+		PHP_QT_ME(php_qt_generic_class,emit,NULL,ZEND_ACC_PUBLIC);
+        PHP_QT_ME(php_qt_generic_class,proxyMethod,phpqt_cast_arginfo,ZEND_ACC_PUBLIC);
 
-	QHash<const char*, bool> tmpMethodList;	// avoids doubled method names
+		QHash<const char*, bool> tmpMethodList;	// avoids doubled method names
 
-        for(int j=0;j<PQ::smoke()->numMethods;j++){
-            if(PQ::smoke()->methods[j].classId == i){
-                if(!(PQ::smoke()->methods[j].flags & Smoke::mf_enum)){
-                    if(PQ::smoke()->methods[j].flags & Smoke::mf_static){
+        for(int j=0;j<PQ::smoke()->numMethods;j++)
+	{
+            if(PQ::smoke()->methods[j].classId == i)
+	    {
+                if(!(PQ::smoke()->methods[j].flags & Smoke::mf_enum))
+		{
+                    if(PQ::smoke()->methods[j].flags & Smoke::mf_static)
+		    {
                         // avoids overloaded methods, fast
-                        if(strcmp(PQ::smoke()->methodNames[PQ::smoke()->methods[j-1].name],PQ::smoke()->methodNames[PQ::smoke()->methods[j].name])){
-                        	if(!tmpMethodList.contains(PQ::smoke()->methodNames[PQ::smoke()->methods[j].name])){ // method already defined in this class?
+                        if(strcmp(PQ::smoke()->methodNames[PQ::smoke()->methods[j-1].name],PQ::smoke()->methodNames[PQ::smoke()->methods[j].name]))
+			{
+                        	if(!tmpMethodList.contains(PQ::smoke()->methodNames[PQ::smoke()->methods[j].name])) // method already defined in this class?
+				{ 
 								tmpMethodList[PQ::smoke()->methodNames[PQ::smoke()->methods[j].name]] = true;
 								t->fname = (char*) emalloc(strlen(PQ::smoke()->methodNames[PQ::smoke()->methods[j].name])+1);
 								t->fname = (char*) PQ::smoke()->methodNames[PQ::smoke()->methods[j].name];
 								t->handler = ZEND_MN(php_qt_generic_class_proxyMethod);
-								t->arg_info = NULL;
+								t->arg_info = phpqt_cast_arginfo;
 								t->flags = ZEND_ACC_PUBLIC|ZEND_ACC_STATIC;
 								t++;
                         	}
                         }
                     }
                 }
-			}
+	   }
         }
 
         // stops the zend-loop 'while(ptr->fname) {...}' in zend_register_functions
@@ -517,8 +539,6 @@
 	    }
 	}
 
-    tmpCeTable.~QHash();
-
     return SUCCESS;
 } // PHP_MINIT
 
@@ -563,8 +583,8 @@
  */
 
 int	
-phpqt_metacall(smokephp_object* so, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a){
-
+phpqt_metacall(smokephp_object* so, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a)
+{
 	QMetaObject* d = so->meta;
 //	int offset = d->methodOffset();
 	int offset = d->methodCount();
@@ -577,7 +597,7 @@
 	if(_id < offset){
 		// find parent
 		Smoke::Index parent = so->smoke->inheritanceList[so->smoke->classes[so->classId].parents];
-		
+
 		// methodId
 		Smoke::Index nameId = so->smoke->idMethodName("qt_metacall$$?");
 		Smoke::Index method = so->smoke->findMethod(so->classId, nameId);
@@ -613,7 +633,6 @@
 	// eg _q_buttonPressed(), breaking at the first bracket
 	char* method_name = estrdup((d->method(_id)).signature());
 
-
     for(int i = 0; i < strlen(method_name); i++){
 #define LEFT_PARENTHESIS 40
         if(method_name[i] == LEFT_PARENTHESIS){
@@ -644,12 +663,9 @@
                 ZVAL_DOUBLE(arg, *reinterpret_cast< double*>(_a[i+1]));
             } else {
                     // must be an object
-                    zend_class_entry *ce;
-                    object_init_ex(arg, qobject_ce);
-                    zend_rsrc_list_entry le;
-                    le.ptr = *reinterpret_cast< QObject**>(_a[1]);
-                    phpqt_register(arg, le);
+                    void* ptr = *reinterpret_cast< QObject**>(_a[1]);
 
+                    phpqt_createObject(arg, ptr, qobject_ce);
             }
 
             args[j++] = &arg;
@@ -673,30 +689,6 @@
 	
 }
 
-void 
-phpqt_register(zval* this_ptr, zend_rsrc_list_entry le){
-
-    assert(&php_qt_objptr_hash);
-    assert(le_php_qt_hashtype);
-
-	Z_OBJ_HT_P(this_ptr) = &php_qt_handler;
-	zval *listhandle;
-	MAKE_STD_ZVAL(listhandle);
-	Z_TYPE_P(listhandle) = IS_LONG;
-	Z_LVAL_P(listhandle) = zend_list_insert(le.ptr, le_php_qt_hashtype);
-
-	if(zend_hash_index_update(Z_OBJPROP_P(this_ptr), 0, &listhandle, sizeof(zval*), NULL) == FAILURE){
-		php_error(E_ERROR,"could not bind resource to object.");
-	}
-	zval_add_ref(&this_ptr);
-
-	if(zend_hash_index_update(&php_qt_objptr_hash, (long) le.ptr, (void*) &this_ptr, sizeof(zval *), NULL) == FAILURE){
-		php_error(E_ERROR,"could not register Qt object in resource table.");
-	}
-
-}
-
-
 static void 
 phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc TSRMLS_DC)
 {
@@ -740,7 +732,8 @@
     MAKE_STD_ZVAL(retval);
 
     if(call_user_function(EG(function_table),&this_ptr,function_name,retval,param_count,*args) == FAILURE){
-    	php_error(E_ERROR, "PHP-Qt could not call method %s", methodName);
+    	smokephp_object* o = phpqt_getSmokePHPObjectFromZval(this_ptr);
+    	php_error(E_ERROR, "PHP-Qt could not call method %s::%s", o->ce_ptr->name, methodName);
     }
 
     return retval;
@@ -880,50 +873,22 @@
 }
 
 bool
-phpqt_SmokePHPObjectExists(zval* this_ptr){
-
-	if(this_ptr == NULL){
-	  php_error(E_ERROR,"fatal: object does not exists and could not be fetched, %s",Z_OBJCE_P(this_ptr)->name);
-	}
-
-	smokephp_object *ptr;
-	zval **listhandle;
-	int type;
-	TSRMLS_FETCH();
-
-	if(zend_hash_index_find(Z_OBJPROP_P(this_ptr), 0, (void**) &listhandle) == FAILURE){
-	    return false;
-	}
-
-	return true;
+phpqt_SmokePHPObjectExists(zval* this_ptr)
+{
+	return obj_x_smokephp.contains(this_ptr->value.obj.handle);
 }
 
 smokephp_object* 
-phpqt_getSmokePHPObjectFromZval(zval* this_ptr){
+phpqt_getSmokePHPObjectFromZval(zval* this_ptr)
+{
 
 	if(this_ptr == NULL){
 	  php_error(E_ERROR,"fatal: object does not exists and could not be fetched, %s",Z_OBJCE_P(this_ptr)->name);
 	}
 
-	smokephp_object *ptr;
-	zval **listhandle;
-	int type;
-	TSRMLS_FETCH();
+	// value.obj.handle
+ 	return (smokephp_object*) obj_x_smokephp.value(this_ptr->value.obj.handle);
 
-	if(zend_hash_index_find(Z_OBJPROP_P(this_ptr), 0, (void**) &listhandle) == FAILURE){
-	  php_error(E_ERROR,"underlying Qt-Object missing. Make sure that the constructor of the parent is called, instance of type '%s' fails",Z_OBJCE_P(this_ptr)->name,Z_OBJCE_P(this_ptr)->name);
-	}
-	ptr = (smokephp_object*) zend_list_find(Z_LVAL_PP(listhandle), &type);
-
-	if(!ptr){
-		php_error(E_ERROR,"reference to Qt object missing, %s",Z_OBJCE_P(this_ptr)->name);
-	} 
-	if(type != le_php_qt_hashtype){
-		php_error(E_ERROR,"phpqt_getSmokePHPObjectFromZval(): wrong type, %s",Z_OBJCE_P(this_ptr)->name);
-	}
-
-	return ptr;
-
 }
 
 void*
@@ -947,28 +912,67 @@
 	return (SmokeQtObjects.find(ptr) != SmokeQtObjects.end());
 }
 
-void
+bool
+phpqt_unmapSmokePHPObject(zval* o)
+{
+	return (bool) obj_x_smokephp.remove(o->value.obj.handle);
+}
+
+/**
+ *	marshall_basetypes.h marshall_to_php<SmokeClassWrapper>(Marshall *m)
+ */
+
+smokephp_object*
 phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce, Smoke::Index classId){
 
-	if(!ce) {
-	    ce = Z_OBJCE_P(zval_ptr);
-	    // classID here
+	Q_ASSERT (zval_ptr);
+	Q_ASSERT (ptr);
+
+ 	if(!ce) {
+ 		qFatal("no class entry!");
+ 	}
+
+	if(classId == QSTRING_CLASSID)
+	{
+		ce = qstring_ce;
+	} else if (classId == 0)
+	{
+		qDebug("\nno class id");
+		check_qobject(zval_ptr);
+		qFatal("php object creation failed");
 	}
 
 	Z_TYPE_P(zval_ptr) = IS_OBJECT;
+	object_init_ex(zval_ptr, ce);
 
 	smokephp_object* o = (smokephp_object*) emalloc(sizeof(smokephp_object));
+	o->allocated = true;
 	o->ptr = ptr;
 	o->zval_ptr = zval_ptr;
 	o->ce_ptr = ce;
 	o->parent_ce_ptr = ce;
-	o->classId = classId;
+ 	o->classId = classId;
 	o->smoke = PQ::smoke();
+
+	Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
 	phpqt_setSmokePHPObject(o);
-	// register all 
-	zend_rsrc_list_entry le;
-	le.ptr = o;
-	object_init_ex(zval_ptr, ce);
-	phpqt_register(o->zval_ptr,le);
+	zval_add_ref(&zval_ptr);
 
+	obj_x_smokephp.insert(zval_ptr->value.obj.handle, o);
+
+	return o;
+
 }
+
+smokephp_object*
+phpqt_createOriginal(zval* zval_ptr, void* ptr)
+{
+	smokephp_object* o = phpqt_getSmokePHPObjectFromQt(ptr);
+/* 		ZVAL_ZVAL(zval_ptr, o->zval_ptr, 1, 0);
+// 		zval_ptr->is_ref = 1;
+		Z_OBJ_HT_P(zval_ptr) = &php_qt_handler;
+		zval_x_smokephp.insert(zval_ptr, o);*/
+	zval_ptr = o->zval_ptr;
+	zval_add_ref(&zval_ptr);
+	return o;
+}

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/php_qt/php_qt.h	2007-05-20 21:13:23 UTC (rev 316)
@@ -29,6 +29,7 @@
 
 #define COMPILE_DL_PHP_QT
 #define PHPQT_CLASS_COUNT 256
+#define QSTRING_CLASSID -1
 
 #include <iostream>
 using namespace std;
@@ -52,6 +53,7 @@
 #include <QtGui/QLayout>
 #include <QtGui/QLCDNumber>
 #include <QtGui/QFont>
+#include <QtCore/QDebug>
 
 // for older php versions
 #ifndef ZEND_MN
@@ -74,6 +76,12 @@
 
 #define PHP_QT_ME(classname, name, arg_info, flags)	PHP_QT_FENTRY(name, ZEND_MN(classname##_##name), arg_info, flags)
 
+// this is needed for override return_value, see qobject_cast
+#if(PHP_MAJOR_VERSION > 5) || (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION > 0)
+static
+	ZEND_BEGIN_ARG_INFO_EX(phpqt_cast_arginfo, 0, 1, 0)
+	ZEND_END_ARG_INFO();
+#endif
 
 PHP_MINIT_FUNCTION(php_qt);
 PHP_MSHUTDOWN_FUNCTION(php_qt);
@@ -90,7 +98,7 @@
 PHP_FUNCTION(qobject_cast);
 PHP_FUNCTION(tr);
 PHP_FUNCTION(check_qobject);
-void check_object(zval* zobject);
+void check_qobject(zval* zobject);
 
 void init_codec();
 zval* zstringFromQString(QString * s);
@@ -109,21 +117,27 @@
 
 static void 			phpqt_destroyHashtable(zend_rsrc_list_entry *rsrc);
 
-void 				phpqt_register(zval* this_ptr, zend_rsrc_list_entry le);
+// void 				phpqt_register(zval* this_ptr, zend_rsrc_list_entry le);
 zval* 				phpqt_callPHPMethod(zval* zend_ptr, char* methodname, zend_uint param_count, zval** params[]);
 bool 				phpqt_methodExists(zend_class_entry* ce_ptr, char* methodname);
 bool 				phpqt_getMocData(zval* this_ptr, char* classname, const QMetaObject* superdata, QMetaObject* metachar, QString* meta_stringdata, uint* signature);
-int				phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
+int					phpqt_metacall(smokephp_object* this_ptr, Smoke::StackItem* args, QMetaObject::Call _c, int _id, void **_a);
 char*				phpqt_checkForOperator(const char* fname);
 
 void* 				phpqt_getQtObjectFromZval(zval* this_ptr);
-smokephp_object* 		phpqt_getSmokePHPObjectFromZval(zval* this_ptr);
-smokephp_object*		phpqt_getSmokePHPObjectFromQt(void* QtPtr);
+smokephp_object* 	phpqt_getSmokePHPObjectFromZval(zval* this_ptr);
+smokephp_object*	phpqt_getSmokePHPObjectFromQt(void* QtPtr);
 void				phpqt_setSmokePHPObject(smokephp_object* o);
 bool 				phpqt_SmokePHPObjectExists(zval* this_ptr);
 bool				phpqt_SmokePHPObjectExists(void* ptr);
-void				phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL, Smoke::Index classId = 0);
 
+bool				phpqt_unmapSmokePHPObject(zval* o);
+
+smokephp_object*	phpqt_createObject(zval* zval_ptr, void* ptr, zend_class_entry* ce = NULL, Smoke::Index classId = 0);
+smokephp_object*	phpqt_createOriginal(zval* zval_ptr, void* ptr);
+
+const char* 		printType(int type);
+
 extern Smoke* qt_Smoke;
 class PQ
 {

Modified: trunk/php_qt/qstring.cpp
===================================================================
--- trunk/php_qt/qstring.cpp	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/php_qt/qstring.cpp	2007-05-20 21:13:23 UTC (rev 316)
@@ -26,8 +26,8 @@
 
 #include <iostream>
 using namespace std;
+#include <QtCore/QDebug>
 
-
 #include <QtCore/QString>
 #include <zend_interfaces.h>
 #include "php_qt.h"
@@ -128,14 +128,17 @@
 
 }
 
+/*
+ *	@return ZVAL_LONG
+ */
+
 ZEND_METHOD(QString,__toString){
 
   QString *QString_ptr = (QString *) PHP_QT_FETCH();
+  zval* zstring = zstringFromQString(QString_ptr);
+  ZVAL_ZVAL(return_value, zstring, 1, 0);
+  efree(zstring);
 
-  zval* z = zstringFromQString(QString_ptr);
-  ZVAL_ZVAL(return_value, z,1,0);
-  efree(z);
-
   return;
 
 }
@@ -213,12 +216,9 @@
 	if (ZEND_NUM_ARGS() == 0){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				const ushort * return_object = (const ushort *) obj->utf16();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				void* ptr = (void*) &return_object;
+				phpqt_createObject(return_value,(void*) return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 	}
 }
 
@@ -232,12 +232,10 @@
 	if (ZEND_NUM_ARGS() == 0){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				const QChar * return_object = (const QChar *) obj->constData();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+
+
+				phpqt_createObject(return_value,(void*) return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 	}
 }
 
@@ -261,15 +259,10 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString & return_object = (QString &) obj->insert((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				return_value = (zval*) emalloc(sizeof(zval));				
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
@@ -330,15 +323,10 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString & return_object = (QString &) obj->setUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				return_value = (zval*) emalloc(sizeof(zval));				
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -366,27 +354,17 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString & return_object = (QString &) obj->prepend((char) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				return_value = (zval*) emalloc(sizeof(zval));				
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_STRING){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString & return_object = (QString &) obj->prepend( (const char*) Z_STRVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				return_value = (zval*) emalloc(sizeof(zval));				
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
 			QString *obj = (QString*) PHP_QT_FETCH();
@@ -408,12 +386,8 @@
 	if (ZEND_NUM_ARGS() == 0){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->trimmed();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 	}
 }
 
@@ -459,16 +433,10 @@
 		zval *z_2; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-
-
+				QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->leftJustified((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(bool) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -558,15 +526,9 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString return_object = (QString) obj->fromAscii( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -608,12 +570,8 @@
 	if (ZEND_NUM_ARGS() == 0){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->toUpper();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 	}
 }
 
@@ -627,7 +585,7 @@
 
 	if (ZEND_NUM_ARGS() == 0){
 	    QString *QString_ptr = new QString();
-	    phpqt_createObject(getThis(), (void*) QString_ptr, qstring_ce);
+	    phpqt_createObject(getThis(), (void*) QString_ptr, qstring_ce, QSTRING_CLASSID);
 	    RETURN_NULL();
 	}
 
@@ -636,12 +594,12 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG){
 				QString *QString_ptr = new QString((char) Z_LVAL_P(z_0));
-				phpqt_createObject(getThis(), (void*) QString_ptr, qstring_ce);
+				phpqt_createObject(getThis(), (void*) QString_ptr, qstring_ce, QSTRING_CLASSID);
 				RETURN_NULL();
 			}
 			if(Z_TYPE_P(z_0) == IS_STRING){
 				QString *QString_ptr = new QString( (const char*) Z_STRVAL_P(z_0));
-				phpqt_createObject(getThis(), (void*) QString_ptr, qstring_ce);
+				phpqt_createObject(getThis(), (void*) QString_ptr, qstring_ce, QSTRING_CLASSID);
 				RETURN_NULL();
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT){
@@ -667,7 +625,7 @@
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			    QString *QString_ptr = new QString((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1));
-			    phpqt_createObject(getThis(), QString_ptr, qstring_ce);
+			    phpqt_createObject(getThis(), QString_ptr, qstring_ce, QSTRING_CLASSID);
 			    RETURN_NULL();
 			}
 		}
@@ -693,15 +651,9 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString return_object = (QString) obj->normalized((QString::NormalizationForm) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -715,15 +667,9 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString return_object = (QString) obj->normalized((QString::NormalizationForm) Z_LVAL_P(z_0) ,(QChar::UnicodeVersion) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -746,15 +692,9 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString return_object = (QString) obj->fromUtf16((const ushort*) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -790,15 +730,10 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString & return_object = (QString &) obj->setNum((short) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				return_value = (zval*) emalloc(sizeof(zval));				
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -816,27 +751,17 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString & return_object = (QString &) obj->setNum((float) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				return_value = (zval*) emalloc(sizeof(zval));				
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString & return_object = (QString &) obj->setNum((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				return_value = (zval*) emalloc(sizeof(zval));				
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -889,14 +814,14 @@
 			if(Z_TYPE_P(z_0) == IS_LONG){
 				QString obj = (QString) QString::number((ulong) Z_LVAL_P(z_0));
 				QString *s1 = new QString(obj);
-				object_init_ex(return_value, qstring_ce);
-				phpqt_createObject(return_value, (void*) s1, qstring_ce);
+				
+				phpqt_createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
 				return;
 			} else if(Z_TYPE_P(z_0) == IS_DOUBLE){
 				QString obj = (QString) QString::number((double) Z_DVAL_P(z_0));
 				QString *s1 = new QString(obj);
-				object_init_ex(return_value, qstring_ce);
-				phpqt_createObject(return_value, (void*) s1, qstring_ce);
+				
+				phpqt_createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
 				return;
 			}
 			
@@ -909,27 +834,15 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString return_object = (QString) obj->number((ulong) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString return_object = (QString) obj->number((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -941,15 +854,9 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString return_object = (QString) obj->number((double) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -1019,15 +926,9 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzzz", &z_0, &z_1, &z_2, &z_3) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString return_object = (QString) obj->section((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(int) Z_LVAL_P(z_2) ,(QString::SectionFlags) Z_LVAL_P(z_3));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG && Z_TYPE_P(z_3) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
@@ -1075,12 +976,8 @@
 	if (ZEND_NUM_ARGS() == 0){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->simplified();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 	}
 }
 
@@ -1203,15 +1100,9 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString return_object = (QString) obj->right((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -1396,15 +1287,9 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString return_object = (QString) obj->left((int) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -1427,15 +1312,9 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString return_object = (QString) obj->fromLocal8Bit( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -1507,15 +1386,10 @@
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString & return_object = (QString &) obj->remove((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				return_value = (zval*) emalloc(sizeof(zval));				
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -1878,15 +1752,9 @@
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
 			if(Z_TYPE_P(z_0) == IS_STRING && Z_TYPE_P(z_1) == IS_LONG){
 			QString *obj = (QString*) PHP_QT_FETCH();
-
-
 				QString return_object = (QString) obj->fromLatin1( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -1902,12 +1770,8 @@
 	if (ZEND_NUM_ARGS() == 0){
 			QString *obj = (QString*) PHP_QT_FETCH();
 				QChar * return_object = (QChar *) obj->data();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 	}
 }
 
@@ -2054,36 +1918,28 @@
 		zval *z_1; // define ZVAL
 		zval *z_2; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
-			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
-
-
+			if(Z_TYPE_P(z_0) == IS_OBJECT && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG)
+			{
+				QString *obj = (QString*) PHP_QT_FETCH();
+				QObject* obj_z_0 = (QObject*) phpqt_getQtObjectFromZval(z_0);
+				QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
 			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
-
-
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_OBJECT && Z_TYPE_P(z_2) == IS_LONG)
+			{
+				QString *obj = (QString*) PHP_QT_FETCH();
+				QObject* obj_z_1 = (QObject*) phpqt_getQtObjectFromZval(z_1);
 			}
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-
-
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG)
+			{
+				QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->replace((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1) ,(char) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				return_value = (zval*) emalloc(sizeof(zval));				
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_OBJECT){
-			QString *obj = (QString*) PHP_QT_FETCH();
-			QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
-
-
+				QString *obj = (QString*) PHP_QT_FETCH();
+				QObject* obj_z_2 = (QObject*) phpqt_getQtObjectFromZval(z_2);
 			}
 		}
 	}
@@ -2123,8 +1979,8 @@
   			    if(getThis() == NULL){
 				QString obj = (QString) QString::fromUtf8( (const char*) Z_STRVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
 				QString *s1 = new QString(obj);
-				object_init_ex(return_value, qstring_ce);
-				phpqt_createObject(return_value, (void*) s1, qstring_ce);
+				
+				phpqt_createObject(return_value, (void*) s1, qstring_ce, QSTRING_CLASSID);
 				return;
 
 			    }
@@ -2185,26 +2041,22 @@
 		zval *z_0; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z", &z_0) == SUCCESS) {
 			/* QString & append ( QChar ch ) */
-			if(Z_TYPE_P(z_0) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
+			if(Z_TYPE_P(z_0) == IS_LONG)
+			{
+				QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->append((char) Z_LVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				return_value = (zval*) emalloc(sizeof(zval));				
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 			/* QString & append ( const char * str ) */
-			if(Z_TYPE_P(z_0) == IS_STRING){
+			if(Z_TYPE_P(z_0) == IS_STRING)
+			{
 				QString *obj = (QString*) PHP_QT_FETCH();
-				QString & return_object = (QString &) obj->append( (const char*) Z_STRVAL_P(z_0));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				QString & return_object = (QString&) obj->append( (const char*) Z_STRVAL_P(z_0) );
+				return_value = (zval*) emalloc(sizeof(zval));
+ 				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 
 			/*  QString & append ( const QLatin1String & str )
@@ -2214,8 +2066,7 @@
 			    smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
 			    QString* obj_z_0 = (QString*) phpqt_getQtObjectFromZval(z_0);
 			    QString* s = new QString(((QString*) o->ptr)->append((QString) *obj_z_0));
-			    object_init_ex(return_value, qstring_ce);     
-			    phpqt_createObject(return_value, s, qstring_ce);
+			    phpqt_createObject(return_value, s, qstring_ce, QSTRING_CLASSID);
 			    return;
 			}
 		}
@@ -2237,17 +2088,12 @@
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-
-
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG)
+			{
+				QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->mid((int) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -2294,17 +2140,13 @@
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zz", &z_0, &z_1) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-
-
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG)
+			{
+				QString *obj = (QString*) PHP_QT_FETCH();
 				QString & return_object = (QString &) obj->fill((char) Z_LVAL_P(z_0) ,(int) Z_LVAL_P(z_1));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				return_value = (zval*) emalloc(sizeof(zval));				
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -2325,18 +2167,14 @@
 		zval *z_0; // define ZVAL
 		zval *z_1; // define ZVAL
 		zval *z_2; // define ZVAL
-		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) {
-			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG){
-			QString *obj = (QString*) PHP_QT_FETCH();
-
-
+		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzz", &z_0, &z_1, &z_2) == SUCCESS) 
+		{
+			if(Z_TYPE_P(z_0) == IS_LONG && Z_TYPE_P(z_1) == IS_LONG && Z_TYPE_P(z_2) == IS_LONG)
+			{
+				QString *obj = (QString*) PHP_QT_FETCH();
 				QString return_object = (QString) obj->rightJustified((int) Z_LVAL_P(z_0) ,(char) Z_LVAL_P(z_1) ,(bool) Z_LVAL_P(z_2));
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+				phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+				return;
 			}
 		}
 	}
@@ -2348,16 +2186,14 @@
  *    function  toLower
  *    flags:    c
  */
-ZEND_METHOD(QString, toLower){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				QString return_object = (QString) obj->toLower();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+ZEND_METHOD(QString, toLower)
+{
+	if (ZEND_NUM_ARGS() == 0)
+	{
+		QString *obj = (QString*) PHP_QT_FETCH();
+		QString return_object = (QString) obj->toLower();
+		phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+		return;
 	}
 }
 
@@ -2418,16 +2254,14 @@
  *    function  unicode
  *    flags:    c
  */
-ZEND_METHOD(QString, unicode){
-	if (ZEND_NUM_ARGS() == 0){
-			QString *obj = (QString*) PHP_QT_FETCH();
-				const QChar * return_object = (const QChar *) obj->unicode();
-				zend_class_entry *ce;                                   
-				object_init_ex(return_value, qstring_ce);     
-				zend_rsrc_list_entry le;                            
-				le.ptr = (void*) &return_object;                                       
-				phpqt_register(return_value,le);                   
-				return;                                             
+ZEND_METHOD(QString, unicode)
+{
+	if (ZEND_NUM_ARGS() == 0)
+	{
+		QString *obj = (QString*) PHP_QT_FETCH();
+		const QChar * return_object = (const QChar *) obj->unicode();
+		phpqt_createObject(return_value,(void*) &return_object,qstring_ce, QSTRING_CLASSID);
+		return;
 	}
 }
 

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/php_qt/smokephp.cpp	2007-05-20 21:13:23 UTC (rev 316)
@@ -37,13 +37,25 @@
 Smoke::Index connect4;
 Smoke::Index connect5;
 
+extern QHash<void*, smokephp_object*> SmokeQtObjects;
+
 class PHPQtSmokeBinding : public SmokeBinding {
 
 public:
     PHPQtSmokeBinding(Smoke *s) : SmokeBinding(s) {}
 
-    virtual void deleted(Smoke::Index, void*) {
-            // ignore object deletion
+    virtual void deleted(Smoke::Index classId, void* ptr) {
+        qDebug("deleted");
+        if(phpqt_SmokePHPObjectExists(ptr)){
+			smokephp_object *o = (smokephp_object*) phpqt_getSmokePHPObjectFromQt(ptr);
+			if(!o->allocated){
+				delete (QObject*) ptr;
+				efree(o);
+			} else {
+				o->ptr = 0;
+			}
+			SmokeQtObjects.remove(o->ptr);
+		}
     }
     virtual bool callMethod(Smoke::Index method, void* QtPtr, Smoke::Stack args, bool /*isAbstract*/) {
 
@@ -77,17 +89,16 @@
 		}
 		
 		return false;
-
     }
 
     virtual char *className(Smoke::Index classId) {
-	// return a new[] copy of the language-specific name of this Smoke class
-	// poorly designed function, but oh well. Sorry.
+		// return a new[] copy of the language-specific name of this Smoke class
+		// poorly designed function, but oh well. Sorry.
 
-	const char *className = smoke->className(classId);
-	char *buf = new char[strlen(className) + 1];
-	strcpy(buf, className);
-	return buf;
+		const char *className = smoke->className(classId);
+		char *buf = new char[strlen(className) + 1];
+		strcpy(buf, className);
+		return buf;
     }
     virtual ~PHPQtSmokeBinding() {}
 };
@@ -122,12 +133,14 @@
  *  @return Smoke::Index        unambiguous method ID
  */
 Smoke::Index 
-smokephp_getMethod(const char* c, const char* m, int argc, zval*** args) {
+smokephp_getMethod(const char* c, const char* m, int argc, zval*** args)
+{
 
     Smoke::Index method = PQ::smoke()->findMethod(c, m);	// qt_Smoke->methods
     Smoke::Index i = PQ::smoke()->methodMaps[method].method;
 
-    if(i <= 0) {
+    if(i <= 0)
+    {
 	    i = -i;		// turn into ambiguousMethodList index
 	    while(PQ::smoke()->ambiguousMethodList[i]) {
 
@@ -346,8 +359,8 @@
         	    methodNameStack.top()->append("#");
         	}
 	    } else {
-	        php_error(E_ERROR,"Unknown argument or unsupported argument type %d, type %d, exit\n", i, type);
-	        exit(FAILURE);
+	        php_error(E_ERROR,"Unknown argument or unsupported type %d at argument %d, cannot prepare method call\n", type, i);
+// 	        exit(FAILURE);
 	    }
     }
 }

Modified: trunk/tests/QtBasicTestCase.php
===================================================================
--- trunk/tests/QtBasicTestCase.php	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/tests/QtBasicTestCase.php	2007-05-20 21:13:23 UTC (rev 316)
@@ -175,6 +175,13 @@
 	    echo " passed";
 	}
 
+	function testTr(){
+	    echo "\ntesting tr()";
+	    $s = tr("hello world");
+	    $this->assertEquals($s->__toString(), "hello world", "tr() doesnt work!");
+	    echo " passed";
+	}
+
     }    
     
 ?>
\ No newline at end of file

Modified: trunk/tutorials/t5/main.php
===================================================================
--- trunk/tutorials/t5/main.php	2007-03-26 11:34:59 UTC (rev 315)
+++ trunk/tutorials/t5/main.php	2007-05-20 21:13:23 UTC (rev 316)
@@ -47,7 +47,8 @@
     }
 
 
-    $app = new QApplication(&$argc,$argv);
+    $app = new QApplication($argc,$argv);
+
     $widget = new MyWidget();
     $widget->show();
 



From tm243 at mail.berlios.de  Mon May 21 22:19:08 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Mon, 21 May 2007 22:19:08 +0200
Subject: [Php-qt-svn] r317 - trunk
Message-ID: <200705212019.l4LKJ83l029489@sheep.berlios.de>

Author: tm243
Date: 2007-05-21 22:19:08 +0200 (Mon, 21 May 2007)
New Revision: 317

Modified:
   trunk/README
Log:
* fixed grammar and capitalization errors, removed reference to php_qt/build because it doesnt work always. Thanks Katrina!



Modified: trunk/README
===================================================================
--- trunk/README	2007-05-20 21:13:23 UTC (rev 316)
+++ trunk/README	2007-05-21 20:19:08 UTC (rev 317)
@@ -1,69 +1,92 @@
-PHP-Qt - an extension for PHP5 that aims to write software with the Qt Toolkit.
+PHP-Qt - an extension for PHP5 that enables the writing of PHP software using 
+the Qt Toolkit.
 ================================================================================
 
-PHP-Qt is an extension for PHP5 that aims to write software with the Qt Toolkit. 
-It provides an object-oriented interface to the Qt4 Framework and allowes 
-to write Qt applications in the PHP language.
+PHP-Qt is an extension for PHP5 that provides an object-oriented interface to 
+the Qt4 Framework and allows 
+one to write Qt applications in the PHP language.
 
 Requirements
 ============
 
-PHP-Qt requires PHP 5.1 or greater, the Qt4 header files and CMake.
+PHP 5.1 or greater
+PHP header files and the development scripts
+(package may be called php-devel)
 
-PHP5: You should have a the header files and the development scripts.
-Qt4: You should have the header files.
+Qt4 header files
+(package may be called qt4-devel)
 
-Note: at this time compilation is only tested in a Unix environment.
+CMake
 
+Note: at this time compilation has only been tested in a Unix environment.
+
 Compiling and installation
 ==========================
 
-short:
+Both of these methods will compile and install PHP-Qt as a module.
 
+The quick and easy way:
+
 cmake /path/to/php_qt
 make
 make install
 
-more detailed:
 
-You have cmake installed and the path to your PHP5 header files. After 
-downloading or checking out from SVN the easiest way is to create a build 
-directory in your copy of PHP-Qt. The extension will be built out-of-source 
-which allows you to have a clean copy of PHP-Qt without any files of the build 
-system.
+The more detailed way:
 
-PHP-Qt will be compiled as module! 
+First make sure CMake, your PHP header files, and your Qt header files are 
+installed.
+Then, get PHP-Qt either by downloading or checking out from SVN and placing it 
+into
+its own directory.
 
-At first it is neccessary to create your build environment for compiling.
-To do that just change into the 'php_qt/build' directory and run cmake:
+Next it is neccessary to create your build environment for compiling.
+To do this, just change into the directory where you placed PHP-Qt and run 
+cmake:
 
-cmake ..
+cmake
 
-You can give arguments to cmake via the -D option:
-  -DQT_INCLUDE_DIR=/usr/lib/qt4/include \
-  -DQT_LIBRARY_DIR=/usr/lib/qt4
+If needed you can give arguments to CMake via the -D option, such as:
+? -DQT_INCLUDE_DIR=/usr/lib/qt4/include
+? -DQT_LIBRARY_DIR=/usr/lib/qt4
+? -DQT_QMAKE_EXECUTABLE=/usr/lib/qt4/bin/qmake
+? 
+If no arguments are given, CMake will try to find the Qt4 and PHP5 files in 
+the default or standard 
+paths such as /usr/include, /usr/local/include etc.
 
-If no argument is given cmake will try to find the Qt4 and PHP5 files in the default or standard 
-pathes as /usr/include, /usr/local/include etc.
+Finally, run:
 
-Finally, run 
-
 make
 
-to build the extension. If the compilation is successful run 
+to build the extension. If the compilation is successful run:
 
 make install
 
-to copy 'php_qt.so' into php's extension directory. If it fails please check if you have 
-permissions and all related pathes on your system are correct.
+to copy 'php_qt.so' into php's extension directory. If it fails please check 
+if you have 
+permissions and all related paths on your system are correct.
 
-To remove old objectfiles run 
+To remove old objectfiles run:
 
 make clean
 
-To test it, simply run one of the test scripts in the php_qt/test/ subdirectory.
-To get a clean build system just remove all files in the build/ directory.
+To test it, simply run one of the test scripts in the php_qt/test/ 
+subdirectory.
 
+Troubleshooting
+===================================
+
+If you get the following error:
+CMake Error: Could NOT find QtCore. Check CMakeFiles/CMakeError.log for more 
+details.
+
+Try running cmake as:
+cmake /path/to/php-qt ?-DQT_QMAKE_EXECUTABLE=/usr/lib/qt4/bin/qmake
+(you may need to replace the /usr/lib/qt4/bin/qmake if yours is in another 
+place)
+
+
 Mailing lists
 =============
 
@@ -71,17 +94,18 @@
 -----------------
 users mailing list
 
-address:        php-qt-users at lists.sourceforge.net
-Subscription:   https://lists.sourceforge.net/lists/listinfo/php-qt-users
-Archive:        http://sourceforge.net/mailarchive/forum.php?forum=php-qt-users
+address: ? ? ? ?php-qt-users at lists.sourceforge.net
+Subscription: ? https://lists.sourceforge.net/lists/listinfo/php-qt-users
+Archive: ? ? ? ?
+http://sourceforge.net/mailarchive/forum.php?forum=php-qt-users
 
 Subversion commits
 --------------------
 The list for svn commits. Readonly!
 
-address:        php-qt-svn at lists.berlios.de.
-Subscription:   https://lists.berlios.de/mailman/listinfo/php-qt-svn
-Archive:        https://lists.berlios.de/pipermail/php-qt-svn/
+address: ? ? ? ?php-qt-svn at lists.berlios.de.
+Subscription: ? https://lists.berlios.de/mailman/listinfo/php-qt-svn
+Archive: ? ? ? ?https://lists.berlios.de/pipermail/php-qt-svn/
 
 
 Website
@@ -89,6 +113,4 @@
 
 The website for the project:
 
-    http://www.php-qt.org
-
-
+? ? http://www.php-qt.org



From tm243 at mail.berlios.de  Tue May 22 10:59:27 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Tue, 22 May 2007 10:59:27 +0200
Subject: [Php-qt-svn] r318 - trunk/tests
Message-ID: <200705220859.l4M8xRc5008580@sheep.berlios.de>

Author: tm243
Date: 2007-05-22 10:59:26 +0200 (Tue, 22 May 2007)
New Revision: 318

Modified:
   trunk/tests/box2buttons.php
Log:
* zend seems to re-create object properties when calling the parents constructor, we need to copy them



Modified: trunk/tests/box2buttons.php
===================================================================
--- trunk/tests/box2buttons.php	2007-05-21 20:19:08 UTC (rev 317)
+++ trunk/tests/box2buttons.php	2007-05-22 08:59:26 UTC (rev 318)
@@ -1,4 +1,4 @@
-<?
+<?php
 	if(!extension_loaded('php_qt')) {
 		dl('php_qt.' . PHP_SHLIB_SUFFIX);
 	}
@@ -10,19 +10,23 @@
 		public $button2;
 	
 		function __construct() {
-			$this->mainWidget = new QWidget();
-			parent::__construct(QBoxLayout::TopToBottom,$this->mainWidget);
+
+			$mainWidget = new QWidget();
+			parent::__construct(QBoxLayout::TopToBottom,$mainWidget);
+			$this->mainWidget = $mainWidget;
+
 			$this->button1 = new QPushButton("About Qt!");
 			$this->button2 = new QPushButton("Quit");
 			$this->addWidget($this->button1);
 			$this->addWidget($this->button2);
-			
+
 		}
+
 		function __destruct()
 		{
-     		$this->button1 = 0;
-     		$this->button2 = 0;	
-			$this->mainWidget = 0;
+     		    $this->button1 = 0;
+     		    $this->button2 = 0;	
+	 	    $this->mainWidget = 0;
 		}
 		
 		function show()
@@ -32,7 +36,7 @@
 	}
 	
 	
-	$app = new QApplication(&$argc,$argv);
+	$app = new QApplication($argc,$argv);
 
 	$box = new Box();
 	$box->show();



From tm243 at mail.berlios.de  Tue May 22 23:48:07 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Tue, 22 May 2007 23:48:07 +0200
Subject: [Php-qt-svn] r319 - trunk/php_qt
Message-ID: <200705222148.l4MLm7D3013121@sheep.berlios.de>

Author: tm243
Date: 2007-05-22 23:48:06 +0200 (Tue, 22 May 2007)
New Revision: 319

Modified:
   trunk/php_qt/functions.cpp
   trunk/php_qt/marshall_basetypes.h
   trunk/php_qt/marshall_types.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/smokephp.cpp
Log:
* worked on a memory problem at VirtualMethodCall



Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-05-22 08:59:26 UTC (rev 318)
+++ trunk/php_qt/functions.cpp	2007-05-22 21:48:06 UTC (rev 319)
@@ -173,12 +173,13 @@
 		cout << "PHP Object \n(" << endl;
 
 		cout << "\t       zval => " << zobject << endl;
-// 		cout << "\tclass entry => " << Z_OBJCE_P(zobject)->name << endl;
+		if(Z_TYPE_P(zobject) == IS_OBJECT)
+			cout << "\tclass entry => " << Z_OBJCE_P(zobject)->name << endl;
 		cout << "\t  ref count => " << zobject->refcount << endl;
 		cout << "\t     is_ref => " << (int) zobject->is_ref << endl;
 		cout << "\t       type => " << printType(Z_TYPE_P(zobject)) << endl;
 
-		if(Z_TYPE_P(zobject) == 5)
+		if(Z_TYPE_P(zobject) == IS_OBJECT)
 		{
 		 cout <<"\t obj-handle => " << zobject->value.obj.handle << endl;
 		}
@@ -192,7 +193,7 @@
 		cout << "PHP-Qt object \n(" << endl;
 
 		cout << "\t       zval => " << zobject << endl;
-	// 	cout << "\tclass entry => " << Z_OBJCE_P(zobject)->name << endl;
+// 		cout << "\tclass entry => " << Z_OBJCE_P(zobject)->name << endl;
 		cout << "\tclass entry => " << o->ce_ptr->name << endl;
 		cout << "\t  ref count => " << zobject->refcount << endl;
 		cout << "\t     is_ref => " << (int) zobject->is_ref << endl;

Modified: trunk/php_qt/marshall_basetypes.h
===================================================================
--- trunk/php_qt/marshall_basetypes.h	2007-05-22 08:59:26 UTC (rev 318)
+++ trunk/php_qt/marshall_basetypes.h	2007-05-22 21:48:06 UTC (rev 319)
@@ -97,7 +97,7 @@
 			php_error(E_WARNING, "References can't be nil\n");
 			m->unsupported();
 		}
-					
+
 		m->item().s_class = 0;
 		return;
 	}
@@ -119,8 +119,9 @@
 		o->classId,			// from
 		o->smoke->idClass(cl.className)	// to
 		);
+	
+	m->item().s_class = ptr;
 
-	m->item().s_class = ptr;
 	return;
 }
 
@@ -146,7 +147,7 @@
 		}
 		return;
 
-	//create a new PHP obnject (return_value):
+	//create a new PHP object (return_value):
 	} else {
 		void* __p = m->item().s_class;
 	    QObject* __qo = ((QObject*) __p);

Modified: trunk/php_qt/marshall_types.cpp
===================================================================
--- trunk/php_qt/marshall_types.cpp	2007-05-22 08:59:26 UTC (rev 318)
+++ trunk/php_qt/marshall_types.cpp	2007-05-22 21:48:06 UTC (rev 319)
@@ -387,16 +387,16 @@
  */
 
 VirtualMethodCall::VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, zval* obj, zval ***sp) :
-	MethodCallBase(smoke,meth,stack), _obj(obj), _sp(sp)
+	MethodCallBase(smoke,meth,stack), _obj(obj)
 {
 	identifier = "VirtualMethodCall";
-	_sp = sp;
-	_args = _smoke->argumentList + method().args;
+ 	_sp = sp;
+  	_args = _smoke->argumentList + method().args;
 }
 
 VirtualMethodCall::~VirtualMethodCall() 
 {
-//    delete[] _stack;
+    delete[] _stack;
 }
 
 Marshall::Action 
@@ -407,11 +407,9 @@
 
 zval*
 VirtualMethodCall::var() 
-{ 
-    if(*_sp[_cur] == NULL) {
-	MAKE_STD_ZVAL(*_sp[_cur]);
-    }
-    return (zval*) *_sp[_cur]; 
+{
+	*_sp[_cur] = (zval*) emalloc(sizeof(zval));
+    return (zval*) *_sp[_cur];
 }
 
 int 
@@ -426,10 +424,10 @@
 	if (_called) return;
 	_called = true;
 
-	phpqt_callPHPMethod(_obj, (char*) _smoke->methodNames[method().name], method().numArgs, _sp);
+	phpqt_callPHPMethod(_obj, (char*) _smoke->methodNames[method().name], items(), _sp);
 
 	zval _retval;
-	VirtualMethodReturnValue r(_smoke, _method, _stack, _retval);
+ 	VirtualMethodReturnValue r(_smoke, _method, _stack, _retval);
 }
 
 bool 
@@ -445,6 +443,7 @@
 MethodCall::MethodCall(Smoke *smoke, Smoke::Index method, zval* target, zval ***sp, int items, zval *retval, zval** return_value_ptr) :
 	MethodCallBase(smoke,method), _target(target), _current_object(0), _sp(sp), _items(items), _retval(retval), _return_value_ptr(return_value_ptr)
 {
+
 	identifier = "MethodCall";
     if(target != NULL)
     {

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-05-22 08:59:26 UTC (rev 318)
+++ trunk/php_qt/php_qt.cpp	2007-05-22 21:48:06 UTC (rev 319)
@@ -282,11 +282,11 @@
     smokephp_prepareMethodName(args, argc, methodNameStack);	// #, $, ?
     Smoke::Index method = smokephp_getMethod(ce->name, methodNameStack.top()->constData(), ZEND_NUM_ARGS(), args);
 
-	MethodCall c(PQ::smoke(), method, getThis(), args, argc-1, getThis(), return_value_ptr);
+ 	MethodCall c(PQ::smoke(), method, getThis(), args, argc-1, getThis(), return_value_ptr);
     c.next();
 
 	// smokephp_object is created above in c.next()
-     smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
+    smokephp_object* o = phpqt_getSmokePHPObjectFromZval(getThis());
     o->parent_ce_ptr = ce_parent; // = ce if no parent
 
 	// if QObject

Modified: trunk/php_qt/smokephp.cpp
===================================================================
--- trunk/php_qt/smokephp.cpp	2007-05-22 08:59:26 UTC (rev 318)
+++ trunk/php_qt/smokephp.cpp	2007-05-22 21:48:06 UTC (rev 319)
@@ -81,11 +81,12 @@
 
 		if(phpqt_methodExists(o->ce_ptr, (char*) methodName)){
 		    Smoke::Method & meth = smoke->methods[method];
-		    zval*** sp = (zval ***) safe_emalloc((int) meth.numArgs, sizeof(zval **), 0);
+		    zval*** sp = (zval ***) safe_emalloc((int) meth.numArgs, sizeof(zval), 0);
 
 		    VirtualMethodCall c(smoke, method, args, o->zval_ptr, sp);
-//		    c.next();
-		    efree(sp);
+		    c.next();
+
+  		    efree(sp);
 		}
 		
 		return false;



From tm243 at mail.berlios.de  Wed May 23 00:03:03 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Wed, 23 May 2007 00:03:03 +0200
Subject: [Php-qt-svn] r320 - trunk/php_qt
Message-ID: <200705222203.l4MM33nT014880@sheep.berlios.de>

Author: tm243
Date: 2007-05-23 00:03:02 +0200 (Wed, 23 May 2007)
New Revision: 320

Modified:
   trunk/php_qt/marshall_primitives.h
Log:
* fixed a bug in marshall_it<bool>, false-values weren't handled correctly



Modified: trunk/php_qt/marshall_primitives.h
===================================================================
--- trunk/php_qt/marshall_primitives.h	2007-05-22 21:48:06 UTC (rev 319)
+++ trunk/php_qt/marshall_primitives.h	2007-05-22 22:03:02 UTC (rev 320)
@@ -14,7 +14,7 @@
 		// A Qt::Boolean has been passed as a value
 		php_error(E_WARNING,"A Qt::Boolean has been passed as a value");
 	} else {
-		return ZEND_NORMALIZE_BOOL(v);
+		return Z_BVAL_P(v);
 	}
 }
 



From tm243 at mail.berlios.de  Thu May 24 23:26:51 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Thu, 24 May 2007 23:26:51 +0200
Subject: [Php-qt-svn] r321 - trunk/php_qt
Message-ID: <200705242126.l4OLQpcK010535@sheep.berlios.de>

Author: tm243
Date: 2007-05-24 23:26:50 +0200 (Thu, 24 May 2007)
New Revision: 321

Modified:
   trunk/php_qt/handlers.cpp
Log:
* removed the isNull question since the value returned by toZVAL is a real QString that can be asked for ->isNull() even in php.



Modified: trunk/php_qt/handlers.cpp
===================================================================
--- trunk/php_qt/handlers.cpp	2007-05-22 22:03:02 UTC (rev 320)
+++ trunk/php_qt/handlers.cpp	2007-05-24 21:26:50 UTC (rev 321)
@@ -254,6 +254,7 @@
 
 
 static void marshall_QString(Marshall *m) {
+
 	switch(m->action()) {
 		case Marshall::FromZVAL:
 		{
@@ -287,21 +288,9 @@
 
 		case Marshall::ToZVAL:
 		{
-			QString* s = (QString*) m->item().s_voidp;
-			zval* obj = m->var();
-// 			object_init_ex(obj, qstring_ce);
-
-			phpqt_createObject(obj, (void*) s, qstring_ce, -1);
-
-			if(s) {
-				if (s->isNull()) {
-// 					m->setRetval(Qnil);
-					*(m->var()) = *Qnil;
-				}
-			} else {
-// 				m->setRetval(Qnil);
-				*(m->var()) = *Qnil;
-			}
+			QString* s = static_cast<QString*>(m->item().s_voidp);
+// 			zval* obj = m->var();
+			phpqt_createObject(m->var(), (void*) s, qstring_ce, -1);
 		}
 		break;
  



From tm243 at mail.berlios.de  Fri May 25 00:16:57 2007
From: tm243 at mail.berlios.de (tm243 at BerliOS)
Date: Fri, 25 May 2007 00:16:57 +0200
Subject: [Php-qt-svn] r322 - trunk/php_qt
Message-ID: <200705242216.l4OMGv2v014548@sheep.berlios.de>

Author: tm243
Date: 2007-05-25 00:16:57 +0200 (Fri, 25 May 2007)
New Revision: 322

Modified:
   trunk/php_qt/marshall_primitives.h
Log:
* when for an argument an integer is expected, try to convert strings too since e.g. php::date() returns a string.



Modified: trunk/php_qt/marshall_primitives.h
===================================================================
--- trunk/php_qt/marshall_primitives.h	2007-05-24 21:26:50 UTC (rev 321)
+++ trunk/php_qt/marshall_primitives.h	2007-05-24 22:16:57 UTC (rev 322)
@@ -81,7 +81,14 @@
 	if (v->type == IS_OBJECT) {
 	    php_error(E_WARNING,"An integer has been passed as an object");
 	} else {
-	    return Z_LVAL_P(v);
+		if(v->type == IS_LONG) {
+	    	return Z_LVAL_P(v);
+		// e.g. date() gives a string, so we try to convert it
+		} else if (v->type == IS_STRING) {
+			return QString(Z_STRVAL_P(v)).toLong();
+		} else {
+			php_error(E_ERROR,"wrong type, num expected");
+		}
 	}
 }
 



From Katrina.Niolet at mail.berlios.de  Wed May 30 22:50:47 2007
From: Katrina.Niolet at mail.berlios.de (Katrina.Niolet at mail.berlios.de)
Date: Wed, 30 May 2007 22:50:47 +0200
Subject: [Php-qt-svn] r323 - in trunk: php_qt tests
Message-ID: <200705302050.l4UKolVh004534@sheep.berlios.de>

Author: Katrina Niolet
Date: 2007-05-30 22:50:45 +0200 (Wed, 30 May 2007)
New Revision: 323

Added:
   trunk/tests/qFunctions.php
Modified:
   trunk/php_qt/functions.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
Log:
Added support for the following Qt namespace functions:
qDebug,qWarning,qCritical,qAbs,qRound,qRound64,qMin,qMax,qBound,qPrintable; 
also qFunctions.php file in test folder to demonstrate and test these 
functions.

Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-05-24 22:16:57 UTC (rev 322)
+++ trunk/php_qt/functions.cpp	2007-05-30 20:50:45 UTC (rev 323)
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 2006 
  * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Katrina Niolet <katrina at niolet.name>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -140,6 +141,195 @@
 
 }
 
+/**
+ * qDebug($message) triggers a notice with the given message.
+ */
+PHP_FUNCTION(qDebug) {
+	const char* msg;
+	int msglen;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s",&msg,&msglen)==FAILURE) {
+		php_error(E_PARSE,"wrong parameters for qDebug");
+		return;
+	}
+	php_error(E_NOTICE,msg);
+	return;
+}
+
+/**
+ * qWarning($message) triggers a warning with the given message.
+ */
+PHP_FUNCTION(qWarning) {
+	const char* msg;
+	int msglen;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s",&msg,&msglen)==FAILURE) {
+		php_error(E_PARSE,"wrong parameters for qWarning");
+		return;
+	}
+	php_error(E_WARNING,msg);
+	return;
+}
+
+/**
+ * qCritical($message) triggers a fatal error with the given message.
+ */
+PHP_FUNCTION(qCritical) {
+	const char* msg;
+	int msglen;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"s",&msg,&msglen)==FAILURE) {
+		php_error(E_PARSE,"wrong parameters for qCritical");
+		return;
+	}
+	php_error(E_ERROR,msg);
+	return;
+}
+
+/**
+ * Returns the absolute value of a number.
+ */
+PHP_FUNCTION(qAbs) {
+	double x;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"d",&x)==FAILURE) {
+		php_error(E_PARSE,"wrong parameters for qAbs");
+		return;
+	}
+	RETURN_DOUBLE(0.0 >= x ? -x : x);
+}
+	
+/**
+ * Returns this number rounded to the nearest integer
+ * if decimal is greater than .5 it rounds up, otherwise it rounds down
+ */
+PHP_FUNCTION(qRound) {
+	double x;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"d",&x)==FAILURE) {
+		php_error(E_PARSE,"wrong parameters for qRound");
+		return;
+	}
+	RETURN_DOUBLE(x >= 0.00 ? (int)(x+0.5) : (int)(x - (int)(x-1) + 0.5) + (int)(x-1));
+}
+
+/**
+ * Returns this number rounded to the nearest integer
+ * if decimal is greater than .5 it rounds up, otherwise it rounds down
+ */
+PHP_FUNCTION(qRound64) {
+	double x;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"d",&x)==FAILURE) {
+		php_error(E_PARSE,"wrong parameters for qRound");
+		return;
+	}
+	RETURN_DOUBLE(x >= 0.00 ? (int)(x+0.5) : (int)(x - (int)(x-1) + 0.5) + (int)(x-1));
+}
+
+/**
+ * Return the smaller of two numbers
+ * TODO: Make this capable of dealing with objects
+ */
+PHP_FUNCTION(qMin) {
+	double x;
+	double y;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"dd",&x,&y)==FAILURE) {
+		php_error(E_PARSE,"wrong paramters for qMin");
+		return;
+	}
+	if(x>y)
+		RETURN_DOUBLE(y);
+	RETURN_DOUBLE(x);
+}
+
+/**
+ * Return the larger of two numbers
+ * TODO: Make this capable of dealing with objects
+ */
+PHP_FUNCTION(qMax) {
+	double x;
+	double y;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"dd",&x,&y)==FAILURE) {
+		php_error(E_PARSE,"wrong parameters for qMax");
+		return;
+	}
+	if(x>y)
+		RETURN_DOUBLE(x);
+	RETURN_DOUBLE(y);
+}
+
+/**
+ * Return a value bound by a minimum and maximum value.
+ * TODO: Make this capable of dealing with objects
+ */
+PHP_FUNCTION(qBound) {
+	double min;
+	double val;
+	double max;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"ddd",&min,&val,&max)==FAILURE) {
+		php_error(E_PARSE,"wrong parameters for qBound");
+		return;
+	}
+	if(min>max) {
+		php_error(E_PARSE,"minimum cannot be greater than maximum for qBound");
+		return;
+	}
+	if(val>max)
+		val=max;
+	if(val<min)
+		val=min;
+	RETURN_DOUBLE(val);
+}
+
+/**
+ * Convert a string or character code into a printable character based on local 8 bit character set
+ */
+PHP_FUNCTION(qPrintable) {
+	zval* string;
+	QString *ptr;
+	//int string_len;
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z",&string)==FAILURE) {
+		php_error(E_PARSE,"wrong parameters for qPrintable");
+		return;
+	}
+	switch(Z_TYPE_P(string)) {
+		case IS_NULL:
+			RETURN_STRING("",1);
+			break;
+		case IS_BOOL:
+			RETURN_STRING ("",1);
+			break;
+		case IS_LONG:
+			ptr = new QString((int)Z_LVAL_P(string));
+			RETURN_STRING((char *)ptr->toLocal8Bit().constData(),1);
+			break;
+		case IS_DOUBLE:
+			ptr = new QString((int)Z_DVAL_P(string));
+			RETURN_STRING((char*)ptr->toLocal8Bit().constData(),1);
+			break;
+		case IS_RESOURCE:
+			RETURN_STRING("Resource",1);
+			break;
+		case IS_ARRAY:
+			RETURN_STRING("Array",1);
+			break;
+		case IS_STRING:
+			ptr = new QString(Z_STRVAL_P(string));
+			RETURN_STRING((char*)ptr->toLocal8Bit().constData(),1);
+			break;
+		case IS_OBJECT:
+			if(strcmp(Z_OBJCE_P(string)->name,"QString")==0) {
+				ptr = (QString*) phpqt_getQtObjectFromZval(string);
+				RETURN_STRING((char*)ptr->toLocal8Bit().constData(),1);
+			}
+			RETURN_STRING(Z_OBJCE_P(string)->name,1);
+			break;
+	}
+}
 /*!
  *	tr() returns QObject::tr()
  *

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-05-24 22:16:57 UTC (rev 322)
+++ trunk/php_qt/php_qt.cpp	2007-05-30 20:50:45 UTC (rev 323)
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 2006 
  * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Katrina Niolet <katrina at niolet.name>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -70,7 +71,17 @@
 	PHP_FE(confirm_php_qt_compiled,	NULL)		/* For testing, remove later. */
 	PHP_FE(SIGNAL,	NULL)
 	PHP_FE(SLOT,	NULL)	
-	PHP_FE(emit,	NULL)	
+	PHP_FE(emit,	NULL)
+	PHP_FE(qDebug,	NULL)
+	PHP_FE(qWarning,	NULL)
+	PHP_FE(qCritical,	NULL)
+	PHP_FE(qAbs, 		NULL)
+	PHP_FE(qRound,		NULL)
+	PHP_FE(qRound64,	NULL)
+	PHP_FE(qMin,		NULL)
+	PHP_FE(qMax,		NULL)
+	PHP_FE(qBound,		NULL)
+	PHP_FE(qPrintable,	NULL)
 	PHP_FE(qobject_cast,	phpqt_cast_arginfo)
 	PHP_FE(tr,	NULL)
 	PHP_FE(check_qobject,	NULL)

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-05-24 22:16:57 UTC (rev 322)
+++ trunk/php_qt/php_qt.h	2007-05-30 20:50:45 UTC (rev 323)
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 2006 
  * Thomas Moenicke <thomas.moenicke at kdemail.net>
+ * Katrina Niolet <katrina at niolet.name>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -95,6 +96,16 @@
 PHP_FUNCTION(SLOT);
 #undef emit
 PHP_FUNCTION(emit);
+PHP_FUNCTION(qDebug);
+PHP_FUNCTION(qWarning);
+PHP_FUNCTION(qCritical);
+PHP_FUNCTION(qAbs);
+PHP_FUNCTION(qRound);
+PHP_FUNCTION(qRound64);
+PHP_FUNCTION(qMin);
+PHP_FUNCTION(qMax);
+PHP_FUNCTION(qBound);
+PHP_FUNCTION(qPrintable);
 PHP_FUNCTION(qobject_cast);
 PHP_FUNCTION(tr);
 PHP_FUNCTION(check_qobject);

Added: trunk/tests/qFunctions.php
===================================================================
--- trunk/tests/qFunctions.php	2007-05-24 22:16:57 UTC (rev 322)
+++ trunk/tests/qFunctions.php	2007-05-30 20:50:45 UTC (rev 323)
@@ -0,0 +1,52 @@
+<?php
+
+if(!extension_loaded('php_qt')) {
+	dl('php_qt.' . PHP_SHLIB_SUFFIX);
+}
+
+echo "\nTesting qAbs:\n";
+echo "qAbs(4) = ".qAbs(4)."\n";
+echo "qAbs(-4) = ".qAbs(-4)."\n";
+echo "qAbs(4.3) = ".qAbs(4.3)."\n";
+echo "qAbs(-4.3) = ".qAbs(-4.3)."\n";
+
+echo "\nTesting qRound:\n";
+echo "qRound(1) = ".qRound(1)."\n";
+echo "qRound(4.5) = ".qRound(4.5)."\n";
+echo "qRound(-4.47837289) = ".qRound(-4.478327289)."\n";
+
+echo "\nTesting qRound64:\n";
+echo "qRound64(1) = ".qRound64(1)."\n";
+echo "qRound64(4.5) = ".qRound64(4.5)."\n";
+echo "qRound64(-4.47837289) = ".qRound64(-4.478327289)."\n";
+
+echo "\nTesting qMin:\n";
+echo "qMin(4,5) = ".qMin(4,5)."\n";
+echo "qMin(7,-1.567) = ".qMin(7,-1.567)."\n";
+
+echo "\nTesting qMax:\n";
+echo "qMax(4,5) = ".qMax(4,5)."\n";
+echo "qMax(7,-1.567) = ".qMax(7,-1.567)."\n";
+
+echo "\nTesting qBound:\n";
+echo "qBound(3,4,5) = ".qBound(3,4,5)."\n";
+echo "qBound(4,3,5) = ".qBound(4,3,5)."\n";
+echo "qBound(4,6,5) = ".qBound(4,6,5)."\n";
+
+echo "\nTesting qPrintable:\n";
+echo "qPrintable(\"bob\") = ".qPrintable("bob")."\n";
+echo "qPrintable(new QString(\"fred\") = ".qPrintable(new QString("fred"))."\n";
+echo 'qPrintable(45) = '.qPrintable(45)."\n";
+class test {}
+echo "qPrintable(new test) = ".qPrintable(new test)."\n";
+
+echo "\nTesting qDebug:\n";
+qDebug("This is a debug message");
+
+echo "Testing qWarning:\n";
+qWarning("This is a warning message");
+
+echo "Testing qCritical:\n";
+qCritical("This is a fatal error");
+
+?>



From Katrina.Niolet at mail.berlios.de  Thu May 31 07:37:33 2007
From: Katrina.Niolet at mail.berlios.de (Katrina.Niolet at mail.berlios.de)
Date: Thu, 31 May 2007 07:37:33 +0200
Subject: [Php-qt-svn] r324 - in trunk: php_qt tests
Message-ID: <200705310537.l4V5bXKs011300@sheep.berlios.de>

Author: Katrina Niolet
Date: 2007-05-31 07:37:32 +0200 (Thu, 31 May 2007)
New Revision: 324

Modified:
   trunk/php_qt/functions.cpp
   trunk/php_qt/php_qt.cpp
   trunk/php_qt/php_qt.h
   trunk/tests/qFunctions.php
Log:
Added support for the following Qt namespace functions:
qFuzzyCompare,qIsNull,qIntCast,qVersion,PHPQtVersion,QiDiVersin,qSharedBuild,qMalloc,qFree,qRealloc,qMemCopy and updated tests/qFunctions.php accordingly.

Modified: trunk/php_qt/functions.cpp
===================================================================
--- trunk/php_qt/functions.cpp	2007-05-30 20:50:45 UTC (rev 323)
+++ trunk/php_qt/functions.cpp	2007-05-31 05:37:32 UTC (rev 324)
@@ -330,6 +330,195 @@
 			break;
 	}
 }
+
+/**
+ * Returns true if x-y is between 0.0 and 0.00000000001
+ */
+PHP_FUNCTION(qFuzzyCompare) {
+	double x;
+	double y;
+	double ret;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"dd",&x,&y)==FAILURE) {
+		php_error(E_PARSE,"wrong parameters for qFuzzyCompare");
+		return;
+	}
+	//Just so happens the Qt version does just what we need for this one
+	RETURN_BOOL(qFuzzyCompare(x,y));
+}
+		
+/**
+ * Returns true if variable is NULL or a numeric 0
+ * This varies slightly from the Qt implementation which tests
+ * a double or float for a NULL value only.
+ */
+PHP_FUNCTION(qIsNull) {
+	zval *var;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z",&var)==FAILURE) {
+		php_error(E_PARSE,"wrong parameters for qIsNull");
+		return;
+	}
+	if(Z_TYPE_P(var)==IS_NULL)
+		RETURN_BOOL(true);
+	if(Z_TYPE_P(var)==IS_LONG) {
+		if(Z_LVAL_P(var) == 0)
+			RETURN_BOOL(true);
+	}
+	if(Z_TYPE_P(var)==IS_DOUBLE) {
+		if(Z_DVAL_P(var) == 0.0)
+			RETURN_BOOL(true);
+	}
+	RETURN_BOOL(false);
+}
+
+/**
+ * Cast a variable to an integer. NULL casts to 0 Resources and Arrays return false.
+ * Objects will call the __toInt() method if available, otherwise will return false.
+ * This differs from the Qt version which can only convert a float or double to an int
+ * TODO: implement __toInt() functionality
+ */
+PHP_FUNCTION(qIntCast) {
+	zval *var;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z",&var)==FAILURE)
+		return;
+	switch(Z_TYPE_P(var)) {
+		case IS_NULL:
+			RETURN_LONG(0);
+			break;
+		case IS_LONG:
+			RETURN_LONG(Z_LVAL_P(var));
+			break;
+		case IS_DOUBLE:
+			RETURN_LONG((long)Z_DVAL_P(var));
+			break;
+		case IS_RESOURCE:
+			RETURN_BOOL(false);
+			break;
+		case IS_ARRAY:
+			RETURN_BOOL(false);
+			break;
+		case IS_OBJECT:
+			RETURN_BOOL(false);
+			break;
+	}
+}
+
+/**
+ * Return the version of Qt being used
+ */
+PHP_FUNCTION(qVersion) {
+	RETURN_STRING(QT_VERSION_STR,1);
+}
+
+/**
+ * Return the version of PHP-Qt being used
+ */
+PHP_FUNCTION(PHPQtVersion) {
+	RETURN_STRING(PHPQT_VERSION,1);
+}
+
+/**
+ * Return the version of QiDi that this release complies with
+ */
+PHP_FUNCTION(QiDiVersion) {
+	RETURN_STRING(QIDI_VERSION,1);
+}
+
+PHP_FUNCTION(qSharedBuild) {
+	RETURN_BOOL(qSharedBuild);
+}
+
+/**
+ * We don't REALLY need to allocate memory in PHP, this is just here for ease of
+ * porting code from C++
+ * This doesn't ACTUALLY return a pointer to allocated memory exactly,
+ * it creates a space of allocated memory and assigns to it a null string
+ * then returns a pointer to this null string.
+ */
+PHP_FUNCTION(qMalloc) {
+	long size;
+	char *tmp;
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"l",&size)==FAILURE)
+		return;
+	tmp = (char *)emalloc(size);
+	qMemCopy(&tmp[0],"\0",1);
+	RETURN_STRING(tmp,0);
+}
+
+/**
+ * Simulate freeing the memory used by a variable by setting it to NULL
+ */
+PHP_FUNCTION(qFree) {
+	zval* var;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"z",&var)==FAILURE)
+		return;
+	convert_to_null(var);
+}
+
+/**
+ * We don't REALLY need to allocate memory in PHP, this is just here for ease of
+ * porting code from C++
+ */
+PHP_FUNCTION(qRealloc) {
+	zval *val;
+	double size;
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zd",&val,&size)==FAILURE)
+		return;
+	RETURN_BOOL(true);
+}
+
+/**
+ * Copy the contents of one pointer to another pointer
+ * This is reasonably zval safe, but note the destination must already exist.
+ * Additionally, the destination will automatically grow if the
+ * size of the coppied data is to large
+ * Currently this only supports string, int and float types
+ * TODO: add support for array, objects, bool
+ */
+PHP_FUNCTION(qMemCopy) {
+	zval* dest;
+	zval* src;
+	
+	long size;
+	int src_orig_type;
+	int dest_orig_type;
+	
+	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,"zzl",&dest,&src,&size)==FAILURE)
+		return;
+
+	src_orig_type = Z_TYPE_P(src);
+	dest_orig_type = Z_TYPE_P(dest);
+	
+	switch(Z_TYPE_P(src)) {
+		case IS_STRING:
+		case IS_LONG:
+		case IS_DOUBLE:
+			convert_to_string(src);
+			convert_to_string(dest);
+			if(dest->value.str.len < size) {
+				dest->value.str.val = (char*)emalloc((size_t)size);
+				dest->value.str.len = size;
+			}
+			qMemCopy(dest->value.str.val,src->value.str.val,(size_t)size);
+			break;
+		default:
+			RETURN_FALSE;
+	}
+	if(src_orig_type==IS_STRING || dest_orig_type==IS_STRING)
+		RETURN_TRUE;
+	if(src_orig_type==IS_DOUBLE || dest_orig_type==IS_DOUBLE) {
+		convert_to_double(dest);
+		RETURN_TRUE;
+	}
+	if(src_orig_type==IS_LONG || dest_orig_type==IS_LONG) {
+		convert_to_long(dest);
+		RETURN_TRUE;
+	}
+}
+
 /*!
  *	tr() returns QObject::tr()
  *

Modified: trunk/php_qt/php_qt.cpp
===================================================================
--- trunk/php_qt/php_qt.cpp	2007-05-30 20:50:45 UTC (rev 323)
+++ trunk/php_qt/php_qt.cpp	2007-05-31 05:37:32 UTC (rev 324)
@@ -82,6 +82,17 @@
 	PHP_FE(qMax,		NULL)
 	PHP_FE(qBound,		NULL)
 	PHP_FE(qPrintable,	NULL)
+	PHP_FE(qFuzzyCompare,	NULL)
+	PHP_FE(qIsNull,		NULL)
+	PHP_FE(qIntCast,	NULL)
+	PHP_FE(qVersion,	NULL)
+	PHP_FE(PHPQtVersion,	NULL)
+	PHP_FE(QiDiVersion,	NULL)
+	PHP_FE(qSharedBuild,		NULL)
+	PHP_FE(qMalloc,		NULL)
+	PHP_FE(qFree,		NULL)
+	PHP_FE(qRealloc,	NULL)
+	PHP_FE(qMemCopy,	NULL)
 	PHP_FE(qobject_cast,	phpqt_cast_arginfo)
 	PHP_FE(tr,	NULL)
 	PHP_FE(check_qobject,	NULL)

Modified: trunk/php_qt/php_qt.h
===================================================================
--- trunk/php_qt/php_qt.h	2007-05-30 20:50:45 UTC (rev 323)
+++ trunk/php_qt/php_qt.h	2007-05-31 05:37:32 UTC (rev 324)
@@ -25,6 +25,7 @@
 #define QTPHP_H
 
 #define PHPQT_VERSION "0.0.4"
+#define QIDI_VERSION "1.0"
 
 #define MONITOR
 
@@ -106,6 +107,17 @@
 PHP_FUNCTION(qMax);
 PHP_FUNCTION(qBound);
 PHP_FUNCTION(qPrintable);
+PHP_FUNCTION(qFuzzyCompare);
+PHP_FUNCTION(qIsNull);
+PHP_FUNCTION(qIntCast);
+PHP_FUNCTION(qVersion);
+PHP_FUNCTION(PHPQtVersion);
+PHP_FUNCTION(QiDiVersion);
+PHP_FUNCTION(qSharedBuild);
+PHP_FUNCTION(qMalloc);
+PHP_FUNCTION(qFree);
+PHP_FUNCTION(qRealloc);
+PHP_FUNCTION(qMemCopy);
 PHP_FUNCTION(qobject_cast);
 PHP_FUNCTION(tr);
 PHP_FUNCTION(check_qobject);

Modified: trunk/tests/qFunctions.php
===================================================================
--- trunk/tests/qFunctions.php	2007-05-30 20:50:45 UTC (rev 323)
+++ trunk/tests/qFunctions.php	2007-05-31 05:37:32 UTC (rev 324)
@@ -40,7 +40,65 @@
 class test {}
 echo "qPrintable(new test) = ".qPrintable(new test)."\n";
 
-echo "\nTesting qDebug:\n";
+echo "\nTesting qFuzzyCompare:\n";
+echo "qFuzzyCompare(4.0000000000001,4) = ";
+if(qFuzzyCompare(4.0000000000001,4))
+	echo "TRUE\n";
+else
+	echo "FALSE\n";
+echo "qFuzzyCompare(4.1,4) = ";
+if(qFuzzyCompare(4.1,4))
+	        echo "TRUE\n";
+else
+	        echo "FALSE\n";
+
+echo "\nTesting qVersion:\n";
+echo "qVersion() = ".qVersion()."\n";
+
+echo "\nTesting PHPQtVersion:\n";
+echo "PHPQtVersion() = ".PHPQtVersion()."\n";
+
+echo "\nTesting QiDiVersion:\n";
+echo "QiDiVersion() = ".QiDiVersion()."\n";
+
+echo "\nTesting qMalloc:\n";
+print_r(var_dump(qMalloc(10)));
+echo "\n";
+
+echo "\nTesting qFree:\n";
+echo "a = 5...";
+$a = 5;
+qFree($a);
+if(isset($a))
+	echo "qFree failed\n";
+else
+	echo "a succsessfully freed\n";
+
+echo "\nTesting qMemCopy:\n";
+echo "a='abcdefg'\n";
+echo "b=222.34\n";
+echo 'qMemCopy($b,$a,2)=';
+$a = "abcdefg";
+$b = 222.34;
+qMemCopy($b,$a,2);
+echo $b."\n";
+echo "a=333333\n";
+echo "b=222\n";
+echo 'qMemCopy($b,$a,2)=';
+$a = 333333;
+$b = 222;
+qMemCopy($b,$a,2);
+echo $b."\n";
+echo "a=3.33333\n";
+echo "b=222.56\n";
+echo 'qMemCopy($b,$a,2)=';
+$a = 3.33333;
+$b = 222.56;
+qMemCopy($b,$a,2);
+echo $b."\n";
+
+
+/*echo "\nTesting qDebug:\n";
 qDebug("This is a debug message");
 
 echo "Testing qWarning:\n";
@@ -48,5 +106,5 @@
 
 echo "Testing qCritical:\n";
 qCritical("This is a fatal error");
-
+ */
 ?>



